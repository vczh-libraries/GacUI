/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "GacUIReflection.h"

/***********************************************************************
GUIINSTANCEHELPERTYPES.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace helper_types
		{
		}
	}

#ifndef VCZH_DEBUG_NO_REFLECTION

	namespace reflection
	{
		namespace description
		{
			using namespace presentation::helper_types;

/***********************************************************************
Type Declaration
***********************************************************************/

			GUIREFLECTIONHELPERTYPES_TYPELIST(IMPL_VL_TYPE_INFO)

#define _ ,

			BEGIN_STRUCT_MEMBER(SiteValue)
				STRUCT_MEMBER(row)
				STRUCT_MEMBER(column)
				STRUCT_MEMBER(rowSpan)
				STRUCT_MEMBER(columnSpan)
			END_STRUCT_MEMBER(SiteValue)

			BEGIN_ENUM_ITEM(ListViewViewType)
				ENUM_ITEM_NAMESPACE(ListViewViewType)
				ENUM_NAMESPACE_ITEM(BigIcon)
				ENUM_NAMESPACE_ITEM(SmallIcon)
				ENUM_NAMESPACE_ITEM(List)
				ENUM_NAMESPACE_ITEM(Tile)
				ENUM_NAMESPACE_ITEM(Information)
				ENUM_NAMESPACE_ITEM(Detail)
			END_ENUM_ITEM(ListViewViewType)

#undef _
		}
	}

	namespace presentation
	{
		using namespace reflection::description;
		using namespace controls;

/***********************************************************************
Type Loader
***********************************************************************/

		class GuiHelperTypesLoader : public Object, public ITypeLoader
		{
		public:
			void Load(ITypeManager* manager)
			{
				GUIREFLECTIONHELPERTYPES_TYPELIST(ADD_TYPE_INFO)
			}

			void Unload(ITypeManager* manager)
			{
			}
		};

/***********************************************************************
GuiHelperTypesLoaderPlugin
***********************************************************************/

		class GuiHelperTypesLoaderPlugin : public Object, public IGuiPlugin
		{
		public:
			void Load()override
			{
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiHelperTypesLoader;
					manager->AddTypeLoader(loader);
				}
			}

			void AfterLoad()override
			{
			}

			void Unload()override
			{
			}
		};
		GUI_REGISTER_PLUGIN(GuiHelperTypesLoaderPlugin)
	}
#endif
}

/***********************************************************************
GUIINSTANCELOADER.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace parsing;
		using namespace parsing::xml;
		using namespace parsing::tabling;
		using namespace controls;
		using namespace regex;
		using namespace reflection::description;
		using namespace stream;

/***********************************************************************
GuiInstancePropertyInfo
***********************************************************************/

		GuiInstancePropertyInfo::GuiInstancePropertyInfo()
			:support(NotSupport)
			, tryParent(false)
			, required(false)
			, scope(Property)
		{
		}

		GuiInstancePropertyInfo::~GuiInstancePropertyInfo()
		{
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Unsupported()
		{
			return new GuiInstancePropertyInfo;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Assign(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = new GuiInstancePropertyInfo;
			info->support = SupportAssign;
			if (typeDescriptor) info->acceptableTypes.Add(typeDescriptor);
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::AssignWithParent(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = Assign(typeDescriptor);
			info->tryParent = true;
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Collection(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = Assign(typeDescriptor);
			info->support = SupportCollection;
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::CollectionWithParent(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = Collection(typeDescriptor);
			info->tryParent = true;
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Set(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = new GuiInstancePropertyInfo;
			info->support = SupportSet;
			if (typeDescriptor) info->acceptableTypes.Add(typeDescriptor);
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Array(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = new GuiInstancePropertyInfo;
			info->support = SupportArray;
			if (typeDescriptor) info->acceptableTypes.Add(typeDescriptor);
			return info;
		}

/***********************************************************************
GuiInstanceEventInfo
***********************************************************************/

		GuiInstanceEventInfo::GuiInstanceEventInfo()
			:support(NotSupport)
			, argumentType(0)
		{
		}

		GuiInstanceEventInfo::~GuiInstanceEventInfo()
		{
		}

		Ptr<GuiInstanceEventInfo> GuiInstanceEventInfo::Unsupported()
		{
			return new GuiInstanceEventInfo;
		}

		Ptr<GuiInstanceEventInfo> GuiInstanceEventInfo::Assign(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstanceEventInfo> info = new GuiInstanceEventInfo;
			info->support = SupportAssign;
			info->argumentType = typeDescriptor;
			return info;
		}

/***********************************************************************
IGuiInstanceLoader
***********************************************************************/

		bool IGuiInstanceLoader::IsDeserializable(const TypeInfo& typeInfo)
		{
			return false;
		}

		description::Value IGuiInstanceLoader::Deserialize(const TypeInfo& typeInfo, const WString& text)
		{
			return Value();
		}

		bool IGuiInstanceLoader::IsCreatable(const TypeInfo& typeInfo)
		{
			return false;
		}

		description::Value IGuiInstanceLoader::CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)
		{
			return Value();
		}

		bool IGuiInstanceLoader::IsInitializable(const TypeInfo& typeInfo)
		{
			return false;
		}

		Ptr<GuiInstanceContextScope> IGuiInstanceLoader::InitializeInstance(const TypeInfo& typeInfo, description::Value instance)
		{
			return 0;
		}

		void IGuiInstanceLoader::GetPropertyNames(const TypeInfo& typeInfo, List<GlobalStringKey>& propertyNames)
		{
		}

		void IGuiInstanceLoader::GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)
		{
		}

		Ptr<GuiInstancePropertyInfo> IGuiInstanceLoader::GetPropertyType(const PropertyInfo& propertyInfo)
		{
			return 0;
		}

		bool IGuiInstanceLoader::GetPropertyValue(PropertyValue& propertyValue)
		{
			return false;
		}

		bool IGuiInstanceLoader::SetPropertyValue(PropertyValue& propertyValue)
		{
			return false;
		}

		void IGuiInstanceLoader::GetEventNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& eventNames)
		{
		}

		Ptr<GuiInstanceEventInfo> IGuiInstanceLoader::GetEventType(const PropertyInfo& eventInfo)
		{
			return 0;
		}

		bool IGuiInstanceLoader::SetEventValue(PropertyValue& propertyValue)
		{
			return false;
		}

/***********************************************************************
GuiInstanceContext::ElementName Parser
***********************************************************************/

		class GuiInstanceContextElementNameParser : public Object, public IGuiParser<GuiInstanceContext::ElementName>
		{
			typedef GuiInstanceContext::ElementName			ElementName;
		public:
			Regex						regexElementName;

			GuiInstanceContextElementNameParser()
				:regexElementName(L"((<namespaceName>[a-zA-Z_]/w*):)?((<category>[a-zA-Z_]/w*).)?(<name>[a-zA-Z_]/w*)(-(<binding>[a-zA-Z_]/w*))?")
			{
			}

			Ptr<ElementName> TypedParse(const WString& text, collections::List<WString>& errors)override
			{
				Ptr<RegexMatch> match = regexElementName.MatchHead(text);
				if (!match || match->Result().Length() != text.Length())
				{
					errors.Add(L"Failed to parse an element name \"" + text + L"\".");
					return 0;
				}

				Ptr<ElementName> elementName = new ElementName;
				if (match->Groups().Keys().Contains(L"namespaceName"))
				{
					elementName->namespaceName = match->Groups()[L"namespaceName"][0].Value();
				}
				if (match->Groups().Keys().Contains(L"category"))
				{
					elementName->category = match->Groups()[L"category"][0].Value();
				}
				if (match->Groups().Keys().Contains(L"name"))
				{
					elementName->name = match->Groups()[L"name"][0].Value();
				}
				if (match->Groups().Keys().Contains(L"binding"))
				{
					elementName->binding = match->Groups()[L"binding"][0].Value();
				}
				return elementName;
			}
		};

/***********************************************************************
GuiDefaultInstanceLoader
***********************************************************************/

		class GuiDefaultInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			typedef Tuple<ITypeDescriptor*, GlobalStringKey>				FieldKey;
			typedef Tuple<Ptr<GuiInstancePropertyInfo>, IPropertyInfo*>		PropertyType;
			typedef Tuple<Ptr<GuiInstanceEventInfo>, IEventInfo*>			EventType;

			Dictionary<FieldKey, PropertyType>								propertyTypes;
			Dictionary<FieldKey, EventType>									eventTypes;

		public:
			static IMethodInfo* GetDefaultConstructor(ITypeDescriptor* typeDescriptor)
			{
				if (auto ctors = typeDescriptor->GetConstructorGroup())
				{
					vint count = ctors->GetMethodCount();
					for (vint i = 0; i < count; i++)
					{
						IMethodInfo* method = ctors->GetMethod(i);
						if (method->GetParameterCount() == 0)
						{
							return method;
						}
					}
				}
				return 0;
			}

			GlobalStringKey GetTypeName()override
			{
				return GlobalStringKey::Empty;
			}

			//***********************************************************************************

			bool IsDeserializable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeDescriptor->GetValueSerializer() != 0;
			}

			description::Value Deserialize(const TypeInfo& typeInfo, const WString& text)override
			{
				if (IValueSerializer* serializer = typeInfo.typeDescriptor->GetValueSerializer())
				{
					Value loadedValue;
					if (serializer->Parse(text, loadedValue))
					{
						return loadedValue;
					}
				}
				return Value();
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return GetDefaultConstructor(typeInfo.typeDescriptor) != 0;
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (IMethodInfo* method = GetDefaultConstructor(typeInfo.typeDescriptor))
				{
					return method->Invoke(Value(), (Value_xs()));
				}
				else
				{
					env->scope->errors.Add(L"Failed to create \"" + typeInfo.typeName.ToString() + L"\" because no there is no default constructor.");
					return Value();
				}
			}

			bool IsInitializable(const TypeInfo& typeInfo)override
			{
				return false;
			}

			Ptr<GuiInstanceContextScope> InitializeInstance(const TypeInfo& typeInfo, description::Value instance)override
			{
				return 0;
			}

			//***********************************************************************************

			void ProcessGenericType(ITypeInfo* propType, ITypeInfo*& genericType, ITypeInfo*& elementType, bool& readableList, bool& writableList, bool& collectionType)
			{
				genericType = 0;
				elementType = 0;
				readableList = false;
				writableList = false;
				collectionType = false;
				if (propType->GetDecorator() == ITypeInfo::SharedPtr && propType->GetElementType()->GetDecorator() == ITypeInfo::Generic)
				{
					propType = propType->GetElementType();
					genericType = propType->GetElementType();
					if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
					{
						elementType = propType->GetGenericArgument(0);
						readableList = true;
						writableList = true;
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerator>())
					{
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>())
					{
						elementType = propType->GetGenericArgument(0);
						readableList = true;
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
					{
						elementType = propType->GetGenericArgument(0);
						readableList = true;
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
					{
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
					{
						collectionType = true;
					}
				}
			}

			ITypeInfo* GetPropertyReflectionTypeInfo(const PropertyInfo& propertyInfo, GuiInstancePropertyInfo::Support& support)
			{
				support = GuiInstancePropertyInfo::NotSupport;
				IPropertyInfo* prop = propertyInfo.typeInfo.typeDescriptor->GetPropertyByName(propertyInfo.propertyName.ToString(), true);
				if (prop)
				{
					ITypeInfo* propType = prop->GetReturn();
					ITypeInfo* genericType = 0;
					ITypeInfo* elementType = 0;
					bool readableList = false;
					bool writableList = false;
					bool collectionType = false;
					ProcessGenericType(propType, genericType, elementType, readableList, writableList, collectionType);

					if (prop->IsWritable())
					{
						if (collectionType)
						{
							if (readableList)
							{
								support = GuiInstancePropertyInfo::SupportArray;
								return elementType;
							}
						}
						else if (genericType)
						{
							support = GuiInstancePropertyInfo::SupportAssign;
							return genericType;
						}
						else
						{
							support = GuiInstancePropertyInfo::SupportAssign;
							return propType;
						}
					}
					else if (prop->IsReadable())
					{
						if (collectionType)
						{
							if (writableList)
							{
								support = GuiInstancePropertyInfo::SupportCollection;
								return elementType;
							}
						}
						else if (!genericType)
						{
							if (propType->GetDecorator() == ITypeInfo::SharedPtr || propType->GetDecorator() == ITypeInfo::RawPtr)
							{
								support = GuiInstancePropertyInfo::SupportSet;
								return propType;
							}
						}
					}
				}
				return 0;
			}

			bool FillPropertyInfo(Ptr<GuiInstancePropertyInfo> propertyInfo, ITypeInfo* propType)
			{
				switch (propType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					FillPropertyInfo(propertyInfo, propType->GetElementType());
					return true;
				case ITypeInfo::TypeDescriptor:
					propertyInfo->acceptableTypes.Add(propType->GetTypeDescriptor());
					return true;
				default:;
				}
				return false;
			}

			void CollectPropertyNames(const TypeInfo& typeInfo, ITypeDescriptor* typeDescriptor, collections::List<GlobalStringKey>& propertyNames)
			{
				vint propertyCount = typeDescriptor->GetPropertyCount();
				for (vint i = 0; i < propertyCount; i++)
				{
					GlobalStringKey propertyName = GlobalStringKey::Get(typeDescriptor->GetProperty(i)->GetName());
					if (!propertyNames.Contains(propertyName))
					{
						auto info = GetPropertyType(PropertyInfo(typeInfo, propertyName));
						if (info && info->support != GuiInstancePropertyInfo::NotSupport)
						{
							propertyNames.Add(propertyName);
						}
					}
				}

				vint parentCount = typeDescriptor->GetBaseTypeDescriptorCount();
				for (vint i = 0; i < parentCount; i++)
				{
					CollectPropertyNames(typeInfo, typeDescriptor->GetBaseTypeDescriptor(i), propertyNames);
				}
			}

			bool ContainsViewModels(const TypeInfo& typeInfo)
			{
				if (auto ctors = typeInfo.typeDescriptor->GetConstructorGroup())
				{
					if (ctors->GetMethodCount() == 1)
					{
						IMethodInfo* method = ctors->GetMethod(0);
						vint count = method->GetParameterCount();
						for (vint i = 0; i < count; i++)
						{
							auto parameter = method->GetParameter(i);
							auto prop = typeInfo.typeDescriptor->GetPropertyByName(parameter->GetName(), false);
							if (!prop || !prop->GetGetter() || prop->GetSetter() || prop->GetValueChangedEvent()) return false;
							if (parameter->GetType()->GetTypeFriendlyName() != prop->GetReturn()->GetTypeFriendlyName()) return false;
						}
						return true;
					}
				}
				return false;
			}

			//***********************************************************************************

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				CollectPropertyNames(typeInfo, typeInfo.typeDescriptor, propertyNames);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (ContainsViewModels(typeInfo))
				{
					IMethodInfo* method = typeInfo.typeDescriptor->GetConstructorGroup()->GetMethod(0);
					vint count = method->GetParameterCount();
					for (vint i = 0; i < count; i++)
					{
						propertyNames.Add(GlobalStringKey::Get(method->GetParameter(i)->GetName()));
					}
				}
			}

			PropertyType GetPropertyTypeCached(const PropertyInfo& propertyInfo)
			{
				FieldKey key(propertyInfo.typeInfo.typeDescriptor, propertyInfo.propertyName);
				vint index = propertyTypes.Keys().IndexOf(key);
				if (index == -1)
				{
					GuiInstancePropertyInfo::Support support = GuiInstancePropertyInfo::NotSupport;
					if (ITypeInfo* propType = GetPropertyReflectionTypeInfo(propertyInfo, support))
					{
						Ptr<GuiInstancePropertyInfo> result = new GuiInstancePropertyInfo;
						result->support = support;

						if (ContainsViewModels(propertyInfo.typeInfo))
						{
							IMethodInfo* method = propertyInfo.typeInfo.typeDescriptor->GetConstructorGroup()->GetMethod(0);
							vint count = method->GetParameterCount();
							for (vint i = 0; i < count; i++)
							{
								if (method->GetParameter(i)->GetName() == propertyInfo.propertyName.ToString())
								{
									result->scope = GuiInstancePropertyInfo::ViewModel;
								}
							}
						}

						if (FillPropertyInfo(result, propType))
						{
							IPropertyInfo* prop = propertyInfo.typeInfo.typeDescriptor->GetPropertyByName(propertyInfo.propertyName.ToString(), true);
							PropertyType value(result, prop);
							propertyTypes.Add(key, value);
							return value;
						}
					}
					
					PropertyType value(GuiInstancePropertyInfo::Unsupported(), 0);
					propertyTypes.Add(key, value);
					return value;
				}
				else
				{
					return propertyTypes.Values()[index];
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				return GetPropertyTypeCached(propertyInfo).f0;
			}

			bool GetPropertyValue(PropertyValue& propertyValue)override
			{
				if (IPropertyInfo* prop = GetPropertyTypeCached(propertyValue).f1)
				{
					if (prop->IsReadable())
					{
						propertyValue.propertyValue = prop->GetValue(propertyValue.instanceValue);
						return true;
					}
				}
				return false;
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				PropertyType propertyType = GetPropertyTypeCached(propertyValue);
				if (propertyType.f1)
				{
					switch (propertyType.f0->support)
					{
					case GuiInstancePropertyInfo::SupportCollection:
						{
							Value value = propertyType.f1->GetValue(propertyValue.instanceValue);
							if (auto list = dynamic_cast<IValueList*>(value.GetRawPtr()))
							{
								list->Add(propertyValue.propertyValue);
								return true;
							}
						}
						break;
					case GuiInstancePropertyInfo::SupportAssign:
					case GuiInstancePropertyInfo::SupportArray:
						propertyValue.instanceValue.SetProperty(propertyValue.propertyName.ToString(), propertyValue.propertyValue);
						propertyType.f1->SetValue(propertyValue.instanceValue, propertyValue.propertyValue);
						return true;
					default:;
					}
				}
				return false;
			}

			//***********************************************************************************

			void CollectEventNames(const TypeInfo& typeInfo, ITypeDescriptor* typeDescriptor, collections::List<GlobalStringKey>& eventNames)
			{
				vint eventCount = typeDescriptor->GetEventCount();
				for (vint i = 0; i < eventCount; i++)
				{
					GlobalStringKey eventName = GlobalStringKey::Get(typeDescriptor->GetEvent(i)->GetName());
					if (!eventNames.Contains(eventName))
					{
						auto info = GetEventType(PropertyInfo(typeInfo, eventName));
						if (info && info->support != GuiInstanceEventInfo::NotSupport)
						{
							eventNames.Add(eventName);
						}
					}
				}

				vint parentCount = typeDescriptor->GetBaseTypeDescriptorCount();
				for (vint i = 0; i < parentCount; i++)
				{
					CollectEventNames(typeInfo, typeDescriptor->GetBaseTypeDescriptor(i), eventNames);
				}
			}

			//***********************************************************************************

			void GetEventNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& eventNames)override
			{
				CollectEventNames(typeInfo, typeInfo.typeDescriptor, eventNames);
			}

			EventType GetEventTypeCached(const PropertyInfo& eventInfo)
			{
				FieldKey key(eventInfo.typeInfo.typeDescriptor, eventInfo.propertyName);
				vint index = eventTypes.Keys().IndexOf(key);
				if (index == -1)
				{
					if (IEventInfo* ev = eventInfo.typeInfo.typeDescriptor->GetEventByName(eventInfo.propertyName.ToString(), true))
					{
#ifndef VCZH_DEBUG_NO_REFLECTION
						ITypeInfo	*handlerType = 0,
									*genericType = 0,
									*functionType = 0,
									*returnType = 0,
									*senderType = 0,
									*argumentType = 0;

						handlerType = ev->GetHandlerType();
						if (handlerType->GetDecorator() != ITypeInfo::SharedPtr) goto UNSUPPORTED;

						genericType = handlerType->GetElementType();
						if (genericType->GetDecorator() != ITypeInfo::Generic) goto UNSUPPORTED;

						functionType = genericType->GetElementType();
						if (functionType->GetDecorator() != ITypeInfo::TypeDescriptor) goto UNSUPPORTED;
						if (functionType->GetTypeDescriptor() != description::GetTypeDescriptor<IValueFunctionProxy>()) goto UNSUPPORTED;

						if (genericType->GetGenericArgumentCount() != 3) goto UNSUPPORTED;
						returnType = genericType->GetGenericArgument(0);
						senderType = genericType->GetGenericArgument(1);
						argumentType = genericType->GetGenericArgument(2);
					
						if (returnType->GetDecorator() != ITypeInfo::TypeDescriptor) goto UNSUPPORTED;
						if (returnType->GetTypeDescriptor() != description::GetTypeDescriptor<VoidValue>()) goto UNSUPPORTED;
					
						if (senderType->GetDecorator() != ITypeInfo::RawPtr) goto UNSUPPORTED;
						senderType = senderType->GetElementType();
						if (senderType->GetDecorator() != ITypeInfo::TypeDescriptor) goto UNSUPPORTED;
						if (senderType->GetTypeDescriptor() != description::GetTypeDescriptor<compositions::GuiGraphicsComposition>()) goto UNSUPPORTED;
					
						if (argumentType->GetDecorator() != ITypeInfo::RawPtr) goto UNSUPPORTED;
						argumentType = argumentType->GetElementType();
						if (argumentType->GetDecorator() != ITypeInfo::TypeDescriptor) goto UNSUPPORTED;
						if (!argumentType->GetTypeDescriptor()->CanConvertTo(description::GetTypeDescriptor<compositions::GuiEventArgs>())) goto UNSUPPORTED;

						{
							auto result = GuiInstanceEventInfo::Assign(argumentType->GetTypeDescriptor());
							EventType value(result, ev);
							eventTypes.Add(key, value);
							return value;
						}
					UNSUPPORTED:
						{
							auto result = GuiInstanceEventInfo::Unsupported();
							EventType value(result, ev);
							eventTypes.Add(key, value);
							return value;
						}
#endif
					}

					EventType value(0, 0);
					eventTypes.Add(key, value);
					return value;
				}
				else
				{
					return eventTypes.Values()[index];
				}
			}

			Ptr<GuiInstanceEventInfo> GetEventType(const PropertyInfo& eventInfo)override
			{
				return GetEventTypeCached(eventInfo).f0;
			}

			bool SetEventValue(PropertyValue& propertyValue)override
			{
				EventType eventType = GetEventTypeCached(propertyValue);
				if (eventType.f0 && eventType.f0->support == GuiInstanceEventInfo::SupportAssign)
				{
					Ptr<IValueFunctionProxy> proxy=UnboxValue<Ptr<IValueFunctionProxy>>(propertyValue.propertyValue, Description<IValueFunctionProxy>::GetAssociatedTypeDescriptor(), L"function");
					eventType.f1->Attach(propertyValue.instanceValue, proxy);
					return true;
				}
				return false;
			}
		};

/***********************************************************************
GuiResourceInstanceLoader
***********************************************************************/

		class GuiResourceInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			Ptr<GuiResource>						resource;
			Ptr<GuiInstanceContext>					context;
			GlobalStringKey							contextClassName;

			void InitializeContext(Ptr<GuiResourcePathResolver> resolver, List<WString>& errors)
			{
				context->ApplyStyles(resolver, errors);
			}
		public:
			GuiResourceInstanceLoader(Ptr<GuiResource> _resource, Ptr<GuiInstanceContext> _context)
				:resource(_resource)
				, context(_context)
			{
				if (context->className)
				{
					contextClassName = GlobalStringKey::Get(context->className.Value());
				}
			}

			GlobalStringKey GetTypeName()override
			{
				return contextClassName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == contextClassName;
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == contextClassName)
				{
					if (auto typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(typeInfo.typeName.ToString()))
					{
						InitializeContext(env->resolver, env->scope->errors);
						SortedList<GlobalStringKey> argumentNames;
						{
							List<GlobalStringKey> names;
							GetConstructorParameters(typeInfo, names);
							CopyFrom(argumentNames, names);
						}
						auto group = typeDescriptor->GetConstructorGroup();
						for (vint i = 0; i < group->GetMethodCount(); i++)
						{
							auto method = group->GetMethod(i);
							List<GlobalStringKey> parameterNames;
							for (vint j = 0; j < method->GetParameterCount(); j++)
							{
								parameterNames.Add(GlobalStringKey::Get(method->GetParameter(j)->GetName()));
							}

							auto f = [](GlobalStringKey a, GlobalStringKey b){return GlobalStringKey::Compare(a, b); };
							if (CompareEnumerable(argumentNames, From(parameterNames).OrderBy(f)) == 0)
							{
								Array<Value> arguments(constructorArguments.Count());
								for (vint j = 0; j < arguments.Count(); j++)
								{
									arguments[j] = constructorArguments[parameterNames[j]][0];
								}
								Value result = method->Invoke(Value(), arguments);

								if (auto partialClass = dynamic_cast<IGuiInstancePartialClass*>(result.GetRawPtr()))
								{
									if (auto partialScope = partialClass->GetScope())
									{
										CopyFrom(env->scope->errors, partialScope->errors, true);
									}
								}
								return result;
							}
						}
					}

					Ptr<GuiResourcePathResolver> resolver = new GuiResourcePathResolver(resource, resource->GetWorkingDirectory());
					auto scope = LoadInstanceFromContext(context, resolver);

					if (scope)
					{
						CopyFrom(env->scope->errors, scope->errors, true);
						return scope->rootInstance;
					}
				}
				return Value();
			}

			bool IsInitializable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == contextClassName;
			}

			Ptr<GuiInstanceContextScope> InitializeInstance(const TypeInfo& typeInfo, description::Value instance)override
			{
				if (typeInfo.typeName == contextClassName)
				{
					Ptr<GuiResourcePathResolver> resolver = new GuiResourcePathResolver(resource, resource->GetWorkingDirectory());
					List<WString> errors;
					InitializeContext(resolver, errors);

					auto scope = InitializeInstanceFromContext(context, resolver, instance);
					if (scope)
					{
						for (vint i = 0; i < errors.Count(); i++)
						{
							scope->errors.Insert(i, errors[i]);
						}
					}
					return scope;
				}
				return 0;
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)
			{
				if (typeInfo.typeName == contextClassName)
				{
					FOREACH(Ptr<GuiInstanceParameter>, parameter, context->parameters)
					{
						if (description::GetTypeDescriptor(parameter->className.ToString()))
						{
							propertyNames.Add(parameter->name);
						}
					}
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)
			{
				if (propertyInfo.typeInfo.typeName == contextClassName)
				{
					FOREACH(Ptr<GuiInstanceParameter>, parameter, context->parameters)
					{
						if (parameter->name == propertyInfo.propertyName)
						{
							if (auto td = description::GetTypeDescriptor(parameter->className.ToString()))
							{
								auto info = GuiInstancePropertyInfo::Assign(td);
								info->required = true;
								info->scope = GuiInstancePropertyInfo::ViewModel;
								return info;
							}
						}
					}
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}
		};

/***********************************************************************
GuiInstanceLoaderManager
***********************************************************************/

		IGuiInstanceLoaderManager* instanceLoaderManager = 0;

		IGuiInstanceLoaderManager* GetInstanceLoaderManager()
		{
			return instanceLoaderManager;
		}

		class GuiInstanceLoaderManager : public Object, public IGuiInstanceLoaderManager, public IGuiPlugin
		{
		protected:
			typedef Dictionary<GlobalStringKey, Ptr<IGuiInstanceBinder>>				BinderMap;
			typedef Dictionary<GlobalStringKey, Ptr<IGuiInstanceEventBinder>>			EventBinderMap;
			typedef Dictionary<GlobalStringKey, Ptr<IGuiInstanceBindingContextFactory>>	BindingContextFactoryMap;

			struct VirtualTypeInfo
			{
				GlobalStringKey						typeName;
				ITypeDescriptor*					typeDescriptor;
				GlobalStringKey						parentTypeName;				// for virtual type only
				Ptr<IGuiInstanceLoader>				loader;

				List<ITypeDescriptor*>				parentTypes;				// all direct or indirect base types that does not has a type info
				List<VirtualTypeInfo*>				parentTypeInfos;			// type infos for all registered direct or indirect base types

				VirtualTypeInfo()
					:typeDescriptor(0)
				{
				}
			};
			typedef Dictionary<GlobalStringKey, Ptr<VirtualTypeInfo>>					VirtualTypeInfoMap;
			typedef Dictionary<WString, Ptr<GuiResource>>								ResourceMap;

			Ptr<IGuiInstanceLoader>					rootLoader;
			BinderMap								binders;
			EventBinderMap							eventBinders;
			BindingContextFactoryMap				bindingContextFactories;
			VirtualTypeInfoMap						typeInfos;
			ResourceMap								resources;

			bool IsTypeExists(GlobalStringKey name)
			{
				return GetGlobalTypeManager()->GetTypeDescriptor(name.ToString()) != 0 || typeInfos.Keys().Contains(name);
			}

			void FindParentTypeInfos(Ptr<VirtualTypeInfo> typeInfo, ITypeDescriptor* searchType)
			{
				if (searchType != typeInfo->typeDescriptor)
				{
					vint index = typeInfos.Keys().IndexOf(GlobalStringKey::Get(searchType->GetTypeName()));
					if (index == -1)
					{
						typeInfo->parentTypes.Add(searchType);
					}
					else
					{
						typeInfo->parentTypeInfos.Add(typeInfos.Values()[index].Obj());
						return;
					}
				}

				vint count = searchType->GetBaseTypeDescriptorCount();
				for (vint i = 0; i < count; i++)
				{
					ITypeDescriptor* baseType = searchType->GetBaseTypeDescriptor(i);
					FindParentTypeInfos(typeInfo, baseType);
				}
			}

			void FillParentTypeInfos(Ptr<VirtualTypeInfo> typeInfo)
			{
				typeInfo->parentTypes.Clear();
				typeInfo->parentTypeInfos.Clear();

				ITypeDescriptor* searchType = typeInfo->typeDescriptor;
				if (!searchType)
				{
					vint index = typeInfos.Keys().IndexOf(typeInfo->parentTypeName);
					if (index == -1)
					{
						searchType = GetGlobalTypeManager()->GetTypeDescriptor(typeInfo->parentTypeName.ToString());
						typeInfo->typeDescriptor = searchType;
						typeInfo->parentTypes.Add(searchType);
					}
					else
					{
						VirtualTypeInfo* parentTypeInfo = typeInfos.Values()[index].Obj();
						typeInfo->typeDescriptor = parentTypeInfo->typeDescriptor;
						typeInfo->parentTypeInfos.Add(parentTypeInfo);
						return;
					}
				}

				if (searchType)
				{
					FindParentTypeInfos(typeInfo, searchType);
				}
			}

			IGuiInstanceLoader* GetLoaderFromType(ITypeDescriptor* typeDescriptor)
			{
				vint index = typeInfos.Keys().IndexOf(GlobalStringKey::Get(typeDescriptor->GetTypeName()));
				if (index == -1)
				{
					vint count = typeDescriptor->GetBaseTypeDescriptorCount();
					for (vint i = 0; i < count; i++)
					{
						ITypeDescriptor* baseType = typeDescriptor->GetBaseTypeDescriptor(i);
						IGuiInstanceLoader* loader = GetLoaderFromType(baseType);
						if (loader) return loader;
					}
					return 0;
				}
				else
				{
					return typeInfos.Values()[index]->loader.Obj();
				}
			}

			void GetClassesInResource(Ptr<GuiResourceFolder> folder, Dictionary<GlobalStringKey, Ptr<GuiInstanceContext>>& classes)
			{
				FOREACH(Ptr<GuiResourceItem>, item, folder->GetItems())
				{
					if (auto context = item->GetContent().Cast<GuiInstanceContext>())
					{
						if (context->className)
						{
							auto contextClassName = GlobalStringKey::Get(context->className.Value());
							if (!classes.Keys().Contains(contextClassName))
							{
								classes.Add(contextClassName, context);
							}
						}
					}
				}
				FOREACH(Ptr<GuiResourceFolder>, subFolder, folder->GetFolders())
				{
					GetClassesInResource(subFolder, classes);
				}
			}
		public:
			GuiInstanceLoaderManager()
			{
				rootLoader = new GuiDefaultInstanceLoader;
			}

			void Load()override
			{
				instanceLoaderManager = this;
			}

			void AfterLoad()override
			{
				IGuiParserManager* manager = GetParserManager();
				manager->SetParser(L"INSTANCE-ELEMENT-NAME", new GuiInstanceContextElementNameParser);
			}

			void Unload()override
			{
				instanceLoaderManager = 0;
			}

			bool AddInstanceBindingContextFactory(Ptr<IGuiInstanceBindingContextFactory> factory)override
			{
				if (bindingContextFactories.Keys().Contains(factory->GetContextName())) return false;
				bindingContextFactories.Add(factory->GetContextName(), factory);
				return true;
			}

			IGuiInstanceBindingContextFactory* GetInstanceBindingContextFactory(GlobalStringKey contextName)override
			{
				vint index = bindingContextFactories.Keys().IndexOf(contextName);
				return index == -1 ? 0 : bindingContextFactories.Values()[index].Obj();
			}

			bool AddInstanceBinder(Ptr<IGuiInstanceBinder> binder)override
			{
				if (binders.Keys().Contains(binder->GetBindingName())) return false;
				binders.Add(binder->GetBindingName(), binder);
				return true;
			}

			IGuiInstanceBinder* GetInstanceBinder(GlobalStringKey bindingName)override
			{
				vint index = binders.Keys().IndexOf(bindingName);
				return index == -1 ? 0 : binders.Values()[index].Obj();
			}

			bool AddInstanceEventBinder(Ptr<IGuiInstanceEventBinder> binder)override
			{
				if (eventBinders.Keys().Contains(binder->GetBindingName())) return false;
				eventBinders.Add(binder->GetBindingName(), binder);
				return true;
			}

			IGuiInstanceEventBinder* GetInstanceEventBinder(GlobalStringKey bindingName)override
			{
				vint index = eventBinders.Keys().IndexOf(bindingName);
				return index == -1 ? 0 : eventBinders.Values()[index].Obj();
			}

			bool CreateVirtualType(GlobalStringKey parentType, Ptr<IGuiInstanceLoader> loader)override
			{
				if (IsTypeExists(loader->GetTypeName()) || !IsTypeExists(parentType)) return false;

				Ptr<VirtualTypeInfo> typeInfo = new VirtualTypeInfo;
				typeInfo->typeName = loader->GetTypeName();
				typeInfo->parentTypeName = parentType;
				typeInfo->loader = loader;
				typeInfos.Add(loader->GetTypeName(), typeInfo);
				FillParentTypeInfos(typeInfo);

				return true;
			}

			bool SetLoader(Ptr<IGuiInstanceLoader> loader)override
			{
				vint index = typeInfos.Keys().IndexOf(loader->GetTypeName());
				if (index != -1) return false;

				ITypeDescriptor* typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(loader->GetTypeName().ToString());
				if (typeDescriptor == 0) return false;

				Ptr<VirtualTypeInfo> typeInfo = new VirtualTypeInfo;
				typeInfo->typeName = loader->GetTypeName();
				typeInfo->typeDescriptor = typeDescriptor;
				typeInfo->loader = loader;
				typeInfos.Add(typeInfo->typeName, typeInfo);
				FillParentTypeInfos(typeInfo);

				FOREACH(Ptr<VirtualTypeInfo>, derived, typeInfos.Values())
				{
					if (derived->parentTypes.Contains(typeInfo->typeDescriptor))
					{
						FillParentTypeInfos(derived);
					}
				}

				return true;
			}

			IGuiInstanceLoader* GetLoader(GlobalStringKey typeName)override
			{
				vint index = typeInfos.Keys().IndexOf(typeName);
				if (index != -1)
				{
					return typeInfos.Values()[index]->loader.Obj();
				}

				ITypeDescriptor* typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(typeName.ToString());
				if (typeDescriptor)
				{
					IGuiInstanceLoader* loader = GetLoaderFromType(typeDescriptor);
					return loader ? loader : rootLoader.Obj();
				}
				return 0;
			}

			IGuiInstanceLoader* GetParentLoader(IGuiInstanceLoader* loader)override
			{
				vint index = typeInfos.Keys().IndexOf(loader->GetTypeName());
				if (index != -1)
				{
					Ptr<VirtualTypeInfo> typeInfo = typeInfos.Values()[index];
					if (typeInfo->parentTypeInfos.Count() > 0)
					{
						return typeInfo->parentTypeInfos[0]->loader.Obj();
					}
					return rootLoader.Obj();
				}
				return 0;
			}

			description::ITypeDescriptor* GetTypeDescriptorForType(GlobalStringKey typeName)override
			{
				vint index = typeInfos.Keys().IndexOf(typeName);
				return index == -1
					? GetGlobalTypeManager()->GetTypeDescriptor(typeName.ToString())
					: typeInfos.Values()[index]->typeDescriptor;
			}

			void GetVirtualTypes(collections::List<GlobalStringKey>& typeNames)override
			{
				for (vint i = 0; i < typeInfos.Count(); i++)
				{
					if (typeInfos.Values()[i]->parentTypeName != GlobalStringKey::Empty)
					{
						typeNames.Add(typeInfos.Keys()[i]);
					}
				}
			}

			GlobalStringKey GetParentTypeForVirtualType(GlobalStringKey virtualType)override
			{
				vint index = typeInfos.Keys().IndexOf(virtualType);
				if (index != -1)
				{
					auto typeInfo = typeInfos.Values()[index];
					return typeInfo->parentTypeName;
				}
				return GlobalStringKey::Empty;
			}

			bool SetResource(const WString& name, Ptr<GuiResource> resource)override
			{
				vint index = resources.Keys().IndexOf(name);
				if (index != -1) return false;

				Ptr<GuiResourcePathResolver> resolver = new GuiResourcePathResolver(resource, resource->GetWorkingDirectory());
				Dictionary<GlobalStringKey, Ptr<GuiInstanceContext>> classes;
				Dictionary<GlobalStringKey, GlobalStringKey> parentTypes;
				GetClassesInResource(resource, classes);

				FOREACH(Ptr<GuiInstanceContext>, context, classes.Values())
				{
					auto contextClassName = GlobalStringKey::Get(context->className.Value());
					if (typeInfos.Keys().Contains(contextClassName))
					{
						return false;
					}

					Ptr<GuiInstanceEnvironment> env = new GuiInstanceEnvironment(context, resolver);
					auto loadingSource = FindInstanceLoadingSource(env->context, context->instance.Obj());
					if (loadingSource.loader)
					{
						parentTypes.Add(contextClassName, loadingSource.typeName);
					}
				}
				
				FOREACH(GlobalStringKey, className, classes.Keys())
				{
					auto context = classes[className];
					vint index = parentTypes.Keys().IndexOf(className);
					if (index == -1) continue;
					auto parentType = parentTypes.Values()[index];

					Ptr<IGuiInstanceLoader> loader = new GuiResourceInstanceLoader(resource, context);
					if (GetGlobalTypeManager()->GetTypeDescriptor(context->className.Value()))
					{
						SetLoader(loader);
					}
					else
					{
						CreateVirtualType(parentType, loader);
					}
				}

				resources.Add(name, resource);
				return true;
			}

			Ptr<GuiResource> GetResource(const WString& name)override
			{
				vint index = resources.Keys().IndexOf(name);
				return index == -1 ? nullptr : resources.Values()[index];
			}
		};
		GUI_REGISTER_PLUGIN(GuiInstanceLoaderManager)
	}
}

/***********************************************************************
GUIINSTANCELOADER_LOADINSTANCE.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace reflection::description;

/***********************************************************************
Helper Functions Declarations
***********************************************************************/

		struct FillInstanceBindingSetter
		{
			IGuiInstanceBinder*					binder;
			IGuiInstanceLoader*					loader;
			GuiAttSetterRepr*					bindingTarget;
			IGuiInstanceLoader::PropertyValue	propertyValue;

			FillInstanceBindingSetter()
				:binder(0)
				, loader(0)
				, bindingTarget(0)
			{
			}
		};

		struct FillInstanceEventSetter
		{
			IGuiInstanceEventBinder*			binder;
			IGuiInstanceLoader*					loader;
			GuiAttSetterRepr*					bindingTarget;
			Ptr<GuiInstanceEventInfo>			eventInfo;
			IGuiInstanceLoader::PropertyValue	propertyValue;
			WString								handlerName;

			FillInstanceEventSetter()
				:binder(0)
				, loader(0)
				, bindingTarget(0)
			{
			}
		};

		bool LoadInstancePropertyValue(
			Ptr<GuiInstanceEnvironment> env,
			GuiAttSetterRepr* attSetter,
			GlobalStringKey binding,
			IGuiInstanceLoader::PropertyValue propertyValue,
			List<Ptr<GuiValueRepr>>& input,
			IGuiInstanceLoader* propertyLoader,
			bool constructorArgument,
			List<Pair<Value, IGuiInstanceLoader*>>& output,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters
			);

		void FillInstance(
			description::Value createdInstance,
			Ptr<GuiInstanceEnvironment> env,
			GuiAttSetterRepr* attSetter,
			IGuiInstanceLoader* loader,
			bool skipDefaultProperty,
			GlobalStringKey typeName,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters
			);

		description::Value CreateInstance(
			Ptr<GuiInstanceEnvironment> env,
			GuiConstructorRepr* ctor,
			description::ITypeDescriptor* expectedType,
			GlobalStringKey& typeName,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters,
			bool isRootInstance
			);

		void ExecuteParameters(
			Ptr<GuiInstanceEnvironment> env
			);

		bool PrepareBindingContext(
			Ptr<GuiInstanceEnvironment> env,
			collections::List<GlobalStringKey>& contextNames,
			const WString& dependerType,
			const GlobalStringKey& dependerName
			);

		void ExecuteBindingSetters(
			Ptr<GuiInstanceEnvironment> env,
			List<FillInstanceBindingSetter>& bindingSetters
			);

		void ExecuteEventSetters(
			description::Value createdInstance,
			Ptr<GuiInstanceEnvironment> env,
			List<FillInstanceEventSetter>& eventSetters
			);

		void InitializeInstanceFromConstructor(
			Ptr<GuiInstanceEnvironment> env,
			GuiConstructorRepr* ctor,
			IGuiInstanceLoader* instanceLoader,
			GlobalStringKey typeName,
			description::Value instance,
			bool deserialized,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters
			);

		namespace visitors
		{

/***********************************************************************
LoadValueVisitor
***********************************************************************/

			class LoadValueVisitor : public Object, public GuiValueRepr::IVisitor
			{
			public:
				Ptr<GuiInstanceEnvironment>				env;
				List<ITypeDescriptor*>&					acceptableTypes;
				List<FillInstanceBindingSetter>&		bindingSetters;
				List<FillInstanceEventSetter>&			eventSetters;
				bool									result;
				Value									loadedValue;

				LoadValueVisitor(Ptr<GuiInstanceEnvironment> _env, List<ITypeDescriptor*>& _acceptableTypes, List<FillInstanceBindingSetter>& _bindingSetters, List<FillInstanceEventSetter>& _eventSetters)
					:env(_env)
					, acceptableTypes(_acceptableTypes)
					, bindingSetters(_bindingSetters)
					, eventSetters(_eventSetters)
					, result(false)
				{
				}

				void Visit(GuiTextRepr* repr)override
				{
					FOREACH(ITypeDescriptor*, typeDescriptor, acceptableTypes)
					{
						if (IValueSerializer* serializer = typeDescriptor->GetValueSerializer())
						{
							if (serializer->Parse(repr->text, loadedValue))
							{
								result = true;
								return;
							}
						}
					}
					
					FOREACH(ITypeDescriptor*, typeDescriptor, acceptableTypes)
					{
						env->scope->errors.Add(
							L"Failed to deserialize object of type \"" +
							typeDescriptor->GetTypeName() +
							L"\" from string \"" +
							repr->text +
							L"\".");
					}
				}

				void Visit(GuiAttSetterRepr* repr)override
				{
				}

				void Visit(GuiConstructorRepr* repr)override
				{
					vint errorCount = env->scope->errors.Count();
					FOREACH(ITypeDescriptor*, typeDescriptor, acceptableTypes)
					{
						GlobalStringKey _typeName;
						loadedValue = CreateInstance(env, repr, typeDescriptor, _typeName, bindingSetters, eventSetters, false);
						if (!loadedValue.IsNull())
						{
							for (vint i = env->scope->errors.Count() - 1; i >= errorCount; i--)
							{
								if (wcsstr(env->scope->errors[i].Buffer(), L"because the expected type is"))
								{
									env->scope->errors.RemoveAt(i);
								}
							}
							result = true;
							return;
						}
					}
				}

				static bool LoadValue(Ptr<GuiValueRepr> valueRepr, Ptr<GuiInstanceEnvironment> env, List<ITypeDescriptor*>& acceptableTypes, List<FillInstanceBindingSetter>& bindingSetters, List<FillInstanceEventSetter>& eventSetters, Value& loadedValue)
				{
					LoadValueVisitor visitor(env, acceptableTypes, bindingSetters, eventSetters);
					valueRepr->Accept(&visitor);
					if (visitor.result)
					{
						loadedValue = visitor.loadedValue;
					}
					return visitor.result;
				}
			};

		}
		using namespace visitors;

/***********************************************************************
FindInstanceLoadingSource
***********************************************************************/

		InstanceLoadingSource FindInstanceLoadingSource(
			Ptr<GuiInstanceContext> context,
			GuiConstructorRepr* ctor
			)
		{
			vint index=context->namespaces.Keys().IndexOf(ctor->typeNamespace);
			if(index!=-1)
			{
				Ptr<GuiInstanceContext::NamespaceInfo> namespaceInfo=context->namespaces.Values()[index];
				FOREACH(Ptr<GuiInstanceNamespace>, ns, namespaceInfo->namespaces)
				{
					auto fullName = GlobalStringKey::Get(ns->prefix + ctor->typeName.ToString() + ns->postfix);
					IGuiInstanceLoader* loader = GetInstanceLoaderManager()->GetLoader(fullName);
					if(loader)
					{
						return InstanceLoadingSource(loader, fullName);
					}
				}
			}
			return InstanceLoadingSource();
		}

/***********************************************************************
LoadInstancePropertyValue
***********************************************************************/

		bool LoadInstancePropertyValue(
			Ptr<GuiInstanceEnvironment> env,
			GuiAttSetterRepr* attSetter,
			GlobalStringKey binding,
			IGuiInstanceLoader::PropertyValue propertyValue,
			List<Ptr<GuiValueRepr>>& input,
			IGuiInstanceLoader* propertyLoader,
			bool constructorArgument,
			List<Pair<Value, IGuiInstanceLoader*>>& output,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters
			)
		{
			GlobalStringKey instanceType;
			if (propertyValue.instanceValue.IsNull())
			{
				instanceType = propertyLoader->GetTypeName();
			}
			else
			{
				instanceType = GlobalStringKey::Get(propertyValue.instanceValue.GetTypeDescriptor()->GetTypeName());
			}

			vint loadedValueCount = 0;
			// try to look for a loader to handle this property
			while (propertyLoader && loadedValueCount < input.Count())
			{
				if (auto propertyInfo = propertyLoader->GetPropertyType(propertyValue))
				{
					if (constructorArgument)
					{
						if (propertyInfo->scope == GuiInstancePropertyInfo::Property)
						{
							return false;
						}
					}
					else
					{
						if (propertyInfo->scope == GuiInstancePropertyInfo::Constructor)
						{
							return false;
						}
					}
					if (propertyInfo->support == GuiInstancePropertyInfo::NotSupport)
					{
						env->scope->errors.Add(
							L"Property \"" +
							propertyValue.propertyName.ToString() +
							L"\" of type \"" +
							propertyValue.instanceValue.GetTypeDescriptor()->GetTypeName() +
							L"\" is not supported.");
						return false;
					}

					switch (propertyInfo->support)
					{
					case GuiInstancePropertyInfo::SupportSet:
						if (input.Count() != 1)
						{
							env->scope->errors.Add(
								L"Collection property \"" +
								propertyValue.propertyName.ToString() +
								L"\" of type \"" +
								instanceType.ToString() +
								L"\" can only be assigned with a single value.");
							return false;
						}
						if (constructorArgument) return false;
						if (binding != GlobalStringKey::_Set)
						{
							env->scope->errors.Add(
								L"Collection property \"" +
								propertyValue.propertyName.ToString() +
								L"\" of type \"" +
								instanceType.ToString() +
								L"\" can only be retrived using binding \"set\".");
							return false;
						}
						{
							// set binding: get the property value and apply another property list on it
							if(Ptr<GuiAttSetterRepr> propertyAttSetter=input[0].Cast<GuiAttSetterRepr>())
							{
								if(propertyLoader->GetPropertyValue(propertyValue) && propertyValue.propertyValue.GetRawPtr())
								{
									input[0] = 0;
									loadedValueCount++;

									ITypeDescriptor* propertyTypeDescriptor=propertyValue.propertyValue.GetRawPtr()->GetTypeDescriptor();
									auto propertyTypeKey = GlobalStringKey::Get(propertyTypeDescriptor->GetTypeName());
									IGuiInstanceLoader* propertyInstanceLoader=GetInstanceLoaderManager()->GetLoader(propertyTypeKey);
									if(propertyInstanceLoader)
									{
										FillInstance(propertyValue.propertyValue, env, propertyAttSetter.Obj(), propertyInstanceLoader, false, propertyTypeKey, bindingSetters, eventSetters);
									}
								}
							}
						}
						break;
					case GuiInstancePropertyInfo::SupportCollection:
						if (binding != GlobalStringKey::Empty)
						{
							env->scope->errors.Add(
								L"Collection property \"" +
								propertyValue.propertyName.ToString() +
								L"\" of type \"" +
								instanceType.ToString() +
								L"\" cannot be assigned using binding.");
							return false;
						}
						{
							FOREACH_INDEXER(Ptr<GuiValueRepr>, valueRepr, index, input)
							{
								if (valueRepr)
								{
									// default binding: set the value directly
									vint errorCount = env->scope->errors.Count();
									if (LoadValueVisitor::LoadValue(valueRepr, env, propertyInfo->acceptableTypes, bindingSetters, eventSetters, propertyValue.propertyValue))
									{
										input[index] = 0;
										loadedValueCount++;
										output.Add(Pair<Value, IGuiInstanceLoader*>(propertyValue.propertyValue, propertyLoader));
									}
									else if (propertyInfo->tryParent)
									{
										env->scope->errors.RemoveRange(errorCount, env->scope->errors.Count() - errorCount);
									}
								}
							}
						}
						break;
					case GuiInstancePropertyInfo::SupportAssign:
						if (input.Count() != 1)
						{
							env->scope->errors.Add(
								L"Assignable property \"" +
								propertyValue.propertyName.ToString() +
								L"\" of type \"" +
								instanceType.ToString() +
								L"\" cannot be assigned using multiple values.");
							return false;
						}
						if (binding == GlobalStringKey::_Set)
						{
							env->scope->errors.Add(
								L"Assignable property \"" +
								propertyValue.propertyName.ToString() +
								L"\" of type \"" +
								instanceType.ToString() +
								L"\" cannot be retrived using binding \"set\".");
							return false;
						}
						{
							FOREACH_INDEXER(Ptr<GuiValueRepr>, valueRepr, index, input)
							{
								if (valueRepr)
								{
									bool canRemoveLoadedValue = false;
									if (binding == GlobalStringKey::Empty)
									{
										// default binding: set the value directly
										if (LoadValueVisitor::LoadValue(valueRepr, env, propertyInfo->acceptableTypes, bindingSetters, eventSetters, propertyValue.propertyValue))
										{
											canRemoveLoadedValue = true;
											output.Add(Pair<Value, IGuiInstanceLoader*>(propertyValue.propertyValue, propertyLoader));
										}
									}
									else if (IGuiInstanceBinder* binder=GetInstanceLoaderManager()->GetInstanceBinder(binding))
									{
										List<GlobalStringKey> contextNames;
										binder->GetRequiredContexts(contextNames);
										bool success = PrepareBindingContext(env, contextNames, L"property binding", binder->GetBindingName());

										if (success)
										{
											// other binding: provide the property value to the specified binder
											List<ITypeDescriptor*> binderExpectedTypes;
											binder->GetExpectedValueTypes(binderExpectedTypes);
											if (LoadValueVisitor::LoadValue(valueRepr, env, binderExpectedTypes, bindingSetters, eventSetters, propertyValue.propertyValue))
											{
												canRemoveLoadedValue = true;
												if (constructorArgument)
												{
													auto translatedValue = binder->GetValue(env, propertyValue.propertyValue);
													if (translatedValue.IsNull())
													{
														env->scope->errors.Add(
															L"Assignable property \"" +
															propertyValue.propertyName.ToString() +
															L"\" of type \"" +
															instanceType.ToString() +
															L"\" cannot be assigned using binding \"" +
															binding.ToString() +
															L"\" because the value translation failed.");
													}
													else
													{
														output.Add(Pair<Value, IGuiInstanceLoader*>(translatedValue, propertyLoader));
													}
												}
												else if (propertyInfo->scope == GuiInstancePropertyInfo::Property)
												{
													FillInstanceBindingSetter bindingSetter;
													bindingSetter.binder = binder;
													bindingSetter.loader = propertyLoader;
													bindingSetter.bindingTarget = attSetter;
													bindingSetter.propertyValue = propertyValue;
													bindingSetters.Add(bindingSetter);
												}
											}
										}
									}
									else
									{
										env->scope->errors.Add(
											L"Assignable property \"" +
											propertyValue.propertyName.ToString() +
											L"\" of type \"" +
											instanceType.ToString() +
											L"\" cannot be assigned using binding \"" +
											binding.ToString() +
											L"\" because the appropriate IGuiInstanceBinder for this binding cannot be found.");
									}

									if (canRemoveLoadedValue)
									{
										input[index] = 0;
										loadedValueCount++;
									}
								}
							}
						}
						break;
					case GuiInstancePropertyInfo::SupportArray:
						if (binding != GlobalStringKey::Empty)
						{
							env->scope->errors.Add(
								L"Array property \"" +
								propertyValue.propertyName.ToString() +
								L"\" of type \"" +
								instanceType.ToString() +
								L"\" cannot be assigned using binding.");
							return false;
						}
						{
							auto list = IValueList::Create();
							FOREACH_INDEXER(Ptr<GuiValueRepr>, valueRepr, index, input)
							{
								// default binding: add the value to the list
								if (LoadValueVisitor::LoadValue(valueRepr, env, propertyInfo->acceptableTypes, bindingSetters, eventSetters, propertyValue.propertyValue))
								{
									input[index] = 0;
									loadedValueCount++;
									list->Add(propertyValue.propertyValue);
								}
							}

							// set the whole list to the property
							output.Add(Pair<Value, IGuiInstanceLoader*>(Value::From(list), propertyLoader));
						}
						break;
					default:;
					}

					if (!propertyInfo->tryParent)
					{
						break;
					}
				}
				if (constructorArgument)
				{
					break;
				}
				else
				{
					propertyLoader = GetInstanceLoaderManager()->GetParentLoader(propertyLoader);
				}
			}

			return true;
		}

/***********************************************************************
FillInstance
***********************************************************************/

		void FillInstance(
			description::Value createdInstance,
			Ptr<GuiInstanceEnvironment> env,
			GuiAttSetterRepr* attSetter,
			IGuiInstanceLoader* loader,
			bool skipDefaultProperty,
			GlobalStringKey typeName,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters
			)
		{
			IGuiInstanceLoader::TypeInfo typeInfo(typeName, createdInstance.GetTypeDescriptor());
			// reverse loop to set the default property (name == L"") after all other properties
			for (vint i = attSetter->setters.Count() - 1; i >= 0; i--)
			{
				GlobalStringKey propertyName = attSetter->setters.Keys()[i];
				if (propertyName == GlobalStringKey::Empty && skipDefaultProperty)
				{
					continue;
				}

				auto propertyValue=attSetter->setters.Values()[i];
				IGuiInstanceLoader* propertyLoader=loader;
				IGuiInstanceLoader::PropertyValue cachedPropertyValue(
					typeInfo,
					propertyName,
					createdInstance
					);
				List<Ptr<GuiValueRepr>> input;
				List<Pair<Value, IGuiInstanceLoader*>> output;

				// extract all loaded property values
				CopyFrom(input, propertyValue->values);
				LoadInstancePropertyValue(env, attSetter, propertyValue->binding, cachedPropertyValue, input, propertyLoader, false, output, bindingSetters, eventSetters);

				// if there is no binding, set all values into the specified property
				if (propertyValue->binding == GlobalStringKey::Empty)
				{
					for (vint i = 0; i < output.Count(); i++)
					{
						auto value = output[i].key;
						auto valueLoader = output[i].value;
						cachedPropertyValue.propertyValue = value;
						if (!valueLoader->SetPropertyValue(cachedPropertyValue))
						{
							value.DeleteRawPtr();
						}
					}
				}
			}

			// attach events
			FOREACH_INDEXER(GlobalStringKey, eventName, index, attSetter->eventHandlers.Keys())
			{
				auto handler = attSetter->eventHandlers.Values()[index];

				IGuiInstanceLoader::PropertyInfo propertyInfo(
					typeInfo,
					eventName
					);

				// get the loader to attach the event
				Ptr<GuiInstanceEventInfo> eventInfo;
				IGuiInstanceLoader* eventLoader = loader;
				{
					while (eventLoader)
					{
						if ((eventInfo = eventLoader->GetEventType(propertyInfo)))
						{
							if (eventInfo->support == GuiInstanceEventInfo::NotSupport)
							{
								eventInfo = 0;
							}
							break;
						}
						eventLoader = GetInstanceLoaderManager()->GetParentLoader(eventLoader);
					}
				}

				IGuiInstanceEventBinder* binder = 0;
				if (handler->binding != GlobalStringKey::Empty)
				{
					binder = GetInstanceLoaderManager()->GetInstanceEventBinder(handler->binding);
					if (!binder)
					{
						env->scope->errors.Add(
							L"Failed to attach event \"" +
							eventName.ToString() +
							L"\" of type \"" +
							typeName.ToString() +
							L"\" with the handler \"" +
							handler->value +
							L"\" using event binding \"" +
							handler->binding.ToString() +
							L"\" because the appropriate IGuiInstanceEventBinder for this binding cannot be found.");
						continue;
					}
				}

				if (eventInfo)
				{
					FillInstanceEventSetter eventSetter;
					eventSetter.binder = binder;
					eventSetter.loader = eventLoader;
					eventSetter.bindingTarget = attSetter;
					eventSetter.eventInfo = eventInfo;
					eventSetter.propertyValue.typeInfo = propertyInfo.typeInfo;
					eventSetter.propertyValue.propertyName = propertyInfo.propertyName;
					eventSetter.propertyValue.instanceValue = createdInstance;
					eventSetter.handlerName = handler->value;
					eventSetters.Add(eventSetter);
				}
				else
				{
					env->scope->errors.Add(
						L"Failed to attach event \"" +
						eventName.ToString() +
						L"\" of type \"" +
						typeName.ToString() +
						L"\" with the handler \"" +
						handler->value +
						L"\" using event binding \"" +
						handler->binding.ToString() +
						L"\" because no IGuiInstanceLoader supports this event.");
				}
			}
		}

/***********************************************************************
CreateInstance
***********************************************************************/

		description::Value CreateInstance(
			Ptr<GuiInstanceEnvironment> env,
			GuiConstructorRepr* ctor,
			description::ITypeDescriptor* expectedType,
			GlobalStringKey& typeName,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters,
			bool isRootInstance
			)
		{
			// search for a correct loader
			InstanceLoadingSource source=FindInstanceLoadingSource(env->context, ctor);
			Value instance;
			IGuiInstanceLoader* instanceLoader = 0;
			bool deserialized = false;

			if(source.loader)
			{
				// found the correct loader, prepare a TypeInfo
				IGuiInstanceLoader* loader=source.loader;
				instanceLoader = source.loader;
				typeName = source.typeName;
				ITypeDescriptor* typeDescriptor = GetInstanceLoaderManager()->GetTypeDescriptorForType(source.typeName);
				
				// see if the constructor contains only a single text value
				Ptr<GuiTextRepr> singleTextValue;
				{
					vint index = ctor->setters.Keys().IndexOf(GlobalStringKey::Empty);
					if (index != -1)
					{
						auto setterValue = ctor->setters.Values()[index];
						if (setterValue->values.Count() == 1)
						{
							singleTextValue = setterValue->values[0].Cast<GuiTextRepr>();
						}
					}
					else
					{
						singleTextValue = new GuiTextRepr;
						singleTextValue->text = L"";
					}
				}

				// if the target type is not the expected type, fail
				if (!expectedType || expectedType==GetTypeDescriptor<Value>() || typeDescriptor->CanConvertTo(expectedType))
				{
					// traverse the loader and all ancestors to load the type
					IGuiInstanceLoader::TypeInfo typeInfo(typeName, typeDescriptor);
					bool foundLoader = false;
					while(!foundLoader && loader && instance.IsNull())
					{
						if (singleTextValue && loader->IsDeserializable(typeInfo))
						{
							foundLoader = true;
							// if the loader support deserialization and this is a single text value constructor
							// then choose deserialization
							instance = loader->Deserialize(typeInfo, singleTextValue->text);
							if (!instance.IsNull())
							{
								deserialized = true;
							}
							else
							{
								env->scope->errors.Add(
									L"Failed to deserialize object of type \"" +
									source.typeName.ToString() +
									L"\" from string \"" +
									singleTextValue->text +
									L"\".");
							}
						}
						else if (loader->IsCreatable(typeInfo))
						{
							foundLoader = true;
							// find all constructor parameters
							List<GlobalStringKey> constructorParameters;
							List<GlobalStringKey> requiredParameters;
							loader->GetConstructorParameters(typeInfo, constructorParameters);
							
							// see if all parameters exists
							Group<GlobalStringKey, Value> constructorArguments;
							FOREACH(GlobalStringKey, propertyName, constructorParameters)
							{
								IGuiInstanceLoader::PropertyInfo propertyInfo(typeInfo, propertyName);
								auto info = loader->GetPropertyType(propertyInfo);
								vint index = ctor->setters.Keys().IndexOf(propertyName);

								if (info->scope != GuiInstancePropertyInfo::Property)
								{
									if (info->required)
									{
										if (index == -1)
										{
											// if a required parameter doesn't exist, fail
											env->scope->errors.Add(
												L"Failed to create object of type \"" +
												source.typeName.ToString() +
												L"\" because the required constructor parameter \"" +
												propertyName.ToString() +
												L"\" is missing.");
											goto SKIP_CREATE_INSTANCE;
										}
										requiredParameters.Add(propertyName);
									}

									if (index != -1)
									{
										auto setterValue = ctor->setters.Values()[index];
										if (setterValue->binding != GlobalStringKey::Empty)
										{
											if (IGuiInstanceBinder* binder = GetInstanceLoaderManager()->GetInstanceBinder(setterValue->binding))
											{
												if (!binder->ApplicableToConstructorArgument())
												{
													// if the constructor argument uses binding, fail
													env->scope->errors.Add(
														L"Failed to create object of type \"" +
														source.typeName.ToString() +
														L"\" because the required constructor parameter \"" +
														propertyName.ToString() +
														L"\" is not allowed to use binding \"" +
														setterValue->binding.ToString() +
														L"\" which does not applicable to constructor parameters.");
													goto SKIP_CREATE_INSTANCE;
												}
											}
											else
											{
												env->scope->errors.Add(
													L"Failed to create object of type \"" +
													source.typeName.ToString() +
													L"\" because the required constructor parameter \"" +
													propertyName.ToString() +
													L"\" is not allowed to use binding \"" +
													setterValue->binding.ToString() +
													L"\" because the appropriate IGuiInstanceBinder for this binding cannot be found.");
												goto SKIP_CREATE_INSTANCE;
											}
										}

										// load the parameter
										List<Ptr<GuiValueRepr>> input;
										List<Pair<Value, IGuiInstanceLoader*>> output;
										IGuiInstanceLoader::PropertyValue propertyValue(typeInfo, propertyName, Value());

										CopyFrom(input, setterValue->values);
										LoadInstancePropertyValue(env, ctor, setterValue->binding, propertyValue, input, loader, true, output, bindingSetters, eventSetters);

										for (vint i = 0; i < output.Count(); i++)
										{
											constructorArguments.Add(propertyName, output[i].key);
										}
									}
								}
							}
							
							// check if all required parameters exist
							FOREACH(GlobalStringKey, propertyName, requiredParameters)
							{
								if (!constructorArguments.Contains(propertyName))
								{
									env->scope->errors.Add(
										L"Failed to create object of type \"" +
										source.typeName.ToString() +
										L"\" because the required constructor parameter \"" +
										propertyName.ToString() +
										L"\" is missing.");
									goto SKIP_CREATE_INSTANCE;
								}
							}

							// create the instance
							instance = loader->CreateInstance(env, typeInfo, constructorArguments);
						SKIP_CREATE_INSTANCE:
							// delete all arguments if the constructing fails
							if (instance.IsNull())
							{
								for (vint i = 0; i < constructorArguments.Count(); i++)
								{
									FOREACH(Value, value, constructorArguments.GetByIndex(i))
									{
										value.DeleteRawPtr();
									}
								}
							}
						}
						loader = GetInstanceLoaderManager()->GetParentLoader(loader);
					}

					if (instance.IsNull())
					{
						env->scope->errors.Add(
							L"Failed to create object of type \"" +
							source.typeName.ToString() +
							L"\".");
					}
				}
				else
				{
					env->scope->errors.Add(
						L"Failed to create object of type \"" +
						source.typeName.ToString() +
						L"\" because the expected type is \"" +
						expectedType->GetTypeName() +
						L"\".");
				}
			}
			else if(source.context)
			{
				// found another instance in the resource
				if (Ptr<GuiInstanceContextScope> scope = LoadInstanceFromContext(source.context, env->resolver, expectedType))
				{
					typeName = scope->typeName;
					instance = scope->rootInstance;
					instanceLoader = GetInstanceLoaderManager()->GetLoader(typeName);
				}
				else
				{
					auto contextCtor = source.context->instance;
					env->scope->errors.Add(
						L"Failed to find type \"" +
						(contextCtor->typeNamespace == GlobalStringKey::Empty
							? contextCtor->typeName.ToString()
							: contextCtor->typeNamespace.ToString() + L":" + contextCtor->typeName.ToString()
							) +
						L"\".");
				}
			}
			else
			{
				env->scope->errors.Add(
					L"Failed to find type \"" +
					(ctor->typeNamespace == GlobalStringKey::Empty
						? ctor->typeName.ToString()
						: ctor->typeNamespace.ToString() + L":" + ctor->typeName.ToString()
						) +
					L"\".");
			}

			if(instance.GetRawPtr() && instanceLoader)
			{
				if (isRootInstance)
				{
					env->scope->rootInstance = instance;
					ExecuteParameters(env);
				}
				InitializeInstanceFromConstructor(env, ctor, instanceLoader, typeName, instance, deserialized, bindingSetters, eventSetters);
			}
			return instance;
		}

/***********************************************************************
ExecuteBindingSetters
***********************************************************************/

		void ExecuteParameters(Ptr<GuiInstanceEnvironment> env)
		{
			auto td = env->scope->rootInstance.GetTypeDescriptor();
			FOREACH(Ptr<GuiInstanceParameter>, parameter, env->context->parameters)
			{
				auto info = td->GetPropertyByName(parameter->name.ToString(), true);
				if (!info)
				{
					env->scope->errors.Add(L"Cannot find parameter \"" + parameter->name.ToString() + L"\" in properties of \"" + td->GetTypeName() + L"\".");
					continue;
				}

				auto parameterTd = GetTypeDescriptor(parameter->className.ToString());
				if (!parameterTd)
				{
					env->scope->errors.Add(L"Cannot find type \"" + parameter->className.ToString() + L"\" of parameter \"" + parameter->name.ToString() + L"\".");
				}

				auto value = info->GetValue(env->scope->rootInstance);
				if (parameterTd && (!value.GetTypeDescriptor() || !value.GetTypeDescriptor()->CanConvertTo(parameterTd)))
				{
					env->scope->errors.Add(L"Value of parameter \"" + parameter->name.ToString() + L"\" is not \"" + parameterTd->GetTypeName() + L"\" which is required.");
				}

				if (env->scope->referenceValues.Keys().Contains(parameter->name))
				{
					env->scope->errors.Add(L"Parameter \"" + parameter->name.ToString() + L"\" conflict with an existing named object.");
				}
				else
				{
					env->scope->referenceValues.Add(parameter->name, value);
				}
			}
		}

/***********************************************************************
ExecuteBindingSetters
***********************************************************************/

		bool PrepareBindingContext(
			Ptr<GuiInstanceEnvironment> env,
			collections::List<GlobalStringKey>& contextNames,
			const WString& dependerType,
			const GlobalStringKey& dependerName
			)
		{
			bool success = true;
			FOREACH(GlobalStringKey, contextName, contextNames)
			{
				if (!env->scope->bindingContexts.Keys().Contains(contextName))
				{
					auto factory = GetInstanceLoaderManager()->GetInstanceBindingContextFactory(contextName);
					if (factory)
					{
						env->scope->bindingContexts.Add(contextName, factory->CreateContext());
					}
					else
					{
						env->scope->errors.Add(
							L"Failed to create binding context \"" +
							contextName.ToString() +
							L"\" which is required by " +
							dependerType +
							L" \"" +
							dependerName.ToString() +
							L"\".");
						success = false;
					}
				}
			}
			return success;
		}

		void ExecuteBindingSetters(
			Ptr<GuiInstanceEnvironment> env,
			List<FillInstanceBindingSetter>& bindingSetters
			)
		{
			// set all binding attributes
			FOREACH(FillInstanceBindingSetter, bindingSetter, bindingSetters)
			{
				List<GlobalStringKey> contextNames;
				bindingSetter.binder->GetRequiredContexts(contextNames);
				bool success = PrepareBindingContext(env, contextNames, L"property binding", bindingSetter.binder->GetBindingName());

				if (bindingSetter.binder->RequireInstanceName())
				{
					if (bindingSetter.bindingTarget->instanceName == GlobalStringKey::Empty)
					{
						auto name = GlobalStringKey::Get(L"<temp>" + itow(env->scope->referenceValues.Count()));
						bindingSetter.bindingTarget->instanceName = name;
					}

					auto name = bindingSetter.bindingTarget->instanceName;
					auto value = bindingSetter.propertyValue.instanceValue;
					if (!env->scope->referenceValues.Keys().Contains(bindingSetter.bindingTarget->instanceName))
					{
						env->scope->referenceValues.Add(name, value);
					}
				}

				if (!success || !bindingSetter.binder->SetPropertyValue(env, bindingSetter.loader, bindingSetter.bindingTarget->instanceName, bindingSetter.propertyValue))
				{
					auto value = bindingSetter.propertyValue.propertyValue;
					env->scope->errors.Add(
						L"Failed to set property \"" +
						bindingSetter.propertyValue.propertyName.ToString() +
						L"\" of \"" +
						bindingSetter.propertyValue.instanceValue.GetTypeDescriptor()->GetTypeName() +
						L"\" using binding \"" +
						bindingSetter.binder->GetBindingName().ToString() +
						L"\" and value \"" +
						(
							value.GetValueType() == Value::Null ? WString(L"null") :
							value.GetValueType() == Value::Text ? value.GetText() :
							(L"<" + value.GetTypeDescriptor()->GetTypeName() + L">")
						) +
						L"\".");
					bindingSetter.propertyValue.propertyValue.DeleteRawPtr();
				}
			}

			// initialize all binding context
			FOREACH(Ptr<IGuiInstanceBindingContext>, context, env->scope->bindingContexts.Values())
			{
				context->Initialize(env);
			}
		}

/***********************************************************************
ExecuteBindingSetters
***********************************************************************/

		void ExecuteEventSetters(
			description::Value createdInstance,
			Ptr<GuiInstanceEnvironment> env,
			List<FillInstanceEventSetter>& eventSetters
			)
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			// set all event attributes
			FOREACH(FillInstanceEventSetter, eventSetter, eventSetters)
			{
				if (eventSetter.binder)
				{
					List<GlobalStringKey> contextNames;
					eventSetter.binder->GetRequiredContexts(contextNames);
					auto propertyValue = eventSetter.propertyValue;
					propertyValue.propertyValue = BoxValue(eventSetter.handlerName);
					bool success = PrepareBindingContext(env, contextNames, L"event binding", eventSetter.binder->GetBindingName());

					if (eventSetter.binder->RequireInstanceName())
					{
						if (eventSetter.bindingTarget->instanceName == GlobalStringKey::Empty)
						{
							auto name = GlobalStringKey::Get(L"<temp>" + itow(env->scope->referenceValues.Count()));
							eventSetter.bindingTarget->instanceName = name;
						}

						auto name = eventSetter.bindingTarget->instanceName;
						auto value = eventSetter.propertyValue.instanceValue;
						if (!env->scope->referenceValues.Keys().Contains(eventSetter.bindingTarget->instanceName))
						{
							env->scope->referenceValues.Add(name, value);
						}
					}

					if (!success || !eventSetter.binder->AttachEvent(env, eventSetter.loader, eventSetter.bindingTarget->instanceName, propertyValue))
					{
						env->scope->errors.Add(
							L"Failed to attach event \"" +
							propertyValue.propertyName.ToString() +
							L"\" of type \"" +
							propertyValue.instanceValue.GetTypeDescriptor()->GetTypeName() +
							L"\" with the handler \"" +
							propertyValue.propertyValue.GetText() +
							L"\" using event binding \"" +
							eventSetter.binder->GetBindingName().ToString() +
							L"\".");
					}
				}
				else if (auto group = createdInstance.GetTypeDescriptor()->GetMethodGroupByName(eventSetter.handlerName, true))
				{
					// find a correct method
					vint count = group->GetMethodCount();
					IMethodInfo* selectedMethod = 0;
					for (vint i = 0; i < count; i++)
					{
						auto method = group->GetMethod(i);
						if (method->GetParameterCount() != 2) goto UNSUPPORTED;

						{
							auto returnType = method->GetReturn();
							auto senderType = method->GetParameter(0)->GetType();
							auto argumentType = method->GetParameter(1)->GetType();
					
							if (returnType->GetDecorator() != ITypeInfo::TypeDescriptor) goto UNSUPPORTED;
							if (returnType->GetTypeDescriptor() != description::GetTypeDescriptor<VoidValue>()) goto UNSUPPORTED;
					
							if (senderType->GetDecorator() != ITypeInfo::RawPtr) goto UNSUPPORTED;
							senderType = senderType->GetElementType();
							if (senderType->GetDecorator() != ITypeInfo::TypeDescriptor) goto UNSUPPORTED;
							if (senderType->GetTypeDescriptor() != description::GetTypeDescriptor<compositions::GuiGraphicsComposition>()) goto UNSUPPORTED;
					
							if (argumentType->GetDecorator() != ITypeInfo::RawPtr) goto UNSUPPORTED;
							argumentType = argumentType->GetElementType();
							if (argumentType->GetDecorator() != ITypeInfo::TypeDescriptor) goto UNSUPPORTED;
							if (argumentType->GetTypeDescriptor() != eventSetter.eventInfo->argumentType) goto UNSUPPORTED;

							selectedMethod = method;
							break;
						}

					UNSUPPORTED:
						continue;
					}

					if (selectedMethod)
					{
						Value proxy = selectedMethod->CreateFunctionProxy(createdInstance);
						if (!proxy.IsNull())
						{
							auto propertyValue = eventSetter.propertyValue;
							propertyValue.propertyValue = proxy;
							eventSetter.loader->SetEventValue(propertyValue);
						}
					}
					else
					{
						env->scope->errors.Add(
							L"Event handler \"" +
							eventSetter.handlerName +
							L"\" exists but the type does not match the event \"" +
							eventSetter.propertyValue.propertyName.ToString() +
							L"\" of \"" +
							env->context->instance->typeName.ToString() +
							L"\".");
					}
				}
				else
				{
					env->scope->errors.Add(
						L"Failed to find event handler \"" +
						eventSetter.handlerName +
						L"\" when setting event \"" +
						eventSetter.propertyValue.propertyName.ToString() +
						L"\" of \"" +
						env->context->instance->typeName.ToString() +
						L"\".");
				}
			}
#endif
		}

/***********************************************************************
LoadInstance
***********************************************************************/

		Ptr<GuiInstanceContextScope> LoadInstanceFromContext(
			Ptr<GuiInstanceContext> context,
			Ptr<GuiResourcePathResolver> resolver,
			description::ITypeDescriptor* expectedType
			)
		{
			Ptr<GuiInstanceEnvironment> env = new GuiInstanceEnvironment(context, resolver);
			List<FillInstanceBindingSetter> bindingSetters;
			List<FillInstanceEventSetter> eventSetters;
			Value instance = CreateInstance(env, context->instance.Obj(), expectedType, env->scope->typeName, bindingSetters, eventSetters, true);
			
			if (!instance.IsNull())
			{
				ExecuteBindingSetters(env, bindingSetters);
				ExecuteEventSetters(instance, env, eventSetters);
				return env->scope;
			}
			return 0;
		}

		Ptr<GuiInstanceContextScope> LoadInstance(
			Ptr<GuiResource> resource,
			const WString& instancePath,
			description::ITypeDescriptor* expectedType
			)
		{
			Ptr<GuiInstanceContext> context=resource->GetValueByPath(instancePath).Cast<GuiInstanceContext>();
			if (context)
			{
				Ptr<GuiResourcePathResolver> resolver = new GuiResourcePathResolver(resource, resource->GetWorkingDirectory());
				return LoadInstanceFromContext(context, resolver, expectedType);
			}
			return 0;
		}

/***********************************************************************
InitializeInstance
***********************************************************************/

		void InitializeInstanceFromConstructor(
			Ptr<GuiInstanceEnvironment> env,
			GuiConstructorRepr* ctor,
			IGuiInstanceLoader* instanceLoader,
			GlobalStringKey typeName,
			description::Value instance,
			bool deserialized,
			List<FillInstanceBindingSetter>& bindingSetters,
			List<FillInstanceEventSetter>& eventSetters
			)
		{
			// fill all attributes
			FillInstance(instance, env, ctor, instanceLoader, deserialized, typeName, bindingSetters, eventSetters);

			if (ctor->instanceName != GlobalStringKey::Empty)
			{
				if (env->scope->referenceValues.Keys().Contains(ctor->instanceName))
				{
					env->scope->errors.Add(L"Parameter \"" + ctor->instanceName.ToString() + L"\" conflict with an existing named object.");
				}
				else
				{
					env->scope->referenceValues.Add(ctor->instanceName, instance);
				}
			}
		}

		Ptr<GuiInstanceContextScope> InitializeInstanceFromContext(
			Ptr<GuiInstanceContext> context,
			Ptr<GuiResourcePathResolver> resolver,
			description::Value instance
			)
		{
			List<FillInstanceBindingSetter> bindingSetters;
			List<FillInstanceEventSetter> eventSetters;

			// search for a correct loader
			GuiConstructorRepr* ctor = context->instance.Obj();
			Ptr<GuiInstanceEnvironment> env = new GuiInstanceEnvironment(context, resolver);
			InstanceLoadingSource source = FindInstanceLoadingSource(env->context, ctor);

			// initialize the instance
			if(source.loader)
			{
				env->scope->rootInstance = instance;
				ExecuteParameters(env);
				InitializeInstanceFromConstructor(env, ctor, source.loader, source.typeName, instance, false, bindingSetters, eventSetters);
				ExecuteBindingSetters(env, bindingSetters);
				ExecuteEventSetters(instance, env, eventSetters);
				return env->scope;
			}
			return 0;
		}

		Ptr<GuiInstanceContextScope> InitializeInstance(
			Ptr<GuiResource> resource,
			const WString& instancePath,
			description::Value instance
			)
		{
			if (instance.GetRawPtr())
			{
				Ptr<GuiInstanceContext> context=resource->GetValueByPath(instancePath).Cast<GuiInstanceContext>();
				if (context)
				{
					Ptr<GuiResourcePathResolver> resolver = new GuiResourcePathResolver(resource, resource->GetWorkingDirectory());
					return InitializeInstanceFromContext(context, resolver, instance);
				}
			}
			return 0;
		}
	}
}

/***********************************************************************
GUIINSTANCELOADER_LOG.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace reflection::description;

/***********************************************************************
LogInstanceLoaderManager_GetParentTypes
***********************************************************************/

		void LogInstanceLoaderManager_GetParentTypes(const WString& typeName, List<WString>& parentTypes)
		{
			if (ITypeDescriptor* type = GetGlobalTypeManager()->GetTypeDescriptor(typeName))
			{
				vint parentCount = type->GetBaseTypeDescriptorCount();
				for (vint j = 0; j < parentCount; j++)
				{
					ITypeDescriptor* parent = type->GetBaseTypeDescriptor(j);
					parentTypes.Add(parent->GetTypeName());
				}
			}
			else
			{
				parentTypes.Add(GetInstanceLoaderManager()->GetParentTypeForVirtualType(GlobalStringKey::Get(typeName)).ToString());
			}
		}

/***********************************************************************
LogInstanceLoaderManager_PrintParentTypes
***********************************************************************/

		void LogInstanceLoaderManager_PrintParentTypes(stream::TextWriter& writer, const WString& typeName)
		{
			List<WString> parentTypes;
			LogInstanceLoaderManager_GetParentTypes(typeName, parentTypes);
			FOREACH_INDEXER(WString, parentType, index, parentTypes)
			{
				writer.WriteLine(L"        " + WString(index == 0 ? L": " : L", ") + parentType);
			}
		}

/***********************************************************************
LogInstanceLoaderManager_PrintFieldName
***********************************************************************/

		void LogInstanceLoaderManager_PrintFieldName(stream::TextWriter& writer, const WString& name)
		{
			writer.WriteString(L"        " + name);
			for (vint i = name.Length(); i < 24; i++)
			{
				writer.WriteChar(L' ');
			}
			writer.WriteString(L" : ");
		}

/***********************************************************************
LogInstanceLoaderManager_PrintProperties
***********************************************************************/

		void LogInstanceLoaderManager_PrintProperties(stream::TextWriter& writer, const WString& typeName)
		{
			List<IGuiInstanceLoader*> loaders;
			{
				IGuiInstanceLoader* loader = GetInstanceLoaderManager()->GetLoader(GlobalStringKey::Get(typeName));
				while (loader)
				{
					loaders.Add(loader);
					loader = GetInstanceLoaderManager()->GetParentLoader(loader);
				}
			}
			
			IGuiInstanceLoader::TypeInfo typeInfo(GlobalStringKey::Get(typeName), GetInstanceLoaderManager()->GetTypeDescriptorForType(GlobalStringKey::Get(typeName)));
			Dictionary<GlobalStringKey, IGuiInstanceLoader*> propertyLoaders;
			FOREACH(IGuiInstanceLoader*, loader, loaders)
			{
				List<GlobalStringKey> propertyNames;
				loader->GetPropertyNames(typeInfo, propertyNames);

				FOREACH(GlobalStringKey, propertyName, propertyNames)
				{
					if (!propertyLoaders.Keys().Contains(propertyName))
					{
						propertyLoaders.Add(propertyName, loader);
					}
				}
			}

			FOREACH_INDEXER(GlobalStringKey, propertyName, index, propertyLoaders.Keys())
			{
				SortedList<WString> acceptableTypes;
				Ptr<GuiInstancePropertyInfo> firstInfo;
				IGuiInstanceLoader* loader = propertyLoaders.Values()[index];
				IGuiInstanceLoader::PropertyInfo propertyInfo(typeInfo, propertyName);

				while (loader)
				{
					if (auto info = loader->GetPropertyType(propertyInfo))
					{
						if (firstInfo)
						{
							if (info->support != firstInfo->support)
							{
								break;
							}
						}
						else
						{
							firstInfo = info;
						}

						if (info->support!=GuiInstancePropertyInfo::NotSupport)
						{
							FOREACH(ITypeDescriptor*, type, info->acceptableTypes)
							{
								if (!acceptableTypes.Contains(type->GetTypeName()))
								{
									acceptableTypes.Add(type->GetTypeName());
								}
							}

							if (!info->tryParent)
							{
								break;
							}
						}
						else
						{
							break;
						}
					}
					
					vint index = loaders.IndexOf(loader);
					loader = index == loaders.Count() - 1 ? 0 : loaders[index + 1];
				}

				if (firstInfo->support == GuiInstancePropertyInfo::NotSupport)
				{
					continue;
				}

				LogInstanceLoaderManager_PrintFieldName(writer, (propertyName == GlobalStringKey::Empty? L"<DEFAULT-PROPERTY>" : propertyName.ToString()));
				switch (firstInfo->scope)
				{
				case GuiInstancePropertyInfo::ViewModel:
					writer.WriteString(L"#");
					break;
				case GuiInstancePropertyInfo::Constructor:
					writer.WriteString(firstInfo->required ? L"+" : L"*");
					break;
				case GuiInstancePropertyInfo::Property:
					writer.WriteString(L" ");
					break;
				}
				switch (firstInfo->support)
				{
				case GuiInstancePropertyInfo::SupportAssign:
					writer.WriteString(L"[assign]     ");
					break;
				case GuiInstancePropertyInfo::SupportCollection:
					writer.WriteString(L"[collection] ");
					break;
				case GuiInstancePropertyInfo::SupportArray:
					writer.WriteString(L"[array]      ");
					break;
				case GuiInstancePropertyInfo::SupportSet:
					writer.WriteString(L"[set]        ");
					break;
				default:;
				}

				switch (acceptableTypes.Count())
				{
				case 0:
					writer.WriteLine(L"<UNKNOWN-TYPE>");
					break;
				case 1:
					writer.WriteLine(acceptableTypes[0]);
					break;
				default:
					writer.WriteLine(L"{");
					FOREACH(WString, typeName, acceptableTypes)
					{
						writer.WriteLine(L"            " + typeName + L",");
					}
					writer.WriteLine(L"        }");
				}
			}
		}

/***********************************************************************
LogInstanceLoaderManager_PrintProperties
***********************************************************************/

		void LogInstanceLoaderManager_PrintEvents(stream::TextWriter& writer, const WString& typeName)
		{
			List<IGuiInstanceLoader*> loaders;
			{
				IGuiInstanceLoader* loader = GetInstanceLoaderManager()->GetLoader(GlobalStringKey::Get(typeName));
				while (loader)
				{
					loaders.Add(loader);
					loader = GetInstanceLoaderManager()->GetParentLoader(loader);
				}
			}
			
			IGuiInstanceLoader::TypeInfo typeInfo(GlobalStringKey::Get(typeName), GetInstanceLoaderManager()->GetTypeDescriptorForType(GlobalStringKey::Get(typeName)));
			Dictionary<GlobalStringKey, IGuiInstanceLoader*> eventLoaders;
			FOREACH(IGuiInstanceLoader*, loader, loaders)
			{
				List<GlobalStringKey> eventNames;
				loader->GetEventNames(typeInfo, eventNames);

				FOREACH(GlobalStringKey, eventName, eventNames)
				{
					if (!eventLoaders.Keys().Contains(eventName))
					{
						eventLoaders.Add(eventName, loader);
					}
				}
			}

			FOREACH_INDEXER(GlobalStringKey, eventName, index, eventLoaders.Keys())
			{
				IGuiInstanceLoader* loader = eventLoaders.Values()[index];
				IGuiInstanceLoader::PropertyInfo propertyInfo(typeInfo, eventName);
				auto info = loader->GetEventType(propertyInfo);
				if (info->support == GuiInstanceEventInfo::NotSupport)
				{
					continue;
				}

				LogInstanceLoaderManager_PrintFieldName(writer, eventName.ToString());
				writer.WriteString(L" [event]      ");
				writer.WriteLine(info->argumentType->GetTypeName());
			}
		}

/***********************************************************************
LogInstanceLoaderManager_PrintSerializableType
***********************************************************************/

		void LogInstanceLoaderManager_PrintSerializableType(stream::TextWriter& writer, const WString& typeName)
		{
			if (ITypeDescriptor* type = GetGlobalTypeManager()->GetTypeDescriptor(typeName))
			{
				if (IValueSerializer* serializer = type->GetValueSerializer())
				{
					if (serializer->HasCandidate())
					{
						if (serializer->CanMergeCandidate())
						{
							writer.WriteLine(L"    enum " + typeName + L" = {" + serializer->GetDefaultText() + L"}");
						}
						else
						{
							writer.WriteLine(L"    flags " + typeName + L" = {" + serializer->GetDefaultText() + L"}");
						}

						writer.WriteLine(L"    {");
						vint count = serializer->GetCandidateCount();
						for (vint i = 0; i < count; i++)
						{
							writer.WriteLine(L"        " + serializer->GetCandidate(i) + L",");
						}
						writer.WriteLine(L"    }");
						return;
					}
					else if (type->GetPropertyCount() > 0)
					{
						writer.WriteLine(L"    struct "+ typeName +  + L" = {" + serializer->GetDefaultText() + L"}");
						writer.WriteLine(L"    {");
						vint count = type->GetPropertyCount();
						for (vint i = 0; i < count; i++)
						{
							IPropertyInfo* prop = type->GetProperty(i);
							LogInstanceLoaderManager_PrintFieldName(writer, prop->GetName());
							writer.WriteLine(prop->GetReturn()->GetTypeFriendlyName() + L";");
						}
						writer.WriteLine(L"    }");
						return;
					}
					else
					{
						writer.WriteLine(L"    data "+ typeName +  + L" = {" + serializer->GetDefaultText() + L"}");
						return;
					}
				}
			}
			writer.WriteLine(L"    serializable " + typeName);
		}

/***********************************************************************
LogInstanceLoaderManager_PrintConstructableType
***********************************************************************/

		void LogInstanceLoaderManager_PrintConstructableType(stream::TextWriter& writer, const WString& typeName)
		{
			writer.WriteLine(L"    class " + typeName);
			LogInstanceLoaderManager_PrintParentTypes(writer, typeName);
			writer.WriteLine(L"    {");
			LogInstanceLoaderManager_PrintProperties(writer, typeName);
			LogInstanceLoaderManager_PrintEvents(writer, typeName);
			writer.WriteLine(L"    }");
		}

/***********************************************************************
LogInstanceLoaderManager_PrintUnconstructableParentType
***********************************************************************/

		void LogInstanceLoaderManager_PrintUnconstructableParentType(stream::TextWriter& writer, const WString& typeName)
		{
			writer.WriteLine(L"    abstract class " + typeName);
			LogInstanceLoaderManager_PrintParentTypes(writer, typeName);
			writer.WriteLine(L"    {");
			writer.WriteLine(L"    }");
		}

/***********************************************************************
LogInstanceLoaderManager_Others
***********************************************************************/

		void LogInstanceLoaderManager_PrintVirtualizedType(stream::TextWriter& writer, const WString& typeName)
		{
			writer.WriteLine(L"    abstract class " + typeName);
		}

		void LogInstanceLoaderManager_PrintUnconstructableType(stream::TextWriter& writer, const WString& typeName)
		{
			writer.WriteLine(L"    abstract class " + typeName);
		}

		void LogInstanceLoaderManager_PrintInterfaceType(stream::TextWriter& writer, const WString& typeName)
		{
			writer.WriteLine(L"    interface " + typeName);
		}

		void LogInstanceLoaderManager_PrintInterfaceConstructableType(stream::TextWriter& writer, const WString& typeName)
		{
			writer.WriteLine(L"    interface " + typeName);
		}

/***********************************************************************
LogInstanceLoaderManager
***********************************************************************/

		void LogInstanceLoaderManager(stream::TextWriter& writer)
		{
			SortedList<WString> allTypes, virtualizedTypes;
			Group<WString, WString> typeParents, typeChildren;

			// collect types
			{
				vint typeCount = GetGlobalTypeManager()->GetTypeDescriptorCount();
				for (vint i = 0; i < typeCount; i++)
				{
					ITypeDescriptor* type = GetGlobalTypeManager()->GetTypeDescriptor(i);
					allTypes.Add(type->GetTypeName());

					vint parentCount = type->GetBaseTypeDescriptorCount();
					for (vint j = 0; j < parentCount; j++)
					{
						ITypeDescriptor* parent = type->GetBaseTypeDescriptor(j);
						typeParents.Add(type->GetTypeName(), parent->GetTypeName());
						typeChildren.Add(parent->GetTypeName(), type->GetTypeName());
					}
				}

				List<GlobalStringKey> virtualTypes;
				GetInstanceLoaderManager()->GetVirtualTypes(virtualTypes);
				FOREACH(GlobalStringKey, typeName, virtualTypes)
				{
					GlobalStringKey parentType = GetInstanceLoaderManager()->GetParentTypeForVirtualType(typeName);
					if (description::GetTypeDescriptor(parentType.ToString()) && !virtualizedTypes.Contains(parentType.ToString()))
					{
						virtualizedTypes.Add(parentType.ToString());
					}
					allTypes.Add(typeName.ToString());
					typeParents.Add(typeName.ToString(), parentType.ToString());
					typeChildren.Add(parentType.ToString(), typeName.ToString());
				}
			}

			// sort types
			List<WString> sortedTypes;
			{
				FOREACH(WString, typeName, allTypes)
				{
					if (!typeParents.Contains(typeName))
					{
						sortedTypes.Add(typeName);
					}
				}

				for (vint i = 0; i < sortedTypes.Count(); i++)
				{
					WString selectedType = sortedTypes[i];
					vint index = typeChildren.Keys().IndexOf(selectedType);
					if (index != -1)
					{
						FOREACH(WString, childType, typeChildren.GetByIndex(index))
						{
							typeParents.Remove(childType, selectedType);
							if (!typeParents.Contains(childType))
							{
								sortedTypes.Add(childType);
							}
						}
						typeChildren.Remove(selectedType);
					}
				}
			}

			// categorize types
			List<WString> serializableTypes;
			List<WString> constructableTypes;
			List<WString> unconstructableParentTypes;
			List<WString> unconstructableTypes;
			List<WString> interfaceTypes;
			List<WString> interfaceConstructableTypes;
			{
				FOREACH(WString, typeName, sortedTypes)
				{
					auto typeKey = GlobalStringKey::Get(typeName);
					auto typeDescriptor = GetInstanceLoaderManager()->GetTypeDescriptorForType(typeKey);
					IGuiInstanceLoader::TypeInfo typeInfo(typeKey, typeDescriptor);
					
					auto loader = GetInstanceLoaderManager()->GetLoader(typeKey);
					while (loader)
					{
						if (loader->IsDeserializable(typeInfo))
						{
							serializableTypes.Add(typeName);
							break;
						}
						else if (loader->IsCreatable(typeInfo))
						{
							constructableTypes.Add(typeName);
							break;
						}
						else
						{
							loader = GetInstanceLoaderManager()->GetParentLoader(loader);
						}
					}
					if (!loader && !virtualizedTypes.Contains(typeName))
					{
						bool acceptProxy = false;
						if (typeDescriptor->GetTypeName() == typeName && IsInterfaceType(typeDescriptor, acceptProxy))
						{
							if (acceptProxy)
							{
								interfaceConstructableTypes.Add(typeName);
							}
							else
							{
								interfaceTypes.Add(typeName);
							}
						}
						else
						{
							unconstructableTypes.Add(typeName);
						}
					}
				}

				List<WString> parentTypes;
				FOREACH(WString, typeName, constructableTypes)
				{
					parentTypes.Add(typeName);
				}
				for (vint i = 0; i < parentTypes.Count(); i++)
				{
					LogInstanceLoaderManager_GetParentTypes(parentTypes[i], parentTypes);
				}

				for (vint i = unconstructableTypes.Count() - 1; i >= 0; i--)
				{
					WString selectedType = unconstructableTypes[i];
					if (parentTypes.Contains(selectedType))
					{
						unconstructableTypes.RemoveAt(i);
						unconstructableParentTypes.Insert(0, selectedType);
					}
				}
			}

			writer.WriteLine(L"/***********************************************************************");
			writer.WriteLine(L"Serializable Types");
			writer.WriteLine(L"***********************************************************************/");
			FOREACH(WString, typeName, serializableTypes)
			{
				writer.WriteLine(L"");
				LogInstanceLoaderManager_PrintSerializableType(writer, typeName);
			}
			writer.WriteLine(L"");

			writer.WriteLine(L"/***********************************************************************");
			writer.WriteLine(L"Constructable Types");
			writer.WriteLine(L"***********************************************************************/");
			FOREACH(WString, typeName, constructableTypes)
			{
				writer.WriteLine(L"");
				LogInstanceLoaderManager_PrintConstructableType(writer, typeName);
			}
			writer.WriteLine(L"");

			writer.WriteLine(L"/***********************************************************************");
			writer.WriteLine(L"Unconstructable Parent Types");
			writer.WriteLine(L"***********************************************************************/");
			FOREACH(WString, typeName, unconstructableParentTypes)
			{
				writer.WriteLine(L"");
				LogInstanceLoaderManager_PrintUnconstructableParentType(writer, typeName);
			}
			writer.WriteLine(L"");

			writer.WriteLine(L"/***********************************************************************");
			writer.WriteLine(L"Unconstructable Virtualized Types");
			writer.WriteLine(L"***********************************************************************/");
			FOREACH(WString, typeName, virtualizedTypes)
			{
				writer.WriteLine(L"");
				LogInstanceLoaderManager_PrintVirtualizedType(writer, typeName);
			}
			writer.WriteLine(L"");

			writer.WriteLine(L"/***********************************************************************");
			writer.WriteLine(L"Unconstructable Types");
			writer.WriteLine(L"***********************************************************************/");
			FOREACH(WString, typeName, unconstructableTypes)
			{
				writer.WriteLine(L"");
				LogInstanceLoaderManager_PrintUnconstructableType(writer, typeName);
			}
			writer.WriteLine(L"");

			writer.WriteLine(L"/***********************************************************************");
			writer.WriteLine(L"Interface Types");
			writer.WriteLine(L"***********************************************************************/");
			FOREACH(WString, typeName, interfaceTypes)
			{
				writer.WriteLine(L"");
				LogInstanceLoaderManager_PrintInterfaceType(writer, typeName);
			}
			writer.WriteLine(L"");

			writer.WriteLine(L"/***********************************************************************");
			writer.WriteLine(L"Interface Constructable Types");
			writer.WriteLine(L"***********************************************************************/");
			FOREACH(WString, typeName, interfaceConstructableTypes)
			{
				writer.WriteLine(L"");
				LogInstanceLoaderManager_PrintInterfaceConstructableType(writer, typeName);
			}
			writer.WriteLine(L"");
		}
	}
}

/***********************************************************************
GUIINSTANCELOADER_PREDEFINEDINSTANCEBINDERS.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace reflection::description;
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace workflow::runtime;
		using namespace controls;

/***********************************************************************
GuiTextInstanceBinderBase
***********************************************************************/

		class GuiTextInstanceBinderBase : public Object, public IGuiInstanceBinder
		{
		protected:
			ITypeDescriptor*				stringTypeDescriptor;
		public:
			GuiTextInstanceBinderBase()
				:stringTypeDescriptor(description::GetTypeDescriptor<WString>())
			{
			}

			bool ApplicableToConstructorArgument()override
			{
				return false;
			}

			bool RequireInstanceName()override
			{
				return false;
			}

			void GetRequiredContexts(collections::List<GlobalStringKey>& contextNames)override
			{
			}

			void GetExpectedValueTypes(collections::List<description::ITypeDescriptor*>& expectedTypes)override
			{
				expectedTypes.Add(stringTypeDescriptor);
			}

			description::Value GetValue(Ptr<GuiInstanceEnvironment> env, const description::Value& propertyValue)override
			{
				return Value();
			}
		};

/***********************************************************************
GuiResourceInstanceBinder
***********************************************************************/

		class GuiResourceInstanceBinder : public GuiTextInstanceBinderBase
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Uri;
			}

			bool SetPropertyValue(Ptr<GuiInstanceEnvironment> env, IGuiInstanceLoader* loader, GlobalStringKey instanceName, IGuiInstanceLoader::PropertyValue& propertyValue)override
			{
				if (propertyValue.propertyValue.GetValueType() == Value::Text)
				{
					WString protocol, path;
					if (IsResourceUrl(propertyValue.propertyValue.GetText(), protocol, path))
					{
						if(Ptr<DescriptableObject> resource=env->resolver->ResolveResource(protocol, path))
						{
							Value value;
							if(Ptr<GuiTextData> text=resource.Cast<GuiTextData>())
							{
								value=Value::From(text->GetText(), stringTypeDescriptor);
							}
							else if(Ptr<DescriptableObject> obj=resource.Cast<DescriptableObject>())
							{
								if (auto image = obj.Cast<GuiImageData>())
								{
									auto td = propertyValue.typeInfo.typeDescriptor;
									if (auto prop = td->GetPropertyByName(propertyValue.propertyName.ToString(), true))
									{
										if (prop->GetReturn() && prop->GetReturn()->GetTypeDescriptor()->GetTypeName() == L"presentation::INativeImage")
										{
											obj = image->GetImage();
										}
									}
								}
								value = Value::From(obj);
							}

							if(!value.IsNull())
							{
								IGuiInstanceLoader::PropertyValue newValue = propertyValue;
								newValue.propertyValue = value;
								return loader->SetPropertyValue(newValue);
							}
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiReferenceInstanceBinder
***********************************************************************/

		class GuiReferenceInstanceBinder : public GuiTextInstanceBinderBase
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Ref;
			}

			bool SetPropertyValue(Ptr<GuiInstanceEnvironment> env, IGuiInstanceLoader* loader, GlobalStringKey instanceName, IGuiInstanceLoader::PropertyValue& propertyValue)override
			{
				if (propertyValue.propertyValue.GetValueType() == Value::Text)
				{
					GlobalStringKey name = GlobalStringKey::Get(propertyValue.propertyValue.GetText());
					vint index = env->scope->referenceValues.Keys().IndexOf(name);
					if (index != -1)
					{
						IGuiInstanceLoader::PropertyValue newValue = propertyValue;
						newValue.propertyValue = env->scope->referenceValues.Values()[index];
						if (!newValue.propertyValue.IsNull())
						{
							return loader->SetPropertyValue(newValue);
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiWorkflowGlobalContext
***********************************************************************/

		class GuiWorkflowGlobalContext : public Object, public IGuiInstanceBindingContext
		{
		public:
			List<WorkflowDataBinding>		dataBindings;
			Ptr<WfRuntimeGlobalContext>		globalContext;

			GuiWorkflowGlobalContext()
			{
			}

			GlobalStringKey GetContextName()override
			{
				return GuiWorkflowCache::CacheContextName;
			}

			void Initialize(Ptr<GuiInstanceEnvironment> env)override
			{
				Ptr<WfAssembly> assembly;
				vint cacheIndex = env->context->precompiledCaches.Keys().IndexOf(GetContextName());
				if (cacheIndex != -1)
				{
					assembly = env->context->precompiledCaches.Values()[cacheIndex].Cast<GuiWorkflowCache>()->assembly;
				}
				else
				{
					types::VariableTypeMap types;
					ITypeDescriptor* thisType = env->scope->rootInstance.GetTypeDescriptor();
					Workflow_GetVariableTypes(env, types);
					assembly = Workflow_CompileDataBinding(env->context, types, thisType, env->scope->errors, dataBindings);
					env->context->precompiledCaches.Add(GetContextName(), new GuiWorkflowCache(assembly));
				}

				if (assembly)
				{
					globalContext = new WfRuntimeGlobalContext(assembly);
				
					try
					{
						LoadFunction<void()>(globalContext, L"<initialize>")();
					}
					catch (const TypeDescriptorException& ex)
					{
						env->scope->errors.Add(L"Workflow Script Exception: " + ex.Message());
					}

					Workflow_SetVariablesForReferenceValues(globalContext, env);
					{
						vint index = assembly->variableNames.IndexOf(L"<this>");
						globalContext->globalVariables->variables[index] = env->scope->rootInstance;
					}

					try
					{
						LoadFunction<void()>(globalContext, L"<initialize-data-binding>")();
					}
					catch (const TypeDescriptorException& ex)
					{
						env->scope->errors.Add(L"Workflow Script Exception: " + ex.Message());
					}
				}
			}
		};

/***********************************************************************
GuiScriptInstanceBinder
***********************************************************************/

		class GuiScriptInstanceBinder : public GuiTextInstanceBinderBase
		{
		public:
			virtual WString TranslateExpression(const WString& input) = 0;

			bool RequireInstanceName()override
			{
				return true;
			}

			void GetRequiredContexts(collections::List<GlobalStringKey>& contextNames)override
			{
				contextNames.Add(GuiWorkflowCache::CacheContextName);
			}

			bool SetPropertyValue(Ptr<GuiInstanceEnvironment> env, IGuiInstanceLoader* loader, GlobalStringKey instanceName, IGuiInstanceLoader::PropertyValue& propertyValue)override
			{
				auto context = env->scope->bindingContexts[GuiWorkflowCache::CacheContextName].Cast<GuiWorkflowGlobalContext>();
				WorkflowDataBinding dataBinding;
				dataBinding.variableName = instanceName;

				if (env->context->precompiledCaches.Keys().Contains(GuiWorkflowCache::CacheContextName))
				{
					goto SUCCESS;
				}
				if (propertyValue.propertyValue.GetValueType() == Value::Text)
				{
					WString expressionCode = TranslateExpression(propertyValue.propertyValue.GetText());
					Ptr<WfExpression> expression;
					types::VariableTypeMap types;
					Workflow_GetVariableTypes(env, types);
					if (Workflow_ValidateExpression(env->context, types, env->scope->errors, propertyValue, expressionCode, expression))
					{
						auto expr = expression;
						if (auto bind = expr.Cast<WfBindExpression>())
						{
							bind->expandedExpression = 0;
							expr = bind->expression;
						}
						if (auto format = expr.Cast<WfFormatExpression>())
						{
							format->expandedExpression = 0;
						}
						
						auto td = propertyValue.typeInfo.typeDescriptor;
						auto propertyInfo = td->GetPropertyByName(propertyValue.propertyName.ToString(), true);
						dataBinding.propertyInfo = propertyInfo;
						dataBinding.bindExpression = expression;
						goto SUCCESS;
					}
					else
					{
						goto FAILED;
					}
				}

			FAILED:
				context->dataBindings.Add(dataBinding);
				return false;
			SUCCESS:
				context->dataBindings.Add(dataBinding);
				return true;
			}
		};

/***********************************************************************
GuiEvalInstanceBinder
***********************************************************************/

		class GuiEvalInstanceBinder : public GuiScriptInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Eval;
			}

			bool ApplicableToConstructorArgument()override
			{
				return true;
			}

			description::Value GetValue(Ptr<GuiInstanceEnvironment> env, const description::Value& propertyValue)override
			{
				if (propertyValue.GetValueType() == Value::Text)
				{
					Ptr<WfAssembly> assembly;
					WString expressionCode = TranslateExpression(propertyValue.GetText());
					GlobalStringKey cacheKey = GlobalStringKey::Get(L"<att.eval>" + expressionCode);
					vint cacheIndex = env->context->precompiledCaches.Keys().IndexOf(cacheKey);
					if (cacheIndex != -1)
					{
						assembly = env->context->precompiledCaches.Values()[cacheIndex].Cast<GuiWorkflowCache>()->assembly;
					}
					else
					{
						types::VariableTypeMap types;
						Workflow_GetVariableTypes(env, types);
						assembly = Workflow_CompileExpression(env->context, types, env->scope->errors, expressionCode);
						env->context->precompiledCaches.Add(cacheKey, new GuiWorkflowCache(assembly));
					}

					if (assembly)
					{
						auto globalContext = MakePtr<WfRuntimeGlobalContext>(assembly);
				
						try
						{
							LoadFunction<void()>(globalContext, L"<initialize>")();
						}
						catch (const TypeDescriptorException& ex)
						{
							env->scope->errors.Add(L"Workflow Script Exception: " + ex.Message());
						}

						Workflow_SetVariablesForReferenceValues(globalContext, env);
						vint variableIndex = assembly->variableNames.IndexOf(L"<initialize-data-binding>");
						auto variable = globalContext->globalVariables->variables[variableIndex];
						auto proxy = UnboxValue<Ptr<IValueFunctionProxy>>(variable);

						Value translated;
						try
						{
							translated = proxy->Invoke(IValueList::Create());
						}
						catch (const TypeDescriptorException& ex)
						{
							env->scope->errors.Add(L"Workflow Script Exception: " + ex.Message());
						}

						// the global context contains a closure variable <initialize-data-binding> which captured the context
						// clear all variables to break the circle references
						globalContext->globalVariables = 0;
						return translated;
					}
				}
				return Value();
			}

			WString TranslateExpression(const WString& input)override
			{
				return input;
			}
		};

/***********************************************************************
GuiEvalInstanceEventBinder
***********************************************************************/

		class GuiEvalInstanceEventBinder : public Object, public IGuiInstanceEventBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Eval;
			}

			bool RequireInstanceName()override
			{
				return true;
			}

			void GetRequiredContexts(collections::List<GlobalStringKey>& contextNames)override
			{
			}

			bool AttachEvent(Ptr<GuiInstanceEnvironment> env, IGuiInstanceLoader* loader, GlobalStringKey instanceName, IGuiInstanceLoader::PropertyValue& propertyValue)
			{
				auto handler = propertyValue.propertyValue;
				if (handler.GetValueType() == Value::Text)
				{
					Ptr<WfAssembly> assembly;
					WString statementCode = handler.GetText();
					GlobalStringKey cacheKey = GlobalStringKey::Get(L"<ev.eval><" + instanceName.ToString() + L"><" + propertyValue.propertyName.ToString() + L">" + statementCode);
					vint cacheIndex = env->context->precompiledCaches.Keys().IndexOf(cacheKey);
					if (cacheIndex != -1)
					{
						assembly = env->context->precompiledCaches.Values()[cacheIndex].Cast<GuiWorkflowCache>()->assembly;
					}
					else
					{
						types::VariableTypeMap types;
						Workflow_GetVariableTypes(env, types);
						assembly = Workflow_CompileEventHandler(env->context, types, env->scope->errors, propertyValue, statementCode);
						env->context->precompiledCaches.Add(cacheKey, new GuiWorkflowCache(assembly));
					}

					if (assembly)
					{
						auto globalContext = MakePtr<WfRuntimeGlobalContext>(assembly);
				
						try
						{
							LoadFunction<void()>(globalContext, L"<initialize>")();
						}
						catch (const TypeDescriptorException& ex)
						{
							env->scope->errors.Add(L"Workflow Script Exception: " + ex.Message());
						}

						Workflow_SetVariablesForReferenceValues(globalContext, env);
						auto eventHandler = LoadFunction(globalContext, L"<event-handler>");
						handler = BoxValue(eventHandler);

						propertyValue.propertyValue = handler;
						return loader->SetEventValue(propertyValue);
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiBindInstanceBinder
***********************************************************************/

		class GuiBindInstanceBinder : public GuiScriptInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Bind;
			}

			WString TranslateExpression(const WString& input)override
			{
				return L"bind(" + input + L")";
			}
		};

/***********************************************************************
GuiFormatInstanceBinder
***********************************************************************/

		class GuiFormatInstanceBinder : public GuiScriptInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Format;
			}

			WString TranslateExpression(const WString& input)override
			{
				return L"bind($\"" + input + L"\")";
			}
		};

/***********************************************************************
GuiPredefinedInstanceBindersPlugin
***********************************************************************/

		class GuiPredefinedInstanceBindersPlugin : public Object, public IGuiPlugin
		{
		public:
			GuiPredefinedInstanceBindersPlugin()
			{
			}

			void Load()override
			{
				WfLoadTypes();
				GuiIqLoadTypes();
			}

			void AfterLoad()override
			{
				{
					IGuiParserManager* manager = GetParserManager();
					manager->SetParsingTable(L"WORKFLOW", &WfLoadTable);
					manager->SetTableParser(L"WORKFLOW", L"WORKFLOW-EXPRESSION", &WfParseExpression);
					manager->SetTableParser(L"WORKFLOW", L"WORKFLOW-STATEMENT", &WfParseStatement);
					manager->SetTableParser(L"WORKFLOW", L"WORKFLOW-MODULE", &WfParseModule);
					manager->SetParsingTable(L"INSTANCE-QUERY", &GuiIqLoadTable);
					manager->SetTableParser(L"INSTANCE-QUERY", L"INSTANCE-QUERY", &GuiIqParse);
				}
				{
					IGuiInstanceLoaderManager* manager=GetInstanceLoaderManager();

					manager->AddInstanceBindingContextFactory(new GuiInstanceBindingContextFactory<GuiWorkflowGlobalContext>(GuiWorkflowCache::CacheContextName));

					manager->AddInstanceBinder(new GuiResourceInstanceBinder);
					manager->AddInstanceBinder(new GuiReferenceInstanceBinder);
					manager->AddInstanceBinder(new GuiEvalInstanceBinder);
					manager->AddInstanceEventBinder(new GuiEvalInstanceEventBinder);
					manager->AddInstanceBinder(new GuiBindInstanceBinder);
					manager->AddInstanceBinder(new GuiFormatInstanceBinder);
				}
			}

			void Unload()override
			{
			}
		};
		GUI_REGISTER_PLUGIN(GuiPredefinedInstanceBindersPlugin)
	}
}

/***********************************************************************
GUIINSTANCELOADER_PREDEFINEDINSTANCELOADERS.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace reflection::description;
		using namespace controls;
		using namespace compositions;
		using namespace theme;
		using namespace helper_types;

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
GuiVrtualTypeInstanceLoader
***********************************************************************/

		class GuiTemplateControlInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey								typeName;
			Func<Value()>								defaultConstructor;
			Func<Value(Ptr<GuiTemplate::IFactory>)>		templateConstructor;
		public:
			GuiTemplateControlInstanceLoader(const WString& _typeName, const Func<Value()>& _defaultConstructor, const Func<Value(Ptr<GuiTemplate::IFactory>)>& _templateConstructor)
				:typeName(GlobalStringKey::Get(_typeName))
				, defaultConstructor(_defaultConstructor)
				, templateConstructor(_templateConstructor)
			{
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeName == typeInfo.typeName;
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if(typeName==typeInfo.typeName)
				{
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						return defaultConstructor();
					}
					else
					{
						auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						return templateConstructor(factory);
					}
				}
				return Value();
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ControlTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return 0;
			}
		};

/***********************************************************************
GuiControlInstanceLoader
***********************************************************************/

		class GuiControlInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiControlInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiControl>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::Empty);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					auto info = GuiInstancePropertyInfo::Collection();
					info->acceptableTypes.Add(description::GetTypeDescriptor<GuiControl>());
					info->acceptableTypes.Add(description::GetTypeDescriptor<GuiGraphicsComposition>());
					if (propertyInfo.typeInfo.typeDescriptor->CanConvertTo(description::GetTypeDescriptor<GuiInstanceRootObject>()))
					{
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiComponent>());
					}
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiInstanceRootObject*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto component = dynamic_cast<GuiComponent*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->AddComponent(component);
							return true;
						}
						else if (auto controlHost = dynamic_cast<GuiControlHost*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->AddComponent(new GuiObjectComponent<GuiControlHost>(controlHost));
							return true;
						}
					}
				}
				if (auto container = dynamic_cast<GuiControl*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto control = dynamic_cast<GuiControl*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->AddChild(control);
							return true;
						}
						else if (auto composition = dynamic_cast<GuiGraphicsComposition*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->GetContainerComposition()->AddChild(composition);
							return true;
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiTabInstanceLoader
***********************************************************************/

		class GuiTabInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiTabInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiTab>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return GetTypeName() == typeInfo.typeName;
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if(GetTypeName() == typeInfo.typeName)
				{
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						return Value::From(g::NewTab());
					}
					else
					{
						auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						return Value::From(new GuiTab(new GuiTabTemplate_StyleProvider(factory)));
					}
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::Empty);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ControlTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiTabPage>());
				}
				else if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiTab*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto tabPage = dynamic_cast<GuiTabPage*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->CreatePage(tabPage);
							return true;
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiTabPageInstanceLoader
***********************************************************************/

		class GuiTabPageInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiTabPageInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiTabPage>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::Empty);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					auto info = GuiInstancePropertyInfo::Collection();
					info->acceptableTypes.Add(description::GetTypeDescriptor<GuiControl>());
					info->acceptableTypes.Add(description::GetTypeDescriptor<GuiGraphicsComposition>());
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiTabPage*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto control = dynamic_cast<GuiControl*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->GetContainerComposition()->AddChild(control->GetBoundsComposition());
							return true;
						}
						else if (auto composition = dynamic_cast<GuiGraphicsComposition*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->GetContainerComposition()->AddChild(composition);
							return true;
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiToolstripMenuInstanceLoader
***********************************************************************/

		class GuiToolstripMenuInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiToolstripMenuInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiToolstripMenu>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return GetTypeName() == typeInfo.typeName;
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if(GetTypeName() == typeInfo.typeName)
				{
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						return Value::From(g::NewMenu(0));
					}
					else
					{
						auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						return Value::From(new GuiToolstripMenu(new GuiMenuTemplate_StyleProvider(factory), 0));
					}
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::Empty);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ControlTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiControl>());
				}
				else if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiToolstripMenu*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto control = dynamic_cast<GuiControl*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->GetToolstripItems().Add(control);
							return true;
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiToolstripMenuBarInstanceLoader
***********************************************************************/

		class GuiToolstripMenuBarInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiToolstripMenuBarInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiToolstripMenuBar>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return GetTypeName() == typeInfo.typeName;
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if(GetTypeName() == typeInfo.typeName)
				{
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						return Value::From(new GuiToolstripMenuBar(GetCurrentTheme()->CreateMenuBarStyle()));
					}
					else
					{
						auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						return Value::From(new GuiToolstripMenuBar(new GuiControlTemplate_StyleProvider(factory)));
					}
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::Empty);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ControlTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiControl>());
				}
				else if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiToolstripMenuBar*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto control = dynamic_cast<GuiControl*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->GetToolstripItems().Add(control);
							return true;
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiToolstripToolBarInstanceLoader
***********************************************************************/

		class GuiToolstripToolBarInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiToolstripToolBarInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiToolstripToolBar>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return GetTypeName() == typeInfo.typeName;
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if(GetTypeName() == typeInfo.typeName)
				{
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						return Value::From(new GuiToolstripToolBar(GetCurrentTheme()->CreateToolBarStyle()));
					}
					else
					{
						auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						return Value::From(new GuiToolstripToolBar(new GuiControlTemplate_StyleProvider(factory)));
					}
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::Empty);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ControlTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiControl>());
				}
				else if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiToolstripToolBar*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto control = dynamic_cast<GuiControl*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->GetToolstripItems().Add(control);
							return true;
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiToolstripButtonInstanceLoader
***********************************************************************/

		class GuiToolstripButtonInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;
			GlobalStringKey					_SubMenu;

		public:
			GuiToolstripButtonInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiToolstripButton>()->GetTypeName());
				_SubMenu = GlobalStringKey::Get(L"SubMenu");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == GetTypeName();
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						return Value::From(g::NewToolBarButton());
					}
					else
					{
						auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						return Value::From(new GuiToolstripButton(new GuiToolstripButtonTemplate_StyleProvider(factory)));
					}
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(_SubMenu);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ControlTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				else if (propertyInfo.propertyName == _SubMenu)
				{
					return GuiInstancePropertyInfo::Set(description::GetTypeDescriptor<GuiToolstripMenu>());
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool GetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiToolstripButton*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == _SubMenu)
					{
						if (!container->GetToolstripSubMenu())
						{
							container->CreateToolstripSubMenu();
						}
						propertyValue.propertyValue = Value::From(container->GetToolstripSubMenu());
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiSelectableListControlInstanceLoader
***********************************************************************/

		class GuiSelectableListControlInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiSelectableListControlInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiSelectableListControl>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ItemTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::_ItemTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiSelectableListControl*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::_ItemTemplate)
					{
						auto factory = CreateTemplateFactory(propertyValue.propertyValue.GetText());
						auto styleProvider = new GuiListItemTemplate_ItemStyleProvider(factory);
						container->SetStyleProvider(styleProvider);
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiVirtualTreeViewInstanceLoader
***********************************************************************/

		class GuiVirtualTreeViewInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiVirtualTreeViewInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiVirtualTreeView>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::_ItemTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::_ItemTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiVirtualTreeListControl*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::_ItemTemplate)
					{
						auto factory = CreateTemplateFactory(propertyValue.propertyValue.GetText());
						auto styleProvider = new GuiTreeItemTemplate_ItemStyleProvider(factory);
						container->SetNodeStyleProvider(styleProvider);
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiListViewInstanceLoader
***********************************************************************/

		class GuiListViewInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			bool				bindable;
			GlobalStringKey		typeName;
			GlobalStringKey		_View, _IconSize, _ItemSource;

		public:
			GuiListViewInstanceLoader(bool _bindable)
				:bindable(_bindable)
			{
				if (bindable)
				{
					typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiBindableListView>()->GetTypeName());
				}
				else
				{
					typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiListView>()->GetTypeName());
				}
				_View = GlobalStringKey::Get(L"View");
				_IconSize = GlobalStringKey::Get(L"IconSize");
				_ItemSource = GlobalStringKey::Get(L"ItemSource");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == GetTypeName();
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					Ptr<IValueEnumerable> itemSource;
					ListViewViewType viewType = ListViewViewType::Detail;
					GuiListViewBase::IStyleProvider* styleProvider = 0;
					Size iconSize;
					{
						vint indexItemSource = constructorArguments.Keys().IndexOf(_ItemSource);
						if (indexItemSource != -1)
						{
							itemSource = UnboxValue<Ptr<IValueEnumerable>>(constructorArguments.GetByIndex(indexItemSource)[0]);
						}
						else if (bindable)
						{
							return Value();
						}

						vint indexView = constructorArguments.Keys().IndexOf(_View);
						if (indexView != -1)
						{
							viewType = UnboxValue<ListViewViewType>(constructorArguments.GetByIndex(indexView)[0]);
						}

						vint indexIconSize = constructorArguments.Keys().IndexOf(_IconSize);
						if (indexIconSize != -1)
						{
							iconSize = UnboxValue<Size>(constructorArguments.GetByIndex(indexIconSize)[0]);
						}

						vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
						if (indexControlTemplate == -1)
						{
							styleProvider = GetCurrentTheme()->CreateListViewStyle();
						}
						else
						{
							auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
							styleProvider = new GuiListViewTemplate_StyleProvider(factory);
						}
					}

					GuiVirtualListView* listView = 0;
					if (bindable)
					{
						listView = new GuiBindableListView(styleProvider, itemSource);
					}
					else
					{
						listView = new GuiListView(styleProvider);
					}
					switch (viewType)
					{
#define VIEW_TYPE_CASE(NAME)\
					case ListViewViewType::NAME:\
						if (iconSize == Size())\
						{\
							listView->ChangeItemStyle(new list::ListView##NAME##ContentProvider);\
						}\
						else\
						{\
							listView->ChangeItemStyle(new list::ListView##NAME##ContentProvider(iconSize, false));\
						}\
						break;\

						VIEW_TYPE_CASE(BigIcon)
						VIEW_TYPE_CASE(SmallIcon)
						VIEW_TYPE_CASE(List)
						VIEW_TYPE_CASE(Tile)
						VIEW_TYPE_CASE(Information)
						VIEW_TYPE_CASE(Detail)

#undef VIEW_TYPE_CASE
					}

					return Value::From(listView);
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					propertyNames.Add(GlobalStringKey::_ControlTemplate);
					propertyNames.Add(_View);
					propertyNames.Add(_IconSize);
					if (bindable)
					{
						propertyNames.Add(_ItemSource);
					}
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				else if (propertyInfo.propertyName == _View)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<ListViewViewType>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				else if (propertyInfo.propertyName == _IconSize)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Size>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				else if (propertyInfo.propertyName == _ItemSource)
				{
					if (bindable)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<IValueEnumerable>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						info->required = true;
						return info;
					}
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				return false;
			}
		};

/***********************************************************************
GuiTreeViewInstanceLoader
***********************************************************************/

		class GuiTreeViewInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			bool				bindable;
			GlobalStringKey		typeName;
			GlobalStringKey		_IconSize, _ItemSource, _Nodes;

		public:
			GuiTreeViewInstanceLoader(bool _bindable)
				:bindable(_bindable)
			{
				if (bindable)
				{
					typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiBindableTreeView>()->GetTypeName());
				}
				else
				{
					typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiTreeView>()->GetTypeName());
				}
				_IconSize = GlobalStringKey::Get(L"IconSize");
				_ItemSource = GlobalStringKey::Get(L"ItemSource");
				_Nodes = GlobalStringKey::Get(L"Nodes");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == GetTypeName();
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					vint indexItemSource = constructorArguments.Keys().IndexOf(_ItemSource);
					GuiVirtualTreeView::IStyleProvider* styleProvider = 0;
					{
						vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
						if (indexControlTemplate == -1)
						{
							styleProvider = GetCurrentTheme()->CreateTreeViewStyle();
						}
						else
						{
							auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
							styleProvider = new GuiTreeViewTemplate_StyleProvider(factory);
						}
					}

					GuiVirtualTreeView* treeView = 0;
					if (bindable)
					{
						if (indexItemSource == -1)
						{
							return Value();
						}

						auto itemSource = constructorArguments.GetByIndex(indexItemSource)[0];
						treeView = new GuiBindableTreeView(styleProvider, itemSource);
					}
					else
					{
						treeView = new GuiTreeView(styleProvider);
					}

					vint indexIconSize = constructorArguments.Keys().IndexOf(_IconSize);
					if (indexIconSize != -1)
					{
						auto iconSize = UnboxValue<Size>(constructorArguments.GetByIndex(indexIconSize)[0]);
						treeView->SetNodeStyleProvider(new tree::TreeViewNodeItemStyleProvider(iconSize, false));
					}

					return Value::From(treeView);
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (!bindable)
				{
					propertyNames.Add(_Nodes);
				}
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					propertyNames.Add(GlobalStringKey::_ControlTemplate);
					propertyNames.Add(_IconSize);
					if (bindable)
					{
						propertyNames.Add(_ItemSource);
					}
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == _Nodes)
				{
					if (!bindable)
					{
						return GuiInstancePropertyInfo::Collection(description::GetTypeDescriptor<tree::MemoryNodeProvider>());
					}
				}
				else if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				else if (propertyInfo.propertyName == _ItemSource)
				{
					if (bindable)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Value>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						info->required = true;
						return info;
					}
				}
				else if (propertyInfo.propertyName == _IconSize)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Size>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiTreeView*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == _Nodes)
					{
						auto item = UnboxValue<Ptr<tree::MemoryNodeProvider>>(propertyValue.propertyValue);
						container->Nodes()->Children().Add(item);
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiComboBoxInstanceLoader
***********************************************************************/

		class GuiComboBoxInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey						typeName;
			GlobalStringKey						_ListControl;

		public:
			GuiComboBoxInstanceLoader()
				:typeName(GlobalStringKey::Get(L"presentation::controls::GuiComboBox"))
			{
				_ListControl = GlobalStringKey::Get(L"ListControl");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == GetTypeName();
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					vint indexListControl = constructorArguments.Keys().IndexOf(_ListControl);
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexListControl != -1)
					{
						Ptr<GuiTemplate::IFactory> factory;
						if (indexControlTemplate != -1)
						{
							factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						}

						GuiComboBoxBase::IStyleController* styleController = 0;
						if (factory)
						{
							styleController = new GuiComboBoxTemplate_StyleProvider(factory);
						}
						else
						{
							styleController = GetCurrentTheme()->CreateComboBoxStyle();
						}

						auto listControl = UnboxValue<GuiSelectableListControl*>(constructorArguments.GetByIndex(indexListControl)[0]);
						auto comboBox = new GuiComboBoxListControl(styleController, listControl);
						return Value::From(comboBox);
					}
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					propertyNames.Add(_ListControl);
				}
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					propertyNames.Add(GlobalStringKey::_ControlTemplate);
					propertyNames.Add(_ListControl);
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == _ListControl)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<GuiSelectableListControl>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					info->required = true;
					return info;
				}
				else if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}
		};

/***********************************************************************
GuiBindableTextListInstanceLoader
***********************************************************************/

		class GuiBindableTextListInstanceLoader : public Object, public IGuiInstanceLoader
		{
			typedef Func<list::TextItemStyleProvider::ITextItemStyleProvider*()>		ItemStyleProviderFactory;
		protected:
			GlobalStringKey					typeName;
			ItemStyleProviderFactory		itemStyleProviderFactory;
			GlobalStringKey					_ItemSource;

		public:
			GuiBindableTextListInstanceLoader(const WString& type, const ItemStyleProviderFactory& factory)
				:typeName(GlobalStringKey::Get(L"presentation::controls::GuiBindable" + type + L"TextList"))
				, itemStyleProviderFactory(factory)
			{
				_ItemSource = GlobalStringKey::Get(L"ItemSource");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == GetTypeName();
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					vint indexItemSource = constructorArguments.Keys().IndexOf(_ItemSource);
					if (indexItemSource != -1)
					{
						GuiTextListTemplate_StyleProvider* styleProvider = 0;
						{
							vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
							if (indexControlTemplate != -1)
							{
								auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
								styleProvider = new GuiTextListTemplate_StyleProvider(factory);
							}
						}

						auto itemSource = UnboxValue<Ptr<IValueEnumerable>>(constructorArguments.GetByIndex(indexItemSource)[0]);
						GuiBindableTextList* control = 0;
						if (styleProvider)
						{
							control = new GuiBindableTextList(styleProvider, styleProvider->CreateArgument(), itemSource);
						}
						else
						{
							control = new GuiBindableTextList(GetCurrentTheme()->CreateTextListStyle(), itemStyleProviderFactory(), itemSource);
						}
						return Value::From(control);
					}
				}
				return Value();
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					propertyNames.Add(GlobalStringKey::_ControlTemplate);
					propertyNames.Add(_ItemSource);
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				if (propertyInfo.propertyName == _ItemSource)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<IValueEnumerable>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					info->required = true;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}
		};

/***********************************************************************
GuiBindableDataColumnInstanceLoader
***********************************************************************/

		class GuiBindableDataColumnInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey		typeName;
			GlobalStringKey		_VisualizerTemplates;
			GlobalStringKey		_EditorTemplate;

		public:
			GuiBindableDataColumnInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<list::BindableDataColumn>()->GetTypeName());
				_VisualizerTemplates = GlobalStringKey::Get(L"VisualizerTemplates");
				_EditorTemplate = GlobalStringKey::Get(L"EditorTemplate");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(_VisualizerTemplates);
				propertyNames.Add(_EditorTemplate);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == _VisualizerTemplates)
				{
					return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
				}
				else if (propertyInfo.propertyName == _EditorTemplate)
				{
					return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<list::BindableDataColumn*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == _VisualizerTemplates)
					{
						List<WString> types;
						SplitBySemicolon(propertyValue.propertyValue.GetText(), types);
						Ptr<list::IDataVisualizerFactory> factory;
						FOREACH(WString, type, types)
						{
							auto templateFactory = CreateTemplateFactory(type);
							if (factory)
							{
								factory = new GuiBindableDataVisualizer::DecoratedFactory(templateFactory, container, factory);
							}
							else
							{
								factory = new GuiBindableDataVisualizer::Factory(templateFactory, container);
							}
						}

						container->SetVisualizerFactory(factory);
						return true;
					}
					else if (propertyValue.propertyName == _EditorTemplate)
					{
						auto templateFactory = CreateTemplateFactory(propertyValue.propertyValue.GetText());
						auto factory = new GuiBindableDataEditor::Factory(templateFactory, container);
						container->SetEditorFactory(factory);
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiBindableDataGridInstanceLoader
***********************************************************************/

		class GuiBindableDataGridInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey		typeName;
			GlobalStringKey		_ItemSource;
			GlobalStringKey		_ViewModelContext;
			GlobalStringKey		_Columns;

		public:
			GuiBindableDataGridInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiBindableDataGrid>()->GetTypeName());
				_ItemSource = GlobalStringKey::Get(L"ItemSource");
				_ViewModelContext = GlobalStringKey::Get(L"ViewModelContext");
				_Columns = GlobalStringKey::Get(L"Columns");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == GetTypeName();
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					vint indexItemSource = constructorArguments.Keys().IndexOf(_ItemSource);	
					if (indexItemSource == -1)
					{
						return Value();
					}

					GuiBindableDataGrid::IStyleProvider* styleProvider = 0;
					vint indexControlTemplate = constructorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
					if (indexControlTemplate == -1)
					{
						styleProvider = GetCurrentTheme()->CreateListViewStyle();
					}
					else
					{
						auto factory = CreateTemplateFactory(constructorArguments.GetByIndex(indexControlTemplate)[0].GetText());
						styleProvider = new GuiListViewTemplate_StyleProvider(factory);
					}
					
					auto itemSource = UnboxValue<Ptr<IValueEnumerable>>(constructorArguments.GetByIndex(indexItemSource)[0]);

					Value viewModelContext;
					vint indexViewModelContext = constructorArguments.Keys().IndexOf(_ViewModelContext);
					if (indexViewModelContext != -1)
					{
						viewModelContext = constructorArguments.GetByIndex(indexViewModelContext)[0];
					}

					auto dataGrid = new GuiBindableDataGrid(styleProvider, itemSource, viewModelContext);
					return Value::From(dataGrid);
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(_Columns);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					propertyNames.Add(GlobalStringKey::_ControlTemplate);
					propertyNames.Add(_ItemSource);
					propertyNames.Add(_ViewModelContext);
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == _Columns)
				{
					return GuiInstancePropertyInfo::Collection(description::GetTypeDescriptor<list::BindableDataColumn>());
				}
				else if (propertyInfo.propertyName == GlobalStringKey::_ControlTemplate)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				else if (propertyInfo.propertyName == _ItemSource)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<IValueEnumerable>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					info->required = true;
					return info;
				}
				else if (propertyInfo.propertyName == _ViewModelContext)
				{
					auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Value>());
					info->scope = GuiInstancePropertyInfo::Constructor;
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiBindableDataGrid*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == _Columns)
					{
						auto column = UnboxValue<Ptr<list::BindableDataColumn>>(propertyValue.propertyValue);
						container->AddBindableColumn(column);
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiCompositionInstanceLoader
***********************************************************************/

		class GuiCompositionInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;

		public:
			GuiCompositionInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiGraphicsComposition>()->GetTypeName());
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(GlobalStringKey::Empty);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					auto info = GuiInstancePropertyInfo::Collection();
					info->acceptableTypes.Add(description::GetTypeDescriptor<GuiControl>());
					info->acceptableTypes.Add(description::GetTypeDescriptor<GuiGraphicsComposition>());
					info->acceptableTypes.Add(description::GetTypeDescriptor<IGuiGraphicsElement>());
					return info;
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiGraphicsComposition*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						if (auto control = dynamic_cast<GuiControl*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->AddChild(control->GetBoundsComposition());
							return true;
						}
						else if(auto composition = dynamic_cast<GuiGraphicsComposition*>(propertyValue.propertyValue.GetRawPtr()))
						{
							container->AddChild(composition);
							return true;
						}
						else if (Ptr<IGuiGraphicsElement> element = propertyValue.propertyValue.GetSharedPtr().Cast<IGuiGraphicsElement>())
						{
							container->SetOwnedElement(element);
							return true;
						}
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiTableCompositionInstanceLoader
***********************************************************************/

		class GuiTableCompositionInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;
			GlobalStringKey					_Rows, _Columns;

		public:
			GuiTableCompositionInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiTableComposition>()->GetTypeName());
				_Rows = GlobalStringKey::Get(L"Rows");
				_Columns = GlobalStringKey::Get(L"Columns");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(_Rows);
				propertyNames.Add(_Columns);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == _Rows || propertyInfo.propertyName == _Columns)
				{
					return GuiInstancePropertyInfo::Array(description::GetTypeDescriptor<GuiCellOption>());
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiTableComposition*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == _Rows)
					{
						List<GuiCellOption> options;
						CopyFrom(options, GetLazyList<GuiCellOption>(UnboxValue<Ptr<IValueList>>(propertyValue.propertyValue)));
						container->SetRowsAndColumns(options.Count(), container->GetColumns());
						FOREACH_INDEXER(GuiCellOption, option, index, options)
						{
							container->SetRowOption(index, option);
						}
						return true;
					}
					else if (propertyValue.propertyName == _Columns)
					{
						List<GuiCellOption> options;
						CopyFrom(options, GetLazyList<GuiCellOption>(UnboxValue<Ptr<IValueList>>(propertyValue.propertyValue)));
						container->SetRowsAndColumns(container->GetRows(), options.Count());
						FOREACH_INDEXER(GuiCellOption, option, index, options)
						{
							container->SetColumnOption(index, option);
						}
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiCellCompositionInstanceLoader
***********************************************************************/

		class GuiCellCompositionInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey					typeName;
			GlobalStringKey					_Site;

		public:
			GuiCellCompositionInstanceLoader()
			{
				typeName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiCellComposition>()->GetTypeName());
				_Site = GlobalStringKey::Get(L"Site");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(_Site);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == _Site)
				{
					return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<SiteValue>());
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<GuiCellComposition*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == _Site)
					{
						SiteValue site = UnboxValue<SiteValue>(propertyValue.propertyValue);
						container->SetSite(site.row, site.column, site.rowSpan, site.columnSpan);
						return true;
					}
				}
				return false;
			}
		};

/***********************************************************************
GuiTreeNodeInstanceLoader
***********************************************************************/

		class GuiTreeNodeInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			GlobalStringKey							typeName;
			GlobalStringKey							_Text, _Image, _Tag;

		public:
			GuiTreeNodeInstanceLoader()
				:typeName(GlobalStringKey::Get(L"presentation::controls::tree::TreeNode"))
			{
				_Text = GlobalStringKey::Get(L"Text");
				_Image = GlobalStringKey::Get(L"Image");
				_Tag = GlobalStringKey::Get(L"Tag");
			}

			GlobalStringKey GetTypeName()override
			{
				return typeName;
			}

			bool IsCreatable(const TypeInfo& typeInfo)override
			{
				return typeInfo.typeName == GetTypeName();
			}

			description::Value CreateInstance(Ptr<GuiInstanceEnvironment> env, const TypeInfo& typeInfo, collections::Group<GlobalStringKey, description::Value>& constructorArguments)override
			{
				if (typeInfo.typeName == GetTypeName())
				{
					Ptr<tree::TreeViewItem> item = new tree::TreeViewItem;
					Ptr<tree::MemoryNodeProvider> node = new tree::MemoryNodeProvider(item);
					return Value::From(node);
				}
				return Value();
			}

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				propertyNames.Add(_Text);
				propertyNames.Add(_Image);
				propertyNames.Add(_Tag);
				propertyNames.Add(GlobalStringKey::Empty);
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				if (propertyInfo.propertyName == _Text)
				{
					return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
				}
				else if (propertyInfo.propertyName == _Image)
				{
					return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<GuiImageData>());
				}
				else if (propertyInfo.propertyName == _Tag)
				{
					return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Value>());
				}
				else if (propertyInfo.propertyName == GlobalStringKey::Empty)
				{
					return GuiInstancePropertyInfo::Collection(description::GetTypeDescriptor<tree::MemoryNodeProvider>());
				}
				return IGuiInstanceLoader::GetPropertyType(propertyInfo);
			}

			bool SetPropertyValue(PropertyValue& propertyValue)override
			{
				if (auto container = dynamic_cast<tree::MemoryNodeProvider*>(propertyValue.instanceValue.GetRawPtr()))
				{
					if (propertyValue.propertyName == _Text)
					{
						if (auto item = container->GetData().Cast<tree::TreeViewItem>())
						{
							item->text = UnboxValue<WString>(propertyValue.propertyValue);
							container->NotifyDataModified();
							return true;
						}
					}
					else if (propertyValue.propertyName == _Image)
					{
						if (auto item = container->GetData().Cast<tree::TreeViewItem>())
						{
							item->image = UnboxValue<Ptr<GuiImageData>>(propertyValue.propertyValue);
							container->NotifyDataModified();
							return true;
						}
					}
					else if (propertyValue.propertyName == _Tag)
					{
						if (auto item = container->GetData().Cast<tree::TreeViewItem>())
						{
							item->tag = propertyValue.propertyValue;
							return true;
						}
					}
					else if (propertyValue.propertyName == GlobalStringKey::Empty)
					{
						auto item = UnboxValue<Ptr<tree::MemoryNodeProvider>>(propertyValue.propertyValue);
						container->Children().Add(item);
						return true;
					}
				}
				return false;
			}
		};

#endif

/***********************************************************************
GuiPredefinedInstanceLoadersPlugin
***********************************************************************/

		void InitializeTrackerProgressBar(GuiScroll* control)
		{
			control->SetPageSize(0);
		}

		class GuiPredefinedInstanceLoadersPlugin : public Object, public IGuiPlugin
		{
		public:
			void Load()override
			{
			}

			void AfterLoad()override
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				IGuiInstanceLoaderManager* manager=GetInstanceLoaderManager();

#define ADD_VIRTUAL_TYPE_LOADER(TYPENAME, LOADER)\
	manager->CreateVirtualType(\
		GlobalStringKey::Get(description::GetTypeDescriptor<TYPENAME>()->GetTypeName()),\
		new LOADER\
		)

#define ADD_TEMPLATE_CONTROL(TYPENAME, CONSTRUCTOR, TEMPLATE)\
	manager->SetLoader(\
		new GuiTemplateControlInstanceLoader(\
			L"presentation::controls::" L ## #TYPENAME,\
			[](){return Value::From(CONSTRUCTOR());},\
			[](Ptr<GuiTemplate::IFactory> factory){return Value::From(new TYPENAME(new TEMPLATE##_StyleProvider(factory))); }\
			)\
		)

#define ADD_TEMPLATE_CONTROL_2(TYPENAME, CONSTRUCTOR, TEMPLATE)\
	manager->SetLoader(\
		new GuiTemplateControlInstanceLoader(\
			L"presentation::controls::" L ## #TYPENAME,\
			[](){return Value::From(CONSTRUCTOR());},\
			[](Ptr<GuiTemplate::IFactory> factory)\
			{\
				auto style = new TEMPLATE##_StyleProvider(factory);\
				auto argument = style->CreateArgument();\
				return Value::From(new TYPENAME(style, argument));\
			}\
			)\
		)

#define ADD_VIRTUAL_CONTROL(VIRTUALTYPENAME, TYPENAME, CONSTRUCTOR, TEMPLATE)\
	manager->CreateVirtualType(\
		GlobalStringKey::Get(description::GetTypeDescriptor<TYPENAME>()->GetTypeName()),\
		new GuiTemplateControlInstanceLoader(\
			L"presentation::controls::Gui" L ## #VIRTUALTYPENAME,\
			[](){return Value::From(CONSTRUCTOR());},\
			[](Ptr<GuiTemplate::IFactory> factory){return Value::From(new TYPENAME(new TEMPLATE##_StyleProvider(factory))); }\
			)\
		)

#define ADD_VIRTUAL_CONTROL_2(VIRTUALTYPENAME, TYPENAME, CONSTRUCTOR, TEMPLATE)\
	manager->CreateVirtualType(\
		GlobalStringKey::Get(description::GetTypeDescriptor<TYPENAME>()->GetTypeName()),\
		new GuiTemplateControlInstanceLoader(\
			L"presentation::controls::Gui" L ## #VIRTUALTYPENAME,\
			[](){return Value::From(CONSTRUCTOR());},\
			[](Ptr<GuiTemplate::IFactory> factory)\
			{\
				auto style = new TEMPLATE##_StyleProvider(factory);\
				auto argument = style->CreateArgument();\
				return Value::From(new TYPENAME(style, argument));\
			}\
			)\
		)

#define ADD_VIRTUAL_CONTROL_F(VIRTUALTYPENAME, TYPENAME, CONSTRUCTOR, TEMPLATE, FUNCTION)\
	manager->CreateVirtualType(\
		GlobalStringKey::Get(description::GetTypeDescriptor<TYPENAME>()->GetTypeName()),\
		new GuiTemplateControlInstanceLoader(\
			L"presentation::controls::Gui" L ## #VIRTUALTYPENAME,\
			[](){return Value::From(CONSTRUCTOR());},\
			[](Ptr<GuiTemplate::IFactory> factory)\
			{\
				auto control = new TYPENAME(new TEMPLATE##_StyleProvider(factory));\
				FUNCTION(control);\
				return Value::From(control);\
			}\
			)\
		)

				manager->SetLoader(new GuiControlInstanceLoader);
				manager->SetLoader(new GuiTabInstanceLoader);						// ControlTemplate
				manager->SetLoader(new GuiTabPageInstanceLoader);
				manager->SetLoader(new GuiToolstripMenuInstanceLoader);				// ControlTemplate
				manager->SetLoader(new GuiToolstripMenuBarInstanceLoader);			// ControlTemplate
				manager->SetLoader(new GuiToolstripToolBarInstanceLoader);			// ControlTemplate
				manager->SetLoader(new GuiToolstripButtonInstanceLoader);			// ControlTemplate
				manager->SetLoader(new GuiSelectableListControlInstanceLoader);		// ItemTemplate
				manager->SetLoader(new GuiVirtualTreeViewInstanceLoader);			// ItemTemplate
				manager->SetLoader(new GuiListViewInstanceLoader(false));			// ControlTemplate
				manager->SetLoader(new GuiTreeViewInstanceLoader(false));			// ControlTemplate
				manager->SetLoader(new GuiBindableTextListInstanceLoader(L"", [](){return GetCurrentTheme()->CreateTextListItemStyle(); }));	// ControlTemplate, ItemSource
				manager->SetLoader(new GuiListViewInstanceLoader(true));			// ControlTemplate, ItemSource
				manager->SetLoader(new GuiTreeViewInstanceLoader(true));			// ControlTemplate, ItemSource
				manager->SetLoader(new GuiBindableDataColumnInstanceLoader);		// VisualizerTemplates, EditorTemplate
				manager->SetLoader(new GuiBindableDataGridInstanceLoader);			// ControlTemplate, ItemSource

				manager->SetLoader(new GuiCompositionInstanceLoader);
				manager->SetLoader(new GuiTableCompositionInstanceLoader);
				manager->SetLoader(new GuiCellCompositionInstanceLoader);
				
				ADD_VIRTUAL_TYPE_LOADER(GuiComboBoxListControl,						GuiComboBoxInstanceLoader);				// ControlTemplate
				ADD_VIRTUAL_TYPE_LOADER(tree::MemoryNodeProvider,					GuiTreeNodeInstanceLoader);

				ADD_TEMPLATE_CONTROL	(							GuiCustomControl,		g::NewCustomControl,			GuiControlTemplate);			// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiLabel,				g::NewLabel,					GuiLabelTemplate);				// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiButton,				g::NewButton,					GuiButtonTemplate);				// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiScrollContainer,		g::NewScrollContainer,			GuiScrollViewTemplate);			// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiWindow,				g::NewWindow,					GuiWindowTemplate);				// ControlTemplate
				ADD_TEMPLATE_CONTROL_2	(							GuiTextList,			g::NewTextList,					GuiTextListTemplate);			// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiDocumentViewer,		g::NewDocumentViewer,			GuiDocumentViewerTemplate);		// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiDocumentLabel,		g::NewDocumentLabel,			GuiDocumentLabelTemplate);		// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiMultilineTextBox,	g::NewMultilineTextBox,			GuiMultilineTextBoxTemplate);	// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiSinglelineTextBox,	g::NewTextBox,					GuiSinglelineTextBoxTemplate);	// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiDatePicker,			g::NewDatePicker,				GuiDatePickerTemplate);			// ControlTemplate
				ADD_TEMPLATE_CONTROL_2	(							GuiDateComboBox,		g::NewDateComboBox,				GuiDateComboBoxTemplate);		// ControlTemplate
				ADD_TEMPLATE_CONTROL	(							GuiStringGrid,			g::NewStringGrid,				GuiListViewTemplate);			// ControlTemplate
																																							// ControlTemplate
				ADD_VIRTUAL_CONTROL		(GroupBox,					GuiControl,				g::NewGroupBox,					GuiControlTemplate);			// ControlTemplate
				ADD_VIRTUAL_CONTROL		(MenuSplitter,				GuiControl,				g::NewMenuSplitter,				GuiControlTemplate);			// ControlTemplate
				ADD_VIRTUAL_CONTROL		(MenuBarButton,				GuiToolstripButton,		g::NewMenuBarButton,			GuiToolstripButtonTemplate);	// ControlTemplate
				ADD_VIRTUAL_CONTROL		(MenuItemButton,			GuiToolstripButton,		g::NewMenuItemButton,			GuiToolstripButtonTemplate);	// ControlTemplate
				ADD_VIRTUAL_CONTROL		(ToolstripDropdownButton,	GuiToolstripButton,		g::NewToolBarDropdownButton,	GuiToolstripButtonTemplate);	// ControlTemplate
				ADD_VIRTUAL_CONTROL		(ToolstripSplitButton,		GuiToolstripButton,		g::NewToolBarSplitButton,		GuiToolstripButtonTemplate);	// ControlTemplate
				ADD_VIRTUAL_CONTROL		(ToolstripSplitter,			GuiControl,				g::NewToolBarSplitter,			GuiControlTemplate);			// ControlTemplate
				ADD_VIRTUAL_CONTROL		(CheckBox,					GuiSelectableButton,	g::NewCheckBox,					GuiSelectableButtonTemplate);	// ControlTemplate
				ADD_VIRTUAL_CONTROL		(RadioButton,				GuiSelectableButton,	g::NewRadioButton,				GuiSelectableButtonTemplate);	// ControlTemplate
				ADD_VIRTUAL_CONTROL		(HScroll,					GuiScroll,				g::NewHScroll,					GuiScrollTemplate);				// ControlTemplate
				ADD_VIRTUAL_CONTROL		(VScroll,					GuiScroll,				g::NewVScroll,					GuiScrollTemplate);				// ControlTemplate
				ADD_VIRTUAL_CONTROL_F	(HTracker,					GuiScroll,				g::NewHTracker,					GuiScrollTemplate,				InitializeTrackerProgressBar);	// ControlTemplate
				ADD_VIRTUAL_CONTROL_F	(VTracker,					GuiScroll,				g::NewVTracker,					GuiScrollTemplate,				InitializeTrackerProgressBar);	// ControlTemplate
				ADD_VIRTUAL_CONTROL_F	(ProgressBar,				GuiScroll,				g::NewProgressBar,				GuiScrollTemplate,				InitializeTrackerProgressBar);	// ControlTemplate
				ADD_VIRTUAL_CONTROL_2	(CheckTextList,				GuiTextList,			g::NewCheckTextList,			GuiTextListTemplate);			// ControlTemplate
				ADD_VIRTUAL_CONTROL_2	(RadioTextList,				GuiTextList,			g::NewRadioTextList,			GuiTextListTemplate);			// ControlTemplate

				auto bindableTextListName = GlobalStringKey::Get(description::GetTypeDescriptor<GuiBindableTextList>()->GetTypeName());						// ControlTemplate, ItemSource
				manager->CreateVirtualType(bindableTextListName, new GuiBindableTextListInstanceLoader(L"Check", [](){return GetCurrentTheme()->CreateCheckTextListItemStyle(); }));
				manager->CreateVirtualType(bindableTextListName, new GuiBindableTextListInstanceLoader(L"Radio", [](){return GetCurrentTheme()->CreateRadioTextListItemStyle(); }));

#undef ADD_VIRTUAL_TYPE
#undef ADD_VIRTUAL_TYPE_LOADER
#endif
			}

			void Unload()override
			{
			}
		};
		GUI_REGISTER_PLUGIN(GuiPredefinedInstanceLoadersPlugin)
	}
}

/***********************************************************************
GUIINSTANCELOADER_PREDEFINEDTYPERESOLVERS.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace parsing;
		using namespace parsing::xml;
		using namespace workflow::analyzer;
		using namespace workflow::runtime;
		using namespace reflection::description;
		using namespace collections;

#define ERROR_CODE_PREFIX L"================================================================"

/***********************************************************************
Instance Type Resolver
***********************************************************************/

		class GuiResourceInstanceTypeResolver
			: public Object
			, public IGuiResourceTypeResolver
			, private IGuiResourceTypeResolver_Precompile
			, private IGuiResourceTypeResolver_DirectLoadStream
			, private IGuiResourceTypeResolver_IndirectLoad
		{
		public:
			WString GetType()override
			{
				return L"Instance";
			}

			WString GetPreloadType()override
			{
				return L"Xml";
			}

			bool IsDelayLoad()override
			{
				return false;
			}

			vint GetMaxPassIndex()override
			{
				return 2;
			}

			void Precompile(Ptr<DescriptableObject> resource, GuiResource* rootResource, vint passIndex, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				if (passIndex == 2)
				{
					if (auto obj = resource.Cast<GuiInstanceContext>())
					{
						obj->ApplyStyles(resolver, errors);
						Workflow_PrecompileInstanceContext(obj, errors);
					}
				}
			}

			IGuiResourceTypeResolver_Precompile* Precompile()override
			{
				return this;
			}

			IGuiResourceTypeResolver_DirectLoadStream* DirectLoadStream()override
			{
				return this;
			}

			IGuiResourceTypeResolver_IndirectLoad* IndirectLoad()override
			{
				return this;
			}

			void SerializePrecompiled(Ptr<DescriptableObject> resource, stream::IStream& stream)override
			{
				auto obj = resource.Cast<GuiInstanceContext>();
				obj->SavePrecompiledBinary(stream);
			}

			Ptr<DescriptableObject> ResolveResourcePrecompiled(stream::IStream& stream, collections::List<WString>& errors)override
			{
				return GuiInstanceContext::LoadPrecompiledBinary(stream, errors);
			}

			Ptr<DescriptableObject> Serialize(Ptr<DescriptableObject> resource, bool serializePrecompiledResource)override
			{
				if (auto obj = resource.Cast<GuiInstanceContext>())
				{
					return obj->SaveToXml(serializePrecompiledResource);
				}
				return 0;
			}

			Ptr<DescriptableObject> ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				Ptr<XmlDocument> xml = resource.Cast<XmlDocument>();
				if (xml)
				{
					Ptr<GuiInstanceContext> context = GuiInstanceContext::LoadFromXml(xml, errors);
					return context;
				}
				return 0;
			}
		};

/***********************************************************************
Instance Style Type Resolver
***********************************************************************/

		class GuiResourceInstanceStyleResolver
			: public Object
			, public IGuiResourceTypeResolver
			, private IGuiResourceTypeResolver_IndirectLoad
		{
		public:
			WString GetType()override
			{
				return L"InstanceStyle";
			}

			WString GetPreloadType()override
			{
				return L"Xml";
			}

			bool IsDelayLoad()override
			{
				return false;
			}

			IGuiResourceTypeResolver_IndirectLoad* IndirectLoad()override
			{
				return this;
			}

			Ptr<DescriptableObject> Serialize(Ptr<DescriptableObject> resource, bool serializePrecompiledResource)override
			{
				if (!serializePrecompiledResource)
				{
					if (auto obj = resource.Cast<GuiInstanceStyleContext>())
					{
						return obj->SaveToXml();
					}
				}
				return 0;
			}

			Ptr<DescriptableObject> ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				Ptr<XmlDocument> xml = resource.Cast<XmlDocument>();
				if (xml)
				{
					auto context = GuiInstanceStyleContext::LoadFromXml(xml, errors);
					return context;
				}
				return 0;
			}
		};

/***********************************************************************
Instance Schema Type Resolver
***********************************************************************/

		class GuiResourceInstanceSchemaTypeResolver
			: public Object
			, public IGuiResourceTypeResolver
			, private IGuiResourceTypeResolver_IndirectLoad
		{
		public:
			WString GetType()override
			{
				return L"InstanceSchema";
			}

			WString GetPreloadType()override
			{
				return L"Xml";
			}

			bool IsDelayLoad()override
			{
				return false;
			}

			IGuiResourceTypeResolver_IndirectLoad* IndirectLoad()override
			{
				return this;
			}

			Ptr<DescriptableObject> Serialize(Ptr<DescriptableObject> resource, bool serializePrecompiledResource)override
			{
				if (!serializePrecompiledResource)
				{
					if (auto obj = resource.Cast<GuiInstanceSchema>())
					{
						return obj->SaveToXml();
					}
				}
				return 0;
			}

			Ptr<DescriptableObject> ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				Ptr<XmlDocument> xml = resource.Cast<XmlDocument>();
				if (xml)
				{
					auto schema = GuiInstanceSchema::LoadFromXml(xml, errors);
					return schema;
				}
				return 0;
			}
		};

/***********************************************************************
Shared Script Type Resolver
***********************************************************************/

		class GuiSharedWorkflowCache : public Object, public IGuiResourceCache
		{
		public:
			static const GlobalStringKey&					CacheTypeName;
			static const GlobalStringKey&					CacheContextName;

			List<WString>									moduleCodes;
			Ptr<WfAssembly>									assembly;
			Ptr<WfRuntimeGlobalContext>						globalContext;

			GuiSharedWorkflowCache()
			{
			}

			GuiSharedWorkflowCache(Ptr<WfAssembly> _assembly)
				:assembly(_assembly)
			{
				Initialize();
			}

			GlobalStringKey GetCacheTypeName()override
			{
				return CacheTypeName;
			}

			void Initialize()
			{
				if (!globalContext)
				{
					globalContext = new WfRuntimeGlobalContext(assembly);
					LoadFunction<void()>(globalContext, L"<initialize>")();
				}
			}
		};

		const GlobalStringKey& GuiSharedWorkflowCache::CacheTypeName = GlobalStringKey::_Shared_Workflow_Assembly_Cache;
		const GlobalStringKey& GuiSharedWorkflowCache::CacheContextName = GlobalStringKey::_Shared_Workflow_Global_Context;

		class GuiSharedWorkflowCacheResolver : public Object, public IGuiResourceCacheResolver 
		{
		public:
			GlobalStringKey GetCacheTypeName()override
			{
				return GuiSharedWorkflowCache::CacheTypeName;
			}

			bool Serialize(Ptr<IGuiResourceCache> cache, stream::IStream& stream)override
			{
				if (auto obj = cache.Cast<GuiSharedWorkflowCache>())
				{
					obj->assembly->Serialize(stream);
					return true;
				}
				else
				{
					return false;
				}
			}

			Ptr<IGuiResourceCache> Deserialize(stream::IStream& stream)override
			{
				auto assembly = new WfAssembly(stream);
				return new GuiSharedWorkflowCache(assembly);
			}
		};

		class GuiResourceSharedScriptTypeResolver
			: public Object
			, public IGuiResourceTypeResolver
			, private IGuiResourceTypeResolver_Precompile
			, private IGuiResourceTypeResolver_IndirectLoad
		{
		public:
			WString GetType()override
			{
				return L"Script";
			}

			WString GetPreloadType()override
			{
				return L"Xml";
			}

			bool IsDelayLoad()override
			{
				return false;
			}

			vint GetMaxPassIndex()override
			{
				return 1;
			}

			void Precompile(Ptr<DescriptableObject> resource, GuiResource* rootResource, vint passIndex, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				if (passIndex == 0)
				{
					if (auto obj = resource.Cast<GuiInstanceSharedScript>())
					{
						if (obj->language == L"Workflow")
						{
							Ptr<GuiSharedWorkflowCache> cache;
							auto key = GuiSharedWorkflowCache::CacheContextName;
							auto index = rootResource->precompiledCaches.Keys().IndexOf(key);

							if (index == -1)
							{
								cache = new GuiSharedWorkflowCache;
								rootResource->precompiledCaches.Add(key, cache);
							}
							else
							{
								cache = rootResource->precompiledCaches.Values()[index].Cast<GuiSharedWorkflowCache>();
							}
							cache->moduleCodes.Add(obj->code);
						}
					}
				}
				else if (passIndex == 1)
				{
					Ptr<GuiSharedWorkflowCache> cache;
					auto key = GuiSharedWorkflowCache::CacheContextName;
					auto index = rootResource->precompiledCaches.Keys().IndexOf(key);

					if (index != -1)
					{
						auto cache = rootResource->precompiledCaches.Values()[index].Cast<GuiSharedWorkflowCache>();
						if (cache->moduleCodes.Count() > 0)
						{
							auto table = GetParserManager()->GetParsingTable(L"WORKFLOW");
							List<Ptr<ParsingError>> scriptErrors;
							cache->assembly = Compile(table, cache->moduleCodes, scriptErrors);
							cache->moduleCodes.Clear();

							if (scriptErrors.Count() > 0)
							{
								errors.Add(ERROR_CODE_PREFIX L"Failed to parse the shared workflow script");
								FOREACH(Ptr<ParsingError>, error, scriptErrors)
								{
									errors.Add(
										L"Row: " + itow(error->codeRange.start.row + 1) +
										L", Column: " + itow(error->codeRange.start.column + 1) +
										L", Message: " + error->errorMessage);
								}
							}
							else
							{
								cache->Initialize();
							}
						}
					}
				}
			}

			IGuiResourceTypeResolver_Precompile* Precompile()override
			{
				return this;
			}

			IGuiResourceTypeResolver_IndirectLoad* IndirectLoad()override
			{
				return this;
			}

			Ptr<DescriptableObject> Serialize(Ptr<DescriptableObject> resource, bool serializePrecompiledResource)override
			{
				if (!serializePrecompiledResource)
				{
					if (auto obj = resource.Cast<GuiInstanceSharedScript>())
					{
						return obj->SaveToXml();
					}
				}
				return 0;
			}

			Ptr<DescriptableObject> ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				Ptr<XmlDocument> xml = resource.Cast<XmlDocument>();
				if (xml)
				{
					auto schema = GuiInstanceSharedScript::LoadFromXml(xml, errors);
					return schema;
				}
				return 0;
			}
		};

/***********************************************************************
Shared Script Type Resolver
***********************************************************************/

		class GuiPredefinedTypeResolversPlugin : public Object, public IGuiPlugin
		{
		public:
			GuiPredefinedTypeResolversPlugin()
			{
			}

			void Load()override
			{
			}

			void AfterLoad()override
			{
				IGuiResourceResolverManager* manager = GetResourceResolverManager();
				manager->SetTypeResolver(new GuiResourceInstanceTypeResolver);
				manager->SetTypeResolver(new GuiResourceInstanceStyleResolver);
				manager->SetTypeResolver(new GuiResourceInstanceSchemaTypeResolver);
				manager->SetTypeResolver(new GuiResourceSharedScriptTypeResolver);
				manager->SetCacheResolver(new GuiSharedWorkflowCacheResolver);
			}

			void Unload()override
			{
			}
		};
		GUI_REGISTER_PLUGIN(GuiPredefinedTypeResolversPlugin)
	}
}

/***********************************************************************
GUIINSTANCELOADER_WORKFLOWCOMPILER.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace workflow::runtime;
		using namespace reflection::description;
		using namespace collections;

#define ERROR_CODE_PREFIX L"================================================================"

/***********************************************************************
Module
***********************************************************************/

		Ptr<workflow::WfModule> Workflow_CreateEmptyModule(Ptr<GuiInstanceContext> context)
		{
			auto module = MakePtr<WfModule>();
			vint index = context->namespaces.Keys().IndexOf(GlobalStringKey());
			if (index != -1)
			{
				auto nss = context->namespaces.Values()[index];
				FOREACH(Ptr<GuiInstanceNamespace>, ns, nss->namespaces)
				{
					auto path = MakePtr<WfModuleUsingPath>();
					module->paths.Add(path);

					auto pathCode = ns->prefix + L"*" + ns->postfix;
					auto reading = pathCode.Buffer();
					while (reading)
					{
						auto delimiter = wcsstr(reading, L"::");
						auto begin = reading;
						auto end = delimiter ? delimiter : begin + wcslen(reading);

						auto wildcard = wcschr(reading, L'*');
						if (wildcard >= end)
						{
							wildcard = nullptr;
						}

						auto item = MakePtr<WfModuleUsingItem>();
						path->items.Add(item);
						if (wildcard)
						{
							if (begin < wildcard)
							{
								auto fragment = MakePtr<WfModuleUsingNameFragment>();
								item->fragments.Add(fragment);
								fragment->name.value = WString(begin, vint(wildcard - begin));
							}
							{
								auto fragment = MakePtr<WfModuleUsingWildCardFragment>();
								item->fragments.Add(fragment);
							}
							if (wildcard + 1 < end)
							{
								auto fragment = MakePtr<WfModuleUsingNameFragment>();
								item->fragments.Add(fragment);
								fragment->name.value = WString(wildcard, vint(end - wildcard - 1));
							}
						}
						else if (begin < end)
						{
							auto fragment = MakePtr<WfModuleUsingNameFragment>();
							item->fragments.Add(fragment);
							fragment->name.value = WString(begin, vint(end - begin));
						}

						if (delimiter)
						{
							reading = delimiter + 2;
						}
						else
						{
							reading = nullptr;
						}
					}
				}
			}
			return module;
		}

/***********************************************************************
Variable
***********************************************************************/

		void Workflow_CreatePointerVariable(Ptr<workflow::WfModule> module, GlobalStringKey name, description::ITypeDescriptor* type)
		{
			auto var = MakePtr<WfVariableDeclaration>();
			var->name.value = name.ToString();
			{
				Ptr<TypeInfoImpl> elementType = new TypeInfoImpl(ITypeInfo::TypeDescriptor);
				elementType->SetTypeDescriptor(type);

				Ptr<TypeInfoImpl> pointerType = new TypeInfoImpl(ITypeInfo::RawPtr);
				pointerType->SetElementType(elementType);

				var->type = GetTypeFromTypeInfo(pointerType.Obj());
			}

			auto literal = MakePtr<WfLiteralExpression>();
			literal->value = WfLiteralValue::Null;
			var->expression = literal;

			module->declarations.Add(var);
		}

		void Workflow_GetVariableTypes(Ptr<GuiInstanceEnvironment> env, types::VariableTypeMap& types)
		{
			FOREACH_INDEXER(GlobalStringKey, name, index, env->scope->referenceValues.Keys())
			{
				auto value = env->scope->referenceValues.Values()[index];
				if (value.GetTypeDescriptor())
				{
					types.Add(name, value.GetTypeDescriptor());
				}
				else
				{
					types.Add(name, GetTypeDescriptor<Value>());
				}
			}
		}
		
		void Workflow_CreateVariablesForReferenceValues(Ptr<workflow::WfModule> module, types::VariableTypeMap& types)
		{
			for (vint i = 0; i < types.Count(); i++)
			{
				auto key = types.Keys()[i];
				auto value = types.Values()[i];
				Workflow_CreatePointerVariable(module, key, value);
			}
		}

		void Workflow_SetVariablesForReferenceValues(Ptr<workflow::runtime::WfRuntimeGlobalContext> context, Ptr<GuiInstanceEnvironment> env)
		{
			FOREACH_INDEXER(GlobalStringKey, name, index, env->scope->referenceValues.Keys())
			{
				vint variableIndex = context->assembly->variableNames.IndexOf(name.ToString());
				if (variableIndex != -1)
				{
					context->globalVariables->variables[variableIndex] = env->scope->referenceValues.Values()[index];
				}
			}
		}

/***********************************************************************
Workflow_ValidateExpression
***********************************************************************/

		bool Workflow_ValidateExpression(Ptr<GuiInstanceContext> context, types::VariableTypeMap& types, types::ErrorList& errors, IGuiInstanceLoader::PropertyInfo& bindingTarget, const WString& expressionCode, Ptr<workflow::WfExpression>& expression)
		{
			auto parser = GetParserManager()->GetParser<WfExpression>(L"WORKFLOW-EXPRESSION");
			expression = parser->TypedParse(expressionCode, errors);
			if (!expression)
			{
				errors.Add(ERROR_CODE_PREFIX L"Failed to parse the workflow expression.");
				return false;
			}

			bool failed = false;
			auto td = bindingTarget.typeInfo.typeDescriptor;
			auto propertyInfo = td->GetPropertyByName(bindingTarget.propertyName.ToString(), true);
			if (!propertyInfo)
			{
				errors.Add(ERROR_CODE_PREFIX L"Property \"" + bindingTarget.propertyName.ToString() + L"\" does not exist in type \"" + td->GetTypeName() + L"\".");
				failed = true;
			}
			else if (!propertyInfo->IsReadable() || !propertyInfo->IsWritable())
			{
				errors.Add(ERROR_CODE_PREFIX L"Property \"" + bindingTarget.propertyName.ToString() + L"\" of type \"" + td->GetTypeName() + L"\" should be both readable and writable.");
				failed = true;
			}

			auto module = Workflow_CreateEmptyModule(context);
			Workflow_CreateVariablesForReferenceValues(module, types);
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->anonymity = WfFunctionAnonymity::Named;
				func->name.value = L"<initialize-data-binding>";
				func->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = expression;
				func->statement = stat;

				module->declarations.Add(func);
			}

			Workflow_GetSharedManager()->Clear(true, true);
			Workflow_GetSharedManager()->AddModule(module);
			Workflow_GetSharedManager()->Rebuild(true);
			if (Workflow_GetSharedManager()->errors.Count() > 0)
			{
				errors.Add(ERROR_CODE_PREFIX L"Failed to analyze the workflow expression \"" + expressionCode + L"\".");
				FOREACH(Ptr<parsing::ParsingError>, error, Workflow_GetSharedManager()->errors)
				{
					errors.Add(error->errorMessage);
				}
				failed = true;
			}
			else if (propertyInfo)
			{
				auto bind = expression.Cast<WfBindExpression>();
				auto result = Workflow_GetSharedManager()->expressionResolvings[(bind ? bind->expression : expression).Obj()];
				if (result.type)
				{
					ITypeInfo* propertyType = propertyInfo->GetReturn();
					if (propertyInfo->GetSetter() && propertyInfo->GetSetter()->GetParameterCount() == 1)
					{
						propertyType = propertyInfo->GetSetter()->GetParameter(0)->GetType();
					}
					if (!CanConvertToType(result.type.Obj(), propertyType, false))
					{
						errors.Add(ERROR_CODE_PREFIX L"Failed to analyze the workflow expression \"" + expressionCode + L"\".");
						errors.Add(
							WfErrors::ExpressionCannotImplicitlyConvertToType(expression.Obj(), result.type.Obj(), propertyType)
							->errorMessage);
						failed = true;
					}
				}
			}

			return !failed;
		}

/***********************************************************************
Workflow_CompileExpression
***********************************************************************/

		Ptr<workflow::runtime::WfAssembly> Workflow_CompileExpression(Ptr<GuiInstanceContext> context, types::VariableTypeMap& types, types::ErrorList& errors, const WString& expressionCode)
		{
			auto parser = GetParserManager()->GetParser<WfExpression>(L"WORKFLOW-EXPRESSION");
			auto expression = parser->TypedParse(expressionCode, errors);
			if (!expression)
			{
				errors.Add(ERROR_CODE_PREFIX L"Failed to parse the workflow expression \"" + expressionCode + L"\".");
				return 0;
			}

			auto module = Workflow_CreateEmptyModule(context);
			Workflow_CreateVariablesForReferenceValues(module, types);
			{
				auto lambda = MakePtr<WfOrderedLambdaExpression>();
				lambda->body = expression;

				auto var = MakePtr<WfVariableDeclaration>();
				var->name.value = L"<initialize-data-binding>";
				var->expression = lambda;

				module->declarations.Add(var);
			}

			Workflow_GetSharedManager()->Clear(true, true);
			Workflow_GetSharedManager()->AddModule(module);
			Workflow_GetSharedManager()->Rebuild(true);
			if (Workflow_GetSharedManager()->errors.Count() > 0)
			{
				errors.Add(ERROR_CODE_PREFIX L"Failed to analyze the workflow expression \"" + expressionCode + L"\".");
				FOREACH(Ptr<parsing::ParsingError>, error, Workflow_GetSharedManager()->errors)
				{
					errors.Add(error->errorMessage);
				}
				return 0;
			}

			return GenerateAssembly(Workflow_GetSharedManager());
		}

/***********************************************************************
Workflow_CompileEventHandler
***********************************************************************/

		Ptr<workflow::runtime::WfAssembly> Workflow_CompileEventHandler(Ptr<GuiInstanceContext> context, types::VariableTypeMap& types, types::ErrorList& errors, IGuiInstanceLoader::PropertyInfo& bindingTarget, const WString& statementCode)
		{
			auto parser = GetParserManager()->GetParser<WfStatement>(L"WORKFLOW-STATEMENT");
			auto statement = parser->TypedParse(statementCode, errors);
			if (!statement)
			{
				errors.Add(ERROR_CODE_PREFIX L"Failed to parse the workflow statement.");
				return 0;
			}

			auto module = Workflow_CreateEmptyModule(context);
			Workflow_CreateVariablesForReferenceValues(module, types);
			{
				auto func = MakePtr<WfFunctionDeclaration>();
				func->anonymity = WfFunctionAnonymity::Named;
				func->name.value = L"<event-handler>";
				func->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());

				auto td = bindingTarget.typeInfo.typeDescriptor;
				auto eventInfo = td->GetEventByName(bindingTarget.propertyName.ToString(), true);
				if (eventInfo)
				{
					vint count = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgumentCount() - 1;
					bool standardName = false;
					if (count == 2)
					{
						auto senderType = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(1)->GetTypeDescriptor();
						auto argumentType = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(2)->GetTypeDescriptor();
						if (senderType == GetTypeDescriptor<GuiGraphicsComposition>())
						{
							auto expectedType = GetTypeDescriptor<GuiEventArgs>();
							List<ITypeDescriptor*> types;
							types.Add(argumentType);
							for (vint i = 0; i < types.Count(); i++)
							{
								auto type = types[i];
								if (type == expectedType)
								{
									standardName = true;
									break;
								}
								vint baseCount = type->GetBaseTypeDescriptorCount();
								for (vint j = 0; j < baseCount; j++)
								{
									auto baseType = type->GetBaseTypeDescriptor(j);
									if (!types.Contains(baseType))
									{
										types.Add(baseType);
									}
								}
							}
						}
					}

					if (standardName)
					{
						{
							auto arg = MakePtr<WfFunctionArgument>();
							arg->name.value = L"sender";
							arg->type = GetTypeFromTypeInfo(eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(1));
							func->arguments.Add(arg);
						}
						{
							auto arg = MakePtr<WfFunctionArgument>();
							arg->name.value = L"arguments";
							arg->type = GetTypeFromTypeInfo(eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(2));
							func->arguments.Add(arg);
						}
					}
					else
					{
						auto type = TypeInfoRetriver<Value>::CreateTypeInfo();
						for (vint i = 0; i < count; i++)
						{
							auto arg = MakePtr<WfFunctionArgument>();
							arg->name.value = L"<argument>" + itow(i + 1);
							arg->type = GetTypeFromTypeInfo(type.Obj());
							func->arguments.Add(arg);
						}
					}
				}
						
				auto block = MakePtr<WfBlockStatement>();
				block->statements.Add(statement);
				func->statement = block;

				module->declarations.Add(func);
			}

			Workflow_GetSharedManager()->Clear(true, true);
			Workflow_GetSharedManager()->AddModule(module);
			Workflow_GetSharedManager()->Rebuild(true);
			if (Workflow_GetSharedManager()->errors.Count() > 0)
			{
				errors.Add(ERROR_CODE_PREFIX L"Failed to analyze the workflow statement \"" + statementCode + L"\".");
				FOREACH(Ptr<parsing::ParsingError>, error, Workflow_GetSharedManager()->errors)
				{
					errors.Add(error->errorMessage);
				}
				return 0;
			}

			return GenerateAssembly(Workflow_GetSharedManager());
		}

/***********************************************************************
Workflow_CompileDataBinding
***********************************************************************/

		WString Workflow_ModuleToString(Ptr<workflow::WfModule> module)
		{
			stream::MemoryStream stream;
			{
				stream::StreamWriter writer(stream);
				WfPrint(module, L"", writer);
			}
			stream.SeekFromBegin(0);
			stream::StreamReader reader(stream);
			return reader.ReadToEnd();
		}

		Ptr<workflow::runtime::WfAssembly> Workflow_CompileDataBinding(Ptr<GuiInstanceContext> context, types::VariableTypeMap& types, description::ITypeDescriptor* thisType, types::ErrorList& errors, collections::List<WorkflowDataBinding>& dataBindings)
		{
			auto module = Workflow_CreateEmptyModule(context);
			Workflow_CreateVariablesForReferenceValues(module, types);
			Workflow_CreatePointerVariable(module, GlobalStringKey::Get(L"<this>"), thisType);

			auto func = MakePtr<WfFunctionDeclaration>();
			func->anonymity = WfFunctionAnonymity::Named;
			func->name.value = L"<initialize-data-binding>";
			func->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());

			auto block = MakePtr<WfBlockStatement>();
			func->statement = block;
			module->declarations.Add(func);
			

			FOREACH(WorkflowDataBinding, dataBinding, dataBindings)
			{
				if (dataBinding.bindExpression.Cast<WfBindExpression>())
				{
					auto subBlock = MakePtr<WfBlockStatement>();
					block->statements.Add(subBlock);
					{
						auto refThis = MakePtr<WfReferenceExpression>();
						refThis->name.value = L"<this>";

						auto member = MakePtr<WfMemberExpression>();
						member->parent = refThis;
						member->name.value = L"AddSubscription";

						auto call = MakePtr<WfCallExpression>();
						call->function = member;
						call->arguments.Add(dataBinding.bindExpression);

						auto var = MakePtr<WfVariableDeclaration>();
						var->name.value = L"<subscription>";
						var->expression = call;

						auto stat = MakePtr<WfVariableStatement>();
						stat->variable = var;
						subBlock->statements.Add(stat);
					}
					{
						auto callback = MakePtr<WfFunctionDeclaration>();
						callback->anonymity = WfFunctionAnonymity::Anonymous;
						callback->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());;
						{
							auto arg = MakePtr<WfFunctionArgument>();
							arg->name.value = L"<value>";
							arg->type = GetTypeFromTypeInfo(TypeInfoRetriver<Value>::CreateTypeInfo().Obj());
							callback->arguments.Add(arg);
						}
						auto callbackBlock = MakePtr<WfBlockStatement>();
						callback->statement = callbackBlock;
						{
							auto refSubscribee = MakePtr<WfReferenceExpression>();
							refSubscribee->name.value = dataBinding.variableName.ToString();

							auto member = MakePtr<WfMemberExpression>();
							member->parent = refSubscribee;
							member->name.value = dataBinding.propertyInfo->GetName();

							auto var = MakePtr<WfVariableDeclaration>();
							var->name.value = L"<old>";
							var->expression = member;

							auto stat = MakePtr<WfVariableStatement>();
							stat->variable = var;
							callbackBlock->statements.Add(stat);
						}
						{
							ITypeInfo* propertyType = dataBinding.propertyInfo->GetReturn();
							if (dataBinding.propertyInfo->GetSetter() && dataBinding.propertyInfo->GetSetter()->GetParameterCount() == 1)
							{
								propertyType = dataBinding.propertyInfo->GetSetter()->GetParameter(0)->GetType();
							}

							auto refValue = MakePtr<WfReferenceExpression>();
							refValue->name.value = L"<value>";

							auto cast = MakePtr<WfTypeCastingExpression>();
							cast->strategy = WfTypeCastingStrategy::Strong;
							cast->expression = refValue;
							cast->type = GetTypeFromTypeInfo(propertyType);

							auto var = MakePtr<WfVariableDeclaration>();
							var->name.value = L"<new>";
							var->expression = cast;

							auto stat = MakePtr<WfVariableStatement>();
							stat->variable = var;
							callbackBlock->statements.Add(stat);
						}
						{
							auto refOld = MakePtr<WfReferenceExpression>();
							refOld->name.value = L"<old>";

							auto refNew = MakePtr<WfReferenceExpression>();
							refNew->name.value = L"<new>";

							auto compare = MakePtr<WfBinaryExpression>();
							compare->op = WfBinaryOperator::EQ;
							compare->first = refOld;
							compare->second = refNew;

							auto ifStat = MakePtr<WfIfStatement>();
							ifStat->expression = compare;
							callbackBlock->statements.Add(ifStat);

							auto ifBlock = MakePtr<WfBlockStatement>();
							ifStat->trueBranch = ifBlock;

							auto returnStat = MakePtr<WfReturnStatement>();
							ifBlock->statements.Add(returnStat);
						}
						{
							auto refSubscribee = MakePtr<WfReferenceExpression>();
							refSubscribee->name.value = dataBinding.variableName.ToString();

							auto member = MakePtr<WfMemberExpression>();
							member->parent = refSubscribee;
							member->name.value = dataBinding.propertyInfo->GetName();

							auto refNew = MakePtr<WfReferenceExpression>();
							refNew->name.value = L"<new>";

							auto assign = MakePtr<WfBinaryExpression>();
							assign->op = WfBinaryOperator::Assign;
							assign->first = member;
							assign->second = refNew;

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = assign;
							callbackBlock->statements.Add(stat);
						}

						auto funcExpr = MakePtr<WfFunctionExpression>();
						funcExpr->function = callback;

						auto refThis = MakePtr<WfReferenceExpression>();
						refThis->name.value = L"<subscription>";

						auto member = MakePtr<WfMemberExpression>();
						member->parent = refThis;
						member->name.value = L"Subscribe";

						auto call = MakePtr<WfCallExpression>();
						call->function = member;
						call->arguments.Add(funcExpr);

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = call;
						subBlock->statements.Add(stat);
					}
					{
						auto refThis = MakePtr<WfReferenceExpression>();
						refThis->name.value = L"<subscription>";

						auto member = MakePtr<WfMemberExpression>();
						member->parent = refThis;
						member->name.value = L"Update";

						auto call = MakePtr<WfCallExpression>();
						call->function = member;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = call;
						subBlock->statements.Add(stat);
					}
				}
				else if (dataBinding.bindExpression)
				{
					auto refSubscribee = MakePtr<WfReferenceExpression>();
					refSubscribee->name.value = dataBinding.variableName.ToString();

					auto member = MakePtr<WfMemberExpression>();
					member->parent = refSubscribee;
					member->name.value = dataBinding.propertyInfo->GetName();

					auto assign = MakePtr<WfBinaryExpression>();
					assign->op = WfBinaryOperator::Assign;
					assign->first = member;
					assign->second = dataBinding.bindExpression;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assign;
					block->statements.Add(stat);
				}
			}

			Workflow_GetSharedManager()->Clear(true, true);
			Workflow_GetSharedManager()->AddModule(module);
			Workflow_GetSharedManager()->Rebuild(true);
			WString moduleCode = Workflow_ModuleToString(module);

			if (Workflow_GetSharedManager()->errors.Count() > 0)
			{
				errors.Add(ERROR_CODE_PREFIX L"Unexpected errors are encountered when initializing data binding.");
				FOREACH(Ptr<parsing::ParsingError>, error, Workflow_GetSharedManager()->errors)
				{
					errors.Add(error->errorMessage);
				}
				errors.Add(ERROR_CODE_PREFIX L"Print code for reference:");
				errors.Add(moduleCode);
				return 0;
			}
			return GenerateAssembly(Workflow_GetSharedManager());
		}

/***********************************************************************
Workflow_GetSharedManager
***********************************************************************/

		class WorkflowReferenceNamesVisitor : public Object, public GuiValueRepr::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			types::VariableTypeInfoMap&			typeInfos;
			types::ErrorList&					errors;

			IGuiInstanceLoader::TypeInfo		bindingTargetTypeInfo;
			vint								generatedNameCount;
			ITypeDescriptor*					rootTypeDescriptor;

			WorkflowReferenceNamesVisitor(Ptr<GuiInstanceContext> _context, types::VariableTypeInfoMap& _typeInfos, types::ErrorList& _errors)
				:context(_context)
				, typeInfos(_typeInfos)
				, errors(_errors)
				, generatedNameCount(0)
				, rootTypeDescriptor(0)
			{
			}

			void Visit(GuiTextRepr* repr)override
			{
			}

			void Visit(GuiAttSetterRepr* repr)override
			{
				auto reprTypeInfo = bindingTargetTypeInfo;
				auto loader = GetInstanceLoaderManager()->GetLoader(reprTypeInfo.typeName);

				if (repr->instanceName != GlobalStringKey::Empty && reprTypeInfo.typeDescriptor)
				{
					if (typeInfos.Keys().Contains(repr->instanceName))
					{
						errors.Add(L"Precompile: Parameter \"" + repr->instanceName.ToString() + L"\" conflict with an existing named object.");
					}
					else
					{
						typeInfos.Add(repr->instanceName, reprTypeInfo);
					}
				}
				
				FOREACH_INDEXER(Ptr<GuiAttSetterRepr::SetterValue>, setter, index, repr->setters.Values())
				{
					IGuiInstanceLoader::TypeInfo propertyTypeInfo;

					if (setter->binding != GlobalStringKey::Empty && setter->binding != GlobalStringKey::_Set)
					{
						auto binder = GetInstanceLoaderManager()->GetInstanceBinder(setter->binding);
						if (!binder)
						{
							errors.Add(L"The appropriate IGuiInstanceBinder of binding \"" + setter->binding.ToString() + L"\" cannot be found.");
						}
						else if (binder->RequireInstanceName() && repr->instanceName == GlobalStringKey::Empty && reprTypeInfo.typeDescriptor)
						{
							auto name = GlobalStringKey::Get(L"<precompile>" + itow(generatedNameCount++));
							repr->instanceName = name;
							typeInfos.Add(name, reprTypeInfo);
						}
					}

					if (setter->binding == GlobalStringKey::_Set)
					{
						IGuiInstanceLoader::PropertyInfo info;
						info.typeInfo = reprTypeInfo;
						info.propertyName = repr->setters.Keys()[index];
						auto currentLoader = loader;

						while (currentLoader)
						{
							auto typeInfo = currentLoader->GetPropertyType(info);
							if (typeInfo && typeInfo->support != GuiInstancePropertyInfo::NotSupport)
							{
								propertyTypeInfo.typeDescriptor = typeInfo->acceptableTypes[0];
								propertyTypeInfo.typeName = GlobalStringKey::Get(typeInfo->acceptableTypes[0]->GetTypeName());
								break;
							}
							currentLoader = GetInstanceLoaderManager()->GetParentLoader(currentLoader);
						}
					}

					FOREACH(Ptr<GuiValueRepr>, value, setter->values)
					{
						bindingTargetTypeInfo = propertyTypeInfo;
						value->Accept(this);
					}
				}

				FOREACH(Ptr<GuiAttSetterRepr::EventValue>, handler, repr->eventHandlers.Values())
				{
					if (handler->binding != GlobalStringKey::Empty)
					{
						auto binder = GetInstanceLoaderManager()->GetInstanceEventBinder(handler->binding);
						if (!binder)
						{
							errors.Add(L"The appropriate IGuiInstanceEventBinder of binding \"" + handler->binding.ToString() + L"\" cannot be found.");
						}
						else if (binder->RequireInstanceName() && repr->instanceName == GlobalStringKey::Empty && reprTypeInfo.typeDescriptor)
						{
							auto name = GlobalStringKey::Get(L"<precompile>" + itow(generatedNameCount++));
							repr->instanceName = name;
							typeInfos.Add(name, reprTypeInfo);
						}
					}
				}
			}

			void Visit(GuiConstructorRepr* repr)override
			{
				bool found = false;
				if (repr == context->instance.Obj() && context->className)
				{
					auto fullName = GlobalStringKey::Get(context->className.Value());
					auto td = GetInstanceLoaderManager()->GetTypeDescriptorForType(fullName);
					if (td)
					{
						found = true;
						bindingTargetTypeInfo.typeName = fullName;
						bindingTargetTypeInfo.typeDescriptor = td;
					}
				}

				if (!found)
				{
					auto source = FindInstanceLoadingSource(context, repr);
					bindingTargetTypeInfo.typeName = source.typeName;
					bindingTargetTypeInfo.typeDescriptor = GetInstanceLoaderManager()->GetTypeDescriptorForType(source.typeName);
				}

				if (!bindingTargetTypeInfo.typeDescriptor)
				{
					errors.Add(
						L"Precompile: Failed to find type \"" +
						(repr->typeNamespace == GlobalStringKey::Empty
							? repr->typeName.ToString()
							: repr->typeNamespace.ToString() + L":" + repr->typeName.ToString()
							) +
						L"\".");
				}

				if (context->instance.Obj() == repr)
				{
					rootTypeDescriptor = bindingTargetTypeInfo.typeDescriptor;
				}
				Visit((GuiAttSetterRepr*)repr);
			}
		};

		class WorkflowCompileVisitor : public Object, public GuiValueRepr::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			types::VariableTypeInfoMap&			typeInfos;
			types::ErrorList&					errors;
			
			types::VariableTypeMap				types;
			List<WorkflowDataBinding>			dataBindings;

			WorkflowCompileVisitor(Ptr<GuiInstanceContext> _context, types::VariableTypeInfoMap& _typeInfos, types::ErrorList& _errors)
				:context(_context)
				, typeInfos(_typeInfos)
				, errors(_errors)
			{
				for (vint i = 0; i < typeInfos.Count(); i++)
				{
					auto key = typeInfos.Keys()[i];
					auto value = typeInfos.Values()[i];
					types.Add(key, value.typeDescriptor);
				}
			}

			void Visit(GuiTextRepr* repr)override
			{
			}

			void Visit(GuiAttSetterRepr* repr)override
			{
				IGuiInstanceLoader::TypeInfo reprTypeInfo;
				if (repr->instanceName != GlobalStringKey::Empty)
				{
					reprTypeInfo = typeInfos[repr->instanceName];
				}

				FOREACH_INDEXER(Ptr<GuiAttSetterRepr::SetterValue>, setter, index, repr->setters.Values())
				{
					if (reprTypeInfo.typeDescriptor)
					{
						GlobalStringKey propertyName = repr->setters.Keys()[index];
						Ptr<GuiInstancePropertyInfo> propertyInfo;
						IGuiInstanceLoader::PropertyInfo info;
						info.typeInfo = reprTypeInfo;
						info.propertyName = propertyName;

						{
							auto currentLoader = GetInstanceLoaderManager()->GetLoader(info.typeInfo.typeName);

							while (currentLoader && !propertyInfo)
							{
								propertyInfo = currentLoader->GetPropertyType(info);
								if (propertyInfo && propertyInfo->support == GuiInstancePropertyInfo::NotSupport)
								{
									propertyInfo = 0;
								}
								currentLoader = GetInstanceLoaderManager()->GetParentLoader(currentLoader);
							}
						}

						if (!propertyInfo)
						{
							errors.Add(L"Precompile: Cannot find property \"" + propertyName.ToString() + L"\" in type \"" + reprTypeInfo.typeName.ToString() + L"\".");
						}
						else
						{
							WString expressionCode;
							if (auto obj = setter->values[0].Cast<GuiTextRepr>())
							{
								expressionCode = obj->text;
							}

							if (setter->binding == GlobalStringKey::_Bind || setter->binding == GlobalStringKey::_Format)
							{
								WorkflowDataBinding dataBinding;
								dataBinding.variableName = repr->instanceName;

								if (setter->binding == GlobalStringKey::_Bind)
								{
									expressionCode = L"bind(" + expressionCode + L")";
								}
								else if (setter->binding == GlobalStringKey::_Format)
								{
									expressionCode = L"bind($\"" + expressionCode + L"\")";
								}

								Ptr<WfExpression> expression;
								if (Workflow_ValidateExpression(context, types, errors, info, expressionCode, expression))
								{
									dataBinding.propertyInfo = reprTypeInfo.typeDescriptor->GetPropertyByName(propertyName.ToString(), true);
									dataBinding.bindExpression = expression;
								}

								dataBindings.Add(dataBinding);
							}
							else if (setter->binding == GlobalStringKey::_Eval)
							{
								if (propertyInfo->scope != GuiInstancePropertyInfo::Property)
								{
									WString cacheKey = L"<att.eval>" + expressionCode;
									auto assembly = Workflow_CompileExpression(context, types, errors, expressionCode);
									context->precompiledCaches.Add(GlobalStringKey::Get(cacheKey), new GuiWorkflowCache(assembly));
								}
								else
								{
									WorkflowDataBinding dataBinding;
									dataBinding.variableName = repr->instanceName;
									Ptr<WfExpression> expression;
									if (Workflow_ValidateExpression(context, types, errors, info, expressionCode, expression))
									{
										dataBinding.propertyInfo = reprTypeInfo.typeDescriptor->GetPropertyByName(propertyName.ToString(), true);
										dataBinding.bindExpression = expression;
									}

									dataBindings.Add(dataBinding);
								}
							}
						}
					}

					FOREACH(Ptr<GuiValueRepr>, value, setter->values)
					{
						value->Accept(this);
					}
				}

				FOREACH_INDEXER(Ptr<GuiAttSetterRepr::EventValue>, handler, index, repr->eventHandlers.Values())
				{
					if (reprTypeInfo.typeDescriptor)
					{
						GlobalStringKey propertyName = repr->eventHandlers.Keys()[index];
						Ptr<GuiInstanceEventInfo> eventInfo;
						IGuiInstanceLoader::PropertyInfo info;
						info.typeInfo = reprTypeInfo;
						info.propertyName = propertyName;

						{
							auto currentLoader = GetInstanceLoaderManager()->GetLoader(info.typeInfo.typeName);

							while (currentLoader && !eventInfo)
							{
								eventInfo = currentLoader->GetEventType(info);
								if (eventInfo && eventInfo->support == GuiInstanceEventInfo::NotSupport)
								{
									eventInfo = 0;
								}
								currentLoader = GetInstanceLoaderManager()->GetParentLoader(currentLoader);
							}
						}

						if (!eventInfo)
						{
							errors.Add(L"Precompile: Cannot find event \"" + propertyName.ToString() + L"\" in type \"" + reprTypeInfo.typeName.ToString() + L"\".");
						}
						else
						{
							WString statementCode = handler->value;

							if (handler->binding == GlobalStringKey::_Eval)
							{
								WString cacheKey = L"<ev.eval><" + repr->instanceName.ToString() + L"><" + propertyName.ToString() + L">" + statementCode;
								auto assembly = Workflow_CompileEventHandler(context, types, errors, info, statementCode);
								context->precompiledCaches.Add(GlobalStringKey::Get(cacheKey), new GuiWorkflowCache(assembly));
							}
						}
					}
				}
			}

			void Visit(GuiConstructorRepr* repr)override
			{
				Visit((GuiAttSetterRepr*)repr);
			}
		};

		void Workflow_PrecompileInstanceContext(Ptr<GuiInstanceContext> context, types::ErrorList& errors)
		{
			ITypeDescriptor* rootTypeDescriptor = 0;
			types::VariableTypeInfoMap typeInfos;
			{
				FOREACH(Ptr<GuiInstanceParameter>, parameter, context->parameters)
				{
					auto type = GetTypeDescriptor(parameter->className.ToString());
					if (!type)
					{
						errors.Add(L"Precompile: Cannot find type \"" + parameter->className.ToString() + L"\".");
					}
					else if (typeInfos.Keys().Contains(parameter->name))
					{
						errors.Add(L"Precompile: Parameter \"" + parameter->name.ToString() + L"\" conflict with an existing named object.");
					}
					else
					{
						IGuiInstanceLoader::TypeInfo typeInfo;
						typeInfo.typeDescriptor = type;
						typeInfo.typeName = GlobalStringKey::Get(type->GetTypeName());
						typeInfos.Add(parameter->name, typeInfo);
					}
				}

				WorkflowReferenceNamesVisitor visitor(context, typeInfos, errors);
				context->instance->Accept(&visitor);
				rootTypeDescriptor = visitor.rootTypeDescriptor;
			}
			{
				WorkflowCompileVisitor visitor(context, typeInfos, errors);
				context->instance->Accept(&visitor);

				if (visitor.dataBindings.Count() > 0 && rootTypeDescriptor)
				{
					auto assembly = Workflow_CompileDataBinding(context, visitor.types, rootTypeDescriptor, errors, visitor.dataBindings);
					context->precompiledCaches.Add(GuiWorkflowCache::CacheContextName, new GuiWorkflowCache(assembly));
				}
			}
		}

/***********************************************************************
GuiWorkflowCache
***********************************************************************/

		const GlobalStringKey& GuiWorkflowCache::CacheTypeName = GlobalStringKey::_Workflow_Assembly_Cache;
		const GlobalStringKey& GuiWorkflowCache::CacheContextName = GlobalStringKey::_Workflow_Global_Context;

		GuiWorkflowCache::GuiWorkflowCache()
		{
		}

		GuiWorkflowCache::GuiWorkflowCache(Ptr<workflow::runtime::WfAssembly> _assembly)
			:assembly(_assembly)
		{
		}

		GlobalStringKey GuiWorkflowCache::GetCacheTypeName()
		{
			return CacheTypeName;
		}

/***********************************************************************
GuiWorkflowCacheResolver
***********************************************************************/

		GlobalStringKey GuiWorkflowCacheResolver::GetCacheTypeName()
		{
			return GuiWorkflowCache::CacheTypeName;
		}

		bool GuiWorkflowCacheResolver::Serialize(Ptr<IGuiResourceCache> cache, stream::IStream& stream)
		{
			if (auto obj = cache.Cast<GuiWorkflowCache>())
			{
				obj->assembly->Serialize(stream);
				return true;
			}
			else
			{
				return false;
			}
		}

		Ptr<IGuiResourceCache> GuiWorkflowCacheResolver::Deserialize(stream::IStream& stream)
		{
			auto assembly = new WfAssembly(stream);
			return new GuiWorkflowCache(assembly);
		}

/***********************************************************************
Workflow_GetSharedManager
***********************************************************************/

#undef ERROR_CODE_PREFIX

		class GuiWorkflowSharedManagerPlugin;
		GuiWorkflowSharedManagerPlugin* sharedManagerPlugin = 0;

		class GuiWorkflowSharedManagerPlugin : public Object, public IGuiPlugin
		{
		protected:
			Ptr<WfLexicalScopeManager>		workflowManager;

		public:
			GuiWorkflowSharedManagerPlugin()
			{
			}

			void Load()override
			{
			}

			void AfterLoad()override
			{
				sharedManagerPlugin = this;

				auto manager=GetResourceResolverManager();
				manager->SetCacheResolver(new GuiWorkflowCacheResolver);
			}

			void Unload()override
			{
				sharedManagerPlugin = 0;
			}

			WfLexicalScopeManager* GetWorkflowManager()
			{
				if (!workflowManager)
				{
					workflowManager = new WfLexicalScopeManager(GetParserManager()->GetParsingTable(L"WORKFLOW"));
				}
				return workflowManager.Obj();
			}
		};
		GUI_REGISTER_PLUGIN(GuiWorkflowSharedManagerPlugin)

		WfLexicalScopeManager* Workflow_GetSharedManager()
		{
			return sharedManagerPlugin->GetWorkflowManager();
		}
	}
}

/***********************************************************************
GUIINSTANCEREPRESENTATION.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace parsing;
		using namespace parsing::xml;
		using namespace templates;
		using namespace stream;

/***********************************************************************
GuiValueRepr
***********************************************************************/

		Ptr<GuiValueRepr> GuiValueRepr::LoadPrecompiledBinary(stream::IStream& stream, collections::List<GlobalStringKey>& keys)
		{
			stream::internal::Reader reader(stream);
			vint key = -1;
			reader << key;
			switch (key)
			{
			case GuiTextRepr::BinaryKey:
				return GuiTextRepr::LoadPrecompiledBinary(stream, keys);
			case GuiAttSetterRepr::BinaryKey:
				return GuiAttSetterRepr::LoadPrecompiledBinary(stream, keys);
			case GuiConstructorRepr::BinaryKey:
				return GuiConstructorRepr::LoadPrecompiledBinary(stream, keys);
			default:
				CHECK_FAIL(L"GuiValueRepr::LoadPrecompiledBinary(stream::IStream&, collections::List<presentation::GlobalStringKey>&)#Internal Error.");
			}
		}

/***********************************************************************
GuiTextRepr
***********************************************************************/

		Ptr<GuiValueRepr> GuiTextRepr::Clone()
		{
			auto repr = MakePtr<GuiTextRepr>();
			repr->fromStyle = fromStyle;
			repr->text = text;
			return repr;
		}

		void GuiTextRepr::FillXml(Ptr<parsing::xml::XmlElement> xml, bool serializePrecompiledResource)
		{
			if (!fromStyle || serializePrecompiledResource)
			{
				auto xmlText = MakePtr<XmlText>();
				xmlText->content.value = text;
				xml->subNodes.Add(xmlText);
			}
		}

		void GuiTextRepr::CollectUsedKey(collections::List<GlobalStringKey>& keys)
		{
		}

		void GuiTextRepr::SavePrecompiledBinary(stream::IStream& stream, collections::SortedList<GlobalStringKey>& keys, bool saveKey)
		{
			stream::internal::Writer writer(stream);
			if (saveKey)
			{
				vint key = BinaryKey;
				writer << key;
			}
			writer << text;
		}

		Ptr<GuiTextRepr> GuiTextRepr::LoadPrecompiledBinary(stream::IStream& stream, collections::List<GlobalStringKey>& keys, Ptr<GuiTextRepr> repr)
		{
			stream::internal::Reader reader(stream);
			if (!repr)
			{
				repr = MakePtr<GuiTextRepr>();
			}
			reader << repr->text;
			return repr;
		}

/***********************************************************************
GuiAttSetterRepr
***********************************************************************/

		void GuiAttSetterRepr::CloneBody(Ptr<GuiAttSetterRepr> repr)
		{
			CopyFrom(repr->eventHandlers, eventHandlers);
			FOREACH_INDEXER(GlobalStringKey, name, index, setters.Keys())
			{
				Ptr<SetterValue> src = setters.Values()[index];
				Ptr<SetterValue> dst = new SetterValue;
				dst->binding = src->binding;
				FOREACH(Ptr<GuiValueRepr>, value, src->values)
				{
					dst->values.Add(value->Clone());
				}
				repr->setters.Add(name, dst);
			}
			repr->instanceName = instanceName;
		}

		Ptr<GuiValueRepr> GuiAttSetterRepr::Clone()
		{
			auto repr = MakePtr<GuiAttSetterRepr>();
			repr->fromStyle = fromStyle;
			CloneBody(repr);
			return repr;
		}

		void GuiAttSetterRepr::FillXml(Ptr<parsing::xml::XmlElement> xml, bool serializePrecompiledResource)
		{
			if (!fromStyle || serializePrecompiledResource)
			{
				if (instanceName != GlobalStringKey::Empty)
				{
					auto attName = MakePtr<XmlAttribute>();
					attName->name.value = L"ref.Name";
					attName->value.value = instanceName.ToString();
					xml->attributes.Add(attName);
				}

				for (vint i = 0; i < setters.Count(); i++)
				{
					auto key = setters.Keys()[i];
					auto value = setters.Values()[i];
					if (key == GlobalStringKey::Empty)
					{
						FOREACH(Ptr<GuiValueRepr>, repr, value->values)
						{
							repr->FillXml(xml, serializePrecompiledResource);
						}
					}
					else
					{
						bool containsElement = false;
						FOREACH(Ptr<GuiValueRepr>, repr, value->values)
						{
							if (!repr.Cast<GuiTextRepr>())
							{
								containsElement = true;
								break;
							}
						}

						if (containsElement)
						{
							auto xmlProp = MakePtr<XmlElement>();
							xmlProp->name.value = L"att." + key.ToString();
							if (value->binding != GlobalStringKey::Empty)
							{
								xmlProp->name.value += L"-" + value->binding.ToString();
							}

							FOREACH(Ptr<GuiValueRepr>, repr, value->values)
							{
								if (!repr.Cast<GuiTextRepr>())
								{
									repr->FillXml(xmlProp, serializePrecompiledResource);
								}
							}
							xml->subNodes.Add(xmlProp);
						}
						else if (value->values.Count() > 0)
						{
							auto att = MakePtr<XmlAttribute>();
							att->name.value = key.ToString();
							if (value->binding != GlobalStringKey::Empty)
							{
								att->name.value += L"-" + value->binding.ToString();
							}
							att->value.value = value->values[0].Cast<GuiTextRepr>()->text;
							xml->attributes.Add(att);
						}
					}
				}

				for (vint i = 0; i < eventHandlers.Count(); i++)
				{
					auto key = eventHandlers.Keys()[i];
					auto value = eventHandlers.Values()[i];

					auto xmlEvent = MakePtr<XmlElement>();
					xmlEvent->name.value = L"ev." + key.ToString();
					if (value->binding != GlobalStringKey::Empty)
					{
						xmlEvent->name.value += L"-" + value->binding.ToString();
					}
					xml->subNodes.Add(xmlEvent);

					auto xmlText = MakePtr<XmlText>();
					xmlText->content.value = value->value;
					xmlEvent->subNodes.Add(xmlText);
				}
			}
		}

		void GuiAttSetterRepr::CollectUsedKey(collections::List<GlobalStringKey>& keys)
		{
			keys.Add(instanceName);

			for (vint i = 0; i < setters.Count(); i++)
			{
				keys.Add(setters.Keys()[i]);
				auto value = setters.Values()[i];
				keys.Add(value->binding);
				for (vint j = 0; j < value->values.Count(); j++)
				{
					value->values[j]->CollectUsedKey(keys);
				}
			}
			
			for (vint i = 0; i < eventHandlers.Count(); i++)
			{
				keys.Add(eventHandlers.Keys()[i]);
				keys.Add(eventHandlers.Values()[i]->binding);
			}
		}

		void GuiAttSetterRepr::SavePrecompiledBinary(stream::IStream& stream, collections::SortedList<GlobalStringKey>& keys, bool saveKey)
		{
			stream::internal::Writer writer(stream);
			if (saveKey)
			{
				vint key = BinaryKey;
				writer << key;
			}
			{
				vint count = setters.Count();
				writer << count;
				for (vint i = 0; i < count; i++)
				{
					auto keyIndex = keys.IndexOf(setters.Keys()[i]);
					auto value = setters.Values()[i];
					auto bindingIndex = keys.IndexOf(value->binding);
					CHECK_ERROR(keyIndex != -1 && bindingIndex != -1, L"GuiAttSetterRepr::SavePrecompiledBinary(stream::IStream&, collections::SortedList<presentation::GlobalStringKey>&)#Internal Error.");
					writer << keyIndex << bindingIndex;

					vint valueCount = value->values.Count();
					writer << valueCount;
					for (vint j = 0; j < valueCount; j++)
					{
						value->values[j]->SavePrecompiledBinary(stream, keys, true);
					}
				}
			}
			{
				vint count = eventHandlers.Count();
				writer << count;
				for (vint i = 0; i < count; i++)
				{
					auto keyIndex = keys.IndexOf(eventHandlers.Keys()[i]);
					auto value = eventHandlers.Values()[i];
					auto bindingIndex = keys.IndexOf(value->binding);
					CHECK_ERROR(keyIndex != -1 && bindingIndex != -1, L"GuiAttSetterRepr::SavePrecompiledBinary(stream::IStream&, collections::SortedList<presentation::GlobalStringKey>&)#Internal Error.");
					writer << keyIndex << bindingIndex << value->value;
				}
			}
			{
				vint instanceNameIndex = keys.IndexOf(instanceName);
				CHECK_ERROR(instanceNameIndex != -1, L"GuiAttSetterRepr::SavePrecompiledBinary(stream::IStream&, collections::SortedList<presentation::GlobalStringKey>&)#Internal Error.");
				writer << instanceNameIndex;
			}
		}

		Ptr<GuiAttSetterRepr> GuiAttSetterRepr::LoadPrecompiledBinary(stream::IStream& stream, collections::List<GlobalStringKey>& keys, Ptr<GuiAttSetterRepr> repr)
		{
			stream::internal::Reader reader(stream);
			if (!repr)
			{
				repr = MakePtr<GuiAttSetterRepr>();
			}
			{
				vint count = -1;
				reader << count;
				for (vint i = 0; i < count; i++)
				{
					vint keyIndex = -1;
					vint bindingIndex = -1;
					auto value = MakePtr<SetterValue>();
					reader << keyIndex << bindingIndex;
					auto key = keys[keyIndex];
					value->binding = keys[bindingIndex];
					repr->setters.Add(key, value);

					vint valueCount = -1;
					reader << valueCount;
					for (vint j = 0; j < valueCount; j++)
					{
						auto repr = GuiValueRepr::LoadPrecompiledBinary(stream, keys);
						value->values.Add(repr);
					}
				}
			}
			{
				vint count = -1;
				reader << count;
				for (vint i = 0; i < count; i++)
				{
					vint keyIndex = -1;
					vint bindingIndex = -1;
					auto value = MakePtr<EventValue>();
					reader << keyIndex << bindingIndex << value->value;
					auto key = keys[keyIndex];
					value->binding = keys[bindingIndex];
					repr->eventHandlers.Add(key, value);
				}
			}
			{
				vint instanceNameIndex = -1;
				reader << instanceNameIndex;
				repr->instanceName = keys[instanceNameIndex];
			}
			return repr;
		}

/***********************************************************************
GuiConstructorRepr
***********************************************************************/

		Ptr<GuiValueRepr> GuiConstructorRepr::Clone()
		{
			auto repr = MakePtr<GuiConstructorRepr>();
			repr->fromStyle = fromStyle;
			repr->typeNamespace = typeNamespace;
			repr->typeName = typeName;
			repr->styleName = styleName;
			CloneBody(repr);
			return repr;
		}

		void GuiConstructorRepr::FillXml(Ptr<parsing::xml::XmlElement> xml, bool serializePrecompiledResource)
		{
			if (!fromStyle || serializePrecompiledResource)
			{
				auto xmlCtor = MakePtr<XmlElement>();
				if (typeNamespace == GlobalStringKey::Empty)
				{
					xmlCtor->name.value = typeName.ToString();
				}
				else
				{
					xmlCtor->name.value = typeNamespace.ToString() + L":" + typeName.ToString();
				}

				if (styleName)
				{
					auto attStyle = MakePtr<XmlAttribute>();
					attStyle->name.value = L"ref.Style";
					attStyle->value.value = styleName.Value();
					xml->attributes.Add(attStyle);
				}

				GuiAttSetterRepr::FillXml(xmlCtor, serializePrecompiledResource);
				xml->subNodes.Add(xmlCtor);
			}
		}

		void GuiConstructorRepr::CollectUsedKey(collections::List<GlobalStringKey>& keys)
		{
			GuiAttSetterRepr::CollectUsedKey(keys);
			keys.Add(typeNamespace);
			keys.Add(typeName);
		}

		void GuiConstructorRepr::SavePrecompiledBinary(stream::IStream& stream, collections::SortedList<GlobalStringKey>& keys, bool saveKey)
		{
			stream::internal::Writer writer(stream);
			if (saveKey)
			{
				vint key = BinaryKey;
				writer << key;
			}
			vint typeNamespaceIndex = keys.IndexOf(typeNamespace);
			vint typeNameIndex = keys.IndexOf(typeName);
			CHECK_ERROR(typeNamespaceIndex != -1 && typeNameIndex != -1, L"GuiConstructorRepr::SavePrecompiledBinary(stream::IStream&, collections::SortedList<presentation::GlobalStringKey>&)#Internal Error.");
			writer << typeNamespaceIndex << typeNameIndex << styleName;
			GuiAttSetterRepr::SavePrecompiledBinary(stream, keys, false);
		}

		Ptr<GuiConstructorRepr> GuiConstructorRepr::LoadPrecompiledBinary(stream::IStream& stream, collections::List<GlobalStringKey>& keys, Ptr<GuiConstructorRepr> repr)
		{
			stream::internal::Reader reader(stream);
			if (!repr)
			{
				repr = MakePtr<GuiConstructorRepr>();
			}
			vint typeNamespaceIndex = -1;
			vint typeNameIndex = -1;
			reader << typeNamespaceIndex << typeNameIndex << repr->styleName;
			repr->typeNamespace = keys[typeNamespaceIndex];
			repr->typeName = keys[typeNameIndex];
			GuiAttSetterRepr::LoadPrecompiledBinary(stream, keys, repr);
			return repr;
		}

/***********************************************************************
GuiInstanceContext
***********************************************************************/

		void GuiInstanceContext::CollectDefaultAttributes(GuiAttSetterRepr::ValueList& values, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				// test if there is only one text value in the xml
				if(xml->subNodes.Count()==1)
				{
					if(Ptr<XmlText> text=xml->subNodes[0].Cast<XmlText>())
					{
						Ptr<GuiTextRepr> value=new GuiTextRepr;
						value->text=text->content.value;
						values.Add(value);
					}
					else if(Ptr<XmlCData> text=xml->subNodes[0].Cast<XmlCData>())
					{
						Ptr<GuiTextRepr> value=new GuiTextRepr;
						value->text=text->content.value;
						values.Add(value);
					}
				}

				// collect default attributes
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml))
				{
					if(auto name=parser->TypedParse(element->name.value, errors))
					{
						if(name->IsCtorName())
						{
							// collect constructor values in the default attribute setter
							auto ctor=LoadCtor(element, errors);
							if(ctor)
							{
								values.Add(ctor);
							}
						}
					}
				}
			}
		}

		void GuiInstanceContext::CollectAttributes(GuiAttSetterRepr::SetteValuerMap& setters, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				Ptr<GuiAttSetterRepr::SetterValue> defaultValue=new GuiAttSetterRepr::SetterValue;

				// collect default attributes
				CollectDefaultAttributes(defaultValue->values, xml, errors);
				if(defaultValue->values.Count()>0)
				{
					setters.Add(GlobalStringKey::Empty, defaultValue);
				}

				// collect values
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml))
				{
					if (auto name = parser->TypedParse(element->name.value, errors))
					{
						if(name->IsPropertyElementName())
						{
							// collect a value as a new attribute setter
							if (setters.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								errors.Add(L"Duplicated attribute name \"" + name->name + L"\".");
							}
							else
							{
								Ptr<GuiAttSetterRepr::SetterValue> sv=new GuiAttSetterRepr::SetterValue;
								sv->binding = GlobalStringKey::Get(name->binding);

								if(name->binding==L"set")
								{
									// if the binding is "set", it means that this element is a complete setter element
									Ptr<GuiAttSetterRepr> setter=new GuiAttSetterRepr;
									FillAttSetter(setter, element, errors);
									sv->values.Add(setter);
								}
								else
								{
									// if the binding is not "set", then this is a single-value attribute or a colection attribute
									// fill all data into this attribute
									CollectDefaultAttributes(sv->values, element, errors);
								}

								if(sv->values.Count()>0)
								{
									setters.Add(GlobalStringKey::Get(name->name), sv);
								}
							}
						}
					}
				}
			}
		}

		void GuiInstanceContext::CollectEvents(GuiAttSetterRepr::EventHandlerMap& eventHandlers, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				// collect values
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml))
				{
					if(auto name=parser->TypedParse(element->name.value, errors))
					{
						if(name->IsEventElementName())
						{
							// collect a value as a new attribute setter
							if (eventHandlers.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								errors.Add(L"Duplicated event name \"" + name->name + L"\".");
							}
							else
							{
								// test if there is only one text value in the xml
								if(element->subNodes.Count()==1)
								{
									if(Ptr<XmlText> text=element->subNodes[0].Cast<XmlText>())
									{
										auto value = MakePtr<GuiAttSetterRepr::EventValue>();
										value->binding = GlobalStringKey::Get(name->binding);
										value->value = text->content.value;
										eventHandlers.Add(GlobalStringKey::Get(name->name), value);
									}
									else if(Ptr<XmlCData> text=element->subNodes[0].Cast<XmlCData>())
									{
										auto value = MakePtr<GuiAttSetterRepr::EventValue>();
										value->binding = GlobalStringKey::Get(name->binding);
										value->value = text->content.value;
										eventHandlers.Add(GlobalStringKey::Get(name->name), value);
									}
								}
							}
						}
					}
				}
			}
		}

		void GuiInstanceContext::FillAttSetter(Ptr<GuiAttSetterRepr> setter, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				// collect attributes as setters
				FOREACH(Ptr<XmlAttribute>, att, xml->attributes)
				{
					if (auto name = parser->TypedParse(att->name.value, errors))
					{
						if(name->IsReferenceAttributeName())
						{
							// collect reference attributes
							if (name->name == L"Name")
							{
								setter->instanceName = GlobalStringKey::Get(att->value.value);
							}
						}
						else if(name->IsPropertyAttributeName())
						{
							// collect attributes setters
							if (setter->setters.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								errors.Add(L"Duplicated attribute name \"" + name->name + L"\".");
							}
							else
							{
								Ptr<GuiAttSetterRepr::SetterValue> sv=new GuiAttSetterRepr::SetterValue;
								sv->binding=GlobalStringKey::Get(name->binding);
								setter->setters.Add(GlobalStringKey::Get(name->name), sv);

								Ptr<GuiTextRepr> value=new GuiTextRepr;
								value->text=att->value.value;
								sv->values.Add(value);
							}
						}
						else if (name->IsEventAttributeName())
						{
							// collect event setters
							if (!setter->eventHandlers.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								auto value = MakePtr<GuiAttSetterRepr::EventValue>();
								value->binding = GlobalStringKey::Get(name->binding);
								value->value = att->value.value;
								setter->eventHandlers.Add(GlobalStringKey::Get(name->name), value);
							}
						}
					}
				}

				// collect attributes and events
				CollectAttributes(setter->setters, xml, errors);
				CollectEvents(setter->eventHandlers, xml, errors);
			}
		}

		Ptr<GuiConstructorRepr> GuiInstanceContext::LoadCtor(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if (auto parser = GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				if (auto name = parser->TypedParse(xml->name.value, errors))
				{
					if(name->IsCtorName())
					{
						Ptr<GuiConstructorRepr> ctor=new GuiConstructorRepr;
						ctor->typeNamespace = GlobalStringKey::Get(name->namespaceName);
						ctor->typeName = GlobalStringKey::Get(name->name);
						// collect attributes as setters
						FOREACH(Ptr<XmlAttribute>, att, xml->attributes)
						{
							if(auto name=parser->TypedParse(att->name.value, errors))
							if(name->IsReferenceAttributeName())
							{
								if (name->name == L"Style")
								{
									ctor->styleName = att->value.value;
								}
							}
						}
						FillAttSetter(ctor, xml, errors);
						return ctor;
					}
					else
					{
						errors.Add(L"Wrong constructor name \"" + xml->name.value + L"\".");
					}
				}
			}
			return 0;
		}

		Ptr<GuiInstanceContext> GuiInstanceContext::LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors)
		{
			Ptr<GuiInstanceContext> context=new GuiInstanceContext;
			if(xml->rootElement->name.value==L"Instance")
			{
				if (auto codeBehindAttr = XmlGetAttribute(xml->rootElement, L"ref.CodeBehind"))
				{
					context->codeBehind = codeBehindAttr->value.value == L"true";
				}

				// load type name
				if (auto classAttr = XmlGetAttribute(xml->rootElement, L"ref.Class"))
				{
					context->className = classAttr->value.value;
				}

				// load style names
				if (auto styleAttr = XmlGetAttribute(xml->rootElement, L"ref.Styles"))
				{
					SplitBySemicolon(styleAttr->value.value, context->stylePaths);
				}

				// load namespaces
				List<Ptr<XmlAttribute>> namespaceAttributes;
				CopyFrom(namespaceAttributes, xml->rootElement->attributes);
				if(!XmlGetAttribute(xml->rootElement, L"xmlns"))
				{
					Ptr<XmlAttribute> att=new XmlAttribute;
					att->name.value=L"xmlns";
					att->value.value =
						L"presentation::controls::Gui*;"
						L"presentation::elements::Gui*Element;"
						L"presentation::compositions::Gui*Composition;"
						L"presentation::compositions::Gui*;"
						L"presentation::templates::Gui*;"
						L"system::*;"
						L"system::reflection::*;"
						L"presentation::*;"
						L"presentation::Gui*;"
						L"presentation::controls::*;"
						L"presentation::controls::list::*;"
						L"presentation::controls::tree::*;"
						L"presentation::elements::*;"
						L"presentation::elements::Gui*;"
						L"presentation::elements::text*;"
						L"presentation::compositions::*;"
						L"presentation::templates::*";
					namespaceAttributes.Add(att);
				}
				FOREACH(Ptr<XmlAttribute>, att, namespaceAttributes)
				{
					// check if the attribute defines a namespace
					WString attName=att->name.value;
					if(attName.Length()>=5 && attName.Left(5)==L"xmlns")
					{
						GlobalStringKey ns;
						if(attName.Length()>6)
						{
							if(attName.Left(6)==L"xmlns:")
							{
								ns = GlobalStringKey::Get(attName.Sub(6, attName.Length() - 6));
							}
							else
							{
								continue;
							}
						}

						// create a data structure for the namespace
						Ptr<NamespaceInfo> info;
						vint index=context->namespaces.Keys().IndexOf(ns);
						if(index==-1)
						{
							info=new NamespaceInfo;
							info->name=ns;
							context->namespaces.Add(ns, info);
						}
						else
						{
							info=context->namespaces.Values()[index];
						}

						// extract all patterns in the namespace, split the value by ';'
						List<WString> patterns;
						SplitBySemicolon(att->value.value, patterns);
						FOREACH(WString, pattern, patterns)
						{
							// add the pattern to the namespace
							Ptr<GuiInstanceNamespace> ns=new GuiInstanceNamespace;
							Pair<vint, vint> star=INVLOC.FindFirst(pattern, L"*", Locale::None);
							if(star.key==-1)
							{
								ns->prefix=pattern;
							}
							else
							{
								ns->prefix=pattern.Sub(0, star.key);
								ns->postfix=pattern.Sub(star.key+star.value, pattern.Length()-star.key-star.value);
							}
							info->namespaces.Add(ns);
						}
					}
				}

				// load instance
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml->rootElement))
				{
					if (element->name.value == L"ref.Parameter")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attClass = XmlGetAttribute(element, L"Class");
						if (attName && attClass)
						{
							auto parameter = MakePtr<GuiInstanceParameter>();
							parameter->name = GlobalStringKey::Get(attName->value.value);
							parameter->className = GlobalStringKey::Get(attClass->value.value);
							context->parameters.Add(parameter);
						}
					}
					else if (element->name.value == L"ref.Property")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attType = XmlGetAttribute(element, L"Type");
						auto attReadonly = XmlGetAttribute(element, L"Readonly");
						if (attName && attType)
						{
							auto prop = MakePtr<GuiInstanceProperty>();
							prop->name = GlobalStringKey::Get(attName->value.value);
							prop->typeName = attType->value.value;
							if (attReadonly)
							{
								prop->readonly = attReadonly->value.value == L"true";
							}
							context->properties.Add(prop);
						}
					}
					else if (element->name.value == L"ref.State")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attType = XmlGetAttribute(element, L"Type");
						if (attName && attType)
						{
							auto state = MakePtr<GuiInstanceState>();
							state->name = GlobalStringKey::Get(attName->value.value);
							state->typeName = attType->value.value;
							context->states.Add(state);
						}
					}
					else if (element->name.value == L"ref.Caches")
					{
						IGuiResourceCache::LoadFromXml(element, context->precompiledCaches);
					}
					else if (!context->instance)
					{
						context->instance=LoadCtor(element, errors);
					}
				}
			}

			return context->instance ? context : nullptr;
		}

		Ptr<parsing::xml::XmlDocument> GuiInstanceContext::SaveToXml(bool serializePrecompiledResource)
		{
			auto xmlInstance = MakePtr<XmlElement>();
			xmlInstance->name.value = L"Instance";

			{
				auto attCodeBehind = MakePtr<XmlAttribute>();
				attCodeBehind->name.value = L"ref.CodeBehind";
				attCodeBehind->value.value = codeBehind ? L"true" : L"false";
				xmlInstance->attributes.Add(attCodeBehind);
			}
			
			if (className)
			{
				auto attClass = MakePtr<XmlAttribute>();
				attClass->name.value = L"ref.Class";
				attClass->value.value = className.Value();
				xmlInstance->attributes.Add(attClass);
			}

			for (vint i = 0; i < namespaces.Count(); i++)
			{
				auto key = namespaces.Keys()[i];
				auto value = namespaces.Values()[i];

				auto xmlns = MakePtr<XmlAttribute>();
				xmlns->name.value = L"xmlns";
				if (key != GlobalStringKey::Empty)
				{
					xmlns->name.value += L":" + key.ToString();
				}
				xmlInstance->attributes.Add(xmlns);

				for (vint j = 0; j < value->namespaces.Count(); j++)
				{
					auto ns = value->namespaces[j];
					if (j != 0)
					{
						xmlns->value.value += L";";
					}
					xmlns->value.value += ns->prefix + L"*" + ns->postfix;
				}
			}

			FOREACH(Ptr<GuiInstanceParameter>, parameter, parameters)
			{
				auto xmlParameter = MakePtr<XmlElement>();
				xmlParameter->name.value = L"ref.Parameter";
				xmlInstance->subNodes.Add(xmlParameter);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = parameter->name.ToString();
				xmlParameter->attributes.Add(attName);

				auto attClass = MakePtr<XmlAttribute>();
				attClass->name.value = L"Class";
				attClass->value.value = parameter->className.ToString();
				xmlParameter->attributes.Add(attClass);
			}

			FOREACH(Ptr<GuiInstanceProperty>, prop, properties)
			{
				auto xmlProperty = MakePtr<XmlElement>();
				xmlProperty->name.value = L"ref.Property";
				xmlInstance->subNodes.Add(xmlProperty);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = prop->name.ToString();
				xmlProperty->attributes.Add(attName);

				auto attType = MakePtr<XmlAttribute>();
				attType->name.value = L"Type";
				attType->value.value = prop->typeName;
				xmlProperty->attributes.Add(attType);

				auto attReadonly = MakePtr<XmlAttribute>();
				attReadonly->name.value = L"Readonly";
				attReadonly->value.value = prop->readonly ? L"true" : L"false";
				xmlProperty->attributes.Add(attReadonly);
			}

			FOREACH(Ptr<GuiInstanceState>, state, states)
			{
				auto xmlState = MakePtr<XmlElement>();
				xmlState->name.value = L"ref.State";
				xmlInstance->subNodes.Add(xmlState);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = state->name.ToString();
				xmlState->attributes.Add(attName);

				auto attType = MakePtr<XmlAttribute>();
				attType->name.value = L"Type";
				attType->value.value = state->typeName;
				xmlState->attributes.Add(attType);
			}

			if (!serializePrecompiledResource && stylePaths.Count() > 0)
			{
				auto attStyles = MakePtr<XmlAttribute>();
				attStyles->name.value = L"ref.Styles";
				xmlInstance->attributes.Add(attStyles);

				for (vint j = 0; j < stylePaths.Count(); j++)
				{
					if (j != 0)
					{
						attStyles->value.value += L";";
					}
					attStyles->value.value += stylePaths[j];
				}
			}

			if (serializePrecompiledResource && precompiledCaches.Count() > 0)
			{
				auto xmlCaches = MakePtr<XmlElement>();
				xmlCaches->name.value = L"ref.Caches";
				xmlInstance->subNodes.Add(xmlCaches);
				IGuiResourceCache::SaveToXml(xmlCaches, precompiledCaches);
			}

			instance->FillXml(xmlInstance, serializePrecompiledResource);

			auto doc = MakePtr<XmlDocument>();
			doc->rootElement = xmlInstance;
			return doc;
		}

		Ptr<GuiInstanceContext> GuiInstanceContext::LoadPrecompiledBinary(stream::IStream& stream, collections::List<WString>& errors)
		{
			stream::internal::Reader reader(stream);
			List<GlobalStringKey> sortedKeys;
			{
				vint count = 0;
				reader << count;

				for (vint i = 0; i < count; i++)
				{
					WString keyString;
					reader << keyString;
					sortedKeys.Add(GlobalStringKey::Get(keyString));
				}
			}

			auto context = MakePtr<GuiInstanceContext>();
			context->appliedStyles = true;
			{
				context->instance = GuiConstructorRepr::LoadPrecompiledBinary(stream, sortedKeys);
			}
			{
				vint count = -1;
				reader << count;
				for (vint i = 0; i < count; i++)
				{
					vint keyIndex = -1;
					vint valueNameIndex = -1;
					reader << keyIndex << valueNameIndex;

					auto key = sortedKeys[keyIndex];
					auto ni = MakePtr<NamespaceInfo>();
					ni->name = sortedKeys[valueNameIndex];
					context->namespaces.Add(key, ni);

					vint valueCount = -1;
					reader << valueCount;
					for (vint j = 0; j < valueCount; j++)
					{
						auto ns = MakePtr<GuiInstanceNamespace>();
						reader << ns->prefix << ns->postfix;
						ni->namespaces.Add(ns);
					}
				}
			}
			{
				reader << context->codeBehind << context->className;
			}
			{
				vint count = -1;
				reader << count;
				for (vint i = 0; i < count; i++)
				{
					vint nameIndex = -1;
					vint classNameIndex = -1;
					reader << nameIndex << classNameIndex;

					auto parameter = MakePtr<GuiInstanceParameter>();
					parameter->name = sortedKeys[nameIndex];
					parameter->className = sortedKeys[classNameIndex];
					context->parameters.Add(parameter);
				}
			}
			{
				vint count = -1;
				reader << count;
				for (vint i = 0; i < count; i++)
				{
					vint nameIndex = -1;
					WString typeName;
					bool readonly = false;
					reader << nameIndex << typeName << readonly;

					auto prop = MakePtr<GuiInstanceProperty>();
					prop->name = sortedKeys[nameIndex];
					prop->typeName = typeName;
					prop->readonly = readonly;
					context->properties.Add(prop);
				}
			}
			{
				vint count = -1;
				reader << count;
				for (vint i = 0; i < count; i++)
				{
					vint nameIndex = -1;
					WString typeName;
					reader << nameIndex << typeName;

					auto state = MakePtr<GuiInstanceState>();
					state->name = sortedKeys[nameIndex];
					state->typeName = typeName;
					context->states.Add(state);
				}
			}
			IGuiResourceCache::LoadFromBinary(reader, context->precompiledCaches, sortedKeys);

			return context;
		}

		void GuiInstanceContext::SavePrecompiledBinary(stream::IStream& stream)
		{
			stream::internal::Writer writer(stream);
			SortedList<GlobalStringKey> sortedKeys;
			{
				List<GlobalStringKey> keys;
				CollectUsedKey(keys);
				CopyFrom(sortedKeys, From(keys).Distinct());

				vint count = sortedKeys.Count();
				writer << count;
				FOREACH(GlobalStringKey, key, sortedKeys)
				{
					WString keyString = key.ToString();
					writer << keyString;
				}
			}
			{
				instance->SavePrecompiledBinary(stream, sortedKeys, false);
			}
			{
				vint count = namespaces.Count();
				writer << count;
				for (vint i = 0; i < count; i++)
				{
					auto keyIndex = sortedKeys.IndexOf(namespaces.Keys()[i]);
					auto value = namespaces.Values()[i];
					auto valueNameIndex = sortedKeys.IndexOf(value->name);
					CHECK_ERROR(keyIndex != -1 && valueNameIndex != -1, L"GuiInstanceContext::SavePrecompiledBinary(stream::IStream&)#Internal Error.");
					writer << keyIndex << valueNameIndex;

					vint valueCount = value->namespaces.Count();
					writer << valueCount;
					FOREACH(Ptr<GuiInstanceNamespace>, ns, value->namespaces)
					{
						writer << ns->prefix << ns->postfix;
					}
				}
			}
			{
				writer << codeBehind << className;
			}
			{
				vint count = parameters.Count();
				writer << count;
				FOREACH(Ptr<GuiInstanceParameter>, parameter, parameters)
				{
					vint nameIndex = sortedKeys.IndexOf(parameter->name);
					vint classNameIndex = sortedKeys.IndexOf(parameter->className);
					CHECK_ERROR(nameIndex != -1 && classNameIndex != -1, L"GuiInstanceContext::SavePrecompiledBinary(stream::IStream&)#Internal Error.");
					writer << nameIndex << classNameIndex;
				}
			}
			{
				vint count = properties.Count();
				writer << count;
				FOREACH(Ptr<GuiInstanceProperty>, prop, properties)
				{
					vint nameIndex = sortedKeys.IndexOf(prop->name);
					WString typeName = prop->typeName;
					bool readonly = prop->readonly;
					CHECK_ERROR(nameIndex != -1, L"GuiInstanceContext::SavePrecompiledBinary(stream::IStream&)#Internal Error.");
					writer << nameIndex << typeName << readonly;
				}
			}
			{
				vint count = states.Count();
				writer << count;
				FOREACH(Ptr<GuiInstanceState>, state, states)
				{
					vint nameIndex = sortedKeys.IndexOf(state->name);
					WString typeName = state->typeName;
					CHECK_ERROR(nameIndex != -1, L"GuiInstanceContext::SavePrecompiledBinary(stream::IStream&)#Internal Error.");
					writer << nameIndex << typeName;
				}
			}
			
			IGuiResourceCache::SaveToBinary(writer, precompiledCaches, sortedKeys);
		}

		void GuiInstanceContext::CollectUsedKey(collections::List<GlobalStringKey>& keys)
		{
			instance->CollectUsedKey(keys);
			
			for (vint i = 0; i < namespaces.Count(); i++)
			{
				keys.Add(namespaces.Keys()[i]);
				keys.Add(namespaces.Values()[i]->name);
			}

			for (vint i = 0; i < parameters.Count(); i++)
			{
				keys.Add(parameters[i]->name);
				keys.Add(parameters[i]->className);
			}

			for (vint i = 0; i < properties.Count(); i++)
			{
				keys.Add(properties[i]->name);
			}

			for (vint i = 0; i < states.Count(); i++)
			{
				keys.Add(states[i]->name);
			}

			for (vint i = 0; i < precompiledCaches.Count(); i++)
			{
				keys.Add(precompiledCaches.Keys()[i]);
				keys.Add(precompiledCaches.Values()[i]->GetCacheTypeName());
			}
		}

		bool GuiInstanceContext::ApplyStyles(Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)
		{
			if (!appliedStyles)
			{
				appliedStyles = true;

				List<Ptr<GuiInstanceStyle>> styles;
				FOREACH(WString, uri, stylePaths)
				{
					WString protocol, path;
					if (IsResourceUrl(uri, protocol, path))
					{
						if (auto styleContext = resolver->ResolveResource(protocol, path).Cast<GuiInstanceStyleContext>())
						{
							CopyFrom(styles, styleContext->styles, true);
						}
						else
						{
							errors.Add(L"Failed to find the style referred in attribute \"ref.Styles\": \"" + uri + L"\".");
						}
					}
					else
					{
						errors.Add(L"Invalid path in attribute \"ref.Styles\": \"" + uri + L"\".");
					}
				}

				FOREACH(Ptr<GuiInstanceStyle>, style, styles)
				{
					List<Ptr<GuiConstructorRepr>> output;
					ExecuteQuery(style->query, this, output);
					FOREACH(Ptr<GuiConstructorRepr>, ctor, output)
					{
						ApplyStyle(style, ctor);
					}
				}

				return true;
			}
			else
			{
				return false;
			}
		}

/***********************************************************************
GuiInstanceStyle
***********************************************************************/

		namespace visitors
		{
			class SetStyleMarkVisitor : public Object, public GuiValueRepr::IVisitor
			{
			public:
				void Visit(GuiTextRepr* repr)override
				{
					repr->fromStyle = true;
				}

				void Visit(GuiAttSetterRepr* repr)override
				{
					repr->fromStyle = true;
					FOREACH(Ptr<GuiAttSetterRepr::SetterValue>, value, repr->setters.Values())
					{
						FOREACH(Ptr<GuiValueRepr>, subValue, value->values)
						{
							subValue->Accept(this);
						}
					}
					FOREACH(Ptr<GuiAttSetterRepr::EventValue>, value, repr->eventHandlers.Values())
					{
						value->fromStyle = true;
					}
				}

				void Visit(GuiConstructorRepr* repr)override
				{
					Visit((GuiAttSetterRepr*)repr);
				}
			};
		}
		using namespace visitors;

		Ptr<GuiInstanceStyle> GuiInstanceStyle::LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			auto style = MakePtr<GuiInstanceStyle>();
			if (auto pathAttr = XmlGetAttribute(xml, L"ref.Path"))
			{
				auto parser = GetParserManager()->GetParser<GuiIqQuery>(L"INSTANCE-QUERY");
				if (auto query = parser->TypedParse(pathAttr->value.value, errors))
				{
					style->query = query;
				}
				else
				{
					return 0;
				}
			}
			else
			{
				errors.Add(L"Missing attribute \"ref.Path\" in <Style>.");
			}
			style->setter = MakePtr<GuiAttSetterRepr>();
			GuiInstanceContext::FillAttSetter(style->setter, xml, errors);

			SetStyleMarkVisitor visitor;
			style->setter->Accept(&visitor);
			return style;
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceStyle::SaveToXml()
		{
			auto xmlStyle = MakePtr<XmlElement>();
			xmlStyle->name.value = L"Style";

			auto attPath = MakePtr<XmlAttribute>();
			attPath->name.value = L"ref.Path";
			{
				MemoryStream stream;
				{
					StreamWriter writer(stream);
					GuiIqPrint(query, writer);
				}
				stream.SeekFromBegin(0);
				{
					StreamReader reader(stream);
					attPath->value.value = reader.ReadToEnd();
				}
			}
			xmlStyle->attributes.Add(attPath);

			setter->FillXml(xmlStyle, true);

			return xmlStyle;
		}

/***********************************************************************
GuiInstanceStyleContext
***********************************************************************/

		Ptr<GuiInstanceStyleContext> GuiInstanceStyleContext::LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors)
		{
			auto context = MakePtr<GuiInstanceStyleContext>();
			FOREACH(Ptr<XmlElement>, styleElement, XmlGetElements(xml->rootElement))
			{
				if (styleElement->name.value == L"Style")
				{
					if (auto style = GuiInstanceStyle::LoadFromXml(styleElement, errors))
					{
						context->styles.Add(style);
					}
				}
				else
				{
					errors.Add(L"Unknown style type \"" + styleElement->name.value + L"\".");
				}
			}
			return context;
		}

		Ptr<parsing::xml::XmlDocument> GuiInstanceStyleContext::SaveToXml()
		{
			auto xmlStyles = MakePtr<XmlElement>();
			xmlStyles->name.value = L"Styles";

			FOREACH(Ptr<GuiInstanceStyle>, style, styles)
			{
				xmlStyles->subNodes.Add(style->SaveToXml());
			}

			auto doc = MakePtr<XmlDocument>();
			doc->rootElement = xmlStyles;
			return doc;
		}
	}
}

/***********************************************************************
GUIINSTANCESCHEMAREPRESENTATION.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace parsing::xml;

/***********************************************************************
GuiInstancePropertySchame
***********************************************************************/

		Ptr<GuiInstancePropertySchame> GuiInstancePropertySchame::LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			auto schema = MakePtr<GuiInstancePropertySchame>();
			if (auto attName = XmlGetAttribute(xml, L"Name"))
			{
				schema->name = attName->value.value;
			}
			else
			{
				errors.Add(L"Missing attribute \"Name\" in <" + xml->name.value + L">.");
			}
			if (auto attName = XmlGetAttribute(xml, L"Type"))
			{
				schema->typeName = attName->value.value;
			}
			else
			{
				errors.Add(L"Missing attribute \"Type\" in <" + xml->name.value + L">.");
			}
			if (auto attReadonly = XmlGetAttribute(xml, L"Readonly"))
			{
				schema->readonly = attReadonly->value.value == L"true";
			}
			if (auto attObservable = XmlGetAttribute(xml, L"Observable"))
			{
				schema->observable = attObservable->value.value == L"true";
			}
			return schema;
		}

		Ptr<parsing::xml::XmlElement> GuiInstancePropertySchame::SaveToXml()
		{
			auto xmlProperty = MakePtr<XmlElement>();
			xmlProperty->name.value = L"Property";
			
			auto attName = MakePtr<XmlAttribute>();
			attName->name.value = L"Name";
			attName->value.value = name;
			xmlProperty->attributes.Add(attName);
			
			auto attType = MakePtr<XmlAttribute>();
			attType->name.value = L"Type";
			attType->value.value = typeName;
			xmlProperty->attributes.Add(attType);
			
			auto attReadonly = MakePtr<XmlAttribute>();
			attReadonly->name.value = L"Readonly";
			attReadonly->value.value = readonly ? L"true" : L"false";
			xmlProperty->attributes.Add(attReadonly);
			
			auto attObservable = MakePtr<XmlAttribute>();
			attObservable->name.value = L"Observable";
			attObservable->value.value = observable ? L"true" : L"false";
			xmlProperty->attributes.Add(attObservable);

			return xmlProperty;
		}

/***********************************************************************
GuiInstanceTypeSchema
***********************************************************************/

		void GuiInstanceTypeSchema::LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if (auto attName = XmlGetAttribute(xml, L"ref.Class"))
			{
				typeName = attName->value.value;
			}
			else
			{
				errors.Add(L"Missing attribute \"ref.Class\" in <" + xml->name.value + L">.");
			}
			if (auto attParent = XmlGetAttribute(xml, L"Parent"))
			{
				parentType = attParent->value.value;
			}
			FOREACH(Ptr<XmlElement>, memberElement, XmlGetElements(xml, L"Property"))
			{
				auto prop = GuiInstancePropertySchame::LoadFromXml(memberElement, errors);
				properties.Add(prop);
			}
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceTypeSchema::SaveToXml()
		{
			auto xmlType = MakePtr<XmlElement>();
			
			auto attClass = MakePtr<XmlAttribute>();
			attClass->name.value = L"ref.Class";
			attClass->value.value = typeName;
			xmlType->attributes.Add(attClass);

			if (parentType != L"")
			{
				auto attParent = MakePtr<XmlAttribute>();
				attParent->name.value = L"Parent";
				attParent->value.value = parentType;
				xmlType->attributes.Add(attParent);
			}

			FOREACH(Ptr<GuiInstancePropertySchame>, prop, properties)
			{
				xmlType->subNodes.Add(prop->SaveToXml());
			}

			return xmlType;
		}

/***********************************************************************
GuiInstanceDataSchema
***********************************************************************/

		Ptr<GuiInstanceDataSchema> GuiInstanceDataSchema::LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			auto schema = MakePtr<GuiInstanceDataSchema>();
			schema->GuiInstanceTypeSchema::LoadFromXml(xml, errors);
			schema->referenceType = xml->name.value == L"Class";

			if (!schema->referenceType)
			{
				if (schema->parentType != L"")
				{
					errors.Add(
						L"Struct \"" + schema->parentType +
						L"\" should not have a parent type."
						);
				}
			}

			FOREACH(Ptr<GuiInstancePropertySchame>, prop, schema->properties)
			{
				if (prop->readonly)
				{
					errors.Add(
						L"Property \"" + prop->name +
						L"\" should not be readonly in data type \"" + schema->typeName +
						L"\"."
						);
				}
				if (prop->observable)
				{
					errors.Add(
						L"Property \"" + prop->name +
						L"\" should not be observable in data type \"" + schema->typeName +
						L"\"."
						);
				}
			}
			return schema;
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceDataSchema::SaveToXml()
		{
			auto xmlType = GuiInstanceTypeSchema::SaveToXml();
			xmlType->name.value = referenceType ? L"Class" : L"Struct";
			return xmlType;
		}

/***********************************************************************
GuiInstanceInterfaceSchema
***********************************************************************/

		Ptr<GuiInstanceMethodSchema> GuiInstanceMethodSchema::LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			auto schema = MakePtr<GuiInstanceMethodSchema>();
			if (auto attName = XmlGetAttribute(xml, L"Name"))
			{
				schema->name = attName->value.value;
			}
			else
			{
				errors.Add(L"Missing attribute \"Name\" in <" + xml->name.value + L">.");
			}
			if (auto attName = XmlGetAttribute(xml, L"Type"))
			{
				schema->returnType = attName->value.value;
			}
			else
			{
				errors.Add(L"Missing attribute \"Type\" in <" + xml->name.value + L">.");
			}
			FOREACH(Ptr<XmlElement>, memberElement, XmlGetElements(xml, L"Argument"))
			{
				auto prop = GuiInstancePropertySchame::LoadFromXml(memberElement, errors);
				schema->arguments.Add(prop);
			}
			return schema;
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceMethodSchema::SaveToXml()
		{
			auto xmlMethod = MakePtr<XmlElement>();
			xmlMethod->name.value = L"Method";
			
			auto attName = MakePtr<XmlAttribute>();
			attName->name.value = L"Name";
			attName->value.value = name;
			xmlMethod->attributes.Add(attName);
			
			auto attType = MakePtr<XmlAttribute>();
			attType->name.value = L"Type";
			attType->value.value = returnType;
			xmlMethod->attributes.Add(attType);

			FOREACH(Ptr<GuiInstancePropertySchame>, prop, arguments)
			{
				xmlMethod->subNodes.Add(prop->SaveToXml());
			}

			return xmlMethod;
		}

/***********************************************************************
GuiInstanceInterfaceSchema
***********************************************************************/

		Ptr<GuiInstanceInterfaceSchema> GuiInstanceInterfaceSchema::LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			auto schema = MakePtr<GuiInstanceInterfaceSchema>();
			schema->GuiInstanceTypeSchema::LoadFromXml(xml, errors);
			FOREACH(Ptr<XmlElement>, memberElement, XmlGetElements(xml, L"Method"))
			{
				auto method = GuiInstanceMethodSchema::LoadFromXml(memberElement, errors);
				schema->methods.Add(method);
			}
			return schema;
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceInterfaceSchema::SaveToXml()
		{
			auto xmlType = GuiInstanceTypeSchema::SaveToXml();
			xmlType->name.value = L"Interface";

			FOREACH(Ptr<GuiInstanceMethodSchema>, method, methods)
			{
				xmlType->subNodes.Add(method->SaveToXml());
			}

			return xmlType;
		}

/***********************************************************************
GuiInstanceSchema
***********************************************************************/

		Ptr<GuiInstanceSchema> GuiInstanceSchema::LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors)
		{
			auto schema = MakePtr<GuiInstanceSchema>();
			FOREACH(Ptr<XmlElement>, schemaElement, XmlGetElements(xml->rootElement))
			{
				if (schemaElement->name.value == L"Struct" || schemaElement->name.value == L"Class")
				{
					schema->schemas.Add(GuiInstanceDataSchema::LoadFromXml(schemaElement, errors));
				}
				else if (schemaElement->name.value == L"Interface")
				{
					schema->schemas.Add(GuiInstanceInterfaceSchema::LoadFromXml(schemaElement, errors));
				}
				else
				{
					errors.Add(L"Unknown schema type \"" + schemaElement->name.value + L"\".");
				}
			}
			return schema;
		}

		Ptr<parsing::xml::XmlDocument> GuiInstanceSchema::SaveToXml()
		{
			auto xmlElement = MakePtr<XmlElement>();
			xmlElement->name.value = L"InstanceSchema";

			FOREACH(Ptr<GuiInstanceTypeSchema>, type, schemas)
			{
				xmlElement->subNodes.Add(type->SaveToXml());
			}

			auto doc = MakePtr<XmlDocument>();
			doc->rootElement = xmlElement;
			return doc;
		}
	}
}

/***********************************************************************
GUIINSTANCESHAREDSCRIPT.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace parsing::xml;

/***********************************************************************
GuiInstanceSharedScript
***********************************************************************/

		Ptr<GuiInstanceSharedScript> GuiInstanceSharedScript::LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors)
		{
			auto script = MakePtr<GuiInstanceSharedScript>();
			script->language = xml->rootElement->name.value;
			script->code = XmlGetValue(xml->rootElement);
			return script;
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceSharedScript::SaveToXml()
		{
			auto cdata = MakePtr<XmlCData>();
			cdata->content.value = code;

			auto xml = MakePtr<XmlElement>();
			xml->name.value = language;
			xml->subNodes.Add(cdata);

			return xml;
		}
	}
}

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;

/***********************************************************************
ExecuteQueryVisitor
***********************************************************************/

		class ExecuteQueryVisitor : public Object, public GuiIqQuery::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			List<Ptr<GuiConstructorRepr>>&		input;
			List<Ptr<GuiConstructorRepr>>&		output;

			ExecuteQueryVisitor(Ptr<GuiInstanceContext> _context, List<Ptr<GuiConstructorRepr>>& _input, List<Ptr<GuiConstructorRepr>>& _output)
				:context(_context), input(_input), output(_output)
			{
			}

			static bool TestCtor(GuiIqPrimaryQuery* node, GlobalStringKey attribute, Ptr<GuiConstructorRepr> ctor)
			{
				if (node->attributeNameOption == GuiIqNameOption::Specified && node->attributeName.value != attribute.ToString())
				{
					return false;
				}
				if (node->typeNameOption == GuiIqNameOption::Specified && node->typeName.value != ctor->typeName.ToString())
				{
					return false;
				}
				if (node->referenceName.value != L"")
				{
					bool instanceName = ctor->instanceName != GlobalStringKey::Empty && node->referenceName.value == ctor->instanceName.ToString();
					bool styleName = ctor->styleName && node->referenceName.value == ctor->styleName.Value();
					return instanceName || styleName;
				}
				return true;
			}

			void Traverse(GuiIqPrimaryQuery* node, Ptr<GuiAttSetterRepr> setter)
			{
				if (setter)
				{
					FOREACH_INDEXER(GlobalStringKey, attribute, index, setter->setters.Keys())
					{
						auto setterValue = setter->setters.Values()[index];
						FOREACH(Ptr<GuiValueRepr>, value, setterValue->values)
						{
							if (auto ctor = value.Cast<GuiConstructorRepr>())
							{
								if (TestCtor(node, attribute, ctor))
								{
									output.Add(ctor);
								}
							}
							if (node->childOption == GuiIqChildOption::Indirect)
							{
								if (auto setter = value.Cast<GuiAttSetterRepr>())
								{
									Traverse(node, setter);
								}
							}
						}
					}
				}
				else
				{
					if (TestCtor(node, GlobalStringKey::Empty, context->instance))
					{
						output.Add(context->instance);
					}
					if (node->childOption == GuiIqChildOption::Indirect)
					{
						Traverse(node, context->instance);
					}
				}
			}

			void Visit(GuiIqPrimaryQuery* node)override
			{
				auto inputExists = &input;
				if (inputExists)
				{
					FOREACH(Ptr<GuiConstructorRepr>, setter, input)
					{
						Traverse(node, setter);
					}
				}
				else
				{
					Traverse(node, 0);
				}
			}

			void Visit(GuiIqCascadeQuery* node)override
			{
				List<Ptr<GuiConstructorRepr>> temp;
				ExecuteQuery(node->parent, context, input, temp);
				ExecuteQuery(node->child, context, temp, output);
			}

			void Visit(GuiIqSetQuery* node)override
			{
				List<Ptr<GuiConstructorRepr>> first, second;
				ExecuteQuery(node->first, context, input, first);
				ExecuteQuery(node->second, context, input, second);

				switch (node->op)
				{
				case GuiIqBinaryOperator::ExclusiveOr:
					CopyFrom(output, From(first).Except(second).Union(From(second).Except(second)));
					break;
				case GuiIqBinaryOperator::Intersect:
					CopyFrom(output, From(first).Intersect(second));
					break;
				case GuiIqBinaryOperator::Union:
					CopyFrom(output, From(first).Union(second));
					break;
				case GuiIqBinaryOperator::Substract:
					CopyFrom(output, From(first).Except(second));
					break;
				}
			}
		};

/***********************************************************************
ExecuteQuery
***********************************************************************/

		void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& input, collections::List<Ptr<GuiConstructorRepr>>& output)
		{
			ExecuteQueryVisitor visitor(context, input, output);
			query->Accept(&visitor);
		}

		void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& output)
		{
			ExecuteQuery(query, context, *(List<Ptr<GuiConstructorRepr>>*)0, output);
		}

/***********************************************************************
ApplyStyle
***********************************************************************/

		void ApplyStyleInternal(Ptr<GuiAttSetterRepr> src, Ptr<GuiAttSetterRepr> dst)
		{
			FOREACH_INDEXER(GlobalStringKey, attribute, srcIndex, src->setters.Keys())
			{
				auto srcValue = src->setters.Values()[srcIndex];
				vint dstIndex = dst->setters.Keys().IndexOf(attribute);
				if (dstIndex == -1)
				{
					dst->setters.Add(attribute, srcValue);
				}
				else
				{
					auto dstValue = dst->setters.Values()[dstIndex];
					if (srcValue->binding == dstValue->binding)
					{
						if (srcValue->binding == GlobalStringKey::_Set)
						{
							ApplyStyleInternal(srcValue->values[0].Cast<GuiAttSetterRepr>(), dstValue->values[0].Cast<GuiAttSetterRepr>());
						}
						else
						{
							CopyFrom(dstValue->values, srcValue->values, true);
						}
					}
				}
			}

			FOREACH_INDEXER(GlobalStringKey, eventName, srcIndex, src->eventHandlers.Keys())
			{
				if (!dst->eventHandlers.Keys().Contains(eventName))
				{
					auto srcValue = src->eventHandlers.Values()[srcIndex];
					dst->eventHandlers.Add(eventName, srcValue);
				}
			}
		}

		void ApplyStyle(Ptr<GuiInstanceStyle> style, Ptr<GuiConstructorRepr> ctor)
		{
			ApplyStyleInternal(style->setter->Clone().Cast<GuiAttSetterRepr>(), ctor);
		}

/***********************************************************************
GuiIqPrint
***********************************************************************/

		class GuiIqPrintVisitor : public Object, public GuiIqQuery::IVisitor
		{
		public:
			stream::StreamWriter&				writer;

			GuiIqPrintVisitor(stream::StreamWriter& _writer)
				:writer(_writer)
			{
			}

			void Visit(GuiIqPrimaryQuery* node)override
			{
				switch (node->childOption)
				{
				case GuiIqChildOption::Direct:
					writer.WriteString(L"/");
					break;
				case GuiIqChildOption::Indirect:
					writer.WriteString(L"//");
					break;
				}

				if (node->attributeNameOption == GuiIqNameOption::Specified)
				{
					writer.WriteChar(L'@');
					writer.WriteString(node->attributeName.value);
					writer.WriteChar(L':');
				}

				if (node->typeNameOption == GuiIqNameOption::Specified)
				{
					writer.WriteString(node->typeName.value);
				}
				else
				{
					writer.WriteChar(L'*');
				}

				if (node->referenceName.value != L"")
				{
					writer.WriteChar(L'.');
					writer.WriteString(node->referenceName.value);
				}
			}

			void Visit(GuiIqCascadeQuery* node)override
			{
				node->parent->Accept(this);
				node->child->Accept(this);
			}

			void Visit(GuiIqSetQuery* node)override
			{
				writer.WriteChar(L'(');
				node->first->Accept(this);
				switch (node->op)
				{
				case GuiIqBinaryOperator::ExclusiveOr:
					writer.WriteString(L" ^ ");
					break;
				case GuiIqBinaryOperator::Intersect:
					writer.WriteString(L" * ");
					break;
				case GuiIqBinaryOperator::Union:
					writer.WriteString(L" + ");
					break;
				case GuiIqBinaryOperator::Substract:
					writer.WriteString(L" - ");
					break;
				}
				node->second->Accept(this);
				writer.WriteChar(L')');
			}
		};

		void GuiIqPrint(Ptr<GuiIqQuery> query, stream::StreamWriter& writer)
		{
			GuiIqPrintVisitor visitor(writer);
			query->Accept(&visitor);
		}
	}
}

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY_PARSER.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Query"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum NameOption"
L"\r\n" L"{"
L"\r\n" L"\tSpecified,"
L"\r\n" L"\tAny,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ChildOption"
L"\r\n" L"{"
L"\r\n" L"\tDirect,"
L"\r\n" L"\tIndirect,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class PrimaryQuery : Query"
L"\r\n" L"{"
L"\r\n" L"\tChildOption\t\tchildOption;"
L"\r\n" L"\tNameOption\t\tattributeNameOption;"
L"\r\n" L"\ttoken\t\t\tattributeName;"
L"\r\n" L"\tNameOption\t\ttypeNameOption;"
L"\r\n" L"\ttoken\t\t\ttypeName;"
L"\r\n" L"\ttoken\t\t\treferenceName;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CascadeQuery : Query"
L"\r\n" L"{"
L"\r\n" L"\tQuery\t\t\tparent;"
L"\r\n" L"\tQuery\t\t\tchild;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum BinaryOperator"
L"\r\n" L"{"
L"\r\n" L"\tExclusiveOr,"
L"\r\n" L"\tIntersect,"
L"\r\n" L"\tUnion,"
L"\r\n" L"\tSubstract,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SetQuery : Query"
L"\r\n" L"{"
L"\r\n" L"\tQuery\t\t\tfirst;"
L"\r\n" L"\tQuery\t\t\tsecond;"
L"\r\n" L"\tBinaryOperator\top;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token INDIRECT = \"////\";"
L"\r\n" L"token DIRECT = \"//\";"
L"\r\n" L"token NAME = \"[a-zA-Z_][a-zA-Z0-9]*\";"
L"\r\n" L"token WILDCARD = \"/*\";"
L"\r\n" L"token OPEN = \"/(\";"
L"\r\n" L"token CLOSE = \"/)\";"
L"\r\n" L"token XOR = \"/^\";"
L"\r\n" L"token INTERSECT = \"/*\";"
L"\r\n" L"token UNION = \"/+\";"
L"\r\n" L"token SUBSTRACT = \"-\";"
L"\r\n" L"token ATTRIBUTE = \"@\";"
L"\r\n" L"token COLON = \":\";"
L"\r\n" L"token DOT = \".\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule PrimaryQuery QPrimaryFragment"
L"\r\n" L"\t=\t("
L"\r\n" L"\t\t\t(NAME : typeName with {typeNameOption=\"Specified\"})"
L"\r\n" L"\t\t\t| (\"*\" with {typeNameOption=\"Any\"})"
L"\r\n" L"\t\t)"
L"\r\n" L"\t\t[\".\" NAME : referenceName] as PrimaryQuery"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule PrimaryQuery QPrimaryAttributed"
L"\r\n" L"\t= !QPrimaryFragment with {attributeNameOption=\"Any\"}"
L"\r\n" L"\t= \"@\" [NAME : attributeName] \":\" !QPrimaryFragment with {attributeNameOption=\"Specified\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule PrimaryQuery QPrimary"
L"\r\n" L"\t= (\"/\" with {childOption=\"Direct\"}) !QPrimaryAttributed"
L"\r\n" L"\t= (\"//\" with {childOption=\"Indirect\"}) !QPrimaryAttributed"
L"\r\n" L"\t= \"(\" !QueryRoot \")\""
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Query Query0"
L"\r\n" L"\t= !QPrimary"
L"\r\n" L"\t= Query0 : parent QPrimary : child as CascadeQuery;"
L"\r\n" L""
L"\r\n" L"rule Query Query1"
L"\r\n" L"\t= !Query0"
L"\r\n" L"\t= Query1 : first \"^\" Query0 : second as SetQuery with {op=\"ExclusiveOr\"}"
L"\r\n" L"\t= Query1 : first \"*\" Query0 : second as SetQuery with {op=\"Intersect\"}"
L"\r\n" L"\t;"
L"\r\n" L"\t"
L"\r\n" L"rule Query Query2"
L"\r\n" L"\t= !Query1"
L"\r\n" L"\t= Query2 : first \"+\" Query1 : second as SetQuery with {op=\"Union\"}"
L"\r\n" L"\t= Query2 : first \"-\" Query1 : second as SetQuery with {op=\"Substract\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Query QueryRoot"
L"\r\n" L"\t= !Query2"
L"\r\n" L"\t;"
;

		vl::WString GuiIqGetParserTextBuffer()
		{
			return parserTextBuffer;
		}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 6336; // 25801 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 192;
const vint parserBufferRows = 7;
const char* parserBuffer[] = {
"\x00\x00\x80\x84\x01\x8C\x01\x83\x20\x00\x61\x00\x33\x20\x03\x30\x84\x00\x32\x00\x65\x00\x11\x20\x05\x39\x88\x00\x72\x00\x39\x20\x0F\x7D\x8F\x7F\x82\x00\xD0\x18\x80\x09\x30\x01\x36\x87\x19\x9B\x94\x96\x82\x89\x94\x8E\x8F\x05\x01\xAB\x97\x8E\x96\x8F\x7E\x04\x01\xD3\x17\x94\x33\x8D\x88\x9A\x8D\x2F\x9D\x8B\x04\x86\x86\x87\x85\x86\x09\x90\x92\x93\x9D\x90\xA1\x98\x80\x0D\xE8\x24\x80\x0C\x37\x85\xA1\x8F\x45\x89\x87\xAE\x8A\xA5\x9C\x97\x91\x1B\x86\x01\x90\x38\x97\x8A\x36\x00\x3C\xB6\xA0\x80\x02\x91\x8D\x93\x93\x09\xAE\x8C\xA0\xB0\x05\x05\x81\x84\x3C\xBC\xAE\xA0\x02\x36\x9C\x9E\x89\x4E\x0E\xA7\x92\x8A\xB1\x81\xB7\xA9\x70\xF4\xB3\xAE\x93\x0F\xB8\xB5\xC7\x7B\xFD\x96\x9F\xB0\x01\xC1\x85\xC1\x00\x4F\x00\x04\xBC\x9D\x93\x36\x00\x67\x85\xE1\x83\x9F\xB5\xB2\x94\x9F\x4D\x9B\x83\xB0\xA0\x02\xA9\x93\xAA\x10\x9A\xDC\xD3\xAF\xC9\xD2\x8F\xB5\x87\xA5\xF1\xA0\xAB\xC0\xA2\xBA\x80\x19\x92\xA6\x3F\x92\x8F\xB1\x86\xC0\x82\x97\xA2\xCC\xB4\xD6\x92\xD2\xAF\x3F\x9B\xB8\x80\x8C\x9B\x8C\xB2\xE4\x97\xCA\xF7\xC6\xCD\xE1\xC6\xB8\xD4\x74\x8E\x01\x95\xEB\xCF\x8A\xCA\xE7\x12\xB2\xCF\xDE\xC0\xD7\xAB\xE8\x00\x3A\x92\xBC\x9D\xDB\x8F\xA4\x01\xE1\x25\x99\x8B\x89\xBE\x8F\xF5\xF9\xC7\xF4\x40\x02\x01\x40\x9F\x64\x56\x4E\x7F\x3B\x50\x79\x68\x00\x62\x40\x4B\x42\x44\x0D\x75\x66\x56\x4D\x11\x01\x4F\x09\x40\x15\x81\x4A\x85\x40\x36\x76\x4B\x84\x87\x1D\x9D\x4F\x84\x40\x21\xA2\x83\x89\x89\x37\x41\x49\x11\x65\x00\x04\x10\x03\x8A\x52\x00\x05\x10\x00\x07\x54\x10\x03\x40\x00\x57\x8A\x8C\x00\x17\x9A\x86\x4D\x83\x2D\xAF\x80\x01\x8C\x33\xB5\x82\x82\x85\x3C\x80\x01\x00\x88\x1D\x78\x8C\x89\x10\x00\x0D\x12\x8C\x00\x15\x01\x4B\x16\x43\x2D\x00\x0A\x1C\x00\x50\x99\x9A\x14\x00\x5F\x00\x0D\x14\x00\x57\x89\x49\x97\x96\x5D\x80\x0F\x94\x0C\x00\x19\x99\x0E\x98\x00\x2A\x07\x90\x89\xFD\x41\x47\x16\x90\x4C\x01\x97\x40\x94\x31\xAE\x83\x81\x8E\x71\x80\x03\x00\x93\xFF\x0E\x9A\x66\x48\x33\x81\x6F\x9D\x92\x28\x37\x84\xA2\x7D\x07\x79\x9A\x66\x4E\x33\x8B\xA7\x85\x0A\x00\x36\x76\x4F\xA0\x00\x58\x19\x67\x90\x73\x89\x9E\x14\x83\x84\x89\x0A\x88\x8B\x36\xB3\x81\x8C\xA5\x34\x80\x06\x8E\xA5\x81\x87\x0F\xA1\x40\x55\x2C\x8B\x8A\x66\x8A\x88\x9B\x08\x00\xEF\x76\x46\xA8\x40\x3A\x75\xA2\x10\x7C\xAE\xA0\xA0\x96\x91\x4B\x80\x49\x97\xAF\x57\x4C\xB0\x96\x8D\x36\xB1\x8B\x8B\xB0\xB5\xA9\xAA\x91\x40\x40\x00\x0A\x03\xAC\x00\x47\x4A\x66\xA4\x2C\x89\xB0\x02\x0E\x00\x2B\x67\x54\xA7\x41\x9A\x66\x8E\xB8\x2E\x00\x0B\x5A\x4D\xE2\xB6\x7A\x4E\x48\xC7\x93\x98\xBB\x85\x0B\x7B\xAF\x6F\x55\x3D\xBC\xA2\x4C\x73\x7B\x5E\x70\x52\x04\xFF\xB9\x6E\x73\x6E\x1B\x6D\xB1\x8F\x67\x9F\x7C\x4A\x4C\x4F\xBB\x7C\x4B\xBD\xB6\x20\x00\x04\x08\x00\x3C\x3D\x46\xC2\xC0\x1B\x7E\x0E\xBC\x40\x14\x5B\xCF\x72\x78\x20\xC0\xC8\x63\x73\xED\x8F\xC5\x58\x4F\x6B\x54\xC8\xC6\xC6\xDD\x4F\x7E\xC7\x7B\x21\xF1\xC8\xC2\xB6\x05\xF6\xC4\x5D\xBB\x31\x00\x05\x25\x40\x19\xF5\xC1\xC2\xCC\xE3\x80\x05\xC5\xA3\x15\xE2\x09\x92\xD2\x2E\xF7\x13\x54\x4F\x52\x55\xCB\x1E\xD1\x0C\x6D\x63\x54\x6C\x9F\xB3\x6C\x7B\x59\x15\xFD\x04\xD6\xD2\x2E\xB9\x77\x45\x43\x3C\x4A\xD5\xC5\x1F\x54\xD8\xA5\xC5\x08\x30\xC3\xD7\xCC\x94\x79\x4D\x72\x67\x63\x12\x50\x46\x5F\xB6\x41\xE6\xCA\x6C\x5D\x1E\xE4\xB7\xD3\xD7\x49\x97\x8C\xD0\xD5\x4E\xE5\x40\xD4\xD5\x53\xD5\xC1\x57\xD5\x56\x6A\x7D\x64\x00\x12\x9D\xD0\xE3\x8A\x67\x50\x42\xD8\x84\x8F\x66\xD0\x00\xDA\x15\xEA\xD0\x00\xDB\x42\xE7\xCF\xDB\x63\x7A\x53\x53\xDC\x65\x10\x74\xCA\xDF\xC1\x74\x5B\xB5\xCA\xC8\x37\xED\xB2\x0C\x00\x1F\x00\xDD\xDA\xE8\x7C\xC5\xD9\xD0\x00\x8D\x83\xEB\xDA\x82\x74\x4B\xC0\xE7\x63\xBB\xD8\xAA\xD0\x04\x39\xEE\xD4\x5E\x11\x23\x49\x47\x18\x7A\xED\x7C\x44\xC3\xEB\x3A\xEE\x4C\xF1\x46\xCE\xD0\xF7\x58\x4F\x3C\xC0\x09\x2A\xED\xA1\xFB\xD6\xF5\xF3\x00\x0F\xF8\x67\xF6\x00\x3D\xD4\xD4\xD2\xBC\xD4\xD1\x60\x94\x52\xB3\x85\xC6\xDF\x8F\x56\x76\x79\x72\x12\x55\xC5\xE3\x63\x51\xC0\x09\xE1\xFD\xE5\x38\x38\xF4\x0E\x74\x37\xF6\x12\x73\x77\x3A\x37\x39\xD5\x25\x28\x3F\x8B\x10\x22\x73\x9C\x60\x02\xE7\x7C\x0B\x7C\xC0\x72\x4A\x73\xFB\x67\x72\xD4\x54\x64\x3C\x05\xA7\x38\x33\x04\x9B\x68\xD5\x5E\x6B\x76\x28\x67\x2B\x23\x10\x89\x6E\x0A\xAE\x67\x4B\xDD\x6D\x5A\x73\xEF\x71\x4B\x94\x73\x74\x6B\xE0\x37\x3C\x38\xED\x27\x38\x8B\x59\x39\x7E\x38\x55\x62\x2B\x54\x70\x76\x62\x60\x3E\x24",
"\xE4\x54\x7A\x79\xE3\x78\x79\xF9\x5A\x7F\x31\xE9\x77\x72\x7C\x40\x37\x7A\x43\x66\x76\x2D\xC7\x32\x76\x7B\xE0\x6B\x74\xC7\x00\x02\x8B\xEC\x67\x7F\x31\xEA\x7F\x6E\x18\xCF\x42\x86\xF9\x7A\x70\x80\x1E\x98\x7C\xE1\x4F\x66\x6B\x0D\x95\x65\x83\xF7\x7C\x85\xD6\x6B\x33\x78\xAE\x40\x04\x84\x00\x0A\x69\x02\xE3\x63\x2B\x06\xB5\x69\x8F\x54\x71\x83\x04\x95\x8B\x77\x0B\xAB\x8E\x70\x6D\x9E\x7C\x07\xC0\x29\x8C\x39\xA1\x85\x8E\x23\x80\x72\x09\xC0\x29\x85\xCE\x6B\x84\x6A\x2D\x80\x93\x0B\xEE\x7C\x4B\x32\x94\x6C\x7E\x36\x83\x39\x53\x45\x35\x6A\x01\x98\x35\x62\x63\x5F\x86\x42\x41\x85\x7A\xDE\x04\x8B\x60\xC9\x78\x76\x4B\x70\x60\x32\xD3\x7E\x2E\x81\x00\x14\x01\x2C\xD0\x8B\x22\x5A\xA5\x75\x24\xA7\x78\x95\xF7\x3C\x20\x21\xBC\x42\x8B\x96\xA4\x72\x6F\x2D\xFF\x81\x8C\x40\x99\x5E\x77\x64\x5C\x90\xFC\x33\x87\x8C\xBC\x35\x90\x98\xCB\x9B\x84\xF4\x28\x90\x70\x72\x5A\x70\x74\x5A\x8F\x39\x17\xCB\x8F\x8A\x9E\x3A\x7C\x8D\xFD\x7F\x7E\x35\xBF\x9C\x2F\x6C\x9F\x87\x22\x8F\x91\x73\x1D\x80\x7B\x8E\xCC\x4C\x83\x2A\x7F\x89\x86\x11\xCF\x8C\x75\x24\x93\x8C\x89\xD2\x7B\x95\x3F\xD1\x84\x7C\x2A\xA4\x94\x7B\x00\x13\x04\x16\xC5\x9C\x9F\x2D\xA3\x9E\xA0\xD1\x69\x7F\x19\xEC\x7C\x7D\x18\xB1\x7F\x93\x8B\x96\x7E\x29\x97\x27\x9C\x44\xA9\x99\xA3\x01\x9A\x98\x08\xE5\x3F\x70\x79\xB8\x8A\x8F\x21\xAD\x23\x3D\xA5\x29\x9F\x40\xAA\x85\x62\x14\x83\x8E\xD2\x06\x9D\xA2\xFE\x48\x70\xA4\x8D\x83\x80\x49\x85\x86\x8F\x93\x9D\x97\x84\x80\x87\x6F\x4B\x92\x88\x92\xC0\x5B\x96\x65\x16\xB4\x98\x28\x97\x22\x95\x91\x24\x92\x87\xEF\x9D\x85\x2A\xC6\x2C\x94\x24\xAE\x97\x2B\x45\x82\xA2\x43\x85\xA0\xA0\x00\x18\x02\xAB\xE2\x9C\xA9\x39\x80\x0A\x61\xE1\x4D\x63\x4A\x95\x74\x49\x40\x17\x66\x99\x56\x9B\x27\xA1\x5D\xBE\x61\xC5\x59\x5E\x89\xF0\x43\xA5\x97\xC9\x91\x31\x36\x90\x2A\x97\x23\xB2\x90\x28\xBE\x8A\x9B\x64\x42\x90\x00\x1A\x00\x03\x18\x59\x87\x98\x60\xF9\xA6\x97\xC1\x8C\x9F\x8C\x83\x7A\x71\x26\xC9\xA6\x8C\xFA\x6B\x9A\xB0\x74\x62\xA4\x47\xBE\x80\x90\x6F\x94\x68\x9C\x8A\xAF\xAE\x58\xD5\x8C\x27\xA6\x68\x9F\xA6\xAA\x91\x6E\x5E\x8E\xBA\xB3\xF4\x3B\xA2\x84\x07\x80\x91\x3D\x8B\x87\x86\x96\x96\x29\x85\x77\x6F\x66\x5D\xDB\x81\xB1\xD5\x99\xB0\x22\xCD\x80\xB6\x5B\xDC\x83\xB5\x83\x80\x06\xB4\x1E\xA8\xB6\x43\x2A\xBD\xB1\xCC\x91\xAB\x8E\x25\xA6\x83\x3C\xA5\x8D\x3C\x14\xAE\xA5\xAE\xE1\x83\x74\x73\xD8\x9C\xB4\xBE\xA0\xAA\xBB\xD7\x8D\x9D\x77\xE4\xA9\xA1\xC7\x0C\xA3\xB7\xCF\x3D\xB5\x73\xA8\x72\xA2\xFA\x51\xB5\xA8\x15\x74\xB0\x46\xA9\xB1\xBD\x60\x9B\xA2\xAA\xDD\x8E\x9B\x67\x8D\xA1\xAC\x25\x90\xA0\x7D\x35\xBA\x82\x22\xF4\xBC\x9C\xFB\xAD\xB0\xBA\x3C\xB1\x90\x02\xA9\xAD\x8E\x7C\xB7\xB7\xBA\xDF\xB4\x2E\x7A\xDC\xBF\xB7\x5C\x91\xC0\x99\xDB\xA2\xBD\x85\xD7\x84\x98\xDD\x99\xBA\xC2\x8C\xB4\xC0\x7B\xCD\x9F\xBD\x8A\x53\xB5\x93\x17\xB4\x84\x81\x98\xB4\x33\xE7\x9C\x9E\x65\x4A\x7E\xB3\xEF\x68\xB7\x66\xB8\xA3\xA9\xC0\x89\x8A\x9D\x88\x9A\xCD\xC4\x35\xB1\x9A\xBA\x3E\xB3\xB6\x4A\xB5\xB8\x96\x7D\x97\xC4\xA0\xFE\xBD\xA8\x76\xA1\xB4\xB9\x24\xE3\xAD\x5D\x35\x0B\xA2\x87\xCC\xC6\xC6\xD2\xAD\xBC\x90\xED\x71\xBC\x8A\xCA\xA8\xA7\x38\x9B\x98\x00\x19\x99\xC5\x97\xF7\xB8\xC0\xD8\x93\xBA\xB6\x0C\xCB\xA5\x91\xAE\xA6\x92\x98\x98\xCB\xA6\x41\xA0\xCF\x69\xEE\x88\x8C\x2F\xE3\xA2\x6B\x90\x91\xB6\xD2\x13\x96\xBA\xA1\xAD\xCC\xA8\x26\xC6\xA9\x9C\xF2\xBA\xC4\xA7\xB7\x83\x94\x39\x96\xCF\x66\xD3\xA0\x89\x8A\x4C\xC9\x40\xD9\x4A\x74\x93\xAE\x7C\xBF\xD8\x65\xBE\x16\x89\xA3\xB9\x33\xEC\x7A\x69\x1D\x58\x83\xCE\x03\xD5\x6A\x6B\x54\x2D\x71\xD7\xB9\xCF\xCC\x4A\x74\x72\x55\x17\x75\x6B\xB2\x6C\xC8\xD0\x9F\x75\xD0\x88\x99\xC6\xC0\x88\x19\x59\xB7\x6D\xB6\xA9\xC7\x10\xBD\x7D\x6F\x80\x7E\x25\xC2\x67\xAD\xF1\x7A\xB8\xD6\x59\xEE\x23\xD3\x80\x62\x73\x21\xB6\xA4\xCF\xC5\x6F\x35\xD4\x78\xC6\xA4\xE0\x61\x66\xD0\xB2\x71\xCA\x90\xFB\xB4\xC7\xAC\xF5\xBB\xAF\xE3\x80\x03\xC9\xC3\xB3\xC0\x8F\xB8\x9A\x03\x23\xF8\xAC\xD6\xDD\xC5\xAC\xC3\x0F\x33\x47\xB4\x97\x03\xAD\x53\xC1\xDF\x8E\xB5\xD2\xA3\xB9\x9F\x66\xD8\x40\x3B\x9E\xB6\xAE\x2A\xDD\xE1\x7C\x25\xDD\x56\x3B\x5C\x5B\xF8\xDB\xD6\x7B\xC0\x49\x40\x6C\x4A\x74\x56\xC0\x2C\x4D\x76\x4A\xA4\x22\xE7\xAF\x97\x46\x6C\x4D\x98\x84\xF3\xBD\x3C\xBB\x26\xB9\xC5\x7B\xD0\x29\x42\xCE\xDC\xD4\x10\x2A\x97\x42\x15\x67\x20\x20\x88\x2E\x2A\x4B\x32\xE2\xB7\xC5\xD6\xE3\xE0",
"\x84\xE6\xDB\x07\xEA\xE5\xC2\xFF\x5B\xE1\x89\xE4\xBB\x76\x3B\x19\x89\xCD\x80\x04\xE3\x33\x96\xE5\xD0\x64\x39\xE1\x44\x9B\xEF\xC2\x97\x1E\xE6\x6A\xCF\xC1\xE4\x55\xA4\xE4\xAB\x93\xDD\x28\xD2\xA4\x45\x67\xCE\xBD\x6A\xE1\xE8\x00\x05\x67\xED\x46\xB2\x2F\x3A\xE6\xEB\x9E\x55\xE2\xE5\x3D\x65\xD1\x03\xFA\x34\x78\x40\xB4\xA7\xD7\x0C\xF7\xE3\x83\x55\x62\x42\xA5\xCD\xD4\x58\xF2\x28\xEF\x46\x38\xCF\xA3\x8A\x45\x42\xC1\x80\x8A\xD4\x65\x64\xE8\x72\x57\xC2\xAF\xD6\x38\x79\x6F\xD4\xD7\xC3\xC6\x99\xEB\xE1\xF0\x72\xF7\xE8\xE1\x89\xF1\xED\x33\xA3\xEB\x95\xE6\x80\x93\xA8\x1A\x7F\xE7\x33\xAB\xE9\x42\xED\x2E\xEF\x2A\x95\x6F\x3F\xF9\x2A\xE4\xEE\xCA\xB7\xEE\x9E\xD3\x48\x0F\xAA\x55\x2E\x22\x0B\x25\x26\x1D\x70\x93\x25\x14\x99\x59\xE6\x83\xF5\xEB\x82\x58\xE5\xBC\x55\x1C\xEB\xF6\x8B\xE1\x41\xE3\xF4\x7F\xF1\xFD\x16\x81\xCE\x95\xF4\x7F\xE5\x90\x9A\xF3\x91\xF0\xE8\x40\x2A\xE8\xB8\xB3\xA1\xD2\xF4\x54\xC2\x48\x7D\x4D\x23\xFA\xDF\x9B\x75\x2E\xC4\xFA\xF1\xF7\x60\xF7\xE1\xEF\xE5\xEA\x69\xC9\xD4\x69\xF8\x54\x63\xF9\xDB\xD4\x6F\xED\xCE\xC9\xF2\xF9\x02\xDF\x7D\xF3\xBE\xA3\x47\xD2\xCD\x27\xF4\xAB\x8A\xF4\xEB\x99\x29\x84\xD8\xD6\xEB\xE6\x52\xF7\xFC\x79\xBD\x69\xE7\x88\xFB\xE5\xE7\xF4\x30\x7E\x15\x31\x74\x86\x68\x3E\x2E\x3C\x71\x73\x77\x46\x1F\x78\x35\x22\x74\x35\x25\x7B\x4A\x4E\x77\x11\x01\x26\x7F\x0B\x2C\x26\x24\x39\x78\x0D\x70\x2A\xEB\x6F\x6F\x99\x75\x2E\xF0\x62\x78\xFA\x72\x57\x30\x74\x73\x5D\x77\x6F\xD7\x7D\x3D\xB6\x7E\x7F\x25\x8F\x75\x83\x72\x76\x53\x14\x76\xA5\x50\x38\xDE\x74\x74\xFF\x7A\x76\x7C\x43\x7E\x0D\x8C\x79\x09\x21\x20\xA0\x74\x67\xEB\x70\x38\xED\x76\x7A\x3E\x19\x7A\x00\x0B\x7A\xAE\x54\x7F\x2E\x5C\x72\xD9\x7C\x82\x25\x8E\x82\x62\x3E\x7B\x30\x61\x28\x94\x76\x78\x85\x62\x7E\x1D\x89\x83\xC7\x7E\x79\x3B\x7D\x83\xCC\x75\x1E\xA3\x7A\x77\x3F\x12\x7D\xD7\x61\x75\x8C\x70\x00\x17\x87\x82\x1A\x8E\x6F\x68\x56\x15\xE6\x23\x70\xD7\x72\x82\xAF\x74\x82\x0B\x23\x3B\xB2\x74\x17\xB3\x3D\x3D\xB8\x07\x7B\x76\x8B\x78\xE0\x43\x78\x80\x78\x37\x89\x73\x3B\x4C\x83\x87\xDA\x7F\x82\x90\x70\x38\xBB\x23\x85\x2D\x86\x79\x37\x87\x85\x4B\x79\x85\x89\x7C\x85\xEA\x7E\x85\xCE\x75\x2B\x67\x12\x42\xAE\x75\x7D\x80\x81\x20\x82\x8E\x73\x2A\x73\x3B\x4E\x83\x12\xBE\x7B\x3B\x59\x2A\x88\x4D\x8C\x88\x98\x38\x83\x8F\x86\x7E\x3C\x82\x67\xC9\x5E\x83\x94\x81\x64\x3E\x1D\x17\xBE\x7A\x44\xD6\x69\x89\x14\x8B\x87\x75\x8E\x12\x77\x85\x58\x00\x04\x0A\x7A\x8C\x8B\xD8\x7B\x73\xA0\x8E\x78\x86\x83\x8A\x80\x45\x8A\xDF\x79\x7D\x55\x8D\x88\x69\x58\x85\xAC\x89\x7C\xCB\x69\x7E\x54\x3F\x83\x0B\x66\x11\xB4\x85\x4B\x09\x17\x8B\x49\x86\x7D\x9F\x83\x8C\x56\x75\x8C\xBC\x77\x8C\xDC\x70\x00\x89\x8B\x8C\x8B\x82\x7C\xCE\x86\x15\xD0\x8B\x83\xD2\x82\x89\xD5\x81\x8B\x80\x36\x89\x09\x65\x7F\x72\x84\x17\x54\x77\x8F\x2E\x14\x7B\xB3\x39\x82\x1E\x63\x78\x83\x88\x8F\x85\x8F\x84\xE5\x8E\x7D\x07\x84\x85\xA8\x8C\x76\x8E\x85\x7E\xEE\x8B\x85\xAE\x8B\x7C\x93\x84\x16\xA3\x71\x84\xEF\x73\x84\x53\x16\x84\x9F\x28\x84\x42\x5A\x84\x00\x9E\x89\xE9\x84\x35\xDB\x71\x79\x70\x60\x4D\x02\x8B\x4A\xA9\x8B\x90\x9B\x70\x89\xAD\x81\x66\x75\x73\x3C\x12\x9E\x7C\x60\x81\x7D\x7C\x43\x7D\x68\x39\x8B\xC2\x8B\x8B\x40\x1D\x8B\xB3\x30\x8C\x2A\x84\x88\x01\x92\x8C\xA1\x80\x83\xDE\x64\x8A\xC0\x7C\x8C\x09\x98\x79\xCF\x8B\x8A\x0D\x96\x75\xF0\x86\x77\xF2\x87\x8D\xED\x45\x8B\x0E\x1C\x8D\x1B\x9E\x8D\xC4\x80\x8E\x84\x81\x94\x87\x81\x85\xE7\x84\x83\xA7\x8A\x8E\x27\x99\x94\x0C\x91\x77\x2B\x90\x6A\x11\x98\x77\x4A\x34\x8F\x98\x8E\x52\x36\x99\x93\x66\x8A\x8F\x6E\x9D\x6F\x67\x50\x70\x10\x1D\x86\xFF\x81\x8E\xF5\x6E\x6D\xCC\x21\x20\xC1\x6F\x18\xE6\x2C\x97\x66\x56\x45\x8A\x75\x25\x3D\x91\x3C\x81\x9C\x13\x2E\x7C\x89\x23\x89\x7F\x84\x88\x93\x1B\x1D\x8B\x0A\x5C\x93\x77\x9E\x93\x1E\x98\x97\x5A\x98\x8C\x4A\x3A\x8C\x07\x9F\x91\x15\x36\x85\x62\x99\x92\xD1\x8E\x90\x2C\x91\x7A\x4F\x98\x66\xD8\x87\x88\xB6\x89\x39\xDD\x8B\x89\xDF\x8F\x93\x6E\x97\x99\xE5\x87\x8E\x9B\x9F\x95\xE1\x7B\x8E\xC5\x74\x35\xA1\x9C\x94\x0F\x94\x8D\x4E\x9F\x92\x3E\x5A\x96\x90\x49\x42\x92\x63\x5C\x94\x68\x80\xE4\x56\x58\xB5\x31\x71\x4C\x64\x62\xBD\x69\x6D\x2A\x7D\x97\x31\x83\x6C\x4A\x3B\x97\xCF\x97\x98\x00\x09\x21\x89\x70\x9D\xE4\x5A\x9D\x74\x9F\x96\x00\x1E\x86\xD5\x9B\x81\x79\x91\x87\x8C\x92\x90\xFA\x69\x7D\x72\x9F\x18",
"\x2A\x31\x31\x1E\x80\x10\x2E\x30\x9E\x1D\x9D\x96\x1B\x1D\x33\x6B\x18\x86\xEB\x93\x12\x3C\x14\x69\x2E\x30\x82\xB8\x7E\x31\xE7\x94\x65\xC5\x51\x51\xE5\x6E\x57\xBC\x4D\x64\xFF\x4F\x64\x69\x87\x56\xF7\x99\x11\x3C\x14\x98\x43\x96\x31\xF1\x6A\x6B\x06\xAE\x45\x56\x6E\x9F\xE6\x63\xA1\xE4\x46\x65\x16\x07\xA1\x55\x66\x5C\x29\x3F\x18\xEC\x9D\x57\x0F\xA9\x6B\x7F\x52\x5A\x4E\x65\xA1\xDF\x67\xA1\xE2\x64\x6F\x1C\x0A\xA2\xF3\x69\x6E\x09\xAA\x9E\x20\xA8\x9F\x00\x0F\x6E\xEE\x94\x35\xE0\x9C\x64\x2B\xAD\x6D\x1E\x30\x6E\x12\xAB\xA3\xE3\x5F\x55\x04\xA7\x57\x9D\x48\x6E\xE3\x5F\xA1\x10\x34\xA3\x1B\xA7\xA3\x15\x34\xA2\x05\xA0\xA4\x15\x6E\x31\xF2\x9C\x73\x00\x07\x9E\x35\x89\x9E\x0E\x33\xA3\x0C\xAD\x9E\x0F\xA0\x9F\x21\x84\x86\x16\x75\x9F\x86\x78\xA4\x2B\x38\x33\x4C\xA3\x99\x74\x1D\x73\x53\xA3\x3B\x56\xA8\x97\x58\xA4\x2C\x49\xAB\xA5\xE6\x2F\x9E\x68\xA2\x8C\x52\xA0\x97\x8F\x9E\x2E\x78\xA0\x00\xBD\x8B\xA0\x8F\x1A\x9F\x54\x3C\x9F\x7B\x8E\x31\xD4\x9B\x73\xDA\x9D\x18\xE5\x90\x6C\xD6\x9F\xA6\x7E\xAC\x13\x17\x84\xA7\x82\xAA\xA8\xE2\x94\xA8\x7B\xAA\x9D\x0F\x05\xA9\x8B\xA0\xA7\x65\xA3\x31\x81\xA9\x9D\xD6\x96\xA1\x43\xAB\x55\x27\xA6\x5C\x3E\xA5\xA2\x18\xAF\x5F\x82\x96\x58\xDF\x3A\x9C\xC3\x5D\xA1\x11\x58\x6C\x63\x44\x68\x67\x40\x47\x64\x6D\x94\x75\x64\x66\x3F\x6D\x53\xF4\x49\x66\x44\x6D\x52\x7E\x60\x6B\x31\x59\x65\x66\x71\x67\xA3\x94\x67\xB4\xA7\x60\xB9\xA8\x96\x3F\x54\x49\xAF\x6E\x39\x9E\x39\x49\x4A\x3B\x49\x5A\x63\x4D\x95\x55\x43\x4C\x58\x43\xC6\x1A\x68\xF8\x58\x85\x8F\x62\x8D\xA5\xAF\xA4\x2F\xA3\x5E\x22\xA6\x9C\x50\xAC\x5E\x50\x67\x58\x99\x6F\xA3\xE1\xA1\xA5\xBC\x6F\x4C\xF0\x54\x46\x29\x65\x4D\xEB\xAD\x63\x72\x4C\x4D\xBB\x32\x63\xB1\x66\x9C\xAE\xA0\x60\xBB\x92\x66\x2B\x6E\x5B\xF4\xAA\x53\xD1\x60\x64\xBB\xAA\x40\x43\x6E\x47\x0F\x6F\x77\x9A\x81\xA1\xA6\xA5\xAE\xB8\x49\x98\x45\x78\x64\x07\xA6\x65\xB6\xA7\x59\x00\xBA\xAD\x65\x67\x6A\x3E\x5C\x67\x63\x89\x2D\xB2\x20\x10\xC3\x92\xA1\xB8\x13\x5C\x01\x23\x22\x57\x13\xA5\x3D\x36\x1F\x25\xB1\x10\x6C\x34\x27\x1D\x1F\x9F\xAD\xA1\xA0\xE8\x33\xB2\x12\xAB\xB2\x00\x13\x02\x84\x2F\xAD\x44\xAE\xB0\x7F\x44\xB3\xA6\xA6\xB3\x00\x05\x02\x84\x23\xA5\x6C\x2A\xB2\x2A\x7A\x21\x27\x03\xB4\x7B\xA3\x3B\x46\xBB\x73\x1A\x28\x29\x2E\xBF\x0F\x85\xA6\x75\xDA\x9D\xB4\x56\x7A\x21\xBB\x21\xB5\x1F\x0C\x29\xFF\x02\x2E\xFF\x0A\x21\xE2\x26\xB2\x62\xB3\xB6\x1B\x2D\xB5\x1C\x2E\x24\x8B\x26\xB2\xE2\x2E\x24\x1A\x26\x2E\x0B\x80\x6D\x74\x42\x21\xEF\x1A\x6A\x96\x35\x6D\x8F\x11\xB2\xA6\xA6\xB6\x24\x26\x1F\x69\xB3\x22\x6B\xB3\x22\x6E\xB8\x74\x20\x79\xB1\x12\x20\x24\xD4\x66\x43\xD6\x68\xB7\x05\xA4\x22\x5E\xBF\x1E\xE8\x24\xB6\x90\xBC\x21\x5E\xB0\x24\x6C\xB3\x22\xE8\x2C\xB7\x64\xBA\xB8\x44\xA6\x1F\x26\x04\xB6\x3A\xBC\x5B\xF3\xA8\x4B\x61\xB1\x10\xEF\x17\xAC\xCF\x5A\x21\x30\xB2\xA1\xFB\xAF\x18\x7A\xBC\x11\x1F\xB9\x29\x64\xBB\x28\x98\xB3\xB6\x9A\xBB\x45\x9C\xBE\xB9\x2E\xA6\xA4\x15\x6F\x21\xAD\xBF\x0F\x17\x80\x24\x6A\xB1\x10\xB3\xB2\xB6\xB5\xBF\x1C\xBC\xBE\xB5\x68\xB4\xB6\x40\x26\x1F\x8F\xB3\x22\xC5\xB7\x33\xF6\x1C\x02\x64\xB3\xB5\x0B\x25\xB5\x01\x12\x27\x63\xBB\xA6\xB0\xB0\x10\x4A\x39\xBD\x7B\xA9\xB2\x01\x1D\x28\xDE\xB9\xA8\x69\x75\xB9\x00\x11\xB8\xA3\x68\x35\xC9\xA3\xB7\x1D\x8C\x6A\x89\xB7\xA1\xBD\xB3\xBC\x26\xBB\xBC\x01\x1D\xBC\x1F\x2F\xBC\x74\x11\xBD\xD3\xB8\xA9\xE2\x96\x1F\xD8\xB2\xB6\xDA\xB6\x1F\xDD\xB0\xC0\xDF\xBB\xBD\xED\x33\xBE\x18\x8E\x28\x1F\x28\xBE\x8C\x31\x1B\xA6\x65\xB8\x01\x17\xB8\x33\x96\x82\x11\xBB\x11\x8C\xBC\x21\x8E\xB4\xB6\xF6\x1C\xBC\x99\xB7\xA1\xFA\xB3\xB6\xD4\xB6\x98\xFD\xB7\xBD\xCA\xBB\xB4\x06\xC3\xC0\xF3\xB5\xC0\xF6\x12\xBE\x04\xC4\xBE\x36\x72\xB6\xBD\xB2\x2E\xEF\x16\xB2\x7D\xBF\x21\x3E\xB5\xA0\x40\xB9\xBA\xA6\xAB\xBA\x3C\x16\xBE\xDE\x97\xAB\xC8\xAF\xC0\xED\x1C\x2C\x42\x6D\x60\xB6\x50\x11\x3A\xC5\xA0\x3C\xCC\x11\x8B\x2F\x0F\x8B\x2C\x2C\xCC\x2D\xBA\xCC\x2B\x2F\xAD\xBB\x16\x1E\x02\xB9\x01\x1B\x2F\x57\xC7\xC1\x00\x12\x2E\x2D\xAC\xC5\x00\x0F\xBA\x03\xAC\x11\xE2\x24\x69\x63\xCD\xBA\xC9\xB0\xC6\xC3\xBD\xBA\x19\xCD\xC5\x01\x1D\xB9\x00\x16\x1F\x26\xB7\xC3\x44\xA9\xC3\x1C\xA2\xB3\x8F\x1E\xC3\x17\x86\xBA\x3E\x62\xC4\x67\x14\xC4\xBC\xA8\xB0\x48\xC7\xC7\xA3\xA1\x51\x40\x20\xC7\x62\xB9\xC4\x44\xAB\xC4\xF6\xB2\xB6\x9F\xB9\x5E\xA1\xBF\x47\x3E\xC8\xA8\xCB",
"\x5C\x6D\xAC\x5F\x5C\xC9\xA8\x2E\x1C\xBF\xC8\xE0\x55\x60\xDD\x6E\xC4\x01\x10\xC5\x58\xC0\x10\x56\xC3\xCA\xD5\x70\x10\x5B\xC4\xC6\xA1\xC9\xC5\xA6\xC2\xC6\xA6\xC6\xC6\xA6\xC2\x2E\x36\xAA\xCA\x02\x11\x10\x4D\xC1\x2F\xB6\xC6\xCA\x6D\xC7\x2D\x00\x14\x69\x72\xC3\x22\x74\xCB\x45\x76\xC1\xAA\xFD\x53\xB1\xC6\x5A\xC7\xE3\x1C\x48\x18\xB9\xAC\x80\xC6\xB0\x46\xC8\x4B\x8A\xC2\xAA\xC6\xC6\xC8\x01\x14\x69\x26\xB1\xCD\xC5\xC4\xA1\xC6\x5D\xC8\x26\xBC\xC9\xDB\x6E\xC9\xE3\x53\xC9\x8E\x1A\xBB\x01\xB7\x67\x71\xB3\xC4\x39\x11\xC8\x0E\x60\x11\xDE\xC8\x61\x96\xCB\xBB\x90\xBD\xBB\xFB\x4F\xBA\x5E\xB2\x2E\x40\x2B\x16\x60\xB1\x10\xC8\xC4\x1D\xCA\xC8\xAB\x7E\xC0\x00\xCD\xCC\x47\x6A\x6F\x47\xD8\xC5\x63\x78\xC4\x4C\x31\xC4\xBA\xB1\xB4\xB6\xC1\xCF\x1C\xC3\xCF\x72\x4B\xCB\xCF\x40\xC8\xC9\xFF\xCA\xC9\xD5\x55\xA5\x84\xC3\xCD\xE8\x30\xCA\x24\x2F\xC4\xAB\xC0\xC6\x5A\xC6\xCA\x53\xCD\xCA\x01\x17\xC6\x65\xC5\xD2\xB1\xC1\x10\x15\x30\xC6\xA5\xC0\xC6\x69\xC4\xCB\x06\xC7\xCB\x0A\xD0\x10\xE8\x22\x2E\x88\xCF\xCB\x36\xCC\x1D\x35\xB7\xB4\x01\x15\xD0\xCB\x37\xD0\x0A\xCB\x21\x7B\xCD\xCF\x41\xC3\xB0\x67\x16\xD1\x40\x5E\xD3\xFE\x4A\xCD\xD4\xC0\x10\x88\xC7\xCD\x19\xDC\xD4\xE8\x3C\xCD\x23\x2D\xCE\x8B\x54\xCE\xB8\x42\xCE\x00\x16\xB1\xEB\x5B\xCC\x15\xD1\x10\x9B\xC9\xBB\xEF\xCC\x5E\x1C\xD0\xD0\x1F\xD0\xD3\x23\xD0\xD2\x01\x19\xCA\xAD\xBE\xC5\xA6\xCD\xD2\x30\xDE\xCA\x60\xC0\xCB\x2E\xD9\xCB\x6A\xC6\xD7\x30\xDB\xCB\x27\xD1\xC7\x0C\xDA\xD3\x3F\xBC\xD3\x00\x1A\xD4\x12\xB2\xD5\x79\xC3\x22\x43\xDA\x51\x45\xD7\xCE\x47\xD0\xD6\x17\xD2\xD8\x26\xAA\xD1\x8F\x10\x24\xD6\xC3\x22\x8E\xD7\xAA\x5D\x54\xD5\x1F\x26\xD5\xE7\x63\xD6\x59\xD3\x22\x94\xCC\xD5\x22\x6E\xD5\x46\xD6\xD6\xC0\x2A\xCE\x47\xC9\xA2\xC4\xCD\xC9\x2C\x68\x4B\x91\xB2\xCF\x01\x14\xCF\xA6\xC7\xCF\x7E\xBA\xCF\x86\xD9\xCC\x88\xD4\xD1\xA3\xD8\xD4\xF9\x61\xD5\x19\xA6\x5C\xC7\xBC\x21\x40\x26\x2E\xC1\xBE\xC6\x1F\x2B\x2F\xA0\xD3\x6E\x64\x6A\x21\x9A\xD5\xA4\x9C\xDF\x47\x26\xBD\xBB\x97\xAD\xCB\x91\xB0\xC3\x93\xB4\x14\x63\xB2\x2E\xA3\xB0\x10\xFB\x21\x4A\xD8\xA5\x4A\x07\x68\xBA\xBC\xD8\xAA\x1D\x63\xDD\xF1\xC5\xCF\x01\x17\x81\xE5\xDC\x21\x8B\x2B\x2F\xF9\xC0\x10\x8B\x2B\x28\x40\x25\xC3\x1B\x2B\xDC\x3C\xB6\x15\x98\xDB\x21\xF8\xBE\x12\xE4\xD5\xB6\xD5\xD5\xCB\x63\xB2\xBB\xD5\xC8\xBB\xA9\xDF\xCD\xAB\xDF\x47\xD9\xD7\x6F\x7C\xC2\x47\xE0\xD3\xE0\x4B\xDD\xDB\x11\x5D\xBB\xAF\xB8\xD3\x1B\x28\xCB\xD2\xD3\xB6\xF4\xD1\xC9\x56\x1B\xDF\xCF\xDE\xB5\xD1\xD6\xA6\xE4\xD9\xD0\x20\xB4\xB6\x07\xEA\x21\x0D\xD7\x33\x0F\xDA\xAF\x40\xD5\xD6\x65\xDC\x2C\xED\xD0\x00\x88\xCE\xC3\x24\xEE\xD7\x38\xC0\xD8\x18\xDC\xE0\x83\xDE\xE0\xE8\x37\xC8\x64\xB5\xD9\x8C\xC4\xDE\x17\xE8\xD5\x92\xCE\xD9\xE3\xCD\xDC\x89\xD1\x5D\x8B\xD0\x10\x61\xD6\xE3\x9B\xD0\xCE\x15\x6B\xE2\xB3\xD5\xE1\x41\xD3\xC7\x32\xE5\xC7\x34\xEC\xE3\x40\xD2\xD9\x3B\xE1\xDE\x97\xDE\xE3\x62\xDC\xE4\xEC\x5A\xD5\x95\xCE\xE5\xA2\xDA\xD8\xA4\xD4\x2C\xCE\xC3\xD0\x56\x1F\xE3\x44\xE0\x11\x1F\xE6\xDE\x00\x1D\xE1\xF1\xCD\xC4\x8B\x2B\x4F\x2D\xEC\xC2\xF0\xD1\xBE\x1D\xCA\xE4\x82\x24\xDE\x44\xBC\xC4\x18\x2F\xE4\x16\x6E\xDE\x01\x10\x24\x22\xA6\xB2\xF9\xD0\x14\x07\xE6\x1F\x6F\xBC\xE6\x83\xEB\xA7\x6C\x2A\xE1\x90\xE3\xDD\x20\xEA\x56\x92\xE2\xE7\x01\x1E\x44\x40\x2D\xD6\x01\x1F\xC5\x68\xDC\xCA\x2C\xDB\xD6\xA6\xC1\xD2\x60\xC2\xD7\x30\xD4\xD7\xBC\xC0\x48\x82\xE0\x10\x40\x28\xC2\x23\x2D\xE7\xF7\xDA\x21\x28\xBE\xE7\x00\x14\xC9\x99\xE8\xDD\x01\x13\xCB\x52\xCE\xE9\x30\xD2\xEA\x30\xD0\xD7\xAD\xB4\xEA\xAD\xB6\xEA\xE2\x23\xC6\x77\xE0\x10\x63\xC9\xC2\x2E\xC4\xA5\x07\xE0\x24\x9E\x99\xE1\x8D\xE9\xEC\x3D\x3D\xBB\xE8\x22\xA2\xE8\x2D\xBA\x6B\xC2\xC3\xF5\xB6\xCA\x2F\xDA\x21\x8B\x2F\xBA\x2C\xC8\xEC\x09\xCB\xEC\x63\x15\x16\xBE\xDF\xEC\x09\xC2\xE9\x6E\xE4\xE9\x62\xB3\xE2\xD6\xDD\x2A\x26\x7C\x15\x12\x84\xE3\x7D\xEA\xE2\x8B\x28\xE9\x29\xD0\x10\xB8\xE2\x2E\x69\xDD\xEB\xA0\xEA\xD6\xA8\xC4\xD2\xC6\xEF\xCA\x28\xD4\xDC\xA8\xEB\xE7\x63\xBB\x16\x0F\x8B\x15\x49\x11\xEF\x4E\xB6\xEE\x16\x7B\xEA\x25\xC9\xEC\x6C\x2F\xEA\x0E\xF9\x7D\x65\xD4\xEB\xF7\xE5\xA3\x22\xDA\xEB\x55\xCD\xEF\xBB\xEE\xF1\xBF\xE3\xF0\xA5\xE2\xF2\xC3\xE9\xED\x07\xF9\x15\x10\x80\xEF\x29\x7D\xF0\xAA\xEE\xE8\x64\x87\xEC\xAD\xEE\xF2\xE2\xEE\x20\xB6\x9B\x21\xB1\xE2\xED\x01\x14\xED\xDA\xE8\xD7\xD6\xEC\xF3\xD8\xE4",
"\xD3\x96\xBD\xD7\xDD\x2D\x74\x2A\xF9\x78\xB0\xEE\xF2\xDE\xE1\xF1\xE1\xE1\xF3\x00\x14\x80\x36\x48\x3E\x47\xF2\xF1\x6D\xE6\xCA\xB3\xC1\xE7\xEA\xD1\x10\x42\xA1\xD4\x9A\xE0\x10\x2B\xDD\xE9\xDA\xDF\xD6\x20\xF2\x2E\xBC\xE2\x2E\xFF\xB5\xEC\x81\x28\xC0\xD7\x74\xF1\x2D\xF9\xEC\xB3\x35\xD6\x19\x04\xDB\x60\xCE\xD6\x60\xCB\xEF\x1D\xFF\xEF\xFE\xE0\x00\xA9\xC2\x2E\xA9\xC6\xF6\xA9\xC0\xEE\xD7\x73\xF3\x26\x9A\x90\x69\x51\xF5\x81\x80\xD3\xFF\x08\x2E\x4B\xA1\x2A\x21\xF1\xF0\x73\xD2\xF2\xDC\xEF\xDA\x01\x1C\xEA\x1F\x21\xEB\x89\xE1\x10\x21\x96\xF3\x05\xC8\xEE\x54\xFF\xE1\x96\xE0\x10\x59\xFE\x24\x5B\xF0\x00\x9C\xE9\xEB\x5F\xFF\xE9\x76\xFF\xF1\xA7\xF4\xF6\x78\xD0\x24\xFF\xBE\xF7\xD9\x7A\xF6\x60\xAF\x8D\x6E\xF0\xF7\x30\xD2\xF7\x5E\xF7\xCA\xFC\xE7\xFA\xAD\xB3\xF6\x1E\xFC\xF7\x4A\xFF\xF7\x4C\xF1\xF8\x48\x9E\xEC\x6B\xF5\xF8\x38\xF0\x10\x89\xF2\xD3\x00\x10\xEC\x7B\xD0\x00\x30\xF9\xEA\x61\xC1\xF9\xBF\xF9\x7D\x95\xF0\x10\x97\xF4\xF8\xD7\x7A\xE1\xBD\xBB\xED\x23\x20\xE0\x00\x15\xE8\xC1\xF6\x71\x3E\xCC\xC0\x49\x74\xB8\xED\x1C\xBE\x69\x5E\xBE\x77\xB0\xBF\x5E\xB2\xBF\xDD\xF2\xBC\x39\xF3\xFD\x35\x83\xFE\x01\x1B\xE8\xE6\xF7\x16\x86\xB6\x88\x7D\x74\xC1\x4C\x60\xC6\x29\x20\xF4\xD7\x68\xFE\x5F\x7E\xF9\x7A\x7F\x11\x75\x6B\x7E\x5A\xA4\x74\x86\x79\x72\x95\x42\xEF\x05\x62\x0F\x6B\x14\x77\x3C\x59\x31\x48\x51\x43\xC1\x31\x76\xFF\x66\x75\x0A\x84\x76\x69\x66\xB2\x4D\x00\xD0\x75\x94\x78\x6B\x77\x3E\x5C\x14\x48\x52\x38\x7A\x17\x4B\xFC\x31\x7D\x83\x3E\x00\xBE\x11\x74\x7C\xE9\x69\x6D\x47\x61\x08\x1D\x06\xE7\x41\x08\x71\x1D\xF5\x24\x7C\xEE\x62\x17\xD2\x58\xFA\x40\x13\x1C\x8D\xC2\x05\x7C\xEC\x61\x61\x92\x52\x0D\x47\x7E\x00\x0B\x01\x32\x80\x29\x61\x7B\xBA\x75\xEF\x78\x6B\xD7\x5D\xFA\x61\x7F\x37\x55\x7E\x44\x32\x28\x58\x7F\x6F\x4A\xF9\x60\x61\x0B\x84\x5B\xBD\x5B\x51\x31\x80\xE8\x71\xFA\x35\x82\xBE\x7A\x75\x38\x83\xF5\x41\x08\x1E\x8E\xFA\x57\x4B\x0F\x9C\x5F\x42\x86\x6B\x68\x17\x22\x8C\x05\xE2\x16\xAF\x62\x7B\x1E\x7F\xF1\x4B\x7E\x12\x68\xF6\x4F\x83\x88\x16\x0F\xD7\x7D\xE2\x57\x4A\xED\x78\xBC\x78\x6A\xC9\x57\x5C\x8E\x7E\x09\x83\x3D\x15\x64\x00\x95\x43\x07\x87\x5F\xF5\x7A\x70\x6A\x5F\x7F\x68\xFE\x2B\x36\xDD\x5C\x09\x87\x73\x23\x31\x5E\x3F\x81\xF4\x7C\x68\xE3\x7D\x81\xD7\x3C\x10\xB5\x83\xF9\x70\xB8\x09\x85\xFA\x50\x5B\x46\x74\x0C\x52\x61\xFD\x71\x09\xA6\x67\xFF\x66\x78\x62\x5E\xFB\x4E\x7F\x42\x82\x90\x1A\x84\x26\x86\x3C\x06\x85\x77\x70\x6B\x0C\x84\xBC\x1B\x80\xF2\x2C\x79\x28\x80\x2F\x4F\x80\x02\x15\x1E\x76\x0C\x70\x50\x60\x6C\x7E\xF0\x7C\x74\x5A\x86\xE8\x36\x86\x16\x57\x5A\x7A\x82\x17\xAF\x7E\x80\x01\x01\xE9\x67\x69\x52\x4A\xDB\x41\xB2\x66\x60\x15\x83\xE9\x5D\x7A\x0B\x92\x75\xB4\x18\xD0\x68\x16\xB3\x77\xDF\x40\x80\x50\x1A\x4E\xB0\x7D\x14\x90\x75\xED\x74\x09\x9F\x12\x93\x16\x0F\x4A\x83\xF2\x66\x60\x01\x6C\x0A\xFB\x46\x01\x7F\x76\x82\x82\xFF\x34\x7E\xD6\x0F\x09\x8E\x63\x68\x6D\x84\x75\x58\x71\x6B\x7E\x3D\x73\x09\xD0\x7E\xC9\x47\x87\x71\x81\x1E\x84\x44\x76\x8B\x09\xA5\x42\x2B\x85\x83\xF2\x85\x13\xB4\x87\x06\x67\xFF\x22\x86\xFE\x6D\x35\xFC\x7B\xB8\x3E\x7F\x5D\x6F\x07\x82\x80\xDE\x6D\x87\x6E\x4C\x20\xAF\x85\x41\x88\xE7\x05\x8A\x21\x9C\x83\x1C\x13\xDF\x6A\x81\xA9\x74\x22\x1A\x12\xE4\x63\x89\x27\x15\x0F\xBE\x87\x4A\x87\xC2\x18\x8B\x7C\x4F\x87\x2E\x8C\x4A\x73\x86\x51\x3C\x10\xEB\x5F\xA9\x09\x7F\x8F\x81\x22\x92\x51\x7E\x81\x2A\x15\x8A\x25\x85\x78\x08\x88\xF7\x07\x88\x81\x89\xA6\x07\x84\x97\x56\x7F\xC9\x51\xFF\x6A\x7E\x48\x87\xA1\x13\x8A\xC9\x69\x85\x16\x8F\x24\x93\x82\x8E\x80\x10\x70\x86\x3A\x92\x7A\x1B\x74\x43\x1A\x11\x8B\x18\x12\x87\x80\x70\x74\x7D\xC3\x6F\xD4\x5A\x11\xD2\x54\xD4\x27\x5D\x4F\x7A\x72\x63\x28\xC2\x56\x88\x6A\x8E\xB5\x1A\x13\x53\x7D\x8A\xD4\x6F\x2B\xBE\x6E\xA8\x8F\x13\xEF\x89\x66\x7D\x72\x05\x76\x2A\x07\x70\xB2\x87\xDB\x6A\x23\x82\x70\x68\x29\x70\x01\xAB\x8A\x40\x77\xBB\x16\x70\x5E\x97\x58\xCE\x6C\xBF\x5C\x11\xDF\x50\x12\xA5\x89\x47\x90\x8B\x59\x8C\x44\x1C\x7F\x0F\x1A\x0A\xD6\x88\xE6\x72\x7A\x33\x88\x29\x8C\x85\x9B\x8E\x08\xFA\x84\x53\x9C\x87\xED\x7D\x1C\x9B\x11\xCA\x81\x13\xEC\x11\x66\x8A\x84\xA0\x81\xC1\x0A\x8B\x9C\x82\x0E\x86\x7C\x45\x84\x8C\x8F\x89\x28\x85\x8B\xC8\x8C\x11\x1A\x11\x13\x90\x8C\x2B\x87\x6C\x62\x8C\x0D\x10\x10\x80\x0B\x6D\x97\x8C\x85\x7A\x23\xB2\x8C\x77\x83",
"\x14\xD7\x89\x02\x67\x8D\xF5\x85\x21\xB8\x87\x87\x8F\xBE\x20\x8C\x87\x0E\x7F\xE6\x86\x22\xBF\x8D\xA9\x88\x97\x42\x8C\x51\x84\x8E\xB1\x8F\x3A\xA5\x5E\x85\x84\x13\xE5\x7D\x52\x91\x60\xCC\x8B\x1F\xAF\x38\xA7\x80\x00\xE2\x58\x20\x9E\x8D\x31\x8C\x69\x52\x7E\x8F\x8D\x0A\xD9\x8E\x71\x96\x38\xB4\x8F\x6B\x63\x82\xDC\x81\x1F\x93\x8F\x86\x1B\x60\xF3\x88\x84\x68\x83\xB3\x2E\xBF\x69\x8D\x4B\x8C\x8F\xD8\x8D\x2A\xA5\x8C\xA3\x84\xFE\x03\x5E\x4D\x80\x08\x74\x59\x3C\x9F\x8D\x97\x3C\x13\xF2\x6E\x86\x18\x8F\x00\x0C\x0C\xA3\x10\x6F\x8B\x11\x56\x5C\x7A\x80\x90\x19\x8B\x3D\x9B\x88\x83\x8E\x1E\xC0\x8E\xF8\x7C\x8E\x9A\x8B\xB4\x6B\x8C\xCF\x8A\x13\xA6\x54\x79\x88\x85\xFF\x86\x22\x92\x91\x0F\x14\x21\xB1\x50\x4F\x1D\x8F\x18\x91\x4F\x56\x8F\xF7\x89\x7D\x45\x8E\x87\x90\x85\xF4\x89\x72\x40",
};

		void GuiIqGetParserBuffer(vl::stream::MemoryStream& stream)
		{
			vl::stream::MemoryStream compressedStream;
			for (vint i = 0; i < parserBufferRows; i++)
			{
				vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
				compressedStream.Write((void*)parserBuffer[i], size);
			}
			compressedStream.SeekFromBegin(0);
			vl::stream::LzwDecoder decoder;
			vl::stream::DecoderStream decoderStream(compressedStream, decoder);
			vl::collections::Array<vl::vuint8_t> buffer(65536);
			while (true)
			{
				vl::vint size = decoderStream.Read(&buffer[0], 65536);
				if (size == 0) break;
				stream.Write(&buffer[0], size);
			}
			stream.SeekFromBegin(0);
		}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

		class GuiIqTreeConverter : public vl::parsing::ParsingTreeConverter
		{
		public:
			using vl::parsing::ParsingTreeConverter::SetMember;

			bool SetMember(GuiIqNameOption& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Specified") { member=GuiIqNameOption::Specified; return true; }
					else if(token->GetValue()==L"Any") { member=GuiIqNameOption::Any; return true; }
					else { member=GuiIqNameOption::Specified; return false; }
				}
				member=GuiIqNameOption::Specified;
				return false;
			}

			bool SetMember(GuiIqChildOption& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Direct") { member=GuiIqChildOption::Direct; return true; }
					else if(token->GetValue()==L"Indirect") { member=GuiIqChildOption::Indirect; return true; }
					else { member=GuiIqChildOption::Direct; return false; }
				}
				member=GuiIqChildOption::Direct;
				return false;
			}

			bool SetMember(GuiIqBinaryOperator& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"ExclusiveOr") { member=GuiIqBinaryOperator::ExclusiveOr; return true; }
					else if(token->GetValue()==L"Intersect") { member=GuiIqBinaryOperator::Intersect; return true; }
					else if(token->GetValue()==L"Union") { member=GuiIqBinaryOperator::Union; return true; }
					else if(token->GetValue()==L"Substract") { member=GuiIqBinaryOperator::Substract; return true; }
					else { member=GuiIqBinaryOperator::ExclusiveOr; return false; }
				}
				member=GuiIqBinaryOperator::ExclusiveOr;
				return false;
			}

			void Fill(vl::Ptr<GuiIqQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<GuiIqPrimaryQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->childOption, obj->GetMember(L"childOption"), tokens);
				SetMember(tree->attributeNameOption, obj->GetMember(L"attributeNameOption"), tokens);
				SetMember(tree->attributeName, obj->GetMember(L"attributeName"), tokens);
				SetMember(tree->typeNameOption, obj->GetMember(L"typeNameOption"), tokens);
				SetMember(tree->typeName, obj->GetMember(L"typeName"), tokens);
				SetMember(tree->referenceName, obj->GetMember(L"referenceName"), tokens);
			}

			void Fill(vl::Ptr<GuiIqCascadeQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->child, obj->GetMember(L"child"), tokens);
			}

			void Fill(vl::Ptr<GuiIqSetQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->first, obj->GetMember(L"first"), tokens);
				SetMember(tree->second, obj->GetMember(L"second"), tokens);
				SetMember(tree->op, obj->GetMember(L"op"), tokens);
			}

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
			{
				if(obj->GetType()==L"PrimaryQuery")
				{
					vl::Ptr<GuiIqPrimaryQuery> tree = new GuiIqPrimaryQuery;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<GuiIqQuery>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"CascadeQuery")
				{
					vl::Ptr<GuiIqCascadeQuery> tree = new GuiIqCascadeQuery;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<GuiIqQuery>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SetQuery")
				{
					vl::Ptr<GuiIqSetQuery> tree = new GuiIqSetQuery;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<GuiIqQuery>(), obj, tokens);
					return tree;
				}
				else 
					return 0;
			}
		};

		vl::Ptr<vl::parsing::ParsingTreeCustomBase> GuiIqConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			GuiIqTreeConverter converter;
			vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
			converter.SetMember(tree, node, tokens);
			return tree;
		}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

		vl::Ptr<GuiIqPrimaryQuery> GuiIqPrimaryQuery::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return GuiIqConvertParsingTreeNode(node, tokens).Cast<GuiIqPrimaryQuery>();
		}

		vl::Ptr<GuiIqCascadeQuery> GuiIqCascadeQuery::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return GuiIqConvertParsingTreeNode(node, tokens).Cast<GuiIqCascadeQuery>();
		}

		vl::Ptr<GuiIqSetQuery> GuiIqSetQuery::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return GuiIqConvertParsingTreeNode(node, tokens).Cast<GuiIqSetQuery>();
		}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

		void GuiIqPrimaryQuery::Accept(GuiIqQuery::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void GuiIqCascadeQuery::Accept(GuiIqQuery::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void GuiIqSetQuery::Accept(GuiIqQuery::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

/***********************************************************************
Parser Function
***********************************************************************/

		vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"QueryRoot");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return GuiIqParseAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"QueryRoot");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return GuiIqConvertParsingTreeNode(node, state.GetTokens()).Cast<GuiIqQuery>();
			}
			return 0;
		}

		vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return GuiIqParse(input, table, errors, codeIndex);
		}

/***********************************************************************
Table Generation
***********************************************************************/

		vl::Ptr<vl::parsing::tabling::ParsingTable> GuiIqLoadTable()
		{
			vl::stream::MemoryStream stream;
			GuiIqGetParserBuffer(stream);
			vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
			table->Initialize();
			return table;
		}

	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::presentation;

			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqQuery, presentation::GuiIqQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqNameOption, presentation::GuiIqNameOption)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqChildOption, presentation::GuiIqChildOption)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqPrimaryQuery, presentation::GuiIqPrimaryQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqCascadeQuery, presentation::GuiIqCascadeQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqBinaryOperator, presentation::GuiIqBinaryOperator)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqSetQuery, presentation::GuiIqSetQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqQuery::IVisitor, presentation::GuiIqQuery::IVisitor)

			BEGIN_CLASS_MEMBER(GuiIqQuery)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(GuiIqQuery)

			BEGIN_ENUM_ITEM(GuiIqNameOption)
				ENUM_ITEM_NAMESPACE(GuiIqNameOption)
				ENUM_NAMESPACE_ITEM(Specified)
				ENUM_NAMESPACE_ITEM(Any)
			END_ENUM_ITEM(GuiIqNameOption)

			BEGIN_ENUM_ITEM(GuiIqChildOption)
				ENUM_ITEM_NAMESPACE(GuiIqChildOption)
				ENUM_NAMESPACE_ITEM(Direct)
				ENUM_NAMESPACE_ITEM(Indirect)
			END_ENUM_ITEM(GuiIqChildOption)

			BEGIN_CLASS_MEMBER(GuiIqPrimaryQuery)
				CLASS_MEMBER_BASE(GuiIqQuery)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<GuiIqPrimaryQuery>(), NO_PARAMETER)

				CLASS_MEMBER_EXTERNALMETHOD(get_attributeName, NO_PARAMETER, vl::WString(GuiIqPrimaryQuery::*)(), [](GuiIqPrimaryQuery* node){ return node->attributeName.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_attributeName, {L"value"}, void(GuiIqPrimaryQuery::*)(const vl::WString&), [](GuiIqPrimaryQuery* node, const vl::WString& value){ node->attributeName.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_typeName, NO_PARAMETER, vl::WString(GuiIqPrimaryQuery::*)(), [](GuiIqPrimaryQuery* node){ return node->typeName.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_typeName, {L"value"}, void(GuiIqPrimaryQuery::*)(const vl::WString&), [](GuiIqPrimaryQuery* node, const vl::WString& value){ node->typeName.value = value; })
				CLASS_MEMBER_EXTERNALMETHOD(get_referenceName, NO_PARAMETER, vl::WString(GuiIqPrimaryQuery::*)(), [](GuiIqPrimaryQuery* node){ return node->referenceName.value; })
				CLASS_MEMBER_EXTERNALMETHOD(set_referenceName, {L"value"}, void(GuiIqPrimaryQuery::*)(const vl::WString&), [](GuiIqPrimaryQuery* node, const vl::WString& value){ node->referenceName.value = value; })

				CLASS_MEMBER_FIELD(childOption)
				CLASS_MEMBER_FIELD(attributeNameOption)
				CLASS_MEMBER_PROPERTY(attributeName, get_attributeName, set_attributeName)
				CLASS_MEMBER_FIELD(typeNameOption)
				CLASS_MEMBER_PROPERTY(typeName, get_typeName, set_typeName)
				CLASS_MEMBER_PROPERTY(referenceName, get_referenceName, set_referenceName)
			END_CLASS_MEMBER(GuiIqPrimaryQuery)

			BEGIN_CLASS_MEMBER(GuiIqCascadeQuery)
				CLASS_MEMBER_BASE(GuiIqQuery)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<GuiIqCascadeQuery>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_FIELD(child)
			END_CLASS_MEMBER(GuiIqCascadeQuery)

			BEGIN_ENUM_ITEM(GuiIqBinaryOperator)
				ENUM_ITEM_NAMESPACE(GuiIqBinaryOperator)
				ENUM_NAMESPACE_ITEM(ExclusiveOr)
				ENUM_NAMESPACE_ITEM(Intersect)
				ENUM_NAMESPACE_ITEM(Union)
				ENUM_NAMESPACE_ITEM(Substract)
			END_ENUM_ITEM(GuiIqBinaryOperator)

			BEGIN_CLASS_MEMBER(GuiIqSetQuery)
				CLASS_MEMBER_BASE(GuiIqQuery)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<GuiIqSetQuery>(), NO_PARAMETER)


				CLASS_MEMBER_FIELD(first)
				CLASS_MEMBER_FIELD(second)
				CLASS_MEMBER_FIELD(op)
			END_CLASS_MEMBER(GuiIqSetQuery)

			BEGIN_CLASS_MEMBER(GuiIqQuery::IVisitor)
				CLASS_MEMBER_BASE(vl::reflection::IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiIqQuery::IVisitor>(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::GuiIqQuery_IVisitor::Create)

				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(GuiIqQuery::IVisitor::*)(GuiIqPrimaryQuery* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(GuiIqQuery::IVisitor::*)(GuiIqCascadeQuery* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(GuiIqQuery::IVisitor::*)(GuiIqSetQuery* node))
			END_CLASS_MEMBER(GuiIqQuery)

			class GuiIqTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::presentation::GuiIqQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqNameOption)
					ADD_TYPE_INFO(vl::presentation::GuiIqChildOption)
					ADD_TYPE_INFO(vl::presentation::GuiIqPrimaryQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqCascadeQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqBinaryOperator)
					ADD_TYPE_INFO(vl::presentation::GuiIqSetQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqQuery::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool GuiIqLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiIqTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONBASIC.CPP
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			using namespace collections;
			using namespace parsing;
			using namespace parsing::tabling;
			using namespace parsing::xml;
			using namespace stream;

#ifndef VCZH_DEBUG_NO_REFLECTION

			GUIREFLECTIONBASIC_TYPELIST(IMPL_VL_TYPE_INFO)

			GuiGraphicsAnimationManager* GuiControlHost_GetAnimationManager(GuiControlHost* thisObject)
			{
				return thisObject->GetGraphicsHost()->GetAnimationManager();
			}

/***********************************************************************
Color Serialization
***********************************************************************/

			Color TypedValueSerializerProvider<Color>::GetDefaultValue()
			{
				return Color();
			}

			bool TypedValueSerializerProvider<Color>::Serialize(const Color& input, WString& output)
			{
				output=input.ToString();
				return true;
			}

			bool TypedValueSerializerProvider<Color>::Deserialize(const WString& input, Color& output)
			{
				output=Color::Parse(input);
				return true;
			}

/***********************************************************************
GlobalStringKey Serialization
***********************************************************************/

			GlobalStringKey TypedValueSerializerProvider<GlobalStringKey>::GetDefaultValue()
			{
				return GlobalStringKey();
			}

			bool TypedValueSerializerProvider<GlobalStringKey>::Serialize(const GlobalStringKey& input, WString& output)
			{
				output=input.ToString();
				return true;
			}

			bool TypedValueSerializerProvider<GlobalStringKey>::Deserialize(const WString& input, GlobalStringKey& output)
			{
				output = GlobalStringKey::Get(input);
				return true;
			}

/***********************************************************************
External Functions
***********************************************************************/

			Ptr<INativeImage> INativeImage_Constructor(const WString& path)
			{
				return GetCurrentController()->ImageService()->CreateImageFromFile(path);
			}

			INativeCursor* INativeCursor_Constructor1()
			{
				return GetCurrentController()->ResourceService()->GetDefaultSystemCursor();
			}

			INativeCursor* INativeCursor_Constructor2(INativeCursor::SystemCursorType type)
			{
				return GetCurrentController()->ResourceService()->GetSystemCursor(type);
			}

			Ptr<DocumentModel> DocumentModel_Constructor(const WString& path)
			{
				FileStream fileStream(path, FileStream::ReadOnly);
				if(!fileStream.IsAvailable()) return 0;

				BomDecoder decoder;
				DecoderStream decoderStream(fileStream, decoder);
				StreamReader reader(decoderStream);
				WString xmlText=reader.ReadToEnd();

				Ptr<ParsingTable> table=XmlLoadTable();
				Ptr<XmlDocument> xml=XmlParseDocument(xmlText, table);
				if(!xml) return 0;

				List<WString> errors;
				return DocumentModel::LoadFromXml(xml, GetFolderPath(path), errors);
			}

/***********************************************************************
Type Declaration
***********************************************************************/

#define _ ,

			BEGIN_ENUM_ITEM(Alignment)
				ENUM_CLASS_ITEM(Left)
				ENUM_CLASS_ITEM(Top)
				ENUM_CLASS_ITEM(Center)
				ENUM_CLASS_ITEM(Right)
				ENUM_CLASS_ITEM(Bottom)
			END_ENUM_ITEM(Alignment)

			BEGIN_STRUCT_MEMBER(TextPos)
				STRUCT_MEMBER(row)
				STRUCT_MEMBER(column)
			END_STRUCT_MEMBER(TextPos)

			BEGIN_STRUCT_MEMBER(GridPos)
				STRUCT_MEMBER(row)
				STRUCT_MEMBER(column)
			END_STRUCT_MEMBER(GridPos)

			BEGIN_STRUCT_MEMBER(Point)
				STRUCT_MEMBER(x)
				STRUCT_MEMBER(y)
			END_STRUCT_MEMBER(Point)

			BEGIN_STRUCT_MEMBER(Size)
				STRUCT_MEMBER(x)
				STRUCT_MEMBER(y)
			END_STRUCT_MEMBER(Size)

			BEGIN_STRUCT_MEMBER(Rect)
				STRUCT_MEMBER(x1)
				STRUCT_MEMBER(y1)
				STRUCT_MEMBER(x2)
				STRUCT_MEMBER(y2)
			END_STRUCT_MEMBER(Rect)

			BEGIN_STRUCT_MEMBER(Margin)
				STRUCT_MEMBER(left)
				STRUCT_MEMBER(top)
				STRUCT_MEMBER(right)
				STRUCT_MEMBER(bottom)
			END_STRUCT_MEMBER(Margin)

			BEGIN_STRUCT_MEMBER(FontProperties)
				STRUCT_MEMBER(fontFamily)
				STRUCT_MEMBER(size)
				STRUCT_MEMBER(bold)
				STRUCT_MEMBER(italic)
				STRUCT_MEMBER(underline)
				STRUCT_MEMBER(strikeline)
				STRUCT_MEMBER(antialias)
				STRUCT_MEMBER(verticalAntialias)
			END_STRUCT_MEMBER(FontProperties)

			BEGIN_CLASS_MEMBER(INativeImageFrame)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_METHOD(GetImage, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetSize, NO_PARAMETER)
			END_CLASS_MEMBER(INativeImageFrame)

			BEGIN_CLASS_MEMBER(INativeImage)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_METHOD(GetFormat, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetFrameCount, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetFrame, {L"index"})
				CLASS_MEMBER_EXTERNALCTOR(Ptr<INativeImage>(const WString&), {L"filePath"}, &INativeImage_Constructor)
			END_CLASS_MEMBER(INativeImage)

			BEGIN_ENUM_ITEM(INativeImage::FormatType)
				ENUM_ITEM_NAMESPACE(INativeImage)
				ENUM_NAMESPACE_ITEM(Bmp)
				ENUM_NAMESPACE_ITEM(Gif)
				ENUM_NAMESPACE_ITEM(Icon)
				ENUM_NAMESPACE_ITEM(Jpeg)
				ENUM_NAMESPACE_ITEM(Png)
				ENUM_NAMESPACE_ITEM(Tiff)
				ENUM_NAMESPACE_ITEM(Wmp)
				ENUM_NAMESPACE_ITEM(Unknown)
			END_ENUM_ITEM(INativeImage::FormatType)

			BEGIN_CLASS_MEMBER(INativeCursor)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_METHOD(IsSystemCursor, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetSystemCursorType, NO_PARAMETER)
				CLASS_MEMBER_EXTERNALCTOR(INativeCursor*(), NO_PARAMETER, &INativeCursor_Constructor1)
				CLASS_MEMBER_EXTERNALCTOR(INativeCursor*(INativeCursor::SystemCursorType), NO_PARAMETER, &INativeCursor_Constructor2)
			END_CLASS_MEMBER(INativeCursor)

			BEGIN_ENUM_ITEM(INativeCursor::SystemCursorType)
				ENUM_ITEM_NAMESPACE(INativeCursor)
				ENUM_NAMESPACE_ITEM(SmallWaiting)
				ENUM_NAMESPACE_ITEM(LargeWaiting)
				ENUM_NAMESPACE_ITEM(Arrow)
				ENUM_NAMESPACE_ITEM(Cross)
				ENUM_NAMESPACE_ITEM(Hand)
				ENUM_NAMESPACE_ITEM(Help)
				ENUM_NAMESPACE_ITEM(IBeam)
				ENUM_NAMESPACE_ITEM(SizeAll)
				ENUM_NAMESPACE_ITEM(SizeNESW)
				ENUM_NAMESPACE_ITEM(SizeNS)
				ENUM_NAMESPACE_ITEM(SizeNWSE)
				ENUM_NAMESPACE_ITEM(SizeWE)
			END_ENUM_ITEM(INativeCursor::SystemCursorType)

			BEGIN_CLASS_MEMBER(INativeWindow)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_PROPERTY_FAST(Bounds)
				CLASS_MEMBER_PROPERTY_FAST(ClientSize)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ClientBoundsInScreen)
				CLASS_MEMBER_PROPERTY_FAST(Title)
				CLASS_MEMBER_PROPERTY_FAST(WindowCursor)
				CLASS_MEMBER_PROPERTY_FAST(CaretPoint)
				CLASS_MEMBER_PROPERTY_FAST(Parent)
				CLASS_MEMBER_PROPERTY_FAST(AlwaysPassFocusToParent)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SizeState)
				CLASS_MEMBER_PROPERTY_FAST(MinimizedBox)
				CLASS_MEMBER_PROPERTY_FAST(MaximizedBox)
				CLASS_MEMBER_PROPERTY_FAST(Border)
				CLASS_MEMBER_PROPERTY_FAST(SizeBox)
				CLASS_MEMBER_PROPERTY_FAST(IconVisible)
				CLASS_MEMBER_PROPERTY_FAST(TitleBar)
				CLASS_MEMBER_PROPERTY_FAST(TopMost)

				CLASS_MEMBER_METHOD(EnableCustomFrameMode, NO_PARAMETER)
				CLASS_MEMBER_METHOD(DisableCustomFrameMode, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsCustomFrameModeEnabled, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Show, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowDeactivated, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowRestored, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowMaximized, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowMinimized, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Hide, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsVisible, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Enable, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Disable, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsEnabled, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetFocus, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsFocused, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetActivate, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsActivated, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowInTaskBar, NO_PARAMETER)
				CLASS_MEMBER_METHOD(HideInTaskBar, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsAppearedInTaskBar, NO_PARAMETER)
				CLASS_MEMBER_METHOD(EnableActivate, NO_PARAMETER)
				CLASS_MEMBER_METHOD(DisableActivate, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsEnabledActivate, NO_PARAMETER)
				CLASS_MEMBER_METHOD(RequireCapture, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ReleaseCapture, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsCapturing, NO_PARAMETER)
				CLASS_MEMBER_METHOD(RedrawContent, NO_PARAMETER)
			END_CLASS_MEMBER(INativeWindow)

			BEGIN_ENUM_ITEM(INativeWindow::WindowSizeState)
				ENUM_ITEM_NAMESPACE(INativeWindow)
				ENUM_NAMESPACE_ITEM(Minimized)
				ENUM_NAMESPACE_ITEM(Restored)
				ENUM_NAMESPACE_ITEM(Maximized)
			END_ENUM_ITEM(INativeWindow::WindowSizeState)

			BEGIN_CLASS_MEMBER(INativeDelay)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Status)

				CLASS_MEMBER_METHOD(Delay, {L"milliseconds"})
				CLASS_MEMBER_METHOD(Cancel, NO_PARAMETER)
			END_CLASS_MEMBER(INativeDelay)

			BEGIN_ENUM_ITEM(INativeDelay::ExecuteStatus)
				ENUM_ITEM_NAMESPACE(INativeDelay)
				ENUM_NAMESPACE_ITEM(Pending)
				ENUM_NAMESPACE_ITEM(Executing)
				ENUM_NAMESPACE_ITEM(Executed)
				ENUM_NAMESPACE_ITEM(Canceled)
			END_ENUM_ITEM(INativeDelay::ExecuteStatus)

			BEGIN_CLASS_MEMBER(INativeScreen)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Bounds);
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ClientBounds);
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Name);

				CLASS_MEMBER_METHOD(IsPrimary, NO_PARAMETER)
			END_CLASS_MEMBER(INativeScreen)

			BEGIN_CLASS_MEMBER(INativeImageService)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_METHOD(CreateImageFromFile, {L"path"})
			END_CLASS_MEMBER(INativeImageService)

			BEGIN_CLASS_MEMBER(INativeResourceService)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(DefaultSystemCursor)
				CLASS_MEMBER_PROPERTY_FAST(DefaultFont)

				CLASS_MEMBER_METHOD(GetSystemCursor, {L"type"})
			END_CLASS_MEMBER(INativeResourceService)

			BEGIN_CLASS_MEMBER(INativeAsyncService)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_METHOD(IsInMainThread, {L"type"})
				CLASS_MEMBER_METHOD(InvokeAsync, {L"proc"})
				CLASS_MEMBER_METHOD(InvokeInMainThread, {L"proc"})
				CLASS_MEMBER_METHOD(InvokeInMainThreadAndWait, {L"proc" _ L"milliseconds"})
				CLASS_MEMBER_METHOD(DelayExecute, {L"proc" _ L"milliseconds"})
				CLASS_MEMBER_METHOD(DelayExecuteInMainThread, {L"proc" _ L"milliseconds"})
			END_CLASS_MEMBER(INativeAsyncService)

			BEGIN_CLASS_MEMBER(INativeClipboardService)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_PROPERTY_FAST(Text)

				CLASS_MEMBER_METHOD(ContainsText, NO_PARAMETER)
			END_CLASS_MEMBER(INativeClipboardService)

			BEGIN_CLASS_MEMBER(INativeScreenService)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ScreenCount)

				CLASS_MEMBER_METHOD_OVERLOAD(GetScreen, {L"index"}, INativeScreen*(INativeScreenService::*)(vint))
				CLASS_MEMBER_METHOD_OVERLOAD(GetScreen, {L"window"}, INativeScreen*(INativeScreenService::*)(INativeWindow*))
			END_CLASS_MEMBER(INativeScreenService)

			BEGIN_CLASS_MEMBER(INativeInputService)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_METHOD(IsKeyPressing, { L"code" })
				CLASS_MEMBER_METHOD(IsKeyToggled, { L"code" })
				CLASS_MEMBER_METHOD(GetKeyName, { L"code" })
				CLASS_MEMBER_METHOD(GetKey, { L"name" })
			END_CLASS_MEMBER(INativeInputService)

			BEGIN_ENUM_ITEM(INativeDialogService::MessageBoxButtonsInput)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(DisplayOK)
				ENUM_NAMESPACE_ITEM(DisplayOKCancel)
				ENUM_NAMESPACE_ITEM(DisplayYesNo)
				ENUM_NAMESPACE_ITEM(DisplayYesNoCancel)
				ENUM_NAMESPACE_ITEM(DisplayRetryCancel)
				ENUM_NAMESPACE_ITEM(DisplayAbortRetryIgnore)
				ENUM_NAMESPACE_ITEM(DisplayCancelTryAgainContinue)
			END_ENUM_ITEM(INativeDialogService::MessageBoxButtonsInput)

			BEGIN_ENUM_ITEM(INativeDialogService::MessageBoxButtonsOutput)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(SelectOK)
				ENUM_NAMESPACE_ITEM(SelectCancel)
				ENUM_NAMESPACE_ITEM(SelectYes)
				ENUM_NAMESPACE_ITEM(SelectNo)
				ENUM_NAMESPACE_ITEM(SelectRetry)
				ENUM_NAMESPACE_ITEM(SelectAbort)
				ENUM_NAMESPACE_ITEM(SelectIgnore)
				ENUM_NAMESPACE_ITEM(SelectTryAgain)
				ENUM_NAMESPACE_ITEM(SelectContinue)
			END_ENUM_ITEM(INativeDialogService::MessageBoxButtonsOutput)

			BEGIN_ENUM_ITEM(INativeDialogService::MessageBoxDefaultButton)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(DefaultFirst)
				ENUM_NAMESPACE_ITEM(DefaultSecond)
				ENUM_NAMESPACE_ITEM(DefaultThird)
			END_ENUM_ITEM(INativeDialogService::MessageBoxDefaultButton)

			BEGIN_ENUM_ITEM(INativeDialogService::MessageBoxIcons)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(IconNone)
				ENUM_NAMESPACE_ITEM(IconError)
				ENUM_NAMESPACE_ITEM(IconQuestion)
				ENUM_NAMESPACE_ITEM(IconWarning)
				ENUM_NAMESPACE_ITEM(IconInformation)
			END_ENUM_ITEM(INativeDialogService::MessageBoxIcons)

			BEGIN_ENUM_ITEM(INativeDialogService::MessageBoxModalOptions)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(ModalWindow)
				ENUM_NAMESPACE_ITEM(ModalTask)
				ENUM_NAMESPACE_ITEM(ModalSystem)
			END_ENUM_ITEM(INativeDialogService::MessageBoxModalOptions)

			BEGIN_ENUM_ITEM(INativeDialogService::ColorDialogCustomColorOptions)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(CustomColorDisabled)
				ENUM_NAMESPACE_ITEM(CustomColorEnabled)
				ENUM_NAMESPACE_ITEM(CustomColorOpened)
			END_ENUM_ITEM(INativeDialogService::ColorDialogCustomColorOptions)

			BEGIN_ENUM_ITEM(INativeDialogService::FileDialogTypes)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(FileDialogOpen)
				ENUM_NAMESPACE_ITEM(FileDialogOpenPreview)
				ENUM_NAMESPACE_ITEM(FileDialogSave)
				ENUM_NAMESPACE_ITEM(FileDialogSavePreview)
			END_ENUM_ITEM(INativeDialogService::FileDialogTypes)

			BEGIN_ENUM_ITEM_MERGABLE(INativeDialogService::FileDialogOptions)
				ENUM_ITEM_NAMESPACE(INativeDialogService)
				ENUM_NAMESPACE_ITEM(FileDialogAllowMultipleSelection)
				ENUM_NAMESPACE_ITEM(FileDialogFileMustExist)
				ENUM_NAMESPACE_ITEM(FileDialogShowReadOnlyCheckBox)
				ENUM_NAMESPACE_ITEM(FileDialogDereferenceLinks)
				ENUM_NAMESPACE_ITEM(FileDialogShowNetworkButton)
				ENUM_NAMESPACE_ITEM(FileDialogPromptCreateFile)
				ENUM_NAMESPACE_ITEM(FileDialogPromptOverwriteFile)
				ENUM_NAMESPACE_ITEM(FileDialogDirectoryMustExist)
				ENUM_NAMESPACE_ITEM(FileDialogAddToRecent)
			END_ENUM_ITEM(INativeDialogService::FileDialogOptions)

			BEGIN_CLASS_MEMBER(INativeController)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_STATIC_EXTERNALMETHOD(GetCurrentController, NO_PARAMETER, INativeController*(*)(), &GetCurrentController)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(OSVersion)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ExecutablePath)

				CLASS_MEMBER_METHOD(ResourceService, NO_PARAMETER)
				CLASS_MEMBER_METHOD(AsyncService, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ClipboardService, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ImageService, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ScreenService, NO_PARAMETER)
				CLASS_MEMBER_METHOD(InputService, NO_PARAMETER)
			END_CLASS_MEMBER(INativeController)

			BEGIN_CLASS_MEMBER(GuiImageData)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiImageData>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiImageData>(Ptr<INativeImage>, vint), {L"image" _ L"frameIndex"})

				CLASS_MEMBER_METHOD(GetImage, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetFrameIndex, NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_READONLY(Image, GetImage)
				CLASS_MEMBER_PROPERTY_READONLY(FrameIndex, GetFrameIndex)
			END_CLASS_MEMBER(GuiImageData)

			BEGIN_CLASS_MEMBER(GuiTextData)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiTextData>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiTextData>(const WString&), {L"text"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Text)
			END_CLASS_MEMBER(GuiTextData)

			BEGIN_CLASS_MEMBER(DocumentStyleProperties)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentStyleProperties>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(face)
				CLASS_MEMBER_FIELD(size)
				CLASS_MEMBER_FIELD(color)
				CLASS_MEMBER_FIELD(backgroundColor)
				CLASS_MEMBER_FIELD(bold)
				CLASS_MEMBER_FIELD(italic)
				CLASS_MEMBER_FIELD(underline)
				CLASS_MEMBER_FIELD(strikeline)
				CLASS_MEMBER_FIELD(antialias)
				CLASS_MEMBER_FIELD(verticalAntialias)
			END_CLASS_MEMBER(DocumentStyleProperties)

			BEGIN_CLASS_MEMBER(DocumentRun)
			END_CLASS_MEMBER(DocumentRun)

			BEGIN_CLASS_MEMBER(DocumentContainerRun)
				CLASS_MEMBER_BASE(DocumentRun)

				CLASS_MEMBER_FIELD(runs)
			END_CLASS_MEMBER(DocumentContainerRun)

			BEGIN_CLASS_MEMBER(DocumentContentRun)
				CLASS_MEMBER_BASE(DocumentRun)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(RepresentationText)
			END_CLASS_MEMBER(DocumentContentRun)

			BEGIN_CLASS_MEMBER(DocumentTextRun)
				CLASS_MEMBER_BASE(DocumentContentRun)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentTextRun>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(text)
			END_CLASS_MEMBER(DocumentTextRun)

			BEGIN_CLASS_MEMBER(DocumentInlineObjectRun)
				CLASS_MEMBER_BASE(DocumentContentRun)
				
				CLASS_MEMBER_FIELD(size)
				CLASS_MEMBER_FIELD(baseline)
			END_CLASS_MEMBER(DocumentInlineObjectRun)

			BEGIN_CLASS_MEMBER(DocumentImageRun)
				CLASS_MEMBER_BASE(DocumentInlineObjectRun)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentImageRun>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(image)
				CLASS_MEMBER_FIELD(frameIndex)
				CLASS_MEMBER_FIELD(source)
			END_CLASS_MEMBER(DocumentImageRun)

			BEGIN_CLASS_MEMBER(DocumentStylePropertiesRun)
				CLASS_MEMBER_BASE(DocumentContainerRun)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentStylePropertiesRun>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(style)
			END_CLASS_MEMBER(DocumentStylePropertiesRun)

			BEGIN_CLASS_MEMBER(DocumentStyleApplicationRun)
				CLASS_MEMBER_BASE(DocumentContainerRun)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentStyleApplicationRun>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(styleName)
			END_CLASS_MEMBER(DocumentStyleApplicationRun)

			BEGIN_CLASS_MEMBER(DocumentHyperlinkRun)
				CLASS_MEMBER_BASE(DocumentStyleApplicationRun)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentHyperlinkRun>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(normalStyleName)
				CLASS_MEMBER_FIELD(activeStyleName)
				CLASS_MEMBER_FIELD(reference)
			END_CLASS_MEMBER(DocumentHyperlinkRun)

			BEGIN_CLASS_MEMBER(DocumentParagraphRun)
				CLASS_MEMBER_BASE(DocumentContainerRun)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentParagraphRun>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(alignment)

				CLASS_MEMBER_METHOD_OVERLOAD(GetText, {L"skipNonTextContent"}, WString(DocumentParagraphRun::*)(bool))
			END_CLASS_MEMBER(DocumentParagraphRun)

			BEGIN_CLASS_MEMBER(DocumentStyle)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DocumentStyle>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(parentStyleName)
				CLASS_MEMBER_FIELD(styles)
				CLASS_MEMBER_FIELD(resolvedStyles)
			END_CLASS_MEMBER(DocumentStyle)

			BEGIN_CLASS_MEMBER(DocumentModel)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<DocumentModel>(const WString&), {L"filePath"}, &DocumentModel_Constructor)
				
				CLASS_MEMBER_FIELD(paragraphs)
				CLASS_MEMBER_FIELD(styles)

				CLASS_MEMBER_METHOD_OVERLOAD(GetText, {L"skipNonTextContent"}, WString(DocumentModel::*)(bool))
				CLASS_MEMBER_STATIC_METHOD_OVERLOAD(LoadFromXml, {L"xml" _ L"workingDirectory" _ L"errors"}, Ptr<DocumentModel>(*)(Ptr<XmlDocument>, const WString&, List<WString>&))
				CLASS_MEMBER_STATIC_METHOD_OVERLOAD(LoadFromXml, {L"filePath" _ L"errors"}, Ptr<DocumentModel>(*)(const WString&, List<WString>&))
				CLASS_MEMBER_METHOD_OVERLOAD(SaveToXml, NO_PARAMETER, Ptr<XmlDocument>(DocumentModel::*)())
				CLASS_MEMBER_METHOD_OVERLOAD(SaveToXml, {L"filePath"}, bool(DocumentModel::*)(const WString&))
			END_CLASS_MEMBER(DocumentModel)

			BEGIN_CLASS_MEMBER(GuiInstanceStyle)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceStyle>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(query)
				CLASS_MEMBER_FIELD(setter)

				CLASS_MEMBER_STATIC_METHOD_OVERLOAD(LoadFromXml, {L"xml" _ L"errors"}, Ptr<GuiInstanceStyle>(*)(Ptr<XmlDocument>, List<WString>&))
				CLASS_MEMBER_METHOD_OVERLOAD(SaveToXml, NO_PARAMETER, Ptr<XmlDocument>(GuiInstanceStyle::*)())
			END_CLASS_MEMBER(GuiInstanceStyle)

			BEGIN_CLASS_MEMBER(GuiInstanceStyleContext)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceStyleContext>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(styles)

				CLASS_MEMBER_STATIC_METHOD(LoadFromXml, {L"xml" _ L"errors"})
				CLASS_MEMBER_METHOD(SaveToXml, NO_PARAMETER)
			END_CLASS_MEMBER(GuiInstanceStyleContext)

			BEGIN_CLASS_MEMBER(GuiInstancePropertySchame)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstancePropertySchame>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(name)
				CLASS_MEMBER_FIELD(typeName)
				CLASS_MEMBER_FIELD(readonly)
				CLASS_MEMBER_FIELD(observable)
			END_CLASS_MEMBER(GuiInstancePropertySchame)

			BEGIN_CLASS_MEMBER(GuiInstanceTypeSchema)
				CLASS_MEMBER_FIELD(typeName)
				CLASS_MEMBER_FIELD(parentType)
				CLASS_MEMBER_FIELD(properties)
			END_CLASS_MEMBER(GuiInstanceTypeSchema)

			BEGIN_CLASS_MEMBER(GuiInstanceDataSchema)
				CLASS_MEMBER_BASE(GuiInstanceTypeSchema)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceDataSchema>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(referenceType)
			END_CLASS_MEMBER(GuiInstanceDataSchema)

			BEGIN_CLASS_MEMBER(GuiInstanceMethodSchema)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceMethodSchema>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(name)
				CLASS_MEMBER_FIELD(returnType)
				CLASS_MEMBER_FIELD(arguments)
			END_CLASS_MEMBER(GuiInstanceMethodSchema)

			BEGIN_CLASS_MEMBER(GuiInstanceInterfaceSchema)
				CLASS_MEMBER_BASE(GuiInstanceTypeSchema)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceInterfaceSchema>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(methods)
			END_CLASS_MEMBER(GuiInstanceInterfaceSchema)

			BEGIN_CLASS_MEMBER(GuiInstanceSchema)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceSchema>(), NO_PARAMETER)
				
				CLASS_MEMBER_FIELD(schemas)

				CLASS_MEMBER_STATIC_METHOD(LoadFromXml, {L"xml" _ L"errors"})
				CLASS_MEMBER_METHOD(SaveToXml, NO_PARAMETER)
			END_CLASS_MEMBER(GuiInstanceSchema)

			BEGIN_CLASS_MEMBER(GuiValueRepr)
			END_CLASS_MEMBER(GuiValueRepr)

			BEGIN_CLASS_MEMBER(GuiTextRepr)
				CLASS_MEMBER_BASE(GuiValueRepr)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiTextRepr>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(text)
			END_CLASS_MEMBER(GuiTextRepr)

			BEGIN_CLASS_MEMBER(GuiAttSetterRepr)
				CLASS_MEMBER_BASE(GuiValueRepr)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiAttSetterRepr>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(setters)
				CLASS_MEMBER_FIELD(eventHandlers)
				CLASS_MEMBER_FIELD(instanceName)
			END_CLASS_MEMBER(GuiAttSetterRepr)

			BEGIN_CLASS_MEMBER(GuiAttSetterRepr::SetterValue)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiAttSetterRepr::SetterValue>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(binding)
				CLASS_MEMBER_FIELD(values)
			END_CLASS_MEMBER(GuiAttSetterRepr::SetterValue)

			BEGIN_CLASS_MEMBER(GuiAttSetterRepr::EventValue)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiAttSetterRepr::EventValue>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(binding)
				CLASS_MEMBER_FIELD(value)
			END_CLASS_MEMBER(GuiAttSetterRepr::EventValue)

			BEGIN_CLASS_MEMBER(GuiConstructorRepr)
				CLASS_MEMBER_BASE(GuiAttSetterRepr)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiConstructorRepr>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(typeNamespace)
				CLASS_MEMBER_FIELD(typeName)
				CLASS_MEMBER_FIELD(styleName)
			END_CLASS_MEMBER(GuiConstructorRepr)

			BEGIN_CLASS_MEMBER(GuiInstanceNamespace)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceNamespace>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(prefix)
				CLASS_MEMBER_FIELD(postfix)
			END_CLASS_MEMBER(GuiInstanceNamespace)

			BEGIN_CLASS_MEMBER(GuiInstanceParameter)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceParameter>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(name)
				CLASS_MEMBER_FIELD(className)
			END_CLASS_MEMBER(GuiInstanceParameter)

			BEGIN_CLASS_MEMBER(GuiInstanceProperty)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceProperty>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(name)
				CLASS_MEMBER_FIELD(typeName)
				CLASS_MEMBER_FIELD(readonly)
			END_CLASS_MEMBER(GuiInstanceProperty)

			BEGIN_CLASS_MEMBER(GuiInstanceState)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceState>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(name)
				CLASS_MEMBER_FIELD(typeName)
			END_CLASS_MEMBER(GuiInstanceState)

			BEGIN_CLASS_MEMBER(GuiInstanceContext)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceContext>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(instance)
				CLASS_MEMBER_FIELD(namespaces)
				CLASS_MEMBER_FIELD(codeBehind)
				CLASS_MEMBER_FIELD(className)
				CLASS_MEMBER_FIELD(parameters)
				CLASS_MEMBER_FIELD(properties)
				CLASS_MEMBER_FIELD(states)
				CLASS_MEMBER_FIELD(stylePaths)

				CLASS_MEMBER_STATIC_METHOD(LoadFromXml, {L"xml" _ L"errors"})
				CLASS_MEMBER_METHOD(SaveToXml, {L"serializePrecompiledResource"})
			END_CLASS_MEMBER(GuiInstanceContext)

			BEGIN_CLASS_MEMBER(GuiInstanceContext::NamespaceInfo)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiInstanceContext::NamespaceInfo>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(name)
				CLASS_MEMBER_FIELD(namespaces)
			END_CLASS_MEMBER(GuiInstanceContext::NamespaceInfo)

			BEGIN_CLASS_MEMBER(GuiResourceNodeBase)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Parent)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Name)
				CLASS_MEMBER_PROPERTY_FAST(Path)
			END_CLASS_MEMBER(GuiResourceNodeBase)

			BEGIN_CLASS_MEMBER(GuiResourceItem)
				CLASS_MEMBER_BASE(GuiResourceNodeBase)
				
				CLASS_MEMBER_METHOD(GetContent, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetContent, {L"typeName" _ L"value"})

				CLASS_MEMBER_METHOD(AsImage, NO_PARAMETER)
				CLASS_MEMBER_METHOD(AsXml, NO_PARAMETER)
				CLASS_MEMBER_METHOD(AsString, NO_PARAMETER)
				CLASS_MEMBER_METHOD(AsDocument, NO_PARAMETER)
			END_CLASS_MEMBER(GuiResourceItem)

			BEGIN_CLASS_MEMBER(GuiResourceFolder)
				CLASS_MEMBER_BASE(GuiResourceNodeBase)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Items)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Folders)

				CLASS_MEMBER_METHOD(GetItem, { L"name" })
				CLASS_MEMBER_METHOD(AddItem, { L"name" _ L"item" })
				CLASS_MEMBER_METHOD(RemoveItem, { L"name" })
				CLASS_MEMBER_METHOD(ClearItems, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetFolder, { L"name" })
				CLASS_MEMBER_METHOD(AddFolder, { L"name" _ L"folder" })
				CLASS_MEMBER_METHOD(RemoveFolder, { L"name" })
				CLASS_MEMBER_METHOD(ClearFolders, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetValueByPath, { L"path" })
				CLASS_MEMBER_METHOD(GetFolderByPath, { L"path" })
			END_CLASS_MEMBER(GuiResourceFolder)

			BEGIN_CLASS_MEMBER(GuiResource)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<GuiResource>(), NO_PARAMETER)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiResource>(const WString&, List<WString>&), {L"filePath" _ L"errors"}, &GuiResource::LoadFromXml);

				CLASS_MEMBER_PROPERTY_READONLY_FAST(WorkingDirectory)

				CLASS_MEMBER_METHOD(GetDocumentByPath, {L"path"})
				CLASS_MEMBER_METHOD(GetImageByPath, {L"path"})
				CLASS_MEMBER_METHOD(GetXmlByPath, {L"path"})
				CLASS_MEMBER_METHOD(GetStringByPath, {L"path"})
			END_CLASS_MEMBER(GuiResource)

			BEGIN_CLASS_MEMBER(IGuiGraphicsElement)
				CLASS_MEMBER_BASE(IDescriptable)
			END_CLASS_MEMBER(IGuiGraphicsElement)

			BEGIN_CLASS_MEMBER(GuiGraphicsComposition)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(leftButtonDown)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(leftButtonUp)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(leftButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(middleButtonDown)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(middleButtonUp)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(middleButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(rightButtonDown)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(rightButtonUp)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(rightButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(horizontalWheel)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(verticalWheel)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(mouseMove)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(mouseEnter)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(mouseLeave)
				
				CLASS_MEMBER_GUIEVENT_COMPOSITION(previewKey)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(keyDown)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(keyUp)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(systemKeyDown)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(systemKeyUp)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(previewCharInput)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(charInput)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(gotFocus)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(lostFocus)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(caretNotify)
				CLASS_MEMBER_GUIEVENT_COMPOSITION(clipboardNotify)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Parent)
				CLASS_MEMBER_PROPERTY_FAST(OwnedElement)
				CLASS_MEMBER_PROPERTY_FAST(Visible)
				CLASS_MEMBER_PROPERTY_FAST(MinSizeLimitation)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(GlobalBounds)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(AssociatedControl)
				CLASS_MEMBER_PROPERTY_FAST(AssociatedCursor)
				CLASS_MEMBER_PROPERTY_FAST(AssociatedHitTestResult)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RelatedControl)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RelatedControlHost)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RelatedCursor)
				CLASS_MEMBER_PROPERTY_FAST(Margin)
				CLASS_MEMBER_PROPERTY_FAST(InternalMargin)
				CLASS_MEMBER_PROPERTY_FAST(PreferredMinSize)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ClientArea)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(MinPreferredClientSize)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(PreferredBounds)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Bounds)

				CLASS_MEMBER_METHOD_RENAME(GetChildren, Children, NO_PARAMETER)
				CLASS_MEMBER_PROPERTY_READONLY(Children, GetChildren)

				CLASS_MEMBER_METHOD(AddChild, {L"child"})
				CLASS_MEMBER_METHOD(InsertChild, {L"index" _ L"child"})
				CLASS_MEMBER_METHOD(RemoveChild, {L"child"})
				CLASS_MEMBER_METHOD(MoveChild, {L"child" _ L"newIndex"})
				CLASS_MEMBER_METHOD(Render, {L"size"})
				CLASS_MEMBER_METHOD(FindComposition, {L"location"})
				CLASS_MEMBER_METHOD(ForceCalculateSizeImmediately, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsSizeAffectParent, NO_PARAMETER)
			END_CLASS_MEMBER(GuiGraphicsComposition)

			BEGIN_ENUM_ITEM(GuiGraphicsComposition::MinSizeLimitation)
				ENUM_ITEM_NAMESPACE(GuiGraphicsComposition)
				ENUM_NAMESPACE_ITEM(NoLimit)
				ENUM_NAMESPACE_ITEM(LimitToElement)
				ENUM_NAMESPACE_ITEM(LimitToElementAndChildren)
			END_ENUM_ITEM(GuiGraphicsComposition::MinSizeLimitation)

			BEGIN_ENUM_ITEM(INativeWindowListener::HitTestResult)
				ENUM_ITEM_NAMESPACE(INativeWindowListener)
				ENUM_NAMESPACE_ITEM(BorderNoSizing)
				ENUM_NAMESPACE_ITEM(BorderLeft)
				ENUM_NAMESPACE_ITEM(BorderRight)
				ENUM_NAMESPACE_ITEM(BorderTop)
				ENUM_NAMESPACE_ITEM(BorderBottom)
				ENUM_NAMESPACE_ITEM(BorderLeftTop)
				ENUM_NAMESPACE_ITEM(BorderRightTop)
				ENUM_NAMESPACE_ITEM(BorderLeftBottom)
				ENUM_NAMESPACE_ITEM(BorderRightBottom)
				ENUM_NAMESPACE_ITEM(Title)
				ENUM_NAMESPACE_ITEM(ButtonMinimum)
				ENUM_NAMESPACE_ITEM(ButtonMaximum)
				ENUM_NAMESPACE_ITEM(ButtonClose)
				ENUM_NAMESPACE_ITEM(Client)
				ENUM_NAMESPACE_ITEM(Icon)
				ENUM_NAMESPACE_ITEM(NoDecision)
			END_ENUM_ITEM(INativeWindowListener::HitTestResult)

			BEGIN_CLASS_MEMBER(GuiGraphicsSite)
				CLASS_MEMBER_BASE(GuiGraphicsComposition)

				CLASS_MEMBER_PROPERTY_GUIEVENT_READONLY_FAST(Bounds)
			END_CLASS_MEMBER(GuiGraphicsSite)

			BEGIN_CLASS_MEMBER(GuiWindowComposition)
				CLASS_MEMBER_BASE(GuiGraphicsSite)
				CLASS_MEMBER_CONSTRUCTOR(GuiWindowComposition*(), NO_PARAMETER)
			END_CLASS_MEMBER(GuiWindowComposition)

			BEGIN_CLASS_MEMBER(GuiBoundsComposition)
				CLASS_MEMBER_BASE(GuiGraphicsSite)
				CLASS_MEMBER_CONSTRUCTOR(GuiBoundsComposition*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_EVENT_FAST(Bounds, BoundsChanged)
				CLASS_MEMBER_PROPERTY_FAST(AlignmentToParent)
				
				CLASS_MEMBER_METHOD(ClearAlignmentToParent, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsAlignedToParent, NO_PARAMETER)
			END_CLASS_MEMBER(GuiBoundsComposition)

			BEGIN_CLASS_MEMBER(GuiControl)
				CLASS_MEMBER_CONSTRUCTOR(GuiControl*(GuiControl::IStyleController*), {L"styleController"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(StyleController)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(BoundsComposition)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ContainerComposition)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(FocusableComposition)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Parent)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ChildrenCount)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RelatedControlHost)
				CLASS_MEMBER_PROPERTY_GUIEVENT_READONLY_FAST(VisuallyEnabled)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Enabled)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Visible)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Alt)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Text)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Font)
				CLASS_MEMBER_PROPERTY_FAST(Tag)
				CLASS_MEMBER_PROPERTY_FAST(TooltipControl)
				CLASS_MEMBER_PROPERTY_FAST(TooltipWidth)

				CLASS_MEMBER_METHOD(SetActivatingAltHost, { L"host" })
				CLASS_MEMBER_METHOD(GetChild, {L"index"})
				CLASS_MEMBER_METHOD(AddChild, {L"control"})
				CLASS_MEMBER_METHOD(HasChild, {L"control"})
				CLASS_MEMBER_METHOD(SetFocus, NO_PARAMETER)
				CLASS_MEMBER_METHOD(DisplayTooltip, {L"location"})
				CLASS_MEMBER_METHOD(CloseTooltip, NO_PARAMETER)
				CLASS_MEMBER_METHOD_OVERLOAD(QueryService, {L"identifier"}, IDescriptable*(GuiControl::*)(const WString&))
			END_CLASS_MEMBER(GuiControl)

			BEGIN_CLASS_MEMBER(GuiControl::IStyleController)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(GuiControl::IStyleController*(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::GuiControl_IStyleController::Create)

				CLASS_MEMBER_METHOD(GetBoundsComposition, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetContainerComposition, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetFocusableComposition, {L"value"})
				CLASS_MEMBER_METHOD(SetText, {L"value"})
				CLASS_MEMBER_METHOD(SetFont, {L"value"})
				CLASS_MEMBER_METHOD(SetVisuallyEnabled, {L"value"})
			END_CLASS_MEMBER(GuiControl::IStyleController)

			BEGIN_CLASS_MEMBER(GuiControl::IStyleProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_EXTERNALCTOR(GuiControl::IStyleProvider*(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::GuiControl_IStyleProvider::Create)

				CLASS_MEMBER_METHOD(AssociateStyleController, {L"controller"})
				CLASS_MEMBER_METHOD(SetFocusableComposition, {L"value"})
				CLASS_MEMBER_METHOD(SetText, {L"value"})
				CLASS_MEMBER_METHOD(SetFont, {L"value"})
				CLASS_MEMBER_METHOD(SetVisuallyEnabled, {L"value"})
			END_CLASS_MEMBER(GuiControl::IStyleProvider)

			BEGIN_CLASS_MEMBER(GuiComponent)
			END_CLASS_MEMBER(GuiComponent)

			BEGIN_CLASS_MEMBER(GuiControlHost)
				CLASS_MEMBER_BASE(GuiControl)
				CLASS_MEMBER_BASE(GuiInstanceRootObject)
				CLASS_MEMBER_CONSTRUCTOR(GuiControlHost*(GuiControl::IStyleController*), {L"styleController"})

				CLASS_MEMBER_GUIEVENT(WindowGotFocus)
				CLASS_MEMBER_GUIEVENT(WindowLostFocus)
				CLASS_MEMBER_GUIEVENT(WindowActivated)
				CLASS_MEMBER_GUIEVENT(WindowDeactivated)
				CLASS_MEMBER_GUIEVENT(WindowOpened)
				CLASS_MEMBER_GUIEVENT(WindowClosing)
				CLASS_MEMBER_GUIEVENT(WindowClosed)
				CLASS_MEMBER_GUIEVENT(WindowDestroying)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(MainComposition)
				CLASS_MEMBER_PROPERTY_FAST(ShowInTaskBar)
				CLASS_MEMBER_PROPERTY_FAST(EnabledActivate)
				CLASS_MEMBER_PROPERTY_FAST(TopMost)
				CLASS_MEMBER_PROPERTY_FAST(ClientSize)
				CLASS_MEMBER_PROPERTY_FAST(Bounds)
				CLASS_MEMBER_PROPERTY_FAST(ShortcutKeyManager)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(AnimationManager)

				CLASS_MEMBER_METHOD(ForceCalculateSizeImmediately, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetFocused, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetFocused, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetActivated, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetActivated, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Show, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowDeactivated, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowRestored, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowMaximized, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowMinimized, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Hide, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Close, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetOpening, NO_PARAMETER)
			END_CLASS_MEMBER(GuiControlHost)

#undef _

/***********************************************************************
Type Loader
***********************************************************************/

			class GuiBasicTypeLoader : public Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					GUIREFLECTIONBASIC_TYPELIST(ADD_TYPE_INFO)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};

#endif

			bool LoadGuiBasicTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiBasicTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONCOMPOSITIONS.CPP
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			using namespace collections;
			using namespace parsing;
			using namespace parsing::tabling;
			using namespace parsing::xml;
			using namespace stream;

#ifndef VCZH_DEBUG_NO_REFLECTION

			GUIREFLECTIONCOMPOSITION_TYPELIST(IMPL_VL_TYPE_INFO)

/***********************************************************************
External Functions
***********************************************************************/

			void GuiTableComposition_SetRows(GuiTableComposition* thisObject, vint value)
			{
				vint columns=thisObject->GetColumns();
				if(columns<=0) columns=1;
				thisObject->SetRowsAndColumns(value, columns);
			}

			void GuiTableComposition_SetColumns(GuiTableComposition* thisObject, vint value)
			{
				vint row=thisObject->GetRows();
				if(row<=0) row=1;
				thisObject->SetRowsAndColumns(row, value);
			}

			void IGuiAltActionHost_CollectAltActions(IGuiAltActionHost* host, List<IGuiAltAction*>& actions)
			{
				Group<WString, IGuiAltAction*> group;
				host->CollectAltActions(group);
				for (vint i = 0; i < group.Count(); i++)
				{
					CopyFrom(actions, group.GetByIndex(i), true);
				}
			}

/***********************************************************************
Type Declaration
***********************************************************************/

#define _ ,

#define INTERFACE_EXTERNALCTOR(CONTROL, INTERFACE)\
	CLASS_MEMBER_EXTERNALCTOR(decltype(interface_proxy::CONTROL##_##INTERFACE::Create(0))(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::CONTROL##_##INTERFACE::Create)

#define INTERFACE_IDENTIFIER(INTERFACE)\
	CLASS_MEMBER_STATIC_EXTERNALMETHOD(GetIdentifier, NO_PARAMETER, WString(*)(), []()->WString{return INTERFACE::Identifier;})

			BEGIN_CLASS_MEMBER(GuiStackComposition)
				CLASS_MEMBER_BASE(GuiBoundsComposition)
				CLASS_MEMBER_CONSTRUCTOR(GuiStackComposition*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(StackItems)

				CLASS_MEMBER_PROPERTY_FAST(Direction)
				CLASS_MEMBER_PROPERTY_FAST(Padding)
				CLASS_MEMBER_PROPERTY_FAST(ExtraMargin)

				CLASS_MEMBER_METHOD(InsertStackItem, {L"index" _ L"item"})
				CLASS_MEMBER_METHOD(IsStackItemClipped, NO_PARAMETER)
				CLASS_MEMBER_METHOD(EnsureVisible, {L"index"})
			END_CLASS_MEMBER(GuiStackComposition)

			BEGIN_ENUM_ITEM(GuiStackComposition::Direction)
				ENUM_ITEM_NAMESPACE(GuiStackComposition)
				ENUM_NAMESPACE_ITEM(Horizontal)
				ENUM_NAMESPACE_ITEM(Vertical)
			END_ENUM_ITEM(GuiStackComposition::Direction)

			BEGIN_CLASS_MEMBER(GuiStackItemComposition)
				CLASS_MEMBER_BASE(GuiGraphicsSite)
				CLASS_MEMBER_CONSTRUCTOR(GuiStackItemComposition*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_EVENT_FAST(Bounds, BoundsChanged)
				CLASS_MEMBER_PROPERTY_FAST(ExtraMargin)
			END_CLASS_MEMBER(GuiStackItemComposition)

			BEGIN_STRUCT_MEMBER(GuiCellOption)
				STRUCT_MEMBER(composeType)
				STRUCT_MEMBER(absolute)
				STRUCT_MEMBER(percentage)
			END_STRUCT_MEMBER(GuiCellOption)

			BEGIN_ENUM_ITEM(GuiCellOption::ComposeType)
				ENUM_ITEM_NAMESPACE(GuiCellOption)
				ENUM_NAMESPACE_ITEM(Absolute)
				ENUM_NAMESPACE_ITEM(Percentage)
				ENUM_NAMESPACE_ITEM(MinSize)
			END_ENUM_ITEM(GuiCellOption::ComposeType)

			BEGIN_CLASS_MEMBER(GuiTableComposition)
				CLASS_MEMBER_BASE(GuiBoundsComposition)
				CLASS_MEMBER_CONSTRUCTOR(GuiTableComposition*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_FAST(CellPadding)

				CLASS_MEMBER_METHOD(GetRows, NO_PARAMETER)
				CLASS_MEMBER_EXTERNALMETHOD(SetRows, {L"value"}, void(GuiTableComposition::*)(vint), &GuiTableComposition_SetRows)
				CLASS_MEMBER_PROPERTY(Rows, GetRows, SetRows)
				CLASS_MEMBER_METHOD(GetColumns, NO_PARAMETER)
				CLASS_MEMBER_EXTERNALMETHOD(SetColumns, {L"value"}, void(GuiTableComposition::*)(vint), &GuiTableComposition_SetColumns)
				CLASS_MEMBER_PROPERTY(Columns, GetColumns, SetColumns)
				CLASS_MEMBER_METHOD(SetRowsAndColumns, {L"rows" _ L"columns"})

				CLASS_MEMBER_METHOD(GetSitedCell, {L"rows" _ L"columns"})
				CLASS_MEMBER_METHOD(GetRowOption, {L"row"})
				CLASS_MEMBER_METHOD(SetRowOption, {L"row" _ L"option"})
				CLASS_MEMBER_METHOD(GetColumnOption, {L"column"})
				CLASS_MEMBER_METHOD(SetColumnOption, {L"column" _ L"option"})
				CLASS_MEMBER_METHOD(GetCellArea, NO_PARAMETER)
				CLASS_MEMBER_METHOD(UpdateCellBounds, NO_PARAMETER)
			END_CLASS_MEMBER(GuiTableComposition)

			BEGIN_CLASS_MEMBER(GuiCellComposition)
				CLASS_MEMBER_BASE(GuiGraphicsSite)
				CLASS_MEMBER_CONSTRUCTOR(GuiCellComposition*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(TableParent)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Row)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RowSpan)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Column)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ColumnSpan)

				CLASS_MEMBER_METHOD(SetSite, {L"row" _ L"column" _ L"rowSpan" _ L"columnSpan"})
			END_CLASS_MEMBER(GuiCellComposition)

			BEGIN_CLASS_MEMBER(GuiSideAlignedComposition)
				CLASS_MEMBER_BASE(GuiGraphicsSite)
				CLASS_MEMBER_CONSTRUCTOR(GuiSideAlignedComposition*(), NO_PARAMETER)
				
				CLASS_MEMBER_PROPERTY_FAST(Direction)
				CLASS_MEMBER_PROPERTY_FAST(MaxLength)
				CLASS_MEMBER_PROPERTY_FAST(MaxRatio)
			END_CLASS_MEMBER(GuiSideAlignedComposition)

			BEGIN_ENUM_ITEM(GuiSideAlignedComposition::Direction)
				ENUM_ITEM_NAMESPACE(GuiSideAlignedComposition)
				ENUM_NAMESPACE_ITEM(Left)
				ENUM_NAMESPACE_ITEM(Top)
				ENUM_NAMESPACE_ITEM(Right)
				ENUM_NAMESPACE_ITEM(Bottom)
			END_ENUM_ITEM(GuiSideAlignedComposition::Direction)

			BEGIN_CLASS_MEMBER(GuiPartialViewComposition)
				CLASS_MEMBER_BASE(GuiGraphicsSite)
				CLASS_MEMBER_CONSTRUCTOR(GuiPartialViewComposition*(), NO_PARAMETER)
				
				CLASS_MEMBER_PROPERTY_FAST(WidthRatio)
				CLASS_MEMBER_PROPERTY_FAST(WidthPageSize)
				CLASS_MEMBER_PROPERTY_FAST(HeightRatio)
				CLASS_MEMBER_PROPERTY_FAST(HeightPageSize)
			END_CLASS_MEMBER(GuiPartialViewComposition)

			BEGIN_CLASS_MEMBER(GuiSharedSizeItemComposition)
				CLASS_MEMBER_BASE(GuiBoundsComposition)
				CLASS_MEMBER_CONSTRUCTOR(GuiSharedSizeItemComposition*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_FAST(Group)
				CLASS_MEMBER_PROPERTY_FAST(SharedWidth)
				CLASS_MEMBER_PROPERTY_FAST(SharedHeight)
			END_CLASS_MEMBER(GuiSubComponentMeasurer)

			BEGIN_CLASS_MEMBER(GuiSharedSizeRootComposition)
				CLASS_MEMBER_BASE(GuiBoundsComposition)
				CLASS_MEMBER_CONSTRUCTOR(GuiSharedSizeRootComposition*(), NO_PARAMETER)
			END_CLASS_MEMBER(GuiSubComponentMeasurerSource)

			BEGIN_CLASS_MEMBER(IGuiGraphicsAnimation)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(composition, IGuiGraphicsAnimation)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(TotalLength)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(CurrentPosition)

				CLASS_MEMBER_METHOD(Play, {L"currentPosition" _ L"totalLength"})
				CLASS_MEMBER_METHOD(Stop, NO_PARAMETER)
			END_CLASS_MEMBER(IGuiGraphicsAnimation)

			BEGIN_CLASS_MEMBER(GuiGraphicsAnimationManager)
				CLASS_MEMBER_METHOD(AddAnimation, {L"animation"})
				CLASS_MEMBER_METHOD(HasAnimation, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Play, NO_PARAMETER)
			END_CLASS_MEMBER(GuiGraphicsAnimationManager)

			BEGIN_CLASS_MEMBER(IGuiShortcutKeyItem)
				CLASS_MEMBER_BASE(IDescriptable)
				
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Manager)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Name)
			END_CLASS_MEMBER(IGuiShortcutKeyItem)

			BEGIN_CLASS_MEMBER(IGuiShortcutKeyManager)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ItemCount)

				CLASS_MEMBER_METHOD(GetItem, {L"index"})
			END_CLASS_MEMBER(IGuiShortcutKeyManager)

			BEGIN_CLASS_MEMBER(GuiShortcutKeyManager)
				CLASS_MEMBER_BASE(IGuiShortcutKeyManager)
				CLASS_MEMBER_CONSTRUCTOR(GuiShortcutKeyManager*(), NO_PARAMETER)

				CLASS_MEMBER_METHOD(CreateShortcut, {L"ctrl" _ L"shift" _ L"alt" _ L"ket"})
				CLASS_MEMBER_METHOD(DestroyShortcut, {L"ctrl" _ L"shift" _ L"alt" _ L"ket"})
				CLASS_MEMBER_METHOD(TryGetShortcut, {L"ctrl" _ L"shift" _ L"alt" _ L"ket"})
			END_CLASS_MEMBER(GuiShortcutKeyManager)

			BEGIN_CLASS_MEMBER(IGuiAltAction)
				INTERFACE_IDENTIFIER(IGuiAltAction)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Alt)

				CLASS_MEMBER_METHOD(IsAltEnabled, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsAltAvailable, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetAltComposition, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetActivatingAltHost, NO_PARAMETER)
				CLASS_MEMBER_METHOD(OnActiveAlt, NO_PARAMETER)
			END_CLASS_MEMBER(IGuiAltAction)

			BEGIN_CLASS_MEMBER(IGuiAltActionContainer)
				INTERFACE_IDENTIFIER(IGuiAltActionContainer)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(AltActionCount)
				
				CLASS_MEMBER_METHOD(GetAltAction, { L"index" })
			END_CLASS_MEMBER(IGuiAltActionContainer)

			BEGIN_CLASS_MEMBER(IGuiAltActionHost)
				INTERFACE_IDENTIFIER(IGuiAltActionHost)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(PreviousAltHost)

				CLASS_MEMBER_METHOD(OnActivatedAltHost, { L"previousHost" })
				CLASS_MEMBER_METHOD(OnDeactivatedAltHost, NO_PARAMETER)
				CLASS_MEMBER_EXTERNALMETHOD(CollectAltActions, {L"actions"}, void(IGuiAltActionHost::*)(List<IGuiAltAction*>&), &IGuiAltActionHost_CollectAltActions)
			END_CLASS_MEMBER(IGuiAltActionHost)

#undef INTERFACE_EXTERNALCTOR
#undef _

/***********************************************************************
Type Loader
***********************************************************************/

			class GuiCompositionTypeLoader : public Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					GUIREFLECTIONCOMPOSITION_TYPELIST(ADD_TYPE_INFO)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};

#endif

			bool LoadGuiCompositionTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiCompositionTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONCONTROLS.CPP
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			using namespace collections;
			using namespace parsing;
			using namespace parsing::tabling;
			using namespace parsing::definitions;
			using namespace parsing::analyzing;
			using namespace parsing::xml;
			using namespace stream;
			using namespace list;
			using namespace tree;
			using namespace text;
			using namespace theme;

#ifndef VCZH_DEBUG_NO_REFLECTION

			GUIREFLECTIONCONTROLS_TYPELIST(IMPL_VL_TYPE_INFO)

/***********************************************************************
External Functions
***********************************************************************/

			Ptr<ITheme> CreateWin7Theme()
			{
				return new win7::Win7Theme();
			}

			Ptr<ITheme> CreateWin8Theme()
			{
				return new win8::Win8Theme();
			}

			ListViewItemStyleProvider::IListViewItemContent* ListViewItemStyleProvider_GetItemContent(ListViewItemStyleProvider* thisObject, GuiListControl::IItemStyleController* itemStyleController)
			{
				return thisObject->GetItemContent<ListViewItemStyleProvider::IListViewItemContent>(itemStyleController);
			}

/***********************************************************************
Type Declaration
***********************************************************************/

#define _ ,

#define CONTROL_CONSTRUCTOR_CONTROLLER(CONTROL)\
	CLASS_MEMBER_CONSTRUCTOR(CONTROL*(CONTROL::IStyleController*), {L"styleController"})

#define CONTROL_CONSTRUCTOR_DEFAULT(CONTROL, CONSTRUCTOR)\
	CLASS_MEMBER_EXTERNALCTOR(CONTROL*(), NO_PARAMETER, CONSTRUCTOR)

#define CONTROL_CONSTRUCTOR_PROVIDER(CONTROL)\
	CLASS_MEMBER_CONSTRUCTOR(CONTROL*(CONTROL::IStyleProvider*), {L"styleProvider"})

#define INTERFACE_EXTERNALCTOR(CONTROL, INTERFACE)\
	CLASS_MEMBER_EXTERNALCTOR(decltype(interface_proxy::CONTROL##_##INTERFACE::Create(0))(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::CONTROL##_##INTERFACE::Create)

#define INTERFACE_IDENTIFIER(INTERFACE)\
	CLASS_MEMBER_STATIC_EXTERNALMETHOD(GetIdentifier, NO_PARAMETER, WString(*)(), []()->WString{return INTERFACE::Identifier;})

			BEGIN_CLASS_MEMBER(GuiApplication)
				CLASS_MEMBER_STATIC_EXTERNALMETHOD(GetApplication, NO_PARAMETER, GuiApplication*(*)(), &GetApplication)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(MainWindow)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(TooltipOwner)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ExecutablePath)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ExecutableFolder)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Windows)
				
				CLASS_MEMBER_METHOD(Run, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ShowTooltip, {L"owner" _ L"tooltip" _ L"preferredContentWidth" _ L"location"})
				CLASS_MEMBER_METHOD(CloseTooltip, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsInMainThread, NO_PARAMETER)
				CLASS_MEMBER_METHOD(InvokeAsync, {L"proc"})
				CLASS_MEMBER_METHOD(InvokeInMainThread, {L"proc"})
				CLASS_MEMBER_METHOD(InvokeInMainThreadAndWait, {L"proc" _ L"milliseconds"})
				CLASS_MEMBER_METHOD(DelayExecute, {L"proc" _ L"milliseconds"})
				CLASS_MEMBER_METHOD(DelayExecuteInMainThread, {L"proc" _ L"milliseconds"})
			END_CLASS_MEMBER(GuiApplication)

			BEGIN_CLASS_MEMBER(ITheme)
				CLASS_MEMBER_STATIC_EXTERNALMETHOD(GetCurrentTheme, NO_PARAMETER, ITheme*(*)(), &GetCurrentTheme)
				CLASS_MEMBER_STATIC_EXTERNALMETHOD(SetCurrentTheme, {L"theme"}, void(*)(ITheme*), &SetCurrentTheme)
				CLASS_MEMBER_STATIC_EXTERNALMETHOD(CreateWin7Theme, NO_PARAMETER, Ptr<ITheme>(*)(), &CreateWin7Theme)
				CLASS_MEMBER_STATIC_EXTERNALMETHOD(CreateWin8Theme, NO_PARAMETER, Ptr<ITheme>(*)(), &CreateWin8Theme)

				CLASS_MEMBER_METHOD(CreateWindowStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateTooltipStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateLabelStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateShortcutKeyStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateScrollContainerStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateGroupBoxStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateTabStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateComboBoxStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateMultilineTextBoxStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateTextBoxStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetDefaultTextBoxColorEntry, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateDocumentViewerStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateDocumentLabelStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateListViewStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateTreeViewStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateListItemBackgroundStyle, NO_PARAMETER)

				CLASS_MEMBER_METHOD(CreateMenuStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateMenuBarStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateMenuSplitterStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateMenuBarButtonStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateMenuItemButtonStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateToolBarStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateToolBarButtonStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateToolBarDropdownButtonStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateToolBarSplitButtonStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateToolBarSplitterStyle, NO_PARAMETER)

				CLASS_MEMBER_METHOD(CreateButtonStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateCheckBoxStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateRadioButtonStyle, NO_PARAMETER)

				CLASS_MEMBER_METHOD(CreateHScrollStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateVScrollStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateHTrackerStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateVTrackerStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateProgressBarStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetScrollDefaultSize, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetTrackerDefaultSize, NO_PARAMETER)

				CLASS_MEMBER_METHOD(CreateTextListStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateTextListItemStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateCheckTextListItemStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateRadioTextListItemStyle, NO_PARAMETER)
			END_CLASS_MEMBER(ITheme)

			BEGIN_CLASS_MEMBER(GuiInstanceRootObject)
				CLASS_MEMBER_METHOD(AddSubscription, {L"subscription"})
				CLASS_MEMBER_METHOD(RemoveSubscription, {L"subscription"})
				CLASS_MEMBER_METHOD(ContainsSubscription, {L"subscription"})

				CLASS_MEMBER_METHOD(AddComponent, {L"component"})
				CLASS_MEMBER_METHOD(RemoveComponent, {L"component"})
				CLASS_MEMBER_METHOD(ContainsComponent, {L"component"})
			END_CLASS_MEMBER(GuiInstanceRootObject)

			BEGIN_CLASS_MEMBER(GuiDialogBase)
				CLASS_MEMBER_BASE(GuiComponent)
			END_CLASS_MEMBER(GuiDialogBase)

			BEGIN_CLASS_MEMBER(GuiMessageDialog)
				CLASS_MEMBER_BASE(GuiDialogBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiMessageDialog*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_FAST(Input)
				CLASS_MEMBER_PROPERTY_FAST(DefaultButton)
				CLASS_MEMBER_PROPERTY_FAST(Icon)
				CLASS_MEMBER_PROPERTY_FAST(ModalOption)
				CLASS_MEMBER_PROPERTY_FAST(Text)
				CLASS_MEMBER_PROPERTY_FAST(Title)

				CLASS_MEMBER_METHOD(ShowDialog, NO_PARAMETER)
			END_CLASS_MEMBER(GuiMessageDialog)

			BEGIN_CLASS_MEMBER(GuiColorDialog)
				CLASS_MEMBER_BASE(GuiDialogBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiColorDialog*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_FAST(EnabledCustomColor)
				CLASS_MEMBER_PROPERTY_FAST(OpenedCustomColor)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SelectedColor)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(CustomColors)

				CLASS_MEMBER_METHOD(ShowDialog, NO_PARAMETER)
			END_CLASS_MEMBER(GuiColorDialog)

			BEGIN_CLASS_MEMBER(GuiFontDialog)
				CLASS_MEMBER_BASE(GuiDialogBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiFontDialog*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SelectedFont)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SelectedColor)
				CLASS_MEMBER_PROPERTY_FAST(ShowSelection)
				CLASS_MEMBER_PROPERTY_FAST(ShowEffect)
				CLASS_MEMBER_PROPERTY_FAST(ForceFontExist)

				CLASS_MEMBER_METHOD(ShowDialog, NO_PARAMETER)
			END_CLASS_MEMBER(GuiFontDialog)

			BEGIN_CLASS_MEMBER(GuiFileDialogBase)
				CLASS_MEMBER_BASE(GuiDialogBase)

				CLASS_MEMBER_PROPERTY_FAST(Filter)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(FilterIndex)
				CLASS_MEMBER_PROPERTY_FAST(EnabledPreview)
				CLASS_MEMBER_PROPERTY_FAST(Title)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(FileName)
				CLASS_MEMBER_PROPERTY_FAST(Directory)
				CLASS_MEMBER_PROPERTY_FAST(DefaultExtension)
				CLASS_MEMBER_PROPERTY_FAST(Options)
			END_CLASS_MEMBER(GuiFileDialogBase)

			BEGIN_CLASS_MEMBER(GuiOpenFileDialog)
				CLASS_MEMBER_BASE(GuiFileDialogBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiOpenFileDialog*(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(FileNames)
				CLASS_MEMBER_METHOD(ShowDialog, NO_PARAMETER)
			END_CLASS_MEMBER(GuiOpenFileDialog)

			BEGIN_CLASS_MEMBER(GuiSaveFileDialog)
				CLASS_MEMBER_BASE(GuiFileDialogBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiSaveFileDialog*(), NO_PARAMETER)
				
				CLASS_MEMBER_METHOD(ShowDialog, NO_PARAMETER)
			END_CLASS_MEMBER(GuiSaveFileDialog)

			BEGIN_CLASS_MEMBER(GuiCustomControl)
				CLASS_MEMBER_BASE(GuiControl)
				CLASS_MEMBER_BASE(GuiInstanceRootObject)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiCustomControl)
			END_CLASS_MEMBER(GuiCustomControl)

			BEGIN_CLASS_MEMBER(GuiLabel)
				CLASS_MEMBER_BASE(GuiControl)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiLabel)

				CLASS_MEMBER_PROPERTY_FAST(TextColor)
			END_CLASS_MEMBER(GuiLabel)

			BEGIN_CLASS_MEMBER(GuiLabel::IStyleController)
				CLASS_MEMBER_BASE(GuiControl::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiLabel, IStyleController)

				CLASS_MEMBER_METHOD(GetDefaultTextColor, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetTextColor, {L"value"})
			END_CLASS_MEMBER(GuiLabel::IStyleController)

			BEGIN_CLASS_MEMBER(GuiButton)
				CLASS_MEMBER_BASE(GuiControl)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiButton)

				CLASS_MEMBER_GUIEVENT(Clicked)

				CLASS_MEMBER_PROPERTY_FAST(ClickOnMouseUp)
			END_CLASS_MEMBER(GuiButton)

			BEGIN_ENUM_ITEM(GuiButton::ControlState)
				ENUM_ITEM_NAMESPACE(GuiButton)
				ENUM_NAMESPACE_ITEM(Normal)
				ENUM_NAMESPACE_ITEM(Active)
				ENUM_NAMESPACE_ITEM(Pressed)
			END_ENUM_ITEM(GuiButton::ControlState)

			BEGIN_CLASS_MEMBER(GuiButton::IStyleController)
				CLASS_MEMBER_BASE(GuiControl::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiButton, IStyleController)

				CLASS_MEMBER_METHOD(Transfer, {L"value"})
			END_CLASS_MEMBER(GuiButton::IStyleController)

			BEGIN_CLASS_MEMBER(GuiSelectableButton)
				CLASS_MEMBER_BASE(GuiButton)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiSelectableButton)

				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(GroupController)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(AutoSelection)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Selected)
			END_CLASS_MEMBER(GuiSelectableButton)

			BEGIN_CLASS_MEMBER(GuiSelectableButton::IStyleController)
				CLASS_MEMBER_BASE(GuiButton::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiSelectableButton, IStyleController)

				CLASS_MEMBER_METHOD(SetSelected, {L"value"})
			END_CLASS_MEMBER(GuiSelectableButton::IStyleController)

			BEGIN_CLASS_MEMBER(GuiSelectableButton::GroupController)
				CLASS_MEMBER_BASE(GuiComponent)

				CLASS_MEMBER_METHOD(Attach, {L"button"})
				CLASS_MEMBER_METHOD(Detach, {L"button"})
				CLASS_MEMBER_METHOD(OnSelectedChanged, {L"button"})
			END_CLASS_MEMBER(GuiSelectableButton::GroupController)

			BEGIN_CLASS_MEMBER(GuiSelectableButton::MutexGroupController)
				CLASS_MEMBER_BASE(GuiSelectableButton::GroupController)
				CLASS_MEMBER_CONSTRUCTOR(GuiSelectableButton::MutexGroupController*(), NO_PARAMETER)
			END_CLASS_MEMBER(GuiSelectableButton::MutexGroupController)

			BEGIN_CLASS_MEMBER(GuiScroll)
				CLASS_MEMBER_BASE(GuiControl)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiScroll)

				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(TotalSize)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(PageSize)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Position)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SmallMove)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(BigMove)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(MinPosition)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(MaxPosition)
			END_CLASS_MEMBER(GuiScroll)

			BEGIN_CLASS_MEMBER(GuiScroll::ICommandExecutor)
				CLASS_MEMBER_METHOD(SmallDecrease, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SmallIncrease, NO_PARAMETER)
				CLASS_MEMBER_METHOD(BigDecrease, NO_PARAMETER)
				CLASS_MEMBER_METHOD(BigIncrease, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetTotalSize, {L"value"})
				CLASS_MEMBER_METHOD(SetPageSize, {L"value"})
				CLASS_MEMBER_METHOD(SetPosition, {L"value"})
			END_CLASS_MEMBER(GuiScroll::ICommandExecutor)

			BEGIN_CLASS_MEMBER(GuiScroll::IStyleController)
				CLASS_MEMBER_BASE(GuiControl::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiScroll, IStyleController)

				CLASS_MEMBER_METHOD(SetCommandExecutor, {L"value"})
				CLASS_MEMBER_METHOD(SetTotalSize, {L"value"})
				CLASS_MEMBER_METHOD(SetPageSize, {L"value"})
				CLASS_MEMBER_METHOD(SetPosition, {L"value"})
			END_CLASS_MEMBER(GuiScroll::IStyleController)

			BEGIN_CLASS_MEMBER(GuiTabPage)
				CLASS_MEMBER_CONSTRUCTOR(GuiTabPage*(), NO_PARAMETER)
				CLASS_MEMBER_GUIEVENT(PageInstalled)
				CLASS_MEMBER_GUIEVENT(PageUninstalled)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ContainerComposition)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(OwnerTab)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Alt)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Text)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Selected)
			END_CLASS_MEMBER(GuiTabPage)

			BEGIN_CLASS_MEMBER(GuiTab)
				CLASS_MEMBER_BASE(GuiControl)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiTab)
				CONTROL_CONSTRUCTOR_DEFAULT(GuiTab, &g::NewTab)

				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SelectedPage)

				CLASS_MEMBER_METHOD_OVERLOAD(CreatePage, {L"index"}, GuiTabPage*(GuiTab::*)(vint))
				CLASS_MEMBER_METHOD_OVERLOAD(CreatePage, {L"page" _ L"index"}, bool(GuiTab::*)(GuiTabPage* _ vint))
				CLASS_MEMBER_METHOD(RemovePage, {L"value"})
				CLASS_MEMBER_METHOD(MovePage, {L"page" _ L"newIndex"})
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Pages)
			END_CLASS_MEMBER(GuiTab)

			BEGIN_CLASS_MEMBER(GuiTab::ICommandExecutor)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_METHOD(ShowTab, {L"index"})
			END_CLASS_MEMBER(GuiTab::ICommandExecutor)

			BEGIN_CLASS_MEMBER(GuiTab::IStyleController)
				CLASS_MEMBER_BASE(GuiControl::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiTab, IStyleController)

				CLASS_MEMBER_METHOD(SetCommandExecutor, {L"value"})
				CLASS_MEMBER_METHOD(InsertTab, {L"index"})
				CLASS_MEMBER_METHOD(SetTabText, {L"index" _ L"value"})
				CLASS_MEMBER_METHOD(RemoveTab, {L"index"})
				CLASS_MEMBER_METHOD(MoveTab, {L"oldIndex" _ L"newIndex"})
				CLASS_MEMBER_METHOD(SetSelectedTab, {L"index"})
				CLASS_MEMBER_METHOD(SetTabAlt, {L"index" _ L"value" _ L"host"})
				CLASS_MEMBER_METHOD(GetTabAltAction, {L"index"})
			END_CLASS_MEMBER(GuiTab::IStyleController)

			BEGIN_CLASS_MEMBER(GuiScrollView)
				CLASS_MEMBER_BASE(GuiControl)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ViewSize)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ViewBounds)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(HorizontalScroll)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(VerticalScroll)
				CLASS_MEMBER_PROPERTY_FAST(HorizontalAlwaysVisible)
				CLASS_MEMBER_PROPERTY_FAST(VerticalAlwaysVisible)

				CLASS_MEMBER_METHOD(CalculateView, NO_PARAMETER)
			END_CLASS_MEMBER(GuiScrollView)

			BEGIN_CLASS_MEMBER(GuiScrollView::IStyleProvider)
				CLASS_MEMBER_BASE(GuiControl::IStyleProvider)
				INTERFACE_EXTERNALCTOR(GuiScrollView, IStyleProvider)

				CLASS_MEMBER_METHOD(CreateHorizontalScrollStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateVerticalScrollStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetDefaultScrollSize, NO_PARAMETER)
				CLASS_MEMBER_METHOD(InstallBackground, {L"boundsComposition"})
			END_CLASS_MEMBER(GuiScrollView::IStyleProvider)

			BEGIN_CLASS_MEMBER(GuiScrollContainer)
				CLASS_MEMBER_BASE(GuiScrollView)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiScrollContainer)

				CLASS_MEMBER_PROPERTY_FAST(ExtendToFullWidth)
			END_CLASS_MEMBER(GuiScrollContainer)

			BEGIN_CLASS_MEMBER(GuiWindow)
				CLASS_MEMBER_BASE(GuiControlHost)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiWindow)

				CLASS_MEMBER_GUIEVENT(ClipboardUpdated)

				CLASS_MEMBER_PROPERTY_FAST(MaximizedBox)
				CLASS_MEMBER_PROPERTY_FAST(MinimizedBox)
				CLASS_MEMBER_PROPERTY_FAST(Border)
				CLASS_MEMBER_PROPERTY_FAST(SizeBox)
				CLASS_MEMBER_PROPERTY_FAST(IconVisible)
				CLASS_MEMBER_PROPERTY_FAST(TitleBar)

				CLASS_MEMBER_METHOD(MoveToScreenCenter, NO_PARAMETER)
			END_CLASS_MEMBER(GuiWindow)

			BEGIN_CLASS_MEMBER(GuiWindow::IStyleController)
				CLASS_MEMBER_BASE(GuiControl::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiWindow, IStyleController)

				CLASS_MEMBER_METHOD(AttachWindow, {L"window"})
				CLASS_MEMBER_METHOD(InitializeNativeWindowProperties, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetSizeState, {L"value"})

				CLASS_MEMBER_PROPERTY_FAST(MaximizedBox)
				CLASS_MEMBER_PROPERTY_FAST(MinimizedBox)
				CLASS_MEMBER_PROPERTY_FAST(Border)
				CLASS_MEMBER_PROPERTY_FAST(SizeBox)
				CLASS_MEMBER_PROPERTY_FAST(IconVisible)
				CLASS_MEMBER_PROPERTY_FAST(TitleBar)

				CLASS_MEMBER_METHOD(CreateTooltipStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateShortcutKeyStyle, NO_PARAMETER)
			END_CLASS_MEMBER(GuiWindow::IStyleController)

			BEGIN_CLASS_MEMBER(GuiPopup)
				CLASS_MEMBER_BASE(GuiWindow)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiPopup)

				CLASS_MEMBER_METHOD(IsClippedByScreen, {L"location"})
				CLASS_MEMBER_METHOD_OVERLOAD(ShowPopup, {L"location" _ L"screen"}, void(GuiPopup::*)(Point _ INativeScreen*))
				CLASS_MEMBER_METHOD_OVERLOAD(ShowPopup, {L"control" _ L"location"}, void(GuiPopup::*)(GuiControl* _ Point))
				CLASS_MEMBER_METHOD_OVERLOAD(ShowPopup, {L"control" _ L"preferredTopBottomSide"}, void(GuiPopup::*)(GuiControl* _ bool))
			END_CLASS_MEMBER(GuiPopup)

			BEGIN_CLASS_MEMBER(GuiTooltip)
				CLASS_MEMBER_BASE(GuiPopup)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiPopup)
				
				CLASS_MEMBER_PROPERTY_FAST(PreferredContentWidth)
				CLASS_MEMBER_PROPERTY_FAST(TemporaryContentControl)
			END_CLASS_MEMBER(GuiTooltip)

			BEGIN_CLASS_MEMBER(GuiListControl)
				CLASS_MEMBER_BASE(GuiScrollView)
				CLASS_MEMBER_CONSTRUCTOR(GuiListControl*(GuiListControl::IStyleProvider* _ GuiListControl::IItemProvider* _ bool), {L"styleProvider" _ L"itemProvider" _ L"acceptFocus"})

				CLASS_MEMBER_GUIEVENT(ItemLeftButtonDown)
				CLASS_MEMBER_GUIEVENT(ItemLeftButtonUp)
				CLASS_MEMBER_GUIEVENT(ItemLeftButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT(ItemMiddleButtonDown)
				CLASS_MEMBER_GUIEVENT(ItemMiddleButtonUp)
				CLASS_MEMBER_GUIEVENT(ItemMiddleButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT(ItemRightButtonDown)
				CLASS_MEMBER_GUIEVENT(ItemRightButtonUp)
				CLASS_MEMBER_GUIEVENT(ItemRightButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT(ItemMouseMove)
				CLASS_MEMBER_GUIEVENT(ItemMouseEnter)
				CLASS_MEMBER_GUIEVENT(ItemMouseLeave)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ItemProvider)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(StyleProvider)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Arranger)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(CoordinateTransformer)

				CLASS_MEMBER_METHOD(EnsureItemVisible, {L"itemIndex"})
			END_CLASS_MEMBER(GuiListControl)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemProviderCallback)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemProviderCallback)

				CLASS_MEMBER_METHOD(OnAttached, {L"provider"})
				CLASS_MEMBER_METHOD(OnItemModified, {L"start" _ L"count" _ L"newCount"})
			END_CLASS_MEMBER(GuiListControl::IItemProviderCallback)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemArrangerCallback)
				CLASS_MEMBER_BASE(IDescriptable)
				CLASS_MEMBER_METHOD(RequestItem, {L"itemIndex"})
				CLASS_MEMBER_METHOD(ReleaseItem, {L"style"})
				CLASS_MEMBER_METHOD(SetViewLocation, {L"value"})
				CLASS_MEMBER_METHOD(GetStylePreferredSize, {L"style"})
				CLASS_MEMBER_METHOD(SetStyleAlignmentToParent, {L"style" _ L"margin"})
				CLASS_MEMBER_METHOD(GetStyleBounds, {L"style"})
				CLASS_MEMBER_METHOD(SetStyleBounds, {L"style" _ L"bounds"})
				CLASS_MEMBER_METHOD(GetContainerComposition, NO_PARAMETER)
				CLASS_MEMBER_METHOD(OnTotalSizeChanged, NO_PARAMETER)
			END_CLASS_MEMBER(GuiListControl::IItemArrangerCallback)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemPrimaryTextView)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemPrimaryTextView)
				INTERFACE_IDENTIFIER(GuiListControl::IItemPrimaryTextView)

				CLASS_MEMBER_METHOD(GetPrimaryTextViewText, {L"itemIndex"})
				CLASS_MEMBER_METHOD(ContainsPrimaryText, {L"itemIndex"})
			END_CLASS_MEMBER(GuiListControl::IItemPrimaryTextView)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemBindingView)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemBindingView)
				INTERFACE_IDENTIFIER(GuiListControl::IItemBindingView)

				CLASS_MEMBER_METHOD(GetBindingValue, {L"itemIndex"})
			END_CLASS_MEMBER(GuiListControl::IItemBindingView)

			BEGIN_ENUM_ITEM(GuiListControl::KeyDirection)
				ENUM_ITEM_NAMESPACE(GuiListControl)
				ENUM_NAMESPACE_ITEM(Up)
				ENUM_NAMESPACE_ITEM(Down)
				ENUM_NAMESPACE_ITEM(Left)
				ENUM_NAMESPACE_ITEM(Right)
				ENUM_NAMESPACE_ITEM(Home)
				ENUM_NAMESPACE_ITEM(End)
				ENUM_NAMESPACE_ITEM(PageUp)
				ENUM_NAMESPACE_ITEM(PageDown)
				ENUM_NAMESPACE_ITEM(PageLeft)
				ENUM_NAMESPACE_ITEM(PageRight)
			END_ENUM_ITEM(GuiListControl::KeyDirection)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemProvider)

				CLASS_MEMBER_METHOD(AttachCallback, {L"value"})
				CLASS_MEMBER_METHOD(DetachCallback, {L"value"})
				CLASS_MEMBER_METHOD(Count, NO_PARAMETER)
				CLASS_MEMBER_METHOD(RequestView, {L"identifier"})
				CLASS_MEMBER_METHOD(ReleaseView, {L"view"})
			END_CLASS_MEMBER(GuiListControl::IItemProvider)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemStyleController)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(StyleProvider)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ItemStyleId)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(BoundsComposition)

				CLASS_MEMBER_METHOD(IsCacheable, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsInstalled, NO_PARAMETER)
				CLASS_MEMBER_METHOD(OnInstalled, NO_PARAMETER)
				CLASS_MEMBER_METHOD(OnUninstalled, NO_PARAMETER)
			END_CLASS_MEMBER(GuiListControl::IItemStyleController)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemStyleProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemStyleProvider)

				CLASS_MEMBER_METHOD(AttachListControl, {L"value"})
				CLASS_MEMBER_METHOD(DetachListControl, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetItemStyleId, {L"itemIndex"})
				CLASS_MEMBER_METHOD(CreateItemStyle, {L"styleId"})
				CLASS_MEMBER_METHOD(DestroyItemStyle, {L"style"})
				CLASS_MEMBER_METHOD(Install, {L"style" _ L"itemIndex"})
			END_CLASS_MEMBER(GuiListControl::IItemStyleProvider)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemArranger)
				CLASS_MEMBER_BASE(GuiListControl::IItemProviderCallback)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemArranger)

				CLASS_MEMBER_PROPERTY_FAST(Callback)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(TotalSize)
				
				CLASS_MEMBER_METHOD(AttachListControl, {L"value"})
				CLASS_MEMBER_METHOD(DetachListControl, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetVisibleStyle, {L"itemIndex"})
				CLASS_MEMBER_METHOD(GetVisibleIndex, {L"style"})
				CLASS_MEMBER_METHOD(OnViewChanged, {L"bounds"})
				CLASS_MEMBER_METHOD(FindItem, {L"itemIndex" _ L"key"})
				CLASS_MEMBER_METHOD(EnsureItemVisible, {L"itemIndex"})
			END_CLASS_MEMBER(GuiListControl::IItemArranger)

			BEGIN_CLASS_MEMBER(GuiListControl::IItemCoordinateTransformer)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(GuiListControl, IItemCoordinateTransformer)

				CLASS_MEMBER_METHOD(RealSizeToVirtualSize, {L"size"})
				CLASS_MEMBER_METHOD(VirtualSizeToRealSize, {L"size"})
				CLASS_MEMBER_METHOD(RealPointToVirtualPoint, {L"realFullSize" _ L"point"})
				CLASS_MEMBER_METHOD(VirtualPointToRealPoint, {L"realFullSize" _ L"point"})
				CLASS_MEMBER_METHOD(RealRectToVirtualRect, {L"realFullSize" _ L"rect"})
				CLASS_MEMBER_METHOD(VirtualRectToRealRect, {L"realFullSize" _ L"rect"})
				CLASS_MEMBER_METHOD(RealMarginToVirtualMargin, {L"margin"})
				CLASS_MEMBER_METHOD(VirtualMarginToRealMargin, {L"margin"})
				CLASS_MEMBER_METHOD(RealKeyDirectionToVirtualKeyDirection, {L"key"})
			END_CLASS_MEMBER(GuiListControl::IItemCoordinateTransformer)

			BEGIN_CLASS_MEMBER(GuiSelectableListControl)
				CLASS_MEMBER_BASE(GuiListControl)
				CLASS_MEMBER_CONSTRUCTOR(GuiSelectableListControl*(GuiSelectableListControl::IStyleProvider* _ GuiSelectableListControl::IItemProvider*), {L"styleProvider" _ L"itemProvider"})

				CLASS_MEMBER_GUIEVENT(SelectionChanged)

				CLASS_MEMBER_PROPERTY_FAST(MultiSelect)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItems, SelectionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItemIndex, SelectionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItemText, SelectionChanged)

				CLASS_MEMBER_METHOD(GetSelected, {L"itemIndex"})
				CLASS_MEMBER_METHOD(SetSelected, {L"itemIndex" _ L"value"})
				CLASS_MEMBER_METHOD(SelectItemsByClick, {L"itemIndex" _ L"ctrl" _ L"shift" _ L"leftButton"})
				CLASS_MEMBER_METHOD(SelectItemsByKey, {L"code" _ L"ctrl" _ L"shift"})
				CLASS_MEMBER_METHOD(ClearSelection, NO_PARAMETER)
			END_CLASS_MEMBER(GuiSelectableListControl)

			BEGIN_CLASS_MEMBER(GuiSelectableListControl::IItemStyleProvider)
				CLASS_MEMBER_BASE(GuiListControl::IItemStyleProvider)
				INTERFACE_EXTERNALCTOR(GuiSelectableListControl, IItemStyleProvider)

				CLASS_MEMBER_METHOD(SetStyleSelected, {L"style" _ L"value"})
			END_CLASS_MEMBER(GuiSelectableListControl::IItemStyleProvider)

			BEGIN_CLASS_MEMBER(DefaultItemCoordinateTransformer)
				CLASS_MEMBER_BASE(GuiListControl::IItemCoordinateTransformer)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DefaultItemCoordinateTransformer>(), NO_PARAMETER)
			END_CLASS_MEMBER(DefaultItemCoordinateTransformer)

			BEGIN_CLASS_MEMBER(AxisAlignedItemCoordinateTransformer)
				CLASS_MEMBER_BASE(GuiListControl::IItemCoordinateTransformer)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<AxisAlignedItemCoordinateTransformer>(AxisAlignedItemCoordinateTransformer::Alignment), {L"alignment"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Alignment)
			END_CLASS_MEMBER(AxisAlignedItemCoordinateTransformer)

			BEGIN_ENUM_ITEM(AxisAlignedItemCoordinateTransformer::Alignment)
				ENUM_ITEM_NAMESPACE(AxisAlignedItemCoordinateTransformer)
				ENUM_NAMESPACE_ITEM(LeftDown)
				ENUM_NAMESPACE_ITEM(RightDown)
				ENUM_NAMESPACE_ITEM(LeftUp)
				ENUM_NAMESPACE_ITEM(RightUp)
				ENUM_NAMESPACE_ITEM(DownLeft)
				ENUM_NAMESPACE_ITEM(DownRight)
				ENUM_NAMESPACE_ITEM(UpLeft)
				ENUM_NAMESPACE_ITEM(UpRight)
			END_ENUM_ITEM(AxisAlignedItemCoordinateTransformer::Alignment)

			BEGIN_CLASS_MEMBER(RangedItemArrangerBase)
				CLASS_MEMBER_BASE(GuiListControl::IItemArranger)
			END_CLASS_MEMBER(RangedItemArrangerBase)

			BEGIN_CLASS_MEMBER(FixedHeightItemArranger)
				CLASS_MEMBER_BASE(RangedItemArrangerBase)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<FixedHeightItemArranger>(), NO_PARAMETER)
			END_CLASS_MEMBER(FixedHeightItemArranger)

			BEGIN_CLASS_MEMBER(FixedSizeMultiColumnItemArranger)
				CLASS_MEMBER_BASE(RangedItemArrangerBase)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<FixedSizeMultiColumnItemArranger>(), NO_PARAMETER)
			END_CLASS_MEMBER(FixedSizeMultiColumnItemArranger)

			BEGIN_CLASS_MEMBER(FixedHeightMultiColumnItemArranger)
				CLASS_MEMBER_BASE(RangedItemArrangerBase)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<FixedHeightMultiColumnItemArranger>(), NO_PARAMETER)
			END_CLASS_MEMBER(FixedHeightMultiColumnItemArranger)

			BEGIN_CLASS_MEMBER(ItemStyleControllerBase)
				CLASS_MEMBER_BASE(GuiListControl::IItemStyleController)
			END_CLASS_MEMBER(ItemStyleControllerBase)

			BEGIN_CLASS_MEMBER(TextItemStyleProvider)
				CLASS_MEMBER_BASE(GuiSelectableListControl::IItemStyleProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TextItemStyleProvider>(TextItemStyleProvider::ITextItemStyleProvider*), {L"textItemStyleProvider"})
			END_CLASS_MEMBER(TextItemStyleProvider)

			BEGIN_CLASS_MEMBER(TextItemStyleProvider::ITextItemStyleProvider)
				INTERFACE_EXTERNALCTOR(TextItemStyleProvider, ITextItemStyleProvider)

				CLASS_MEMBER_METHOD(CreateBackgroundStyleController, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateBulletStyleController, NO_PARAMETER)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(TextColor)
			END_CLASS_MEMBER(TextItemStyleProvider::ITextItemStyleProvider)

			BEGIN_CLASS_MEMBER(TextItemStyleProvider::ITextItemView)
				CLASS_MEMBER_BASE(GuiListControl::IItemPrimaryTextView)
				INTERFACE_EXTERNALCTOR(TextItemStyleProvider, ITextItemView)
				INTERFACE_IDENTIFIER(TextItemStyleProvider::ITextItemView)

				CLASS_MEMBER_METHOD(GetText, {L"itemIndex"})
				CLASS_MEMBER_METHOD(GetChecked, {L"itemIndex"})
				CLASS_MEMBER_METHOD(SetCheckedSilently, {L"itemIndex" _ L"value"})
			END_CLASS_MEMBER(TextItemStyleProvider::ITextItemView)

			BEGIN_CLASS_MEMBER(TextItemStyleProvider::TextItemStyleController)
				CLASS_MEMBER_BASE(ItemStyleControllerBase)
				CLASS_MEMBER_CONSTRUCTOR(TextItemStyleProvider::TextItemStyleController*(TextItemStyleProvider*), {L"provider"})

				CLASS_MEMBER_PROPERTY_FAST(Selected)
				CLASS_MEMBER_PROPERTY_FAST(Checked)
				CLASS_MEMBER_PROPERTY_FAST(Text)
			END_CLASS_MEMBER(TextItemStyleProvider::TextItemStyleController)

			BEGIN_CLASS_MEMBER(TextItem)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TextItem>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TextItem>(const WString&), {L"text"})
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TextItem>(const WString&, bool), {L"text" _ L"checked"})

				CLASS_MEMBER_PROPERTY_FAST(Text)
				CLASS_MEMBER_PROPERTY_FAST(Checked)
			END_CLASS_MEMBER(TextItem)

			BEGIN_CLASS_MEMBER(GuiVirtualTextList)
				CLASS_MEMBER_BASE(GuiSelectableListControl)
				CLASS_MEMBER_CONSTRUCTOR(GuiVirtualTextList*(GuiSelectableListControl::IStyleProvider* _ TextItemStyleProvider::ITextItemStyleProvider* _ GuiListControl::IItemProvider*), {L"styleProvider" _ L"itemStyleProvider" _ L"itemProvider"})

				CLASS_MEMBER_GUIEVENT(ItemChecked)

				CLASS_MEMBER_METHOD(ChangeItemStyle, {L"itemStyleProvider"})
			END_CLASS_MEMBER(GuiVirtualTextList)

			BEGIN_CLASS_MEMBER(GuiTextList)
				CLASS_MEMBER_BASE(GuiVirtualTextList)
				CLASS_MEMBER_CONSTRUCTOR(GuiTextList*(GuiSelectableListControl::IStyleProvider* _ TextItemStyleProvider::ITextItemStyleProvider*), {L"styleProvider" _ L"itemStyleProvider"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Items)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItem, SelectionChanged)
			END_CLASS_MEMBER(GuiTextList)

			BEGIN_CLASS_MEMBER(ListViewItemStyleProviderBase)
				CLASS_MEMBER_BASE(GuiSelectableListControl::IItemStyleProvider)
			END_CLASS_MEMBER(ListViewItemStyleProviderBase)

			BEGIN_CLASS_MEMBER(ListViewItemStyleProviderBase::ListViewItemStyleController)
				CLASS_MEMBER_BASE(ItemStyleControllerBase)
				CLASS_MEMBER_CONSTRUCTOR(ListViewItemStyleProviderBase::ListViewItemStyleController*(ListViewItemStyleProviderBase*), {L"provider"})

				CLASS_MEMBER_PROPERTY_FAST(Selected)
			END_CLASS_MEMBER(ListViewItemStyleProviderBase::ListViewItemStyleController)

			BEGIN_CLASS_MEMBER(GuiListViewColumnHeader)
				CLASS_MEMBER_BASE(GuiMenuButton)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiListViewColumnHeader)

				CLASS_MEMBER_PROPERTY_FAST(ColumnSortingState)
			END_CLASS_MEMBER(GuiListViewColumnHeader)

			BEGIN_ENUM_ITEM(GuiListViewColumnHeader::ColumnSortingState)
				ENUM_ITEM_NAMESPACE(GuiListViewColumnHeader)
				ENUM_NAMESPACE_ITEM(NotSorted)
				ENUM_NAMESPACE_ITEM(Ascending)
				ENUM_NAMESPACE_ITEM(Descending)
			END_ENUM_ITEM(GuiListViewColumnHeader::ColumnSortingState)

			BEGIN_CLASS_MEMBER(GuiListViewColumnHeader::IStyleController)
				CLASS_MEMBER_BASE(GuiMenuButton::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiListViewColumnHeader, IStyleController)

				CLASS_MEMBER_METHOD(SetColumnSortingState, {L"value"})
			END_CLASS_MEMBER(GuiListViewColumnHeader::IStyleController)

			BEGIN_CLASS_MEMBER(GuiListViewBase)
				CLASS_MEMBER_BASE(GuiSelectableListControl)
				CLASS_MEMBER_CONSTRUCTOR(GuiListViewBase*(GuiListViewBase::IStyleProvider* _ GuiListControl::IItemProvider*), {L"styleProvider" _ L"itemProvider"})

				CLASS_MEMBER_GUIEVENT(ColumnClicked)

				CLASS_MEMBER_METHOD(GetListViewStyleProvider, NO_PARAMETER)
			END_CLASS_MEMBER(GuiListViewBase)

			BEGIN_CLASS_MEMBER(GuiListViewBase::IStyleProvider)
				CLASS_MEMBER_BASE(GuiSelectableListControl::IStyleProvider)
				INTERFACE_EXTERNALCTOR(GuiListViewBase, IStyleProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(PrimaryTextColor)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SecondaryTextColor)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ItemSeparatorColor)

				CLASS_MEMBER_METHOD(CreateItemBackground, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateColumnStyle, NO_PARAMETER)
			END_CLASS_MEMBER(GuiListViewBase::IStyleProvider)

			BEGIN_CLASS_MEMBER(ListViewItemStyleProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProviderBase)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewItemStyleProvider>(Ptr<ListViewItemStyleProvider::IListViewItemContentProvider>), {L"itemContentProvider"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ItemContentProvider)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(CreatedItemStyles)

				CLASS_MEMBER_METHOD(IsItemStyleAttachedToListView, {L"itemStyle"})
				CLASS_MEMBER_METHOD(GetItemContentFromItemStyleController, {L"itemStyleController"})
				CLASS_MEMBER_METHOD(GetItemStyleControllerFromItemContent, {L"itemContent"})
				CLASS_MEMBER_EXTERNALMETHOD(GetItemContent, {L"itemStyleController"}, ListViewItemStyleProvider::IListViewItemContent*(ListViewItemStyleProvider::*)(GuiListControl::IItemStyleController*), &ListViewItemStyleProvider_GetItemContent)
			END_CLASS_MEMBER(ListViewItemStyleProvider)

			BEGIN_CLASS_MEMBER(ListViewItemStyleProvider::IListViewItemView)
				CLASS_MEMBER_BASE(GuiListControl::IItemPrimaryTextView)
				INTERFACE_EXTERNALCTOR(ListViewItemStyleProvider, IListViewItemView)
				INTERFACE_IDENTIFIER(ListViewItemStyleProvider::IListViewItemView)

				CLASS_MEMBER_METHOD(GetSmallImage, {L"itemIndex"})
				CLASS_MEMBER_METHOD(GetLargeImage, {L"itemIndex"})
				CLASS_MEMBER_METHOD(GetText, {L"itemIndex"})
				CLASS_MEMBER_METHOD(GetSubItem, {L"itemIndex" _ L"index"})
				CLASS_MEMBER_METHOD(GetDataColumnCount, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetDataColumn, {L"index"})
				CLASS_MEMBER_METHOD(GetColumnCount, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetColumnText, {L"index"})
			END_CLASS_MEMBER(ListViewItemStyleProvider::IListViewItemView)

			BEGIN_CLASS_MEMBER(ListViewItemStyleProvider::IListViewItemContent)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(ListViewItemStyleProvider, IListViewItemContent)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ContentComposition)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(BackgroundDecorator)
				
				CLASS_MEMBER_METHOD(Install, {L"styleProvider" _ L"view" _ L"itemIndex"})
			END_CLASS_MEMBER(ListViewItemStyleProvider::IListViewItemContent)

			BEGIN_CLASS_MEMBER(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(ListViewItemStyleProvider, IListViewItemContentProvider)

				CLASS_MEMBER_METHOD(CreatePreferredCoordinateTransformer, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreatePreferredArranger, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateItemContent, {L"font"})
				CLASS_MEMBER_METHOD(AttachListControl, {L"value"})
				CLASS_MEMBER_METHOD(DetachListControl, NO_PARAMETER)
			END_CLASS_MEMBER(ListViewItemStyleProvider::IListViewItemContentProvider)

			BEGIN_CLASS_MEMBER(ListViewItemStyleProvider::ListViewContentItemStyleController)
				CLASS_MEMBER_BASE(ListViewItemStyleProviderBase::ListViewItemStyleController)
				CLASS_MEMBER_CONSTRUCTOR(ListViewItemStyleProvider::ListViewContentItemStyleController*(ListViewItemStyleProvider*), {L"provider"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ItemContent)

				CLASS_MEMBER_METHOD(Install, {L"view" _ L"itemIndex"})
			END_CLASS_MEMBER(ListViewItemStyleProvider::ListViewContentItemStyleController)

			BEGIN_CLASS_MEMBER(ListViewBigIconContentProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewBigIconContentProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewBigIconContentProvider>(Size, bool), {L"minIconSize" _ L"fitImage"})
			END_CLASS_MEMBER(ListViewBigIconContentProvider)

			BEGIN_CLASS_MEMBER(ListViewSmallIconContentProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewSmallIconContentProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewSmallIconContentProvider>(Size, bool), {L"minIconSize" _ L"fitImage"})
			END_CLASS_MEMBER(ListViewSmallIconContentProvider)

			BEGIN_CLASS_MEMBER(ListViewListContentProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewListContentProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewListContentProvider>(Size, bool), {L"minIconSize" _ L"fitImage"})
			END_CLASS_MEMBER(ListViewListContentProvider)

			BEGIN_CLASS_MEMBER(ListViewTileContentProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewTileContentProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewTileContentProvider>(Size, bool), {L"minIconSize" _ L"fitImage"})
			END_CLASS_MEMBER(ListViewTileContentProvider)

			BEGIN_CLASS_MEMBER(ListViewInformationContentProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewInformationContentProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewInformationContentProvider>(Size, bool), {L"minIconSize" _ L"fitImage"})
			END_CLASS_MEMBER(ListViewInformationContentProvider)

			BEGIN_CLASS_MEMBER(ListViewColumnItemArranger)
				CLASS_MEMBER_BASE(FixedHeightItemArranger)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewColumnItemArranger>(), NO_PARAMETER)
			END_CLASS_MEMBER(ListViewColumnItemArranger)

			BEGIN_CLASS_MEMBER(ListViewColumnItemArranger::IColumnItemViewCallback)
				CLASS_MEMBER_METHOD(OnColumnChanged, NO_PARAMETER)
			END_CLASS_MEMBER(ListViewColumnItemArranger::IColumnItemViewCallback)

			BEGIN_CLASS_MEMBER(ListViewColumnItemArranger::IColumnItemView)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(ListViewColumnItemArranger, IColumnItemView)
				INTERFACE_IDENTIFIER(ListViewColumnItemArranger::IColumnItemView)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ColumnCount)

				CLASS_MEMBER_METHOD(AttachCallback, {L"value"})
				CLASS_MEMBER_METHOD(DetachCallback, {L"value"})
				CLASS_MEMBER_METHOD(GetColumnText, {L"index"})
				CLASS_MEMBER_METHOD(GetColumnSize, {L"index"})
				CLASS_MEMBER_METHOD(SetColumnSize, {L"index" _ L"value"})
				CLASS_MEMBER_METHOD(GetDropdownPopup, {L"index"})
				CLASS_MEMBER_METHOD(GetSortingState, {L"index"})
			END_CLASS_MEMBER(ListViewColumnItemArranger::IColumnItemView)

			BEGIN_CLASS_MEMBER(ListViewDetailContentProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewDetailContentProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewDetailContentProvider>(Size, bool), {L"minIconSize" _ L"fitImage"})
			END_CLASS_MEMBER(ListViewDetailContentProvider)

			BEGIN_CLASS_MEMBER(ListViewItem)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewItem>(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_FAST(SmallImage)
				CLASS_MEMBER_PROPERTY_FAST(LargeImage)
				CLASS_MEMBER_PROPERTY_FAST(Text)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SubItems)
				CLASS_MEMBER_PROPERTY_FAST(Tag)
			END_CLASS_MEMBER(ListViewItem)

			BEGIN_CLASS_MEMBER(ListViewColumn)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewColumn>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewColumn>(const WString&), {L"text"})
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewColumn>(const WString&, vint), {L"text" _ L"size"})

				CLASS_MEMBER_PROPERTY_FAST(Text)
				CLASS_MEMBER_PROPERTY_FAST(TextProperty)
				CLASS_MEMBER_PROPERTY_FAST(Size)
				CLASS_MEMBER_PROPERTY_FAST(DropdownPopup)
				CLASS_MEMBER_PROPERTY_FAST(SortingState)
			END_CLASS_MEMBER(ListViewColumn)

			BEGIN_CLASS_MEMBER(GuiVirtualListView)
				CLASS_MEMBER_BASE(GuiListViewBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiVirtualListView*(GuiVirtualListView::IStyleProvider* _ GuiListControl::IItemProvider*), {L"styleProvider" _ L"itemProvider"})

				CLASS_MEMBER_METHOD(ChangeItemStyle, {L"contentProvider"})
			END_CLASS_MEMBER(GuiVirtualListView)

			BEGIN_CLASS_MEMBER(GuiListView)
				CLASS_MEMBER_BASE(GuiVirtualListView)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiListView)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(DataColumns)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Columns)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Items)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItem, SelectionChanged)
			END_CLASS_MEMBER(GuiListView)

			BEGIN_CLASS_MEMBER(IGuiMenuService)
				INTERFACE_IDENTIFIER(IGuiMenuService)

				CLASS_MEMBER_METHOD(GetParentMenuService, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetPreferredDirection, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsActiveState, NO_PARAMETER)
				CLASS_MEMBER_METHOD(IsSubMenuActivatedByMouseDown, NO_PARAMETER)
				CLASS_MEMBER_METHOD(MenuItemExecuted, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetOpeningMenu, NO_PARAMETER)
				CLASS_MEMBER_METHOD(MenuOpened, {L"menu"})
				CLASS_MEMBER_METHOD(MenuClosed, {L"menu"})
			END_CLASS_MEMBER(IGuiMenuService)

			BEGIN_ENUM_ITEM(IGuiMenuService::Direction)
				ENUM_ITEM_NAMESPACE(IGuiMenuService)
				ENUM_NAMESPACE_ITEM(Horizontal)
				ENUM_NAMESPACE_ITEM(Vertical)
			END_ENUM_ITEM(IGuiMenuService::Direction)

			BEGIN_CLASS_MEMBER(GuiMenu)
				CLASS_MEMBER_BASE(GuiPopup)
				CLASS_MEMBER_CONSTRUCTOR(GuiMenu*(GuiMenu::IStyleController* _ GuiControl*), {L"styleController" _ L"owner"})

				CLASS_MEMBER_METHOD(UpdateMenuService, NO_PARAMETER)
				CLASS_MEMBER_METHOD(QueryService, {L"identifier"})
			END_CLASS_MEMBER(GuiMenu)

			BEGIN_CLASS_MEMBER(GuiMenuBar)
				CLASS_MEMBER_BASE(GuiControl)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiMenuBar)
			END_CLASS_MEMBER(GuiMenuBar)

			BEGIN_CLASS_MEMBER(GuiMenuButton)
				CLASS_MEMBER_BASE(GuiSelectableButton)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiMenuButton)

				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(Image)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(ShortcutText)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SubMenu)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(OwnedSubMenu)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SubMenuOpening)
				CLASS_MEMBER_PROPERTY_FAST(PreferredMenuClientSize)
				CLASS_MEMBER_PROPERTY_FAST(CascadeAction)

				CLASS_MEMBER_METHOD(IsSubMenuExists, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateSubMenu, {L"subMenuStyleController"})
				CLASS_MEMBER_METHOD(SetSubMenu, {L"value" _ L"owned"})
			END_CLASS_MEMBER(GuiMenuButton)

			BEGIN_CLASS_MEMBER(GuiMenuButton::IStyleController)
				CLASS_MEMBER_BASE(GuiSelectableButton::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiMenuButton, IStyleController)

				CLASS_MEMBER_METHOD(CreateSubMenuStyleController, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetSubMenuExisting, {L"value"})
				CLASS_MEMBER_METHOD(SetSubMenuOpening, {L"value"})
				CLASS_MEMBER_METHOD(GetSubMenuHost, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetImage, {L"value"})
				CLASS_MEMBER_METHOD(SetShortcutText, {L"value"})
			END_CLASS_MEMBER(GuiMenuButton::IStyleController)

			BEGIN_CLASS_MEMBER(INodeProviderCallback)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_METHOD(OnAttached, {L"provider"})
				CLASS_MEMBER_METHOD(OnBeforeItemModified, {L"parentNode" _ L"start" _ L"count" _ L"newCount"})
				CLASS_MEMBER_METHOD(OnAfterItemModified, {L"parentNode" _ L"start" _ L"count" _ L"newCount"})
				CLASS_MEMBER_METHOD(OnItemExpanded, {L"node"})
				CLASS_MEMBER_METHOD(OnItemCollapsed, {L"node"})
			END_CLASS_MEMBER(INodeProviderCallback)

			BEGIN_CLASS_MEMBER(INodeProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(tree, INodeProvider)

				CLASS_MEMBER_PROPERTY_FAST(Expanding)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ChildCount)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Parent)

				CLASS_MEMBER_METHOD(CalculateTotalVisibleNodes, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetChild, {L"index"})
				CLASS_MEMBER_METHOD(Increase, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Release, NO_PARAMETER)
			END_CLASS_MEMBER(INodeProvider)

			BEGIN_CLASS_MEMBER(INodeRootProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(tree, INodeRootProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(RootNode)

				CLASS_MEMBER_METHOD(CanGetNodeByVisibleIndex, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetNodeByVisibleIndex, {L"index"})
				CLASS_MEMBER_METHOD(AttachCallback, {L"value"})
				CLASS_MEMBER_METHOD(DetachCallback, {L"value"})
				CLASS_MEMBER_METHOD(RequestView, {L"identifier"})
				CLASS_MEMBER_METHOD(ReleaseView, {L"value"})
			END_CLASS_MEMBER(INodeRootProvider)

			BEGIN_CLASS_MEMBER(INodeItemView)
				CLASS_MEMBER_BASE(GuiListControl::IItemPrimaryTextView)
				INTERFACE_EXTERNALCTOR(tree, INodeItemView)
				INTERFACE_IDENTIFIER(INodeItemView)

				CLASS_MEMBER_METHOD(RequestNode, {L"index"})
				CLASS_MEMBER_METHOD(ReleaseNode, {L"node"})
				CLASS_MEMBER_METHOD(CalculateNodeVisibilityIndex, {L"node"})
			END_CLASS_MEMBER(INodeItemView)

			BEGIN_CLASS_MEMBER(INodeItemPrimaryTextView)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(tree, INodeItemPrimaryTextView)
				INTERFACE_IDENTIFIER(INodeItemPrimaryTextView)

				CLASS_MEMBER_METHOD(GetPrimaryTextViewText, {L"node"})
			END_CLASS_MEMBER(INodeItemPrimaryTextView)

			BEGIN_CLASS_MEMBER(INodeItemBindingView)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(tree, INodeItemBindingView)
				INTERFACE_IDENTIFIER(INodeItemBindingView)

				CLASS_MEMBER_METHOD(GetBindingValue, {L"node"})
			END_CLASS_MEMBER(INodeItemBindingView)

			BEGIN_CLASS_MEMBER(INodeItemStyleController)
				CLASS_MEMBER_BASE(GuiListControl::IItemStyleController)
				INTERFACE_EXTERNALCTOR(tree, INodeItemStyleController)

				CLASS_MEMBER_METHOD(GetNodeStyleProvider, NO_PARAMETER)
			END_CLASS_MEMBER(INodeItemStyleController)

			BEGIN_CLASS_MEMBER(INodeItemStyleProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(tree, INodeItemStyleProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(BindedItemStyleProvider)

				CLASS_MEMBER_METHOD(BindItemStyleProvider, {L"styleProvider"})
				CLASS_MEMBER_METHOD(AttachListControl, {L"value"})
				CLASS_MEMBER_METHOD(DetachListControl, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetItemStyleId, {L"node"})
				CLASS_MEMBER_METHOD(CreateItemStyle, {L"styleId"})
				CLASS_MEMBER_METHOD(DestroyItemStyle, {L"style"})
				CLASS_MEMBER_METHOD(Install, {L"style" _ L"node" _ L"index"})
				CLASS_MEMBER_METHOD(SetStyleIndex, {L"style" _ L"value"})
				CLASS_MEMBER_METHOD(SetStyleSelected, {L"style" _ L"value"})
			END_CLASS_MEMBER(INodeItemStyleProvider)

			BEGIN_CLASS_MEMBER(NodeItemStyleProvider)
				CLASS_MEMBER_BASE(GuiSelectableListControl::IItemStyleProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<NodeItemStyleProvider>(Ptr<INodeItemStyleProvider>), {L"provider"})
			END_CLASS_MEMBER(NodeItemStyleProvider)

			BEGIN_CLASS_MEMBER(IMemoryNodeData)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(tree, IMemoryNodeData)
			END_CLASS_MEMBER(IMemoryNodeData)

			BEGIN_CLASS_MEMBER(MemoryNodeProvider)
				CLASS_MEMBER_BASE(INodeProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<MemoryNodeProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<MemoryNodeProvider>(Ptr<IMemoryNodeData>), {L"data"})

				CLASS_MEMBER_PROPERTY_FAST(Data)

				CLASS_MEMBER_METHOD(NotifyDataModified, NO_PARAMETER)
				CLASS_MEMBER_METHOD_RENAME(GetChildren, Children, NO_PARAMETER)
				CLASS_MEMBER_PROPERTY_READONLY(Children, GetChildren)
			END_CLASS_MEMBER(MemoryNodeProvider)

			BEGIN_CLASS_MEMBER(NodeRootProviderBase)
				CLASS_MEMBER_BASE(INodeRootProvider)
			END_CLASS_MEMBER(NodeRootProviderBase)

			BEGIN_CLASS_MEMBER(MemoryNodeRootProvider)
				CLASS_MEMBER_BASE(MemoryNodeProvider)
				CLASS_MEMBER_BASE(NodeRootProviderBase)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<MemoryNodeRootProvider>(), NO_PARAMETER)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(RootNode)

				CLASS_MEMBER_METHOD(GetMemoryNode, {L"node"})
			END_CLASS_MEMBER(MemoryNodeRootProvider)

			BEGIN_CLASS_MEMBER(GuiVirtualTreeListControl)
				CLASS_MEMBER_BASE(GuiSelectableListControl)
				CLASS_MEMBER_CONSTRUCTOR(GuiVirtualTreeListControl*(GuiVirtualTreeListControl::IStyleProvider* _ Ptr<INodeRootProvider>), {L"styleProvider" _ L"rootNodeProvider"})

				CLASS_MEMBER_GUIEVENT(NodeLeftButtonDown)
				CLASS_MEMBER_GUIEVENT(NodeLeftButtonUp)
				CLASS_MEMBER_GUIEVENT(NodeLeftButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT(NodeMiddleButtonDown)
				CLASS_MEMBER_GUIEVENT(NodeMiddleButtonUp)
				CLASS_MEMBER_GUIEVENT(NodeMiddleButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT(NodeRightButtonDown)
				CLASS_MEMBER_GUIEVENT(NodeRightButtonUp)
				CLASS_MEMBER_GUIEVENT(NodeRightButtonDoubleClick)
				CLASS_MEMBER_GUIEVENT(NodeMouseMove)
				CLASS_MEMBER_GUIEVENT(NodeMouseEnter)
				CLASS_MEMBER_GUIEVENT(NodeMouseLeave)
				CLASS_MEMBER_GUIEVENT(NodeExpanded)
				CLASS_MEMBER_GUIEVENT(NodeCollapsed)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(NodeItemView)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(NodeRootProvider)
				CLASS_MEMBER_PROPERTY_FAST(NodeStyleProvider)
			END_CLASS_MEMBER(GuiVirtualTreeListControl)

			BEGIN_CLASS_MEMBER(ITreeViewItemView)
				CLASS_MEMBER_BASE(INodeItemPrimaryTextView)
				INTERFACE_EXTERNALCTOR(tree, ITreeViewItemView)
				INTERFACE_IDENTIFIER(ITreeViewItemView)

				CLASS_MEMBER_METHOD(GetNodeImage, {L"node"})
				CLASS_MEMBER_METHOD(GetNodeText, {L"node"})
			END_CLASS_MEMBER(ITreeViewItemView)

			BEGIN_CLASS_MEMBER(TreeViewItem)
				CLASS_MEMBER_BASE(IMemoryNodeData)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TreeViewItem>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TreeViewItem>(const Ptr<GuiImageData>&, const WString&), {L"image" _ L"text"})

				CLASS_MEMBER_FIELD(image)
				CLASS_MEMBER_FIELD(text)
				CLASS_MEMBER_FIELD(tag)
			END_CLASS_MEMBER(TreeViewItem)

			BEGIN_CLASS_MEMBER(TreeViewItemRootProvider)
				CLASS_MEMBER_BASE(MemoryNodeRootProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TreeViewItemRootProvider>(), NO_PARAMETER)

				CLASS_MEMBER_METHOD(GetTreeViewData, {L"node"})
				CLASS_MEMBER_METHOD(SetTreeViewData, {L"node" _ L"value"})
				CLASS_MEMBER_METHOD(UpdateTreeViewData, {L"node"})
			END_CLASS_MEMBER(TreeViewItemRootProvider)

			BEGIN_CLASS_MEMBER(GuiVirtualTreeView)
				CLASS_MEMBER_BASE(GuiVirtualTreeListControl)
				CLASS_MEMBER_CONSTRUCTOR(GuiVirtualTreeView*(GuiVirtualTreeView::IStyleProvider* _ Ptr<INodeRootProvider>), {L"styleProvider" _ L"rootNodeProvider"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(TreeViewStyleProvider)
			END_CLASS_MEMBER(GuiVirtualTreeView)

			BEGIN_CLASS_MEMBER(GuiVirtualTreeView::IStyleProvider)
				CLASS_MEMBER_BASE(GuiVirtualTreeListControl::IStyleProvider)
				INTERFACE_EXTERNALCTOR(GuiVirtualTreeView, IStyleProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(TextColor)

				CLASS_MEMBER_METHOD(CreateItemBackground, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateItemExpandingDecorator, NO_PARAMETER)
			END_CLASS_MEMBER(GuiVirtualTreeView::IStyleProvider)

			BEGIN_CLASS_MEMBER(GuiTreeView)
				CLASS_MEMBER_BASE(GuiVirtualTreeView)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiTreeView)

				CLASS_MEMBER_METHOD_RENAME(GetNodes, Nodes, NO_PARAMETER)
				CLASS_MEMBER_PROPERTY_READONLY(Nodes, GetNodes)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItem, SelectionChanged)
			END_CLASS_MEMBER(GuiTreeView)

			BEGIN_CLASS_MEMBER(TreeViewNodeItemStyleProvider)
				CLASS_MEMBER_BASE(INodeItemStyleProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TreeViewNodeItemStyleProvider>(), NO_PARAMETER)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TreeViewNodeItemStyleProvider>(Size, bool), {L"minIconSize" _ L"fitImage"})
			END_CLASS_MEMBER(TreeViewNodeItemStyleProvider)

			BEGIN_CLASS_MEMBER(GuiComboBoxBase)
				CLASS_MEMBER_BASE(GuiMenuButton)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiComboBoxBase)

				CLASS_MEMBER_GUIEVENT(ItemSelected)
			END_CLASS_MEMBER(GuiComboBoxBase)

			BEGIN_CLASS_MEMBER(GuiComboBoxBase::ICommandExecutor)
				CLASS_MEMBER_BASE(IDescriptable)
				
				CLASS_MEMBER_METHOD(SelectItem, NO_PARAMETER)
			END_CLASS_MEMBER(GuiComboBoxBase::ICommandExecutor)

			BEGIN_CLASS_MEMBER(GuiComboBoxBase::IStyleController)
				CLASS_MEMBER_BASE(GuiMenuButton::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiComboBoxBase, IStyleController)
				
				CLASS_MEMBER_METHOD(SetCommandExecutor, {L"value"})
				CLASS_MEMBER_METHOD(OnItemSelected, NO_PARAMETER)
			END_CLASS_MEMBER(GuiComboBoxBase::IStyleController)

			BEGIN_CLASS_MEMBER(GuiComboBoxListControl)
				CLASS_MEMBER_BASE(GuiComboBoxBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiComboBoxListControl*(GuiComboBoxListControl::IStyleController* _ GuiSelectableListControl*), {L"styleController" _ L"containedListControl"})

				CLASS_MEMBER_PROPERTY_FAST(Font)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ContainedListControl)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SelectedIndex)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ItemProvider)
			END_CLASS_MEMBER(GuiComboBoxListControl)

			BEGIN_CLASS_MEMBER(GuiToolstripCommand)
				CLASS_MEMBER_BASE(GuiComponent)
				CLASS_MEMBER_CONSTRUCTOR(GuiToolstripCommand*(), NO_PARAMETER)

				CLASS_MEMBER_GUIEVENT(Executed)
				CLASS_MEMBER_GUIEVENT(DescriptionChanged)

				CLASS_MEMBER_PROPERTY_EVENT_FAST(Image, DescriptionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_FAST(Text, DescriptionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_FAST(Shortcut, DescriptionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_FAST(ShortcutBuilder, DescriptionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_FAST(Enabled, DescriptionChanged)
			END_CLASS_MEMBER(GuiToolstripCommand)

			BEGIN_CLASS_MEMBER(GuiToolstripMenu)
				CLASS_MEMBER_BASE(GuiMenu)
				CLASS_MEMBER_CONSTRUCTOR(GuiToolstripMenu*(GuiToolstripMenu::IStyleController* _ GuiControl*), {L"styleController" _ L"owner"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ToolstripItems)
			END_CLASS_MEMBER(GuiToolstripMenu)

			BEGIN_CLASS_MEMBER(GuiToolstripMenuBar)
				CLASS_MEMBER_BASE(GuiMenuBar)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiToolstripMenuBar)
				
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ToolstripItems)
			END_CLASS_MEMBER(GuiToolstripMenuBar)

			BEGIN_CLASS_MEMBER(GuiToolstripToolBar)
				CLASS_MEMBER_BASE(GuiControl)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiToolstripToolBar)
				
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ToolstripItems)
			END_CLASS_MEMBER(GuiToolstripToolBar)

			BEGIN_CLASS_MEMBER(GuiToolstripButton)
				CLASS_MEMBER_BASE(GuiMenuButton)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiToolstripToolBar)

				CLASS_MEMBER_PROPERTY_FAST(Command)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ToolstripSubMenu)

				CLASS_MEMBER_METHOD(CreateToolstripSubMenu, {L"subMenuStyleController"})
			END_CLASS_MEMBER(GuiToolstripButton)

			BEGIN_CLASS_MEMBER(GuiDocumentCommonInterface)
				CLASS_MEMBER_PROPERTY_FAST(Document)
				CLASS_MEMBER_PROPERTY_FAST(EditMode)

				CLASS_MEMBER_GUIEVENT(ActiveHyperlinkChanged)
				CLASS_MEMBER_GUIEVENT(ActiveHyperlinkExecuted)
				CLASS_MEMBER_GUIEVENT(SelectionChanged)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(CaretBegin)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(CaretEnd)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ActiveHyperlinkReference)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SelectionText)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SelectionModel)

				CLASS_MEMBER_METHOD(SetCaret, {L"begin" _ L"end" _ L"frontSide"})
				CLASS_MEMBER_METHOD(CalculateCaretFromPoint, {L"point"})
				CLASS_MEMBER_METHOD(GetCaretBounds, {L"caret" _ L"frontSide"})
				CLASS_MEMBER_METHOD(NotifyParagraphUpdated, {L"index" _ L"oldCount" _ L"newCount" _ L"updatedText"})
				CLASS_MEMBER_METHOD(EditRun, {L"begin" _ L"end" _ L"model"})
				CLASS_MEMBER_METHOD(EditText, {L"begin" _ L"end" _ L"frontSide" _ L"text"})
				CLASS_MEMBER_METHOD(EditStyle, {L"begin" _ L"end" _ L"style"})
				CLASS_MEMBER_METHOD(EditImage, {L"begin" _ L"end" _ L"image"})
				CLASS_MEMBER_METHOD(EditImage, {L"paragraphIndex" _ L"begin" _ L"end" _ L"reference" _ L"normalStyleName" _ L"activeStyleName"})
				CLASS_MEMBER_METHOD(RemoveHyperlink, {L"paragraphIndex" _ L"begin" _ L"end"})
				CLASS_MEMBER_METHOD(EditStyleName, {L"begin" _ L"end" _ L"styleName"})
				CLASS_MEMBER_METHOD(RemoveStyleName, {L"begin" _ L"end" _ L"image"})
				CLASS_MEMBER_METHOD(RenameStyle, {L"oldStyleName" _ L"newStyleName"})
				CLASS_MEMBER_METHOD(ClearStyle, {L"begin" _ L"end"})
				CLASS_MEMBER_METHOD(SummarizeStyle, {L"begin" _ L"end"})
				CLASS_MEMBER_METHOD(SetParagraphAlignment, {L"begin" _ L"end" _ L"alignments"})
				CLASS_MEMBER_METHOD(SelectAll, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanCut, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanCopy, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanPaste, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Cut, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Copy, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Paste, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanUndo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanRedo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ClearUndoRedo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(NotifyModificationSaved, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Undo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Redo, NO_PARAMETER)
			END_CLASS_MEMBER(GuiDocumentCommonInterface)

			BEGIN_ENUM_ITEM(GuiDocumentCommonInterface::EditMode)
				ENUM_ITEM_NAMESPACE(GuiDocumentCommonInterface)
				ENUM_NAMESPACE_ITEM(ViewOnly)
				ENUM_NAMESPACE_ITEM(Selectable)
				ENUM_NAMESPACE_ITEM(Editable)
			END_ENUM_ITEM(GuiDocumentCommonInterface::EditMode)

			BEGIN_CLASS_MEMBER(GuiDocumentViewer)
				CLASS_MEMBER_BASE(GuiScrollContainer)
				CLASS_MEMBER_BASE(GuiDocumentCommonInterface)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiDocumentViewer)
			END_CLASS_MEMBER(GuiDocumentViewer)

			BEGIN_CLASS_MEMBER(GuiDocumentViewer::IStyleProvider)
				CLASS_MEMBER_BASE(GuiScrollContainer::IStyleProvider)
				INTERFACE_EXTERNALCTOR(GuiDocumentViewer, IStyleProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(BaselineDocument)
			END_CLASS_MEMBER(GuiDocumentViewer::IStyleProvider)

			BEGIN_CLASS_MEMBER(GuiDocumentLabel)
				CLASS_MEMBER_BASE(GuiControl)
				CLASS_MEMBER_BASE(GuiDocumentCommonInterface)
				CONTROL_CONSTRUCTOR_CONTROLLER(GuiDocumentLabel)
			END_CLASS_MEMBER(GuiDocumentLabel)

			BEGIN_CLASS_MEMBER(GuiDocumentLabel::IStyleController)
				CLASS_MEMBER_BASE(GuiControl::IStyleController)
				INTERFACE_EXTERNALCTOR(GuiDocumentLabel, IStyleController)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(BaselineDocument)
			END_CLASS_MEMBER(GuiDocumentLabel::IStyleProvider)

			BEGIN_CLASS_MEMBER(GuiTextBoxCommonInterface)
				CLASS_MEMBER_GUIEVENT(SelectionChanged)
				
				CLASS_MEMBER_PROPERTY_FAST(Readonly)
				CLASS_MEMBER_PROPERTY_EVENT_FAST(SelectionText, SelectionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(CaretBegin, SelectionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(CaretEnd, SelectionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(CaretSmall, SelectionChanged)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(CaretLarge, SelectionChanged)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RowHeight)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(MaxWidth)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(MaxHeight)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(EditVersion)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Modified)

				CLASS_MEMBER_METHOD(CanCut, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanCopy, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanPaste, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Cut, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Copy, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Paste, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SelectAll, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Select, {L"begin" _ L"end"})
				CLASS_MEMBER_METHOD(SetSelectionTextAsKeyInput, {L"value"})
				CLASS_MEMBER_METHOD(GetRowText, {L"row"})
				CLASS_MEMBER_METHOD(GetFragmentText, {L"start" _ L"end"})
				CLASS_MEMBER_METHOD(GetRowWidth, {L"row"})
				CLASS_MEMBER_METHOD(GetTextPosFromPoint, {L"point"})
				CLASS_MEMBER_METHOD(GetPointFromTextPos, {L"pos"})
				CLASS_MEMBER_METHOD(GetRectFromTextPos, {L"pos"})
				CLASS_MEMBER_METHOD(GetNearestTextPos, {L"point"})
				CLASS_MEMBER_METHOD(CanUndo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CanRedo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ClearUndoRedo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(NotifyModificationSaved, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Undo, NO_PARAMETER)
				CLASS_MEMBER_METHOD(Redo, NO_PARAMETER)
			END_CLASS_MEMBER(GuiTextBoxCommonInterface)

			BEGIN_CLASS_MEMBER(GuiMultilineTextBox)
				CLASS_MEMBER_BASE(GuiScrollView)
				CLASS_MEMBER_BASE(GuiTextBoxCommonInterface)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiMultilineTextBox)
			END_CLASS_MEMBER(GuiMultilineTextBox)

			BEGIN_CLASS_MEMBER(GuiSinglelineTextBox)
				CLASS_MEMBER_BASE(GuiControl)
				CLASS_MEMBER_BASE(GuiTextBoxCommonInterface)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiSinglelineTextBox)

				CLASS_MEMBER_PROPERTY_FAST(PasswordChar)
			END_CLASS_MEMBER(GuiSinglelineTextBox)

			BEGIN_CLASS_MEMBER(GuiSinglelineTextBox::IStyleProvider)
				CLASS_MEMBER_BASE(GuiControl::IStyleProvider)
				INTERFACE_EXTERNALCTOR(GuiSinglelineTextBox, IStyleProvider)

				CLASS_MEMBER_METHOD(InstallBackground, {L"background"})
			END_CLASS_MEMBER(GuiSinglelineTextBox::IStyleProvider)

			BEGIN_CLASS_MEMBER(IDataVisualizerFactory)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IDataVisualizerFactory)

				CLASS_MEMBER_METHOD(CreateVisualizer, {L"font" _ L"styleProvider"})
			END_CLASS_MEMBER(IDataVisualizerFactory)

			BEGIN_CLASS_MEMBER(IDataVisualizer)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IDataVisualizer)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Factory)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(BoundsComposition)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(DecoratedDataVisualizer)

				CLASS_MEMBER_METHOD(BeforeVisualizeCell, {L"dataProvider" _ L"row" _ L"column"})
				CLASS_MEMBER_METHOD(SetSelected, {L"value"})
			END_CLASS_MEMBER(IDataVisualizer)

			BEGIN_CLASS_MEMBER(IDataEditorCallback)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_METHOD(RequestSaveData, NO_PARAMETER);
			END_CLASS_MEMBER(IDataEditorCallback)

			BEGIN_CLASS_MEMBER(IDataEditorFactory)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IDataEditorFactory)

				CLASS_MEMBER_METHOD(CreateEditor, {L"callback"})
			END_CLASS_MEMBER(IDataEditorFactory)

			BEGIN_CLASS_MEMBER(IDataEditor)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IDataEditor)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Factory)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(BoundsComposition)

				CLASS_MEMBER_METHOD(BeforeEditCell, {L"dataProvider" _ L"row" _ L"column"})
				CLASS_MEMBER_METHOD(ReinstallEditor, NO_PARAMETER)
			END_CLASS_MEMBER(IDataEditor)

			BEGIN_CLASS_MEMBER(IDataProviderCommandExecutor)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_METHOD(OnDataProviderColumnChanged, NO_PARAMETER)
				CLASS_MEMBER_METHOD(OnDataProviderItemModified, {L"start" _ L"count" _ L"newCount"})
			END_CLASS_MEMBER(IDataProviderCommandExecutor)

			BEGIN_CLASS_MEMBER(IDataProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IDataProvider)
				INTERFACE_IDENTIFIER(IDataProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ColumnCount)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SortedColumn)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RowCount)

				CLASS_MEMBER_METHOD(SetCommandExecutor, {L"value"})
				CLASS_MEMBER_METHOD(GetColumnText, {L"column"})
				CLASS_MEMBER_METHOD(GetColumnSize, {L"column"})
				CLASS_MEMBER_METHOD(SetColumnSize, {L"column" _ L"value"})
				CLASS_MEMBER_METHOD(GetColumnPopup, {L"column"})
				CLASS_MEMBER_METHOD(IsColumnSortable, {L"column"})
				CLASS_MEMBER_METHOD(SortByColumn, {L"column" _ L"ascending"})
				CLASS_MEMBER_METHOD(IsSortOrderAscending, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetRowLargeImage, {L"row" _ L"column"})
				CLASS_MEMBER_METHOD(GetRowSmallImage, {L"row" _ L"column"})
				CLASS_MEMBER_METHOD(GetCellSpan, {L"row" _ L"column"})
				CLASS_MEMBER_METHOD(GetCellText, {L"row" _ L"column"})
				CLASS_MEMBER_METHOD(GetCellDataVisualizerFactory, {L"row" _ L"column"})
				CLASS_MEMBER_METHOD(VisualizeCell, {L"row" _ L"column" _ L"dataVisualizer"})
				CLASS_MEMBER_METHOD(GetCellDataEditorFactory, {L"row" _ L"column"})
				CLASS_MEMBER_METHOD(BeforeEditCell, {L"row" _ L"column" _ L"dataEditor"})
				CLASS_MEMBER_METHOD(SaveCellData, {L"row" _ L"column" _ L"dataEditor"})
			END_CLASS_MEMBER(IDataProvider)

			BEGIN_CLASS_MEMBER(IStructuredDataFilterCommandExecutor)
				CLASS_MEMBER_BASE(IDescriptable)

				CLASS_MEMBER_METHOD(OnFilterChanged, NO_PARAMETER)
			END_CLASS_MEMBER(IStructuredDataFilterCommandExecutor)

			BEGIN_CLASS_MEMBER(IStructuredDataFilter)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IStructuredDataFilter)

				CLASS_MEMBER_METHOD(SetCommandExecutor, {L"value"})
				CLASS_MEMBER_METHOD(Filter, {L"row"})
			END_CLASS_MEMBER(IStructuredDataFilter)

			BEGIN_CLASS_MEMBER(IStructuredDataSorter)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IStructuredDataSorter)

				CLASS_MEMBER_METHOD(Compare, {L"row1" _ L"row2"})
			END_CLASS_MEMBER(IStructuredDataSorter)

			BEGIN_CLASS_MEMBER(IStructuredColumnProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IStructuredColumnProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(Text)
				CLASS_MEMBER_PROPERTY_FAST(Size)
				CLASS_MEMBER_PROPERTY_FAST(SortingState)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Popup)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(InherentFilter)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(InherentSorter)
				CLASS_MEMBER_METHOD(GetCellText, {L"row"})
				CLASS_MEMBER_METHOD(GetCellDataVisualizerFactory, {L"row"})
				CLASS_MEMBER_METHOD(VisualizeCell, {L"row" _ L"dataVisualizer"})
				CLASS_MEMBER_METHOD(GetCellDataEditorFactory, {L"row"})
				CLASS_MEMBER_METHOD(BeforeEditCell, {L"row" _ L"dataEditor"})
				CLASS_MEMBER_METHOD(SaveCellData, {L"row" _ L"dataEditor"})
			END_CLASS_MEMBER(IStructuredColumnProvider)

			BEGIN_CLASS_MEMBER(IStructuredDataProvider)
				CLASS_MEMBER_BASE(IDescriptable)
				INTERFACE_EXTERNALCTOR(list, IStructuredDataProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ColumnCount)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RowCount)

				CLASS_MEMBER_METHOD(SetCommandExecutor, {L"value"})
				CLASS_MEMBER_METHOD(GetColumn, {L"column"})
				CLASS_MEMBER_METHOD(GetRowLargeImage, {L"row"})
				CLASS_MEMBER_METHOD(GetRowSmallImage, {L"row"})
			END_CLASS_MEMBER(IStructuredDataProvider)

			BEGIN_CLASS_MEMBER(DataGridContentProvider)
				CLASS_MEMBER_BASE(ListViewItemStyleProvider::IListViewItemContentProvider)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DataGridContentProvider>(), NO_PARAMETER)
			END_CLASS_MEMBER(DataGridContentProvider)

			BEGIN_CLASS_MEMBER(GuiVirtualDataGrid)
				CLASS_MEMBER_BASE(GuiVirtualListView)
				CLASS_MEMBER_CONSTRUCTOR(GuiVirtualDataGrid*(GuiVirtualListView::IStyleProvider* _ list::IDataProvider*), {L"styleProvider" _ L"dataProvider"})
				CLASS_MEMBER_CONSTRUCTOR(GuiVirtualDataGrid*(GuiVirtualListView::IStyleProvider* _ list::IStructuredDataProvider*), {L"styleProvider" _ L"dataProvider"})

				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SelectedCell)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(DataProvider)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(StructuredDataProvider)
			END_CLASS_MEMBER(GuiVirtualDataGrid)

			BEGIN_CLASS_MEMBER(StructuredDataFilterBase)
				CLASS_MEMBER_BASE(IStructuredDataFilter)
			END_CLASS_MEMBER(StructuredDataFilterBase)

			BEGIN_CLASS_MEMBER(StructuredDataMultipleFilter)
				CLASS_MEMBER_BASE(StructuredDataFilterBase)

				CLASS_MEMBER_METHOD(AddSubFilter, {L"value"})
				CLASS_MEMBER_METHOD(RemoveSubFilter, {L"value"})
			END_CLASS_MEMBER(StructuredDataMultipleFilter)

			BEGIN_CLASS_MEMBER(StructuredDataAndFilter)
				CLASS_MEMBER_BASE(StructuredDataMultipleFilter)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<StructuredDataAndFilter>(), NO_PARAMETER)
			END_CLASS_MEMBER(StructuredDataAndFilter)

			BEGIN_CLASS_MEMBER(StructuredDataOrFilter)
				CLASS_MEMBER_BASE(StructuredDataMultipleFilter)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<StructuredDataOrFilter>(), NO_PARAMETER)
			END_CLASS_MEMBER(StructuredDataOrFilter)

			BEGIN_CLASS_MEMBER(StructuredDataNotFilter)
				CLASS_MEMBER_BASE(StructuredDataFilterBase)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<StructuredDataNotFilter>(), NO_PARAMETER)

				CLASS_MEMBER_METHOD(SetSubFilter, {L"value"})
			END_CLASS_MEMBER(StructuredDataNotFilter)

			BEGIN_CLASS_MEMBER(StructuredDataMultipleSorter)
				CLASS_MEMBER_BASE(IStructuredDataSorter)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<StructuredDataMultipleSorter>(), NO_PARAMETER)

				CLASS_MEMBER_METHOD(SetLeftSorter, {L"value"})
				CLASS_MEMBER_METHOD(SetRightSorter, {L"value"})
			END_CLASS_MEMBER(StructuredDataMultipleSorter)

			BEGIN_CLASS_MEMBER(StructuredDataReverseSorter)
				CLASS_MEMBER_BASE(IStructuredDataSorter)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<StructuredDataReverseSorter>(), NO_PARAMETER)
				
				CLASS_MEMBER_METHOD(SetSubSorter, {L"value"})
			END_CLASS_MEMBER(StructuredDataReverseSorter)

			BEGIN_CLASS_MEMBER(StructuredDataProvider)
				CLASS_MEMBER_BASE(IDataProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(StructuredDataProvider)
				CLASS_MEMBER_PROPERTY_FAST(AdditionalFilter)
			END_CLASS_MEMBER(StructuredDataProvider)

			BEGIN_CLASS_MEMBER(StructuredColummProviderBase)
				CLASS_MEMBER_BASE(IStructuredColumnProvider)

				CLASS_MEMBER_PROPERTY_FAST(Text)
				CLASS_MEMBER_PROPERTY_FAST(Popup)
				CLASS_MEMBER_PROPERTY_FAST(InherentFilter)
				CLASS_MEMBER_PROPERTY_FAST(InherentSorter)
				CLASS_MEMBER_PROPERTY_FAST(VisualizerFactory)
				CLASS_MEMBER_PROPERTY_FAST(EditorFactory)
			END_CLASS_MEMBER(StructuredColummProviderBase)

			BEGIN_CLASS_MEMBER(StructuredDataProviderBase)
				CLASS_MEMBER_BASE(IStructuredDataProvider)
			END_CLASS_MEMBER(StructuredDataProviderBase)

			BEGIN_CLASS_MEMBER(ListViewMainColumnDataVisualizer)
				CLASS_MEMBER_BASE(IDataVisualizer)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(TextElement)
			END_CLASS_MEMBER(ListViewMainColumnDataVisualizer)

			BEGIN_CLASS_MEMBER(ListViewMainColumnDataVisualizer::Factory)
				CLASS_MEMBER_BASE(IDataVisualizerFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewMainColumnDataVisualizer::Factory>(), NO_PARAMETER)
			END_CLASS_MEMBER(ListViewMainColumnDataVisualizer::Factory)

			BEGIN_CLASS_MEMBER(ListViewSubColumnDataVisualizer)
				CLASS_MEMBER_BASE(IDataVisualizer)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(TextElement)
			END_CLASS_MEMBER(ListViewSubColumnDataVisualizer)

			BEGIN_CLASS_MEMBER(ListViewSubColumnDataVisualizer::Factory)
				CLASS_MEMBER_BASE(IDataVisualizerFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ListViewSubColumnDataVisualizer::Factory>(), NO_PARAMETER)
			END_CLASS_MEMBER(ListViewSubColumnDataVisualizer::Factory)

			BEGIN_CLASS_MEMBER(HyperlinkDataVisualizer)
				CLASS_MEMBER_BASE(ListViewSubColumnDataVisualizer)
			END_CLASS_MEMBER(HyperlinkDataVisualizer)

			BEGIN_CLASS_MEMBER(HyperlinkDataVisualizer::Factory)
				CLASS_MEMBER_BASE(IDataVisualizerFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<HyperlinkDataVisualizer::Factory>(), NO_PARAMETER)
			END_CLASS_MEMBER(HyperlinkDataVisualizer::Factory)

			BEGIN_CLASS_MEMBER(ImageDataVisualizer)
				CLASS_MEMBER_BASE(IDataVisualizer)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ImageElement)
			END_CLASS_MEMBER(ImageDataVisualizer)

			BEGIN_CLASS_MEMBER(ImageDataVisualizer::Factory)
				CLASS_MEMBER_BASE(IDataVisualizerFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<ImageDataVisualizer::Factory>(), NO_PARAMETER)
			END_CLASS_MEMBER(ImageDataVisualizer::Factory)

			BEGIN_CLASS_MEMBER(CellBorderDataVisualizer)
				CLASS_MEMBER_BASE(IDataVisualizer)
			END_CLASS_MEMBER(CellBorderDataVisualizer)

			BEGIN_CLASS_MEMBER(CellBorderDataVisualizer::Factory)
				CLASS_MEMBER_BASE(IDataVisualizerFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<CellBorderDataVisualizer::Factory>(Ptr<IDataVisualizerFactory>), {L"decoratedFactory"})
			END_CLASS_MEMBER(CellBorderDataVisualizer::Factory)

			BEGIN_CLASS_MEMBER(NotifyIconDataVisualizer)
				CLASS_MEMBER_BASE(IDataVisualizer)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(LeftImageElement)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RightImageElement)
			END_CLASS_MEMBER(NotifyIconDataVisualizer)

			BEGIN_CLASS_MEMBER(NotifyIconDataVisualizer::Factory)
				CLASS_MEMBER_BASE(IDataVisualizerFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<NotifyIconDataVisualizer::Factory>(Ptr<IDataVisualizerFactory>), {L"decoratedFactory"})
			END_CLASS_MEMBER(NotifyIconDataVisualizer::Factory)

			BEGIN_CLASS_MEMBER(TextBoxDataEditor)
				CLASS_MEMBER_BASE(IDataEditor)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(TextBox)
			END_CLASS_MEMBER(TextBoxDataEditor)

			BEGIN_CLASS_MEMBER(TextBoxDataEditor::Factory)
				CLASS_MEMBER_BASE(IDataEditorFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TextBoxDataEditor::Factory>(), NO_PARAMETER)
			END_CLASS_MEMBER(TextBoxDataEditor::Factory)

			BEGIN_CLASS_MEMBER(TextComboBoxDataEditor)
				CLASS_MEMBER_BASE(IDataEditor)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ComboBoxControl)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(TextListControl)
			END_CLASS_MEMBER(TextComboBoxDataEditor)

			BEGIN_CLASS_MEMBER(TextComboBoxDataEditor::Factory)
				CLASS_MEMBER_BASE(IDataEditorFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<TextComboBoxDataEditor::Factory>(), NO_PARAMETER)
			END_CLASS_MEMBER(TextComboBoxDataEditor::Factory)

			BEGIN_CLASS_MEMBER(DateComboBoxDataEditor)
				CLASS_MEMBER_BASE(IDataEditor)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(ComboBoxControl)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(DatePickerControl)
			END_CLASS_MEMBER(DateComboBoxDataEditor)

			BEGIN_CLASS_MEMBER(DateComboBoxDataEditor::Factory)
				CLASS_MEMBER_BASE(IDataEditorFactory)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<DateComboBoxDataEditor::Factory>(), NO_PARAMETER)
			END_CLASS_MEMBER(DateComboBoxDataEditor::Factory)

			BEGIN_CLASS_MEMBER(GuiDatePicker)
				CLASS_MEMBER_BASE(GuiControl)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiDatePicker)

				CLASS_MEMBER_PROPERTY_EVENT_FAST(Date, DateChanged)
				CLASS_MEMBER_PROPERTY_EVENT_FAST(DateFormat, DateFormatChanged)
				CLASS_MEMBER_PROPERTY_EVENT_FAST(DateLocale, DateLocaleChanged)

				CLASS_MEMBER_GUIEVENT(DateSelected);
				CLASS_MEMBER_GUIEVENT(DateNavigated);
			END_CLASS_MEMBER(GuiDatePicker)

			BEGIN_CLASS_MEMBER(GuiDatePicker::IStyleProvider)
				CLASS_MEMBER_BASE(GuiControl::IStyleProvider)
				INTERFACE_EXTERNALCTOR(GuiDatePicker, IStyleProvider)

				CLASS_MEMBER_PROPERTY_READONLY_FAST(BackgroundColor)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(PrimaryTextColor)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(SecondaryTextColor)

				CLASS_MEMBER_METHOD(CreateDateButtonStyle, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateTextList, NO_PARAMETER)
				CLASS_MEMBER_METHOD(CreateComboBoxStyle, NO_PARAMETER)
			END_CLASS_MEMBER(GuiDatePicker::IStyleProvider)

			BEGIN_CLASS_MEMBER(GuiDateComboBox)
				CLASS_MEMBER_BASE(GuiComboBoxBase)
				CLASS_MEMBER_CONSTRUCTOR(GuiDateComboBox*(GuiDateComboBox::IStyleController* _ GuiDatePicker*), {L"styleController" _ L"datePicker"})

				CLASS_MEMBER_PROPERTY_EVENT_FAST(SelectedDate, SelectedDateChanged)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(DatePicker)
			END_CLASS_MEMBER(GuiDateComboBox)

			BEGIN_CLASS_MEMBER(GuiStringGrid)
				CLASS_MEMBER_BASE(GuiVirtualDataGrid)
				CONTROL_CONSTRUCTOR_PROVIDER(GuiStringGrid)

				CLASS_MEMBER_METHOD_RENAME(GetGrids, Grids, NO_PARAMETER)
				CLASS_MEMBER_PROPERTY_READONLY(Grids, GetGrids)
			END_CLASS_MEMBER(GuiStringGrid)

			BEGIN_CLASS_MEMBER(StringGridProvider)
				CLASS_MEMBER_METHOD(InsertRow, {L"row"})
				CLASS_MEMBER_METHOD(AppendRow, NO_PARAMETER)
				CLASS_MEMBER_METHOD(MoveRow, {L"source" _ L"target"})
				CLASS_MEMBER_METHOD(RemoveRow, {L"row"})
				CLASS_MEMBER_METHOD(ClearRows, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetGridString, {L"row" _ L"column"})
				CLASS_MEMBER_METHOD(SetGridString, {L"row" _ L"column" _ L"value"})

				CLASS_MEMBER_METHOD(InsertColumn, {L"column" _ L"text" _ L"size"})
				CLASS_MEMBER_METHOD(AppendColumn, {L"text" _ L"size"})
				CLASS_MEMBER_METHOD(MoveColumn, {L"source" _ L"target"})
				CLASS_MEMBER_METHOD(RemoveColumn, {L"column"})
				CLASS_MEMBER_METHOD(ClearColumns, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetColumnText, {L"column"})
				CLASS_MEMBER_METHOD(SetColumnText, {L"column" _ L"value"})
			END_CLASS_MEMBER(StringGridProvider)

			BEGIN_CLASS_MEMBER(GuiBindableTextList)
				CLASS_MEMBER_BASE(GuiVirtualTextList)
				CLASS_MEMBER_CONSTRUCTOR(GuiBindableTextList*(GuiBindableTextList::IStyleProvider*, list::TextItemStyleProvider::ITextItemStyleProvider*, Ptr<IValueEnumerable>), {L"styleProvider" _ L"itemStyleProvider" _ L"itemSource"})

				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(TextProperty)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(CheckedProperty)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItem, SelectionChanged)
			END_CLASS_MEMBER(GuiBindableTextList)

			BEGIN_CLASS_MEMBER(GuiBindableListView)
				CLASS_MEMBER_BASE(GuiVirtualListView)
				CLASS_MEMBER_CONSTRUCTOR(GuiBindableListView*(GuiBindableListView::IStyleProvider*, Ptr<IValueEnumerable>), {L"styleProvider" _ L"itemSource"})

				CLASS_MEMBER_PROPERTY_READONLY_FAST(DataColumns)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Columns)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(LargeImageProperty)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(SmallImageProperty)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItem, SelectionChanged)
			END_CLASS_MEMBER(GuiBindableListView)

			BEGIN_CLASS_MEMBER(GuiBindableTreeView)
				CLASS_MEMBER_BASE(GuiVirtualTreeView)
				CLASS_MEMBER_CONSTRUCTOR(GuiBindableTreeView*(GuiBindableTreeView::IStyleProvider*, const Value&), {L"styleProvider" _ L"itemSource"})
				
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(TextProperty)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(ImageProperty)
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(ChildrenProperty)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedItem, SelectionChanged)
			END_CLASS_MEMBER(GuiBindableTreeView)

			BEGIN_CLASS_MEMBER(BindableDataColumn)
				CLASS_MEMBER_BASE(StructuredColummProviderBase)
				CLASS_MEMBER_CONSTRUCTOR(Ptr<BindableDataColumn>(), NO_PARAMETER)

				CLASS_MEMBER_METHOD(GetCellValue, { L"row" })
				CLASS_MEMBER_METHOD(SetCellValue, { L"row" _ L"value" })
				CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(ValueProperty)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(ViewModelContext)
			END_CLASS_MEMBER(BindableDataColumn)

			BEGIN_CLASS_MEMBER(GuiBindableDataGrid)
				CLASS_MEMBER_BASE(GuiVirtualDataGrid)
				CLASS_MEMBER_CONSTRUCTOR(GuiBindableDataGrid*(GuiBindableDataGrid::IStyleProvider*, Ptr<IValueEnumerable>, const Value&), {L"styleProvider" _ L"itemSource" _ L"viewModelContext"})

				CLASS_MEMBER_METHOD(InsertBindableColumn, { L"index" _ L"column" })
				CLASS_MEMBER_METHOD(AddBindableColumn, { L"column" })
				CLASS_MEMBER_METHOD(RemoveBindableColumn, { L"column" })
				CLASS_MEMBER_METHOD(ClearBindableColumns, NO_PARAMETER)
				CLASS_MEMBER_METHOD(GetBindableColumn, { L"index" })
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedRowValue, SelectedCellChanged)
				CLASS_MEMBER_PROPERTY_EVENT_READONLY_FAST(SelectedCellValue, SelectedCellChanged)
			END_CLASS_MEMBER(GuiBindableDataGrid)

#undef INTERFACE_IDENTIFIER
#undef CONTROL_CONSTRUCTOR_CONTROLLER
#undef INTERFACE_EXTERNALCTOR
#undef _

/***********************************************************************
Type Loader
***********************************************************************/

			class GuiControlsTypeLoader : public Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					GUIREFLECTIONCONTROLS_TYPELIST(ADD_TYPE_INFO)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};

#endif

			bool LoadGuiControlTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiControlsTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONELEMENTS.CPP
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			using namespace collections;

#ifndef VCZH_DEBUG_NO_REFLECTION

			GUIREFLECTIONELEMENT_TYPELIST(IMPL_VL_TYPE_INFO)

/***********************************************************************
External Functions
***********************************************************************/

			template<typename T>
			Ptr<T> Element_Constructor()
			{
				return T::Create();
			}

			text::TextLines* GuiColorizedTextElement_GetLines(GuiColorizedTextElement* thisObject)
			{
				return &thisObject->GetLines();
			}

/***********************************************************************
Type Declaration
***********************************************************************/

#define _ ,

			BEGIN_CLASS_MEMBER(IGuiGraphicsParagraph)
				CLASS_MEMBER_BASE(IDescriptable)
			END_CLASS_MEMBER(IGuiGraphicsParagraph)

			BEGIN_ENUM_ITEM(IGuiGraphicsParagraph::CaretRelativePosition)
				ENUM_ITEM_NAMESPACE(IGuiGraphicsParagraph)
				ENUM_NAMESPACE_ITEM(CaretFirst)
				ENUM_NAMESPACE_ITEM(CaretLast)
				ENUM_NAMESPACE_ITEM(CaretLineFirst)
				ENUM_NAMESPACE_ITEM(CaretLineLast)
				ENUM_NAMESPACE_ITEM(CaretMoveLeft)
				ENUM_NAMESPACE_ITEM(CaretMoveRight)
				ENUM_NAMESPACE_ITEM(CaretMoveUp)
				ENUM_NAMESPACE_ITEM(CaretMoveDown)
			END_ENUM_ITEM(IGuiGraphicsParagraph::CaretRelativePosition)

			BEGIN_ENUM_ITEM(ElementShape)
				ENUM_CLASS_ITEM(Rectangle)
				ENUM_CLASS_ITEM(Ellipse)
			END_ENUM_ITEM(ElementShape)

			BEGIN_CLASS_MEMBER(GuiSolidBorderElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiSolidBorderElement>(), NO_PARAMETER, &Element_Constructor<GuiSolidBorderElement>)

				CLASS_MEMBER_PROPERTY_FAST(Color)
				CLASS_MEMBER_PROPERTY_FAST(Shape)
			END_CLASS_MEMBER(GuiSolidBorderElement)

			BEGIN_CLASS_MEMBER(GuiRoundBorderElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiRoundBorderElement>(), NO_PARAMETER, &Element_Constructor<GuiRoundBorderElement>)
				
				CLASS_MEMBER_PROPERTY_FAST(Color)
				CLASS_MEMBER_PROPERTY_FAST(Radius)
			END_CLASS_MEMBER(GuiRoundBorderElement)

			BEGIN_CLASS_MEMBER(Gui3DBorderElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<Gui3DBorderElement>(), NO_PARAMETER, &Element_Constructor<Gui3DBorderElement>)
				
				CLASS_MEMBER_METHOD(SetColors, {L"value1" _ L"value2"})

				CLASS_MEMBER_PROPERTY_FAST(Color1)
				CLASS_MEMBER_PROPERTY_FAST(Color2)
			END_CLASS_MEMBER(Gui3DBorderElement)

			BEGIN_CLASS_MEMBER(Gui3DSplitterElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<Gui3DSplitterElement>(), NO_PARAMETER, &Element_Constructor<Gui3DSplitterElement>)
				
				CLASS_MEMBER_METHOD(SetColors, {L"value1" _ L"value2"})

				CLASS_MEMBER_PROPERTY_FAST(Color1)
				CLASS_MEMBER_PROPERTY_FAST(Color2)
				CLASS_MEMBER_PROPERTY_FAST(Direction)
			END_CLASS_MEMBER(Gui3DSplitterElement)

			BEGIN_ENUM_ITEM(Gui3DSplitterElement::Direction)
				ENUM_ITEM_NAMESPACE(Gui3DSplitterElement)
				ENUM_NAMESPACE_ITEM(Horizontal)
				ENUM_NAMESPACE_ITEM(Vertical)
			END_ENUM_ITEM(Gui3DSplitterElement::Direction)

			BEGIN_CLASS_MEMBER(GuiSolidBackgroundElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiSolidBackgroundElement>(), NO_PARAMETER, &Element_Constructor<GuiSolidBackgroundElement>)
				
				CLASS_MEMBER_PROPERTY_FAST(Color)
				CLASS_MEMBER_PROPERTY_FAST(Shape)
			END_CLASS_MEMBER(GuiSolidBackgroundElement)

			BEGIN_CLASS_MEMBER(GuiGradientBackgroundElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiGradientBackgroundElement>(), NO_PARAMETER, &Element_Constructor<GuiGradientBackgroundElement>)
				
				CLASS_MEMBER_METHOD(SetColors, {L"value1" _ L"value2"})

				CLASS_MEMBER_PROPERTY_FAST(Color1)
				CLASS_MEMBER_PROPERTY_FAST(Color2)
				CLASS_MEMBER_PROPERTY_FAST(Direction)
				CLASS_MEMBER_PROPERTY_FAST(Shape)
			END_CLASS_MEMBER(GuiGradientBackgroundElement)

			BEGIN_ENUM_ITEM(GuiGradientBackgroundElement::Direction)
				ENUM_ITEM_NAMESPACE(GuiGradientBackgroundElement)
				ENUM_NAMESPACE_ITEM(Horizontal)
				ENUM_NAMESPACE_ITEM(Vertical)
			END_ENUM_ITEM(GuiGradientBackgroundElement::Direction)

			BEGIN_CLASS_MEMBER(GuiSolidLabelElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiSolidLabelElement>(), NO_PARAMETER, &Element_Constructor<GuiSolidLabelElement>)
				
				CLASS_MEMBER_METHOD(SetAlignments, {L"horizontal" _ L"vertical"})

				CLASS_MEMBER_PROPERTY_FAST(Color)
				CLASS_MEMBER_PROPERTY_FAST(Font)
				CLASS_MEMBER_PROPERTY_FAST(Text)
				CLASS_MEMBER_PROPERTY_FAST(HorizontalAlignment)
				CLASS_MEMBER_PROPERTY_FAST(VerticalAlignment)
				CLASS_MEMBER_PROPERTY_FAST(WrapLine)
				CLASS_MEMBER_PROPERTY_FAST(Ellipse)
				CLASS_MEMBER_PROPERTY_FAST(Multiline)
				CLASS_MEMBER_PROPERTY_FAST(WrapLineHeightCalculation)
			END_CLASS_MEMBER(GuiSolidLabelElement)

			BEGIN_CLASS_MEMBER(GuiImageFrameElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiImageFrameElement>(), NO_PARAMETER, &Element_Constructor<GuiImageFrameElement>)

				CLASS_MEMBER_METHOD(GetImage, NO_PARAMETER)
				CLASS_MEMBER_METHOD_OVERLOAD(SetImage, {L"value"}, void(GuiImageFrameElement::*)(Ptr<INativeImage>))
				CLASS_MEMBER_METHOD_OVERLOAD(SetImage, {L"image" _  L"frameIndex"}, void(GuiImageFrameElement::*)(Ptr<INativeImage> _ vint))
				CLASS_MEMBER_PROPERTY(Image, GetImage, SetImage)

				CLASS_MEMBER_PROPERTY_FAST(FrameIndex)
				CLASS_MEMBER_PROPERTY_FAST(HorizontalAlignment)
				CLASS_MEMBER_PROPERTY_FAST(VerticalAlignment)
				CLASS_MEMBER_PROPERTY_FAST(Stretch)
				CLASS_MEMBER_PROPERTY_FAST(Enabled)
			END_CLASS_MEMBER(GuiImageFrameElement)

			BEGIN_CLASS_MEMBER(GuiPolygonElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiPolygonElement>(), NO_PARAMETER, &Element_Constructor<GuiPolygonElement>)

				CLASS_MEMBER_METHOD_RENAME(GetPoints, GetPointsArray, NO_PARAMETER);
				CLASS_MEMBER_METHOD_RENAME(SetPoints, SetPointsArray, {L"points"});
				CLASS_MEMBER_PROPERTY(Points, GetPoints, SetPoints);
				CLASS_MEMBER_PROPERTY_FAST(Size)
				CLASS_MEMBER_PROPERTY_FAST(BorderColor)
				CLASS_MEMBER_PROPERTY_FAST(BackgroundColor)
			END_CLASS_MEMBER(GuiPolygonElement)

			BEGIN_CLASS_MEMBER(text::TextLines)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(Count)
				CLASS_MEMBER_PROPERTY_FAST(TabSpaceCount)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(RowHeight)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(MaxWidth)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(MaxHeight)
				CLASS_MEMBER_PROPERTY_FAST(PasswordChar)

				CLASS_MEMBER_METHOD_OVERLOAD(GetText, NO_PARAMETER, WString(text::TextLines::*)())
				CLASS_MEMBER_METHOD_OVERLOAD(GetText, {L"start" _ L"end"}, WString(text::TextLines::*)(TextPos _ TextPos))
				CLASS_MEMBER_METHOD(SetText, {L"value"})
				CLASS_MEMBER_METHOD(RemoveLines, {L"start" _ L"end"})
				CLASS_MEMBER_METHOD(IsAvailable, {L"pos"})
				CLASS_MEMBER_METHOD(Normalize, {L"pos"})
				CLASS_MEMBER_METHOD_OVERLOAD(Modify, {L"start" _ L"end" _ L"input"}, TextPos(text::TextLines::*)(TextPos _ TextPos _ const WString&))
				CLASS_MEMBER_METHOD(Clear, NO_PARAMETER)
				CLASS_MEMBER_METHOD(ClearMeasurement, NO_PARAMETER)
				CLASS_MEMBER_METHOD(MeasureRow, {L"row"})
				CLASS_MEMBER_METHOD(GetRowWidth, {L"row"})
				CLASS_MEMBER_METHOD(GetTextPosFromPoint, {L"point"})
				CLASS_MEMBER_METHOD(GetPointFromTextPos, {L"pos"})
				CLASS_MEMBER_METHOD(GetRectFromTextPos, {L"pos"})
			END_CLASS_MEMBER(text::TextLines)

			BEGIN_STRUCT_MEMBER(text::ColorItem)
				STRUCT_MEMBER(text)
				STRUCT_MEMBER(background)
			END_STRUCT_MEMBER(text::ColorItem)

			BEGIN_STRUCT_MEMBER(text::ColorEntry)
				STRUCT_MEMBER(normal)
				STRUCT_MEMBER(selectedFocused)
				STRUCT_MEMBER(selectedUnfocused)
			END_STRUCT_MEMBER(text::ColorEntry)

			BEGIN_CLASS_MEMBER(GuiColorizedTextElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiColorizedTextElement>(), NO_PARAMETER, &Element_Constructor<GuiColorizedTextElement>)

				CLASS_MEMBER_PROPERTY_FAST(Font)
				CLASS_MEMBER_PROPERTY_FAST(PasswordChar)
				CLASS_MEMBER_PROPERTY_FAST(ViewPosition)
				CLASS_MEMBER_PROPERTY_FAST(VisuallyEnabled)
				CLASS_MEMBER_PROPERTY_FAST(Focused)
				CLASS_MEMBER_PROPERTY_FAST(CaretBegin)
				CLASS_MEMBER_PROPERTY_FAST(CaretEnd)
				CLASS_MEMBER_PROPERTY_FAST(CaretVisible)
				CLASS_MEMBER_PROPERTY_FAST(CaretColor)

				CLASS_MEMBER_EXTERNALMETHOD(GetLines, NO_PARAMETER, text::TextLines*(GuiColorizedTextElement::*)(), &GuiColorizedTextElement_GetLines)
				CLASS_MEMBER_PROPERTY_READONLY(Lines, GetLines)
				CLASS_MEMBER_PROPERTY_FAST(Colors)
			END_CLASS_MEMBER(GuiColorizedTextElement)

			BEGIN_CLASS_MEMBER(GuiDocumentElement)
				CLASS_MEMBER_BASE(IGuiGraphicsElement)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiDocumentElement>(), NO_PARAMETER, &Element_Constructor<GuiDocumentElement>)

				CLASS_MEMBER_PROPERTY_FAST(Document)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(CaretBegin)
				CLASS_MEMBER_PROPERTY_READONLY_FAST(CaretEnd)
				CLASS_MEMBER_PROPERTY_FAST(CaretVisible)
				CLASS_MEMBER_PROPERTY_FAST(CaretColor)

				CLASS_MEMBER_METHOD(IsCaretEndPreferFrontSide, NO_PARAMETER)
				CLASS_MEMBER_METHOD(SetCaret, {L"begin" _ L"end" _ L"frontSide"})
				CLASS_MEMBER_METHOD(CalculateCaret, {L"comparingCaret" _ L"position" _ L"preferFrontSide"})
				CLASS_MEMBER_METHOD(CalculateCaretFromPoint, {L"point"})
				CLASS_MEMBER_METHOD(GetCaretBounds, {L"caret" _ L"frontSide"})
				CLASS_MEMBER_METHOD(NotifyParagraphUpdated, {L"index" _ L"oldCount" _ L"newCount" _ L"updatedText"})
				CLASS_MEMBER_METHOD(EditRun, {L"begin" _ L"end" _ L"model"})
				CLASS_MEMBER_METHOD(EditText, {L"begin" _ L"end" _ L"frontSide" _ L"text"})
				CLASS_MEMBER_METHOD(EditStyle, {L"begin" _ L"end" _ L"style"})
				CLASS_MEMBER_METHOD(EditImage, {L"begin" _ L"end" _ L"image"})
				CLASS_MEMBER_METHOD(EditImage, {L"paragraphIndex" _ L"begin" _ L"end" _ L"reference" _ L"normalStyleName" _ L"activeStyleName"})
				CLASS_MEMBER_METHOD(RemoveHyperlink, {L"paragraphIndex" _ L"begin" _ L"end"})
				CLASS_MEMBER_METHOD(EditStyleName, {L"begin" _ L"end" _ L"styleName"})
				CLASS_MEMBER_METHOD(RemoveStyleName, {L"begin" _ L"end" _ L"image"})
				CLASS_MEMBER_METHOD(RenameStyle, {L"oldStyleName" _ L"newStyleName"})
				CLASS_MEMBER_METHOD(ClearStyle, {L"begin" _ L"end"})
				CLASS_MEMBER_METHOD(SummarizeStyle, {L"begin" _ L"end"})
				CLASS_MEMBER_METHOD(SetParagraphAlignment, {L"begin" _ L"end" _ L"alignments"})
				CLASS_MEMBER_METHOD(GetHyperlinkFromPoint, {L"point"})
			END_CLASS_MEMBER(GuiDocumentElement)
#undef _

/***********************************************************************
Type Loader
***********************************************************************/

			class GuiElementTypeLoader : public Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					GUIREFLECTIONELEMENT_TYPELIST(ADD_TYPE_INFO)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};

#endif

			bool LoadGuiElementTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiElementTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONEVENTS.CPP
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			using namespace collections;

#ifndef VCZH_DEBUG_NO_REFLECTION

			GUIREFLECTIONEVENT_TYPELIST(IMPL_VL_TYPE_INFO)

/***********************************************************************
Type Declaration
***********************************************************************/

#define _ ,

#define EVENTARGS_CONSTRUCTOR(EVENTARGS)\
	CLASS_MEMBER_CONSTRUCTOR(Ptr<EVENTARGS>(), NO_PARAMETER)\
	CLASS_MEMBER_CONSTRUCTOR(Ptr<EVENTARGS>(GuiGraphicsComposition*), {L"composition"})

			BEGIN_CLASS_MEMBER(GuiEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiEventArgs)

				CLASS_MEMBER_FIELD(compositionSource)
				CLASS_MEMBER_FIELD(eventSource)
				CLASS_MEMBER_FIELD(handled)
			END_CLASS_MEMBER(GuiEventArgs)

			BEGIN_CLASS_MEMBER(GuiRequestEventArgs)
				CLASS_MEMBER_BASE(GuiEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiRequestEventArgs)

				CLASS_MEMBER_FIELD(cancel)
			END_CLASS_MEMBER(GuiRequestEventArgs)

			BEGIN_CLASS_MEMBER(GuiKeyEventArgs)
				CLASS_MEMBER_BASE(GuiEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiKeyEventArgs)
				
				CLASS_MEMBER_FIELD(code)
				CLASS_MEMBER_FIELD(ctrl)
				CLASS_MEMBER_FIELD(shift)
				CLASS_MEMBER_FIELD(alt)
				CLASS_MEMBER_FIELD(capslock)
			END_CLASS_MEMBER(GuiKeyEventArgs)

			BEGIN_CLASS_MEMBER(GuiCharEventArgs)
				CLASS_MEMBER_BASE(GuiEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiCharEventArgs)
				
				CLASS_MEMBER_FIELD(code)
				CLASS_MEMBER_FIELD(ctrl)
				CLASS_MEMBER_FIELD(shift)
				CLASS_MEMBER_FIELD(alt)
				CLASS_MEMBER_FIELD(capslock)
			END_CLASS_MEMBER(GuiCharEventArgs)

			BEGIN_CLASS_MEMBER(GuiMouseEventArgs)
				CLASS_MEMBER_BASE(GuiEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiMouseEventArgs)
				
				CLASS_MEMBER_FIELD(ctrl)
				CLASS_MEMBER_FIELD(shift)
				CLASS_MEMBER_FIELD(left)
				CLASS_MEMBER_FIELD(middle)
				CLASS_MEMBER_FIELD(right)
				CLASS_MEMBER_FIELD(x)
				CLASS_MEMBER_FIELD(y)
				CLASS_MEMBER_FIELD(wheel)
				CLASS_MEMBER_FIELD(nonClient)
			END_CLASS_MEMBER(GuiMouseEventArgs)

			BEGIN_CLASS_MEMBER(GuiItemEventArgs)
				CLASS_MEMBER_BASE(GuiEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiItemEventArgs)

				CLASS_MEMBER_FIELD(itemIndex)
			END_CLASS_MEMBER(GuiItemEventArgs)

			BEGIN_CLASS_MEMBER(GuiItemMouseEventArgs)
				CLASS_MEMBER_BASE(GuiMouseEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiItemMouseEventArgs)

				CLASS_MEMBER_FIELD(itemIndex)
			END_CLASS_MEMBER(GuiItemMouseEventArgs)

			BEGIN_CLASS_MEMBER(GuiNodeEventArgs)
				CLASS_MEMBER_BASE(GuiEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiNodeEventArgs)

				CLASS_MEMBER_FIELD(node)
			END_CLASS_MEMBER(GuiNodeEventArgs)

			BEGIN_CLASS_MEMBER(GuiNodeMouseEventArgs)
				CLASS_MEMBER_BASE(GuiMouseEventArgs)
				EVENTARGS_CONSTRUCTOR(GuiNodeMouseEventArgs)

				CLASS_MEMBER_FIELD(node)
			END_CLASS_MEMBER(GuiNodeMouseEventArgs)

#undef EVENTARGS_CONSTRUCTOR
#undef _

/***********************************************************************
Type Loader
***********************************************************************/

			class GuiEventTypeLoader : public Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					GUIREFLECTIONEVENT_TYPELIST(ADD_TYPE_INFO)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};

#endif

			bool LoadGuiEventTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiEventTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONPLUGIN.CPP
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			class GuiReflectionPlugin : public Object, public IGuiPlugin
			{
			public:
				void Load()override
				{
					LoadPredefinedTypes();
					LoadParsingTypes();
					XmlLoadTypes();
					JsonLoadTypes();
					LoadGuiBasicTypes();
					LoadGuiElementTypes();
					LoadGuiCompositionTypes();
					LoadGuiControlTypes();
					LoadGuiTemplateTypes();
					LoadGuiEventTypes();
				}
				
				void AfterLoad()override
				{
				}

				void Unload()override
				{
				}
			};
			GUI_REGISTER_PLUGIN(GuiReflectionPlugin)
		}
	}
}

/***********************************************************************
TYPEDESCRIPTORS\GUIREFLECTIONTEMPLATES.CPP
***********************************************************************/

namespace vl
{
	namespace reflection
	{
		namespace description
		{
			using namespace collections;
			using namespace parsing;
			using namespace parsing::tabling;
			using namespace parsing::xml;
			using namespace stream;

#ifndef VCZH_DEBUG_NO_REFLECTION

			GUIREFLECTIONTEMPLATES_TYPELIST(IMPL_VL_TYPE_INFO)

/***********************************************************************
Type Declaration
***********************************************************************/

#define _ ,

#define INTERFACE_EXTERNALCTOR(CONTROL, INTERFACE)\
	CLASS_MEMBER_EXTERNALCTOR(decltype(interface_proxy::CONTROL##_##INTERFACE::Create(0))(Ptr<IValueInterfaceProxy>), {L"proxy"}, &interface_proxy::CONTROL##_##INTERFACE::Create)

#define GUI_TEMPLATE_PROPERTY_REFLECTION(CLASS, TYPE, NAME)\
	CLASS_MEMBER_PROPERTY_GUIEVENT_FAST(NAME)

			BEGIN_ENUM_ITEM(BoolOption)
				ENUM_CLASS_ITEM(AlwaysTrue)
				ENUM_CLASS_ITEM(AlwaysFalse)
				ENUM_CLASS_ITEM(Customizable)
			END_ENUM_ITEM(BoolOption)

			BEGIN_CLASS_MEMBER(GuiTemplate)
				CLASS_MEMBER_BASE(GuiBoundsComposition)
				CLASS_MEMBER_BASE(GuiInstanceRootObject)
				CLASS_MEMBER_CONSTRUCTOR(GuiTemplate*(), NO_PARAMETER)

				GuiTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiTemplate)
			
			BEGIN_CLASS_MEMBER(GuiTemplate::IFactory)
				INTERFACE_EXTERNALCTOR(GuiTemplate, IFactory)
				CLASS_MEMBER_EXTERNALCTOR(Ptr<GuiTemplate::IFactory>(const List<ITypeDescriptor*>&), { L"types" }, &GuiTemplate::IFactory::CreateTemplateFactory)

				CLASS_MEMBER_METHOD(CreateTemplate, NO_PARAMETER)
			END_CLASS_MEMBER(GuiTemplate::IFactory)

			BEGIN_CLASS_MEMBER(GuiControlTemplate)
				CLASS_MEMBER_BASE(GuiTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiControlTemplate*(), NO_PARAMETER)

				GuiControlTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiControlTemplate)

			BEGIN_CLASS_MEMBER(GuiLabelTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiLabelTemplate*(), NO_PARAMETER)

				GuiLabelTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiLabelTemplate)

			BEGIN_CLASS_MEMBER(GuiSinglelineTextBoxTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiSinglelineTextBoxTemplate*(), NO_PARAMETER)

				GuiSinglelineTextBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiSinglelineTextBoxTemplate)

			BEGIN_CLASS_MEMBER(GuiDocumentLabelTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiDocumentLabelTemplate*(), NO_PARAMETER)

				GuiDocumentLabelTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiDocumentLabelTemplate)

			BEGIN_CLASS_MEMBER(GuiMultilineTextBoxTemplate)
				CLASS_MEMBER_BASE(GuiScrollViewTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiMultilineTextBoxTemplate*(), NO_PARAMETER)

				GuiMultilineTextBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiMultilineTextBoxTemplate)

			BEGIN_CLASS_MEMBER(GuiDocumentViewerTemplate)
				CLASS_MEMBER_BASE(GuiScrollViewTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiDocumentViewerTemplate*(), NO_PARAMETER)

				GuiDocumentViewerTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiDocumentViewerTemplate)

			BEGIN_CLASS_MEMBER(GuiMenuTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiMenuTemplate*(), NO_PARAMETER)
			END_CLASS_MEMBER(GuiMenuTemplate)

			BEGIN_CLASS_MEMBER(GuiWindowTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiWindowTemplate*(), NO_PARAMETER)

				GuiWindowTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiWindowTemplate)

			BEGIN_CLASS_MEMBER(GuiButtonTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiButtonTemplate*(), NO_PARAMETER)

				GuiButtonTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiButtonTemplate)

			BEGIN_CLASS_MEMBER(GuiSelectableButtonTemplate)
				CLASS_MEMBER_BASE(GuiButtonTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiSelectableButtonTemplate*(), NO_PARAMETER)

				GuiSelectableButtonTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiSelectableButtonTemplate)

			BEGIN_CLASS_MEMBER(GuiToolstripButtonTemplate)
				CLASS_MEMBER_BASE(GuiSelectableButtonTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiToolstripButtonTemplate*(), NO_PARAMETER)

				GuiToolstripButtonTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiToolstripButtonTemplate)

			BEGIN_CLASS_MEMBER(GuiListViewColumnHeaderTemplate)
				CLASS_MEMBER_BASE(GuiToolstripButtonTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiListViewColumnHeaderTemplate*(), NO_PARAMETER)

				GuiListViewColumnHeaderTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiListViewColumnHeaderTemplate)

			BEGIN_CLASS_MEMBER(GuiComboBoxTemplate)
				CLASS_MEMBER_BASE(GuiToolstripButtonTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiComboBoxTemplate*(), NO_PARAMETER)

				GuiComboBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiComboBoxTemplate)

			BEGIN_CLASS_MEMBER(GuiDatePickerTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiDatePickerTemplate*(), NO_PARAMETER)

				GuiDatePickerTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiDatePickerTemplate)

			BEGIN_CLASS_MEMBER(GuiDateComboBoxTemplate)
				CLASS_MEMBER_BASE(GuiComboBoxTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiDateComboBoxTemplate*(), NO_PARAMETER)

				GuiDateComboBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiDateComboBoxTemplate)

			BEGIN_CLASS_MEMBER(GuiScrollTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiScrollTemplate*(), NO_PARAMETER)

				GuiScrollTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiScrollTemplate)

			BEGIN_CLASS_MEMBER(GuiScrollViewTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiScrollViewTemplate*(), NO_PARAMETER)

				GuiScrollViewTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiScrollViewTemplate)

			BEGIN_CLASS_MEMBER(GuiTextListTemplate)
				CLASS_MEMBER_BASE(GuiScrollViewTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiTextListTemplate*(), NO_PARAMETER)

				GuiTextListTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiTextListTemplate)

			BEGIN_CLASS_MEMBER(GuiListViewTemplate)
				CLASS_MEMBER_BASE(GuiScrollViewTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiListViewTemplate*(), NO_PARAMETER)

				GuiListViewTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiListViewTemplate)

			BEGIN_CLASS_MEMBER(GuiTreeViewTemplate)
				CLASS_MEMBER_BASE(GuiScrollViewTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiTreeViewTemplate*(), NO_PARAMETER)

				GuiTreeViewTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiTreeViewTemplate)

			BEGIN_CLASS_MEMBER(GuiTabTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiTabTemplate*(), NO_PARAMETER)

				GuiTabTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiTabTemplate)

			BEGIN_CLASS_MEMBER(GuiListItemTemplate)
				CLASS_MEMBER_BASE(GuiTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiListItemTemplate*(), NO_PARAMETER)

				GuiListItemTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiListItemTemplate)

			BEGIN_CLASS_MEMBER(GuiTreeItemTemplate)
				CLASS_MEMBER_BASE(GuiListItemTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiTreeItemTemplate*(), NO_PARAMETER)

				GuiTreeItemTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiTreeItemTemplate)

			BEGIN_CLASS_MEMBER(GuiGridVisualizerTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiGridVisualizerTemplate*(), NO_PARAMETER)

				GuiGridVisualizerTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiGridVisualizerTemplate)

			BEGIN_CLASS_MEMBER(GuiGridEditorTemplate)
				CLASS_MEMBER_BASE(GuiControlTemplate)
				CLASS_MEMBER_CONSTRUCTOR(GuiGridEditorTemplate*(), NO_PARAMETER)

				GuiGridEditorTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_REFLECTION)
			END_CLASS_MEMBER(GuiGridEditorTemplate)

#undef INTERFACE_EXTERNALCTOR
#undef _

/***********************************************************************
Type Loader
***********************************************************************/

			class GuiTemplateTypeLoader : public Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					GUIREFLECTIONTEMPLATES_TYPELIST(ADD_TYPE_INFO)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};

#endif

			bool LoadGuiTemplateTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiTemplateTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}
