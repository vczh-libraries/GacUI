/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "GacUIReflection.h"
#include "GacUI.h"
#include "VlppWorkflowCompiler.h"
#include "Vlpp.h"
#include "VlppWorkflowLibrary.h"
#include "VlppWorkflowRuntime.h"

/***********************************************************************
.\INSTANCEQUERY\GUIINSTANCEQUERY_AST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::GuiInstanceQuery_Parser.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER_AST
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER_AST


namespace vl
{
	namespace presentation
	{
		enum class GuiIqParserTokenIndex
		{
			INDIRECT = 0,
			DIRECT = 1,
			NAME = 2,
			WILDCARD = 3,
			OPEN = 4,
			CLOSE = 5,
			XOR = 6,
			INTERSECT = 7,
			UNION = 8,
			SUBSTRACT = 9,
			ATTRIBUTE = 10,
			COLON = 11,
			DOT = 12,
			SPACE = 13,
		};
		class GuiIqQuery;
		class GuiIqPrimaryQuery;
		class GuiIqCascadeQuery;
		class GuiIqSetQuery;

		class GuiIqQuery abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<GuiIqQuery>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(GuiIqPrimaryQuery* node)=0;
				virtual void Visit(GuiIqCascadeQuery* node)=0;
				virtual void Visit(GuiIqSetQuery* node)=0;
			};

			virtual void Accept(GuiIqQuery::IVisitor* visitor)=0;

		};

		enum class GuiIqNameOption
		{
			Specified,
			Any,
		};

		enum class GuiIqChildOption
		{
			Direct,
			Indirect,
		};

		class GuiIqPrimaryQuery : public GuiIqQuery, vl::reflection::Description<GuiIqPrimaryQuery>
		{
		public:
			GuiIqChildOption childOption;
			GuiIqNameOption attributeNameOption;
			vl::parsing::ParsingToken attributeName;
			GuiIqNameOption typeNameOption;
			vl::parsing::ParsingToken typeName;
			vl::parsing::ParsingToken referenceName;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqPrimaryQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class GuiIqCascadeQuery : public GuiIqQuery, vl::reflection::Description<GuiIqCascadeQuery>
		{
		public:
			vl::Ptr<GuiIqQuery> parent;
			vl::Ptr<GuiIqQuery> child;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqCascadeQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class GuiIqBinaryOperator
		{
			ExclusiveOr,
			Intersect,
			Union,
			Substract,
		};

		class GuiIqSetQuery : public GuiIqQuery, vl::reflection::Description<GuiIqSetQuery>
		{
		public:
			vl::Ptr<GuiIqQuery> first;
			vl::Ptr<GuiIqQuery> second;
			GuiIqBinaryOperator op;

			void Accept(GuiIqQuery::IVisitor* visitor)override;

			static vl::Ptr<GuiIqSetQuery> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::presentation::GuiIqQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqNameOption)
			DECL_TYPE_INFO(vl::presentation::GuiIqChildOption)
			DECL_TYPE_INFO(vl::presentation::GuiIqPrimaryQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqCascadeQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqBinaryOperator)
			DECL_TYPE_INFO(vl::presentation::GuiIqSetQuery)
			DECL_TYPE_INFO(vl::presentation::GuiIqQuery::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::presentation::GuiIqQuery::IVisitor)
				void Visit(vl::presentation::GuiIqPrimaryQuery* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::presentation::GuiIqCascadeQuery* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::presentation::GuiIqSetQuery* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::presentation::GuiIqQuery::IVisitor)

#endif
			extern bool GuiIqLoadTypes();
		}
	}
}
#endif

/***********************************************************************
.\INSTANCEQUERY\GUIINSTANCEQUERY_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::GuiInstanceQuery_Parser.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER_PARSER
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY_PARSER_PARSER


namespace vl
{
	namespace presentation
	{
		extern vl::WString GuiIqGetParserTextBuffer();
		extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> GuiIqConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		extern vl::Ptr<vl::parsing::tabling::ParsingTable> GuiIqLoadTable();

		extern vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
	}
}
#endif

/***********************************************************************
.\GUIINSTANCEREPRESENTATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEREPRESENTATION


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Instance Representation
***********************************************************************/

		class GuiTextRepr;
		class GuiAttSetterRepr;
		class GuiConstructorRepr;
		class IGuiInstanceCache;

		class GuiValueRepr : public Object, public Description<GuiValueRepr>
		{
		public:
			class IVisitor : public IDescriptable, public Description<IVisitor>
			{
			public:
				virtual void						Visit(GuiTextRepr* repr)=0;
				virtual void						Visit(GuiAttSetterRepr* repr)=0;
				virtual void						Visit(GuiConstructorRepr* repr)=0;
			};

			bool									fromStyle = false;
			GuiResourceTextPos						tagPosition;

			void									CloneBody(Ptr<GuiValueRepr> repr);

			virtual void							Accept(IVisitor* visitor) = 0;
			virtual Ptr<GuiValueRepr>				Clone() = 0;
			virtual void							FillXml(Ptr<parsing::xml::XmlElement> xml) = 0;
		};

		class GuiTextRepr : public GuiValueRepr, public Description<GuiTextRepr>
		{
		public:
			static const vint						BinaryKey = 1;

			WString									text;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

		class GuiAttSetterRepr : public GuiValueRepr, public Description<GuiAttSetterRepr>
		{
		public:
			typedef collections::List<Ptr<GuiValueRepr>>						ValueList;
			static const vint						BinaryKey = 2;

			struct SetterValue : public Object, public Description<SetterValue>
			{
				GlobalStringKey						binding;
				ValueList							values;
				GuiResourceTextPos					attPosition;
			};

			struct EventValue : public Object, public Description<EventValue>
			{
				GlobalStringKey						binding;
				WString								value;
				bool								fromStyle = false;
				GuiResourceTextPos					attPosition;
				GuiResourceTextPos					valuePosition;
			};

			struct EnvVarValue : public Object, public Description<EnvVarValue>
			{
				WString								value;
				bool								fromStyle = false;
				GuiResourceTextPos					attPosition;
				GuiResourceTextPos					valuePosition;
			};
			
			typedef collections::Dictionary<GlobalStringKey, Ptr<SetterValue>>			SetteValuerMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<EventValue>>			EventHandlerMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<EnvVarValue>>			EnvironmentVariableMap;
		public:
			SetteValuerMap							setters;					// empty key means default property
			EventHandlerMap							eventHandlers;
			EnvironmentVariableMap					environmentVariables;
			GlobalStringKey							instanceName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			void									CloneBody(Ptr<GuiAttSetterRepr> repr);
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

		class GuiConstructorRepr : public GuiAttSetterRepr, public Description<GuiConstructorRepr>
		{
		public:
			static const vint						BinaryKey = 3;

			GlobalStringKey							typeNamespace;
			GlobalStringKey							typeName;
			Nullable<WString>						styleName;

			void									Accept(IVisitor* visitor)override{visitor->Visit(this);}
			Ptr<GuiValueRepr>						Clone()override;
			void									FillXml(Ptr<parsing::xml::XmlElement> xml)override;
		};

/***********************************************************************
Instance Namespace
***********************************************************************/

		class GuiInstanceNamespace : public Object, public Description<GuiInstanceNamespace>
		{
		public:
			WString									prefix;
			WString									postfix;
		};

		// Workflow:	<name>
		// C++:			<instance>->Get<name>()
		class GuiInstanceParameter : public Object, public Description<GuiInstanceParameter>
		{
		public:
			GlobalStringKey							name;
			GlobalStringKey							className;
			GuiResourceTextPos						tagPosition;
			GuiResourceTextPos						classPosition;
		};

		class GuiInstanceLocalized : public Object, public Description<GuiInstanceLocalized>
		{
		public:
			GlobalStringKey							name;
			GlobalStringKey							className;
			GuiResourceTextPos						tagPosition;
			GuiResourceTextPos						classPosition;
			bool									defaultStrings = false;
		};

/***********************************************************************
Instance Context
***********************************************************************/

		class GuiInstanceStyleContext;

		class GuiInstanceContext : public Object, public Description<GuiInstanceContext>
		{
		public:
			typedef collections::List<Ptr<GuiInstanceNamespace>>						NamespaceList;

			struct NamespaceInfo : public Object, public Description<NamespaceInfo>
			{
				GlobalStringKey						name;
				NamespaceList						namespaces;
				GuiResourceTextPos					attPosition;
			};
			typedef collections::Dictionary<GlobalStringKey, Ptr<NamespaceInfo>>		NamespaceMap;
			typedef collections::List<Ptr<GuiInstanceParameter>>						ParameterList;
			typedef collections::List<Ptr<GuiInstanceLocalized>>						LocalizedList;
			typedef collections::List<Ptr<GuiInstanceStyleContext>>						StyleContextList;

			class ElementName : public Object
			{
			public:
				WString								namespaceName;				// empty key means default namespace
				WString								category;
				WString								name;
				WString								binding;

				bool IsCtorName() { return category == L"" && name != L"" && binding == L""; }
				bool IsReferenceAttributeName() { return namespaceName == L"" && category == L"ref" && name != L"" && binding == L""; }
				bool IsEnvironmentAttributeName() { return namespaceName == L"" && category == L"env" && name != L""; }
				bool IsPropertyAttributeName() { return namespaceName == L"" && category == L"" && name != L""; }
				bool IsPropertyElementName() { return namespaceName == L"" && category == L"att" && name != L""; }
				bool IsEventAttributeName() { return namespaceName == L"" && category == L"ev" && name != L""; }
				bool IsEventElementName() { return namespaceName == L"" && category == L"ev" && name != L""; }
			};
		public:
			Ptr<GuiConstructorRepr>					instance;
			NamespaceMap							namespaces;
			bool									codeBehind = true;
			WString									className;
			collections::List<WString>				stylePaths;

			ParameterList							parameters;
			LocalizedList							localizeds;
			WString									memberScript;
			WString									ctorScript;
			WString									dtorScript;

			GuiResourceTextPos						tagPosition;
			GuiResourceTextPos						classPosition;
			GuiResourceTextPos						stylePosition;
			GuiResourceTextPos						memberPosition;
			GuiResourceTextPos						ctorPosition;
			GuiResourceTextPos						dtorPosition;

			bool									appliedStyles = false;
			StyleContextList						styles;

			static void								CollectDefaultAttributes(Ptr<GuiResourceItem> resource, GuiAttSetterRepr::ValueList& values, Ptr<parsing::xml::XmlElement> xml, GuiResourceError::List& errors);
			static void								CollectAttributes(Ptr<GuiResourceItem> resource, GuiAttSetterRepr::SetteValuerMap& setters, Ptr<parsing::xml::XmlElement> xml, GuiResourceError::List& errors);
			static void								CollectEvents(Ptr<GuiResourceItem> resource, GuiAttSetterRepr::EventHandlerMap& eventHandlers, Ptr<parsing::xml::XmlElement> xml, GuiResourceError::List& errors);
			static void								FillAttSetter(Ptr<GuiResourceItem> resource, Ptr<GuiAttSetterRepr> setter, Ptr<parsing::xml::XmlElement> xml, GuiResourceError::List& errors);
			static Ptr<GuiConstructorRepr>			LoadCtor(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlElement> xml, GuiResourceError::List& errors);
			static Ptr<GuiInstanceContext>			LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
			bool									ApplyStyles(Ptr<GuiResourceItem> resource, Ptr<GuiResourcePathResolver> resolver, GuiResourceError::List& errors);
		};

/***********************************************************************
Instance Style Context
***********************************************************************/

		class GuiInstanceStyle : public Object, public Description<GuiInstanceStyle>
		{
		public:
			Ptr<GuiIqQuery>							query;
			Ptr<GuiAttSetterRepr>					setter;

			static Ptr<GuiInstanceStyle>			LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlElement> xml, GuiResourceError::List& errors);
			Ptr<parsing::xml::XmlElement>			SaveToXml();
		};

		class GuiInstanceStyleContext : public Object, public Description<GuiInstanceStyleContext>
		{
			typedef collections::List<Ptr<GuiInstanceStyle>>		StyleList;
		public:
			StyleList								styles;

			static Ptr<GuiInstanceStyleContext>		LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
		};
	}
}

#endif

/***********************************************************************
.\GUIINSTANCEHELPERTYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Helper Types

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEHELPERTYPES
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEHELPERTYPES


#if defined(__APPLE__) || defined(__APPLE_CC__)

using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::templates;
using namespace vl::presentation::theme;

#endif

namespace vl
{
	namespace presentation
	{

/***********************************************************************
Helper Types
***********************************************************************/

		namespace helper_types
		{
			struct SiteValue
			{
				vint			row = 0;
				vint			column = 0;
				vint			rowSpan = 1;
				vint			columnSpan = 1;
			};
		}
	}

#ifndef VCZH_DEBUG_NO_REFLECTION

	namespace reflection
	{
		namespace description
		{

/***********************************************************************
Type List
***********************************************************************/

#define GUIREFLECTIONHELPERTYPES_TYPELIST(F)\
			F(presentation::helper_types::SiteValue)\

			GUIREFLECTIONHELPERTYPES_TYPELIST(DECL_TYPE_INFO)
		}
	}

#endif
}

#endif

/***********************************************************************
.\GUIINSTANCELOADER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifdef VCZH_DEBUG_NO_REFLECTION
static_assert(false, "Don't use GacUICompiler.(h|cpp) if VCZH_DEBUG_NO_REFLECTION is defined.");
#endif

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOADER
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOADER


namespace vl
{
	namespace presentation
	{
		namespace types
		{
			struct ResolvingResult;
		}

/***********************************************************************
Instance Loader
***********************************************************************/

		class GuiInstancePropertyInfo : public IDescriptable, public Description<GuiInstancePropertyInfo>
		{
			typedef collections::List<Ptr<description::ITypeInfo>>		TypeInfoList;
		public:
			enum Support
			{
				NotSupport,
				SupportAssign,
				SupportArray,
				SupportCollection,
				SupportSet,
			};

			enum PropertyUsage
			{
				ConstructorArgument,
				Property,
			};

			enum PropertyBindability
			{
				Bindable,
				NotBindable,
			};

			enum PropertyMergability
			{
				MergeWithParent,
				NotMerge,
			};

			Support									support = NotSupport;
			PropertyUsage							usage = Property;
			PropertyBindability						bindability = NotBindable;
			PropertyMergability						mergability = NotMerge;
			TypeInfoList							acceptableTypes;

			static Ptr<GuiInstancePropertyInfo>		Unsupported();
			static Ptr<GuiInstancePropertyInfo>		Assign(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		AssignWithParent(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		Collection(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		CollectionWithParent(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		Set(Ptr<description::ITypeInfo> typeInfo);
			static Ptr<GuiInstancePropertyInfo>		Array(Ptr<description::ITypeInfo> typeInfo);
		};

		class IGuiInstanceLoader : public IDescriptable, public Description<IGuiInstanceLoader>
		{
		public:
			struct TypeInfo
			{
				GlobalStringKey						typeName;
				Ptr<description::ITypeInfo>			typeInfo = nullptr;

				TypeInfo()
				{
				}

				TypeInfo(GlobalStringKey _typeName, Ptr<description::ITypeInfo> _typeInfo)
					:typeName(_typeName)
					, typeInfo(_typeInfo)
				{
				}
			};

			struct PropertyInfo
			{
				TypeInfo							typeInfo;
				GlobalStringKey						propertyName;

				PropertyInfo(){}
				PropertyInfo(const TypeInfo& _typeInfo, GlobalStringKey _propertyName)
					:typeInfo(_typeInfo)
					, propertyName(_propertyName)
				{
				}
			};

			struct PropertyValue : PropertyInfo
			{
				description::Value					instanceValue;
				description::Value					propertyValue;

				PropertyValue(){}
				PropertyValue(const TypeInfo& _typeInfo, GlobalStringKey _propertyName, description::Value _instanceValue, description::Value _propertyValue = description::Value())
					:PropertyInfo(_typeInfo, _propertyName)
					, instanceValue(_instanceValue)
					, propertyValue(_propertyValue)
				{
				}
			};

			struct ArgumentInfo
			{
				Ptr<workflow::WfExpression>			expression;
				Ptr<description::ITypeInfo>			typeInfo;
				GuiResourceTextPos					attPosition;
				GuiResourceTextPos					valuePosition;				// only apply to text value
			};

			typedef collections::Group<GlobalStringKey, ArgumentInfo>	ArgumentMap;

			virtual GlobalStringKey							GetTypeName() = 0;
			virtual void									ClearReflectionCache();

			virtual void									GetRequiredPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void									GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual void									GetPairedProperties(const PropertyInfo& propertyInfo, collections::List<GlobalStringKey>& propertyNames);
			virtual Ptr<GuiInstancePropertyInfo>			GetPropertyType(const PropertyInfo& propertyInfo);

			virtual bool									CanCreate(const TypeInfo& typeInfo);
			virtual Ptr<workflow::WfBaseConstructorCall>	CreateRootInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, ArgumentMap& arguments, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfStatement>				InitializeRootInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfStatement>				CreateInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceTextPos tagPosition, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfStatement>				AssignParameters(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
			virtual Ptr<workflow::WfExpression>				GetParameter(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const PropertyInfo& propertyInfo, GlobalStringKey variableName, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		};

/***********************************************************************
Instance Binder
***********************************************************************/

		class IGuiInstanceBinder : public IDescriptable, public Description<IGuiInstanceBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual bool							ApplicableToConstructorArgument() = 0;
			virtual bool							RequirePropertyExist() = 0;
			virtual Ptr<workflow::WfExpression>		GenerateConstructorArgument(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, GuiResourceTextPos position, GuiResourceError::List& errors) = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, GuiResourceTextPos position, GuiResourceError::List& errors) = 0;
		};

		class IGuiInstanceEventBinder : public IDescriptable, public Description<IGuiInstanceEventBinder>
		{
		public:
			virtual GlobalStringKey					GetBindingName() = 0;
			virtual Ptr<workflow::WfStatement>		GenerateInstallStatement(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& code, GuiResourceTextPos position, GuiResourceError::List& errors) = 0;
		};

		class IGuiInstanceDeserializer : public IDescriptable, public Description<IGuiInstanceDeserializer>
		{
		public:
			virtual bool							CanDeserialize(const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo) = 0;
			virtual description::ITypeInfo*			DeserializeAs(const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo) = 0;
			virtual Ptr<workflow::WfExpression>		Deserialize(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo, Ptr<workflow::WfExpression> valueExpression, GuiResourceTextPos tagPosition, GuiResourceError::List& errors) = 0;
		};

/***********************************************************************
Instance Loader Manager
***********************************************************************/

		class IGuiInstanceLoaderManager : public IDescriptable, public Description<IGuiInstanceLoaderManager>
		{
		public:
			virtual bool							AddInstanceBinder(Ptr<IGuiInstanceBinder> binder) = 0;
			virtual IGuiInstanceBinder*				GetInstanceBinder(GlobalStringKey bindingName) = 0;
			virtual bool							AddInstanceEventBinder(Ptr<IGuiInstanceEventBinder> binder) = 0;
			virtual IGuiInstanceEventBinder*		GetInstanceEventBinder(GlobalStringKey bindingName) = 0;
			virtual bool							AddInstanceDeserializer(Ptr<IGuiInstanceDeserializer> deserializer) = 0;
			virtual IGuiInstanceDeserializer*		GetInstanceDeserializer(const IGuiInstanceLoader::PropertyInfo& propertyInfo, description::ITypeInfo* typeInfo) = 0;

			virtual bool							CreateVirtualType(GlobalStringKey parentType, Ptr<IGuiInstanceLoader> loader) = 0;
			virtual bool							SetLoader(Ptr<IGuiInstanceLoader> loader) = 0;
			virtual IGuiInstanceLoader*				GetLoader(GlobalStringKey typeName) = 0;
			virtual IGuiInstanceLoader*				GetParentLoader(IGuiInstanceLoader* loader) = 0;
			virtual Ptr<description::ITypeInfo>		GetTypeInfoForType(GlobalStringKey typeName) = 0;
			virtual void							GetVirtualTypes(collections::List<GlobalStringKey>& typeNames) = 0;
			virtual GlobalStringKey					GetParentTypeForVirtualType(GlobalStringKey virtualType) = 0;
			virtual void							ClearReflectionCache() = 0;
		};

		extern IGuiInstanceLoaderManager*			GetInstanceLoaderManager();

/***********************************************************************
Helper Functions
***********************************************************************/

		extern void									SplitTypeName(const WString& input, collections::List<WString>& fragments);
		extern void									SplitBySemicolon(const WString& input, collections::List<WString>& fragments);
	}
}

#endif

/***********************************************************************
.\WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWCODEGEN.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Schema Representation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESCHE_WORKFLOWCODEGEN


namespace vl
{
	namespace presentation
	{
		namespace types
		{
			struct PropertyResolving
			{
				IGuiInstanceLoader*								loader = nullptr;
				IGuiInstanceLoader::PropertyInfo				propertyInfo;
				Ptr<GuiInstancePropertyInfo>					info;
			};

			typedef collections::Dictionary<GlobalStringKey, IGuiInstanceLoader::TypeInfo>		VariableTypeInfoMap;
			typedef collections::Dictionary<GlobalStringKey, Ptr<description::ITypeInfo>>		TypeOverrideMap;
			typedef collections::Dictionary<GuiValueRepr*, PropertyResolving>					PropertyResolvingMap;
			typedef collections::Group<GlobalStringKey, Ptr<GuiAttSetterRepr::EnvVarValue>>		EnvironmentVariableGroup;

			struct ResolvingResult : public Object, public Description<ResolvingResult>
			{
				Ptr<GuiResourceItem>							resource;						// compiling resource
				Ptr<GuiInstanceContext>							context;						// compiling context
				IGuiInstanceLoader::TypeInfo					rootTypeInfo;					// type of the context
				EnvironmentVariableGroup						envVars;						// current environment variable value stacks

				collections::List<GlobalStringKey>				referenceNames;					// all reference names
				IGuiInstanceLoader::ArgumentMap					rootCtorArguments;
				IGuiInstanceLoader*								rootLoader = nullptr;

				VariableTypeInfoMap								typeInfos;						// type of references
				PropertyResolvingMap							propertyResolvings;				// information of property values which are calling constructors
			};
		}
		extern workflow::analyzer::WfLexicalScopeManager*		Workflow_GetSharedManager();
		extern Ptr<workflow::analyzer::WfLexicalScopeManager>	Workflow_TransferSharedManager();
		

/***********************************************************************
WorkflowCompiler (Parser)
***********************************************************************/

		extern Ptr<workflow::WfType>							Workflow_ParseType					(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfExpression>						Workflow_ParseExpression			(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfStatement>						Workflow_ParseStatement				(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfStatement>						Workflow_ParseCoProviderStatement	(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<workflow::WfModule>							Workflow_ParseModule				(GuiResourcePrecompileContext& precompileContext, GuiResourceLocation location, const WString& code, GuiResourceTextPos position, collections::List<GuiResourceError>& errors, parsing::ParsingTextPos availableAfter = { 0,0 });

		extern WString											Workflow_ModuleToString(Ptr<workflow::WfModule> module);
		extern Ptr<workflow::WfExpression>						Workflow_ParseTextValue(GuiResourcePrecompileContext& precompileContext, description::ITypeDescriptor* typeDescriptor, GuiResourceLocation location, const WString& textValue, GuiResourceTextPos position, collections::List<GuiResourceError>& errors);

/***********************************************************************
WorkflowCompiler (Installation)
***********************************************************************/

		extern Ptr<workflow::WfExpression>						Workflow_GetUriProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& protocol, const WString& path, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallUriProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& protocol, const WString& path, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallBindProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, Ptr<workflow::WfExpression> bindExpression);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalProperty(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, Ptr<workflow::WfExpression> evalExpression, GuiResourceTextPos attPosition, GuiResourceError::List& errors);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvent(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& handlerName);
		extern Ptr<workflow::WfFunctionDeclaration>				Workflow_GenerateEventHandler(GuiResourcePrecompileContext& precompileContext, description::IEventInfo* eventInfo);
		extern Ptr<workflow::WfStatement>						Workflow_InstallEvalEvent(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GlobalStringKey variableName, description::IEventInfo* eventInfo, Ptr<workflow::WfStatement> evalStatement);

/***********************************************************************
WorkflowCompiler (Compile)
***********************************************************************/

		extern Ptr<workflow::WfModule>							Workflow_CreateModuleWithUsings(Ptr<GuiInstanceContext> context, const WString& moduleName);
		extern Ptr<workflow::WfClassDeclaration>				Workflow_InstallClass(const WString& className, Ptr<workflow::WfModule> module);
		extern Ptr<workflow::WfBlockStatement>					Workflow_InstallCtorClass(types::ResolvingResult& resolvingResult, Ptr<workflow::WfModule> module);

		extern void												Workflow_CreatePointerVariable(Ptr<workflow::WfClassDeclaration> ctorClass, GlobalStringKey name, description::ITypeInfo* typeInfo);
		extern void												Workflow_CreateVariablesForReferenceValues(Ptr<workflow::WfClassDeclaration> ctorClass, types::ResolvingResult& resolvingResult);
		
		struct InstanceLoadingSource
		{
			IGuiInstanceLoader*						loader;
			GlobalStringKey							typeName;
			Ptr<GuiResourceItem>					item;
			Ptr<GuiInstanceContext>					context;

			InstanceLoadingSource()
				:loader(0)
			{
			}

			InstanceLoadingSource(IGuiInstanceLoader* _loader, GlobalStringKey _typeName)
				:loader(_loader)
				, typeName(_typeName)
			{
			}

			InstanceLoadingSource(Ptr<GuiResourceItem> _item)
				:loader(0)
				, item(_item)
				, context(item->GetContent().Cast<GuiInstanceContext>())
			{
			}

			operator bool()const
			{
				return loader != 0 || context;
			}
		};

		extern IGuiInstanceLoader::TypeInfo						Workflow_AdjustPropertySearchType(types::ResolvingResult& resolvingResult, IGuiInstanceLoader::TypeInfo resolvedTypeInfo, GlobalStringKey prop);
		extern bool												Workflow_GetPropertyTypes(WString& errorPrefix, types::ResolvingResult& resolvingResult, IGuiInstanceLoader* loader, IGuiInstanceLoader::TypeInfo resolvedTypeInfo, GlobalStringKey prop, Ptr<GuiAttSetterRepr::SetterValue> setter, collections::List<types::PropertyResolving>& possibleInfos, GuiResourceError::List& errors);
		extern Ptr<reflection::description::ITypeInfo>			Workflow_GetSuggestedParameterType(reflection::description::ITypeDescriptor* typeDescriptor);
		extern IGuiInstanceLoader::TypeInfo						Workflow_CollectReferences(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, GuiResourceError::List& errors);
		extern void												Workflow_GenerateCreating(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, Ptr<workflow::WfBlockStatement> statements, GuiResourceError::List& errors);
		extern void												Workflow_GenerateBindings(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, Ptr<workflow::WfBlockStatement> statements, GuiResourceError::List& errors);

		extern InstanceLoadingSource							FindInstanceLoadingSource(Ptr<GuiInstanceContext> context, GlobalStringKey namespaceName, const WString& typeName);
		extern Ptr<GuiResourceItem>								FindInstanceResourceItem(Ptr<GuiInstanceContext> context, GuiConstructorRepr* ctor, Ptr<GuiResourceClassNameRecord> record);
		extern InstanceLoadingSource							FindInstanceLoadingSource(Ptr<GuiInstanceContext> context, GuiConstructorRepr* ctor);
		extern Ptr<workflow::WfModule>							Workflow_PrecompileInstanceContext(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, types::ResolvingResult& resolvingResult, GuiResourceError::List& errors);
		extern Ptr<workflow::WfModule>							Workflow_GenerateInstanceClass(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, types::ResolvingResult& resolvingResult, GuiResourceError::List& errors, vint passIndex);

#define WORKFLOW_ENVIRONMENT_VARIABLE_ADD\
		FOREACH_INDEXER(GlobalStringKey, envVar, index, repr->environmentVariables.Keys())\
		{\
			auto value = repr->environmentVariables.Values()[index];\
			resolvingResult.envVars.Add(envVar, value);\
		}\

#define WORKFLOW_ENVIRONMENT_VARIABLE_REMOVE\
		FOREACH_INDEXER(GlobalStringKey, envVar, index, repr->environmentVariables.Keys())\
		{\
			auto value = repr->environmentVariables.Values()[index];\
			resolvingResult.envVars.Remove(envVar, value.Obj());\
		}\

/***********************************************************************
WorkflowCompiler (ScriptPosition)
***********************************************************************/

		namespace types
		{
			struct ScriptPositionRecord
			{
				GuiResourceTextPos								position;
				parsing::ParsingTextPos							availableAfter;
				GuiResourceTextPos								computedPosition;
			};

			class ScriptPosition : public Object, public Description<ScriptPosition>
			{
				using NodePositionMap = collections::Dictionary<Ptr<parsing::ParsingTreeCustomBase>, ScriptPositionRecord>;
			public:
				NodePositionMap									nodePositions;
			};
		}

		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfType> node, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfExpression> node, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfStatement> node, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfDeclaration> node, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern void												Workflow_RecordScriptPosition(GuiResourcePrecompileContext& context, GuiResourceTextPos position, Ptr<workflow::WfModule> node, parsing::ParsingTextPos availableAfter = { 0,0 });
		extern Ptr<types::ScriptPosition>						Workflow_GetScriptPosition(GuiResourcePrecompileContext& context);
		extern void												Workflow_ClearScriptPosition(GuiResourcePrecompileContext& context);

	}
}

#endif

/***********************************************************************
.\GUICPPGEN.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUICPPGEN
#define VCZH_PRESENTATION_REFLECTION_GUICPPGEN


namespace vl
{
	namespace presentation
	{
		extern bool										WriteErrors(
															collections::List<GuiResourceError>& errors,
															const filesystem::FilePath& errorPath
															);

		extern Ptr<GuiResourceFolder>					PrecompileResource(
															Ptr<GuiResource> resource,
															IGuiResourcePrecompileCallback* callback,
															collections::List<GuiResourceError>& errors);

		extern Ptr<GuiInstanceCompiledWorkflow>			WriteWorkflowScript(
															Ptr<GuiResourceFolder> precompiledFolder,
															const WString& assemblyResourcePath,
															const filesystem::FilePath& workflowPath);

		extern Ptr<workflow::cppcodegen::WfCppOutput>	WriteCppCodesToFile(
															Ptr<GuiResource> resource,
															Ptr<GuiInstanceCompiledWorkflow> compiled,
															Ptr<workflow::cppcodegen::WfCppInput> cppInput,
															const filesystem::FilePath& cppFolder,
															collections::List<GuiResourceError>& errors);

		extern bool										WriteBinaryResource(
															Ptr<GuiResource> resource,
															bool compress,
															bool includeAssemblyInResource,
															Nullable<filesystem::FilePath> resourceOutput,
															Nullable<filesystem::FilePath> assemblyOutput);

		extern bool										WriteEmbeddedResource(Ptr<GuiResource> resource,
															Ptr<workflow::cppcodegen::WfCppInput> cppInput,
															Ptr<workflow::cppcodegen::WfCppOutput> cppOutput,
															bool compress,
															const filesystem::FilePath& filePath);
	}
}

#endif


/***********************************************************************
.\GUIINSTANCEANIMATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCEANIMATION
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCEANIMATION


namespace vl
{
	namespace presentation
	{
		class GuiInstanceAnimation : public Object, public Description<GuiInstanceAnimation>
		{
		public:
		};

		class GuiInstanceGradientAnimation : public GuiInstanceAnimation, public Description<GuiInstanceGradientAnimation>
		{
		public:
			struct Target
			{
				WString									name;
				WString									interpolation;

				GuiResourceTextPos						namePosition;
				GuiResourceTextPos						interpolationPosition;
			};

			using EnumerateMemberAccessor = const Func<Ptr<workflow::WfExpression>(Ptr<workflow::WfExpression>)>&;
			using EnumerateMemberCallback = const Func<void(EnumerateMemberAccessor, description::IPropertyInfo*, description::IPropertyInfo*)>&;

			WString										className;
			WString										typeName;
			WString										interpolation;
			collections::List<Target>					targets;

			GuiResourceTextPos							tagPosition;
			GuiResourceTextPos							classPosition;
			GuiResourceTextPos							typePosition;
			GuiResourceTextPos							interpolationPosition;

			static Ptr<GuiInstanceGradientAnimation>	LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<parsing::xml::XmlElement>				SaveToXml();

			bool										IsSupportedPrimitiveType(description::ITypeDescriptor* td);
			vint										ValidateStructMembers(GuiResourceTextPos namePosition, description::ITypeDescriptor* td, const WString& prefix, GuiResourceError::List& errors);
			vint										ValidatePropertyType(GuiResourceTextPos namePosition, description::ITypeInfo* typeInfo, const WString& prefix, GuiResourceError::List& errors, bool rootValue = false);

			void										EnumerateMembers(EnumerateMemberCallback callback, EnumerateMemberAccessor accessor, description::IPropertyInfo* propInfo, description::IPropertyInfo* originPropInfo);
			void										EnumerateMembers(EnumerateMemberCallback callback, EnumerateMemberAccessor accessor, description::ITypeDescriptor* td, description::IPropertyInfo* originPropInfo);
			void										EnumerateProperties(EnumerateMemberCallback callback, description::ITypeDescriptor* td);
			Ptr<workflow::WfExpression>					InitStruct(description::IPropertyInfo* propInfo, const WString& prefix, collections::SortedList<WString>& varNames);
			Ptr<workflow::WfModule>						Compile(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, bool generateImpl, GuiResourceError::List& errors);
		};
	}
}

#endif

/***********************************************************************
.\INSTANCEQUERY\GUIINSTANCEQUERY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Query

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY
#define VCZH_PRESENTATION_REFLECTION_INSTANCEQUERY_GUIINSTANCEQUERY


namespace vl
{
	namespace presentation
	{
		extern void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& input, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& output);
		extern void ApplyStyle(Ptr<GuiInstanceStyle> style, Ptr<GuiConstructorRepr> ctor);
		extern void GuiIqPrint(Ptr<GuiIqQuery> query, stream::StreamWriter& writer);
	}
}

#endif

/***********************************************************************
.\GUIINSTANCESHAREDSCRIPT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCESHAREDSCRIPT


namespace vl
{
	namespace presentation
	{
		class GuiInstanceSharedScript :public Object, public Description<GuiInstanceSharedScript>
		{
		public:
			WString										language;
			WString										code;
			GuiResourceTextPos							codePosition;

			static Ptr<GuiInstanceSharedScript>			LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<parsing::xml::XmlElement>				SaveToXml();
		};
	}
}

#endif

/***********************************************************************
.\GUIINSTANCELOCALIZEDSTRINGS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Shared Script

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOCALIZEDSTRINGS
#define VCZH_PRESENTATION_REFLECTION_GUIINSTANCELOCALIZEDSTRINGS


namespace vl
{
	namespace presentation
	{
		class GuiInstanceLocalizedStrings : public Object, public Description<GuiInstanceLocalizedStrings>
		{
		public:
			struct StringItem
			{
			public:
				WString									name;
				WString									text;
				GuiResourceTextPos						textPosition;
			};

			struct Strings
			{
				using StringItemMap = collections::Dictionary<WString, Ptr<StringItem>>;

				collections::List<WString>				locales;
				StringItemMap							items;
				GuiResourceTextPos						tagPosition;

				WString									GetLocalesName();
			};

			WString										className;
			WString										defaultLocale;
			collections::List<Ptr<Strings>>				strings;
			GuiResourceTextPos							tagPosition;

			using ParameterPair = collections::Pair<Ptr<reflection::description::ITypeInfo>, WString>;
			using ParameterList = collections::List<ParameterPair>;
			using PositionList = collections::List<vint>;
			using TextList = collections::List<WString>;

			struct TextDesc
			{
				ParameterList							parameters;
				PositionList							positions;
				TextList								texts;
			};

			using TextDescMap = collections::Dictionary<collections::Pair<Ptr<Strings>, WString>, Ptr<TextDesc>>;

			static Ptr<GuiInstanceLocalizedStrings>		LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlDocument> xml, GuiResourceError::List& errors);
			Ptr<parsing::xml::XmlElement>				SaveToXml();

			Ptr<Strings>								GetDefaultStrings();
			WString										GetInterfaceTypeName(bool hasNamespace);

			Ptr<TextDesc>								ParseLocalizedText(const WString& text, GuiResourceTextPos pos, GuiResourceError::List& errors);
			void										Validate(TextDescMap& textDescs, GuiResourcePrecompileContext& precompileContext, GuiResourceError::List& errors);
			Ptr<workflow::WfFunctionDeclaration>		GenerateFunction(Ptr<TextDesc> textDesc, const WString& functionName, workflow::WfClassMemberKind classMemberKind);
			Ptr<workflow::WfExpression>					GenerateStrings(TextDescMap& textDescs, Ptr<Strings> ls);
			Ptr<workflow::WfModule>						Compile(GuiResourcePrecompileContext& precompileContext, const WString& moduleName, GuiResourceError::List& errors);
		};
	}
}

#endif

/***********************************************************************
.\INSTANCELOADERS\GUIINSTANCELOADER_TEMPLATECONTROL.H
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL
#define VCZH_PRESENTATION_REFLECTION_INSTANCELOADERS_GUIINSTANCELOADER_TEMPLATECONTROL

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace controls;
			using namespace compositions;
			using namespace theme;
			using namespace helper_types;

			using namespace elements;
			using namespace compositions;
			using namespace controls;
			using namespace templates;

			using namespace workflow;
			using namespace workflow::analyzer;

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
GuiVrtualTypeInstanceLoader
***********************************************************************/

			template<typename TControl>
			class GuiTemplateControlInstanceLoader : public Object, public IGuiInstanceLoader
			{
				typedef Ptr<WfExpression>							ArgumentRawFunctionType(ArgumentMap&);
				typedef void										InitRawFunctionType(const WString&, Ptr<WfBlockStatement>);
				typedef Func<ArgumentRawFunctionType>				ArgumentFunctionType;
				typedef Func<InitRawFunctionType>					InitFunctionType;

			protected:
				GlobalStringKey								typeName;
				theme::ThemeName							themeName;
				ArgumentFunctionType						argumentFunction;
				InitFunctionType							initFunction;

				virtual void AddAdditionalArguments(types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceError::List& errors, Ptr<WfNewClassExpression> createControl)
				{
				}
			public:
				static Ptr<WfExpression> CreateThemeName(theme::ThemeName themeName)
				{
					auto refExpr = MakePtr<WfChildExpression>();
					refExpr->parent = GetExpressionFromTypeDescriptor(description::GetTypeDescriptor<ThemeName>());
					switch (themeName)
					{
#define THEME_NAME_CASE(TEMPLATE, CONTROL) case theme::ThemeName::CONTROL: refExpr->name.value = L ## #CONTROL; break;
						GUI_CONTROL_TEMPLATE_TYPES(THEME_NAME_CASE)
#undef THEME_NAME_CASE
					default:
						CHECK_FAIL(L"GuiTemplateControlInstanceLoader::CreateThemeName()#Unknown theme name.");
					}
					return refExpr;
				}

			public:
				GuiTemplateControlInstanceLoader(const WString& _typeName, theme::ThemeName _themeName, ArgumentRawFunctionType* _argumentFunction = nullptr, InitRawFunctionType* _initFunction = nullptr)
					:typeName(GlobalStringKey::Get(_typeName))
					, themeName(_themeName)
				{
					if (_argumentFunction) argumentFunction = _argumentFunction;
					if (_initFunction) initFunction = _initFunction;
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				bool CanCreate(const TypeInfo& typeInfo)override
				{
					return typeName == typeInfo.typeName;
				}

				Ptr<workflow::WfBaseConstructorCall> CreateRootInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, ArgumentMap& arguments, GuiResourceError::List& errors)override
				{
					auto createControl = MakePtr<WfBaseConstructorCall>();
					createControl->type = GetTypeFromTypeInfo(TypeInfoRetriver<TControl>::CreateTypeInfo().Obj());
					createControl->arguments.Add(CreateThemeName(themeName));
					return createControl;
				}

				Ptr<workflow::WfStatement> CreateInstance(GuiResourcePrecompileContext& precompileContext, types::ResolvingResult& resolvingResult, const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, GuiResourceTextPos tagPosition, GuiResourceError::List& errors)override
				{
					CHECK_ERROR(CanCreate(typeInfo), L"GuiTemplateControlInstanceLoader::CreateInstance()#Wrong type info is provided.");

					auto block = MakePtr<WfBlockStatement>();
					{
						auto controlType = TypeInfoRetriver<TControl*>::CreateTypeInfo();

						auto createControl = MakePtr<WfNewClassExpression>();
						createControl->type = GetTypeFromTypeInfo(controlType.Obj());
						createControl->arguments.Add(CreateThemeName(themeName));

						if (argumentFunction)
						{
							createControl->arguments.Add(argumentFunction(arguments));
						}
						AddAdditionalArguments(resolvingResult, typeInfo, variableName, arguments, errors, createControl);

						auto refVariable = MakePtr<WfReferenceExpression>();
						refVariable->name.value = variableName.ToString();

						auto assignExpr = MakePtr<WfBinaryExpression>();
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refVariable;
						assignExpr->second = createControl;

						auto assignStat = MakePtr<WfExpressionStatement>();
						assignStat->expression = assignExpr;
						block->statements.Add(assignStat);
					}

					if (initFunction)
					{
						initFunction(variableName.ToString(), block);
					}
					return block;
				}
			};
#endif
		}
	}
}
#endif

