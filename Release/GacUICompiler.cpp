/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "GacUICompiler.h"

/***********************************************************************
GUIINSTANCEHELPERTYPES.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace helper_types
		{
		}
	}

#ifndef VCZH_DEBUG_NO_REFLECTION

	namespace reflection
	{
		namespace description
		{
			using namespace presentation::helper_types;

/***********************************************************************
Type Declaration
***********************************************************************/

			GUIREFLECTIONHELPERTYPES_TYPELIST(IMPL_VL_TYPE_INFO)

#define _ ,

			BEGIN_STRUCT_MEMBER(SiteValue)
				STRUCT_MEMBER(row)
				STRUCT_MEMBER(column)
				STRUCT_MEMBER(rowSpan)
				STRUCT_MEMBER(columnSpan)
			END_STRUCT_MEMBER(SiteValue)

			BEGIN_ENUM_ITEM(ListViewViewType)
				ENUM_ITEM_NAMESPACE(ListViewViewType)
				ENUM_NAMESPACE_ITEM(BigIcon)
				ENUM_NAMESPACE_ITEM(SmallIcon)
				ENUM_NAMESPACE_ITEM(List)
				ENUM_NAMESPACE_ITEM(Tile)
				ENUM_NAMESPACE_ITEM(Information)
				ENUM_NAMESPACE_ITEM(Detail)
			END_ENUM_ITEM(ListViewViewType)

#undef _
		}
	}

	namespace presentation
	{
		using namespace reflection::description;
		using namespace controls;

/***********************************************************************
Type Loader
***********************************************************************/

		class GuiHelperTypesLoader : public Object, public ITypeLoader
		{
		public:
			void Load(ITypeManager* manager)
			{
				GUIREFLECTIONHELPERTYPES_TYPELIST(ADD_TYPE_INFO)
			}

			void Unload(ITypeManager* manager)
			{
			}
		};

/***********************************************************************
GuiHelperTypesLoaderPlugin
***********************************************************************/

		class GuiHelperTypesLoaderPlugin : public Object, public IGuiPlugin
		{
		public:
			void Load()override
			{
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiHelperTypesLoader;
					manager->AddTypeLoader(loader);
				}
			}

			void AfterLoad()override
			{
			}

			void Unload()override
			{
			}
		};
		GUI_REGISTER_PLUGIN(GuiHelperTypesLoaderPlugin)
	}
#endif
}

/***********************************************************************
GUIINSTANCELOADER.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace parsing;
		using namespace parsing::xml;
		using namespace parsing::tabling;
		using namespace controls;
		using namespace regex;
		using namespace reflection::description;
		using namespace stream;
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace workflow::typeimpl;

/***********************************************************************
GuiInstancePropertyInfo
***********************************************************************/

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Unsupported()
		{
			return new GuiInstancePropertyInfo;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Assign(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = new GuiInstancePropertyInfo;
			info->support = SupportAssign;
			if (typeDescriptor) info->acceptableTypes.Add(typeDescriptor);
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::AssignWithParent(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = Assign(typeDescriptor);
			info->tryParent = true;
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Collection(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = Assign(typeDescriptor);
			info->support = SupportCollection;
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::CollectionWithParent(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = Collection(typeDescriptor);
			info->tryParent = true;
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Set(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = new GuiInstancePropertyInfo;
			info->support = SupportSet;
			if (typeDescriptor) info->acceptableTypes.Add(typeDescriptor);
			return info;
		}

		Ptr<GuiInstancePropertyInfo> GuiInstancePropertyInfo::Array(description::ITypeDescriptor* typeDescriptor)
		{
			Ptr<GuiInstancePropertyInfo> info = new GuiInstancePropertyInfo;
			info->support = SupportArray;
			if (typeDescriptor) info->acceptableTypes.Add(typeDescriptor);
			return info;
		}

/***********************************************************************
IGuiInstanceLoader
***********************************************************************/

		void IGuiInstanceLoader::ClearReflectionCache()
		{
		}

		void IGuiInstanceLoader::GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)
		{
		}

		void IGuiInstanceLoader::GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)
		{
		}

		void IGuiInstanceLoader::GetPairedProperties(const PropertyInfo& propertyInfo, collections::List<GlobalStringKey>& propertyNames)
		{
		}

		Ptr<GuiInstancePropertyInfo> IGuiInstanceLoader::GetPropertyType(const PropertyInfo& propertyInfo)
		{
			return nullptr;
		}

		bool IGuiInstanceLoader::CanCreate(const TypeInfo& typeInfo)
		{
			return false;
		}

		Ptr<workflow::WfBaseConstructorCall> IGuiInstanceLoader::CreateRootInstance(const TypeInfo& typeInfo, Ptr<workflow::WfExpression> controlTemplate, collections::List<WString>& errors)
		{
			CHECK_FAIL(L"IGuiInstanceLoader::CreateControlTemplateArgument(const TypeInfo&, Ptr<workflow::WfExpression>, collections::List<WString>&)#This function is not implemented.");
		}

		Ptr<workflow::WfStatement> IGuiInstanceLoader::CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)
		{
			CHECK_FAIL(L"IGuiInstanceLoader::CreateInstance(const TypeInfo&, GlobalStringKey, ArgumentMap&, collections::List<WString>&)#This function is not implemented.");
		}

		Ptr<workflow::WfStatement> IGuiInstanceLoader::AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)
		{
			CHECK_FAIL(L"IGuiInstanceLoader::AssignParameters(const TypeInfo&, GlobalStringKey, ArgumentMap&, collections::List<WString>&)#This function is not implemented.");
		}

		Ptr<workflow::WfExpression> IGuiInstanceLoader::GetParameter(const PropertyInfo& propertyInfo, GlobalStringKey variableName, collections::List<WString>& errors)
		{
			CHECK_FAIL(L"IGuiInstanceLoader::GetParameter(const PropertyInfo&, GlobalStringKey, collections::List<WString>&)#This function is not implemented.");
		}

/***********************************************************************
GuiInstanceContext::ElementName Parser
***********************************************************************/

		class GuiInstanceContextElementNameParser : public Object, public IGuiParser<GuiInstanceContext::ElementName>
		{
			typedef GuiInstanceContext::ElementName			ElementName;
		public:
			Regex						regexElementName;

			GuiInstanceContextElementNameParser()
				:regexElementName(L"((<namespaceName>[a-zA-Z_]/w*):)?((<category>[a-zA-Z_]/w*).)?(<name>[a-zA-Z_]/w*)(-(<binding>[a-zA-Z_]/w*))?")
			{
			}

			Ptr<ElementName> TypedParse(const WString& text, collections::List<WString>& errors)override
			{
				Ptr<RegexMatch> match = regexElementName.MatchHead(text);
				if (!match || match->Result().Length() != text.Length())
				{
					errors.Add(L"Failed to parse an element name \"" + text + L"\".");
					return 0;
				}

				Ptr<ElementName> elementName = new ElementName;
				if (match->Groups().Keys().Contains(L"namespaceName"))
				{
					elementName->namespaceName = match->Groups()[L"namespaceName"][0].Value();
				}
				if (match->Groups().Keys().Contains(L"category"))
				{
					elementName->category = match->Groups()[L"category"][0].Value();
				}
				if (match->Groups().Keys().Contains(L"name"))
				{
					elementName->name = match->Groups()[L"name"][0].Value();
				}
				if (match->Groups().Keys().Contains(L"binding"))
				{
					elementName->binding = match->Groups()[L"binding"][0].Value();
				}
				return elementName;
			}
		};

/***********************************************************************
GuiDefaultInstanceLoader
***********************************************************************/

#define CTOR_PARAM_PREFIX\
		static const wchar_t Prefix[] = L"<ctor-parameter>";\
		static const vint PrefixLength = (vint)sizeof(Prefix) / sizeof(*Prefix) - 1;\

#define CTOR_PARAM_NAME(NAME) (NAME).Right((NAME).Length() - PrefixLength)

		class GuiDefaultInstanceLoader : public Object, public IGuiInstanceLoader
		{
		protected:
			typedef Tuple<ITypeDescriptor*, GlobalStringKey>				FieldKey;
			typedef Tuple<Ptr<GuiInstancePropertyInfo>, IPropertyInfo*>		PropertyType;

			Dictionary<FieldKey, PropertyType>								propertyTypes;
			Dictionary<ITypeDescriptor*, IMethodInfo*>						defaultConstructors;
			Dictionary<ITypeDescriptor*, IMethodInfo*>						instanceConstructors;
		public:
			IMethodInfo* GetDefaultConstructor(ITypeDescriptor* typeDescriptor)
			{
				IMethodInfo* ctor = nullptr;
				vint index = defaultConstructors.Keys().IndexOf(typeDescriptor);
				if (index == -1)
				{
					if (auto ctors = typeDescriptor->GetConstructorGroup())
					{
						vint count = ctors->GetMethodCount();
						for (vint i = 0; i < count; i++)
						{
							IMethodInfo* method = ctors->GetMethod(i);
							if (method->GetParameterCount() == 0)
							{
								ctor = method;
								break;
							}
						}
					}
					defaultConstructors.Add(typeDescriptor, ctor);
				}
				else
				{
					ctor = defaultConstructors.Values()[index];
				}
				return ctor;
			}

			IMethodInfo* GetInstanceConstructor(ITypeDescriptor* typeDescriptor)
			{
				CTOR_PARAM_PREFIX
					
				IMethodInfo* ctor = nullptr;
				vint index = instanceConstructors.Keys().IndexOf(typeDescriptor);
				if (index == -1)
				{
					if (dynamic_cast<WfClass*>(typeDescriptor))
					{
						if (auto group = typeDescriptor->GetConstructorGroup())
						{
							if (group->GetMethodCount() == 1)
							{
								auto method = group->GetMethod(0);
								vint count = method->GetParameterCount();
								for (vint i = 0; i < count; i++)
								{
									const auto& name = method->GetParameter(i)->GetName();
									if (name.Length() <= PrefixLength || name.Left(PrefixLength) != Prefix)
									{
										goto FINISHED;
									}

									if (!typeDescriptor->GetPropertyByName(CTOR_PARAM_NAME(name), false))
									{
										goto FINISHED;
									}
								}
								ctor = method;
							}
						}
					}
				FINISHED:
					instanceConstructors.Add(typeDescriptor, ctor);
				}
				else
				{
					ctor = instanceConstructors.Values()[index];
				}
				return ctor;
			}

			GlobalStringKey GetTypeName()override
			{
				return GlobalStringKey::Empty;
			}

			void ClearReflectionCache()override
			{
				propertyTypes.Clear();
				defaultConstructors.Clear();
				instanceConstructors.Clear();
			}

			//***********************************************************************************

			void ProcessGenericType(ITypeInfo* propType, ITypeInfo*& genericType, ITypeInfo*& elementType, bool& readableList, bool& writableList, bool& collectionType)
			{
				genericType = 0;
				elementType = 0;
				readableList = false;
				writableList = false;
				collectionType = false;
				if (propType->GetDecorator() == ITypeInfo::SharedPtr && propType->GetElementType()->GetDecorator() == ITypeInfo::Generic)
				{
					propType = propType->GetElementType();
					genericType = propType->GetElementType();
					if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
					{
						elementType = propType->GetGenericArgument(0);
						readableList = true;
						writableList = true;
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerator>())
					{
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>())
					{
						elementType = propType->GetGenericArgument(0);
						readableList = true;
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
					{
						elementType = propType->GetGenericArgument(0);
						readableList = true;
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
					{
						collectionType = true;
					}
					else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
					{
						collectionType = true;
					}
				}
			}

			ITypeInfo* GetPropertyReflectionTypeInfo(const PropertyInfo& propertyInfo, GuiInstancePropertyInfo::Support& support)
			{
				support = GuiInstancePropertyInfo::NotSupport;
				IPropertyInfo* prop = propertyInfo.typeInfo.typeDescriptor->GetPropertyByName(propertyInfo.propertyName.ToString(), true);
				if (prop)
				{
					ITypeInfo* propType = prop->GetReturn();
					ITypeInfo* genericType = 0;
					ITypeInfo* elementType = 0;
					bool readableList = false;
					bool writableList = false;
					bool collectionType = false;
					ProcessGenericType(propType, genericType, elementType, readableList, writableList, collectionType);

					if (prop->IsWritable())
					{
						if (collectionType)
						{
							if (readableList)
							{
								support = GuiInstancePropertyInfo::SupportArray;
								return elementType;
							}
						}
						else if (genericType)
						{
							support = GuiInstancePropertyInfo::SupportAssign;
							return genericType;
						}
						else
						{
							support = GuiInstancePropertyInfo::SupportAssign;
							return propType;
						}
					}
					else if (prop->IsReadable())
					{
						if (collectionType)
						{
							if (writableList)
							{
								support = GuiInstancePropertyInfo::SupportCollection;
								return elementType;
							}
						}
						else if (!genericType)
						{
							if (propType->GetDecorator() == ITypeInfo::SharedPtr || propType->GetDecorator() == ITypeInfo::RawPtr)
							{
								support = GuiInstancePropertyInfo::SupportSet;
								return propType;
							}
						}
					}
				}
				return 0;
			}

			bool FillPropertyInfo(Ptr<GuiInstancePropertyInfo> propertyInfo, ITypeInfo* propType)
			{
				switch (propType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					FillPropertyInfo(propertyInfo, propType->GetElementType());
					return true;
				case ITypeInfo::TypeDescriptor:
					propertyInfo->acceptableTypes.Add(propType->GetTypeDescriptor());
					return true;
				default:;
				}
				return false;
			}

			void CollectPropertyNames(const TypeInfo& typeInfo, ITypeDescriptor* typeDescriptor, collections::List<GlobalStringKey>& propertyNames)
			{
				vint propertyCount = typeDescriptor->GetPropertyCount();
				for (vint i = 0; i < propertyCount; i++)
				{
					GlobalStringKey propertyName = GlobalStringKey::Get(typeDescriptor->GetProperty(i)->GetName());
					if (!propertyNames.Contains(propertyName))
					{
						auto info = GetPropertyType(PropertyInfo(typeInfo, propertyName));
						if (info && info->support != GuiInstancePropertyInfo::NotSupport)
						{
							propertyNames.Add(propertyName);
						}
					}
				}

				vint parentCount = typeDescriptor->GetBaseTypeDescriptorCount();
				for (vint i = 0; i < parentCount; i++)
				{
					CollectPropertyNames(typeInfo, typeDescriptor->GetBaseTypeDescriptor(i), propertyNames);
				}
			}

			//***********************************************************************************

			void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				CollectPropertyNames(typeInfo, typeInfo.typeDescriptor, propertyNames);
			}

			void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
			{
				CTOR_PARAM_PREFIX

				if (auto ctor = GetInstanceConstructor(typeInfo.typeDescriptor))
				{
					vint count = ctor->GetParameterCount();
					for (vint i = 0; i < count; i++)
					{
						const auto& name = ctor->GetParameter(i)->GetName();
						propertyNames.Add(GlobalStringKey::Get(CTOR_PARAM_NAME(name)));
					}
				}
			}

			PropertyType GetPropertyTypeCached(const PropertyInfo& propertyInfo)
			{
				CTOR_PARAM_PREFIX

				FieldKey key(propertyInfo.typeInfo.typeDescriptor, propertyInfo.propertyName);
				vint index = propertyTypes.Keys().IndexOf(key);
				if (index == -1)
				{
					GuiInstancePropertyInfo::Support support = GuiInstancePropertyInfo::NotSupport;
					if (ITypeInfo* propType = GetPropertyReflectionTypeInfo(propertyInfo, support))
					{
						Ptr<GuiInstancePropertyInfo> result = new GuiInstancePropertyInfo;
						result->support = support;

						if (auto ctor = GetInstanceConstructor(propertyInfo.typeInfo.typeDescriptor))
						{
							vint count = ctor->GetParameterCount();
							for (vint i = 0; i < count; i++)
							{
								const auto& name = ctor->GetParameter(i)->GetName();
								if (CTOR_PARAM_NAME(name) == propertyInfo.propertyName.ToString())
								{
									result->scope = GuiInstancePropertyInfo::ViewModel;
								}
							}
						}

						if (FillPropertyInfo(result, propType))
						{
							IPropertyInfo* prop = propertyInfo.typeInfo.typeDescriptor->GetPropertyByName(propertyInfo.propertyName.ToString(), true);
							PropertyType value(result, prop);
							propertyTypes.Add(key, value);
							return value;
						}
					}
					
					PropertyType value(GuiInstancePropertyInfo::Unsupported(), 0);
					propertyTypes.Add(key, value);
					return value;
				}
				else
				{
					return propertyTypes.Values()[index];
				}
			}

			Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
			{
				return GetPropertyTypeCached(propertyInfo).f0;
			}

			//***********************************************************************************

			bool CanCreate(const TypeInfo& typeInfo)override
			{
				return
					GetDefaultConstructor(typeInfo.typeDescriptor) != nullptr ||
					GetInstanceConstructor(typeInfo.typeDescriptor) != nullptr;
			}

			Ptr<workflow::WfStatement> CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
			{
				CTOR_PARAM_PREFIX
				auto defaultCtor = GetDefaultConstructor(typeInfo.typeDescriptor);
				auto instanceCtor = GetInstanceConstructor(typeInfo.typeDescriptor);

				auto create = MakePtr<WfNewClassExpression>();
				if (defaultCtor)
				{
					create->type = GetTypeFromTypeInfo(defaultCtor->GetReturn());
				}
				else
				{
					create->type = GetTypeFromTypeInfo(instanceCtor->GetReturn());

					vint count = instanceCtor->GetParameterCount();
					for (vint i = 0; i < count; i++)
					{
						const auto& name = instanceCtor->GetParameter(i)->GetName();
						auto key = GlobalStringKey::Get(CTOR_PARAM_NAME(name));

						vint index = arguments.Keys().IndexOf(key);
						if (index == -1)
						{
							return nullptr;
						}
						else
						{
							create->arguments.Add(arguments.GetByIndex(index)[0].expression);
						}
					}
				}

				auto refValue = MakePtr<WfReferenceExpression>();
				refValue->name.value = variableName.ToString();

				auto assign = MakePtr<WfBinaryExpression>();
				assign->op = WfBinaryOperator::Assign;
				assign->first = refValue;
				assign->second = create;

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = assign;
				return stat;
			}

			Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
			{
				auto block = MakePtr<WfBlockStatement>();

				FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
				{
					PropertyType propertyType = GetPropertyTypeCached(PropertyInfo(typeInfo, prop));
					if (propertyType.f1)
					{
						switch (propertyType.f0->support)
						{
						case GuiInstancePropertyInfo::SupportCollection:
							{
								const auto& values = arguments.GetByIndex(index);
								if (values.Count() > 0)
								{
									{
										auto refValue = MakePtr<WfReferenceExpression>();
										refValue->name.value = variableName.ToString();

										auto refProp = MakePtr<WfMemberExpression>();
										refProp->parent = refValue;
										refProp->name.value = prop.ToString();

										auto varDesc = MakePtr<WfVariableDeclaration>();
										varDesc->name.value = L"<collection>";
										varDesc->expression = refProp;

										auto stat = MakePtr<WfVariableStatement>();
										stat->variable = varDesc;
										block->statements.Add(stat);
									}

									for (vint i = 0; i < values.Count(); i++)
									{
										auto refCollection = MakePtr<WfReferenceExpression>();
										refCollection->name.value = L"<collection>";

										auto refAdd = MakePtr<WfMemberExpression>();
										refAdd->parent = refCollection;
										refAdd->name.value = L"Add";

										auto call = MakePtr<WfCallExpression>();
										call->function = refAdd;
										call->arguments.Add(values[i].expression);

										auto stat = MakePtr<WfExpressionStatement>();
										stat->expression = call;
										block->statements.Add(stat);
									}
								}
							}
							break;
						case GuiInstancePropertyInfo::SupportArray:
							{
								auto refArray = MakePtr<WfConstructorExpression>();
								FOREACH(ArgumentInfo, item, arguments.GetByIndex(index))
								{
									auto argument = MakePtr<WfConstructorArgument>();
									argument->key = item.expression;
									refArray->arguments.Add(argument);
								}

								auto refValue = MakePtr<WfReferenceExpression>();
								refValue->name.value = variableName.ToString();

								auto refProp = MakePtr<WfMemberExpression>();
								refProp->parent = refValue;
								refProp->name.value = prop.ToString();

								auto assign = MakePtr<WfBinaryExpression>();
								assign->op = WfBinaryOperator::Assign;
								assign->first = refProp;
								assign->second = refArray;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = assign;
								block->statements.Add(stat);
							}
							break;
						case GuiInstancePropertyInfo::SupportAssign:
							{
								auto refValue = MakePtr<WfReferenceExpression>();
								refValue->name.value = variableName.ToString();

								auto refProp = MakePtr<WfMemberExpression>();
								refProp->parent = refValue;
								refProp->name.value = prop.ToString();

								auto assign = MakePtr<WfBinaryExpression>();
								assign->op = WfBinaryOperator::Assign;
								assign->first = refProp;
								assign->second = arguments.GetByIndex(index)[0].expression;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = assign;
								block->statements.Add(stat);
							}
							break;
						default:
							errors.Add(L"Precompile: Property \"" + prop.ToString() + L"\" of type \"" + typeInfo.typeName.ToString() + L"\" is not assignable.");
						}
					}
				}

				if (block->statements.Count() > 0)
				{
					return block;
				}
				return nullptr;
			}

			Ptr<workflow::WfExpression> GetParameter(const PropertyInfo& propertyInfo, GlobalStringKey variableName, collections::List<WString>& errors)override
			{
				auto refValue = MakePtr<WfReferenceExpression>();
				refValue->name.value = variableName.ToString();

				auto refProp = MakePtr<WfMemberExpression>();
				refProp->parent = refValue;
				refProp->name.value = propertyInfo.propertyName.ToString();

				return refProp;
			}
		};
#undef CTOR_PARAM_NAME
#undef CTOR_PARAM_PREFIX

/***********************************************************************
GuiInstanceLoaderManager
***********************************************************************/

		IGuiInstanceLoaderManager* instanceLoaderManager = 0;

		IGuiInstanceLoaderManager* GetInstanceLoaderManager()
		{
			return instanceLoaderManager;
		}

		class GuiInstanceLoaderManager : public Object, public IGuiInstanceLoaderManager, public IGuiPlugin
		{
		protected:
			typedef Dictionary<GlobalStringKey, Ptr<IGuiInstanceBinder>>				BinderMap;
			typedef Dictionary<GlobalStringKey, Ptr<IGuiInstanceEventBinder>>			EventBinderMap;

			struct VirtualTypeInfo
			{
				GlobalStringKey						typeName;
				ITypeDescriptor*					typeDescriptor = nullptr;
				GlobalStringKey						parentTypeName;				// for virtual type only
				Ptr<IGuiInstanceLoader>				loader;

				List<ITypeDescriptor*>				parentTypes;				// all direct or indirect base types that does not has a type info
				List<VirtualTypeInfo*>				parentTypeInfos;			// type infos for all registered direct or indirect base types
			};

			typedef Dictionary<GlobalStringKey, Ptr<VirtualTypeInfo>>		VirtualTypeInfoMap;

			Ptr<IGuiInstanceLoader>					rootLoader;
			BinderMap								binders;
			EventBinderMap							eventBinders;
			VirtualTypeInfoMap						typeInfos;

			bool IsTypeExists(GlobalStringKey name)
			{
				return GetGlobalTypeManager()->GetTypeDescriptor(name.ToString()) != 0 || typeInfos.Keys().Contains(name);
			}

			void FindParentTypeInfos(Ptr<VirtualTypeInfo> typeInfo, ITypeDescriptor* searchType)
			{
				if (searchType != typeInfo->typeDescriptor)
				{
					vint index = typeInfos.Keys().IndexOf(GlobalStringKey::Get(searchType->GetTypeName()));
					if (index == -1)
					{
						typeInfo->parentTypes.Add(searchType);
					}
					else
					{
						typeInfo->parentTypeInfos.Add(typeInfos.Values()[index].Obj());
						return;
					}
				}

				vint count = searchType->GetBaseTypeDescriptorCount();
				for (vint i = 0; i < count; i++)
				{
					ITypeDescriptor* baseType = searchType->GetBaseTypeDescriptor(i);
					FindParentTypeInfos(typeInfo, baseType);
				}
			}

			void FillParentTypeInfos(Ptr<VirtualTypeInfo> typeInfo)
			{
				if (typeInfo->parentTypeName != GlobalStringKey::Empty)
				{
					typeInfo->typeDescriptor = nullptr;
				}
				typeInfo->parentTypes.Clear();
				typeInfo->parentTypeInfos.Clear();

				ITypeDescriptor* searchType = typeInfo->typeDescriptor;
				if (!searchType)
				{
					vint index = typeInfos.Keys().IndexOf(typeInfo->parentTypeName);
					if (index == -1)
					{
						searchType = GetGlobalTypeManager()->GetTypeDescriptor(typeInfo->parentTypeName.ToString());
						typeInfo->typeDescriptor = searchType;
						typeInfo->parentTypes.Add(searchType);
					}
					else
					{
						VirtualTypeInfo* parentTypeInfo = typeInfos.Values()[index].Obj();
						typeInfo->typeDescriptor = parentTypeInfo->typeDescriptor;
						typeInfo->parentTypeInfos.Add(parentTypeInfo);
						return;
					}
				}

				if (searchType)
				{
					FindParentTypeInfos(typeInfo, searchType);
				}
			}

			IGuiInstanceLoader* GetLoaderFromType(ITypeDescriptor* typeDescriptor)
			{
				vint index = typeInfos.Keys().IndexOf(GlobalStringKey::Get(typeDescriptor->GetTypeName()));
				if (index == -1)
				{
					vint count = typeDescriptor->GetBaseTypeDescriptorCount();
					for (vint i = 0; i < count; i++)
					{
						ITypeDescriptor* baseType = typeDescriptor->GetBaseTypeDescriptor(i);
						IGuiInstanceLoader* loader = GetLoaderFromType(baseType);
						if (loader) return loader;
					}
					return 0;
				}
				else
				{
					return typeInfos.Values()[index]->loader.Obj();
				}
			}
		public:
			GuiInstanceLoaderManager()
			{
				rootLoader = new GuiDefaultInstanceLoader;
			}

			void Load()override
			{
				instanceLoaderManager = this;
			}

			void AfterLoad()override
			{
				IGuiParserManager* manager = GetParserManager();
				manager->SetParser(L"INSTANCE-ELEMENT-NAME", new GuiInstanceContextElementNameParser);
			}

			void Unload()override
			{
				instanceLoaderManager = nullptr;
			}

			bool AddInstanceBinder(Ptr<IGuiInstanceBinder> binder)override
			{
				if (binders.Keys().Contains(binder->GetBindingName())) return false;
				binders.Add(binder->GetBindingName(), binder);
				return true;
			}

			IGuiInstanceBinder* GetInstanceBinder(GlobalStringKey bindingName)override
			{
				vint index = binders.Keys().IndexOf(bindingName);
				return index == -1 ? 0 : binders.Values()[index].Obj();
			}

			bool AddInstanceEventBinder(Ptr<IGuiInstanceEventBinder> binder)override
			{
				if (eventBinders.Keys().Contains(binder->GetBindingName())) return false;
				eventBinders.Add(binder->GetBindingName(), binder);
				return true;
			}

			IGuiInstanceEventBinder* GetInstanceEventBinder(GlobalStringKey bindingName)override
			{
				vint index = eventBinders.Keys().IndexOf(bindingName);
				return index == -1 ? 0 : eventBinders.Values()[index].Obj();
			}

			bool CreateVirtualType(GlobalStringKey parentType, Ptr<IGuiInstanceLoader> loader)override
			{
				if (IsTypeExists(loader->GetTypeName()) || !IsTypeExists(parentType)) return false;

				Ptr<VirtualTypeInfo> typeInfo = new VirtualTypeInfo;
				typeInfo->typeName = loader->GetTypeName();
				typeInfo->parentTypeName = parentType;
				typeInfo->loader = loader;
				typeInfos.Add(loader->GetTypeName(), typeInfo);
				FillParentTypeInfos(typeInfo);

				return true;
			}

			bool SetLoader(Ptr<IGuiInstanceLoader> loader)override
			{
				vint index = typeInfos.Keys().IndexOf(loader->GetTypeName());
				if (index != -1) return false;

				ITypeDescriptor* typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(loader->GetTypeName().ToString());
				if (typeDescriptor == 0) return false;

				Ptr<VirtualTypeInfo> typeInfo = new VirtualTypeInfo;
				typeInfo->typeName = loader->GetTypeName();
				typeInfo->typeDescriptor = typeDescriptor;
				typeInfo->loader = loader;
				typeInfos.Add(typeInfo->typeName, typeInfo);
				FillParentTypeInfos(typeInfo);

				FOREACH(Ptr<VirtualTypeInfo>, derived, typeInfos.Values())
				{
					if (derived->parentTypes.Contains(typeInfo->typeDescriptor))
					{
						FillParentTypeInfos(derived);
					}
				}

				return true;
			}

			IGuiInstanceLoader* GetLoader(GlobalStringKey typeName)override
			{
				vint index = typeInfos.Keys().IndexOf(typeName);
				if (index != -1)
				{
					return typeInfos.Values()[index]->loader.Obj();
				}

				ITypeDescriptor* typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(typeName.ToString());
				if (typeDescriptor)
				{
					IGuiInstanceLoader* loader = GetLoaderFromType(typeDescriptor);
					return loader ? loader : rootLoader.Obj();
				}
				return 0;
			}

			IGuiInstanceLoader* GetParentLoader(IGuiInstanceLoader* loader)override
			{
				vint index = typeInfos.Keys().IndexOf(loader->GetTypeName());
				if (index != -1)
				{
					Ptr<VirtualTypeInfo> typeInfo = typeInfos.Values()[index];
					if (typeInfo->parentTypeInfos.Count() > 0)
					{
						return typeInfo->parentTypeInfos[0]->loader.Obj();
					}
					return rootLoader.Obj();
				}
				return 0;
			}

			description::ITypeDescriptor* GetTypeDescriptorForType(GlobalStringKey typeName)override
			{
				vint index = typeInfos.Keys().IndexOf(typeName);
				return index == -1
					? GetGlobalTypeManager()->GetTypeDescriptor(typeName.ToString())
					: typeInfos.Values()[index]->typeDescriptor;
			}

			void GetVirtualTypes(collections::List<GlobalStringKey>& typeNames)override
			{
				for (vint i = 0; i < typeInfos.Count(); i++)
				{
					if (typeInfos.Values()[i]->parentTypeName != GlobalStringKey::Empty)
					{
						typeNames.Add(typeInfos.Keys()[i]);
					}
				}
			}

			GlobalStringKey GetParentTypeForVirtualType(GlobalStringKey virtualType)override
			{
				vint index = typeInfos.Keys().IndexOf(virtualType);
				if (index != -1)
				{
					auto typeInfo = typeInfos.Values()[index];
					return typeInfo->parentTypeName;
				}
				return GlobalStringKey::Empty;
			}

			void ClearReflectionCache()override
			{
				rootLoader->ClearReflectionCache();
				FOREACH(Ptr<VirtualTypeInfo>, info, typeInfos.Values())
				{
					info->loader->ClearReflectionCache();
				}
			}
		};
		GUI_REGISTER_PLUGIN(GuiInstanceLoaderManager)
	}
}

/***********************************************************************
GUIINSTANCELOADER_PREDEFINEDINSTANCEBINDERS.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace reflection::description;
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace workflow::runtime;
		using namespace controls;

/***********************************************************************
GuiResourceInstanceBinder (uri)
***********************************************************************/

		class GuiResourceInstanceBinder : public Object, public IGuiInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Uri;
			}

			bool ApplicableToConstructorArgument()override
			{
				return false;
			}

			bool RequirePropertyExist()override
			{
				return false;
			}

			Ptr<workflow::WfExpression> GenerateConstructorArgument(IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				CHECK_FAIL(L"GuiResourceInstanceBinder::GenerateConstructorArgument()#This binder does not support binding to constructor arguments. Please call ApplicableToConstructorArgument() to determine before calling this function.");
			}
			
			Ptr<workflow::WfStatement> GenerateInstallStatement(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				WString protocol, path;
				if (!IsResourceUrl(code, protocol, path))
				{
					errors.Add(L"Precompile: \"" + code + L"\" is not a valid resource uri.");
					return nullptr;
				}
				else
				{
					return Workflow_InstallUriProperty(variableName, loader, prop, propInfo, protocol, path, errors);
				}
			}
		};

/***********************************************************************
GuiReferenceInstanceBinder (ref)
***********************************************************************/

		class GuiReferenceInstanceBinder : public Object, public IGuiInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Ref;
			}

			bool ApplicableToConstructorArgument()override
			{
				return false;
			}

			bool RequirePropertyExist()override
			{
				return false;
			}

			Ptr<workflow::WfExpression> GenerateConstructorArgument(IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				CHECK_FAIL(L"GuiReferenceInstanceBinder::GenerateConstructorArgument()#This binder does not support binding to constructor arguments. Please call ApplicableToConstructorArgument() to determine before calling this function.");
			}
			
			Ptr<workflow::WfStatement> GenerateInstallStatement(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				auto expression = MakePtr<WfReferenceExpression>();
				expression->name.value = code;
				return Workflow_InstallEvalProperty(variableName, loader, prop, propInfo, expression, errors);
			}
		};

/***********************************************************************
GuiEvalInstanceBinder (eval)
***********************************************************************/

		class GuiEvalInstanceBinder : public Object, public IGuiInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Eval;
			}

			bool ApplicableToConstructorArgument()override
			{
				return true;
			}

			bool RequirePropertyExist()override
			{
				return false;
			}

			Ptr<workflow::WfExpression> GenerateConstructorArgument(IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				if (auto expression = Workflow_ParseExpression(code, errors))
				{
					return expression;
				}
				return nullptr;
			}
			
			Ptr<workflow::WfStatement> GenerateInstallStatement(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				if (auto expression = Workflow_ParseExpression(code, errors))
				{
					return Workflow_InstallEvalProperty(variableName, loader, prop, propInfo, expression, errors);
				}
				return nullptr;
			}
		};

/***********************************************************************
GuiBindInstanceBinder (bind)
***********************************************************************/

		class GuiBindInstanceBinder : public Object, public IGuiInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Bind;
			}

			bool ApplicableToConstructorArgument()override
			{
				return false;
			}

			bool RequirePropertyExist()override
			{
				return true;
			}

			Ptr<workflow::WfExpression> GenerateConstructorArgument(IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				CHECK_FAIL(L"GuiBindInstanceBinder::GenerateConstructorArgument()#This binder does not support binding to constructor arguments. Please call ApplicableToConstructorArgument() to determine before calling this function.");
			}
			
			Ptr<workflow::WfStatement> GenerateInstallStatement(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				if (auto expression = Workflow_ParseExpression(L"bind(" + code + L")", errors))
				{
					return Workflow_InstallBindProperty(variableName, propertyInfo, expression);
				}
				return nullptr;
			}
		};

/***********************************************************************
GuiFormatInstanceBinder (format)
***********************************************************************/

		class GuiFormatInstanceBinder : public Object, public IGuiInstanceBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Format;
			}

			bool ApplicableToConstructorArgument()override
			{
				return false;
			}

			bool RequirePropertyExist()override
			{
				return true;
			}

			Ptr<workflow::WfExpression> GenerateConstructorArgument(IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				CHECK_FAIL(L"GuiFormatInstanceBinder::GenerateConstructorArgument()#This binder does not support binding to constructor arguments. Please call ApplicableToConstructorArgument() to determine before calling this function.");
			}
			
			Ptr<workflow::WfStatement> GenerateInstallStatement(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& code, collections::List<WString>& errors)override
			{
				if (auto expression = Workflow_ParseExpression(L"bind($\"" + code + L"\")", errors))
				{
					return Workflow_InstallBindProperty(variableName, propertyInfo, expression);
				}
				return nullptr;
			}
		};

/***********************************************************************
GuiEvalInstanceEventBinder (eval)
***********************************************************************/

		class GuiEvalInstanceEventBinder : public Object, public IGuiInstanceEventBinder
		{
		public:
			GlobalStringKey GetBindingName()override
			{
				return GlobalStringKey::_Eval;
			}
			
			Ptr<workflow::WfStatement> GenerateInstallStatement(GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& code, collections::List<WString>& errors)override
			{
				if (auto statement = Workflow_ParseStatement(code, errors))
				{
					return Workflow_InstallEvalEvent(variableName, eventInfo, statement);
				}
				return nullptr;
			}
		};

/***********************************************************************
GuiPredefinedInstanceBindersPlugin
***********************************************************************/

		class GuiPredefinedInstanceBindersPlugin : public Object, public IGuiPlugin
		{
		public:
			GuiPredefinedInstanceBindersPlugin()
			{
			}

			void Load()override
			{
				WfLoadTypes();
				GuiIqLoadTypes();
			}

			void AfterLoad()override
			{
				{
					IGuiParserManager* manager = GetParserManager();
					manager->SetParsingTable(L"WORKFLOW", &WfLoadTable);
					manager->SetTableParser(L"WORKFLOW", L"WORKFLOW-TYPE", &WfParseType);
					manager->SetTableParser(L"WORKFLOW", L"WORKFLOW-EXPRESSION", &WfParseExpression);
					manager->SetTableParser(L"WORKFLOW", L"WORKFLOW-STATEMENT", &WfParseStatement);
					manager->SetTableParser(L"WORKFLOW", L"WORKFLOW-MODULE", &WfParseModule);
					manager->SetParsingTable(L"INSTANCE-QUERY", &GuiIqLoadTable);
					manager->SetTableParser(L"INSTANCE-QUERY", L"INSTANCE-QUERY", &GuiIqParse);
				}
				{
					IGuiInstanceLoaderManager* manager=GetInstanceLoaderManager();

					manager->AddInstanceBinder(new GuiResourceInstanceBinder);
					manager->AddInstanceBinder(new GuiReferenceInstanceBinder);
					manager->AddInstanceBinder(new GuiEvalInstanceBinder);
					manager->AddInstanceEventBinder(new GuiEvalInstanceEventBinder);
					manager->AddInstanceBinder(new GuiBindInstanceBinder);
					manager->AddInstanceBinder(new GuiFormatInstanceBinder);
				}
			}

			void Unload()override
			{
			}
		};
		GUI_REGISTER_PLUGIN(GuiPredefinedInstanceBindersPlugin)
	}
}

/***********************************************************************
GUIINSTANCELOADER_PREDEFINEDTYPERESOLVERS.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace parsing;
		using namespace parsing::xml;
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace workflow::runtime;
		using namespace reflection::description;
		using namespace collections;
		using namespace stream;

		using namespace controls;

		void Workflow_GenerateAssembly(Ptr<GuiInstanceCompiledWorkflow> compiled, const WString& path, collections::List<WString>& errors)
		{
			if (!compiled->assembly)
			{
				List<WString> codes;
				auto manager = Workflow_GetSharedManager();
				manager->Clear(false, true);

				auto addCode = [&codes](TextReader& reader)
				{
					vint row = 0;
					WString code;
					while (!reader.IsEnd())
					{
						auto rowHeader = itow(++row);
						while (rowHeader.Length() < 6)
						{
							rowHeader = L" " + rowHeader;
						}
						code += rowHeader + L" : " + reader.ReadLine() + L"\r\n";
					}
					codes.Add(code);
				};

				if (compiled->modules.Count() > 0)
				{
					FOREACH_INDEXER(Ptr<WfModule>, module, index, compiled->modules)
					{
						{
							MemoryStream stream;
							{
								StreamWriter writer(stream);
								auto recorder = MakePtr<ParsingUpdateLocationRecorder>();
								ParsingWriter parsingWriter(writer, recorder, index);
								WfPrint(module, L"", parsingWriter);
							}
							stream.SeekFromBegin(0);
							{
								StreamReader reader(stream);
								addCode(reader);
							}
						}
						manager->AddModule(module);
					}
				}
				else
				{
					FOREACH(WString, code, compiled->codes)
					{
						{
							StringReader reader(code);
							addCode(reader);
						}
						manager->AddModule(code);
					}
				}

				if (manager->errors.Count() == 0)
				{
					manager->Rebuild(true);
				}

				if (manager->errors.Count() == 0)
				{
					compiled->assembly = GenerateAssembly(manager);
					compiled->Initialize(true);
				}
				else
				{
					errors.Add(L"Failed to compile workflow scripts in: " + path);

					using ErrorGroup = Pair<vint, LazyList<Ptr<ParsingError>>>;
					List<ErrorGroup> errorGroups;
					CopyFrom(
						errorGroups,
						From(manager->errors)
							.GroupBy([](Ptr<ParsingError> error){ return error->codeRange.codeIndex; })
							.OrderBy([](ErrorGroup g1, ErrorGroup g2){ return g1.key - g2.key; })
						);

					FOREACH(ErrorGroup, errorGroup, errorGroups)
					{
						if (errorGroup.key == -1)
						{
							FOREACH(Ptr<ParsingError>, error, errorGroup.value)
							{
								errors.Add(L"    " + error->errorMessage);
							}
						}
						else
						{
							FOREACH(Ptr<ParsingError>, error, errorGroup.value)
							{
								errors.Add(
									L"    "
									L"Row: " + itow(error->codeRange.start.row + 1) +
									L", Column: " + itow(error->codeRange.start.column + 1) +
									L", Message: " + error->errorMessage);
							}
							errors.Add(L"Workflow script for reference:");
							errors.Add(codes[errorGroup.key]);
						}
					}
					errors.Add(L"<END>");
				}
					
				compiled->codes.Clear();
				compiled->modules.Clear();
				manager->Clear(false, true);
			}
		}

/***********************************************************************
Instance Type Resolver (Instance)
***********************************************************************/

		class GuiResourceInstanceTypeResolver
			: public Object
			, public IGuiResourceTypeResolver
			, private IGuiResourceTypeResolver_Precompile
			, private IGuiResourceTypeResolver_IndirectLoad
		{
			const wchar_t* Path_TemporaryClass = L"Workflow/TemporaryClass";
			const wchar_t* Path_InstanceCtor = L"Workflow/InstanceCtor";
			const wchar_t* Path_InstanceClass = L"Workflow/InstanceClass";
		public:
			WString GetType()override
			{
				return L"Instance";
			}

			bool XmlSerializable()override
			{
				return true;
			}

			bool StreamSerializable()override
			{
				return false;
			}

			WString GetPreloadType()override
			{
				return L"Xml";
			}

			bool IsDelayLoad()override
			{
				return false;
			}

			vint GetMaxPassIndex()override
			{
				return Instance_Max;
			}

			PassSupport GetPassSupport(vint passIndex)override
			{
				switch (passIndex)
				{
				case Instance_CollectInstanceTypes:
				case Instance_GenerateTemporaryClass:
				case Instance_GenerateInstanceCtor:
				case Instance_GenerateInstanceClass:
					return PerResource;
				case Instance_ValidateDependency:
				case Instance_CompileTemporaryClass:
				case Instance_CompileInstanceCtor:
				case Instance_CompileInstanceClass:
					return PerPass;
				default:
					return NotSupported;
				}
			}

			void AddModule(GuiResourcePrecompileContext& context, const WString& path, Ptr<WfModule> module, GuiInstanceCompiledWorkflow::AssemblyType assemblyType)
			{
				auto compiled = context.targetFolder->GetValueByPath(path).Cast<GuiInstanceCompiledWorkflow>();
				if (!compiled)
				{
					compiled = new GuiInstanceCompiledWorkflow;
					compiled->type = assemblyType;
					context.targetFolder->CreateValueByPath(path, L"Workflow", compiled);
				}

				compiled->modules.Add(module);
			}

#define ENSURE_ASSEMBLY_EXISTS(PATH)\
			if (auto compiled = context.targetFolder->GetValueByPath(PATH).Cast<GuiInstanceCompiledWorkflow>())\
			{\
				if (!compiled->assembly)\
				{\
					break;\
				}\
			}\
			else\
			{\
				break;\
			}\

#define UNLOAD_ASSEMBLY(PATH)\
			if (auto compiled = context.targetFolder->GetValueByPath(PATH).Cast<GuiInstanceCompiledWorkflow>())\
			{\
				compiled->context = nullptr;\
			}\

#define DELETE_ASSEMBLY(PATH)\
			if (auto compiled = context.targetFolder->GetValueByPath(PATH).Cast<GuiInstanceCompiledWorkflow>())\
			{\
				compiled->context = nullptr;\
				compiled->assembly = nullptr;\
			}\

			void PerResourcePrecompile(Ptr<GuiResourceItem> resource, GuiResourcePrecompileContext& context, collections::List<WString>& errors)override
			{
				switch (context.passIndex)
				{
				case Instance_GenerateTemporaryClass:
					ENSURE_ASSEMBLY_EXISTS(Path_TemporaryClass)
				case Instance_CollectInstanceTypes:
					{
						if (auto obj = resource->GetContent().Cast<GuiInstanceContext>())
						{
							obj->ApplyStyles(context.resolver, errors);

							if (auto module = Workflow_GenerateInstanceClass(obj, *(types::ResolvingResult*)nullptr, errors, context.passIndex))
							{
								AddModule(context, Path_TemporaryClass, module, GuiInstanceCompiledWorkflow::TemporaryClass);
							}

							if (context.passIndex == Instance_CollectInstanceTypes)
							{
								auto record = context.targetFolder->GetValueByPath(L"ClassNameRecord").Cast<GuiResourceClassNameRecord>();
								if (!record)
								{
									record = MakePtr<GuiResourceClassNameRecord>();
									context.targetFolder->CreateValueByPath(L"ClassNameRecord", L"ClassNameRecord", record);
								}
								record->classNames.Add(obj->className);
							}
						}
					}
					break;
				case Instance_GenerateInstanceCtor:
					{
						ENSURE_ASSEMBLY_EXISTS(Path_TemporaryClass)
						if (auto obj = resource->GetContent().Cast<GuiInstanceContext>())
						{
							auto resolvingResult = MakePtr<types::ResolvingResult>();
							if (auto module = Workflow_PrecompileInstanceContext(obj, *resolvingResult.Obj(), errors))
							{
								context.additionalProperties.Add(obj, resolvingResult);
								AddModule(context, Path_InstanceCtor, module, GuiInstanceCompiledWorkflow::InstanceCtor);
								AddModule(context, Path_InstanceClass, module, GuiInstanceCompiledWorkflow::InstanceClass);
							}
						}
					}
					break;
				case Instance_GenerateInstanceClass:
					{
						ENSURE_ASSEMBLY_EXISTS(Path_InstanceCtor)
						ENSURE_ASSEMBLY_EXISTS(Path_TemporaryClass)
						if (auto obj = resource->GetContent().Cast<GuiInstanceContext>())
						{
							vint index = context.additionalProperties.Keys().IndexOf(obj.Obj());
							if (index != -1)
							{
								auto resolvingResult = context.additionalProperties.Values()[index].Cast<types::ResolvingResult>();
								if (auto module = Workflow_GenerateInstanceClass(obj, *resolvingResult.Obj(), errors, context.passIndex))
								{
									AddModule(context, Path_InstanceClass, module, GuiInstanceCompiledWorkflow::InstanceClass);
								}
							}
						}
					}
					break;
				}
			}

			void PerPassPrecompile(GuiResourcePrecompileContext& context, collections::List<WString>& errors)override
			{
				WString path;
				switch (context.passIndex)
				{
				case Instance_ValidateDependency:
					path = Path_TemporaryClass;
					break;
				case Instance_CompileTemporaryClass:
					DELETE_ASSEMBLY(Path_TemporaryClass)
					path = Path_TemporaryClass;
					break;
				case Instance_CompileInstanceCtor:
					path = Path_InstanceCtor;
					break;
				case Instance_CompileInstanceClass:
					UNLOAD_ASSEMBLY(Path_InstanceCtor)
					UNLOAD_ASSEMBLY(Path_TemporaryClass)
					path = Path_InstanceClass;
					break;
				default:
					return;
				}

				if (auto compiled = context.targetFolder->GetValueByPath(path).Cast<GuiInstanceCompiledWorkflow>())
				{
					Workflow_GenerateAssembly(compiled, path, errors);
				}
				GetInstanceLoaderManager()->ClearReflectionCache();
			}

#undef DELETE_ASSEMBLY
#undef UNLOAD_ASSEMBLY
#undef ENSURE_ASSEMBLY_EXISTS

			IGuiResourceTypeResolver_Precompile* Precompile()override
			{
				return this;
			}

			IGuiResourceTypeResolver_IndirectLoad* IndirectLoad()override
			{
				return this;
			}

			Ptr<DescriptableObject> Serialize(Ptr<DescriptableObject> resource)override
			{
				if (auto obj = resource.Cast<GuiInstanceContext>())
				{
					return obj->SaveToXml();
				}
				return 0;
			}

			Ptr<DescriptableObject> ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				Ptr<XmlDocument> xml = resource.Cast<XmlDocument>();
				if (xml)
				{
					Ptr<GuiInstanceContext> context = GuiInstanceContext::LoadFromXml(xml, errors);
					return context;
				}
				return 0;
			}
		};

/***********************************************************************
Instance Style Type Resolver (InstanceStyle)
***********************************************************************/

		class GuiResourceInstanceStyleResolver
			: public Object
			, public IGuiResourceTypeResolver
			, private IGuiResourceTypeResolver_IndirectLoad
		{
		public:
			WString GetType()override
			{
				return L"InstanceStyle";
			}

			bool XmlSerializable()override
			{
				return true;
			}

			bool StreamSerializable()override
			{
				return false;
			}

			WString GetPreloadType()override
			{
				return L"Xml";
			}

			bool IsDelayLoad()override
			{
				return false;
			}

			IGuiResourceTypeResolver_IndirectLoad* IndirectLoad()override
			{
				return this;
			}

			Ptr<DescriptableObject> Serialize(Ptr<DescriptableObject> resource)override
			{
				if (auto obj = resource.Cast<GuiInstanceStyleContext>())
				{
					return obj->SaveToXml();
				}
				return 0;
			}

			Ptr<DescriptableObject> ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				Ptr<XmlDocument> xml = resource.Cast<XmlDocument>();
				if (xml)
				{
					auto context = GuiInstanceStyleContext::LoadFromXml(xml, errors);
					return context;
				}
				return 0;
			}
		};

/***********************************************************************
Shared Script Type Resolver (Script)
***********************************************************************/

		class GuiResourceSharedScriptTypeResolver
			: public Object
			, public IGuiResourceTypeResolver
			, private IGuiResourceTypeResolver_Precompile
			, private IGuiResourceTypeResolver_IndirectLoad
		{
			const wchar_t* Path_ViewModel = L"Workflow/ViewModel";
			const wchar_t* Path_Shared = L"Workflow/Shared";
		public:
			WString GetType()override
			{
				return L"Script";
			}

			bool XmlSerializable()override
			{
				return true;
			}

			bool StreamSerializable()override
			{
				return false;
			}

			WString GetPreloadType()override
			{
				return L"Xml";
			}

			bool IsDelayLoad()override
			{
				return false;
			}

			vint GetMaxPassIndex()override
			{
				return Workflow_Max;
			}

			PassSupport GetPassSupport(vint passIndex)override
			{
				switch (passIndex)
				{
				case Workflow_Collect:
					return PerResource;
				case Workflow_CompileViewModel:
				case Workflow_CompileShared:
					return PerPass;
				default:
					return NotSupported;
				}
			}

			void PerResourcePrecompile(Ptr<GuiResourceItem> resource, GuiResourcePrecompileContext& context, collections::List<WString>& errors)override
			{
				switch (context.passIndex)
				{
				case Workflow_Collect:
					{
						if (auto obj = resource->GetContent().Cast<GuiInstanceSharedScript>())
						{
							WString path;
							GuiInstanceCompiledWorkflow::AssemblyType type = GuiInstanceCompiledWorkflow::Shared;
							if (obj->language == L"Workflow-ViewModel")
							{
								path = Path_ViewModel;
								type = GuiInstanceCompiledWorkflow::ViewModel;
							}
							else if (obj->language == L"Workflow")
							{
								path = Path_Shared;
							}
						
							auto compiled = context.targetFolder->GetValueByPath(path).Cast<GuiInstanceCompiledWorkflow>();
							if (!compiled)
							{
								compiled = new GuiInstanceCompiledWorkflow;
								compiled->type = type;
								context.targetFolder->CreateValueByPath(path, L"Workflow", compiled);
							}

							compiled->codes.Add(obj->code);
						}
					}
					break;
				}
			}

			void PerPassPrecompile(GuiResourcePrecompileContext& context, collections::List<WString>& errors)override
			{
				switch (context.passIndex)
				{
				case Workflow_CompileViewModel:
				case Workflow_CompileShared:
					{
						WString path;
						if (context.passIndex == Workflow_CompileViewModel)
						{
							path = Path_ViewModel;
						}
						else if (context.passIndex == Workflow_CompileShared)
						{
							path = Path_Shared;
						}
						else
						{
							return;
						}

						if (auto compiled = context.targetFolder->GetValueByPath(path).Cast<GuiInstanceCompiledWorkflow>())
						{
							Workflow_GenerateAssembly(compiled, path, errors);
						}
					}
					break;
				}
			}

			IGuiResourceTypeResolver_Precompile* Precompile()override
			{
				return this;
			}

			IGuiResourceTypeResolver_IndirectLoad* IndirectLoad()override
			{
				return this;
			}

			Ptr<DescriptableObject> Serialize(Ptr<DescriptableObject> resource)override
			{
				if (auto obj = resource.Cast<GuiInstanceSharedScript>())
				{
					return obj->SaveToXml();
				}
				return 0;
			}

			Ptr<DescriptableObject> ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)override
			{
				Ptr<XmlDocument> xml = resource.Cast<XmlDocument>();
				if (xml)
				{
					auto schema = GuiInstanceSharedScript::LoadFromXml(xml, errors);
					return schema;
				}
				return 0;
			}
		};

/***********************************************************************
Plugin
***********************************************************************/

		class GuiCompilerTypeResolversPlugin : public Object, public IGuiPlugin
		{
		public:
			GuiCompilerTypeResolversPlugin()
			{
			}

			void Load()override
			{
			}

			void AfterLoad()override
			{
				IGuiResourceResolverManager* manager = GetResourceResolverManager();
				manager->SetTypeResolver(new GuiResourceInstanceTypeResolver);
				manager->SetTypeResolver(new GuiResourceInstanceStyleResolver);
				manager->SetTypeResolver(new GuiResourceSharedScriptTypeResolver);
			}

			void Unload()override
			{
			}
		};
		GUI_REGISTER_PLUGIN(GuiCompilerTypeResolversPlugin)
	}
}

/***********************************************************************
GUIINSTANCEREPRESENTATION.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace parsing;
		using namespace parsing::xml;
		using namespace templates;
		using namespace stream;

/***********************************************************************
GuiTextRepr
***********************************************************************/

		Ptr<GuiValueRepr> GuiTextRepr::Clone()
		{
			auto repr = MakePtr<GuiTextRepr>();
			repr->fromStyle = fromStyle;
			repr->text = text;
			return repr;
		}

		void GuiTextRepr::FillXml(Ptr<parsing::xml::XmlElement> xml)
		{
			if (!fromStyle)
			{
				auto xmlText = MakePtr<XmlText>();
				xmlText->content.value = text;
				xml->subNodes.Add(xmlText);
			}
		}

/***********************************************************************
GuiAttSetterRepr
***********************************************************************/

		void GuiAttSetterRepr::CloneBody(Ptr<GuiAttSetterRepr> repr)
		{
			CopyFrom(repr->eventHandlers, eventHandlers);
			FOREACH_INDEXER(GlobalStringKey, name, index, setters.Keys())
			{
				Ptr<SetterValue> src = setters.Values()[index];
				Ptr<SetterValue> dst = new SetterValue;
				dst->binding = src->binding;
				FOREACH(Ptr<GuiValueRepr>, value, src->values)
				{
					dst->values.Add(value->Clone());
				}
				repr->setters.Add(name, dst);
			}
			repr->instanceName = instanceName;
		}

		Ptr<GuiValueRepr> GuiAttSetterRepr::Clone()
		{
			auto repr = MakePtr<GuiAttSetterRepr>();
			repr->fromStyle = fromStyle;
			CloneBody(repr);
			return repr;
		}

		void GuiAttSetterRepr::FillXml(Ptr<parsing::xml::XmlElement> xml)
		{
			if (!fromStyle)
			{
				if (instanceName != GlobalStringKey::Empty)
				{
					auto attName = MakePtr<XmlAttribute>();
					attName->name.value = L"ref.Name";
					attName->value.value = instanceName.ToString();
					xml->attributes.Add(attName);
				}

				for (vint i = 0; i < setters.Count(); i++)
				{
					auto key = setters.Keys()[i];
					auto value = setters.Values()[i];
					if (key == GlobalStringKey::Empty)
					{
						FOREACH(Ptr<GuiValueRepr>, repr, value->values)
						{
							repr->FillXml(xml);
						}
					}
					else
					{
						bool containsElement = false;
						FOREACH(Ptr<GuiValueRepr>, repr, value->values)
						{
							if (!repr.Cast<GuiTextRepr>())
							{
								containsElement = true;
								break;
							}
						}

						if (containsElement)
						{
							auto xmlProp = MakePtr<XmlElement>();
							xmlProp->name.value = L"att." + key.ToString();
							if (value->binding != GlobalStringKey::Empty)
							{
								xmlProp->name.value += L"-" + value->binding.ToString();
							}

							FOREACH(Ptr<GuiValueRepr>, repr, value->values)
							{
								if (!repr.Cast<GuiTextRepr>())
								{
									repr->FillXml(xmlProp);
								}
							}
							xml->subNodes.Add(xmlProp);
						}
						else if (value->values.Count() > 0)
						{
							auto att = MakePtr<XmlAttribute>();
							att->name.value = key.ToString();
							if (value->binding != GlobalStringKey::Empty)
							{
								att->name.value += L"-" + value->binding.ToString();
							}
							att->value.value = value->values[0].Cast<GuiTextRepr>()->text;
							xml->attributes.Add(att);
						}
					}
				}

				for (vint i = 0; i < eventHandlers.Count(); i++)
				{
					auto key = eventHandlers.Keys()[i];
					auto value = eventHandlers.Values()[i];

					auto xmlEvent = MakePtr<XmlElement>();
					xmlEvent->name.value = L"ev." + key.ToString();
					if (value->binding != GlobalStringKey::Empty)
					{
						xmlEvent->name.value += L"-" + value->binding.ToString();
					}
					xml->subNodes.Add(xmlEvent);

					auto xmlText = MakePtr<XmlText>();
					xmlText->content.value = value->value;
					xmlEvent->subNodes.Add(xmlText);
				}
			}
		}

/***********************************************************************
GuiConstructorRepr
***********************************************************************/

		Ptr<GuiValueRepr> GuiConstructorRepr::Clone()
		{
			auto repr = MakePtr<GuiConstructorRepr>();
			repr->fromStyle = fromStyle;
			repr->typeNamespace = typeNamespace;
			repr->typeName = typeName;
			repr->styleName = styleName;
			CloneBody(repr);
			return repr;
		}

		void GuiConstructorRepr::FillXml(Ptr<parsing::xml::XmlElement> xml)
		{
			if (!fromStyle)
			{
				auto xmlCtor = MakePtr<XmlElement>();
				if (typeNamespace == GlobalStringKey::Empty)
				{
					xmlCtor->name.value = typeName.ToString();
				}
				else
				{
					xmlCtor->name.value = typeNamespace.ToString() + L":" + typeName.ToString();
				}

				if (styleName)
				{
					auto attStyle = MakePtr<XmlAttribute>();
					attStyle->name.value = L"ref.Style";
					attStyle->value.value = styleName.Value();
					xml->attributes.Add(attStyle);
				}

				GuiAttSetterRepr::FillXml(xmlCtor);
				xml->subNodes.Add(xmlCtor);
			}
		}

/***********************************************************************
GuiInstanceContext
***********************************************************************/

		void GuiInstanceContext::CollectDefaultAttributes(GuiAttSetterRepr::ValueList& values, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				// test if there is only one text value in the xml
				if(xml->subNodes.Count()==1)
				{
					if(Ptr<XmlText> text=xml->subNodes[0].Cast<XmlText>())
					{
						Ptr<GuiTextRepr> value=new GuiTextRepr;
						value->text=text->content.value;
						values.Add(value);
					}
					else if(Ptr<XmlCData> text=xml->subNodes[0].Cast<XmlCData>())
					{
						Ptr<GuiTextRepr> value=new GuiTextRepr;
						value->text=text->content.value;
						values.Add(value);
					}
				}

				// collect default attributes
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml))
				{
					if(auto name=parser->TypedParse(element->name.value, errors))
					{
						if(name->IsCtorName())
						{
							// collect constructor values in the default attribute setter
							auto ctor=LoadCtor(element, errors);
							if(ctor)
							{
								values.Add(ctor);
							}
						}
					}
				}
			}
		}

		void GuiInstanceContext::CollectAttributes(GuiAttSetterRepr::SetteValuerMap& setters, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				Ptr<GuiAttSetterRepr::SetterValue> defaultValue=new GuiAttSetterRepr::SetterValue;

				// collect default attributes
				CollectDefaultAttributes(defaultValue->values, xml, errors);
				if(defaultValue->values.Count()>0)
				{
					setters.Add(GlobalStringKey::Empty, defaultValue);
				}

				// collect values
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml))
				{
					if (auto name = parser->TypedParse(element->name.value, errors))
					{
						if(name->IsPropertyElementName())
						{
							// collect a value as a new attribute setter
							if (setters.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								errors.Add(L"Duplicated attribute name \"" + name->name + L"\".");
							}
							else
							{
								Ptr<GuiAttSetterRepr::SetterValue> sv=new GuiAttSetterRepr::SetterValue;
								sv->binding = GlobalStringKey::Get(name->binding);

								if(name->binding==L"set")
								{
									// if the binding is "set", it means that this element is a complete setter element
									Ptr<GuiAttSetterRepr> setter=new GuiAttSetterRepr;
									FillAttSetter(setter, element, errors);
									sv->values.Add(setter);
								}
								else
								{
									// if the binding is not "set", then this is a single-value attribute or a colection attribute
									// fill all data into this attribute
									CollectDefaultAttributes(sv->values, element, errors);
								}

								if(sv->values.Count()>0)
								{
									setters.Add(GlobalStringKey::Get(name->name), sv);
								}
							}
						}
					}
				}
			}
		}

		void GuiInstanceContext::CollectEvents(GuiAttSetterRepr::EventHandlerMap& eventHandlers, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				// collect values
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml))
				{
					if(auto name=parser->TypedParse(element->name.value, errors))
					{
						if(name->IsEventElementName())
						{
							// collect a value as a new attribute setter
							if (eventHandlers.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								errors.Add(L"Duplicated event name \"" + name->name + L"\".");
							}
							else
							{
								// test if there is only one text value in the xml
								if(element->subNodes.Count()==1)
								{
									if(Ptr<XmlText> text=element->subNodes[0].Cast<XmlText>())
									{
										auto value = MakePtr<GuiAttSetterRepr::EventValue>();
										value->binding = GlobalStringKey::Get(name->binding);
										value->value = text->content.value;
										eventHandlers.Add(GlobalStringKey::Get(name->name), value);
									}
									else if(Ptr<XmlCData> text=element->subNodes[0].Cast<XmlCData>())
									{
										auto value = MakePtr<GuiAttSetterRepr::EventValue>();
										value->binding = GlobalStringKey::Get(name->binding);
										value->value = text->content.value;
										eventHandlers.Add(GlobalStringKey::Get(name->name), value);
									}
								}
							}
						}
					}
				}
			}
		}

		void GuiInstanceContext::FillAttSetter(Ptr<GuiAttSetterRepr> setter, Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if(auto parser=GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				// collect attributes as setters
				FOREACH(Ptr<XmlAttribute>, att, xml->attributes)
				{
					if (auto name = parser->TypedParse(att->name.value, errors))
					{
						if(name->IsReferenceAttributeName())
						{
							// collect reference attributes
							if (name->name == L"Name")
							{
								setter->instanceName = GlobalStringKey::Get(att->value.value);
							}
						}
						else if(name->IsPropertyAttributeName())
						{
							// collect attributes setters
							if (setter->setters.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								errors.Add(L"Duplicated attribute name \"" + name->name + L"\".");
							}
							else
							{
								Ptr<GuiAttSetterRepr::SetterValue> sv=new GuiAttSetterRepr::SetterValue;
								sv->binding=GlobalStringKey::Get(name->binding);
								setter->setters.Add(GlobalStringKey::Get(name->name), sv);

								Ptr<GuiTextRepr> value=new GuiTextRepr;
								value->text=att->value.value;
								sv->values.Add(value);
							}
						}
						else if (name->IsEventAttributeName())
						{
							// collect event setters
							if (!setter->eventHandlers.Keys().Contains(GlobalStringKey::Get(name->name)))
							{
								auto value = MakePtr<GuiAttSetterRepr::EventValue>();
								value->binding = GlobalStringKey::Get(name->binding);
								value->value = att->value.value;
								setter->eventHandlers.Add(GlobalStringKey::Get(name->name), value);
							}
						}
					}
				}

				// collect attributes and events
				CollectAttributes(setter->setters, xml, errors);
				CollectEvents(setter->eventHandlers, xml, errors);
			}
		}

		Ptr<GuiConstructorRepr> GuiInstanceContext::LoadCtor(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			if (auto parser = GetParserManager()->GetParser<ElementName>(L"INSTANCE-ELEMENT-NAME"))
			{
				if (auto name = parser->TypedParse(xml->name.value, errors))
				{
					if(name->IsCtorName())
					{
						Ptr<GuiConstructorRepr> ctor=new GuiConstructorRepr;
						ctor->typeNamespace = GlobalStringKey::Get(name->namespaceName);
						ctor->typeName = GlobalStringKey::Get(name->name);
						// collect attributes as setters
						FOREACH(Ptr<XmlAttribute>, att, xml->attributes)
						{
							if(auto name=parser->TypedParse(att->name.value, errors))
							if(name->IsReferenceAttributeName())
							{
								if (name->name == L"Style")
								{
									ctor->styleName = att->value.value;
								}
							}
						}
						FillAttSetter(ctor, xml, errors);
						return ctor;
					}
					else
					{
						errors.Add(L"Wrong constructor name \"" + xml->name.value + L"\".");
					}
				}
			}
			return 0;
		}

		Ptr<GuiInstanceContext> GuiInstanceContext::LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors)
		{
			Ptr<GuiInstanceContext> context=new GuiInstanceContext;
			if(xml->rootElement->name.value==L"Instance")
			{
				if (auto codeBehindAttr = XmlGetAttribute(xml->rootElement, L"ref.CodeBehind"))
				{
					context->codeBehind = codeBehindAttr->value.value == L"true";
				}

				// load type name
				if (auto classAttr = XmlGetAttribute(xml->rootElement, L"ref.Class"))
				{
					context->className = classAttr->value.value;
				}

				// load style names
				if (auto styleAttr = XmlGetAttribute(xml->rootElement, L"ref.Styles"))
				{
					SplitBySemicolon(styleAttr->value.value, context->stylePaths);
				}

				// load namespaces
				List<Ptr<XmlAttribute>> namespaceAttributes;
				CopyFrom(namespaceAttributes, xml->rootElement->attributes);
				if(!XmlGetAttribute(xml->rootElement, L"xmlns"))
				{
					Ptr<XmlAttribute> att=new XmlAttribute;
					att->name.value=L"xmlns";
					att->value.value =
						L"presentation::controls::Gui*;"
						L"presentation::elements::Gui*Element;"
						L"presentation::compositions::Gui*Composition;"
						L"presentation::compositions::Gui*;"
						L"presentation::templates::Gui*;"
						L"system::*;"
						L"system::reflection::*;"
						L"presentation::*;"
						L"presentation::Gui*;"
						L"presentation::controls::*;"
						L"presentation::controls::list::*;"
						L"presentation::controls::tree::*;"
						L"presentation::elements::*;"
						L"presentation::elements::Gui*;"
						L"presentation::elements::text*;"
						L"presentation::compositions::*;"
						L"presentation::templates::*";
					namespaceAttributes.Add(att);
				}
				FOREACH(Ptr<XmlAttribute>, att, namespaceAttributes)
				{
					// check if the attribute defines a namespace
					WString attName=att->name.value;
					if(attName.Length()>=5 && attName.Left(5)==L"xmlns")
					{
						GlobalStringKey ns;
						if(attName.Length()>6)
						{
							if(attName.Left(6)==L"xmlns:")
							{
								ns = GlobalStringKey::Get(attName.Sub(6, attName.Length() - 6));
							}
							else
							{
								continue;
							}
						}

						// create a data structure for the namespace
						Ptr<NamespaceInfo> info;
						vint index=context->namespaces.Keys().IndexOf(ns);
						if(index==-1)
						{
							info=new NamespaceInfo;
							info->name=ns;
							context->namespaces.Add(ns, info);
						}
						else
						{
							info=context->namespaces.Values()[index];
						}

						// extract all patterns in the namespace, split the value by ';'
						List<WString> patterns;
						SplitBySemicolon(att->value.value, patterns);
						FOREACH(WString, pattern, patterns)
						{
							// add the pattern to the namespace
							Ptr<GuiInstanceNamespace> ns=new GuiInstanceNamespace;
							Pair<vint, vint> star=INVLOC.FindFirst(pattern, L"*", Locale::None);
							if(star.key==-1)
							{
								ns->prefix=pattern;
							}
							else
							{
								ns->prefix=pattern.Sub(0, star.key);
								ns->postfix=pattern.Sub(star.key+star.value, pattern.Length()-star.key-star.value);
							}
							info->namespaces.Add(ns);
						}
					}
				}

				// load instance
				FOREACH(Ptr<XmlElement>, element, XmlGetElements(xml->rootElement))
				{
					if (element->name.value == L"ref.Parameter")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attClass = XmlGetAttribute(element, L"Class");
						if (attName && attClass)
						{
							auto parameter = MakePtr<GuiInstanceParameter>();
							parameter->name = GlobalStringKey::Get(attName->value.value);
							parameter->className = GlobalStringKey::Get(attClass->value.value);
							context->parameters.Add(parameter);
						}
						else
						{
							errors.Add(L"ref.Parameter requires the following attributes existing at the same time: Name, Class.");
						}
					}
					else if (element->name.value == L"ref.Property")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attType = XmlGetAttribute(element, L"Type");
						auto attValue = XmlGetAttribute(element, L"Value");
						if (attName && attType)
						{
							auto prop = MakePtr<GuiInstanceProperty>();
							prop->name = GlobalStringKey::Get(attName->value.value);
							prop->typeName = attType->value.value;
							if (attValue)
							{
								prop->value = attValue->value.value;
							}
							context->properties.Add(prop);
						}
						else
						{
							errors.Add(L"ref.Property requires the following attributes existing at the same time: Name, Type.");
						}
					}
					else if (element->name.value == L"ref.State")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attType = XmlGetAttribute(element, L"Type");
						auto attValue = XmlGetAttribute(element, L"Value");
						if (attName && attType)
						{
							auto state = MakePtr<GuiInstanceState>();
							state->name = GlobalStringKey::Get(attName->value.value);
							state->typeName = attType->value.value;
							if (attValue)
							{
								state->value = attValue->value.value;
							}
							context->states.Add(state);
						}
						else
						{
							errors.Add(L"ref.State requires the following attributes existing at the same time: Name, Type.");
						}
					}
					else if (element->name.value == L"ref.Component")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attType = XmlGetAttribute(element, L"Type");
						auto attExpression = XmlGetAttribute(element, L"Expression");
						if (attName && attType && attExpression)
						{
							auto component = MakePtr<GuiInstanceComponent>();
							component->name = GlobalStringKey::Get(attName->value.value);
							component->typeName = attType->value.value;
							if (attExpression)
							{
								component->expression = attExpression->value.value;
							}
							context->components.Add(component);
						}
						else
						{
							errors.Add(L"ref.Component requires the following attributes existing at the same time: Name, Type, Expression.");
						}
					}
					else if (element->name.value == L"ref.Event")
					{
						auto attName = XmlGetAttribute(element, L"Name");
						auto attClass = XmlGetAttribute(element, L"EventArgsClass");
						if (attName)
						{
							auto ev = MakePtr<GuiInstanceEvent>();
							ev->name = GlobalStringKey::Get(attName->value.value);
							if (attClass)
							{
								ev->eventArgsClass = attClass->value.value;
							}
							context->events.Add(ev);
						}
						else
						{
							errors.Add(L"ref.Event requires the following attributes existing at the same time: Name.");
						}
					}
					else if (!context->instance)
					{
						context->instance=LoadCtor(element, errors);
					}
				}
			}

			return context->instance ? context : nullptr;
		}

		Ptr<parsing::xml::XmlDocument> GuiInstanceContext::SaveToXml()
		{
			auto xmlInstance = MakePtr<XmlElement>();
			xmlInstance->name.value = L"Instance";

			{
				auto attCodeBehind = MakePtr<XmlAttribute>();
				attCodeBehind->name.value = L"ref.CodeBehind";
				attCodeBehind->value.value = codeBehind ? L"true" : L"false";
				xmlInstance->attributes.Add(attCodeBehind);
			}
			
			auto attClass = MakePtr<XmlAttribute>();
			attClass->name.value = L"ref.Class";
			attClass->value.value = className;
			xmlInstance->attributes.Add(attClass);

			for (vint i = 0; i < namespaces.Count(); i++)
			{
				auto key = namespaces.Keys()[i];
				auto value = namespaces.Values()[i];

				auto xmlns = MakePtr<XmlAttribute>();
				xmlns->name.value = L"xmlns";
				if (key != GlobalStringKey::Empty)
				{
					xmlns->name.value += L":" + key.ToString();
				}
				xmlInstance->attributes.Add(xmlns);

				for (vint j = 0; j < value->namespaces.Count(); j++)
				{
					auto ns = value->namespaces[j];
					if (j != 0)
					{
						xmlns->value.value += L";";
					}
					xmlns->value.value += ns->prefix + L"*" + ns->postfix;
				}
			}

			FOREACH(Ptr<GuiInstanceParameter>, parameter, parameters)
			{
				auto xmlParameter = MakePtr<XmlElement>();
				xmlParameter->name.value = L"ref.Parameter";
				xmlInstance->subNodes.Add(xmlParameter);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = parameter->name.ToString();
				xmlParameter->attributes.Add(attName);

				auto attClass = MakePtr<XmlAttribute>();
				attClass->name.value = L"Class";
				attClass->value.value = parameter->className.ToString();
				xmlParameter->attributes.Add(attClass);
			}

			FOREACH(Ptr<GuiInstanceProperty>, prop, properties)
			{
				auto xmlProperty = MakePtr<XmlElement>();
				xmlProperty->name.value = L"ref.Property";
				xmlInstance->subNodes.Add(xmlProperty);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = prop->name.ToString();
				xmlProperty->attributes.Add(attName);

				auto attType = MakePtr<XmlAttribute>();
				attType->name.value = L"Type";
				attType->value.value = prop->typeName;
				xmlProperty->attributes.Add(attType);

				if (prop->value != L"")
				{
					auto attValue = MakePtr<XmlAttribute>();
					attValue->name.value = L"Value";
					attValue->value.value = prop->value;
					xmlProperty->attributes.Add(attType);
				}
			}

			FOREACH(Ptr<GuiInstanceState>, state, states)
			{
				auto xmlState = MakePtr<XmlElement>();
				xmlState->name.value = L"ref.State";
				xmlInstance->subNodes.Add(xmlState);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = state->name.ToString();
				xmlState->attributes.Add(attName);

				auto attType = MakePtr<XmlAttribute>();
				attType->name.value = L"Type";
				attType->value.value = state->typeName;
				xmlState->attributes.Add(attType);

				if (state->value != L"")
				{
					auto attValue = MakePtr<XmlAttribute>();
					attValue->name.value = L"Value";
					attValue->value.value = state->value;
					xmlState->attributes.Add(attValue);
				}
			}

			FOREACH(Ptr<GuiInstanceComponent>, component, components)
			{
				auto xmlComponent = MakePtr<XmlElement>();
				xmlComponent->name.value = L"ref.Component";
				xmlInstance->subNodes.Add(xmlComponent);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = component->name.ToString();
				xmlComponent->attributes.Add(attName);

				auto attType = MakePtr<XmlAttribute>();
				attType->name.value = L"Type";
				attType->value.value = component->typeName;
				xmlComponent->attributes.Add(attType);

				auto attExpression = MakePtr<XmlAttribute>();
				attExpression->name.value = L"Value";
				attExpression->value.value = component->expression;
				xmlComponent->attributes.Add(attExpression);
			}

			FOREACH(Ptr<GuiInstanceEvent>, ev, events)
			{
				auto xmlEvent = MakePtr<XmlElement>();
				xmlEvent->name.value = L"ref.Event";
				xmlInstance->subNodes.Add(xmlEvent);

				auto attName = MakePtr<XmlAttribute>();
				attName->name.value = L"Name";
				attName->value.value = ev->name.ToString();
				xmlEvent->attributes.Add(attName);

				if (ev->eventArgsClass != L"")
				{
					auto attClass = MakePtr<XmlAttribute>();
					attClass->name.value = L"EventArgsClass";
					attClass->value.value = ev->eventArgsClass;
					xmlEvent->attributes.Add(attClass);
				}
			}

			if (stylePaths.Count() > 0)
			{
				auto attStyles = MakePtr<XmlAttribute>();
				attStyles->name.value = L"ref.Styles";
				xmlInstance->attributes.Add(attStyles);

				for (vint j = 0; j < stylePaths.Count(); j++)
				{
					if (j != 0)
					{
						attStyles->value.value += L";";
					}
					attStyles->value.value += stylePaths[j];
				}
			}

			instance->FillXml(xmlInstance);

			auto doc = MakePtr<XmlDocument>();
			doc->rootElement = xmlInstance;
			return doc;
		}

		bool GuiInstanceContext::ApplyStyles(Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors)
		{
			if (!appliedStyles)
			{
				appliedStyles = true;

				List<Ptr<GuiInstanceStyle>> styles;
				FOREACH(WString, uri, stylePaths)
				{
					WString protocol, path;
					if (IsResourceUrl(uri, protocol, path))
					{
						if (auto styleContext = resolver->ResolveResource(protocol, path).Cast<GuiInstanceStyleContext>())
						{
							CopyFrom(styles, styleContext->styles, true);
						}
						else
						{
							errors.Add(L"Failed to find the style referred in attribute \"ref.Styles\": \"" + uri + L"\".");
						}
					}
					else
					{
						errors.Add(L"Invalid path in attribute \"ref.Styles\": \"" + uri + L"\".");
					}
				}

				FOREACH(Ptr<GuiInstanceStyle>, style, styles)
				{
					List<Ptr<GuiConstructorRepr>> output;
					ExecuteQuery(style->query, this, output);
					FOREACH(Ptr<GuiConstructorRepr>, ctor, output)
					{
						ApplyStyle(style, ctor);
					}
				}

				return true;
			}
			else
			{
				return false;
			}
		}

/***********************************************************************
GuiInstanceStyle
***********************************************************************/

		namespace visitors
		{
			class SetStyleMarkVisitor : public Object, public GuiValueRepr::IVisitor
			{
			public:
				void Visit(GuiTextRepr* repr)override
				{
					repr->fromStyle = true;
				}

				void Visit(GuiAttSetterRepr* repr)override
				{
					repr->fromStyle = true;
					FOREACH(Ptr<GuiAttSetterRepr::SetterValue>, value, repr->setters.Values())
					{
						FOREACH(Ptr<GuiValueRepr>, subValue, value->values)
						{
							subValue->Accept(this);
						}
					}
					FOREACH(Ptr<GuiAttSetterRepr::EventValue>, value, repr->eventHandlers.Values())
					{
						value->fromStyle = true;
					}
				}

				void Visit(GuiConstructorRepr* repr)override
				{
					Visit((GuiAttSetterRepr*)repr);
				}
			};
		}
		using namespace visitors;

		Ptr<GuiInstanceStyle> GuiInstanceStyle::LoadFromXml(Ptr<parsing::xml::XmlElement> xml, collections::List<WString>& errors)
		{
			auto style = MakePtr<GuiInstanceStyle>();
			if (auto pathAttr = XmlGetAttribute(xml, L"ref.Path"))
			{
				auto parser = GetParserManager()->GetParser<GuiIqQuery>(L"INSTANCE-QUERY");
				if (auto query = parser->TypedParse(pathAttr->value.value, errors))
				{
					style->query = query;
				}
				else
				{
					return 0;
				}
			}
			else
			{
				errors.Add(L"Missing attribute \"ref.Path\" in <Style>.");
			}
			style->setter = MakePtr<GuiAttSetterRepr>();
			GuiInstanceContext::FillAttSetter(style->setter, xml, errors);

			SetStyleMarkVisitor visitor;
			style->setter->Accept(&visitor);
			return style;
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceStyle::SaveToXml()
		{
			auto xmlStyle = MakePtr<XmlElement>();
			xmlStyle->name.value = L"Style";

			auto attPath = MakePtr<XmlAttribute>();
			attPath->name.value = L"ref.Path";
			{
				MemoryStream stream;
				{
					StreamWriter writer(stream);
					GuiIqPrint(query, writer);
				}
				stream.SeekFromBegin(0);
				{
					StreamReader reader(stream);
					attPath->value.value = reader.ReadToEnd();
				}
			}
			xmlStyle->attributes.Add(attPath);

			setter->FillXml(xmlStyle);
			return xmlStyle;
		}

/***********************************************************************
GuiInstanceStyleContext
***********************************************************************/

		Ptr<GuiInstanceStyleContext> GuiInstanceStyleContext::LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors)
		{
			auto context = MakePtr<GuiInstanceStyleContext>();
			FOREACH(Ptr<XmlElement>, styleElement, XmlGetElements(xml->rootElement))
			{
				if (styleElement->name.value == L"Style")
				{
					if (auto style = GuiInstanceStyle::LoadFromXml(styleElement, errors))
					{
						context->styles.Add(style);
					}
				}
				else
				{
					errors.Add(L"Unknown style type \"" + styleElement->name.value + L"\".");
				}
			}
			return context;
		}

		Ptr<parsing::xml::XmlDocument> GuiInstanceStyleContext::SaveToXml()
		{
			auto xmlStyles = MakePtr<XmlElement>();
			xmlStyles->name.value = L"Styles";

			FOREACH(Ptr<GuiInstanceStyle>, style, styles)
			{
				xmlStyles->subNodes.Add(style->SaveToXml());
			}

			auto doc = MakePtr<XmlDocument>();
			doc->rootElement = xmlStyles;
			return doc;
		}
	}
}

/***********************************************************************
GUIINSTANCESHAREDSCRIPT.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace parsing::xml;

/***********************************************************************
GuiInstanceSharedScript
***********************************************************************/

		Ptr<GuiInstanceSharedScript> GuiInstanceSharedScript::LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, collections::List<WString>& errors)
		{
			auto script = MakePtr<GuiInstanceSharedScript>();
			script->language = xml->rootElement->name.value;
			script->code = XmlGetValue(xml->rootElement);
			return script;
		}

		Ptr<parsing::xml::XmlElement> GuiInstanceSharedScript::SaveToXml()
		{
			auto cdata = MakePtr<XmlCData>();
			cdata->content.value = code;

			auto xml = MakePtr<XmlElement>();
			xml->name.value = language;
			xml->subNodes.Add(cdata);

			return xml;
		}
	}
}

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_COMPOSITIONS.CPP
***********************************************************************/

#ifndef VCZH_DEBUG_NO_REFLECTION

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{

/***********************************************************************
GuiAxisInstanceLoader
***********************************************************************/

			class GuiAxisInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;
				GlobalStringKey					_AxisDirection;

			public:
				GuiAxisInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiAxis>::content.typeName);
					_AxisDirection = GlobalStringKey::Get(L"AxisDirection");
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (typeInfo.typeName == GetTypeName())
					{
						propertyNames.Add(_AxisDirection);
					}
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _AxisDirection)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<AxisDirection>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						info->required = true;
						return info;
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				bool CanCreate(const TypeInfo& typeInfo)override
				{
					return typeName == typeInfo.typeName;
				}

				Ptr<workflow::WfStatement> CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					if (typeName == typeInfo.typeName)
					{
						vint indexAxisDirection = arguments.Keys().IndexOf(_AxisDirection);
						if (indexAxisDirection != -1)
						{
							auto createExpr = MakePtr<WfNewClassExpression>();
							createExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<GuiAxis>>::CreateTypeInfo().Obj());
							createExpr->arguments.Add(arguments.GetByIndex(indexAxisDirection)[0].expression);

							auto refVariable = MakePtr<WfReferenceExpression>();
							refVariable->name.value = variableName.ToString();

							auto assignExpr = MakePtr<WfBinaryExpression>();
							assignExpr->op = WfBinaryOperator::Assign;
							assignExpr->first = refVariable;
							assignExpr->second = createExpr;

							auto assignStat = MakePtr<WfExpressionStatement>();
							assignStat->expression = assignExpr;
							return assignStat;
						}
					}
					return nullptr;
				}
			};

/***********************************************************************
GuiCompositionInstanceLoader
***********************************************************************/

			class GuiCompositionInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;

			public:
				GuiCompositionInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiGraphicsComposition>::content.typeName);
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						auto info = GuiInstancePropertyInfo::Collection();
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiControl>());
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiGraphicsComposition>());
						info->acceptableTypes.Add(description::GetTypeDescriptor<IGuiGraphicsElement>());
						return info;
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::Empty)
						{
							auto value = values[0].expression;
							auto type = values[0].type;

							Ptr<WfExpression> expr;
							if (type->CanConvertTo(description::GetTypeDescriptor<IGuiGraphicsElement>()))
							{
								auto refComposition = MakePtr<WfReferenceExpression>();
								refComposition->name.value = variableName.ToString();

								auto refOwnedElement = MakePtr<WfMemberExpression>();
								refOwnedElement->parent = refComposition;
								refOwnedElement->name.value = L"OwnedElement";

								auto assign = MakePtr<WfBinaryExpression>();
								assign->op = WfBinaryOperator::Assign;
								assign->first = refOwnedElement;
								assign->second = value;

								expr = assign;
							}
							else if (type->CanConvertTo(description::GetTypeDescriptor<GuiControl>()))
							{
								auto refBoundsComposition = MakePtr<WfMemberExpression>();
								refBoundsComposition->parent = value;
								refBoundsComposition->name.value = L"BoundsComposition";

								auto refComposition = MakePtr<WfReferenceExpression>();
								refComposition->name.value = variableName.ToString();

								auto refAddChild = MakePtr<WfMemberExpression>();
								refAddChild->parent = refComposition;
								refAddChild->name.value = L"AddChild";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddChild;
								call->arguments.Add(refBoundsComposition);

								expr = call;
							}
							else if (type->CanConvertTo(description::GetTypeDescriptor<GuiGraphicsComposition>()))
							{
								auto refComposition = MakePtr<WfReferenceExpression>();
								refComposition->name.value = variableName.ToString();

								auto refAddChild = MakePtr<WfMemberExpression>();
								refAddChild->parent = refComposition;
								refAddChild->name.value = L"AddChild";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddChild;
								call->arguments.Add(value);

								expr = call;
							}

							if (expr)
							{
								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = expr;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
GuiTableCompositionInstanceLoader
***********************************************************************/

			class GuiTableCompositionInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;
				GlobalStringKey					_Rows, _Columns;

			public:
				GuiTableCompositionInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiTableComposition>::content.typeName);
					_Rows = GlobalStringKey::Get(L"Rows");
					_Columns = GlobalStringKey::Get(L"Columns");
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(_Rows);
					propertyNames.Add(_Columns);
				}

				void GetPairedProperties(const PropertyInfo& propertyInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (propertyInfo.propertyName == _Rows || propertyInfo.propertyName == _Columns)
					{
						propertyNames.Add(_Rows);
						propertyNames.Add(_Columns);
					}
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _Rows || propertyInfo.propertyName == _Columns)
					{
						return GuiInstancePropertyInfo::Array(description::GetTypeDescriptor<GuiCellOption>());
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						if (prop == _Rows)
						{
							auto indexColumns = arguments.Keys().IndexOf(_Columns);
							if (indexColumns != -1)
							{
								auto& rows = arguments.GetByIndex(index);
								auto& columns = arguments.GetByIndex(indexColumns);

								{
									auto refComposition = MakePtr<WfReferenceExpression>();
									refComposition->name.value = variableName.ToString();

									auto refSetRowsAndColumns = MakePtr<WfMemberExpression>();
									refSetRowsAndColumns->parent = refComposition;
									refSetRowsAndColumns->name.value = L"SetRowsAndColumns";

									auto rowsExpr = MakePtr<WfIntegerExpression>();
									rowsExpr->value.value = itow(rows.Count());

									auto columnsExpr = MakePtr<WfIntegerExpression>();
									columnsExpr->value.value = itow(columns.Count());

									auto call = MakePtr<WfCallExpression>();
									call->function = refSetRowsAndColumns;
									call->arguments.Add(rowsExpr);
									call->arguments.Add(columnsExpr);

									auto stat = MakePtr<WfExpressionStatement>();
									stat->expression = call;
									block->statements.Add(stat);
								}

								for (vint i = 0; i < rows.Count(); i++)
								{
									auto refComposition = MakePtr<WfReferenceExpression>();
									refComposition->name.value = variableName.ToString();

									auto refSetRowOption = MakePtr<WfMemberExpression>();
									refSetRowOption->parent = refComposition;
									refSetRowOption->name.value = L"SetRowOption";

									auto indexExpr = MakePtr<WfIntegerExpression>();
									indexExpr->value.value = itow(i);

									auto call = MakePtr<WfCallExpression>();
									call->function = refSetRowOption;
									call->arguments.Add(indexExpr);
									call->arguments.Add(rows[i].expression);

									auto stat = MakePtr<WfExpressionStatement>();
									stat->expression = call;
									block->statements.Add(stat);
								}

								for (vint i = 0; i < columns.Count(); i++)
								{
									auto refComposition = MakePtr<WfReferenceExpression>();
									refComposition->name.value = variableName.ToString();

									auto refSetColumnOption = MakePtr<WfMemberExpression>();
									refSetColumnOption->parent = refComposition;
									refSetColumnOption->name.value = L"SetColumnOption";

									auto indexExpr = MakePtr<WfIntegerExpression>();
									indexExpr->value.value = itow(i);

									auto call = MakePtr<WfCallExpression>();
									call->function = refSetColumnOption;
									call->arguments.Add(indexExpr);
									call->arguments.Add(columns[i].expression);

									auto stat = MakePtr<WfExpressionStatement>();
									stat->expression = call;
									block->statements.Add(stat);
								}
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
GuiCellCompositionInstanceLoader
***********************************************************************/

			class GuiCellCompositionInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;
				GlobalStringKey					_Site;

			public:
				GuiCellCompositionInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiCellComposition>::content.typeName);
					_Site = GlobalStringKey::Get(L"Site");
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(_Site);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _Site)
					{
						return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<SiteValue>());
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						if (prop == _Site)
						{
							SiteValue site;
							{
								auto siteExpr = arguments.GetByIndex(index)[0].expression;
								if (auto inferExpr = siteExpr.Cast<WfInferExpression>())
								{
									if (auto ctorExpr = inferExpr->expression.Cast<WfConstructorExpression>())
									{
										auto st = description::GetTypeDescriptor<vint>()->GetSerializableType();
										FOREACH(Ptr<WfConstructorArgument>, argument, ctorExpr->arguments)
										{
											if (auto keyExpr = argument->key.Cast<WfReferenceExpression>())
											{
												if (auto valueExpr = argument->value.Cast<WfIntegerExpression>())
												{
													Value value;
													if (st->Deserialize(valueExpr->value.value, value))
													{
														vint propValue = UnboxValue<vint>(value);
														if (keyExpr->name.value == L"row")
														{
															site.row = propValue;
														}
														else if (keyExpr->name.value == L"column")
														{
															site.column = propValue;
														}
														else if (keyExpr->name.value == L"rowSpan")
														{
															site.rowSpan = propValue;
														}
														else if (keyExpr->name.value == L"columnSpan")
														{
															site.columnSpan = propValue;
														}
														else
														{
															goto ILLEGAL_SITE_PROPERTY;
														}
														continue;
													}
												}
											}
											goto ILLEGAL_SITE_PROPERTY;
										}
										goto FINISH_SITE_PROPERTY;
									}
								}
							ILLEGAL_SITE_PROPERTY:
								errors.Add(L"Precompile: The value of property \"Site\" of type \"" + typeInfo.typeName.ToString() + L"\" is not in a right format: \"row:<integer> column:<integer> [rowSpan:<integer>] [columnSpan:<integer>]\".");
								continue;
							}
						FINISH_SITE_PROPERTY:;

							{
								auto refComposition = MakePtr<WfReferenceExpression>();
								refComposition->name.value = variableName.ToString();

								auto refSetSite = MakePtr<WfMemberExpression>();
								refSetSite->parent = refComposition;
								refSetSite->name.value = L"SetSite";

								auto call = MakePtr<WfCallExpression>();
								call->function = refSetSite;

								auto GetValueText = [](const Value& value)
								{
									WString result;
									auto st = value.GetTypeDescriptor()->GetSerializableType();
									st->Serialize(value, result);
									return result;
								};

								{
									auto arg = MakePtr<WfIntegerExpression>();
									arg->value.value = itow(site.row);
									call->arguments.Add(arg);
								}
								{
									auto arg = MakePtr<WfIntegerExpression>();
									arg->value.value = itow(site.column);
									call->arguments.Add(arg);
								}
								{
									auto arg = MakePtr<WfIntegerExpression>();
									arg->value.value = itow(site.rowSpan);
									call->arguments.Add(arg);
								}
								{
									auto arg = MakePtr<WfIntegerExpression>();
									arg->value.value = itow(site.columnSpan);
									call->arguments.Add(arg);
								}

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = call;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
Initialization
***********************************************************************/

			void LoadCompositions(IGuiInstanceLoaderManager* manager)
			{
				manager->SetLoader(new GuiAxisInstanceLoader);
				manager->SetLoader(new GuiCompositionInstanceLoader);
				manager->SetLoader(new GuiTableCompositionInstanceLoader);
				manager->SetLoader(new GuiCellCompositionInstanceLoader);
			}
		}
	}
}

#endif

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_DOCUMENT.CPP
***********************************************************************/

#ifndef VCZH_DEBUG_NO_REFLECTION

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{

/***********************************************************************
GuiDocumentItemInstanceLoader
***********************************************************************/

			class GuiDocumentItemInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;
				GlobalStringKey					_Name;

			public:
				GuiDocumentItemInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiDocumentItem>::content.typeName);
					_Name = GlobalStringKey::Get(L"Name");
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (typeInfo.typeName == GetTypeName())
					{
						propertyNames.Add(_Name);
					}
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						auto info = GuiInstancePropertyInfo::Collection();
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiControl>());
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiGraphicsComposition>());
						return info;
					}
					else if (propertyInfo.propertyName == _Name)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						info->required = true;
						return info;
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				
				bool CanCreate(const TypeInfo& typeInfo)override
				{
					return typeName == typeInfo.typeName;
				}

				Ptr<workflow::WfStatement> CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					if (typeInfo.typeName == GetTypeName())
					{
						vint indexName = arguments.Keys().IndexOf(_Name);	
						if (indexName != -1)
						{
							auto type = TypeInfoRetriver<Ptr<GuiDocumentItem>>::CreateTypeInfo();
							auto createExpr = MakePtr<WfNewClassExpression>();
							createExpr->type = GetTypeFromTypeInfo(type.Obj());
							createExpr->arguments.Add(arguments.GetByIndex(indexName)[0].expression);

							auto refVariable = MakePtr<WfReferenceExpression>();
							refVariable->name.value = variableName.ToString();

							auto assignExpr = MakePtr<WfBinaryExpression>();
							assignExpr->op = WfBinaryOperator::Assign;
							assignExpr->first = refVariable;
							assignExpr->second = createExpr;

							auto assignStat = MakePtr<WfExpressionStatement>();
							assignStat->expression = assignExpr;
							return assignStat;
						}
					}
					return nullptr;
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::Empty)
						{
							auto value = values[0].expression;
							auto type = values[0].type;

							Ptr<WfExpression> compositionExpr;
							if (type->CanConvertTo(description::GetTypeDescriptor<GuiControl>()))
							{
								auto member = MakePtr<WfMemberExpression>();
								member->parent = value;
								member->name.value = L"BoundsComposition";
								compositionExpr = member;
							}
							else if (type->CanConvertTo(description::GetTypeDescriptor<GuiGraphicsComposition>()))
							{
								compositionExpr = value;
							}

							if (compositionExpr)
							{
								auto refItem = MakePtr<WfReferenceExpression>();
								refItem->name.value = variableName.ToString();

								auto refContainer = MakePtr<WfMemberExpression>();
								refContainer->parent = refItem;
								refContainer->name.value = L"Container";

								auto refAddChild = MakePtr<WfMemberExpression>();
								refAddChild->parent = refContainer;
								refAddChild->name.value = L"AddChild";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddChild;
								call->arguments.Add(compositionExpr);

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = call;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
GuiDocumentViewerInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiDocumentViewer, GuiDocumentViewerTemplate_StyleProvider, GuiDocumentViewerTemplate>
			class GuiDocumentViewerInstanceLoader : public BASE_TYPE
			{
			public:
				GuiDocumentViewerInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiDocumentViewer>::content.typeName, L"CreateDocumentViewerStyle")
				{
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiDocumentItem>());
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::Empty)
						{
							auto type = values[0].type;

							auto refControl = MakePtr<WfReferenceExpression>();
							refControl->name.value = variableName.ToString();

							auto refAddDocumentItem = MakePtr<WfMemberExpression>();
							refAddDocumentItem->parent = refControl;
							refAddDocumentItem->name.value = L"AddDocumentItem";

							auto call = MakePtr<WfCallExpression>();
							call->function = refAddDocumentItem;
							call->arguments.Add(values[0].expression);

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = call;
							block->statements.Add(stat);
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiDocumentLabelInstanceLoader
***********************************************************************/
		
#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiDocumentLabel, GuiDocumentLabelTemplate_StyleProvider, GuiDocumentLabelTemplate>
			class GuiDocumentLabelInstanceLoader : public BASE_TYPE
			{
			public:
				GuiDocumentLabelInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiDocumentLabel>::content.typeName, L"CreateDocumentLabelStyle")
				{
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiDocumentItem>());
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::Empty)
						{
							auto type = values[0].type;

							auto refControl = MakePtr<WfReferenceExpression>();
							refControl->name.value = variableName.ToString();

							auto refAddDocumentItem = MakePtr<WfMemberExpression>();
							refAddDocumentItem->parent = refControl;
							refAddDocumentItem->name.value = L"AddDocumentItem";

							auto call = MakePtr<WfCallExpression>();
							call->function = refAddDocumentItem;
							call->arguments.Add(values[0].expression);

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = call;
							block->statements.Add(stat);
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
				}
			};
#undef BASE_TYPE

/***********************************************************************
Initialization
***********************************************************************/

			void LoadDocumentControls(IGuiInstanceLoaderManager* manager)
			{
				manager->SetLoader(new GuiDocumentItemInstanceLoader);
				manager->SetLoader(new GuiDocumentViewerInstanceLoader);
				manager->SetLoader(new GuiDocumentLabelInstanceLoader);
			}
		}
	}
}

#endif

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_LIST.CPP
***********************************************************************/

#ifndef VCZH_DEBUG_NO_REFLECTION

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{

			template<typename IItemTemplateStyle, typename ITemplate>
			Ptr<WfStatement> CreateSetControlTemplateStyle(GlobalStringKey variableName, Ptr<WfExpression> argument, const IGuiInstanceLoader::TypeInfo& controlTypeInfo, const WString& propertyName, collections::List<WString>& errors)
			{
				using Helper = GuiTemplateControlInstanceLoader<Value, Value, ITemplate>;
				List<ITypeDescriptor*> controlTemplateTds;
				Helper::GetItemTemplateType(argument, controlTemplateTds, controlTypeInfo, GlobalStringKey::_ItemTemplate.ToString(), errors);

				if (controlTemplateTds.Count() > 0)
				{
					auto refFactory = Helper::CreateTemplateFactory(controlTemplateTds, errors);
					auto createStyle = MakePtr<WfNewClassExpression>();
					createStyle->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<IItemTemplateStyle>>::CreateTypeInfo().Obj());
					createStyle->arguments.Add(refFactory);

					auto refControl = MakePtr<WfReferenceExpression>();
					refControl->name.value = variableName.ToString();

					auto refStyleProvider = MakePtr<WfMemberExpression>();
					refStyleProvider->parent = refControl;
					refStyleProvider->name.value = propertyName;

					auto assign = MakePtr<WfBinaryExpression>();
					assign->op = WfBinaryOperator::Assign;
					assign->first = refStyleProvider;
					assign->second = createStyle;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assign;
					return stat;
				}

				return nullptr;
			}

/***********************************************************************
GuiSelectableListControlInstanceLoader
***********************************************************************/

			class GuiSelectableListControlInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;

			public:
				GuiSelectableListControlInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiSelectableListControl>::content.typeName);
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::_ItemTemplate);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::_ItemTemplate)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
						return info;
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::_ItemTemplate)
						{
							if (auto stat = CreateSetControlTemplateStyle<GuiTextListItemTemplate_ItemStyleProvider, GuiTextListItemTemplate>(variableName, arguments.GetByIndex(index)[0].expression, typeInfo, L"StyleProvider", errors))
							{
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
GuiVirtualTreeViewInstanceLoader
***********************************************************************/

			class GuiVirtualTreeViewInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;

			public:
				GuiVirtualTreeViewInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiVirtualTreeView>::content.typeName);
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::_ItemTemplate);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::_ItemTemplate)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
						return info;
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::_ItemTemplate)
						{
							if (auto stat = CreateSetControlTemplateStyle<GuiTreeItemTemplate_ItemStyleProvider, GuiTreeItemTemplate>(variableName, arguments.GetByIndex(index)[0].expression, typeInfo, L"NodeStyleProvider", errors))
							{
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
GuiComboBoxInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiComboBoxListControl, GuiComboBoxTemplate_StyleProvider, GuiComboBoxTemplate>
			class GuiComboBoxInstanceLoader : public BASE_TYPE
			{
			protected:
				GlobalStringKey						_ListControl;

				void AddAdditionalArguments(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfNewClassExpression> createControl)override
				{
					vint indexListControl = arguments.Keys().IndexOf(_ListControl);
					if (indexListControl != -1)
					{
						createControl->arguments.Add(arguments.GetByIndex(indexListControl)[0].expression);
					}
				}
			public:
				GuiComboBoxInstanceLoader()
					:BASE_TYPE(L"presentation::controls::GuiComboBox", L"CreateComboBoxStyle")
				{
					_ListControl = GlobalStringKey::Get(L"ListControl");
				}

				void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (typeInfo.typeName == GetTypeName())
					{
						propertyNames.Add(_ListControl);
					propertyNames.Add(GlobalStringKey::_ItemTemplate);
					}
					BASE_TYPE::GetConstructorParameters(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _ListControl)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<GuiSelectableListControl>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						info->required = true;
						return info;
					}
					else if (propertyInfo.propertyName == GlobalStringKey::_ItemTemplate)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
						return info;
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::_ItemTemplate)
						{
							if (auto stat = CreateSetControlTemplateStyle<GuiControlTemplate_ItemStyleProvider, GuiControlTemplate>(variableName, arguments.GetByIndex(index)[0].expression, typeInfo, L"StyleProvider", errors))
							{
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiListViewInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<TControl, GuiListViewTemplate_StyleProvider, GuiListViewTemplate>
			template<typename TControl>
			class GuiListViewInstanceLoaderBase : public BASE_TYPE
			{
			protected:
				GlobalStringKey		_View, _IconSize;

				void PrepareAdditionalArgumentsAfterCreation(const typename BASE_TYPE::TypeInfo& typeInfo, GlobalStringKey variableName, typename BASE_TYPE::ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfBlockStatement> block)override
				{
					auto view = ListViewViewType::Detail;
					Ptr<WfExpression> iconSize;
					{
						vint indexView = arguments.Keys().IndexOf(_View);
						if (indexView != -1)
						{
							auto viewExpr = arguments.GetByIndex(indexView)[0].expression;
							if (auto inferExpr = viewExpr.template Cast<WfInferExpression>())
							{
								if (auto refExpr = inferExpr->expression.template Cast<WfReferenceExpression>())
								{
									auto enumType = description::GetTypeDescriptor<ListViewViewType>()->GetEnumType();
									vint index = enumType->IndexOfItem(refExpr->name.value);
									if (index == -1)
									{
										goto ILLEGAL_VIEW_PROPERTY;
									}
									
									view = UnboxValue<ListViewViewType>(enumType->ToEnum(enumType->GetItemValue(index)));
									goto FINISH_VIEW_PROPERTY;
								}
							}
						ILLEGAL_VIEW_PROPERTY:
							errors.Add(L"Precompile: The value of property \"View\" of type \"" + typeInfo.typeName.ToString() + L"\" is not in a right format.");
						FINISH_VIEW_PROPERTY:;
						}

						vint indexIconSize = arguments.Keys().IndexOf(_IconSize);
						if (indexIconSize != -1)
						{
							iconSize = arguments.GetByIndex(indexIconSize)[0].expression;
						}
					}

					Ptr<ITypeInfo> itemStyleType;
					switch (view)
					{
#define VIEW_TYPE_CASE(NAME) case ListViewViewType::NAME: itemStyleType = TypeInfoRetriver<Ptr<list::ListView##NAME##ContentProvider>>::CreateTypeInfo(); break;
						VIEW_TYPE_CASE(BigIcon)
						VIEW_TYPE_CASE(SmallIcon)
						VIEW_TYPE_CASE(List)
						VIEW_TYPE_CASE(Tile)
						VIEW_TYPE_CASE(Information)
						VIEW_TYPE_CASE(Detail)
#undef VIEW_TYPE_CASE
					}

					auto createStyle = MakePtr<WfNewClassExpression>();
					createStyle->type = GetTypeFromTypeInfo(itemStyleType.Obj());

					if (iconSize)
					{
						createStyle->arguments.Add(iconSize);

						auto falseValue = MakePtr<WfLiteralExpression>();
						falseValue->value = WfLiteralValue::False;
						createStyle->arguments.Add(falseValue);
					}
					else
					{
						{
							auto stringValue = MakePtr<WfStringExpression>();
							stringValue->value.value = L"x:32 y:32";

							auto iconSizeValue = MakePtr<WfTypeCastingExpression>();
							iconSizeValue->type = GetTypeFromTypeInfo(TypeInfoRetriver<Size>::CreateTypeInfo().Obj());
							iconSizeValue->expression = stringValue;

							createStyle->arguments.Add(iconSizeValue);
						}
						{
							auto trueValue = MakePtr<WfLiteralExpression>();
							trueValue->value = WfLiteralValue::True;
							createStyle->arguments.Add(trueValue);
						}
					}

					auto refControl = MakePtr<WfReferenceExpression>();
					refControl->name.value = variableName.ToString();

					auto refChangeItemStyle = MakePtr<WfMemberExpression>();
					refChangeItemStyle->parent = refControl;
					refChangeItemStyle->name.value = L"ChangeItemStyle";

					auto call = MakePtr<WfCallExpression>();
					call->function = refChangeItemStyle;
					call->arguments.Add(createStyle);

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = call;
					block->statements.Add(stat);
				}

			public:
				GuiListViewInstanceLoaderBase()
					:BASE_TYPE(description::TypeInfo<TControl>::content.typeName, L"CreateListViewStyle")
				{
					_View = GlobalStringKey::Get(L"View");
					_IconSize = GlobalStringKey::Get(L"IconSize");
				}

				void GetConstructorParameters(const typename BASE_TYPE::TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (typeInfo.typeName == BASE_TYPE::GetTypeName())
					{
						propertyNames.Add(_View);
						propertyNames.Add(_IconSize);
					}
					BASE_TYPE::GetConstructorParameters(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const typename BASE_TYPE::PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _View)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<ListViewViewType>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						return info;
					}
					else if (propertyInfo.propertyName == _IconSize)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Size>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						return info;
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}
			};
#undef BASE_TYPE

			class GuiListViewInstanceLoader : public GuiListViewInstanceLoaderBase<GuiListView>
			{
			};

			class GuiBindableListViewInstanceLoader : public GuiListViewInstanceLoaderBase<GuiBindableListView>
			{
			};

/***********************************************************************
GuiTreeViewInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<TControl, GuiTreeViewTemplate_StyleProvider, GuiTreeViewTemplate>
			template<typename TControl>
			class GuiTreeViewInstanceLoaderBase : public BASE_TYPE
			{
			protected:
				bool				bindable;
				GlobalStringKey		_Nodes, _IconSize;

				void PrepareAdditionalArgumentsAfterCreation(const typename BASE_TYPE::TypeInfo& typeInfo, GlobalStringKey variableName, typename BASE_TYPE::ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfBlockStatement> block)override
				{
					vint indexIconSize = arguments.Keys().IndexOf(_IconSize);
					if (indexIconSize != -1)
					{
						Ptr<ITypeInfo> itemStyleType = TypeInfoRetriver<Ptr<tree::TreeViewNodeItemStyleProvider>>::CreateTypeInfo();

						auto createStyle = MakePtr<WfNewClassExpression>();
						createStyle->type = GetTypeFromTypeInfo(itemStyleType.Obj());
						{
							auto iconSize = arguments.GetByIndex(indexIconSize)[0].expression;
							createStyle->arguments.Add(iconSize);
						}
						{
							auto falseValue = MakePtr<WfLiteralExpression>();
							falseValue->value = WfLiteralValue::False;
							createStyle->arguments.Add(falseValue);
						}

						auto refControl = MakePtr<WfReferenceExpression>();
						refControl->name.value = variableName.ToString();

						auto refSetNodeStyleProvider = MakePtr<WfMemberExpression>();
						refSetNodeStyleProvider->parent = refControl;
						refSetNodeStyleProvider->name.value = L"SetNodeStyleProvider";

						auto call = MakePtr<WfCallExpression>();
						call->function = refSetNodeStyleProvider;
						call->arguments.Add(createStyle);

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = call;
						block->statements.Add(stat);
					}
				}

			public:
				GuiTreeViewInstanceLoaderBase(bool _bindable)
					:BASE_TYPE(description::TypeInfo<TControl>::content.typeName, L"CreateTreeViewStyle")
					, bindable(_bindable)
				{
					_Nodes = GlobalStringKey::Get(L"Nodes");
					_IconSize = GlobalStringKey::Get(L"IconSize");
				}

				void GetPropertyNames(const typename BASE_TYPE::TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (!bindable)
					{
						propertyNames.Add(_Nodes);
					}
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				void GetConstructorParameters(const typename BASE_TYPE::TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (typeInfo.typeName == BASE_TYPE::GetTypeName())
					{
						propertyNames.Add(_IconSize);
					}
					BASE_TYPE::GetConstructorParameters(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const typename BASE_TYPE::PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _Nodes)
					{
						if (!bindable)
						{
							return GuiInstancePropertyInfo::Collection(description::GetTypeDescriptor<tree::MemoryNodeProvider>());
						}
					}
					else if (propertyInfo.propertyName == _IconSize)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Size>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						return info;
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const typename BASE_TYPE::TypeInfo& typeInfo, GlobalStringKey variableName, typename BASE_TYPE::ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						if (prop == _Nodes)
						{
							auto refControl = MakePtr<WfReferenceExpression>();
							refControl->name.value = variableName.ToString();

							auto refNodes = MakePtr<WfMemberExpression>();
							refNodes->parent = refControl;
							refNodes->name.value = L"Nodes";

							auto refChildren = MakePtr<WfMemberExpression>();
							refChildren->parent = refNodes;
							refChildren->name.value = L"Children";

							auto refAdd = MakePtr<WfMemberExpression>();
							refAdd->parent = refChildren;
							refAdd->name.value = L"Add";

							auto call = MakePtr<WfCallExpression>();
							call->function = refAdd;
							call->arguments.Add(arguments.GetByIndex(index)[0].expression);

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = call;
							block->statements.Add(stat);
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
				}
			};
#undef BASE_TYPE

			class GuiTreeViewInstanceLoader : public GuiTreeViewInstanceLoaderBase<GuiTreeView>
			{
			public:
				GuiTreeViewInstanceLoader()
					:GuiTreeViewInstanceLoaderBase<GuiTreeView>(false)
				{
				}
			};

			class GuiBindableTreeViewInstanceLoader : public GuiTreeViewInstanceLoaderBase<GuiBindableTreeView>
			{
			public:
				GuiBindableTreeViewInstanceLoader()
					:GuiTreeViewInstanceLoaderBase<GuiBindableTreeView>(true)
				{
				}
			};

/***********************************************************************
GuiBindableTextListInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiBindableTextList, GuiTextListTemplate_StyleProvider, GuiTextListTemplate>
			class GuiBindableTextListInstanceLoader : public BASE_TYPE
			{
			public:
				GuiBindableTextListInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiBindableTextList>::content.typeName, L"CreateTextListStyle", L"CreateTextListItemStyle")
				{
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiBindableDataColumnInstanceLoader
***********************************************************************/

			class GuiBindableDataColumnInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey		typeName;
				GlobalStringKey		_VisualizerTemplates;
				GlobalStringKey		_EditorTemplate;

			public:
				GuiBindableDataColumnInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<list::BindableDataColumn>::content.typeName);
					_VisualizerTemplates = GlobalStringKey::Get(L"VisualizerTemplates");
					_EditorTemplate = GlobalStringKey::Get(L"EditorTemplate");
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(_VisualizerTemplates);
					propertyNames.Add(_EditorTemplate);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _VisualizerTemplates)
					{
						return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					}
					else if (propertyInfo.propertyName == _EditorTemplate)
					{
						return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						if (prop == _VisualizerTemplates)
						{
							using Helper = GuiTemplateControlInstanceLoader<Value, Value, GuiGridVisualizerTemplate>;
							List<ITypeDescriptor*> controlTemplateTds;
							Helper::GetItemTemplateType(arguments.GetByIndex(index)[0].expression, controlTemplateTds, typeInfo, _EditorTemplate.ToString(), errors);

							if (controlTemplateTds.Count() > 0)
							{
								FOREACH_INDEXER(ITypeDescriptor*, controlTemplateTd, index, controlTemplateTds)
								{
									auto refFactory = Helper::CreateTemplateFactory(controlTemplateTd, errors);
									auto createStyle = MakePtr<WfNewClassExpression>();
									if (index == 0)
									{
										createStyle->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<GuiBindableDataVisualizer::Factory>>::CreateTypeInfo().Obj());
									}
									else
									{
										createStyle->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<GuiBindableDataVisualizer::DecoratedFactory>>::CreateTypeInfo().Obj());
									}
									createStyle->arguments.Add(refFactory);
									{
										auto refContainer = MakePtr<WfReferenceExpression>();
										refContainer->name.value = variableName.ToString();
										createStyle->arguments.Add(refContainer);
									}
									if (index > 0)
									{
										auto refPreviousFactory = MakePtr<WfReferenceExpression>();
										refPreviousFactory->name.value = L"<factory>" + itow(index - 1);
										createStyle->arguments.Add(refPreviousFactory);
									}

									auto varDecl = MakePtr<WfVariableDeclaration>();
									varDecl->name.value = L"<factory>" + itow(index);
									varDecl->expression = createStyle;

									auto stat = MakePtr<WfVariableStatement>();
									stat->variable = varDecl;
									block->statements.Add(stat);
								}

								auto refContainer = MakePtr<WfReferenceExpression>();
								refContainer->name.value = variableName.ToString();

								auto refVisualizerFactory = MakePtr<WfMemberExpression>();
								refVisualizerFactory->parent = refContainer;
								refVisualizerFactory->name.value = L"Visualizer";
									
								auto refLastFactory = MakePtr<WfMemberExpression>();
								refLastFactory->parent = refContainer;
								refLastFactory->name.value = L"<factory>" + itow(controlTemplateTds.Count() - 1);

								auto assign = MakePtr<WfBinaryExpression>();
								assign->op = WfBinaryOperator::Assign;
								assign->first = refVisualizerFactory;
								assign->second = refLastFactory;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = assign;
								block->statements.Add(stat);
							}
						}
						else if (prop == _EditorTemplate)
						{
							using Helper = GuiTemplateControlInstanceLoader<Value, Value, GuiGridEditorTemplate>;
							List<ITypeDescriptor*> controlTemplateTds;
							Helper::GetItemTemplateType(arguments.GetByIndex(index)[0].expression, controlTemplateTds, typeInfo, _EditorTemplate.ToString(), errors);

							if (controlTemplateTds.Count() > 0)
							{
								auto refFactory = Helper::CreateTemplateFactory(controlTemplateTds, errors);
								auto createStyle = MakePtr<WfNewClassExpression>();
								createStyle->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<GuiBindableDataEditor::Factory>>::CreateTypeInfo().Obj());
								createStyle->arguments.Add(refFactory);
								{
									auto refContainer = MakePtr<WfReferenceExpression>();
									refContainer->name.value = variableName.ToString();
									createStyle->arguments.Add(refContainer);
								}

								auto refContainer = MakePtr<WfReferenceExpression>();
								refContainer->name.value = variableName.ToString();

								auto refEditorFactory = MakePtr<WfMemberExpression>();
								refEditorFactory->parent = refContainer;
								refEditorFactory->name.value = L"EditorFactory";

								auto assign = MakePtr<WfBinaryExpression>();
								assign->op = WfBinaryOperator::Assign;
								assign->first = refEditorFactory;
								assign->second = createStyle;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = assign;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
GuiBindableDataGridInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiBindableDataGrid, GuiListViewTemplate_StyleProvider, GuiListViewTemplate>
			class GuiBindableDataGridInstanceLoader : public BASE_TYPE
			{
			protected:
				GlobalStringKey		typeName;
				GlobalStringKey		_ViewModelContext;
				GlobalStringKey		_Columns;
				
				void AddAdditionalArguments(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors, Ptr<WfNewClassExpression> createControl)override
				{
					auto indexViewModelContext = arguments.Keys().IndexOf(_ViewModelContext);
					if (indexViewModelContext == -1)
					{
						auto nullExpr = MakePtr<WfLiteralExpression>();
						nullExpr->value = WfLiteralValue::Null;
						createControl->arguments.Add(nullExpr);
					}
					else
					{
						createControl->arguments.Add(arguments.GetByIndex(indexViewModelContext)[0].expression);
					}
				}
			public:
				GuiBindableDataGridInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiBindableDataGrid>::content.typeName, L"CreateListViewStyle")
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiBindableDataGrid>::content.typeName);
					_ViewModelContext = GlobalStringKey::Get(L"ViewModelContext");
					_Columns = GlobalStringKey::Get(L"Columns");
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(_Columns);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				void GetConstructorParameters(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					if (typeInfo.typeName == GetTypeName())
					{
						propertyNames.Add(_ViewModelContext);
					}
					BASE_TYPE::GetConstructorParameters(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _Columns)
					{
						return GuiInstancePropertyInfo::Collection(description::GetTypeDescriptor<list::BindableDataColumn>());
					}
					else if (propertyInfo.propertyName == _ViewModelContext)
					{
						auto info = GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Value>());
						info->scope = GuiInstancePropertyInfo::Constructor;
						info->bindable = true;
						return info;
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						if (prop == _Columns)
						{
							auto refControl = MakePtr<WfReferenceExpression>();
							refControl->name.value = variableName.ToString();

							auto refAddBindableColumn = MakePtr<WfMemberExpression>();
							refAddBindableColumn->parent = refControl;
							refAddBindableColumn->name.value = L"AddBindableColumn";

							auto call = MakePtr<WfCallExpression>();
							call->function = refAddBindableColumn;
							call->arguments.Add(arguments.GetByIndex(index)[0].expression);

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = call;
							block->statements.Add(stat);
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiTreeNodeInstanceLoader
***********************************************************************/

			class GuiTreeNodeInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey							typeName;
				GlobalStringKey							_Text, _Image, _Tag;

			public:
				GuiTreeNodeInstanceLoader()
					:typeName(GlobalStringKey::Get(L"presentation::controls::tree::TreeNode"))
				{
					_Text = GlobalStringKey::Get(L"Text");
					_Image = GlobalStringKey::Get(L"Image");
					_Tag = GlobalStringKey::Get(L"Tag");
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(_Text);
					propertyNames.Add(_Image);
					propertyNames.Add(_Tag);
					propertyNames.Add(GlobalStringKey::Empty);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _Text)
					{
						return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<WString>());
					}
					else if (propertyInfo.propertyName == _Image)
					{
						return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<GuiImageData>());
					}
					else if (propertyInfo.propertyName == _Tag)
					{
						return GuiInstancePropertyInfo::Assign(description::GetTypeDescriptor<Value>());
					}
					else if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						return GuiInstancePropertyInfo::Collection(description::GetTypeDescriptor<tree::MemoryNodeProvider>());
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				bool CanCreate(const TypeInfo& typeInfo)override
				{
					return typeInfo.typeName == GetTypeName();
				}

				Ptr<workflow::WfStatement> CreateInstance(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					if (typeInfo.typeName == GetTypeName())
					{
						auto createItem = MakePtr<WfNewClassExpression>();
						createItem->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<tree::TreeViewItem>>::CreateTypeInfo().Obj());

						auto createNode = MakePtr<WfNewClassExpression>();
						createNode->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<tree::MemoryNodeProvider>>::CreateTypeInfo().Obj());
						createNode->arguments.Add(createItem);

						auto refNode = MakePtr<WfReferenceExpression>();
						refNode->name.value = variableName.ToString();

						auto assign = MakePtr<WfBinaryExpression>();
						assign->op = WfBinaryOperator::Assign;
						assign->first = refNode;
						assign->second = createNode;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = assign;
						return stat;
					}
					return nullptr;
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						if (prop == GlobalStringKey::Empty)
						{
							auto refNode = MakePtr<WfReferenceExpression>();
							refNode->name.value = variableName.ToString();

							auto refChildren = MakePtr<WfMemberExpression>();
							refChildren->parent = refNode;
							refChildren->name.value = L"Children";

							auto refAdd = MakePtr<WfMemberExpression>();
							refAdd->parent = refChildren;
							refAdd->name.value = L"Add";

							auto call = MakePtr<WfCallExpression>();
							call->function = refAdd;
							call->arguments.Add(arguments.GetByIndex(index)[0].expression);

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = call;
							block->statements.Add(stat);
						}
						else if (prop == _Text || prop == _Image || prop == _Tag)
						{
							{
								auto refNode = MakePtr<WfReferenceExpression>();
								refNode->name.value = variableName.ToString();

								auto refData = MakePtr<WfMemberExpression>();
								refData->parent = refNode;
								refData->name.value = L"Data";

								auto castExpr = MakePtr<WfTypeCastingExpression>();
								castExpr->strategy = WfTypeCastingStrategy::Strong;
								castExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<tree::TreeViewItem>>::CreateTypeInfo().Obj());
								castExpr->expression = refData;

								auto refProp = MakePtr<WfMemberExpression>();
								refProp->parent = castExpr;
								if (prop == _Text)
								{
									refProp->name.value = L"text";
								}
								else if (prop == _Image)
								{
									refProp->name.value = L"image";
								}
								else if (prop == _Tag)
								{
									refProp->name.value = L"tag";
								}

								auto assign = MakePtr<WfBinaryExpression>();
								assign->op = WfBinaryOperator::Assign;
								assign->first = refProp;
								assign->second = arguments.GetByIndex(index)[0].expression;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = assign;
								block->statements.Add(stat);
							}

							if (prop != _Tag)
							{
								auto refNode = MakePtr<WfReferenceExpression>();
								refNode->name.value = variableName.ToString();

								auto refNotifyDataModified = MakePtr<WfMemberExpression>();
								refNotifyDataModified->parent = refNode;
								refNotifyDataModified->name.value = L"NotifyDataModified";

								auto call = MakePtr<WfCallExpression>();
								call->function = refNotifyDataModified;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = call;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
Initialization
***********************************************************************/

			void LoadListControls(IGuiInstanceLoaderManager* manager)
			{
				manager->CreateVirtualType(
					GlobalStringKey::Get(description::TypeInfo<GuiComboBoxListControl>::content.typeName),
					new GuiComboBoxInstanceLoader
					);

				manager->SetLoader(new GuiSelectableListControlInstanceLoader);
				manager->SetLoader(new GuiVirtualTreeViewInstanceLoader);

				manager->SetLoader(new GuiListViewInstanceLoader);
				manager->SetLoader(new GuiBindableListViewInstanceLoader);

				manager->SetLoader(new GuiTreeViewInstanceLoader);
				manager->SetLoader(new GuiBindableTreeViewInstanceLoader);

				manager->SetLoader(new GuiBindableTextListInstanceLoader);

				manager->SetLoader(new GuiBindableDataColumnInstanceLoader);
				manager->SetLoader(new GuiBindableDataGridInstanceLoader);
				
				manager->CreateVirtualType(
					GlobalStringKey::Get(description::TypeInfo<tree::MemoryNodeProvider>::content.typeName),
					new GuiTreeNodeInstanceLoader
					);
			}
		}
	}
}

#endif

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_PLUGIN.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{

#ifndef VCZH_DEBUG_NO_REFLECTION

/***********************************************************************
GuiControlInstanceLoader
***********************************************************************/

			class GuiControlInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;

			public:
				GuiControlInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiControl>::content.typeName);
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						auto info = GuiInstancePropertyInfo::Collection();
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiControl>());
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiGraphicsComposition>());
						if (propertyInfo.typeInfo.typeDescriptor->CanConvertTo(description::GetTypeDescriptor<GuiInstanceRootObject>()))
						{
							info->acceptableTypes.Add(description::GetTypeDescriptor<GuiComponent>());
						}
						return info;
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::Empty)
						{
							auto value = values[0].expression;
							auto type = values[0].type;

							Ptr<WfExpression> expr;
							if (type->CanConvertTo(description::GetTypeDescriptor<GuiComponent>()))
							{
								auto refControl = MakePtr<WfReferenceExpression>();
								refControl->name.value = variableName.ToString();

								auto refAddComponent = MakePtr<WfMemberExpression>();
								refAddComponent->parent = refControl;
								refAddComponent->name.value = L"AddComponent";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddComponent;
								call->arguments.Add(value);

								expr = call;
							}
							else if (type->CanConvertTo(description::GetTypeDescriptor<GuiControlHost>()))
							{
								auto refControl = MakePtr<WfReferenceExpression>();
								refControl->name.value = variableName.ToString();

								auto refAddControlHostComponent = MakePtr<WfMemberExpression>();
								refAddControlHostComponent->parent = refControl;
								refAddControlHostComponent->name.value = L"AddControlHostComponent";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddControlHostComponent;
								call->arguments.Add(value);

								expr = call;
							}
							else if (type->CanConvertTo(description::GetTypeDescriptor<GuiControl>()))
							{
								auto refControl = MakePtr<WfReferenceExpression>();
								refControl->name.value = variableName.ToString();

								auto refAddChild = MakePtr<WfMemberExpression>();
								refAddChild->parent = refControl;
								refAddChild->name.value = L"AddChild";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddChild;
								call->arguments.Add(value);

								expr = call;
							}
							else if (type->CanConvertTo(description::GetTypeDescriptor<GuiGraphicsComposition>()))
							{
								auto refControl = MakePtr<WfReferenceExpression>();
								refControl->name.value = variableName.ToString();

								auto refContainerComposition = MakePtr<WfMemberExpression>();
								refContainerComposition->parent = refControl;
								refContainerComposition->name.value = L"ContainerComposition";

								auto refAddChild = MakePtr<WfMemberExpression>();
								refAddChild->parent = refContainerComposition;
								refAddChild->name.value = L"AddChild";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddChild;
								call->arguments.Add(value);

								expr = call;
							}

							if (expr)
							{
								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = expr;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

#endif
			
/***********************************************************************
GuiPredefinedInstanceLoadersPlugin
***********************************************************************/

			Ptr<WfExpression> CreateStandardDataPicker(IGuiInstanceLoader::ArgumentMap&)
			{
				using TControl = GuiDatePicker;
				using TControlStyle = GuiDateComboBoxTemplate_StyleProvider;
				using TTemplate = GuiDatePickerTemplate;

				auto controlType = TypeInfoRetriver<TControl*>::CreateTypeInfo();
				auto createControl = MakePtr<WfNewClassExpression>();
				createControl->type = GetTypeFromTypeInfo(controlType.Obj());
				createControl->arguments.Add(GuiTemplateControlInstanceLoader<TControl, TControlStyle, TTemplate>::CreateIThemeCall(L"CreateDatePickerStyle"));

				return createControl;
			}

			void InitializeTrackerProgressBar(const WString& variableName, Ptr<WfBlockStatement> block)
			{
				auto refVariable = MakePtr<WfReferenceExpression>();
				refVariable->name.value = variableName;

				auto refSetPageSize = MakePtr<WfMemberExpression>();
				refSetPageSize->parent = refVariable;
				refSetPageSize->name.value = L"SetPageSize";

				auto refZero = MakePtr<WfIntegerExpression>();
				refZero->value.value = L"0";

				auto call = MakePtr<WfCallExpression>();
				call->function = refSetPageSize;
				call->arguments.Add(refZero);

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = call;
				block->statements.Add(stat);
			}

			extern void LoadTabControls(IGuiInstanceLoaderManager* manager);
			extern void LoadToolstripControls(IGuiInstanceLoaderManager* manager);
			extern void LoadListControls(IGuiInstanceLoaderManager* manager);
			extern void LoadDocumentControls(IGuiInstanceLoaderManager* manager);
			extern void LoadCompositions(IGuiInstanceLoaderManager* manager);

			class GuiPredefinedInstanceLoadersPlugin : public Object, public IGuiPlugin
			{
			public:
				void Load()override
				{
				}

				void AfterLoad()override
				{
	#ifndef VCZH_DEBUG_NO_REFLECTION
					IGuiInstanceLoaderManager* manager=GetInstanceLoaderManager();

	#define ADD_VIRTUAL_TYPE_LOADER(TYPENAME, LOADER)\
		manager->CreateVirtualType(\
			GlobalStringKey::Get(description::TypeInfo<TYPENAME>::content.typeName),\
			new LOADER\
			)

	#define ADD_TEMPLATE_CONTROL(TYPENAME, STYLE_METHOD, TEMPLATE)\
		manager->SetLoader(\
		new GuiTemplateControlInstanceLoader<TYPENAME, TEMPLATE##_StyleProvider, TEMPLATE>(\
				L"presentation::controls::" L ## #TYPENAME,\
				L ## #STYLE_METHOD\
				)\
			)

	#define ADD_TEMPLATE_CONTROL_2(TYPENAME, STYLE_METHOD, ARGUMENT_METHOD, TEMPLATE)\
		manager->SetLoader(\
		new GuiTemplateControlInstanceLoader<TYPENAME, TEMPLATE##_StyleProvider, TEMPLATE>(\
				L"presentation::controls::" L ## #TYPENAME,\
				L ## #STYLE_METHOD,\
				L ## #ARGUMENT_METHOD\
				)\
			)

	#define ADD_TEMPLATE_CONTROL_3(TYPENAME, STYLE_METHOD, ARGUMENT_FUNCTION, TEMPLATE)\
		manager->SetLoader(\
		new GuiTemplateControlInstanceLoader<TYPENAME, TEMPLATE##_StyleProvider, TEMPLATE>(\
				L"presentation::controls::" L ## #TYPENAME,\
				L ## #STYLE_METHOD,\
				ARGUMENT_FUNCTION\
				)\
			)

	#define ADD_VIRTUAL_CONTROL(VIRTUALTYPENAME, TYPENAME, STYLE_METHOD, TEMPLATE)\
		manager->CreateVirtualType(GlobalStringKey::Get(description::TypeInfo<TYPENAME>::content.typeName),\
		new GuiTemplateControlInstanceLoader<TYPENAME, TEMPLATE##_StyleProvider, TEMPLATE>(\
				L"presentation::controls::Gui" L ## #VIRTUALTYPENAME,\
				L ## #STYLE_METHOD\
				)\
			)

	#define ADD_VIRTUAL_CONTROL_2(VIRTUALTYPENAME, TYPENAME, STYLE_METHOD, ARGUMENT_METHOD, TEMPLATE)\
		manager->CreateVirtualType(GlobalStringKey::Get(description::TypeInfo<TYPENAME>::content.typeName),\
		new GuiTemplateControlInstanceLoader<TYPENAME, TEMPLATE##_StyleProvider, TEMPLATE>(\
				L"presentation::controls::Gui" L ## #VIRTUALTYPENAME,\
				L ## #STYLE_METHOD,\
				L ## #ARGUMENT_METHOD\
				)\
			)

	#define ADD_VIRTUAL_CONTROL_F(VIRTUALTYPENAME, TYPENAME, STYLE_METHOD, TEMPLATE, INIT_FUNCTION)\
		manager->CreateVirtualType(GlobalStringKey::Get(description::TypeInfo<TYPENAME>::content.typeName),\
		new GuiTemplateControlInstanceLoader<TYPENAME, TEMPLATE##_StyleProvider, TEMPLATE>(\
				L"presentation::controls::Gui" L ## #VIRTUALTYPENAME,\
				L ## #STYLE_METHOD,\
				INIT_FUNCTION\
				)\
			)

					manager->SetLoader(new GuiControlInstanceLoader);

					ADD_TEMPLATE_CONTROL	(							GuiCustomControl,		CreateCustomControlStyle,											GuiControlTemplate											);
					ADD_TEMPLATE_CONTROL	(							GuiLabel,				CreateLabelStyle,													GuiLabelTemplate											);
					ADD_TEMPLATE_CONTROL	(							GuiButton,				CreateButtonStyle,													GuiButtonTemplate											);
					ADD_TEMPLATE_CONTROL	(							GuiScrollContainer,		CreateScrollContainerStyle,											GuiScrollViewTemplate										);
					ADD_TEMPLATE_CONTROL	(							GuiWindow,				CreateWindowStyle,													GuiWindowTemplate											);
					ADD_TEMPLATE_CONTROL_2	(							GuiTextList,			CreateTextListStyle,				CreateTextListItemStyle,		GuiTextListTemplate											);
					ADD_TEMPLATE_CONTROL	(							GuiMultilineTextBox,	CreateMultilineTextBoxStyle,										GuiMultilineTextBoxTemplate									);
					ADD_TEMPLATE_CONTROL	(							GuiSinglelineTextBox,	CreateTextBoxStyle,													GuiSinglelineTextBoxTemplate								);
					ADD_TEMPLATE_CONTROL	(							GuiDatePicker,			CreateDatePickerStyle,												GuiDatePickerTemplate										);
					ADD_TEMPLATE_CONTROL_3	(							GuiDateComboBox,		CreateComboBoxStyle,				CreateStandardDataPicker,		GuiDateComboBoxTemplate										);
					ADD_TEMPLATE_CONTROL	(							GuiStringGrid,			CreateListViewStyle,												GuiListViewTemplate											);

					ADD_VIRTUAL_CONTROL		(GroupBox,					GuiControl,				CreateGroupBoxStyle,												GuiControlTemplate											);
					ADD_VIRTUAL_CONTROL		(MenuSplitter,				GuiControl,				CreateMenuSplitterStyle,											GuiControlTemplate											);
					ADD_VIRTUAL_CONTROL		(MenuBarButton,				GuiToolstripButton,		CreateMenuBarButtonStyle,											GuiToolstripButtonTemplate									);
					ADD_VIRTUAL_CONTROL		(MenuItemButton,			GuiToolstripButton,		CreateMenuItemButtonStyle,											GuiToolstripButtonTemplate									);
					ADD_VIRTUAL_CONTROL		(ToolstripDropdownButton,	GuiToolstripButton,		CreateToolBarDropdownButtonStyle,									GuiToolstripButtonTemplate									);
					ADD_VIRTUAL_CONTROL		(ToolstripSplitButton,		GuiToolstripButton,		CreateToolBarSplitButtonStyle,										GuiToolstripButtonTemplate									);
					ADD_VIRTUAL_CONTROL		(ToolstripSplitter,			GuiControl,				CreateToolBarSplitterStyle,											GuiControlTemplate											);
					ADD_VIRTUAL_CONTROL		(CheckBox,					GuiSelectableButton,	CreateCheckBoxStyle,												GuiSelectableButtonTemplate									);
					ADD_VIRTUAL_CONTROL		(RadioButton,				GuiSelectableButton,	CreateRadioButtonStyle,												GuiSelectableButtonTemplate									);
					ADD_VIRTUAL_CONTROL		(HScroll,					GuiScroll,				CreateHScrollStyle,													GuiScrollTemplate											);
					ADD_VIRTUAL_CONTROL		(VScroll,					GuiScroll,				CreateVScrollStyle,													GuiScrollTemplate											);
					ADD_VIRTUAL_CONTROL		(DocumentTextBox,			GuiDocumentLabel,		CreateDocumentTextBoxStyle,											GuiDocumentLabelTemplate									);
					ADD_VIRTUAL_CONTROL_F	(HTracker,					GuiScroll,				CreateHTrackerStyle,												GuiScrollTemplate,				InitializeTrackerProgressBar);
					ADD_VIRTUAL_CONTROL_F	(VTracker,					GuiScroll,				CreateVTrackerStyle,												GuiScrollTemplate,				InitializeTrackerProgressBar);
					ADD_VIRTUAL_CONTROL_F	(ProgressBar,				GuiScroll,				CreateProgressBarStyle,												GuiScrollTemplate,				InitializeTrackerProgressBar);
					ADD_VIRTUAL_CONTROL_2	(CheckTextList,				GuiTextList,			CreateTextListStyle,				CreateCheckTextListItemStyle,	GuiTextListTemplate											);
					ADD_VIRTUAL_CONTROL_2	(RadioTextList,				GuiTextList,			CreateTextListStyle,				CreateRadioTextListItemStyle,	GuiTextListTemplate											);

					LoadTabControls(manager);
					LoadToolstripControls(manager);
					LoadListControls(manager);
					LoadDocumentControls(manager);
					LoadCompositions(manager);

	#undef ADD_VIRTUAL_TYPE_LOADER
	#undef ADD_TEMPLATE_CONTROL
	#undef ADD_TEMPLATE_CONTROL_2
	#undef ADD_TEMPLATE_CONTROL_3
	#undef ADD_VIRTUAL_CONTROL
	#undef ADD_VIRTUAL_CONTROL_2
	#undef ADD_VIRTUAL_CONTROL_F
	#endif
				}

				void Unload()override
				{
				}
			};
			GUI_REGISTER_PLUGIN(GuiPredefinedInstanceLoadersPlugin)
		}
	}
}

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_TAB.CPP
***********************************************************************/

#ifndef VCZH_DEBUG_NO_REFLECTION

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{

/***********************************************************************
GuiTabInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiTab, GuiTabTemplate_StyleProvider, GuiTabTemplate>
			class GuiTabInstanceLoader : public BASE_TYPE
			{
			public:
				GuiTabInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiTab>::content.typeName, L"CreateTabStyle")
				{
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiTabPage>());
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::Empty)
						{
							auto value = values[0].expression;
							auto type = values[0].type;

							Ptr<WfExpression> expr;
							if (type->CanConvertTo(description::GetTypeDescriptor<GuiTabPage>()))
							{
								auto refControl = MakePtr<WfReferenceExpression>();
								refControl->name.value = variableName.ToString();

								auto refCreatePage = MakePtr<WfMemberExpression>();
								refCreatePage->parent = refControl;
								refCreatePage->name.value = L"CreatePage";

								auto refMinus1 = MakePtr<WfIntegerExpression>();
								refMinus1->value.value = L"-1";

								auto call = MakePtr<WfCallExpression>();
								call->function = refCreatePage;
								call->arguments.Add(value);
								call->arguments.Add(refMinus1);

								expr = call;
							}

							if (expr)
							{
								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = expr;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiTabPageInstanceLoader
***********************************************************************/

			class GuiTabPageInstanceLoader : public Object, public IGuiInstanceLoader
			{
			protected:
				GlobalStringKey					typeName;

			public:
				GuiTabPageInstanceLoader()
				{
					typeName = GlobalStringKey::Get(description::TypeInfo<GuiTabPage>::content.typeName);
				}

				GlobalStringKey GetTypeName()override
				{
					return typeName;
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						auto info = GuiInstancePropertyInfo::Collection();
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiControl>());
						info->acceptableTypes.Add(description::GetTypeDescriptor<GuiGraphicsComposition>());
						return info;
					}
					return IGuiInstanceLoader::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					auto block = MakePtr<WfBlockStatement>();

					FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
					{
						const auto& values = arguments.GetByIndex(index);
						if (prop == GlobalStringKey::Empty)
						{
							auto value = values[0].expression;
							auto type = values[0].type;

							Ptr<WfExpression> expr;
							if (type->CanConvertTo(description::GetTypeDescriptor<GuiControl>()))
							{
								auto refBoundsComposition = MakePtr<WfMemberExpression>();
								refBoundsComposition->parent = value;
								refBoundsComposition->name.value = L"BoundsComposition";

								expr = refBoundsComposition;
							}
							else if (type->CanConvertTo(description::GetTypeDescriptor<GuiGraphicsComposition>()))
							{
								expr = value;
							}

							if (expr)
							{
								auto refControl = MakePtr<WfReferenceExpression>();
								refControl->name.value = variableName.ToString();

								auto refContainerComposition = MakePtr<WfMemberExpression>();
								refContainerComposition->parent = refControl;
								refContainerComposition->name.value = L"ContainerComposition";

								auto refAddChild = MakePtr<WfMemberExpression>();
								refAddChild->parent = refContainerComposition;
								refAddChild->name.value = L"AddChild";

								auto call = MakePtr<WfCallExpression>();
								call->function = refAddChild;
								call->arguments.Add(expr);

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = call;
								block->statements.Add(stat);
							}
						}
					}

					if (block->statements.Count() > 0)
					{
						return block;
					}
					return nullptr;
				}
			};

/***********************************************************************
Initialization
***********************************************************************/

			void LoadTabControls(IGuiInstanceLoaderManager* manager)
			{
				manager->SetLoader(new GuiTabInstanceLoader);
				manager->SetLoader(new GuiTabPageInstanceLoader);
			}
		}
	}
}

#endif

/***********************************************************************
INSTANCELOADERS\GUIINSTANCELOADER_TOOLSTRIP.CPP
***********************************************************************/

#ifndef VCZH_DEBUG_NO_REFLECTION

namespace vl
{
	namespace presentation
	{
		namespace instance_loaders
		{
			Ptr<workflow::WfStatement> AddControlToToolstrip(GlobalStringKey variableName, IGuiInstanceLoader::ArgumentMap& arguments, collections::List<WString>& errors)
			{
				auto block = MakePtr<WfBlockStatement>();

				FOREACH_INDEXER(GlobalStringKey, prop, index, arguments.Keys())
				{
					const auto& values = arguments.GetByIndex(index);
					if (prop == GlobalStringKey::Empty)
					{
						auto value = values[0].expression;
						auto type = values[0].type;

						Ptr<WfExpression> expr;
						if (type->CanConvertTo(description::GetTypeDescriptor<GuiControl>()))
						{
							auto refControl = MakePtr<WfReferenceExpression>();
							refControl->name.value = variableName.ToString();

							auto refToolstripItems = MakePtr<WfMemberExpression>();
							refToolstripItems->parent = refControl;
							refToolstripItems->name.value = L"ToolstripItems";

							auto refAdd = MakePtr<WfMemberExpression>();
							refAdd->parent = refToolstripItems;
							refAdd->name.value = L"Add";

							auto call = MakePtr<WfCallExpression>();
							call->function = refAdd;
							call->arguments.Add(value);

							expr = call;
						}

						if (expr)
						{
							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = expr;
							block->statements.Add(stat);
						}
					}
				}

				if (block->statements.Count() > 0)
				{
					return block;
				}
				return nullptr;
			}

/***********************************************************************
GuiToolstripMenuInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiToolstripMenu, GuiMenuTemplate_StyleProvider, GuiMenuTemplate>
			class GuiToolstripMenuInstanceLoader : public BASE_TYPE
			{
			public:
				static Ptr<WfExpression> ArgumentFunction(ArgumentMap&)
				{
					auto expr = MakePtr<WfLiteralExpression>();
					expr->value = WfLiteralValue::Null;
					return expr;
				}
			public:
				GuiToolstripMenuInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiToolstripMenu>::content.typeName, L"CreateMenuStyle", ArgumentFunction)
				{
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiControl>());
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					if (auto statement = AddControlToToolstrip(variableName, arguments, errors))
					{
						return statement;
					}
					else
					{
						return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
					}
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiToolstripMenuBarInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiToolstripMenuBar, GuiControlTemplate_StyleProvider, GuiControlTemplate>
			class GuiToolstripMenuBarInstanceLoader : public BASE_TYPE
			{
			public:
				GuiToolstripMenuBarInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiToolstripMenuBar>::content.typeName, L"CreateMenuBarStyle")
				{
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiControl>());
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					if (auto statement = AddControlToToolstrip(variableName, arguments, errors))
					{
						return statement;
					}
					else
					{
						return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
					}
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiToolstripToolBarInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiToolstripToolBar, GuiControlTemplate_StyleProvider, GuiControlTemplate>
			class GuiToolstripToolBarInstanceLoader : public BASE_TYPE
			{
			public:
				GuiToolstripToolBarInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiToolstripToolBar>::content.typeName, L"CreateToolBarStyle")
				{
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(GlobalStringKey::Empty);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == GlobalStringKey::Empty)
					{
						return GuiInstancePropertyInfo::CollectionWithParent(description::GetTypeDescriptor<GuiControl>());
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfStatement> AssignParameters(const TypeInfo& typeInfo, GlobalStringKey variableName, ArgumentMap& arguments, collections::List<WString>& errors)override
				{
					if (auto statement = AddControlToToolstrip(variableName, arguments, errors))
					{
						return statement;
					}
					else
					{
						return BASE_TYPE::AssignParameters(typeInfo, variableName, arguments, errors);
					}
				}
			};
#undef BASE_TYPE

/***********************************************************************
GuiToolstripButtonInstanceLoader
***********************************************************************/

#define BASE_TYPE GuiTemplateControlInstanceLoader<GuiToolstripButton, GuiToolstripButtonTemplate_StyleProvider, GuiToolstripButtonTemplate>
			class GuiToolstripButtonInstanceLoader : public BASE_TYPE
			{
			protected:
				GlobalStringKey					_SubMenu;

			public:
				GuiToolstripButtonInstanceLoader()
					:BASE_TYPE(description::TypeInfo<GuiToolstripButton>::content.typeName, L"CreateToolBarButtonStyle")
				{
					_SubMenu = GlobalStringKey::Get(L"SubMenu");
				}

				void GetPropertyNames(const TypeInfo& typeInfo, collections::List<GlobalStringKey>& propertyNames)override
				{
					propertyNames.Add(_SubMenu);
					BASE_TYPE::GetPropertyNames(typeInfo, propertyNames);
				}

				Ptr<GuiInstancePropertyInfo> GetPropertyType(const PropertyInfo& propertyInfo)override
				{
					if (propertyInfo.propertyName == _SubMenu)
					{
						return GuiInstancePropertyInfo::Set(description::GetTypeDescriptor<GuiToolstripMenu>());
					}
					return BASE_TYPE::GetPropertyType(propertyInfo);
				}

				Ptr<workflow::WfExpression> GetParameter(const PropertyInfo& propertyInfo, GlobalStringKey variableName, collections::List<WString>& errors)override
				{
					if (propertyInfo.propertyName == _SubMenu)
					{
						auto refControl = MakePtr<WfReferenceExpression>();
						refControl->name.value = variableName.ToString();

						auto refEnsureToolstripSubMenu = MakePtr<WfMemberExpression>();
						refEnsureToolstripSubMenu->parent = refControl;
						refEnsureToolstripSubMenu->name.value = L"EnsureToolstripSubMenu";

						auto call = MakePtr<WfCallExpression>();
						call->function = refEnsureToolstripSubMenu;

						return call;
					}
					return BASE_TYPE::GetParameter(propertyInfo, variableName, errors);
				}
			};
#undef BASE_TYPE

/***********************************************************************
Initialization
***********************************************************************/

			void LoadToolstripControls(IGuiInstanceLoaderManager* manager)
			{
				manager->SetLoader(new GuiToolstripMenuInstanceLoader);
				manager->SetLoader(new GuiToolstripMenuBarInstanceLoader);
				manager->SetLoader(new GuiToolstripToolBarInstanceLoader);
				manager->SetLoader(new GuiToolstripButtonInstanceLoader);
			}
		}
	}
}

#endif

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;

/***********************************************************************
ExecuteQueryVisitor
***********************************************************************/

		class ExecuteQueryVisitor : public Object, public GuiIqQuery::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			List<Ptr<GuiConstructorRepr>>&		input;
			List<Ptr<GuiConstructorRepr>>&		output;

			ExecuteQueryVisitor(Ptr<GuiInstanceContext> _context, List<Ptr<GuiConstructorRepr>>& _input, List<Ptr<GuiConstructorRepr>>& _output)
				:context(_context), input(_input), output(_output)
			{
			}

			static bool TestCtor(GuiIqPrimaryQuery* node, GlobalStringKey attribute, Ptr<GuiConstructorRepr> ctor)
			{
				if (node->attributeNameOption == GuiIqNameOption::Specified && node->attributeName.value != attribute.ToString())
				{
					return false;
				}
				if (node->typeNameOption == GuiIqNameOption::Specified && node->typeName.value != ctor->typeName.ToString())
				{
					return false;
				}
				if (node->referenceName.value != L"")
				{
					bool instanceName = ctor->instanceName != GlobalStringKey::Empty && node->referenceName.value == ctor->instanceName.ToString();
					bool styleName = ctor->styleName && node->referenceName.value == ctor->styleName.Value();
					return instanceName || styleName;
				}
				return true;
			}

			void Traverse(GuiIqPrimaryQuery* node, Ptr<GuiAttSetterRepr> setter)
			{
				if (setter)
				{
					FOREACH_INDEXER(GlobalStringKey, attribute, index, setter->setters.Keys())
					{
						auto setterValue = setter->setters.Values()[index];
						FOREACH(Ptr<GuiValueRepr>, value, setterValue->values)
						{
							if (auto ctor = value.Cast<GuiConstructorRepr>())
							{
								if (TestCtor(node, attribute, ctor))
								{
									output.Add(ctor);
								}
							}
							if (node->childOption == GuiIqChildOption::Indirect)
							{
								if (auto setter = value.Cast<GuiAttSetterRepr>())
								{
									Traverse(node, setter);
								}
							}
						}
					}
				}
				else
				{
					if (TestCtor(node, GlobalStringKey::Empty, context->instance))
					{
						output.Add(context->instance);
					}
					if (node->childOption == GuiIqChildOption::Indirect)
					{
						Traverse(node, context->instance);
					}
				}
			}

			void Visit(GuiIqPrimaryQuery* node)override
			{
				auto inputExists = &input;
				if (inputExists)
				{
					FOREACH(Ptr<GuiConstructorRepr>, setter, input)
					{
						Traverse(node, setter);
					}
				}
				else
				{
					Traverse(node, 0);
				}
			}

			void Visit(GuiIqCascadeQuery* node)override
			{
				List<Ptr<GuiConstructorRepr>> temp;
				ExecuteQuery(node->parent, context, input, temp);
				ExecuteQuery(node->child, context, temp, output);
			}

			void Visit(GuiIqSetQuery* node)override
			{
				List<Ptr<GuiConstructorRepr>> first, second;
				ExecuteQuery(node->first, context, input, first);
				ExecuteQuery(node->second, context, input, second);

				switch (node->op)
				{
				case GuiIqBinaryOperator::ExclusiveOr:
					CopyFrom(output, From(first).Except(second).Union(From(second).Except(second)));
					break;
				case GuiIqBinaryOperator::Intersect:
					CopyFrom(output, From(first).Intersect(second));
					break;
				case GuiIqBinaryOperator::Union:
					CopyFrom(output, From(first).Union(second));
					break;
				case GuiIqBinaryOperator::Substract:
					CopyFrom(output, From(first).Except(second));
					break;
				}
			}
		};

/***********************************************************************
ExecuteQuery
***********************************************************************/

		void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& input, collections::List<Ptr<GuiConstructorRepr>>& output)
		{
			ExecuteQueryVisitor visitor(context, input, output);
			query->Accept(&visitor);
		}

		void ExecuteQuery(Ptr<GuiIqQuery> query, Ptr<GuiInstanceContext> context, collections::List<Ptr<GuiConstructorRepr>>& output)
		{
			ExecuteQuery(query, context, *(List<Ptr<GuiConstructorRepr>>*)0, output);
		}

/***********************************************************************
ApplyStyle
***********************************************************************/

		void ApplyStyleInternal(Ptr<GuiAttSetterRepr> src, Ptr<GuiAttSetterRepr> dst)
		{
			FOREACH_INDEXER(GlobalStringKey, attribute, srcIndex, src->setters.Keys())
			{
				auto srcValue = src->setters.Values()[srcIndex];
				vint dstIndex = dst->setters.Keys().IndexOf(attribute);
				if (dstIndex == -1)
				{
					dst->setters.Add(attribute, srcValue);
				}
				else
				{
					auto dstValue = dst->setters.Values()[dstIndex];
					if (srcValue->binding == dstValue->binding)
					{
						if (srcValue->binding == GlobalStringKey::_Set)
						{
							ApplyStyleInternal(srcValue->values[0].Cast<GuiAttSetterRepr>(), dstValue->values[0].Cast<GuiAttSetterRepr>());
						}
						else
						{
							CopyFrom(dstValue->values, srcValue->values, true);
						}
					}
				}
			}

			FOREACH_INDEXER(GlobalStringKey, eventName, srcIndex, src->eventHandlers.Keys())
			{
				if (!dst->eventHandlers.Keys().Contains(eventName))
				{
					auto srcValue = src->eventHandlers.Values()[srcIndex];
					dst->eventHandlers.Add(eventName, srcValue);
				}
			}
		}

		void ApplyStyle(Ptr<GuiInstanceStyle> style, Ptr<GuiConstructorRepr> ctor)
		{
			ApplyStyleInternal(style->setter->Clone().Cast<GuiAttSetterRepr>(), ctor);
		}

/***********************************************************************
GuiIqPrint
***********************************************************************/

		class GuiIqPrintVisitor : public Object, public GuiIqQuery::IVisitor
		{
		public:
			stream::StreamWriter&				writer;

			GuiIqPrintVisitor(stream::StreamWriter& _writer)
				:writer(_writer)
			{
			}

			void Visit(GuiIqPrimaryQuery* node)override
			{
				switch (node->childOption)
				{
				case GuiIqChildOption::Direct:
					writer.WriteString(L"/");
					break;
				case GuiIqChildOption::Indirect:
					writer.WriteString(L"//");
					break;
				}

				if (node->attributeNameOption == GuiIqNameOption::Specified)
				{
					writer.WriteChar(L'@');
					writer.WriteString(node->attributeName.value);
					writer.WriteChar(L':');
				}

				if (node->typeNameOption == GuiIqNameOption::Specified)
				{
					writer.WriteString(node->typeName.value);
				}
				else
				{
					writer.WriteChar(L'*');
				}

				if (node->referenceName.value != L"")
				{
					writer.WriteChar(L'.');
					writer.WriteString(node->referenceName.value);
				}
			}

			void Visit(GuiIqCascadeQuery* node)override
			{
				node->parent->Accept(this);
				node->child->Accept(this);
			}

			void Visit(GuiIqSetQuery* node)override
			{
				writer.WriteChar(L'(');
				node->first->Accept(this);
				switch (node->op)
				{
				case GuiIqBinaryOperator::ExclusiveOr:
					writer.WriteString(L" ^ ");
					break;
				case GuiIqBinaryOperator::Intersect:
					writer.WriteString(L" * ");
					break;
				case GuiIqBinaryOperator::Union:
					writer.WriteString(L" + ");
					break;
				case GuiIqBinaryOperator::Substract:
					writer.WriteString(L" - ");
					break;
				}
				node->second->Accept(this);
				writer.WriteChar(L')');
			}
		};

		void GuiIqPrint(Ptr<GuiIqQuery> query, stream::StreamWriter& writer)
		{
			GuiIqPrintVisitor visitor(writer);
			query->Accept(&visitor);
		}
	}
}

/***********************************************************************
INSTANCEQUERY\GUIINSTANCEQUERY_PARSER.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Query"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum NameOption"
L"\r\n" L"{"
L"\r\n" L"\tSpecified,"
L"\r\n" L"\tAny,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum ChildOption"
L"\r\n" L"{"
L"\r\n" L"\tDirect,"
L"\r\n" L"\tIndirect,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class PrimaryQuery : Query"
L"\r\n" L"{"
L"\r\n" L"\tChildOption\t\tchildOption;"
L"\r\n" L"\tNameOption\t\tattributeNameOption;"
L"\r\n" L"\ttoken\t\t\tattributeName;"
L"\r\n" L"\tNameOption\t\ttypeNameOption;"
L"\r\n" L"\ttoken\t\t\ttypeName;"
L"\r\n" L"\ttoken\t\t\treferenceName;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CascadeQuery : Query"
L"\r\n" L"{"
L"\r\n" L"\tQuery\t\t\tparent;"
L"\r\n" L"\tQuery\t\t\tchild;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"enum BinaryOperator"
L"\r\n" L"{"
L"\r\n" L"\tExclusiveOr,"
L"\r\n" L"\tIntersect,"
L"\r\n" L"\tUnion,"
L"\r\n" L"\tSubstract,"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class SetQuery : Query"
L"\r\n" L"{"
L"\r\n" L"\tQuery\t\t\tfirst;"
L"\r\n" L"\tQuery\t\t\tsecond;"
L"\r\n" L"\tBinaryOperator\top;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token INDIRECT = \"////\";"
L"\r\n" L"token DIRECT = \"//\";"
L"\r\n" L"token NAME = \"[a-zA-Z_][a-zA-Z0-9]*\";"
L"\r\n" L"token WILDCARD = \"/*\";"
L"\r\n" L"token OPEN = \"/(\";"
L"\r\n" L"token CLOSE = \"/)\";"
L"\r\n" L"token XOR = \"/^\";"
L"\r\n" L"token INTERSECT = \"/*\";"
L"\r\n" L"token UNION = \"/+\";"
L"\r\n" L"token SUBSTRACT = \"-\";"
L"\r\n" L"token ATTRIBUTE = \"@\";"
L"\r\n" L"token COLON = \":\";"
L"\r\n" L"token DOT = \".\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule PrimaryQuery QPrimaryFragment"
L"\r\n" L"\t=\t("
L"\r\n" L"\t\t\t(NAME : typeName with {typeNameOption=\"Specified\"})"
L"\r\n" L"\t\t\t| (\"*\" with {typeNameOption=\"Any\"})"
L"\r\n" L"\t\t)"
L"\r\n" L"\t\t[\".\" NAME : referenceName] as PrimaryQuery"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule PrimaryQuery QPrimaryAttributed"
L"\r\n" L"\t= !QPrimaryFragment with {attributeNameOption=\"Any\"}"
L"\r\n" L"\t= \"@\" [NAME : attributeName] \":\" !QPrimaryFragment with {attributeNameOption=\"Specified\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule PrimaryQuery QPrimary"
L"\r\n" L"\t= (\"/\" with {childOption=\"Direct\"}) !QPrimaryAttributed"
L"\r\n" L"\t= (\"//\" with {childOption=\"Indirect\"}) !QPrimaryAttributed"
L"\r\n" L"\t= \"(\" !QueryRoot \")\""
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Query Query0"
L"\r\n" L"\t= !QPrimary"
L"\r\n" L"\t= Query0 : parent QPrimary : child as CascadeQuery;"
L"\r\n" L""
L"\r\n" L"rule Query Query1"
L"\r\n" L"\t= !Query0"
L"\r\n" L"\t= Query1 : first \"^\" Query0 : second as SetQuery with {op=\"ExclusiveOr\"}"
L"\r\n" L"\t= Query1 : first \"*\" Query0 : second as SetQuery with {op=\"Intersect\"}"
L"\r\n" L"\t;"
L"\r\n" L"\t"
L"\r\n" L"rule Query Query2"
L"\r\n" L"\t= !Query1"
L"\r\n" L"\t= Query2 : first \"+\" Query1 : second as SetQuery with {op=\"Union\"}"
L"\r\n" L"\t= Query2 : first \"-\" Query1 : second as SetQuery with {op=\"Substract\"}"
L"\r\n" L"\t;"
L"\r\n" L""
L"\r\n" L"rule Query QueryRoot"
L"\r\n" L"\t= !Query2"
L"\r\n" L"\t;"
;

		vl::WString GuiIqGetParserTextBuffer()
		{
			return parserTextBuffer;
		}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 5804; // 27819 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 684;
const vint parserBufferRows = 6;
const char* parserBuffer[] = {
"\x00\x00\x81\x81\x84\x02\x81\x80\x07\x82\x00\x87\x80\x83\x21\x33\x3B\x31\x30\x64\x65\x11\x35\x35\x32\x39\x3D\x7F\x18\x99\x98\x8A\x85\x84\x8C\x28\x39\x69\x6D\x21\x36\x83\x8D\x8B\x8A\x8D\x19\x85\x08\x80\x0A\x90\x81\x92\x8B\x28\x99\x88\x0B\x93\x98\x83\x29\x32\x74\x2F\xA7\x91\x9B\x03\x94\x8E\x81\x1C\x8C\x8E\x90\x82\x8C\x8A\x8B\x96\x05\xC8\xA3\x28\x39\x34\x34\x33\x98\x1B\xBE\x81\x82\xAF\x81\x8A\x9C\x03\x2B\xD8\x80\x90\x33\x95\x32\x36\x3A\x50\xFF\x7F\x86\x81\x87\x8D\x91\x91\x79\x3A\x8D\x0B\x9B\xB0\x81\x30\x3A\x74\x20\xA2\x35\x34\x3D\x32\x27\x30\x6D\x65\x21\xA3\xB9\x85\xB0\x90\x91\x24\xC6\xB9\x33\x0B\x94\xC2\xB6\xB8\x72\xF4\xB6\xB8\xB5\x37\x24\x38\x3A\x69\x6F\x2E\x3B\xB2\xA8\x82\xB2\xC0\x69\x82\xFD\x88\x8B\xC8\x03\xA5\xA6\x64\x0E\xD0\xD2\xC4\xC8\x86\x8F\xBF\x68\xEA\xAC\xA1\x82\x3D\x32\x33\x8A\x5E\xE3\x0B\xD9\xB5\xD5\x8E\xBF\xB3\x81\xA6\xB5\x85\x8B\xDC\x39\x3C\x38\xB3\xFA\x90\xBC\xB0\x07\xD0\xDD\xCC\x26\x8E\x2B\x8A\xE0\x86\xDC\xE1\xBB\x79\xA2\xD1\xD3\xC0\xAB\xDE\x81\xDD\x37\xB9\x82\xC8\xA2\x80\xA6\x33\x34\x72\x73\x20\xB5\xE4\x99\x81\xEC\x9D\x02\x2B\xA9\xE0\x8F\x30\x39\xB0\xEB\x01\xD8\xF8\x97\xA9\xA9\x83\x39\x32\x63\x12\xCF\xB0\xA1\x0B\x97\x17\x95\xFD\x6B\x42\x83\x4A\x61\x61\x53\x80\x81\x05\xB1\x47\x80\x42\x09\x8A\x8B\x82\x40\x0D\xA8\x40\x7C\x40\xBB\x49\x1E\x10\x11\x49\x12\x15\x13\x10\x54\x04\x48\x42\x87\x00\x2F\x02\x8B\x7F\x08\xB1\x4A\x55\x41\x27\x98\x8A\x84\x87\xEB\x45\x4D\x8A\x88\x01\x25\x88\x48\x88\x02\x60\x8E\x11\x10\x4D\x05\x15\x07\x4A\x3B\x80\x4B\x15\x18\x2D\x3A\x11\x11\x0B\x5A\x1F\x1D\x17\x8F\x41\x83\x9A\x14\x0C\x2D\x39\x0D\x16\x0A\x2D\x90\x84\x78\x42\xBB\x57\x19\x10\x13\x44\x03\x11\x12\x14\x44\x11\x91\x43\x8B\x2A\x03\x02\x8E\x46\x34\x83\x41\x43\x13\x50\x05\x1E\x12\x97\x00\x6F\x88\x09\x99\x00\x61\x5C\x75\x40\x48\x43\x1C\x13\x13\x53\x05\x1C\x98\x00\x2F\xA9\x03\x9D\x9C\x50\x62\x98\x42\xA0\x00\x18\x1F\x12\x14\x7B\xAF\x8E\x17\x89\x52\xB1\x49\x03\x4A\x8F\x80\x46\x84\x15\x45\x12\x19\x9C\x8B\xEA\x41\x4F\x0A\x0A\x07\x23\x99\x4B\x4A\x48\x55\x1E\x11\x12\x4F\x2B\x99\xA4\x40\x2F\x2B\x03\x84\x00\x61\x51\xA5\x42\xAB\x53\x15\x12\x13\x14\x54\x12\x11\x10\x87\x31\x88\x49\xAC\x00\x2D\x2E\xAD\xA0\x4A\xBE\x81\x4E\xA9\x10\x54\x35\xA9\x12\x10\x55\x14\xAB\xAE\x40\xBB\x80\x1A\x02\xA7\x18\x7F\x9C\x4B\x54\x4F\x37\x9E\x13\xB2\x01\x7B\xAA\x0D\x67\xBF\x9A\x44\xA2\x40\x84\x84\x1F\x10\x15\xD8\x80\x4B\xAE\x0B\xC4\x61\x55\xBB\xB4\x08\x48\x53\x14\x14\xB7\x85\x1F\xB5\x40\x84\xAF\x03\x1F\x0A\x6D\x45\x41\x58\x89\x05\x52\x0B\x4A\xBF\x2E\x57\x68\x59\x10\x88\x69\x13\x5D\x5D\x64\x1C\x0B\x4A\xC2\x01\xE8\x66\x44\xC1\x71\x46\xCA\x60\x19\x2E\x12\x1F\x1B\x1B\x74\x13\x14\x1F\x48\x74\x17\x0B\x4A\xC7\x00\x40\x10\x08\x09\x3C\x11\x12\xC3\xC3\x05\xC7\xC5\x18\x19\x3E\x00\xCD\xBD\x40\x26\xCE\xC9\x1C\xC4\x89\x48\xC8\x07\x4A\x37\xCD\xC7\x70\xCD\x12\xC8\xCE\x0A\xC6\x1C\xD6\x0B\x4A\xD0\x21\xE0\x05\xCB\xC9\x33\xE9\xC3\xC5\xCB\xFF\xB0\xC8\xD0\xCF\x2A\xE4\x14\x07\x4A\x53\xFA\xC8\x64\xD4\x13\xEE\x02\x0C\x1D\x2B\x5C\xD0\x43\xD1\x32\xD8\xD8\xC2\x0F\x3A\x20\x02\x08\x10\x67\xE0\x0B\x14\x08\x37\xB9\x80\x09\xD9\x6F\x51\xCA\xC8\x74\x65\x20\x0D\x16\xD9\x3A\x22\x00\x09\x08\x31\xC7\x76\x12\x1C\x61\x27\x19\x5F\x57\x20\x37\x19\x18\x1D\x68\x20\x0B\x1C\x08\x71\xF5\xC1\x72\x74\x92\x60\x0D\x0E\xD9\x53\x00\x73\x19\x1A\xDF\x6B\xCA\xDD\x1F\x10\x2B\x4D\xE6\xD5\x68\x7F\xD1\xE3\xE0\x74\x2E\xC2\x42\xCB\x7D\xD8\x62\xEA\xE0\x5E\x74\x1E\x09\x0C\xA9\x2B\x41\xEF\xD7\xA9\xE1\xE0\xE0\xEB\x5F\x64\xD0\x08\x0A\xBB\xEC\xD8\x8D\x11\x6F\xE0\x0E\x71\x70\x85\xC7\xE9\xE3\xE2\xC3\xF4\xD0\xE6\x1B\x92\xD4\xE6\xE4\xE6\x69\x1A\xE0\x09\x1F\x20\x29\x00\x08\x1F\xBD\xE2\x0A\x0A\xDE\x86\xC8\xEA\xE2\xF0\xBF\x4F\xEF\x63\x74\xCD\xE2\x01\x12\x1B\x79\x1B\xE5\xF5\xF5\x22\xEB\xD2\x0A\x0B\x7A\xED\xD0\xF1\xD9\xAD\x6F\x6D\x6A\x1B\xB2\x74\xD6\xDC\xE3\x73\x20\x08\xD2\x4E\x9F\x65\x21\x00\xB5\x76\x23\xD5\x64\x76\x74\x01\x28\x74\xD2\x06\x8D\x74\xAD\x73\x75\x20\x0F\x80\x6E\xDF\x37\x74\x74\xDD\x7C\x74\x77\xF2\x61\x79\xF2\x0C\x35\x78\xEF\x48\x79\x7C\xCA\x63\x7D\xE4\x13\x72\x05\xCA\x78\x38\x7A\xD2\x74\x7A\xF5\x58\x7C\x76\xED\x5C\x7E\x78\xDF\x7B\x81\x74\x22\x8C\x78\x12\xA7\x79\x7D\xD3\x6B\x7D\x0A\x6D\x76\x6C\xF8\x7E\x76\x6D\xF4\x6E\x34\x6C\x78\x74\x79",
"\xBB\x4D\x26\x7F\x32\x7A\x24\x02\x80\x2A\x81\xB0\x4A\x68\x61\x55\x65\x21\x14\x84\x89\x68\xB9\x59\x6C\x06\x5E\x65\x21\x16\x92\x87\x6B\x27\xAB\x62\x77\x67\x7A\x6F\xDA\x19\x80\x6E\x2F\xBA\x7F\x6E\x22\x19\x6E\xC8\x7C\x6B\x80\x0A\xAD\x75\x83\xC7\x6C\x72\x19\x8C\x3B\x79\xF2\x66\x87\x72\x99\x64\x0F\xE6\x4B\x80\x01\x26\xBB\x66\x8B\x52\x74\x6A\xD3\x4E\x86\x8A\x9F\x73\x01\x8B\x02\x3B\x88\x15\xE2\x6F\x8B\xB2\x61\x8A\x6D\x3F\x93\x7E\x1C\x85\x95\x88\x91\x69\x8A\x6F\x6C\x92\x64\x03\x84\x7D\x7B\x38\x8D\x75\x67\xE2\x63\x35\x0D\xCE\x77\x85\x3C\x9B\x71\x80\x02\x23\x81\x1B\xA3\x7D\x74\x3E\xBE\x8A\x75\x6E\x9F\x2A\x0B\x33\x0F\x80\x81\x11\x84\x8A\x9B\x94\x0E\x05\xBD\x74\x8C\xF0\x4F\x3C\x83\x9D\x91\x84\x08\xF4\x84\x86\x3B\x8F\x7E\x94\x39\x8B\x85\xF6\x5B\x70\x8E\x61\xBF\x93\x86\xA2\x85\x7F\x0D\xEA\x76\x7A\xEB\x6E\x78\x7E\x22\x7D\x95\xFD\x43\x89\x7E\x0E\x86\x8D\x7F\xFF\x62\x32\x2B\x83\x9F\x8E\x4A\x81\x90\x21\x53\x8F\x68\x20\xAF\x73\x19\x95\x2D\x9C\x76\xEA\x86\x9E\xEE\x19\x93\x82\x56\x9F\x2A\x64\xC1\x8B\x73\x27\xF3\x64\x99\x68\xB6\x80\x7D\x9B\x6D\x02\x02\x5C\x83\x60\x40\xA0\x88\x6D\x90\x9D\x97\x3E\x8A\x37\x8C\xBC\x58\x90\x97\xB1\x94\x0C\x3E\xB0\x8A\x9F\x39\x90\x9C\x7C\x24\x97\x8C\x0A\xFA\x83\x7A\x54\x81\x22\x95\x9A\x91\xA1\xCE\x05\x23\xA4\x88\xB6\x9E\x75\x16\x78\x61\x11\x6E\x04\x0D\x1E\x45\x26\xA5\x24\x66\xA4\xEE\x3A\x90\x04\x20\x1E\xA0\x20\x20\xB5\x9F\x4C\xE3\x90\x75\x02\x91\xA6\x05\x35\x15\x95\x40\x37\x9B\x95\x99\xBB\x90\x83\xBF\x7A\x83\x30\xF9\x2D\x99\x0F\x8F\x9D\x31\xC5\x99\xA3\x31\xD1\x7C\xA2\x15\x97\x7B\x99\x2F\x9E\x82\x2F\xA1\x98\xA2\xB3\x53\x99\x99\xEB\x77\x99\xFC\x49\xA1\x88\xFB\x71\x35\x88\xFC\x68\x8B\x71\x3A\x20\x08\x9E\x80\x03\x91\x80\x9A\x03\x4A\x72\xAD\xA7\x2A\x8E\x74\x62\x29\xB4\x0F\x4A\xE4\x00\x65\x82\x3D\xA9\xA6\xF1\x97\xAE\x0F\x35\xAB\x55\xDD\x14\x8F\x59\x08\x28\xB3\x5B\xC8\x63\x96\x5B\x2B\x26\xB1\xF0\x92\x67\x2E\xA2\x0F\x05\xAC\xB1\x8F\x33\x4E\x35\x8C\x09\xC4\x00\x3C\xFC\x34\x0C\x9A\x7B\x70\xAE\x39\xC0\x02\xA0\x82\x96\x20\x8C\x28\x0F\xA2\x60\x79\xA6\x6D\x14\x27\x6D\xB4\x54\x93\xB2\x88\x16\xBF\x7A\xCC\xA1\x31\xAA\x66\x69\x08\x4B\x9D\xB3\x0D\xCF\xA0\xAC\x9E\x5D\x83\xB5\x61\xE4\x98\x33\x9B\x80\x01\xA7\x98\x35\x63\xC5\x7A\xAC\xA5\x7C\x42\x21\x5F\x80\xB2\xB1\x4D\x8C\x51\x21\x13\x7A\x20\x06\xC3\xAE\x26\x60\x30\x0F\x75\x28\x2B\x26\xBB\xB4\x7B\xBB\x3C\xD4\x84\xB5\x81\x97\xBA\x77\xD7\xA1\x78\x57\x77\x74\x0E\x10\x14\x89\x78\xB6\xA9\xAC\x55\x44\x2C\xAC\xEA\x80\x26\xBA\xDB\xB9\xBB\x5B\xDB\xB3\x97\x1D\x2B\x26\xBF\xE1\xA6\x24\x0C\x68\xBB\xBA\xF5\x9D\x2C\x70\xEF\xA5\x6D\x7C\xC7\x83\xBE\xAB\x02\x30\x08\xF6\xA0\x00\x7E\x82\xCA\xBF\xEB\x9A\x68\xC0\x05\x38\xC1\xC9\x62\xB5\x6D\xF4\xA5\x6B\xBD\xAD\x62\x65\x82\xA0\x0B\xC1\xFE\x4D\xC5\x28\x26\x31\xC3\x84\x96\x20\x06\xE6\x05\x26\xC5\x16\xD9\xAF\x5E\xDC\x51\x21\xCE\x31\xA2\xBC\xD3\xB5\x3E\x76\xA6\x21\x07\x0A\xC2\x31\x06\x2E\x14\x06\x2F\x2B\x23\xC9\x00\xD6\x21\x06\x04\xDC\xC5\xF0\x5F\x31\x3D\xF6\xAE\x86\xBD\x05\xC5\x6F\x7D\x79\x3C\xA5\xB4\xA7\x3A\x30\x4D\xA0\x05\x7B\x65\x7A\xB7\xBA\x21\x3E\xB3\x9B\x65\xBF\x86\xBC\xC9\xC9\x23\xCB\xC8\x3C\xE2\x26\x6E\x17\x7A\x6E\xC2\x10\x13\xCA\x3F\x56\xD3\x3C\x96\xF9\x9A\xCA\x38\x25\x7D\x08\x78\x03\x0C\x1B\x75\x03\x0F\x34\x36\x0D\x31\x72\x01\xCC\x6C\xBF\xC3\xBD\xED\x90\xC2\xC7\xFB\xBC\xC6\x8F\xBC\xC3\x96\x55\x2B\x26\xD1\x46\xD9\x0C\x92\x9D\xCF\xC7\x33\xCD\xCE\x6C\xCC\x8D\xCF\x9B\xD5\xC7\x89\x2B\xE6\x23\xA2\x5A\xBB\xC8\x09\xDD\xC5\x23\x29\xFE\xB5\x0F\x83\xC4\xCC\xA5\xCA\xC5\x6C\x26\xE9\xCA\x04\x6B\xD0\xCA\x80\xC1\x7B\xD2\x32\x31\xCA\x3B\x9F\xD9\xCA\xA8\xE6\x68\xCE\x3D\xFC\xCE\xCF\x80\xDB\x71\x85\xC8\x6A\xB0\x81\x0A\xB4\x8A\xAF\x75\x13\x4A\x4A\xD1\xB3\xE3\x32\xB1\x6D\x74\xD6\xB6\x66\xE6\x6C\xB3\xD6\x3D\xB0\xB4\xC0\xA5\xA2\x39\xB0\xB8\x68\xD9\x95\xB0\xD4\x97\xAC\x29\x66\xB8\xB2\x04\xDD\xA4\x0C\xB7\xA7\xCB\x7D\xB6\xA8\x66\x9D\x61\xF2\x65\xD8\x01\x27\xD8\x63\xB2\x0F\x03\x95\x35\xDD\xD9\x98\x28\xB5\xDA\x7C\x6B\xB5\xE5\xAD\xB2\x04\x2A\xD0\x66\x60\x32\x0B\xD0\x8B\x32\x01\xC8\xB8\x0B\x25\xC2\x91\xD2\x07\x32\xF9\x0A\x06\x96\xCF\xD5\x0B\x6C\xC5\xD2\x29\xF8\x38\xCE\x9D\xD2\xCE\x49\x3A\xD6\xCF\x8C\xB5\x0A\x0C\xE2\x20\x73\xB5\xD3\x72\xCC\x9D\x0D\xE3\xD5\x06\xF1\xE2\x93\xAB\x04\xE2\x56",
"\xEE\xCF\xE2\x9C\xDD\x7E\xA7\x96\x2C\xE3\xF2\x55\x0E\x0D\xD3\x22\xD2\x79\x83\xE5\xD0\x1E\xC7\xD0\x21\x2B\xCF\xE1\xC1\x8F\xE3\x96\x52\x2B\x26\xE8\x0C\xEE\xE0\xC4\xAD\xD8\xCD\x95\xED\xE6\xCC\x16\xF4\xCA\xAD\x99\xE8\xD6\x8B\x20\xDF\x7B\xBB\xC2\x07\xCD\xB9\xE3\x7B\x54\xC6\xE2\xE9\x2A\xE6\x6F\xC4\xB2\xD0\xEB\x97\xD2\xEF\xD6\x6C\xB5\xE6\xC7\xA0\xE1\x2F\x30\x23\xE5\x0F\x01\xFB\xC7\x91\xC3\xE0\xC9\x18\x10\xD5\x20\x77\xE3\xCF\x91\x8E\xE1\x06\x95\xD6\x91\xD3\x51\xC6\xEC\xC6\xB2\xEA\xE2\x9A\xF4\xC9\xEB\xA4\xDF\xCB\xDB\xDE\xE2\xD2\xBE\xFE\xEA\xCD\x4F\xF9\x0C\x0C\x34\xD0\xE7\xA9\xC4\xF5\xEA\x79\x0A\xEC\xAF\xF9\xCB\xCF\x3E\xFF\xCF\x09\x81\xD3\x79\xDC\x89\xD7\xC8\x17\xC2\x20\xC6\x3F\xCA\xBA\x4A\xAC\xA4\xC6\x80\x36\xC2\xEF\x8D\xF9\xC4\xD0\x82\xE6\x24\x82\xE5\x3A\xEE\x44\xF1\x04\xD2\x85\x2B\xF6\xD8\xE7\xE4\xEC\x0F\xEF\xF2\x08\x2C\xE0\xF9\xBE\xD1\xEB\xF0\x20\x13\xE5\xE6\x87\xFD\xE2\xB3\x5B\xEA\x32\x01\xBB\xE5\xED\xE0\xEC\xE9\x26\xD6\x93\xEC\x3A\x26\xFA\xE0\xB1\xE9\xF9\xC2\xCB\xFC\xA2\x75\xD6\x8F\xC7\xA1\xEE\xED\x53\xE3\xF6\xE4\xA6\xE1\x20\xEA\xB5\xFA\xF4\xE6\xA4\x0D\xF5\x00\x0F\xF6\xC9\x83\xB0\x09\x60\x40\x26\x55\x3A\x39\xAC\xFC\x9D\x39\xFF\xE5\xAF\x76\xA5\x02\x1E\x52\xB0\x79\x57\x3D\x76\x70\x3F\x78\x22\xB4\x73\x77\xB7\x74\x7A\x92\x6A\x35\x77\x72\x10\x79\x79\x7D\x8E\x75\x7D\xAF\x6B\x66\x22\x61\x78\xB5\x68\x76\x73\x60\x7E\x59\x7D\x6B\x9D\x70\x6C\xA0\x71\x7D\xB0\x73\x69\xC5\x71\x76\x2E\x47\x81\xB3\x67\x7C\xDC\x7A\x7C\x9A\x75\x6E\x5F\x15\x6A\x60\x62\x7A\x88\x66\x72\x43\x77\x70\x32\x0B\x7B\x02\x1D\x7B\xF3\x78\x72\xC1\x74\x81\x4E\x63\x71\x28\x85\x76\x19\x84\x75\x3A\x1D\x82\x53\x03\x7E\x6D\x7B\x78\xD2\x7F\x75\x3C\x8B\x74\x20\x0E\x6A\x4E\x71\x84\x92\x64\x79\x67\x74\x84\x1B\x81\x6A\xCD\x7A\x75\x38\x70\x7D\xD3\x3E\x6E\xC7\x10\x6F\x00\x12\x6F\x32\x31\x64\xF7\x65\x10\x65\x86\x5A\x79\x0A\x6F\xA1\x5D\x6F\x18\x36\x49\xAE\x56\x7F\x00\x08\x7F\x6C\x84\x07\x01\x25\x10\x75\x8D\x7F\x18\x3D\x7E\x7B\x59\x7E\x00\x1E\x62\x37\x66\x12\x04\x84\x58\x0B\x84\x45\x6E\x58\x6C\x79\x50\x34\x72\x04\x07\xCE\x51\x10\xF9\x22\x32\xD1\x5E\x6C\x5E\x88\x19\x7C\x80\x00\x30\x6C\x58\x88\x84\x07\xC4\x1C\x11\x22\x38\x86\x3E\x07\x7E\x03\x76\x5C\x03\x43\x70\xED\x77\x89\xFB\x71\x10\x8E\x8E\x7B\x9D\x83\x83\x03\x79\x89\x09\x84\x74\x97\x80\x86\x00\x0A\x58\x9B\x83\x7F\x70\x82\x87\x80\x8B\x5C\x86\x15\x10\xB9\x88\x87\x28\x5B\x5C\x97\x83\x89\x2E\x67\x8A\xBC\x8E\x03\xB5\x8D\x8A\x79\x5F\x00\x2B\x18\x8C\xB8\x79\x57\x3F\x3B\x31\x89\x8B\x88\x00\x1D\x88\x46\x33\x8C\xA0\x84\x5C\xB6\x37\x52\x74\x55\x10\xD9\x82\x53\xA4\x33\x8A\xCE\x84\x07\x00\x81\x10\x2E\x52\x8C\x45\x55\x41\xD5\x85\x57\xB9\x44\x34\x05\x1A\x8E\xDC\x8D\x40\x97\x81\x45\x02\x11\x45\xB3\x85\x8E\xAD\x39\x8A\xB3\x78\x7B\x30\x07\x8E\x0C\x8C\x5D\x87\x8F\x8D\xA5\x85\x34\x7F\x8C\x62\xF6\x88\x80\xF8\x8C\x8A\xF8\x8D\x8C\x1C\x30\x8B\xB2\x83\x8D\xE2\x5E\x89\x3C\x6A\x8F\xD9\x7E\x8D\x1C\x3F\x8F\x00\x02\x8C\x84\x6E\x90\x47\x66\x90\x0C\x80\x64\xAF\x8B\x12\x0B\x93\x82\x4C\x38\x10\xAF\x4A\x6D\x77\x50\x8F\x01\x19\x4E\x84\x47\x57\x40\x5F\x4E\x05\x1C\x92\x68\x8C\x48\x2C\x3E\x48\x08\x53\x46\x64\x53\x49\x8E\x3D\x50\x97\x41\x5A\xF4\x8C\x49\xE0\x7B\x50\x75\x11\x42\xFE\x44\x4A\x78\x44\x55\x3A\x7F\x92\x06\x55\x36\xEB\x69\x07\xB9\x49\x65\x3E\x9C\x55\x23\x4E\x55\x00\x54\x72\x10\x9B\x93\xA5\x3D\x34\xE8\x8F\x53\x34\x02\x54\x00\x14\x54\x21\x57\x52\x47\x51\x49\x4A\x5F\x54\x59\x62\x43\x50\x51\x94\x25\x43\x55\x29\x4B\x3E\x2C\x48\x69\xB4\x5E\x54\x4E\x93\x4A\xE6\x31\x95\x56\x56\x4D\x3D\x43\x56\x40\x40\x02\xDB\x47\x3F\xDD\x4C\x54\xDF\x4A\x56\x98\x1C\x56\x9D\x22\x92\x56\x9B\x58\x29\x90\x4A\x64\x0A\x91\xE1\x46\x12\x0F\x2D\x2D\x32\x13\x88\x48\x38\x98\x49\x42\x18\x02\x21\x02\xD0\x2F\x0F\x18\x9F\x70\xD2\x28\x14\x3A\x12\x20\x23\x05\x99\xC5\x8B\x8C\xCB\x59\x99\xAD\x82\x20\x25\x05\x99\x53\x9D\x95\x33\x50\x99\x6B\x52\x99\x2B\x17\x02\x95\x97\x99\x30\x02\x9A\xB8\x72\x20\x29\x0F\x9A\xAA\x8C\x63\xB2\x9C\x80\x02\x2B\x02\x95\x9F\x01\xF3\x2C\x2A\xEB\x2F\x0F\x02\x2B\x2E\x8B\x95\x9C\xC6\x90\x21\xC1\x91\x61\xBF\x97\x9C\x7C\x20\x2A\x2B\x14\x9C\xC6\x95\x88\x81\x56\x98\xD0\x94\x25\x0B\x84\x96\x02\x27\x9A\x3A\x54\x3A\xFF\x01\x9C\x81\x95\x10\x70\x2C\x9C\xEB\x22\x2D\xD5\x9B\x98\xD2\x95\x98\x51\x3C\x20",
"\xC1\x93\x89\x7B\x2C\x9C\xC6\x9D\x9D\x04\x23\x7A\xEE\x96\x2E\xCF\x96\x9C\xD0\x80\x00\xF9\x2D\x94\x74\x32\x20\xE7\x95\x4E\x77\x52\x20\xF0\x9C\x20\xCA\x89\x14\xF3\x95\x9C\x01\xAA\x2F\xEB\x20\x87\xC7\x9D\x9E\xC6\x9A\x9A\x7F\x9C\x9A\x08\x1A\x9D\xB0\x47\x52\xE1\x92\x20\xC0\x81\x10\x64\x9B\x3C\x9F\x90\x00\x1A\x59\x47\x12\xA7\x8D\x33\x5F\x0F\x7B\x22\xA2\x0B\x82\x10\x70\x87\xA0\xCC\x2B\x12\x19\x04\x20\x09\xA5\x19\x08\xAE\xA2\x02\x1E\x01\x2C\xAB\x1A\x08\x12\xA3\xEA\x9B\x12\xDF\x92\x10\x1D\x03\xA3\x89\x5B\x12\x3B\xA7\xA3\x1F\x22\x48\x40\xA4\xA0\xE8\x4C\xA3\xBC\x1C\x23\xF5\x9D\x2E\xCE\x95\xA0\x7D\x16\x1A\xB7\x1F\xA0\x8A\x9E\x39\x52\xA7\x95\x14\xA6\x9C\x17\xAD\x1C\x4B\x55\x96\xD3\x1B\xA1\x1D\xA4\x55\x1F\xAE\x53\x27\x51\x61\xD2\x27\x9C\x5F\xAA\x94\x11\x5B\x9C\x4C\xA9\x40\x83\x92\x5A\x77\x55\xA1\x85\x1F\xA6\x87\x14\x49\x40\x9B\xA5\x90\x26\x1E\x68\x94\x06\xFD\x91\x5C\x77\x54\xA2\xD6\x98\x10\x27\xAB\x2E\xEB\x20\x02\x46\xA6\xA2\x30\xA1\x10\x28\xAC\x88\x2B\x16\xA3\x2F\xAD\xA3\x08\x1F\xA3\x8B\xA6\x1B\x35\xA3\xA8\x01\x19\xA3\x01\x1E\xA8\xC8\x9B\x12\xE1\x96\x92\x71\x23\x9E\x42\xAF\xA8\xD7\x18\xA4\xBA\x29\xA4\x44\xAC\xA4\x0E\xA9\x1A\x10\xA2\x40\x53\xA4\x98\xDB\x9D\x3A\x6E\xA8\x10\x57\xA0\x00\x19\xA4\x43\x5C\xA7\xA7\x65\xA9\x4B\x11\x65\x9E\x0F\x25\xAB\x67\xA9\xA6\x03\x29\xA7\x24\x96\x98\xAD\xAA\x8B\x70\xA0\x00\xFA\x9D\x4F\xD3\x1B\x9C\x84\x27\x43\xBE\xAC\x6E\xFF\x9F\x20\x87\xA1\x27\xC6\x54\xA9\xF4\x93\xA4\x02\x11\x61\xB0\x83\x9C\x98\xA6\xA5\xCB\x18\xA1\x59\xAA\xA1\x75\xA6\x13\xB4\xA9\xAA\xED\x8F\x15\xC0\x92\xA9\xF7\x7C\xAB\x0C\xA5\x9C\xA5\xA9\x1B\x16\x19\x9D\xE2\xA4\x95\xC1\xA7\x7A\xDB\xA8\xA5\x4F\x5B\x3C\xC8\xA1\x10\x37\x4A\xAB\x27\x5C\xA7\xFA\x2B\x27\xAB\x2F\xA7\x4B\xA2\x45\xE6\xA0\x00\xAB\x21\x8E\x9B\xA4\xA3\x05\x1A\xA8\x97\xAE\xA7\x85\xA7\xB0\x08\x12\xAD\x00\x06\xA9\x86\xAB\x2E\xB0\x82\xB1\x0E\xB5\x10\x81\xA3\xB0\xC4\x1A\xB0\x13\xB9\xAD\x45\xA1\xAA\x4A\xA1\xB2\xA4\xAE\xA2\x89\x9D\xAE\xA9\xA9\x4A\xD6\x80\xA6\x33\x51\xAF\xEA\x73\xAF\xB0\xAD\xAD\x34\x47\xAF\x00\x19\xAF\xEF\xA8\x9A\xA4\x32\xA6\xBC\xAA\xAF\x33\x58\xA6\xBC\xAB\xAC\x76\x50\xAC\xC6\x99\x8B\x02\x19\x8B\xC5\xA7\x51\x92\x13\xAB\xA5\x44\x55\x3E\xB0\x93\xFC\xAF\xA9\x0C\xB4\xAD\x66\x2F\xB1\x9E\xA4\x27\x9D\xAB\xB0\x47\xA8\x10\x06\xB5\xAE\x20\xB5\x10\x1B\x03\xB0\x70\x89\x2E\xEB\x2B\xB1\x03\xB7\x9F\x1C\xB7\xB1\x02\x10\xB1\x16\xBA\xB5\x05\x15\xB1\xA2\xA9\xA2\x22\xB5\xA0\xEB\xA8\x1C\x26\xB1\xA1\x35\xBB\xAA\x5F\x1C\xB2\x7D\x8E\xB2\xB1\xA2\x4A\x32\xB0\x00\x34\xB4\xB7\x54\xA3\x53\xB7\xA9\xB3\x75\xB3\xA1\x3B\xBC\xAB\xFC\x9B\xA6\xD3\x91\x35\x78\xB0\x00\x42\xB1\x10\x44\xB6\x51\x5A\xA2\x19\x7D\xBA\xAC\x8A\xB8\x9E\x13\x3B\x98\xCF\xAC\x2A\xD1\xAD\xB6\x1D\xB7\x8F\x6B\xB6\x9C\xEB\x2D\xB8\xAF\xAB\xB7\xC7\xAB\x12\xC9\xA8\x3E\x3A\xB4\x3A\x50\xB1\x27\xCA\x98\xAE\x01\xBD\x1D\x3D\xB7\xB9\xFE\x94\x9D\xC6\x9A\x5F\xD8\x97\xB2\x1F\x59\xB2\x66\xAB\xAF\xDE\x9E\xB1\x4C\xAC\xA9\x6F\xB3\x9F\x4B\xB0\x48\x88\xBB\xB9\xFF\x03\xA0\xB2\xB8\xB8\x9A\xB9\x9C\x1E\x9C\xAB\x80\xA6\x9F\x08\xB9\x97\x67\x5B\x9F\xBA\xB8\x53\xBC\xB9\x4B\x0B\x28\xBC\xEB\x20\x7F\xC7\xB1\x9C\x7B\x24\x1C\xD8\xA2\xB5\x02\x1B\x27\x11\x6A\xA9\xCC\x95\xBC\xE6\x4C\xB3\x69\xA1\x89\x68\x1C\xBC\x03\xBB\xB9\x0A\xA2\xBA\xBC\xA1\xB7\x9B\x97\xBD\xC7\x59\xBD\x11\x5D\xB4\x86\xAE\xAF\xF4\xB3\xBC\x00\x1D\xB8\x02\x26\xBF\xA7\xA8\xB2\x80\xBA\xAA\x86\xB7\xB3\xB1\xB3\x9F\xAB\xBD\x3A\xEC\xBC\xA4\xEA\xBD\xA6\x41\xB3\xAC\x45\xB3\xB9\x6E\x08\xB4\x43\x9B\x32\x11\xC6\x98\xFC\xB4\x21\xFF\xB8\xB1\xC0\xB0\xB7\x24\xB1\x99\x51\xA7\xC0\x06\xC8\xC0\x20\xAA\xC0\x5B\xB5\xA0\x0D\xCF\x15\x0F\xC5\xA0\x1B\xCC\xB8\x13\xC8\x10\x91\xB2\xA7\xC6\xA4\xB9\xA8\xB8\xAF\xE8\x31\xC3\x99\xB0\xBF\x53\xB6\xB6\x88\xAE\xC3\xFD\xB4\x20\x7B\x23\x89\xE3\xB5\x10\x2A\x07\x2A\x04\x98\xC4\xBC\xAE\xBE\x16\x1F\xC2\xF3\x90\x9B\x1D\xC0\x00\xCA\xBB\x20\xEB\x26\x5C\xE6\xB8\xBF\xC7\x9E\xC4\x79\x08\xAB\x54\xB2\xB2\xB6\x52\x20\xB0\x92\xC4\x56\xB5\xC6\x01\x15\x87\x42\xC3\xC5\x53\xCC\x47\x11\x6B\xB9\xEB\x2B\xA2\xAD\xB1\x87\x0D\xBA\xB6\x40\x19\xA8\x63\xB6\xC7\x71\xC8\xB6\x03\xBC\xB6\x2B\xC1\x10\x2C\x0A\xC4\xD5\xAB\x12\x7F\xC9\xA6\xB0\x90\xC5\xEE\x97\x99\x31\x03\xC5\x8F\xB7\x5F\x03\xBB\x2E\x5D\xB1\xC7\x5F\xB7\xC7\x91\xA1\xC7\x62",
"\xB9\xC7\x3E\xAB\xC7\x97\xCD\xC7\x00\x19\xB6\x59\xCD\xA8\xBC\xA0\x9B\x5E\xCC\xC8\xA0\xB5\x6B\x62\xC7\x9B\x47\x68\xBC\xCB\x96\x5C\xCB\x9B\xB9\x99\xA3\xB0\x05\xB3\xB0\xD2\x28\xBE\x02\x2B\x27\x10\xB9\xC4\x84\xC6\xCA\x92\x71\xCA\x12\x68\x68\x20\x64\xAE\x88\x61\xC8\xF8\x86\xA0\xC1\x9B\x2E\x68\xC3\x9F\xBA\xC3\xC0\x2E\xA7\x62\xF7\xB0\xBA\xC0\xCB\x8F\x6A\xCB\x27\x6C\xCD\xC8\x2B\x1F\xC8\x3F\xC2\xC7\x4E\xA1\xC7\x64\xBA\xB1\x78\xC5\xCD\x7A\xC1\xC7\x7C\xC0\xC2\x08\x13\xC8\x05\x16\xC8\x03\x2A\x91\xCA\xC5\xC0\xD5\x58\xCB\x30\x01\x61\xE2\xC5\xA0\x85\xC4\xC6\xA2\xCB\xC4\xD9\x7A\xC8\xBF\xCF\xB9\xE0\xC5\x10\x82\xA4\xC9\xDB\xC6\xC6\xD1\x8B\xCF\xF6\xC4\xA8\xD7\xCC\xCD\x99\xC5\xCD\xDF\xCE\xB6\x05\x19\xB6\xE4\xC8\xCC\x01\xD7\xCE\x25\xCB\xC4\xCD\xC7\x5D\x11\x69\xB6\xC7\x90\xCA\xC6\x93\x7A\xA4\xC5\xCF\xF1\xC3\xCF\xC1\x99\xCA\x39\xC1\xC7\xAD\xC1\xC7\xB1\xCE\xCA\xA0\xAB\x98\x09\xD3\xC7\x41\x1D\x10\x55\x18\x62\x73\xBE\xD0\xE9\xC8\x8F\xB5\xCF\xC9\xEA\xCA\xCB\xA3\x7D\xCB\x88\x4D\xCC\x0F\xDB\x5D\xCC\x98\xBC\x1F\xDC\xA4\x7B\x22\x2D\xC6\x53\xD1\xEA\xCD\xB8\x14\x92\x6D\x34\x4A\x5F\xE6\x68\x6E\x5C\xC8\xBC\x21\xD9\xA6\x3D\xDA\xC5\x15\xD1\xD4\xC6\x93\xD4\xE2\x67\x5B\xA2\x43\x7A\xD5\x6E\x59\x5C\xC0\xC4\x71\x2F\xCA\x69\xA2\xBC\xA8\xA7\xCB\xA0\xB7\x5D\xF0\xBC\xBD\x2A\xA0\xCF\xAC\x23\xA2\x7B\x2A\x8E\x35\x22\xCD\x08\x19\xCF\xD5\xC1\xC9\xFA\xC3\xC9\xD5\xC9\xCD\x9A\xC0\x00\x24\x00\xC8\x2D\xD5\x10\x77\xD0\xD6\xF2\xCF\x63\x25\xD5\x9C\x97\x92\x03\x53\xCD\x57\x6B\xD1\xC7\x8E\xCE\xB5\x73\xCB\xB9\x95\xC3\xD7\xFE\xC3\xAD\x09\xB8\xD7\xF1\xC1\xA3\x30\xD1\xD6\x3F\x62\xD3\x88\x67\xD1\xCC\xC9\xD7\x26\x78\xCA\x38\x30\xD9\x74\xC1\x6F\x03\xDC\xCF\x00\x0D\xCD\x8B\x94\xCB\x82\xC3\xD9\x7D\xDC\x63\xBA\xC9\x9B\x50\x85\xCA\x94\xDC\x63\xC2\xC3\xB0\x70\xC4\xC6\xCF\xC3\x34\x21\xCF\xCF\xD9\x2B\x12\x6E\xD2\xDA\x70\xD5\xCD\x8B\xD2\xDA\x74\xD7\xCF\x02\x1B\xD7\x2E\x28\xD1\x76\xD8\xDA\x37\xDC\x63\x7F\xDB\x98\x81\xD3\xD8\xB7\xDA\xD5\x00\x07\xD8\x90\xC9\xD8\x61\xBD\xD8\x9F\xDD\xCF\x72\xD6\xD0\x92\xD8\x10\x9D\xCF\xD8\x7C\xD9\xDC\x47\x66\xD9\xA3\xC5\x79\xAE\xD9\xDA\x06\x7C\xD9\x08\x13\x52\xE5\xB3\xB0\xA4\xD2\xDA\x05\xDB\x20\xA6\xD1\xCE\xC8\xDA\xD9\x95\xD6\x9C\xAC\xDD\x74\xE5\xD0\xDE\x92\x63\x9F\xC8\xBF\xBA\x69\xAB\x9C\x4B\xDC\xA4\x5C\xC4\x9E\xB3\xB2\x98\x75\x50\x93\xBA\xC8\xBB\x59\xAE\xAE\x07\xC3\xAE\x60\x1F\xBB\x41\xAC\xD4\x0B\xC0\x10\xB2\xC7\xBB\x8E\x92\x33\x04\xE9\xA6\x3C\xC8\x30\x71\xCF\x0F\xEC\x90\xBD\x13\xE0\x00\x15\xE5\x9C\x59\xD5\xCD\xFF\x0B\xD3\xEE\xC1\xE2\x59\xBB\xC5\x17\xE7\x1C\xD2\x26\x02\xBC\xAB\xA1\xBC\x82\x2D\xC4\xD9\xE2\xAF\xD6\x70\xD2\x2D\xCE\x51\xC8\xCB\x31\x02\x2D\xB6\xCC\xA4\xB0\x92\xD4\x2B\x1D\x19\x44\xD2\x4A\x46\xDB\x5B\xD6\x64\x07\x49\xD1\x9C\x01\xE6\xE3\xA3\xA1\x80\x4D\xCD\xE2\x98\x1F\xE2\x31\xEF\xAD\x0C\x89\x57\x34\xE3\xDF\x19\xD3\x70\x39\xEA\xE5\xBB\xC8\x7B\x3D\xEB\x12\x3F\xEE\xE4\xFA\xD0\x03\x42\xEC\x19\x01\x15\xE4\xD3\x16\xD5\x48\xD2\xE5\xEF\xB7\xDD\xAC\x2C\xD5\x4C\xA9\x9B\x50\xED\xBE\x6E\xE7\x14\x2B\x10\xE3\x69\xA2\xE3\x73\x89\xE5\xDF\xD4\xDF\xB5\x7D\xE5\x7F\xEB\xE5\xB8\x92\xE6\x5E\xE1\x74\x30\x03\x20\x64\xD8\x10\xD4\xC9\xC6\xE0\xBB\x30\x9E\xDE\xC6\xBA\xD8\xD8\x01\xDA\xDD\x01\x1A\xE7\xC5\xD9\xD9\x00\x18\xE9\x64\xE0\xE8\x06\x7B\xDC\x0F\x2C\xE7\xB7\x88\x31\xE8\xDA\x8D\x91\xE5\xDD\xD9\xD8\xDB\xD8\xDE\xDD\xA5\xD8\xA3\x2B\x15\xE3\x3B\xE7\xE3\x0F\x7B\xDA\x01\xBD\xDA\xC6\xD1\x74\x32\x01\xDB\x71\xCD\xE8\x3E\xC8\xBC\x7B\x2C\x30\x99\xE5\xCD\x19\xB3\xDD\x95\xE9\xDB\x08\x1C\xE9\x5F\x26\xDC\xC8\xE7\xC8\xB8\xC2\x03\xA0\xEB\x20\xA2\xE6\x11\x79\x55\xEA\x02\x19\x8D\xEB\xD1\xD7\xAC\xE0\xDC\xD6\xD3\xCB\xAE\xE8\x10\xB0\xEC\xEC\xB2\xE2\x03\xB4\xE2\xB2\xB6\xEA\xE9\x5F\xEC\x80\xB9\xEC\xDF\x10\xE7\xD0\xB0\xB6\xE7\x7D\xAC\xA1\xDE\x79\xDF\x9E\xE2\x69\x8D\xB9\x28\x01\x1D\x1E\x1B\xA9\x78\xA6\x68\xC8\xD0\xDF\x0F\xEF\xDE\x9E\xE9\xAB\x98\xFA\x5A\x7C\xF2\xE4\xE8\x47\x65\xEF\x4A\xCD\x1E\x14\x9E\x81\xBF\x6F\x79\x72\x0C\xEF\x66\xDA\xEA\xAC\x2F\xDB\xF3\x91\xF0\x0F\x23\xF0\xF1\xE7\xEB\xAD\x82\x03\x08\xFC\xDD\xF7\xE0\x07\xB9\x9F\x7C\x6E\x0D\xDC\xC1\x91\xDC\x05\xA6\xF1\x0B\x28\xF1\x98\x75\xF0\xE7\xE6\x72\x1D\xF1\xEC\xF8\xE6\xE5\x47\x8C\x76\x22\x74\x07\x81\xDC\xA4\x8B\xE8\xCF\x66\xDE\xEB\xF6\x6F\xC1\x75\xE1",
"\xEC\x36\xD2\x8E\x55\xEF\xB4\x57\xEB\x5C\xCF\xE7\x20\x25\xE7\x9C\x3A\xD5\xB5\xF3\x90\xE0\xA1\xD1\xEB\xE6\xD2\x69\x3E\xE7\xE8\xAD\x86\xE6\x51\xD3\xE4\x69\xE3\xD5\xCB\x37\xE4\xE7\x69\xE4\x4B\xE4\x20\x4D\xED\xF4\x21\xE2\xD1\x4F\xD2\xEB\x61\xE8\x10\x63\xE0\xF5\x65\xE7\xE6\x05\x14\xE4\x5A\xF4\x43\x6C\xEE\xF5\x77\xE9\x07\xFD\xE2\xE7\x27\xF3\xF6\x54\xF0\xE6\x53\xF3\xE8\x2D\xF8\xD3\xDB\xB1\x9C\x28\xE3\x9F\xE1\x92\x2D\x65\xBC\x9C\x81\xD2\xE8\x40\xEC\xE3\x7B\xF9\xF8\xB2\xE6\xF5\xC5\x92\xD5\xA0\x1B\xF5\x0B\x87\xD4\x72\xFF\xEE\x54\x4A\xD4\x4C\xFE\x9E\x83\xFB\xED\x65\xF1\xF5\x32\x08\xF8\x9D\xE6\xF0\x52\xF6\xE8\x7C\xF8\xE8\x6C\xF2\x10\x6E\xF1\xF9\x70\xF8\x68\x57\xDD\x5B\x25\xE8\xBC\x76\xF2\xF6\x00\xC0\x00\x85\xF0\xD4\xE1\xE0\xFA\x6A\xF3\xEF\x67\xFC\xC4\xA5\xF5\xF5\x39\xD1\x9C\xBD\xD1\xF1\x05\xA8\xBC\x02\x22\x02\xC2\xFE\x9E\x4B\xF4\xBE\xC6\xCF\xDC\x03\x20\xF9\xE3\x66\xE4\x93\xF8\xE4\x58\xD3\xF7\x98\xFA\xFC\xEE\x93\xBA\x57\xF8\xE6\x00\x1A\xE6\x92\x11\xF7\xD3\xF6\xF9\x48\x35\xF7\x23\xD7\xFC\xFD\xE2\x20\xDF\xE4\xFE\x07\x29\xFC\x02\xB9\xA6\x9B\xFE\xED\x79\xF8\xEE\xB8\xF0\xEE\x51\xFB\xFB\x02\x19\xF6\xF2\xFB\xF6\xD9\xFD\xF6\x59\xFA\xFA\xD0\xFF\xEE\x94\xFF\xFD\x57\x58\x85\x70\x08\x26\x79\xF9\x4C\x4D\xFB\x7A\x6B\xEF\x7E\xE4\x31\x7E\xC3\x7A\xF8\x24\x7C\xE3\x71\x7A\x8E\x7B\x31\x4E\x7E\xAA\x6B\xE6\x2C\x7D\x9B\x60\x7F\x32\x1A\xFC\x58\x5A\x5E\x5E\xF4\x6E\x7D\xEF\x78\x3D\x9F\x7F\xB4\x5F\x81\x8D\x4B\xF8\x21\x7D\xDF\x62\x30\x00\x51\x38\x42\x11\x65\x78\xFE\x0A\x74\xE0\x65\x80\xC7\x4C\xCE\x57\x75\xA1\x7F\x2A\x46\x45\x68\x4F\x75\x09\x84\xCB\x62\x81\x07\x8A\xDF\x74\x7D\x40\x16\x7F\x0C\x85\xF1\x67\x7D\x1A\x3B\xFF\x4F\x7F\x74\x1C\x7A\x17\x81\x00\x97\x7C\x02\x86\xFD\x4C\x4E\x0C\x9B\x74\x34\x80\xA0\x45\x7A\x8C\x1E\xE7\x3C\x83\xBC\x61\x81\xF2\x6B\x04\x99\x3F\x12\x89\xFB\x22\x7D\x04\x8F\x10\x13\x83\x79\x1E\x7E\xD7\x73\xF7\x1A\x83\x4B\x3C\x55\x07\x82\x20\x2C\x81\xE3\x41\xED\x79\x00\x96\x78\x81\x5A\x82\x07\x99\x82\x2B\x82\xFA\x3E\x80\x40\x00\x82\xB6\x78\x02\xA9\x80\x02\x12\x20\x28\x01\x0B\x8A\x7A\xCE\x5B\x50\x20\x71\xBA\x62\x20\x0A\x73\x53\x2C\x70\x5F\x6A\x00\xBD\x5D\x10\x5B\xEE\x05\x6F\x1F\x84\x7E\x0E\x87\x0F\xA9\x7F\x17\x8D\x04\x8B\x51\x88\x78\x83\x9D\x78\xFF\x4F\x7C\xAC\x7B\xFD\x6F\x79\xFF\x61\x80\xFF\x7C\x0C\x98\x81\xE3\x05\xFD\x6B\x7C\x4F\x77\x84\x39\x82\xC0\x03\x82\xD7\x35\x04\x94\x81\xF7\x76\x80\x95\x7A\x09\xA1\x7E\x38\x7F\x0F\x31\x7F\xF5\x68\x85\x71\x80\x05\xB1\x5E\x01\x1A\xE3\x12\x85\xFC\x41\x7C\xEE\x4D\x03\x85\x09\x5E\x81\x04\xF3\x7C\x17\x97\x7F\xF3\x77\x0B\x8B\x11\x30\x85\xD4\x51\x7D\xD7\x60\x80\x4E\x5A\x11\xA5\x85\x78\x4C\x01\xA1\x70\x31\x99\x83\x3D\x87\x18\x85\x86\x4D\x82\x01\x9C\x86\x67\x1E\x84\x15\x80\x74\x6D\x7C\x25\x75\x06\xB4\x86\x2D\x8C\x4E\x4D\x6B\x0E\xA6\x81\xA0\x36\x07\x80\x00\x26\x80\x6C\xEA\x66\x17\x80\x08",
};

		void GuiIqGetParserBuffer(vl::stream::MemoryStream& stream)
		{
			vl::stream::MemoryStream compressedStream;
			for (vint i = 0; i < parserBufferRows; i++)
			{
				vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
				compressedStream.Write((void*)parserBuffer[i], size);
			}
			compressedStream.SeekFromBegin(0);
			vl::stream::LzwDecoder decoder;
			vl::stream::DecoderStream decoderStream(compressedStream, decoder);
			vl::collections::Array<vl::vuint8_t> buffer(65536);
			while (true)
			{
				vl::vint size = decoderStream.Read(&buffer[0], 65536);
				if (size == 0) break;
				stream.Write(&buffer[0], size);
			}
			stream.SeekFromBegin(0);
		}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

		class GuiIqTreeConverter : public vl::parsing::ParsingTreeConverter
		{
		public:
			using vl::parsing::ParsingTreeConverter::SetMember;

			bool SetMember(GuiIqNameOption& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Specified") { member=GuiIqNameOption::Specified; return true; }
					else if(token->GetValue()==L"Any") { member=GuiIqNameOption::Any; return true; }
					else { member=GuiIqNameOption::Specified; return false; }
				}
				member=GuiIqNameOption::Specified;
				return false;
			}

			bool SetMember(GuiIqChildOption& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"Direct") { member=GuiIqChildOption::Direct; return true; }
					else if(token->GetValue()==L"Indirect") { member=GuiIqChildOption::Indirect; return true; }
					else { member=GuiIqChildOption::Direct; return false; }
				}
				member=GuiIqChildOption::Direct;
				return false;
			}

			bool SetMember(GuiIqBinaryOperator& member, vl::Ptr<vl::parsing::ParsingTreeNode> node, const TokenList& tokens)
			{
				vl::Ptr<vl::parsing::ParsingTreeToken> token=node.Cast<vl::parsing::ParsingTreeToken>();
				if(token)
				{
					if(token->GetValue()==L"ExclusiveOr") { member=GuiIqBinaryOperator::ExclusiveOr; return true; }
					else if(token->GetValue()==L"Intersect") { member=GuiIqBinaryOperator::Intersect; return true; }
					else if(token->GetValue()==L"Union") { member=GuiIqBinaryOperator::Union; return true; }
					else if(token->GetValue()==L"Substract") { member=GuiIqBinaryOperator::Substract; return true; }
					else { member=GuiIqBinaryOperator::ExclusiveOr; return false; }
				}
				member=GuiIqBinaryOperator::ExclusiveOr;
				return false;
			}

			void Fill(vl::Ptr<GuiIqQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
			}

			void Fill(vl::Ptr<GuiIqPrimaryQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->childOption, obj->GetMember(L"childOption"), tokens);
				SetMember(tree->attributeNameOption, obj->GetMember(L"attributeNameOption"), tokens);
				SetMember(tree->attributeName, obj->GetMember(L"attributeName"), tokens);
				SetMember(tree->typeNameOption, obj->GetMember(L"typeNameOption"), tokens);
				SetMember(tree->typeName, obj->GetMember(L"typeName"), tokens);
				SetMember(tree->referenceName, obj->GetMember(L"referenceName"), tokens);
			}

			void Fill(vl::Ptr<GuiIqCascadeQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->parent, obj->GetMember(L"parent"), tokens);
				SetMember(tree->child, obj->GetMember(L"child"), tokens);
			}

			void Fill(vl::Ptr<GuiIqSetQuery> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
			{
				SetMember(tree->first, obj->GetMember(L"first"), tokens);
				SetMember(tree->second, obj->GetMember(L"second"), tokens);
				SetMember(tree->op, obj->GetMember(L"op"), tokens);
			}

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
			{
				if(obj->GetType()==L"PrimaryQuery")
				{
					vl::Ptr<GuiIqPrimaryQuery> tree = new GuiIqPrimaryQuery;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<GuiIqQuery>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"CascadeQuery")
				{
					vl::Ptr<GuiIqCascadeQuery> tree = new GuiIqCascadeQuery;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<GuiIqQuery>(), obj, tokens);
					return tree;
				}
				else if(obj->GetType()==L"SetQuery")
				{
					vl::Ptr<GuiIqSetQuery> tree = new GuiIqSetQuery;
					vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
					Fill(tree, obj, tokens);
					Fill(tree.Cast<GuiIqQuery>(), obj, tokens);
					return tree;
				}
				else 
					return 0;
			}
		};

		vl::Ptr<vl::parsing::ParsingTreeCustomBase> GuiIqConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			GuiIqTreeConverter converter;
			vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
			converter.SetMember(tree, node, tokens);
			return tree;
		}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

		vl::Ptr<GuiIqPrimaryQuery> GuiIqPrimaryQuery::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return GuiIqConvertParsingTreeNode(node, tokens).Cast<GuiIqPrimaryQuery>();
		}

		vl::Ptr<GuiIqCascadeQuery> GuiIqCascadeQuery::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return GuiIqConvertParsingTreeNode(node, tokens).Cast<GuiIqCascadeQuery>();
		}

		vl::Ptr<GuiIqSetQuery> GuiIqSetQuery::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			return GuiIqConvertParsingTreeNode(node, tokens).Cast<GuiIqSetQuery>();
		}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

		void GuiIqPrimaryQuery::Accept(GuiIqQuery::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void GuiIqCascadeQuery::Accept(GuiIqQuery::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

		void GuiIqSetQuery::Accept(GuiIqQuery::IVisitor* visitor)
		{
			visitor->Visit(this);
		}

/***********************************************************************
Parser Function
***********************************************************************/

		vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"QueryRoot");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			return node;
		}

		vl::Ptr<vl::parsing::ParsingTreeNode> GuiIqParseAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return GuiIqParseAsParsingTreeNode(input, table, errors, codeIndex);
		}

		vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
		{
			vl::parsing::tabling::ParsingState state(input, table, codeIndex);
			state.Reset(L"QueryRoot");
			vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
			vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
			if(node && errors.Count()==0)
			{
				return GuiIqConvertParsingTreeNode(node, state.GetTokens()).Cast<GuiIqQuery>();
			}
			return 0;
		}

		vl::Ptr<GuiIqQuery> GuiIqParse(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
		{
			vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
			return GuiIqParse(input, table, errors, codeIndex);
		}

/***********************************************************************
Table Generation
***********************************************************************/

		vl::Ptr<vl::parsing::tabling::ParsingTable> GuiIqLoadTable()
		{
			vl::stream::MemoryStream stream;
			GuiIqGetParserBuffer(stream);
			vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
			table->Initialize();
			return table;
		}

	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::presentation;

#define PARSING_TOKEN_FIELD(NAME)\
			CLASS_MEMBER_EXTERNALMETHOD_INVOKETEMPLATE(get_##NAME, NO_PARAMETER, vl::WString(ClassType::*)(), [](ClassType* node) { return node->NAME.value; }, L"*")\
			CLASS_MEMBER_EXTERNALMETHOD_INVOKETEMPLATE(set_##NAME, { L"value" }, void(ClassType::*)(const vl::WString&), [](ClassType* node, const vl::WString& value) { node->NAME.value = value; }, L"*")\
			CLASS_MEMBER_PROPERTY_REFERENCETEMPLATE(NAME, get_##NAME, set_##NAME, L"$This->$Name.value")\

			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqQuery, presentation::GuiIqQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqNameOption, presentation::GuiIqNameOption)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqChildOption, presentation::GuiIqChildOption)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqPrimaryQuery, presentation::GuiIqPrimaryQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqCascadeQuery, presentation::GuiIqCascadeQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqBinaryOperator, presentation::GuiIqBinaryOperator)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqSetQuery, presentation::GuiIqSetQuery)
			IMPL_TYPE_INFO_RENAME(vl::presentation::GuiIqQuery::IVisitor, presentation::GuiIqQuery::IVisitor)

			BEGIN_CLASS_MEMBER(GuiIqQuery)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})
			END_CLASS_MEMBER(GuiIqQuery)

			BEGIN_ENUM_ITEM(GuiIqNameOption)
				ENUM_ITEM_NAMESPACE(GuiIqNameOption)
				ENUM_NAMESPACE_ITEM(Specified)
				ENUM_NAMESPACE_ITEM(Any)
			END_ENUM_ITEM(GuiIqNameOption)

			BEGIN_ENUM_ITEM(GuiIqChildOption)
				ENUM_ITEM_NAMESPACE(GuiIqChildOption)
				ENUM_NAMESPACE_ITEM(Direct)
				ENUM_NAMESPACE_ITEM(Indirect)
			END_ENUM_ITEM(GuiIqChildOption)

			BEGIN_CLASS_MEMBER(GuiIqPrimaryQuery)
				CLASS_MEMBER_BASE(GuiIqQuery)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<GuiIqPrimaryQuery>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(childOption)
				CLASS_MEMBER_FIELD(attributeNameOption)
				PARSING_TOKEN_FIELD(attributeName)
				CLASS_MEMBER_FIELD(typeNameOption)
				PARSING_TOKEN_FIELD(typeName)
				PARSING_TOKEN_FIELD(referenceName)
			END_CLASS_MEMBER(GuiIqPrimaryQuery)

			BEGIN_CLASS_MEMBER(GuiIqCascadeQuery)
				CLASS_MEMBER_BASE(GuiIqQuery)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<GuiIqCascadeQuery>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(parent)
				CLASS_MEMBER_FIELD(child)
			END_CLASS_MEMBER(GuiIqCascadeQuery)

			BEGIN_ENUM_ITEM(GuiIqBinaryOperator)
				ENUM_ITEM_NAMESPACE(GuiIqBinaryOperator)
				ENUM_NAMESPACE_ITEM(ExclusiveOr)
				ENUM_NAMESPACE_ITEM(Intersect)
				ENUM_NAMESPACE_ITEM(Union)
				ENUM_NAMESPACE_ITEM(Substract)
			END_ENUM_ITEM(GuiIqBinaryOperator)

			BEGIN_CLASS_MEMBER(GuiIqSetQuery)
				CLASS_MEMBER_BASE(GuiIqQuery)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<GuiIqSetQuery>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(first)
				CLASS_MEMBER_FIELD(second)
				CLASS_MEMBER_FIELD(op)
			END_CLASS_MEMBER(GuiIqSetQuery)

			BEGIN_INTERFACE_MEMBER(GuiIqQuery::IVisitor)
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(GuiIqQuery::IVisitor::*)(GuiIqPrimaryQuery* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(GuiIqQuery::IVisitor::*)(GuiIqCascadeQuery* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(GuiIqQuery::IVisitor::*)(GuiIqSetQuery* node))
			END_INTERFACE_MEMBER(GuiIqQuery)

#undef PARSING_TOKEN_FIELD

			class GuiIqTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::presentation::GuiIqQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqNameOption)
					ADD_TYPE_INFO(vl::presentation::GuiIqChildOption)
					ADD_TYPE_INFO(vl::presentation::GuiIqPrimaryQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqCascadeQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqBinaryOperator)
					ADD_TYPE_INFO(vl::presentation::GuiIqSetQuery)
					ADD_TYPE_INFO(vl::presentation::GuiIqQuery::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool GuiIqLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new GuiIqTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWCODEGEN.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace workflow::runtime;
		using namespace reflection::description;
		using namespace collections;

		using namespace controls;
		using namespace compositions;

/***********************************************************************
FindInstanceLoadingSource
***********************************************************************/

		InstanceLoadingSource FindInstanceLoadingSource(Ptr<GuiInstanceContext> context, GuiConstructorRepr* ctor)
		{
			vint index = context->namespaces.Keys().IndexOf(ctor->typeNamespace);
			if (index != -1)
			{
				Ptr<GuiInstanceContext::NamespaceInfo> namespaceInfo = context->namespaces.Values()[index];
				FOREACH(Ptr<GuiInstanceNamespace>, ns, namespaceInfo->namespaces)
				{
					auto fullName = GlobalStringKey::Get(ns->prefix + ctor->typeName.ToString() + ns->postfix);
					if(auto loader = GetInstanceLoaderManager()->GetLoader(fullName))
					{
						return InstanceLoadingSource(loader, fullName);
					}
				}
			}
			return InstanceLoadingSource();
		}

/***********************************************************************
Workflow_ValidateStatement
***********************************************************************/

		bool Workflow_ValidateStatement(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, types::ErrorList& errors, const WString& code, Ptr<workflow::WfStatement> statement)
		{
			bool failed = false;

			if (!resolvingResult.moduleForValidate)
			{
				resolvingResult.moduleForValidate = Workflow_CreateModuleWithUsings(context);
				resolvingResult.moduleContent = Workflow_InstallCtorClass(context, resolvingResult, rootTypeDescriptor, resolvingResult.moduleForValidate);
			}
			resolvingResult.moduleContent->statements.Add(statement);

			Workflow_GetSharedManager()->Clear(true, true);
			Workflow_GetSharedManager()->AddModule(resolvingResult.moduleForValidate);
			Workflow_GetSharedManager()->Rebuild(true);
			if (Workflow_GetSharedManager()->errors.Count() > 0)
			{
				errors.Add(L"Failed to analyze the workflow code \"" + code + L"\".");
				FOREACH(Ptr<parsing::ParsingError>, error, Workflow_GetSharedManager()->errors)
				{
					errors.Add(L"    " + error->errorMessage);
				}
				failed = true;
			}

			resolvingResult.moduleContent->statements.Remove(statement.Obj());
			return !failed;
		}

/***********************************************************************
Workflow_PrecompileInstanceContext (Passes)
***********************************************************************/

		extern ITypeDescriptor* Workflow_CollectReferences(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, types::ErrorList& errors);
		extern void Workflow_GenerateCreating(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, Ptr<WfBlockStatement> statements, types::ErrorList& errors);
		extern void Workflow_GenerateBindings(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, Ptr<WfBlockStatement> statements, types::ErrorList& errors);

/***********************************************************************
Workflow_PrecompileInstanceContext
***********************************************************************/

		Ptr<workflow::WfModule> Workflow_PrecompileInstanceContext(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, types::ErrorList& errors)
		{
			vint previousErrorCount = errors.Count();
			ITypeDescriptor* rootTypeDescriptor = 0;
			if (context->className == L"")
			{
				errors.Add(
					L"Precompile: Instance  \"" +
					(context->instance->typeNamespace == GlobalStringKey::Empty
						? context->instance->typeName.ToString()
						: context->instance->typeNamespace.ToString() + L":" + context->instance->typeName.ToString()
						) +
					L"\" should have the class name specified in the ref.Class attribute.");
			}

			rootTypeDescriptor = Workflow_CollectReferences(context, resolvingResult, errors);

			if (errors.Count() == previousErrorCount)
			{
				auto module = Workflow_CreateModuleWithUsings(context);
				{
					auto block = Workflow_InstallCtorClass(context, resolvingResult, rootTypeDescriptor, module);
					Workflow_GenerateCreating(context, resolvingResult, rootTypeDescriptor, block, errors);
					Workflow_GenerateBindings(context, resolvingResult, rootTypeDescriptor, block, errors);
				}
				return module;
			}

			return nullptr;
		}

/***********************************************************************
WorkflowEventNamesVisitor
***********************************************************************/

		class WorkflowEventNamesVisitor : public Object, public GuiValueRepr::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			Ptr<WfClassDeclaration>				instanceClass;
			types::ErrorList&					errors;
			IGuiInstanceLoader::TypeInfo		resolvedTypeInfo;

			WorkflowEventNamesVisitor(Ptr<GuiInstanceContext> _context, Ptr<WfClassDeclaration> _instanceClass, types::ErrorList& _errors)
				:context(_context)
				, instanceClass(_instanceClass)
				, errors(_errors)
			{
			}

			void Visit(GuiTextRepr* repr)override
			{
			}

			void Visit(GuiAttSetterRepr* repr)override
			{
				FOREACH_INDEXER(Ptr<GuiAttSetterRepr::SetterValue>, setter, index, repr->setters.Values())
				{
					if (setter->binding == GlobalStringKey::_Set)
					{
						auto prop = repr->setters.Keys()[index];
						IGuiInstanceLoader::PropertyInfo propertyInfo(resolvedTypeInfo, prop);
						auto errorPrefix = L"Precompile: Property \"" + propertyInfo.propertyName.ToString() + L"\" of type \"" + resolvedTypeInfo.typeName.ToString() + L"\"";

						auto loader = GetInstanceLoaderManager()->GetLoader(resolvedTypeInfo.typeName);
						auto currentLoader = loader;
						IGuiInstanceLoader::TypeInfo propTypeInfo;

						while (currentLoader)
						{
							if (auto propertyTypeInfo = currentLoader->GetPropertyType(propertyInfo))
							{
								if (propertyTypeInfo->support == GuiInstancePropertyInfo::NotSupport)
								{
									errors.Add(errorPrefix + L" is not supported.");
									goto SKIP_SET;
								}
								else
								{
									if (propertyTypeInfo->support == GuiInstancePropertyInfo::SupportSet)
									{
										propTypeInfo.typeDescriptor = propertyTypeInfo->acceptableTypes[0];
										propTypeInfo.typeName = GlobalStringKey::Get(propTypeInfo.typeDescriptor->GetTypeName());
									}
									else
									{
										errors.Add(errorPrefix + L" does not support the \"-set\" binding.");
										goto SKIP_SET;
									}
								}

								if (!propertyTypeInfo->tryParent)
								{
									break;
								}
							}
							currentLoader = GetInstanceLoaderManager()->GetParentLoader(currentLoader);
						}

						if (propTypeInfo.typeDescriptor)
						{
							auto oldTypeInfo = resolvedTypeInfo;
							resolvedTypeInfo = propTypeInfo;
							FOREACH(Ptr<GuiValueRepr>, value, setter->values)
							{
								value->Accept(this);
							}
							resolvedTypeInfo = oldTypeInfo;
						}
						else
						{
							errors.Add(errorPrefix + L" does not exist.");
						}
					SKIP_SET:;
					}
					else
					{
						FOREACH(Ptr<GuiValueRepr>, value, setter->values)
						{
							value->Accept(this);
						}
					}
				}

				FOREACH_INDEXER(Ptr<GuiAttSetterRepr::EventValue>, handler, index, repr->eventHandlers.Values())
				{
					if (handler->binding == GlobalStringKey::Empty)
					{
						auto propertyName = repr->eventHandlers.Keys()[index];
						if (auto eventInfo = resolvedTypeInfo.typeDescriptor->GetEventByName(propertyName.ToString(), true))
						{
							auto decl = Workflow_GenerateEventHandler(eventInfo);
							decl->anonymity = WfFunctionAnonymity::Named;
							decl->name.value = handler->value;

							{
								auto block = MakePtr<WfBlockStatement>();
								decl->statement = block;
								
								auto stringExpr = MakePtr<WfStringExpression>();
								stringExpr->value.value = L"Not Implemented: " + handler->value;

								auto raiseStat = MakePtr<WfRaiseExceptionStatement>();
								raiseStat->expression = stringExpr;
								block->statements.Add(raiseStat);
							}

							auto member = MakePtr<WfClassMember>();
							member->kind = WfClassMemberKind::Normal;
							member->declaration = decl;
							instanceClass->members.Add(member);
						}
						else
						{
							errors.Add(L"Precompile: Event \"" + propertyName.ToString() + L"\" cannot be found in type \"" + resolvedTypeInfo.typeName.ToString() + L"\".");
						}
					}
				}
			}

			void Visit(GuiConstructorRepr* repr)override
			{
				IGuiInstanceLoader::TypeInfo reprTypeInfo;

				if (repr == context->instance.Obj())
				{
					auto fullName = GlobalStringKey::Get(context->className);
					if (auto reprTd = GetInstanceLoaderManager()->GetTypeDescriptorForType(fullName))
					{
						reprTypeInfo.typeName = fullName;
						reprTypeInfo.typeDescriptor = reprTd;
					}
				}

				if (!reprTypeInfo.typeDescriptor)
				{
					auto source = FindInstanceLoadingSource(context, repr);
					reprTypeInfo.typeName = source.typeName;
					reprTypeInfo.typeDescriptor = GetInstanceLoaderManager()->GetTypeDescriptorForType(source.typeName);
				}

				if (reprTypeInfo.typeDescriptor)
				{
					auto oldTypeInfo = resolvedTypeInfo;
					resolvedTypeInfo = reprTypeInfo;
					Visit((GuiAttSetterRepr*)repr);
					resolvedTypeInfo = oldTypeInfo;
				}
				else
				{
					errors.Add(
						L"Precompile: Failed to find type \"" +
						(repr->typeNamespace == GlobalStringKey::Empty
							? repr->typeName.ToString()
							: repr->typeNamespace.ToString() + L":" + repr->typeName.ToString()
							) +
						L"\".");
				}
			}
		};

/***********************************************************************
Workflow_GenerateInstanceClass
***********************************************************************/

		Ptr<workflow::WfModule> Workflow_GenerateInstanceClass(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, types::ErrorList& errors, vint passIndex)
		{
			bool beforePrecompile = false;
			bool needEventHandler = false;
			switch (passIndex)
			{
			case IGuiResourceTypeResolver_Precompile::Instance_CollectInstanceTypes:
				beforePrecompile = true;
				needEventHandler = false;
				break;
			case IGuiResourceTypeResolver_Precompile::Instance_GenerateTemporaryClass:
				beforePrecompile = true;
				needEventHandler = true;
				break;
			case IGuiResourceTypeResolver_Precompile::Instance_GenerateInstanceClass:
				beforePrecompile = false;
				needEventHandler = true;
				break;
			}

			auto source = FindInstanceLoadingSource(context, context->instance.Obj());
			auto baseTd = GetInstanceLoaderManager()->GetTypeDescriptorForType(source.typeName);
			if (!baseTd)
			{
				errors.Add(
					L"Precompile: Failed to find type \"" +
					(context->instance->typeNamespace == GlobalStringKey::Empty
						? context->instance->typeName.ToString()
						: context->instance->typeNamespace.ToString() + L":" + context->instance->typeName.ToString()
						) +
					L" for instance type \"" +
					context->className +
					L"\".");
				return nullptr;
			}

			ITypeDescriptor* ctorTd = nullptr;
			Ptr<ITypeInfo> ctorType;
			if (!beforePrecompile)
			{
				if ((ctorTd = description::GetTypeDescriptor(context->className + L"<Ctor>")))
				{
					auto elementType = MakePtr<TypeDescriptorTypeInfo>(ctorTd, TypeInfoHint::Normal);
					auto pointerType = MakePtr<SharedPtrTypeInfo>(elementType);

					ctorType = pointerType;
				}
				else
				{
					errors.Add(
						L"Precompile: Builder type \"" +
						context->className +
						L"<Ctor>\" does not exist.");
					return nullptr;
				}
			}

			ITypeDescriptor* contextTd = nullptr;
			if (!beforePrecompile)
			{
				if (!(contextTd = description::GetTypeDescriptor(context->className)))
				{
					errors.Add(
						L"Precompile: Instance type \"" +
						context->className +
						L"\" does not exist.");
					return nullptr;
				}
			}

			auto module = Workflow_CreateModuleWithUsings(context);
			auto instanceClass = Workflow_InstallClass(context->className, module);
			{
				auto typeInfo = MakePtr<TypeDescriptorTypeInfo>(baseTd, TypeInfoHint::Normal);
				auto baseType = GetTypeFromTypeInfo(typeInfo.Obj());
				instanceClass->baseTypes.Add(baseType);
			}

			auto typeParser = GetParserManager()->GetParser<WfType>(L"WORKFLOW-TYPE");
			auto parseType = [typeParser, &errors](const WString& code, const WString& name)->Ptr<WfType>
			{
				List<WString> parserErrors;
				if (auto type = typeParser->TypedParse(code, parserErrors))
				{
					return type;
				}
				else
				{
					errors.Add(L"Precompile: Failed to parse " + name + L": " + code);
					return nullptr;
				}
			};

			auto expressionParser = GetParserManager()->GetParser<WfExpression>(L"WORKFLOW-EXPRESSION");
			auto parseExpression = [expressionParser, &errors](const WString& code, const WString& name)->Ptr<WfExpression>
			{
				List<WString> parserErrors;
				if (auto type = expressionParser->TypedParse(code, parserErrors))
				{
					return type;
				}
				else
				{
					errors.Add(L"Precompile: Failed to parse " + name + L": " + code);
					return nullptr;
				}
			};

			auto addDecl = [=](Ptr<WfDeclaration> decl)
			{
				auto member = MakePtr<WfClassMember>();
				member->kind = WfClassMemberKind::Normal;
				member->declaration = decl;
				instanceClass->members.Add(member);
			};
			auto notImplemented = []()
			{
				auto block = MakePtr<WfBlockStatement>();

				auto stringExpr = MakePtr<WfStringExpression>();
				stringExpr->value.value = L"Not Implemented";

				auto raiseStat = MakePtr<WfRaiseExceptionStatement>();
				raiseStat->expression = stringExpr;

				block->statements.Add(raiseStat);
				return block;
			};
			auto getPropValue = [=, &errors](const WString& name, Ptr<WfType> type, const WString& value)->Ptr<WfExpression>
			{
				auto propInfo = contextTd->GetPropertyByName(name, false);
				if (propInfo)
				{
					auto propTd = propInfo->GetReturn()->GetTypeDescriptor();
					if ((propTd->GetTypeDescriptorFlags() & TypeDescriptorFlags::StructType) != TypeDescriptorFlags::Undefined)
					{
						if (value == L"")
						{
							auto defaultValue = propTd->GetValueType()->CreateDefault();
							return Workflow_CreateValue(defaultValue, errors);
						}
						else
						{
							return Workflow_ParseTextValue(propTd, value, errors);
						}
					}
					else
					{
						auto nullExpr = MakePtr<WfLiteralExpression>();
						nullExpr->value = WfLiteralValue::Null;

						return nullExpr;
					}
				}
				else
				{
					errors.Add(
						L"Precompile: Cannot find property \"" +
						name +
						L"Precompile: in instance type \"" +
						context->className +
						L"\" does not exist.");
					return nullptr;
				}
			};

			if (!beforePrecompile)
			{
				{
					auto decl = MakePtr<WfVariableDeclaration>();
					addDecl(decl);

					decl->name.value = L"<ctor>";
					decl->type = GetTypeFromTypeInfo(ctorType.Obj());

					auto nullExpr = MakePtr<WfLiteralExpression>();
					nullExpr->value = WfLiteralValue::Null;
					decl->expression = nullExpr;
				}
				FOREACH(GlobalStringKey, name, resolvingResult.referenceNames)
				{
					auto prop = ctorTd->GetPropertyByName(name.ToString(), false);

					auto decl = MakePtr<WfVariableDeclaration>();
					addDecl(decl);

					decl->name.value = prop->GetName();
					decl->type = GetTypeFromTypeInfo(prop->GetReturn());

					auto nullExpr = MakePtr<WfLiteralExpression>();
					nullExpr->value = WfLiteralValue::Null;
					decl->expression = nullExpr;
				}
			}

			FOREACH(Ptr<GuiInstanceState>, state, context->states)
			{
				if (auto type = parseType(state->typeName, L"state \"" + state->name.ToString() + L" of instance \"" + context->className + L"\""))
				{
					auto decl = MakePtr<WfVariableDeclaration>();
					addDecl(decl);

					decl->name.value = state->name.ToString();
					decl->type = type;
					if (!beforePrecompile)
					{
						decl->expression = getPropValue(state->name.ToString(), type, state->value);
					}
					else
					{
						auto nullExpr = MakePtr<WfLiteralExpression>();
						nullExpr->value = WfLiteralValue::Null;

						auto castObject = MakePtr<WfInferExpression>();
						castObject->type = GetTypeFromTypeInfo(TypeInfoRetriver<Value>::CreateTypeInfo().Obj());
						castObject->expression = nullExpr;

						auto castType = MakePtr<WfTypeCastingExpression>();
						castType->strategy = WfTypeCastingStrategy::Strong;
						castType->type = CopyType(type);
						castType->expression = castObject;

						decl->expression = castType;
					}
				}
			}

			FOREACH(Ptr<GuiInstanceProperty>, prop, context->properties)
			{
				if (auto type = parseType(prop->typeName, L"property \"" + prop->name.ToString() + L" of instance \"" + context->className + L"\""))
				{
					if (!beforePrecompile)
					{
						auto decl = MakePtr<WfVariableDeclaration>();
						addDecl(decl);

						decl->name.value = L"<property>" + prop->name.ToString();
						decl->type = CopyType(type);
						decl->expression = getPropValue(prop->name.ToString(), type, prop->value);
					}
					{
						auto decl = MakePtr<WfFunctionDeclaration>();
						addDecl(decl);

						decl->anonymity = WfFunctionAnonymity::Named;
						decl->name.value = L"Get" + prop->name.ToString();
						decl->returnType = CopyType(type);
						if (!beforePrecompile)
						{
							auto block = MakePtr<WfBlockStatement>();
							decl->statement = block;

							auto ref = MakePtr<WfReferenceExpression>();
							ref->name.value = L"<property>" + prop->name.ToString();

							auto returnStat = MakePtr<WfReturnStatement>();
							returnStat->expression = ref;
							block->statements.Add(returnStat);
						}
						else
						{
							decl->statement = notImplemented();
						}
					}
					{
						auto decl = MakePtr<WfFunctionDeclaration>();
						addDecl(decl);

						decl->anonymity = WfFunctionAnonymity::Named;
						decl->name.value = L"Set" + prop->name.ToString();
						{
							auto argument = MakePtr<WfFunctionArgument>();
							argument->name.value = L"<value>";
							argument->type = CopyType(type);
							decl->arguments.Add(argument);
						}
						{
							auto voidType = MakePtr<WfPredefinedType>();
							voidType->name = WfPredefinedTypeName::Void;
							decl->returnType = voidType;
						}
						if (!beforePrecompile)
						{
							auto block = MakePtr<WfBlockStatement>();
							decl->statement = block;

							auto ifStat = MakePtr<WfIfStatement>();
							block->statements.Add(ifStat);
							{
								auto refProp = MakePtr<WfReferenceExpression>();
								refProp->name.value = L"<property>" + prop->name.ToString();

								auto refValue = MakePtr<WfReferenceExpression>();
								refValue->name.value = L"<value>";

								auto compExpr = MakePtr<WfBinaryExpression>();
								compExpr->op = WfBinaryOperator::NE;
								compExpr->first = refProp;
								compExpr->second = refValue;

								ifStat->expression = compExpr;
							}

							auto trueBlock = MakePtr<WfBlockStatement>();
							ifStat->trueBranch = trueBlock;
							{
								auto refProp = MakePtr<WfReferenceExpression>();
								refProp->name.value = L"<property>" + prop->name.ToString();

								auto refValue = MakePtr<WfReferenceExpression>();
								refValue->name.value = L"<value>";

								auto assignExpr = MakePtr<WfBinaryExpression>();
								assignExpr->op = WfBinaryOperator::Assign;
								assignExpr->first = refProp;
								assignExpr->second = refValue;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = assignExpr;

								trueBlock->statements.Add(stat);
							}
							{
								auto refEvent = MakePtr<WfReferenceExpression>();
								refEvent->name.value = prop->name.ToString() + L"Changed";

								auto call = MakePtr<WfCallExpression>();
								call->function = refEvent;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = call;

								trueBlock->statements.Add(stat);
							}
						}
						else
						{
							decl->statement = notImplemented();
						}
					}
					{
						auto decl = MakePtr<WfEventDeclaration>();
						addDecl(decl);

						decl->name.value = prop->name.ToString() + L"Changed";
					}
					{
						auto decl = MakePtr<WfPropertyDeclaration>();
						addDecl(decl);

						decl->name.value = prop->name.ToString();
						decl->type = type;
						decl->getter.value = L"Get" + prop->name.ToString();
						decl->setter.value = L"Set" + prop->name.ToString();
						decl->valueChangedEvent.value = prop->name.ToString() + L"Changed";
					}
				}
			}

			FOREACH(Ptr<GuiInstanceComponent>, component, context->components)
			{
				auto type = parseType(component->typeName, L"component \"" + component->name.ToString() + L" of instance \"" + context->className + L"\"");
				auto expression = parseExpression(component->expression, L"component \"" + component->name.ToString() + L" of instance \"" + context->className + L"\"");

				if (type && expression)
				{
					{
						auto decl = MakePtr<WfFunctionDeclaration>();
						addDecl(decl);

						decl->anonymity = WfFunctionAnonymity::Named;
						decl->name.value = L"Get" + component->name.ToString();
						decl->returnType = CopyType(type);
						if (!beforePrecompile)
						{
							auto block = MakePtr<WfBlockStatement>();
							decl->statement = block;

							auto returnStat = MakePtr<WfReturnStatement>();
							returnStat->expression = expression;
							block->statements.Add(returnStat);
						}
						else
						{
							decl->statement = notImplemented();
						}
					}
					{
						auto decl = MakePtr<WfPropertyDeclaration>();
						addDecl(decl);

						decl->name.value = component->name.ToString();
						decl->type = type;
						decl->getter.value = L"Get" + component->name.ToString();
					}
				}
			}

			auto ctor = MakePtr<WfConstructorDeclaration>();
			ctor->constructorType = WfConstructorType::RawPtr;
			auto ctorBlock = (beforePrecompile ? notImplemented() : MakePtr<WfBlockStatement>());
			ctor->statement = ctorBlock;

			if (auto group = baseTd->GetConstructorGroup())
			{
				vint count = group->GetMethod(0)->GetParameterCount();
				if (count > 0)
				{
					if (!beforePrecompile)
					{
						Ptr<WfExpression> controlTemplate;
						{
							vint index = resolvingResult.rootCtorArguments.Keys().IndexOf(GlobalStringKey::_ControlTemplate);
							if (index != -1)
							{
								controlTemplate = resolvingResult.rootCtorArguments.GetByIndex(index)[0].expression;
							}
						}
						if (auto call = resolvingResult.rootLoader->CreateRootInstance(resolvingResult.rootTypeInfo, controlTemplate, errors))
						{
							ctor->baseConstructorCalls.Add(call);
						}
					}
					else
					{
						auto call = MakePtr<WfBaseConstructorCall>();
						ctor->baseConstructorCalls.Add(call);

						call->type = CopyType(instanceClass->baseTypes[0]);
						for (vint i = 0; i < count; i++)
						{
							auto nullExpr = MakePtr<WfLiteralExpression>();
							nullExpr->value = WfLiteralValue::Null;
							call->arguments.Add(nullExpr);
						}
					}
				}
			}

			FOREACH(Ptr<GuiInstanceEvent>, ev, context->events)
			{
				if (ev->eventArgsClass == L"")
				{
					auto decl = MakePtr<WfEventDeclaration>();
					addDecl(decl);
					decl->name.value = ev->name.ToString();
				}
				else if (auto type = parseType(ev->eventArgsClass + L"*", L"event \"" + ev->name.ToString() + L" of instance \"" + context->className + L"\""))
				{
					{
						auto decl = MakePtr<WfEventDeclaration>();
						addDecl(decl);
						decl->name.value = ev->name.ToString();
						decl->arguments.Add(GetTypeFromTypeInfo(TypeInfoRetriver<GuiGraphicsComposition*>::CreateTypeInfo().Obj()));
						decl->arguments.Add(type);
					}
					if (beforePrecompile)
					{
						auto sharedType = MakePtr<WfSharedPointerType>();
						sharedType->element = CopyType(type.Cast<WfRawPointerType>()->element);
						{
							auto newExpr = MakePtr<WfNewClassExpression>();
							newExpr->type = sharedType;

							auto inferExpr = MakePtr<WfInferExpression>();
							inferExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<GuiEventArgs>>::CreateTypeInfo().Obj());
							inferExpr->expression = newExpr;

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = inferExpr;
							ctorBlock->statements.Add(stat);
						}
						{
							auto nullExpr = MakePtr<WfLiteralExpression>();
							nullExpr->value = WfLiteralValue::Null;

							auto argument = MakePtr<WfInferExpression>();
							argument->type = GetTypeFromTypeInfo(TypeInfoRetriver<GuiGraphicsComposition*>::CreateTypeInfo().Obj());
							argument->expression = nullExpr;

							auto newExpr = MakePtr<WfNewClassExpression>();
							newExpr->type = CopyType(sharedType);
							newExpr->arguments.Add(argument);

							auto inferExpr = MakePtr<WfInferExpression>();
							inferExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<GuiEventArgs>>::CreateTypeInfo().Obj());
							inferExpr->expression = newExpr;

							auto stat = MakePtr<WfExpressionStatement>();
							stat->expression = inferExpr;
							ctorBlock->statements.Add(stat);
						}
					}
				}
			}

			FOREACH(Ptr<GuiInstanceParameter>, param, context->parameters)
			{
				if (auto type = parseType(param->className.ToString() + L"^", L"parameter \"" + param->name.ToString() + L" of instance \"" + context->className + L"\""))
				{
					if (!beforePrecompile)
					{
						auto decl = MakePtr<WfVariableDeclaration>();
						addDecl(decl);

						decl->name.value = L"<parameter>" + param->name.ToString();
						decl->type = CopyType(type);
						
						auto nullExpr = MakePtr<WfLiteralExpression>();
						nullExpr->value = WfLiteralValue::Null;
						decl->expression = nullExpr;
					}
					{
						auto decl = MakePtr<WfFunctionDeclaration>();
						addDecl(decl);

						decl->anonymity = WfFunctionAnonymity::Named;
						decl->name.value = L"Get" + param->name.ToString();
						decl->returnType = CopyType(type);
						if (!beforePrecompile)
						{
							auto block = MakePtr<WfBlockStatement>();
							decl->statement = block;

							auto ref = MakePtr<WfReferenceExpression>();
							ref->name.value = L"<parameter>" + param->name.ToString();

							auto returnStat = MakePtr<WfReturnStatement>();
							returnStat->expression = ref;
							block->statements.Add(returnStat);
						}
						else
						{
							decl->statement = notImplemented();
						}
					}
					{
						auto decl = MakePtr<WfPropertyDeclaration>();
						addDecl(decl);

						decl->name.value = param->name.ToString();
						decl->type = type;
						decl->getter.value = L"Get" + param->name.ToString();
					}
					{
						auto argument = MakePtr<WfFunctionArgument>();
						argument->name.value = L"<ctor-parameter>" + param->name.ToString();
						argument->type = CopyType(type);
						ctor->arguments.Add(argument);
					}
					if (!beforePrecompile)
					{
						auto refLeft = MakePtr<WfReferenceExpression>();
						refLeft->name.value = L"<parameter>" + param->name.ToString();

						auto refRight = MakePtr<WfReferenceExpression>();
						refRight->name.value = L"<ctor-parameter>" + param->name.ToString();

						auto assignExpr = MakePtr<WfBinaryExpression>();
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refLeft;
						assignExpr->second = refRight;

						auto exprStat = MakePtr<WfExpressionStatement>();
						exprStat->expression = assignExpr;

						ctorBlock->statements.Add(exprStat);
					}
				}
			}

			if (needEventHandler)
			{
				WorkflowEventNamesVisitor visitor(context, instanceClass, errors);
				context->instance->Accept(&visitor);
			}
			addDecl(ctor);

			if (!beforePrecompile)
			{
				{
					auto presentationExpr = MakePtr<WfTopQualifiedExpression>();
					presentationExpr->name.value = L"presentation";

					auto rmExpr = MakePtr<WfChildExpression>();
					rmExpr->parent = presentationExpr;
					rmExpr->name.value = L"IGuiResourceManager";

					auto getRmExpr = MakePtr<WfChildExpression>();
					getRmExpr->parent = rmExpr;
					getRmExpr->name.value = L"GetResourceManager";

					auto call1Expr = MakePtr<WfCallExpression>();
					call1Expr->function = getRmExpr;

					auto getResExpr = MakePtr<WfMemberExpression>();
					getResExpr->parent = call1Expr;
					getResExpr->name.value = L"GetResourceFromClassName";

					auto classNameExpr = MakePtr<WfStringExpression>();
					classNameExpr->value.value = context->className;

					auto call2Expr = MakePtr<WfCallExpression>();
					call2Expr->function = getResExpr;
					call2Expr->arguments.Add(classNameExpr);

					auto varDecl = MakePtr<WfVariableDeclaration>();
					varDecl->name.value = L"<resource>";
					varDecl->expression = call2Expr;

					auto varStat = MakePtr<WfVariableStatement>();
					varStat->variable = varDecl;

					ctorBlock->statements.Add(varStat);
				}
				{
					auto resRef = MakePtr<WfReferenceExpression>();
					resRef->name.value = L"<resource>";

					auto resRef2 = MakePtr<WfReferenceExpression>();
					resRef2->name.value = L"<resource>";

					auto wdRef = MakePtr<WfMemberExpression>();
					wdRef->parent = resRef2;
					wdRef->name.value = L"WorkingDirectory";

					auto newClassExpr = MakePtr<WfNewClassExpression>();
					newClassExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<GuiResourcePathResolver>>::CreateTypeInfo().Obj());
					newClassExpr->arguments.Add(resRef);
					newClassExpr->arguments.Add(wdRef);

					auto varDecl = MakePtr<WfVariableDeclaration>();
					varDecl->name.value = L"<resolver>";
					varDecl->expression = newClassExpr;

					auto varStat = MakePtr<WfVariableStatement>();
					varStat->variable = varDecl;

					ctorBlock->statements.Add(varStat);
				}
				{
					auto newClassExpr = MakePtr<WfNewClassExpression>();
					newClassExpr->type = GetTypeFromTypeInfo(ctorType.Obj());
					
					auto ctorRef = MakePtr<WfReferenceExpression>();
					ctorRef->name.value = L"<ctor>";

					auto assignExpr = MakePtr<WfBinaryExpression>();
					assignExpr->op = WfBinaryOperator::Assign;
					assignExpr->first = ctorRef;
					assignExpr->second = newClassExpr;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assignExpr;

					ctorBlock->statements.Add(stat);
				}
				{
					auto ctorRef = MakePtr<WfReferenceExpression>();
					ctorRef->name.value = L"<ctor>";

					auto initRef = MakePtr<WfMemberExpression>();
					initRef->parent = ctorRef;
					initRef->name.value = L"<initialize-instance>";

					auto refThis = MakePtr<WfThisExpression>();
					
					auto resolverRef = MakePtr<WfReferenceExpression>();
					resolverRef->name.value = L"<resolver>";

					auto castExpr = MakePtr<WfTypeCastingExpression>();
					castExpr->strategy = WfTypeCastingStrategy::Strong;
					castExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<GuiResourcePathResolver*>::CreateTypeInfo().Obj());
					castExpr->expression = resolverRef;

					auto callExpr = MakePtr<WfCallExpression>();
					callExpr->function = initRef;
					callExpr->arguments.Add(refThis);
					callExpr->arguments.Add(castExpr);

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = callExpr;

					ctorBlock->statements.Add(stat);
				}
				FOREACH(GlobalStringKey, name, resolvingResult.referenceNames)
				{
					auto propRef = MakePtr<WfReferenceExpression>();
					propRef->name.value = name.ToString();

					auto ctorRef = MakePtr<WfReferenceExpression>();
					ctorRef->name.value = L"<ctor>";

					auto ctorPropRef = MakePtr<WfMemberExpression>();
					ctorPropRef->parent = ctorRef;
					ctorPropRef->name.value =  name.ToString();

					auto assignExpr = MakePtr<WfBinaryExpression>();
					assignExpr->op = WfBinaryOperator::Assign;
					assignExpr->first = propRef;
					assignExpr->second = ctorPropRef;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assignExpr;

					ctorBlock->statements.Add(stat);
				}
			}

			{
				auto dtor = MakePtr<WfDestructorDeclaration>();
				addDecl(dtor);

				auto block = MakePtr<WfBlockStatement>();
				dtor->statement = block;

				auto ref = MakePtr<WfReferenceExpression>();
				ref->name.value = L"ClearSubscriptions";

				auto call = MakePtr<WfCallExpression>();
				call->function = ref;

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = call;
				block->statements.Add(stat);
			}

			return module;
		}

/***********************************************************************
GuiWorkflowSharedManagerPlugin
***********************************************************************/

#undef ERROR_CODE_PREFIX

		class GuiWorkflowSharedManagerPlugin;
		GuiWorkflowSharedManagerPlugin* sharedManagerPlugin = 0;

		class GuiWorkflowSharedManagerPlugin : public Object, public IGuiPlugin
		{
		protected:
			Ptr<WfLexicalScopeManager>		workflowManager;

		public:
			GuiWorkflowSharedManagerPlugin()
			{
			}

			void Load()override
			{
			}

			void AfterLoad()override
			{
				sharedManagerPlugin = this;
			}

			void Unload()override
			{
				sharedManagerPlugin = 0;
			}

			WfLexicalScopeManager* GetWorkflowManager()
			{
				if (!workflowManager)
				{
					workflowManager = new WfLexicalScopeManager(GetParserManager()->GetParsingTable(L"WORKFLOW"));
				}
				return workflowManager.Obj();
			}
		};
		GUI_REGISTER_PLUGIN(GuiWorkflowSharedManagerPlugin)

		WfLexicalScopeManager* Workflow_GetSharedManager()
		{
			return sharedManagerPlugin->GetWorkflowManager();
		}
	}
}

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWCOLLECTREFERENCES.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace reflection::description;
		using namespace collections;
		using namespace workflow::analyzer;

/***********************************************************************
WorkflowReferenceNamesVisitor
***********************************************************************/

		class WorkflowReferenceNamesVisitor : public Object, public GuiValueRepr::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			types::ResolvingResult&				resolvingResult;
			vint&								generatedNameCount;
			types::ErrorList&					errors;

			List<types::PropertyResolving>&		candidatePropertyTypeInfos;
			IGuiInstanceLoader::TypeInfo		resolvedTypeInfo;
			vint								selectedPropertyTypeInfo = -1;

			WorkflowReferenceNamesVisitor(Ptr<GuiInstanceContext> _context, types::ResolvingResult& _resolvingResult, List<types::PropertyResolving>& _candidatePropertyTypeInfos, vint& _generatedNameCount, types::ErrorList& _errors)
				:context(_context)
				, resolvingResult(_resolvingResult)
				, candidatePropertyTypeInfos(_candidatePropertyTypeInfos)
				, generatedNameCount(_generatedNameCount)
				, errors(_errors)
			{
			}

			void Visit(GuiTextRepr* repr)override
			{
				if (selectedPropertyTypeInfo == -1)
				{
					selectedPropertyTypeInfo = 0;
				}
				
				auto candidate = candidatePropertyTypeInfos[selectedPropertyTypeInfo];
				auto propertyInfo = candidate.propertyInfo;
				auto td = candidate.info->acceptableTypes[0];

				if (auto st = td->GetSerializableType())
				{
					Value value;
					if (st->Deserialize(repr->text, value))
					{
						resolvingResult.propertyResolvings.Add(repr, candidate);
					}
					else
					{
						auto error
							= L"Precompile: Property \""
							+ propertyInfo.propertyName.ToString()
							+ L"\" of type \""
							+ propertyInfo.typeInfo.typeName.ToString()
							+ L"\" does not accept a value of text \""
							+ repr->text
							+ L"\" because it is not in a correct format of the serializable type \""
							+ td->GetTypeName()
							+ L"\".";
						errors.Add(error);
					}
				}
				else
				{
					switch (td->GetTypeDescriptorFlags())
					{
					case TypeDescriptorFlags::FlagEnum:
					case TypeDescriptorFlags::NormalEnum:
					case TypeDescriptorFlags::Struct:
						if (auto expression = Workflow_ParseTextValue(td, repr->text, errors))
						{
							resolvingResult.propertyResolvings.Add(repr, candidate);
						}
						break;
					default:
						{
							auto error
								= L"Precompile: Property \""
								+ propertyInfo.propertyName.ToString()
								+ L"\" of type \""
								+ propertyInfo.typeInfo.typeName.ToString()
								+ L"\" does not accept a value of text \""
								+ repr->text
								+ L"\" because its type \""
								+ td->GetTypeName()
								+ L"\" is not serializable.";
							errors.Add(error);
						}
					}
				}
			}

			void Visit(GuiAttSetterRepr* repr)override
			{
				if (candidatePropertyTypeInfos.Count() > 0)
				{
					resolvingResult.propertyResolvings.Add(repr, candidatePropertyTypeInfos[selectedPropertyTypeInfo]);
				}

				bool isReferenceType = (resolvedTypeInfo.typeDescriptor->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined;
				if (repr->instanceName == GlobalStringKey::Empty)
				{
					if (isReferenceType)
					{
						auto name = GlobalStringKey::Get(L"<precompile>" + itow(generatedNameCount++));
						repr->instanceName = name;
						resolvingResult.typeInfos.Add(name, resolvedTypeInfo);
					}
				}
				else if (resolvingResult.typeInfos.Keys().Contains(repr->instanceName))
				{
					errors.Add(L"Precompile: Referece name \"" + repr->instanceName.ToString() + L"\" conflict with an existing named object.");
				}
				else if (!isReferenceType)
				{
					errors.Add(L"Precompile: Reference name \"" + repr->instanceName.ToString() + L"\" cannot be added to a non-reference instance of type \"" + resolvedTypeInfo.typeName.ToString() + L"\".");
				}
				else
				{
					resolvingResult.referenceNames.Add(repr->instanceName);
					resolvingResult.typeInfos.Add(repr->instanceName, resolvedTypeInfo);
				}
			
				auto loader = GetInstanceLoaderManager()->GetLoader(resolvedTypeInfo.typeName);

				FOREACH_INDEXER(Ptr<GuiAttSetterRepr::SetterValue>, setter, index, repr->setters.Values())
				{
					List<types::PropertyResolving> possibleInfos;
					auto prop = repr->setters.Keys()[index];
					IGuiInstanceLoader::PropertyInfo propertyInfo(resolvedTypeInfo, prop);

					auto errorPrefix = L"Precompile: Property \"" + propertyInfo.propertyName.ToString() + L"\" of type \"" + resolvedTypeInfo.typeName.ToString() + L"\"";

					{
						auto currentLoader = loader;

						while (currentLoader)
						{
							if (auto propertyTypeInfo = currentLoader->GetPropertyType(propertyInfo))
							{
								if (propertyTypeInfo->support == GuiInstancePropertyInfo::NotSupport)
								{
									errors.Add(errorPrefix + L" is not supported.");
									break;
								}
								else
								{
									types::PropertyResolving resolving;
									resolving.loader = currentLoader;
									resolving.propertyInfo = propertyInfo;
									resolving.info = propertyTypeInfo;
									possibleInfos.Add(resolving);

									if (setter->binding == GlobalStringKey::_Set)
									{
										break;
									}
								}

								if (!propertyTypeInfo->tryParent)
								{
									break;
								}
							}
							currentLoader = GetInstanceLoaderManager()->GetParentLoader(currentLoader);
						}
					}

					if (possibleInfos.Count() == 0)
					{
						errors.Add(errorPrefix + L" does not exist.");
					}
					else
					{
						if (setter->binding == GlobalStringKey::Empty)
						{
							FOREACH(Ptr<GuiValueRepr>, value, setter->values)
							{
								WorkflowReferenceNamesVisitor visitor(context, resolvingResult, possibleInfos, generatedNameCount, errors);
								value->Accept(&visitor);
							}
						}
						else  if (setter->binding == GlobalStringKey::_Set)
						{
							if (possibleInfos[0].info->support == GuiInstancePropertyInfo::SupportSet)
							{
								auto setTarget = dynamic_cast<GuiAttSetterRepr*>(setter->values[0].Obj());

								WorkflowReferenceNamesVisitor visitor(context, resolvingResult, possibleInfos, generatedNameCount, errors);
								auto td = possibleInfos[0].info->acceptableTypes[0];
								visitor.selectedPropertyTypeInfo = 0;
								visitor.resolvedTypeInfo.typeDescriptor = td;
								visitor.resolvedTypeInfo.typeName = GlobalStringKey::Get(td->GetTypeName());
								setTarget->Accept(&visitor);

								if (auto propInfo = resolvedTypeInfo.typeDescriptor->GetPropertyByName(prop.ToString(), true))
								{
									auto propType = propInfo->GetReturn();
									if (propType->GetTypeDescriptor() == td)
									{
										resolvingResult.typeOverrides.Add(setTarget->instanceName, CopyTypeInfo(propInfo->GetReturn()));
									}
									else
									{
										switch (propType->GetDecorator())
										{
										case ITypeInfo::Nullable:
											{
												auto elementType = MakePtr<TypeDescriptorTypeInfo>(td, TypeInfoHint::Normal);
												auto decoratedType = MakePtr<NullableTypeInfo>(elementType);
												resolvingResult.typeOverrides.Add(setTarget->instanceName, decoratedType);
											}
											break;
										case ITypeInfo::RawPtr:
											{
												auto elementType = MakePtr<TypeDescriptorTypeInfo>(td, TypeInfoHint::Normal);
												auto decoratedType = MakePtr<RawPtrTypeInfo>(elementType);
												resolvingResult.typeOverrides.Add(setTarget->instanceName, decoratedType);
											}
											break;
										case ITypeInfo::SharedPtr:
											{
												auto elementType = MakePtr<TypeDescriptorTypeInfo>(td, TypeInfoHint::Normal);
												auto decoratedType = MakePtr<SharedPtrTypeInfo>(elementType);
												resolvingResult.typeOverrides.Add(setTarget->instanceName, decoratedType);
											}
											break;
										default:
											resolvingResult.typeOverrides.Add(setTarget->instanceName, CopyTypeInfo(propInfo->GetReturn()));
										}
									}
								}
							}
							else
							{
								errors.Add(errorPrefix + L" does not support the \"-set\" binding.");
							}
						}
						else if (setter->binding != GlobalStringKey::Empty)
						{
							auto binder = GetInstanceLoaderManager()->GetInstanceBinder(setter->binding);
							if (binder)
							{
								if (possibleInfos[0].info->scope == GuiInstancePropertyInfo::Constructor)
								{
									if (!possibleInfos[0].info->bindable)
									{
										errors.Add(errorPrefix + L" cannot be assigned using binding \"-" + setter->binding.ToString() + L"\". Because it is a non-bindable constructor argument.");
									}
									else if (!binder->ApplicableToConstructorArgument())
									{
										errors.Add(errorPrefix + L" cannot be assigned using binding \"-" + setter->binding.ToString() + L"\". Because it is a constructor argument, and this binding does not apply to any constructor argument.");
									}
								}
							}
							else
							{
								errors.Add(errorPrefix + L" cannot be assigned using an unexisting binding \"-" + setter->binding.ToString() + L"\".");
							}

							if (setter->values.Count() == 1 && setter->values[0].Cast<GuiTextRepr>())
							{
								resolvingResult.propertyResolvings.Add(setter->values[0].Obj(), possibleInfos[0]);
							}
							else
							{
								errors.Add(L"Precompile: Binder \"" + setter->binding.ToString() + L"\" requires the text value of property \"" + propertyInfo.propertyName.ToString() + L"\".");
							}
						}
					}
				}

				Group<GlobalStringKey, IGuiInstanceLoader*> properties;
				CopyFrom(
					properties,
					From(repr->setters)
						.SelectMany([=](Pair<GlobalStringKey, Ptr<GuiAttSetterRepr::SetterValue>> item)
						{
							return From(item.value->values)
								.Where([=](Ptr<GuiValueRepr> value)
								{
									return resolvingResult.propertyResolvings.Keys().Contains(value.Obj());
								})
								.Select([=](Ptr<GuiValueRepr> value)
								{
									auto loader = resolvingResult.propertyResolvings[value.Obj()].loader;
									return Pair<GlobalStringKey, IGuiInstanceLoader*>(item.key, loader);
								});
						})
						.Distinct()
					);

				if (context->instance.Obj() != repr)
				{
					List<GlobalStringKey> ctorProps;
					loader->GetConstructorParameters(resolvedTypeInfo, ctorProps);
					FOREACH(GlobalStringKey, prop, ctorProps)
					{
						auto info = loader->GetPropertyType(IGuiInstanceLoader::PropertyInfo(resolvedTypeInfo, prop));
						if (info->required && !properties.Contains(prop, loader))
						{
							errors.Add(L"Precompile: Missing constructor argument \"" + prop.ToString() + L"\" of type \"" + resolvedTypeInfo.typeName.ToString() + L"\".");
						}
					}
				}

				while (properties.Count() > 0)
				{
					auto prop = properties.Keys()[0];
					auto loader = properties.GetByIndex(0)[0];
					IGuiInstanceLoader::PropertyInfo propertyInfo(resolvedTypeInfo, prop);

					List<GlobalStringKey> pairProps;
					loader->GetPairedProperties(propertyInfo, pairProps);
					if (pairProps.Count() > 0)
					{
						List<GlobalStringKey> missingProps;
						FOREACH(GlobalStringKey, key, pairProps)
						{
							if (!properties.Contains(key, loader))
							{
								missingProps.Add(key);
							}
						}

						if (missingProps.Count() > 0)
						{
							WString error
								= L"Precompile: When you assign to property \""
								+ prop.ToString()
								+ L"\" of type \""
								+ resolvedTypeInfo.typeName.ToString()
								+ L"\", the following missing properties are required: ";
							FOREACH_INDEXER(GlobalStringKey, key, index, missingProps)
							{
								if (index > 0)error += L", ";
								error += L"\"" + key.ToString() + L"\"";
							}
							error += L".";
							errors.Add(error);
						}
						
						FOREACH(GlobalStringKey, key, pairProps)
						{
							properties.Remove(key, loader);
						}
					}
					else
					{
						properties.Remove(prop, loader);
					}
				}

				FOREACH(Ptr<GuiAttSetterRepr::EventValue>, handler, repr->eventHandlers.Values())
				{
					if (handler->binding != GlobalStringKey::Empty)
					{
						auto binder = GetInstanceLoaderManager()->GetInstanceEventBinder(handler->binding);
						if (!binder)
						{
							errors.Add(L"The appropriate IGuiInstanceEventBinder of binding \"-" + handler->binding.ToString() + L"\" cannot be found.");
						}
					}
				}
			}

			void Visit(GuiConstructorRepr* repr)override
			{
				bool found = false;

				if (repr == context->instance.Obj())
				{
					auto fullName = GlobalStringKey::Get(context->className);
					auto td = GetInstanceLoaderManager()->GetTypeDescriptorForType(fullName);
					if (td)
					{
						found = true;
						resolvedTypeInfo.typeName = fullName;
						resolvedTypeInfo.typeDescriptor = td;
					}
				}

				if (!found)
				{
					auto source = FindInstanceLoadingSource(context, repr);
					resolvedTypeInfo.typeName = source.typeName;
					resolvedTypeInfo.typeDescriptor = GetInstanceLoaderManager()->GetTypeDescriptorForType(source.typeName);
				}

				if (resolvedTypeInfo.typeDescriptor)
				{
					for (vint i = 0; i < candidatePropertyTypeInfos.Count(); i++)
					{
						const auto& tds = candidatePropertyTypeInfos[i].info->acceptableTypes;
						for (vint j = 0; j < tds.Count(); j++)
						{
							if (resolvedTypeInfo.typeDescriptor->CanConvertTo(tds[j]))
							{
								selectedPropertyTypeInfo = i;
								goto FINISH_MATCHING;
							}
						}
					}
				FINISH_MATCHING:

					if (selectedPropertyTypeInfo == -1 && candidatePropertyTypeInfos.Count() > 0)
					{
						auto propertyInfo = candidatePropertyTypeInfos[0].propertyInfo;
						auto error 
							= L"Precompile: Property \""
							+ propertyInfo.propertyName.ToString()
							+ L"\" of type \""
							+ propertyInfo.typeInfo.typeName.ToString()
							+ L"\" does not accept a value of type \""
							+ resolvedTypeInfo.typeName.ToString()
							+ L"\" because it only accepts value of the following types: ";
						
						for (vint i = 0; i < candidatePropertyTypeInfos.Count(); i++)
						{
							const auto& tds = candidatePropertyTypeInfos[i].info->acceptableTypes;
							for (vint j = 0; j < tds.Count(); j++)
							{
								if (i != 0 || j != 0)
								{
									error += L", ";
								}
								error += L"\"" + tds[j]->GetTypeName() + L"\"";
							}
						}

						error += L".";
						errors.Add(error);
					}
					else
					{
						if (repr->setters.Count() == 1 && repr->setters.Keys()[0]==GlobalStringKey::Empty)
						{
							auto setter = repr->setters.Values()[0];
							if (setter->values.Count() == 1)
							{
								if (auto text = setter->values[0].Cast<GuiTextRepr>())
								{
									if (candidatePropertyTypeInfos.Count() == 0)
									{
										errors.Add(L"Precompile: Type \"" + resolvedTypeInfo.typeName.ToString() + L"\" cannot be used to create an instance.");
									}
									else
									{
										Visit(text.Obj());
										auto index = resolvingResult.propertyResolvings.Keys().IndexOf(text.Obj());
										if (index != -1)
										{
											auto value = resolvingResult.propertyResolvings.Values()[index];
											resolvingResult.propertyResolvings.Remove(text.Obj());
											resolvingResult.propertyResolvings.Add(repr, value);
										}
									}
									return;
								}
							}
						}

						if (context->instance.Obj() != repr)
						{
							auto loader = GetInstanceLoaderManager()->GetLoader(resolvedTypeInfo.typeName);
							while (loader)
							{
								if (loader->CanCreate(resolvedTypeInfo))
								{
									break;
								}
								loader = GetInstanceLoaderManager()->GetParentLoader(loader);
							}
							if (loader)
							{
								if (repr == context->instance.Obj())
								{
									List<GlobalStringKey> propertyNames;
									loader->GetConstructorParameters(resolvedTypeInfo, propertyNames);
									if (propertyNames.Count() == 1)
									{
										if (propertyNames[0] != GlobalStringKey::_ControlTemplate)
										{
											errors.Add(L"Precompile: Type \"" + resolvedTypeInfo.typeName.ToString() + L"\" cannot be used to create a root instance, because its only constructor parameter is not for a the control template.");
										}
									}
									else if (propertyNames.Count() > 1)
									{
										errors.Add(L"Precompile: Type \"" + resolvedTypeInfo.typeName.ToString() + L"\" cannot be used to create a root instance, because it has more than one constructor parameters. A root instance type can only have one constructor parameter, which is for the control template.");
									}
								}
							}
							else
							{
								errors.Add(L"Precompile: Type \"" + resolvedTypeInfo.typeName.ToString() + L"\" cannot be used to create an instance.");
							}
						}
						Visit((GuiAttSetterRepr*)repr);
					}
				}
				else
				{
					errors.Add(
						L"Precompile: Failed to find type \"" +
						(repr->typeNamespace == GlobalStringKey::Empty
							? repr->typeName.ToString()
							: repr->typeNamespace.ToString() + L":" + repr->typeName.ToString()
							) +
						L"\".");
				}
			}
		};

		ITypeDescriptor* Workflow_CollectReferences(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, types::ErrorList& errors)
		{
			FOREACH(Ptr<GuiInstanceParameter>, parameter, context->parameters)
			{
				auto type = GetTypeDescriptor(parameter->className.ToString());
				if (!type)
				{
					errors.Add(L"Precompile: Cannot find type \"" + parameter->className.ToString() + L"\".");
				}
				else if (resolvingResult.typeInfos.Keys().Contains(parameter->name))
				{
					errors.Add(L"Precompile: Parameter \"" + parameter->name.ToString() + L"\" conflict with an existing named object.");
				}
				else
				{
					{
						IGuiInstanceLoader::TypeInfo typeInfo;
						typeInfo.typeDescriptor = type;
						typeInfo.typeName = GlobalStringKey::Get(type->GetTypeName());
						resolvingResult.typeInfos.Add(parameter->name, typeInfo);
					}
					{
						auto elementType = MakePtr<TypeDescriptorTypeInfo>(type, TypeInfoHint::Normal);
						auto pointerType = MakePtr<SharedPtrTypeInfo>(elementType);

						resolvingResult.typeOverrides.Add(parameter->name, pointerType);
					}
				}
			}
			
			List<types::PropertyResolving> infos;
			vint generatedNameCount = 0;
			WorkflowReferenceNamesVisitor visitor(context, resolvingResult, infos, generatedNameCount, errors);
			context->instance->Accept(&visitor);
			return visitor.resolvedTypeInfo.typeDescriptor;
		}
	}
}

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWGENERATEBINDINGS.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace workflow;
		using namespace collections;
		using namespace reflection::description;

/***********************************************************************
WorkflowGenerateBindingVisitor
***********************************************************************/

		class WorkflowGenerateBindingVisitor : public Object, public GuiValueRepr::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			types::ResolvingResult&				resolvingResult;
			description::ITypeDescriptor*		rootTypeDescriptor;
			Ptr<WfBlockStatement>				statements;
			types::ErrorList&					errors;
			
			WorkflowGenerateBindingVisitor(Ptr<GuiInstanceContext> _context, types::ResolvingResult& _resolvingResult, description::ITypeDescriptor* _rootTypeDescriptor, Ptr<WfBlockStatement> _statements, types::ErrorList& _errors)
				:context(_context)
				, resolvingResult(_resolvingResult)
				, rootTypeDescriptor(_rootTypeDescriptor)
				, errors(_errors)
				, statements(_statements)
			{
			}

			void Visit(GuiTextRepr* repr)override
			{
			}

			void Visit(GuiAttSetterRepr* repr)override
			{
				IGuiInstanceLoader::TypeInfo reprTypeInfo;
				if (repr->instanceName != GlobalStringKey::Empty)
				{
					reprTypeInfo = resolvingResult.typeInfos[repr->instanceName];
				}
				
				if (reprTypeInfo.typeDescriptor && (reprTypeInfo.typeDescriptor->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined)
				{
					FOREACH_INDEXER(Ptr<GuiAttSetterRepr::SetterValue>, setter, index, repr->setters.Values())
					{
						auto propertyName = repr->setters.Keys()[index];
						if (setter->binding != GlobalStringKey::Empty && setter->binding != GlobalStringKey::_Set)
						{
							if (auto binder = GetInstanceLoaderManager()->GetInstanceBinder(setter->binding))
							{
								auto propertyResolving = resolvingResult.propertyResolvings[setter->values[0].Obj()];
								if (propertyResolving.info->scope == GuiInstancePropertyInfo::Property)
								{
									WString expressionCode = setter->values[0].Cast<GuiTextRepr>()->text;
									auto instancePropertyInfo = reprTypeInfo.typeDescriptor->GetPropertyByName(propertyName.ToString(), true);

									if (instancePropertyInfo || !binder->RequirePropertyExist())
									{
										if (auto statement = binder->GenerateInstallStatement(repr->instanceName, instancePropertyInfo, propertyResolving.loader, propertyResolving.propertyInfo, propertyResolving.info, expressionCode, errors))
										{
											if (Workflow_ValidateStatement(context, resolvingResult, rootTypeDescriptor, errors, expressionCode, statement))
											{
												statements->statements.Add(statement);	
											}
										}
									}
									else
									{
										errors.Add(L"Precompile: Binder \"" + setter->binding.ToString() + L"\" requires property \"" + propertyName.ToString() + L"\" to physically appear in type \"" + reprTypeInfo.typeName.ToString() + L"\".");
									}
								}
							}
							else
							{
								errors.Add(L"Precompile: The appropriate IGuiInstanceBinder of binding \"-" + setter->binding.ToString() + L"\" cannot be found.");
							}
						}
						else
						{
							FOREACH(Ptr<GuiValueRepr>, value, setter->values)
							{
								value->Accept(this);
							}
						}
					}
				}

				FOREACH_INDEXER(Ptr<GuiAttSetterRepr::EventValue>, handler, index, repr->eventHandlers.Values())
				{
					if (reprTypeInfo.typeDescriptor)
					{
						GlobalStringKey propertyName = repr->eventHandlers.Keys()[index];
						auto td = reprTypeInfo.typeDescriptor;
						auto eventInfo = td->GetEventByName(propertyName.ToString(), true);

						if (!eventInfo)
						{
							errors.Add(L"Precompile: Event \"" + propertyName.ToString() + L"\" cannot be found in type \"" + reprTypeInfo.typeName.ToString() + L"\".");
						}
						else
						{
							Ptr<WfStatement> statement;

							if (handler->binding == GlobalStringKey::Empty)
							{
								statement = Workflow_InstallEvent(repr->instanceName, eventInfo, handler->value);
							}
							else
							{
								auto binder = GetInstanceLoaderManager()->GetInstanceEventBinder(handler->binding);
								if (binder)
								{
									statement = binder->GenerateInstallStatement(repr->instanceName, eventInfo, handler->value, errors);
								}
								else
								{
									errors.Add(L"The appropriate IGuiInstanceEventBinder of binding \"-" + handler->binding.ToString() + L"\" cannot be found.");
								}
							}

							if (statement)
							{
								if (Workflow_ValidateStatement(context, resolvingResult, rootTypeDescriptor, errors, handler->value, statement))
								{
									statements->statements.Add(statement);
								}
							}
						}
					}
				}
			}

			void Visit(GuiConstructorRepr* repr)override
			{
				Visit((GuiAttSetterRepr*)repr);
			}
		};

		void Workflow_GenerateBindings(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, Ptr<WfBlockStatement> statements, types::ErrorList& errors)
		{
			WorkflowGenerateBindingVisitor visitor(context, resolvingResult, rootTypeDescriptor, statements, errors);
			context->instance->Accept(&visitor);
		}
	}
}

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWGENERATECREATING.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace collections;
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace reflection::description;

/***********************************************************************
WorkflowGenerateCreatingVisitor
***********************************************************************/

		class WorkflowGenerateCreatingVisitor : public Object, public GuiValueRepr::IVisitor
		{
		public:
			Ptr<GuiInstanceContext>				context;
			types::ResolvingResult&				resolvingResult;
			description::ITypeDescriptor*		rootTypeDescriptor;
			Ptr<WfBlockStatement>				statements;
			types::ErrorList&					errors;
			
			WorkflowGenerateCreatingVisitor(Ptr<GuiInstanceContext> _context, types::ResolvingResult& _resolvingResult, description::ITypeDescriptor* _rootTypeDescriptor, Ptr<WfBlockStatement> _statements, types::ErrorList& _errors)
				:context(_context)
				, resolvingResult(_resolvingResult)
				, rootTypeDescriptor(_rootTypeDescriptor)
				, errors(_errors)
				, statements(_statements)
			{
			}

			IGuiInstanceLoader::ArgumentInfo GetArgumentInfo(GuiValueRepr* repr)
			{
				ITypeDescriptor* td = nullptr;
				bool serializable = false;
				WString textValue;
				GuiConstructorRepr* ctor = nullptr;

				if (auto text = dynamic_cast<GuiTextRepr*>(repr))
				{
					td = resolvingResult.propertyResolvings[repr].info->acceptableTypes[0];
					serializable = true;
					textValue = text->text;
				}
				else if ((ctor = dynamic_cast<GuiConstructorRepr*>(repr)))
				{
					if (ctor->instanceName == GlobalStringKey::Empty)
					{
						td = resolvingResult.propertyResolvings[repr].info->acceptableTypes[0];
					}
					else
					{
						td = resolvingResult.typeInfos[ctor->instanceName].typeDescriptor;
					}
					if ((td->GetTypeDescriptorFlags() & TypeDescriptorFlags::StructType) != TypeDescriptorFlags::Undefined)
					{
						serializable = true;
						textValue = ctor->setters.Values()[0]->values[0].Cast<GuiTextRepr>()->text;
					}
				}

				IGuiInstanceLoader::ArgumentInfo argumentInfo;
				argumentInfo.type = td;

				if (serializable)
				{
					argumentInfo.expression = Workflow_ParseTextValue(td, textValue, errors);

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = argumentInfo.expression;
					Workflow_ValidateStatement(context, resolvingResult, rootTypeDescriptor, errors, textValue, stat);
				}
				else
				{
					repr->Accept(this);

					auto ref = MakePtr<WfReferenceExpression>();
					ref->name.value = ctor->instanceName.ToString();
					argumentInfo.expression = ref;
				}

				return argumentInfo;
			}

			void Visit(GuiTextRepr* repr)override
			{
			}

			void Visit(GuiAttSetterRepr* repr)override
			{
				auto reprTypeInfo = resolvingResult.typeInfos[repr->instanceName];
				
				if (reprTypeInfo.typeDescriptor && (reprTypeInfo.typeDescriptor->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined)
				{
					Group<GlobalStringKey, IGuiInstanceLoader*> usedProps;
					FOREACH(GlobalStringKey, prop, From(repr->setters.Keys()).Reverse())
					{
						auto setter = repr->setters[prop];
						IGuiInstanceLoader::PropertyInfo propInfo(reprTypeInfo, prop);
						if (setter->binding == GlobalStringKey::_Set)
						{
							auto setTarget = dynamic_cast<GuiAttSetterRepr*>(setter->values[0].Obj());
							auto info = resolvingResult.propertyResolvings[setTarget];
							vint errorCount = errors.Count();
							if (auto expr = info.loader->GetParameter(propInfo, repr->instanceName, errors))
							{
								auto refInstance = MakePtr<WfReferenceExpression>();
								refInstance->name.value = setTarget->instanceName.ToString();

								auto assign = MakePtr<WfBinaryExpression>();
								assign->op = WfBinaryOperator::Assign;
								assign->first = refInstance;
								assign->second = expr;

								auto stat = MakePtr<WfExpressionStatement>();
								stat->expression = assign;

								statements->statements.Add(stat);
							}
							else if (errorCount == errors.Count())
							{
								errors.Add(L"Precompile: Something is wrong when retriving the property \"" + prop.ToString() + L"\" from an instance of type \"" + reprTypeInfo.typeName.ToString() + L"\".");
							}
							setTarget->Accept(this);
						}
						else if (setter->binding == GlobalStringKey::Empty)
						{
							FOREACH(Ptr<GuiValueRepr>, value, setter->values)
							{
								auto info = resolvingResult.propertyResolvings[value.Obj()];
								if (info.info->scope == GuiInstancePropertyInfo::Property)
								{
									if (info.info->support == GuiInstancePropertyInfo::SupportCollection)
									{
										if (!usedProps.Contains(prop, info.loader))
										{
											usedProps.Add(prop, info.loader);
										}

										vint errorCount = errors.Count();
										IGuiInstanceLoader::ArgumentMap arguments;
										arguments.Add(prop, GetArgumentInfo(value.Obj()));
										if (auto stat = info.loader->AssignParameters(reprTypeInfo, repr->instanceName, arguments, errors))
										{
											statements->statements.Add(stat);
										}
										else if (errorCount == errors.Count())
										{
											errors.Add(L"Precompile: Something is wrong when assigning to property " + prop.ToString() + L" to an instance of type \"" + reprTypeInfo.typeName.ToString() + L"\".");
										}
									}
									else if (!usedProps.Contains(prop, info.loader))
									{
										List<GlobalStringKey> pairedProps;
										info.loader->GetPairedProperties(propInfo, pairedProps);
										if (pairedProps.Count() == 0)
										{
											pairedProps.Add(prop);
										}

										IGuiInstanceLoader::ArgumentMap arguments;
										FOREACH(GlobalStringKey, pairedProp, pairedProps)
										{
											usedProps.Add(pairedProp, info.loader);
											auto pairedSetter = repr->setters[pairedProp];
											FOREACH(Ptr<GuiValueRepr>, pairedValue, pairedSetter->values)
											{
												auto pairedInfo = resolvingResult.propertyResolvings[pairedValue.Obj()];
												if (pairedInfo.loader == info.loader)
												{
													arguments.Add(pairedProp, GetArgumentInfo(pairedValue.Obj()));
												}
											}
										}

										vint errorCount = errors.Count();
										if (auto stat = info.loader->AssignParameters(reprTypeInfo, repr->instanceName, arguments, errors))
										{
											statements->statements.Add(stat);
										}
										else if (errorCount == errors.Count())
										{
											WString propNames;
											FOREACH_INDEXER(GlobalStringKey, pairedProp, propIndex, pairedProps)
											{
												if (propIndex > 0)propNames += L", ";
												propNames += L"\"" + pairedProp.ToString() + L"\"";
											}
											errors.Add(L"Precompile: Something is wrong when assigning to properties " + propNames + L" to an instance of type \"" + reprTypeInfo.typeName.ToString() + L"\".");
										}
									}
								}
							}
						}
					}
				}
			}

			void FillCtorArguments(GuiConstructorRepr* repr, IGuiInstanceLoader* loader, const IGuiInstanceLoader::TypeInfo& typeInfo, IGuiInstanceLoader::ArgumentMap& arguments)
			{
				List<GlobalStringKey> ctorProps;
				loader->GetConstructorParameters(typeInfo, ctorProps);
				FOREACH(GlobalStringKey, prop, ctorProps)
				{
					auto index = repr->setters.Keys().IndexOf(prop);
					if (index != -1)
					{
						auto setter = repr->setters.Values()[index];
						if (setter->binding == GlobalStringKey::Empty)
						{
							FOREACH(Ptr<GuiValueRepr>, value, setter->values)
							{
								auto argument = GetArgumentInfo(value.Obj());
								if (argument.type && argument.expression)
								{
									arguments.Add(prop, argument);
								}
							}
						}
						else if (auto binder = GetInstanceLoaderManager()->GetInstanceBinder(setter->binding))
						{
							auto propInfo = IGuiInstanceLoader::PropertyInfo(typeInfo, prop);
							auto resolvedPropInfo = loader->GetPropertyType(propInfo);
							auto value = setter->values[0].Cast<GuiTextRepr>();
							if (auto expression = binder->GenerateConstructorArgument(loader, propInfo, resolvedPropInfo, value->text, errors))
							{
								IGuiInstanceLoader::ArgumentInfo argument;
								argument.expression = expression;
								argument.type = resolvedPropInfo->acceptableTypes[0];
								arguments.Add(prop, argument);
							}
						}
						else
						{
							errors.Add(L"Precompile: The appropriate IGuiInstanceBinder of binding \"-" + setter->binding.ToString() + L"\" cannot be found.");
						}
					}
				}
			}

			void Visit(GuiConstructorRepr* repr)override
			{
				IGuiInstanceLoader::TypeInfo ctorTypeInfo;
				if (context->instance.Obj() == repr)
				{
					auto source = FindInstanceLoadingSource(context, repr);
					ctorTypeInfo.typeName = source.typeName;
					ctorTypeInfo.typeDescriptor = GetInstanceLoaderManager()->GetTypeDescriptorForType(source.typeName);
				}
				else
				{
					ctorTypeInfo = resolvingResult.typeInfos[repr->instanceName];
				}

				auto ctorLoader = GetInstanceLoaderManager()->GetLoader(ctorTypeInfo.typeName);
				while (ctorLoader)
				{
					if (ctorLoader->CanCreate(ctorTypeInfo))
					{
						break;
					}
					ctorLoader = GetInstanceLoaderManager()->GetParentLoader(ctorLoader);
				}

				if (context->instance.Obj() == repr)
				{
					resolvingResult.rootLoader = ctorLoader;
					resolvingResult.rootTypeInfo = ctorTypeInfo;
					FillCtorArguments(repr, ctorLoader, ctorTypeInfo, resolvingResult.rootCtorArguments);

					{
						auto refInstance = MakePtr<WfReferenceExpression>();
						refInstance->name.value = repr->instanceName.ToString();

						auto refThis = MakePtr<WfReferenceExpression>();
						refThis->name.value = L"<this>";

						auto assign = MakePtr<WfBinaryExpression>();
						assign->op = WfBinaryOperator::Assign;
						assign->first = refInstance;
						assign->second = refThis;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = assign;

						statements->statements.Add(stat);
					}
					FOREACH(Ptr<GuiInstanceParameter>, parameter, context->parameters)
					{
						auto refInstance = MakePtr<WfReferenceExpression>();
						refInstance->name.value = parameter->name.ToString();

						auto refThis = MakePtr<WfReferenceExpression>();
						refThis->name.value = L"<this>";

						auto refParameter = MakePtr<WfMemberExpression>();
						refParameter->parent = refThis;
						refParameter->name.value = parameter->name.ToString();

						auto assign = MakePtr<WfBinaryExpression>();
						assign->op = WfBinaryOperator::Assign;
						assign->first = refInstance;
						assign->second = refParameter;

						auto stat = MakePtr<WfExpressionStatement>();
						stat->expression = assign;

						statements->statements.Add(stat);
					}
				}
				else
				{
					IGuiInstanceLoader::ArgumentMap arguments;
					FillCtorArguments(repr, ctorLoader, ctorTypeInfo, arguments);

					vint errorCount = errors.Count();
					if (auto ctorStats = ctorLoader->CreateInstance(ctorTypeInfo, repr->instanceName, arguments, errors))
					{
						statements->statements.Add(ctorStats);
					}
					else if (errorCount == errors.Count())
					{
						errors.Add(L"Precompile: Something is wrong when creating an instance of type \"" + ctorTypeInfo.typeName.ToString() + L"\".");
					}
				}
				Visit((GuiAttSetterRepr*)repr);
			}
		};

		void Workflow_GenerateCreating(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, Ptr<WfBlockStatement> statements, types::ErrorList& errors)
		{
			WorkflowGenerateCreatingVisitor visitor(context, resolvingResult, rootTypeDescriptor, statements, errors);
			context->instance->Accept(&visitor);
		}
	}
}

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWINSTALLBINDINGS.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace reflection::description;
		using namespace collections;

		using namespace controls;
		using namespace compositions;

/***********************************************************************
Workflow_InstallBindProperty
***********************************************************************/

		Ptr<workflow::WfStatement> Workflow_InstallUriProperty(GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, const WString& protocol, const WString& path, collections::List<WString>& errors)
		{
			auto subBlock = MakePtr<WfBlockStatement>();
			{
				auto refResolver = MakePtr<WfReferenceExpression>();
				refResolver->name.value = L"<resolver>";

				auto member = MakePtr<WfMemberExpression>();
				member->parent = refResolver;
				member->name.value = L"ResolveResource";

				auto valueProtocol = MakePtr<WfStringExpression>();
				valueProtocol->value.value = protocol;

				auto valuePath = MakePtr<WfStringExpression>();
				valuePath->value.value = path;

				auto call = MakePtr<WfCallExpression>();
				call->function = member;
				call->arguments.Add(valueProtocol);
				call->arguments.Add(valuePath);

				auto varDesc = MakePtr<WfVariableDeclaration>();
				varDesc->name.value = L"<resource-item>";
				varDesc->expression = call;

				auto varStat = MakePtr<WfVariableStatement>();
				varStat->variable = varDesc;
				subBlock->statements.Add(varStat);
			}
			{
				auto refResourceItem = MakePtr<WfReferenceExpression>();
				refResourceItem->name.value = L"<resource-item>";

				auto isNull = MakePtr<WfTypeTestingExpression>();
				isNull->expression = refResourceItem;
				isNull->test = WfTypeTesting::IsNull;

				auto valueException = MakePtr<WfStringExpression>();
				valueException->value.value = L"Resource \"" + protocol + L"://" + path + L"\" does not exist.";

				auto raiseStat = MakePtr<WfRaiseExceptionStatement>();
				raiseStat->expression = valueException;
				
				auto ifBlock = MakePtr<WfBlockStatement>();
				ifBlock->statements.Add(raiseStat);

				auto ifStat = MakePtr<WfIfStatement>();
				ifStat->expression = isNull;
				ifStat->trueBranch = ifBlock;
				subBlock->statements.Add(ifStat);
			}

			auto td = propInfo->acceptableTypes[0];
			Ptr<ITypeInfo> convertedType;
			if (td->GetSerializableType())
			{
				convertedType = TypeInfoRetriver<Ptr<GuiTextData>>::CreateTypeInfo();
			}
			else if (td == description::GetTypeDescriptor<INativeImage>() || td == description::GetTypeDescriptor<GuiImageData>())
			{
				convertedType = TypeInfoRetriver<Ptr<GuiImageData>>::CreateTypeInfo();
			}
			else
			{
				auto elementType = MakePtr<TypeDescriptorTypeInfo>(td, TypeInfoHint::Normal);
				auto pointerType = MakePtr<SharedPtrTypeInfo>(elementType);
				convertedType = pointerType;
			}

			{
				auto refResourceItem = MakePtr<WfReferenceExpression>();
				refResourceItem->name.value = L"<resource-item>";

				auto cast = MakePtr<WfTypeCastingExpression>();
				cast->expression = refResourceItem;
				cast->type = GetTypeFromTypeInfo(convertedType.Obj());
				cast->strategy = WfTypeCastingStrategy::Weak;

				auto varDesc = MakePtr<WfVariableDeclaration>();
				varDesc->name.value = L"<resource-value>";
				varDesc->expression = cast;

				auto varStat = MakePtr<WfVariableStatement>();
				varStat->variable = varDesc;
				subBlock->statements.Add(varStat);
			}
			{
				auto refResourceValue = MakePtr<WfReferenceExpression>();
				refResourceValue->name.value = L"<resource-value>";

				auto isNull = MakePtr<WfTypeTestingExpression>();
				isNull->expression = refResourceValue;
				isNull->test = WfTypeTesting::IsNull;

				auto valueException = MakePtr<WfStringExpression>();
				valueException->value.value = L"Resource \"" + protocol + L"://" + path + L"\" cannot be read as type \"" + convertedType->GetTypeDescriptor()->GetTypeName() + L"\".";

				auto raiseStat = MakePtr<WfRaiseExceptionStatement>();
				raiseStat->expression = valueException;

				auto ifBlock = MakePtr<WfBlockStatement>();
				ifBlock->statements.Add(raiseStat);

				auto ifStat = MakePtr<WfIfStatement>();
				ifStat->expression = isNull;
				ifStat->trueBranch = ifBlock;
				subBlock->statements.Add(ifStat);
			}

			Ptr<WfExpression> evalExpression;
			if (td->GetSerializableType())
			{
				auto refResourceValue = MakePtr<WfReferenceExpression>();
				refResourceValue->name.value = L"<resource-value>";

				auto member = MakePtr<WfMemberExpression>();
				member->parent = refResourceValue;
				member->name.value = L"Text";

				auto elementType = MakePtr<TypeDescriptorTypeInfo>(td, TypeInfoHint::Normal);

				auto cast = MakePtr<WfTypeCastingExpression>();
				cast->expression = member;
				cast->type = GetTypeFromTypeInfo(elementType.Obj());
				cast->strategy = WfTypeCastingStrategy::Strong;

				evalExpression = cast;
			}
			else if (td == description::GetTypeDescriptor<INativeImage>())
			{
				auto refResourceValue = MakePtr<WfReferenceExpression>();
				refResourceValue->name.value = L"<resource-value>";

				auto member = MakePtr<WfMemberExpression>();
				member->parent = refResourceValue;
				member->name.value = L"Image";

				evalExpression = member;
			}
			else
			{
				auto refResourceValue = MakePtr<WfReferenceExpression>();
				refResourceValue->name.value = L"<resource-value>";

				evalExpression = refResourceValue;
			}

			{
				IGuiInstanceLoader::ArgumentMap arguments;
				{
					IGuiInstanceLoader::ArgumentInfo argumentInfo;
					argumentInfo.type = td;
					argumentInfo.expression = evalExpression;
					arguments.Add(prop.propertyName, argumentInfo);
				}

				if (auto stat = loader->AssignParameters(prop.typeInfo, variableName, arguments, errors))
				{
					subBlock->statements.Add(stat);
				}
			}
			return subBlock;
		}

/***********************************************************************
Workflow_InstallBindProperty
***********************************************************************/

		Ptr<workflow::WfStatement> Workflow_InstallBindProperty(GlobalStringKey variableName, description::IPropertyInfo* propertyInfo, Ptr<workflow::WfExpression> bindExpression)
		{
			auto subBlock = MakePtr<WfBlockStatement>();
			{
				auto refThis = MakePtr<WfReferenceExpression>();
				refThis->name.value = L"<this>";

				auto member = MakePtr<WfMemberExpression>();
				member->parent = refThis;
				member->name.value = L"AddSubscription";

				auto call = MakePtr<WfCallExpression>();
				call->function = member;
				call->arguments.Add(bindExpression);

				auto var = MakePtr<WfVariableDeclaration>();
				var->name.value = L"<created-subscription>";
				var->expression = call;

				auto stat = MakePtr<WfVariableStatement>();
				stat->variable = var;
				subBlock->statements.Add(stat);
			}
			{
				auto callback = MakePtr<WfFunctionDeclaration>();
				callback->anonymity = WfFunctionAnonymity::Anonymous;
				callback->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());;
				{
					auto arg = MakePtr<WfFunctionArgument>();
					arg->name.value = L"<value>";
					arg->type = GetTypeFromTypeInfo(TypeInfoRetriver<Value>::CreateTypeInfo().Obj());
					callback->arguments.Add(arg);
				}
				auto callbackBlock = MakePtr<WfBlockStatement>();
				callback->statement = callbackBlock;
				{
					auto refSubscribee = MakePtr<WfReferenceExpression>();
					refSubscribee->name.value = variableName.ToString();

					auto member = MakePtr<WfMemberExpression>();
					member->parent = refSubscribee;
					member->name.value = propertyInfo->GetName();

					auto var = MakePtr<WfVariableDeclaration>();
					var->name.value = L"<old>";
					var->expression = member;

					auto stat = MakePtr<WfVariableStatement>();
					stat->variable = var;
					callbackBlock->statements.Add(stat);
				}
				{
					ITypeInfo* propertyType = propertyInfo->GetReturn();
					if (propertyInfo->GetSetter() && propertyInfo->GetSetter()->GetParameterCount() == 1)
					{
						propertyType = propertyInfo->GetSetter()->GetParameter(0)->GetType();
					}

					auto refValue = MakePtr<WfReferenceExpression>();
					refValue->name.value = L"<value>";

					auto cast = MakePtr<WfTypeCastingExpression>();
					cast->strategy = WfTypeCastingStrategy::Strong;
					cast->expression = refValue;
					cast->type = GetTypeFromTypeInfo(propertyType);

					auto var = MakePtr<WfVariableDeclaration>();
					var->name.value = L"<new>";
					var->expression = cast;

					auto stat = MakePtr<WfVariableStatement>();
					stat->variable = var;
					callbackBlock->statements.Add(stat);
				}
				{
					auto refOld = MakePtr<WfReferenceExpression>();
					refOld->name.value = L"<old>";

					auto refNew = MakePtr<WfReferenceExpression>();
					refNew->name.value = L"<new>";

					auto compare = MakePtr<WfBinaryExpression>();
					compare->op = WfBinaryOperator::EQ;
					compare->first = refOld;
					compare->second = refNew;

					auto ifStat = MakePtr<WfIfStatement>();
					ifStat->expression = compare;
					callbackBlock->statements.Add(ifStat);

					auto ifBlock = MakePtr<WfBlockStatement>();
					ifStat->trueBranch = ifBlock;

					auto returnStat = MakePtr<WfReturnStatement>();
					ifBlock->statements.Add(returnStat);
				}
				{
					auto refSubscribee = MakePtr<WfReferenceExpression>();
					refSubscribee->name.value = variableName.ToString();

					auto member = MakePtr<WfMemberExpression>();
					member->parent = refSubscribee;
					member->name.value = propertyInfo->GetName();

					auto refNew = MakePtr<WfReferenceExpression>();
					refNew->name.value = L"<new>";

					auto assign = MakePtr<WfBinaryExpression>();
					assign->op = WfBinaryOperator::Assign;
					assign->first = member;
					assign->second = refNew;

					auto stat = MakePtr<WfExpressionStatement>();
					stat->expression = assign;
					callbackBlock->statements.Add(stat);
				}

				auto funcExpr = MakePtr<WfFunctionExpression>();
				funcExpr->function = callback;

				auto refThis = MakePtr<WfReferenceExpression>();
				refThis->name.value = L"<created-subscription>";

				auto member = MakePtr<WfMemberExpression>();
				member->parent = refThis;
				member->name.value = L"Subscribe";

				auto call = MakePtr<WfCallExpression>();
				call->function = member;
				call->arguments.Add(funcExpr);

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = call;
				subBlock->statements.Add(stat);
			}
			{
				auto refThis = MakePtr<WfReferenceExpression>();
				refThis->name.value = L"<created-subscription>";

				auto member = MakePtr<WfMemberExpression>();
				member->parent = refThis;
				member->name.value = L"Update";

				auto call = MakePtr<WfCallExpression>();
				call->function = member;

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = call;
				subBlock->statements.Add(stat);
			}

			return subBlock;
		}

/***********************************************************************
Workflow_InstallEvalProperty
***********************************************************************/

		Ptr<workflow::WfStatement> Workflow_InstallEvalProperty(GlobalStringKey variableName, IGuiInstanceLoader* loader, const IGuiInstanceLoader::PropertyInfo& prop, Ptr<GuiInstancePropertyInfo> propInfo, Ptr<workflow::WfExpression> evalExpression, collections::List<WString>& errors)
		{
			IGuiInstanceLoader::ArgumentMap arguments;
			{
				IGuiInstanceLoader::ArgumentInfo argumentInfo;
				argumentInfo.type = propInfo->acceptableTypes[0];
				argumentInfo.expression = evalExpression;
				arguments.Add(prop.propertyName, argumentInfo);
			}

			return loader->AssignParameters(prop.typeInfo, variableName, arguments, errors);
		}

/***********************************************************************
Workflow_InstallEvent
***********************************************************************/

		Ptr<workflow::WfStatement> Workflow_InstallEvent(GlobalStringKey variableName, description::IEventInfo* eventInfo, const WString& handlerName)
		{
			vint count = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgumentCount() - 1;

			auto subBlock = MakePtr<WfBlockStatement>();
			{
				auto var = MakePtr<WfReferenceExpression>();
				var->name.value = variableName.ToString();

				auto member = MakePtr<WfMemberExpression>();
				member->parent = var;
				member->name.value = eventInfo->GetName();

				auto refThis = MakePtr<WfReferenceExpression>();
				refThis->name.value = L"<this>";

				auto handler = MakePtr<WfMemberExpression>();
				handler->parent = refThis;
				handler->name.value = handlerName;

				auto call = MakePtr<WfCallExpression>();
				call->function = handler;
				for (vint i = 0; i < count; i++)
				{
					auto argument = MakePtr<WfOrderedNameExpression>();
					argument->name.value = L"$" + itow(i + 1);
					call->arguments.Add(argument);
				}

				auto eventHandler = MakePtr<WfOrderedLambdaExpression>();
				eventHandler->body = call;

				auto attachEvent = MakePtr<WfAttachEventExpression>();
				attachEvent->event = member;
				attachEvent->function = eventHandler;

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = attachEvent;
				subBlock->statements.Add(stat);
			}

			return subBlock;
		}

/***********************************************************************
Workflow_GenerateEventHandler
***********************************************************************/

		Ptr<workflow::WfFunctionDeclaration> Workflow_GenerateEventHandler(description::IEventInfo* eventInfo)
		{
			auto func = MakePtr<WfFunctionDeclaration>();
			func->anonymity = WfFunctionAnonymity::Anonymous;
			func->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());

			vint count = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgumentCount() - 1;
			bool standardName = false;
			if (count == 2)
			{
				auto senderType = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(1)->GetTypeDescriptor();
				auto argumentType = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(2)->GetTypeDescriptor();
				if (senderType == GetTypeDescriptor<GuiGraphicsComposition>())
				{
					auto expectedType = GetTypeDescriptor<GuiEventArgs>();
					List<ITypeDescriptor*> types;
					types.Add(argumentType);
					for (vint i = 0; i < types.Count(); i++)
					{
						auto type = types[i];
						if (type == expectedType)
						{
							standardName = true;
							break;
						}
						vint baseCount = type->GetBaseTypeDescriptorCount();
						for (vint j = 0; j < baseCount; j++)
						{
							auto baseType = type->GetBaseTypeDescriptor(j);
							if (!types.Contains(baseType))
							{
								types.Add(baseType);
							}
						}
					}
				}
			}

			if (standardName)
			{
				{
					auto arg = MakePtr<WfFunctionArgument>();
					arg->name.value = L"sender";
					arg->type = GetTypeFromTypeInfo(eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(1));
					func->arguments.Add(arg);
				}
				{
					auto arg = MakePtr<WfFunctionArgument>();
					arg->name.value = L"arguments";
					arg->type = GetTypeFromTypeInfo(eventInfo->GetHandlerType()->GetElementType()->GetGenericArgument(2));
					func->arguments.Add(arg);
				}
			}
			else
			{
				auto type = TypeInfoRetriver<Value>::CreateTypeInfo();
				for (vint i = 0; i < count; i++)
				{
					auto arg = MakePtr<WfFunctionArgument>();
					arg->name.value = L"<argument>" + itow(i + 1);
					arg->type = GetTypeFromTypeInfo(type.Obj());
					func->arguments.Add(arg);
				}
			}

			return func;
		}

/***********************************************************************
Workflow_InstallEvalEvent
***********************************************************************/

		Ptr<workflow::WfStatement> Workflow_InstallEvalEvent(GlobalStringKey variableName, description::IEventInfo* eventInfo, Ptr<workflow::WfStatement> evalStatement)
		{
			auto func = Workflow_GenerateEventHandler(eventInfo);
						
			auto funcBlock = MakePtr<WfBlockStatement>();
			funcBlock->statements.Add(evalStatement);
			func->statement = funcBlock;

			auto subBlock = MakePtr<WfBlockStatement>();

			{
				auto eventHandlerLambda = MakePtr<WfFunctionExpression>();
				eventHandlerLambda->function = func;

				auto eventHandler = MakePtr<WfVariableDeclaration>();
				eventHandler->name.value = L"<event-handler>";
				eventHandler->expression = eventHandlerLambda;

				auto stat = MakePtr<WfVariableStatement>();
				stat->variable = eventHandler;
				subBlock->statements.Add(stat);
			}
			{
				auto var = MakePtr<WfReferenceExpression>();
				var->name.value = variableName.ToString();

				auto member = MakePtr<WfMemberExpression>();
				member->parent = var;
				member->name.value = eventInfo->GetName();

				auto eventHandler = MakePtr<WfReferenceExpression>();
				eventHandler->name.value = L"<event-handler>";

				auto attachEvent = MakePtr<WfAttachEventExpression>();
				attachEvent->event = member;
				attachEvent->function = eventHandler;

				auto stat = MakePtr<WfExpressionStatement>();
				stat->expression = attachEvent;
				subBlock->statements.Add(stat);
			}

			return subBlock;
		}
	}
}

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWMODULE.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace workflow;
		using namespace workflow::analyzer;
		using namespace reflection::description;
		using namespace collections;

/***********************************************************************
Workflow_CreateModuleWithUsings
***********************************************************************/

		Ptr<workflow::WfModule> Workflow_CreateModuleWithUsings(Ptr<GuiInstanceContext> context)
		{
			auto module = MakePtr<WfModule>();
			module->name.value = L"<auto-generated>";

			vint index = context->namespaces.Keys().IndexOf(GlobalStringKey());
			if (index != -1)
			{
				auto nss = context->namespaces.Values()[index];
				FOREACH(Ptr<GuiInstanceNamespace>, ns, nss->namespaces)
				{
					auto path = MakePtr<WfModuleUsingPath>();
					module->paths.Add(path);

					auto pathCode = ns->prefix + L"*" + ns->postfix;
					auto reading = pathCode.Buffer();
					while (reading)
					{
						auto delimiter = wcsstr(reading, L"::");
						auto begin = reading;
						auto end = delimiter ? delimiter : begin + wcslen(reading);

						auto wildcard = wcschr(reading, L'*');
						if (wildcard >= end)
						{
							wildcard = nullptr;
						}

						auto item = MakePtr<WfModuleUsingItem>();
						path->items.Add(item);
						if (wildcard)
						{
							if (begin < wildcard)
							{
								auto fragment = MakePtr<WfModuleUsingNameFragment>();
								item->fragments.Add(fragment);
								fragment->name.value = WString(begin, vint(wildcard - begin));
							}
							{
								auto fragment = MakePtr<WfModuleUsingWildCardFragment>();
								item->fragments.Add(fragment);
							}
							if (wildcard + 1 < end)
							{
								auto fragment = MakePtr<WfModuleUsingNameFragment>();
								item->fragments.Add(fragment);
								fragment->name.value = WString(wildcard + 1, vint(end - wildcard - 1));
							}
						}
						else if (begin < end)
						{
							auto fragment = MakePtr<WfModuleUsingNameFragment>();
							item->fragments.Add(fragment);
							fragment->name.value = WString(begin, vint(end - begin));
						}

						if (delimiter)
						{
							reading = delimiter + 2;
						}
						else
						{
							reading = nullptr;
						}
					}
				}
			}
			return module;
		}

/***********************************************************************
Workflow_InstallClass
***********************************************************************/

		Ptr<workflow::WfClassDeclaration> Workflow_InstallClass(const WString& className, Ptr<workflow::WfModule> module)
		{
			auto decls = &module->declarations;
			auto reading = className.Buffer();
			while (true)
			{
				auto delimiter = wcsstr(reading, L"::");
				if (delimiter)
				{
					auto ns = MakePtr<WfNamespaceDeclaration>();
					ns->name.value = WString(reading, delimiter - reading);
					decls->Add(ns);
					decls = &ns->declarations;
				}
				else
				{
					auto ctorClass = MakePtr<WfClassDeclaration>();
					ctorClass->kind = WfClassKind::Class;
					ctorClass->constructorType = WfConstructorType::Undefined;
					ctorClass->name.value = reading;
					decls->Add(ctorClass);
					return ctorClass;
				}
				reading = delimiter + 2;
			}
		}

/***********************************************************************
Workflow_InstallCtorClass
***********************************************************************/
		
		Ptr<workflow::WfBlockStatement> Workflow_InstallCtorClass(Ptr<GuiInstanceContext> context, types::ResolvingResult& resolvingResult, description::ITypeDescriptor* rootTypeDescriptor, Ptr<workflow::WfModule> module)
		{
			auto ctorClass = Workflow_InstallClass(context->className + L"<Ctor>", module);
			Workflow_CreateVariablesForReferenceValues(ctorClass, resolvingResult);

			auto thisParam = MakePtr<WfFunctionArgument>();
			thisParam->name.value = L"<this>";
			{
				auto elementType = MakePtr<TypeDescriptorTypeInfo>(rootTypeDescriptor, TypeInfoHint::Normal);
				auto pointerType = MakePtr<RawPtrTypeInfo>(elementType);

				thisParam->type = GetTypeFromTypeInfo(pointerType.Obj());
			}

			auto resolverParam = MakePtr<WfFunctionArgument>();
			resolverParam->name.value = L"<resolver>";
			{
				auto elementType = MakePtr<TypeDescriptorTypeInfo>(description::GetTypeDescriptor<GuiResourcePathResolver>(), TypeInfoHint::Normal);
				auto pointerType = MakePtr<RawPtrTypeInfo>(elementType);

				resolverParam->type = GetTypeFromTypeInfo(pointerType.Obj());
			}

			auto block = MakePtr<WfBlockStatement>();

			auto func = MakePtr<WfFunctionDeclaration>();
			func->anonymity = WfFunctionAnonymity::Named;
			func->name.value = L"<initialize-instance>";
			func->arguments.Add(thisParam);
			func->arguments.Add(resolverParam);
			func->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());
			func->statement = block;

			auto member = MakePtr<WfClassMember>();
			member->kind = WfClassMemberKind::Normal;
			member->declaration = func;
			ctorClass->members.Add(member);

			return block;
		}

/***********************************************************************
Variable
***********************************************************************/

		void Workflow_CreatePointerVariable(Ptr<workflow::WfClassDeclaration> ctorClass, GlobalStringKey name, description::ITypeDescriptor* type, description::ITypeInfo* typeOverride)
		{
			auto var = MakePtr<WfVariableDeclaration>();
			var->name.value = name.ToString();

			if (typeOverride)
			{
				var->type = GetTypeFromTypeInfo(typeOverride);
			}

			if (!var->type)
			{
				if (auto ctors = type->GetConstructorGroup())
				{
					if (ctors->GetMethodCount() > 0)
					{
						auto ctor = ctors->GetMethod(0);
						var->type = GetTypeFromTypeInfo(ctor->GetReturn());
					}
				}
			}

			if (!var->type)
			{
				auto elementType = MakePtr<TypeDescriptorTypeInfo>(type, TypeInfoHint::Normal);
				auto pointerType = MakePtr<RawPtrTypeInfo>(elementType);

				var->type = GetTypeFromTypeInfo(pointerType.Obj());
			}

			auto literal = MakePtr<WfLiteralExpression>();
			literal->value = WfLiteralValue::Null;
			var->expression = literal;

			auto member = MakePtr<WfClassMember>();
			member->kind = WfClassMemberKind::Normal;
			member->declaration = var;

			ctorClass->members.Add(member);
		}
		
		void Workflow_CreateVariablesForReferenceValues(Ptr<workflow::WfClassDeclaration> ctorClass, types::ResolvingResult& resolvingResult)
		{
			const auto& typeInfos = resolvingResult.typeInfos;
			for (vint i = 0; i < typeInfos.Count(); i++)
			{
				auto key = typeInfos.Keys()[i];
				auto value = typeInfos.Values()[i].typeDescriptor;

				ITypeInfo* typeOverride = nullptr;
				vint index = resolvingResult.typeOverrides.Keys().IndexOf(key);
				if (index != -1)
				{
					typeOverride = resolvingResult.typeOverrides.Values()[index].Obj();
				}
				Workflow_CreatePointerVariable(ctorClass, key, value, typeOverride);
			}
		}
	}
}

/***********************************************************************
WORKFLOWCODEGEN\GUIINSTANCELOADER_WORKFLOWPARSER.CPP
***********************************************************************/

namespace vl
{
	namespace presentation
	{
		using namespace reflection::description;
		using namespace workflow;
		using namespace workflow::analyzer;

/***********************************************************************
Parser
***********************************************************************/

		Ptr<workflow::WfExpression> Workflow_ParseExpression(const WString& code, types::ErrorList& errors)
		{
			auto parser = GetParserManager()->GetParser<WfExpression>(L"WORKFLOW-EXPRESSION");
			return parser->TypedParse(code, errors);
		}

		Ptr<workflow::WfStatement> Workflow_ParseStatement(const WString& code, types::ErrorList& errors)
		{
			auto parser = GetParserManager()->GetParser<WfStatement>(L"WORKFLOW-STATEMENT");
			return parser->TypedParse(code, errors);
		}

/***********************************************************************
Workflow_ModuleToString
***********************************************************************/

		WString Workflow_ModuleToString(Ptr<workflow::WfModule> module)
		{
			stream::MemoryStream stream;
			{
				stream::StreamWriter writer(stream);
				WfPrint(module, L"", writer);
			}
			stream.SeekFromBegin(0);
			stream::StreamReader reader(stream);
			return reader.ReadToEnd();
		}

/***********************************************************************
Converter
***********************************************************************/

		Ptr<workflow::WfExpression> Workflow_ParseTextValue(description::ITypeDescriptor* typeDescriptor, const WString& textValue, types::ErrorList& errors)
		{
			if (typeDescriptor == description::GetTypeDescriptor<WString>())
			{
				auto str = MakePtr<WfStringExpression>();
				str->value.value = textValue;
				return str;
			}
			else if (typeDescriptor->GetSerializableType())
			{
				auto str = MakePtr<WfStringExpression>();
				str->value.value = textValue;

				auto type = MakePtr<TypeDescriptorTypeInfo>(typeDescriptor, TypeInfoHint::Normal);

				auto cast = MakePtr<WfTypeCastingExpression>();
				cast->type = GetTypeFromTypeInfo(type.Obj());
				cast->strategy = WfTypeCastingStrategy::Strong;
				cast->expression = str;

				return cast;
			}
			else if (typeDescriptor->GetTypeDescriptorFlags() == TypeDescriptorFlags::Struct)
			{
				auto valueExpr = Workflow_ParseExpression(L"{" + textValue + L"}", errors);
				auto type = MakePtr<TypeDescriptorTypeInfo>(typeDescriptor, TypeInfoHint::Normal);

				auto infer = MakePtr<WfInferExpression>();
				infer->type = GetTypeFromTypeInfo(type.Obj());
				infer->expression = valueExpr;

				return infer;
			}
			else if ((typeDescriptor->GetTypeDescriptorFlags() & TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
			{
				auto valueExpr = Workflow_ParseExpression(L"(" + textValue + L")", errors);
				auto type = MakePtr<TypeDescriptorTypeInfo>(typeDescriptor, TypeInfoHint::Normal);

				auto infer = MakePtr<WfInferExpression>();
				infer->type = GetTypeFromTypeInfo(type.Obj());
				infer->expression = valueExpr;

				return infer;
			}
			else
			{
				CHECK_FAIL(L"vl::presentation::Workflow_ParseTextValue(ITypeDescriptor*, const WString&, types::ErrorList&)#This is not a value type.");
			}
		}

		Ptr<workflow::WfExpression> Workflow_CreateValue(const description::Value& value, types::ErrorList& errors)
		{
			auto typeDescriptor = value.GetTypeDescriptor();
			if (typeDescriptor == nullptr)
			{
				auto nullExpr = MakePtr<WfLiteralExpression>();
				nullExpr->value = WfLiteralValue::Null;
				return nullExpr;
			}
			else if (typeDescriptor == description::GetTypeDescriptor<WString>())
			{
				auto str = MakePtr<WfStringExpression>();
				str->value.value = UnboxValue<WString>(value);
				return str;
			}
			else if (auto st = typeDescriptor->GetSerializableType())
			{
				auto str = MakePtr<WfStringExpression>();
				st->Serialize(value, str->value.value);

				auto type = MakePtr<TypeDescriptorTypeInfo>(typeDescriptor, TypeInfoHint::Normal);

				auto cast = MakePtr<WfTypeCastingExpression>();
				cast->type = GetTypeFromTypeInfo(type.Obj());
				cast->strategy = WfTypeCastingStrategy::Strong;
				cast->expression = str;

				return cast;
			}
			else if (typeDescriptor->GetTypeDescriptorFlags() == TypeDescriptorFlags::Struct)
			{
				auto ctorExpr = MakePtr<WfConstructorExpression>();
				vint count = typeDescriptor->GetPropertyCount();
				for (vint i = 0; i < count; i++)
				{
					auto prop = typeDescriptor->GetProperty(i);

					auto keyExpr = MakePtr<WfReferenceExpression>();
					keyExpr->name.value = prop->GetName();

					auto argument = MakePtr<WfConstructorArgument>();
					argument->key = keyExpr;
					argument->value = Workflow_CreateValue(prop->GetValue(value), errors);

					ctorExpr->arguments.Add(argument);
				}

				auto type = MakePtr<TypeDescriptorTypeInfo>(typeDescriptor, TypeInfoHint::Normal);

				auto infer = MakePtr<WfInferExpression>();
				infer->type = GetTypeFromTypeInfo(type.Obj());
				infer->expression = ctorExpr;

				return infer;
			}
			else if ((typeDescriptor->GetTypeDescriptorFlags() & TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
			{
				auto valueExpr = MakePtr<WfIntegerExpression>();
				valueExpr->value.value = u64tow(typeDescriptor->GetEnumType()->FromEnum(value));

				auto type = MakePtr<TypeDescriptorTypeInfo>(typeDescriptor, TypeInfoHint::Normal);

				auto cast = MakePtr<WfTypeCastingExpression>();
				cast->type = GetTypeFromTypeInfo(type.Obj());
				cast->strategy = WfTypeCastingStrategy::Strong;
				cast->expression = valueExpr;

				return cast;
			}
			else
			{
				CHECK_FAIL(L"vl::presentation::Workflow_ParseTextValue(ITypeDescriptor*, const WString&, types::ErrorList&)#This is not a value type.");
			}
		}
	}
}
