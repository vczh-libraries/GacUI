/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "GacUI.h"
#include "Vlpp.h"
#include "VlppWorkflowLibrary.h"

/***********************************************************************
.\GRAPHICSELEMENT\WINDOWSDIRECT2D\GUIGRAPHICSWINDOWSDIRECT2D.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSDIRECT2D
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSDIRECT2D

#include <d2d1_1.h>
#include <dwrite_1.h>
#include <d2d1effects.h>
#include <wincodec.h>

namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			
/***********************************************************************
Raw API Rendering Element
***********************************************************************/

			class GuiDirect2DElement;
			
			/// <summary>Direct2D Rendering event arguments.</summary>
			struct GuiDirect2DElementEventArgs : compositions::GuiEventArgs
			{
			public:
				/// <summary>The element that raised this event.</summary>
				GuiDirect2DElement*				element;
				/// <summary>Direct2D render target object.</summary>
				ID2D1RenderTarget*				rt;
				/// <summary>DirectWrite factory object.</summary>
				IDWriteFactory*					factoryDWrite;
				/// <summary>Direct2D factory object.</summary>
				ID2D1Factory*					factoryD2D;
				/// <summary>The range for rendering.</summary>
				Rect							bounds;

				GuiDirect2DElementEventArgs(GuiDirect2DElement* _element, ID2D1RenderTarget* _rt, IDWriteFactory* _fdw, ID2D1Factory* _fd2d, Rect _bounds)
					:element(_element)
					,rt(_rt)
					,factoryDWrite(_fdw)
					,factoryD2D(_fd2d)
					,bounds(_bounds)
				{
				}
			};

			/// <summary>
			/// Defines an element for customized rendering using Direct2D.
			/// </summary>
			class GuiDirect2DElement : public GuiElementBase<GuiDirect2DElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiDirect2DElement, L"Direct2DElement")
			protected:
				GuiDirect2DElement();
			public:
				/// <summary>Render target changed (before) event. Resources that binded to the render target can be released at this moment.</summary>
				compositions::GuiGraphicsEvent<GuiDirect2DElementEventArgs>		BeforeRenderTargetChanged;
				/// <summary>Render target changed (after) event. Resources that binded to the render target can be recreated at this moment.</summary>
				compositions::GuiGraphicsEvent<GuiDirect2DElementEventArgs>		AfterRenderTargetChanged;
				/// <summary>Rendering event.</summary>
				compositions::GuiGraphicsEvent<GuiDirect2DElementEventArgs>		Rendering;
			};
		}

		namespace elements_windows_d2d
		{

/***********************************************************************
Functionality
***********************************************************************/

			class IWindowsDirect2DRenderTarget : public elements::IGuiGraphicsRenderTarget
			{
			public:
				virtual ID2D1RenderTarget*					GetDirect2DRenderTarget()=0;
				virtual ComPtr<ID2D1Bitmap>					GetBitmap(INativeImageFrame* frame, bool enabled)=0;
				virtual void								DestroyBitmapCache(INativeImageFrame* frame)=0;
				virtual void								SetTextAntialias(bool antialias, bool verticalAntialias)=0;

				virtual ID2D1Effect*						GetFocusRectangleEffect() = 0;
				virtual ID2D1SolidColorBrush*				CreateDirect2DBrush(Color color)=0;
				virtual void								DestroyDirect2DBrush(Color color)=0;
				virtual ID2D1LinearGradientBrush*			CreateDirect2DLinearBrush(Color c1, Color c2)=0;
				virtual void								DestroyDirect2DLinearBrush(Color c1, Color c2)=0;
				virtual ID2D1RadialGradientBrush*			CreateDirect2DRadialBrush(Color c1, Color c2) = 0;
				virtual void								DestroyDirect2DRadialBrush(Color c1, Color c2) = 0;
			};

			class Direct2DTextFormatPackage
			{
			public:
				ComPtr<IDWriteTextFormat>		textFormat;
				DWRITE_TRIMMING					trimming;
				ComPtr<IDWriteInlineObject>		ellipseInlineObject;
			};

			class IWindowsDirect2DResourceManager : public Interface
			{
			public:
				virtual Direct2DTextFormatPackage*			CreateDirect2DTextFormat(const FontProperties& fontProperties)=0;
				virtual void								DestroyDirect2DTextFormat(const FontProperties& fontProperties)=0;
				virtual Ptr<elements::text::CharMeasurer>	CreateDirect2DCharMeasurer(const FontProperties& fontProperties)=0;
				virtual void								DestroyDirect2DCharMeasurer(const FontProperties& fontProperties)=0;
			};

			extern IWindowsDirect2DResourceManager*			GetWindowsDirect2DResourceManager();
			extern D2D1::ColorF								GetD2DColor(Color color);

/***********************************************************************
OS Supporting
***********************************************************************/

			class IWindowsDirect2DObjectProvider : public Interface
			{
			public:
				virtual void								RecreateRenderTarget(INativeWindow* window) = 0;
				virtual void								ResizeRenderTarget(INativeWindow* window) = 0;
				virtual ID2D1RenderTarget*					GetNativeWindowDirect2DRenderTarget(INativeWindow* window) = 0;
				virtual void								StartRendering(INativeWindow* window) = 0;
				virtual elements::RenderTargetFailure		StopRenderingAndPresent(INativeWindow* window) = 0;

				virtual ID2D1Factory*						GetDirect2DFactory() = 0;
				virtual IDWriteFactory*						GetDirectWriteFactory() = 0;
				virtual IWindowsDirect2DRenderTarget*		GetBindedRenderTarget(INativeWindow* window) = 0;
				virtual void								SetBindedRenderTarget(INativeWindow* window, IWindowsDirect2DRenderTarget* renderTarget) = 0;
				virtual IWICImagingFactory*					GetWICImagingFactory() = 0;
				virtual IWICBitmap*							GetWICBitmap(INativeImageFrame* frame) = 0;
			};

			extern IWindowsDirect2DObjectProvider*			GetWindowsDirect2DObjectProvider();
			extern void										SetWindowsDirect2DObjectProvider(IWindowsDirect2DObjectProvider* provider);
		}
	}
}

extern void RendererMainDirect2D();

#endif

/***********************************************************************
.\GRAPHICSELEMENT\WINDOWSDIRECT2D\GUIGRAPHICSLAYOUTPROVIDERWINDOWSDIRECT2D.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSLAYOUTPROVIDERWINDOWSDIRECT2D
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSLAYOUTPROVIDERWINDOWSDIRECT2D


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_d2d
		{
			class WindowsDirect2DLayoutProvider : public Object, public elements::IGuiGraphicsLayoutProvider
			{
			public:
				 Ptr<elements::IGuiGraphicsParagraph>		CreateParagraph(const WString& text, elements::IGuiGraphicsRenderTarget* renderTarget, elements::IGuiGraphicsParagraphCallback* callback)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\WINDOWSDIRECT2D\GUIGRAPHICSRENDERERSWINDOWSDIRECT2D.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSDIRECT2D
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSDIRECT2D


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_d2d
		{
			using namespace elements;

#define DEFINE_BRUSH_ELEMENT_RENDERER(TELEMENT, TRENDERER, TBRUSH, TBRUSHPROPERTY)\
				DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, IWindowsDirect2DRenderTarget)\
			protected:\
				TBRUSHPROPERTY			oldColor;\
				TBRUSH*					brush = nullptr;\
				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);\
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);\
				void					InitializeInternal();\
				void					FinalizeInternal();\
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);\
			public:\
				TRENDERER();\
				void					Render(Rect bounds)override;\
				void					OnElementStateChanged()override;\

/***********************************************************************
Renderers
***********************************************************************/

			class GuiFocusRectangleElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiFocusRectangleElement, GuiFocusRectangleElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				ID2D1Effect*			focusRectangleEffect = nullptr;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiSolidBorderElement, GuiSolidBorderElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class Gui3DBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DBorderElement, Gui3DBorderElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				ID2D1SolidColorBrush*	brush1 = nullptr;
				ID2D1SolidColorBrush*	brush2 = nullptr;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				Gui3DBorderElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DSplitterElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DSplitterElement, Gui3DSplitterElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				ID2D1SolidColorBrush*	brush1 = nullptr;
				ID2D1SolidColorBrush*	brush2 = nullptr;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				Gui3DSplitterElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, ID2D1SolidColorBrush, Color)
			};

			class GuiGradientBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				typedef collections::Pair<Color, Color> ColorPair;
				DEFINE_BRUSH_ELEMENT_RENDERER(GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, ID2D1LinearGradientBrush, ColorPair)
			};

			class GuiInnerShadowElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				typedef collections::Pair<Color, Color> ColorPair;
				DEFINE_GUI_GRAPHICS_RENDERER(GuiInnerShadowElement, GuiInnerShadowElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color							oldColor;
				Color							transparentColor;
				ID2D1LinearGradientBrush*		linearBrush = nullptr;
				ID2D1RadialGradientBrush*		radialBrush = nullptr;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiInnerShadowElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidLabelElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidLabelElement, GuiSolidLabelElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color							oldColor;
				FontProperties					oldFont;
				WString							oldText;
				ID2D1SolidColorBrush*			brush = nullptr;
				Direct2DTextFormatPackage*		textFormat = nullptr;
				IDWriteTextLayout*				textLayout = nullptr;
				vint							oldMaxWidth = -1;

				void					CreateBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateTextFormat(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyTextFormat(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateTextLayout();
				void					DestroyTextLayout();
				void					UpdateMinSize();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiSolidLabelElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiImageFrameElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiImageFrameElement, GuiImageFrameElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				ComPtr<ID2D1Bitmap>		bitmap;

				void					UpdateBitmap(IWindowsDirect2DRenderTarget* renderTarget);

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiImageFrameElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiPolygonElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiPolygonElement, GuiPolygonElementRenderer, IWindowsDirect2DRenderTarget)
			protected:
				Color							oldBorderColor;
				Color							oldBackgroundColor;
				ID2D1SolidColorBrush*			borderBrush = nullptr;
				ID2D1SolidColorBrush*			backgroundBrush = nullptr;
				collections::Array<Point>		oldPoints;
				ComPtr<ID2D1PathGeometry>		geometry;

				void							CreateGeometry();
				void							DestroyGeometry();
				void							FillGeometry(Point offset);
				void							RecreateResource(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
				void							InitializeInternal();
				void							FinalizeInternal();
				void							RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiPolygonElementRenderer();

				void							Render(Rect bounds)override;
				void							OnElementStateChanged()override;
			};

			class GuiColorizedTextElementRenderer : public Object, public IGuiGraphicsRenderer, protected GuiColorizedTextElement::ICallback
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiColorizedTextElement, GuiColorizedTextElementRenderer, IWindowsDirect2DRenderTarget)

			public:
				struct ColorItemResource
				{
					Color						text;
					ID2D1SolidColorBrush*		textBrush;
					Color						background;
					ID2D1SolidColorBrush*		backgroundBrush;
				};

				struct ColorEntryResource
				{
					ColorItemResource			normal;
					ColorItemResource			selectedFocused;
					ColorItemResource			selectedUnfocused;

					bool						operator==(const ColorEntryResource& value){return false;}
					bool						operator!=(const ColorEntryResource& value){return true;}
				};

				typedef collections::Array<ColorEntryResource>			ColorArray;
			protected:
				FontProperties					oldFont;
				Direct2DTextFormatPackage*		textFormat;
				ColorArray						colors;
				Color							oldCaretColor;
				ID2D1SolidColorBrush*			caretBrush;
				
				void					CreateTextBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyTextBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					CreateCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget);
				void					DestroyCaretBrush(IWindowsDirect2DRenderTarget* _renderTarget);

				void					ColorChanged();
				void					FontChanged();
				text::CharMeasurer*		GetCharMeasurer();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiDirect2DElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiDirect2DElement, GuiDirect2DElementRenderer, IWindowsDirect2DRenderTarget)

			protected:

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsDirect2DRenderTarget* oldRenderTarget, IWindowsDirect2DRenderTarget* newRenderTarget);
			public:
				GuiDirect2DElementRenderer();
				~GuiDirect2DElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSLAYOUTPROVIDERWINDOWSGDI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSLAYOUTPROVIDERWINDOWSGDI
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSLAYOUTPROVIDERWINDOWSGDI


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{
			class WindowsGDILayoutProvider : public Object, public elements::IGuiGraphicsLayoutProvider
			{
			public:
				 Ptr<elements::IGuiGraphicsParagraph>		CreateParagraph(const WString& text, elements::IGuiGraphicsRenderTarget* renderTarget, elements::IGuiGraphicsParagraphCallback* callback)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\WINNATIVEDPIAWARENESS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_WINNATIVEDPIAWARENESS
#define VCZH_PRESENTATION_WINDOWS_WINNATIVEDPIAWARENESS

#include <Windows.h>
#include <ShellScalingApi.h>

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
/***********************************************************************
DPI Awareness Functions
***********************************************************************/

			extern void				InitDpiAwareness(bool dpiAware);
			extern void				DpiAwared_GetDpiForMonitor(HMONITOR monitor, UINT* x, UINT* y);
			extern void				DpiAwared_GetDpiForWindow(HWND handle, UINT* x, UINT* y);
			extern void				DpiAwared_AdjustWindowRect(LPRECT rect, HWND handle, UINT dpi);
			extern int				DpiAwared_GetSystemMetrics(int index, UINT dpi);
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\GDI\WINGDI.H
***********************************************************************/
/*******************************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::GDI Helper Library

Classes:
  WinRegion				: Region
  WinTransform			: Vertex Transformation
  WinBrush				: Brush for filling geometries
  WinPen				: Pen for filling lines
  WinFont				: Font
  WinDC					: Device Context
  WinControlDC			: Device Context from HWND
  WinImageDC			: Device Context from images
  WinProxyDC			: Device Context from HDC
  WinDIB				: Device Independent Bitmap
  WinMetaFileBuilder	: Metafile Builder
  WinMetaFile			: Metafile Image
  WinBitmap				: Bitmap

Comments:
  WinDC::PolyDraw
    Points				: Points
	Actions				: How to deal with points
		PT_MOVETO		：MoveTo and consume 1 point
		PT_LINETO		：LineTo and consume 1 point
		PT_BEZIERTO		：Draw a bezier curve and consume 3 points
		PT_LINETO and PT_BEZIERTO can be mixed with PT_CLOSFIGURE to close the geometry begins from the last PT_MOVETO that happened
	PointCount			: Point count
  WinDC::DrawBuffer
    Format: See DrawText
  Pen：
	Style：
		PS_SOLID, PS_DASH, PS_DOT, PS_DASHDOT, PS_DASHDOTDOT, PS_USERSTYLE (for Geometric pen)
	EndCap：
		PS_ENDCAP_ROUND, PS_ENDCAP_SQUARE, PS_ENDCAP_FLAT
	Join：
		PS_JOIN_BEVEL, PS_JOIN_MITER, PS_JOIN_ROUND
  Brush：
	Hatch：
		HS_BDIAGONAL, HS_CROSS, HS_DIAGCROSS, HS_FDIAGONAL, HS_HORIZONTAL, HS_VERTICAL
  Region：
	Combine：
		RGN_AND, RGN_OR, RGN_XOR, RGN_DIFF, RGN_COPY
  ImageCopy：
	Draw ROP：
		BLACKNESS, DSTINVERT, MERGECOPY, MERGEPAINT, NOTSRCCOPY, NOTSRCERASE, 
		PATCOPY, PATINVERT, PATPAINT, SRCAND, SRCCOPY, SRCERASE, SRCINVERT, SRCPAINT, WHITENESS

  RasterOperation:
	R2_BLACK, R2_COPYPEN, R2_MASKNOTPEN, R2_MASKPEN, R2_MASKPENNOT, R2_MERGENOTPEN, R2_MERGEPEN
	R2_MERGEPENNOT, R2_NOP, R2_NOT, R2_NOTCOPYPEN, R2_NOTMASKPEN, R2_NOTMERGEPEN, R2_NOTXORPEN
	R2_WHITE, R2_XORPEN
  WinDIB：
	TransformAlphaChannel()：	Convert to an GDI compatible bitmap with alpha channel after all pixels are filled.
	Generate×××()：				Predefined alpha channel generation, TransformAlphaChannel should be called after that
*******************************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINGDI
#define VCZH_PRESENTATION_WINDOWS_GDI_WINGDI


namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/*********************************************************************************************************
Geometry
*********************************************************************************************************/

			class WinRegion : public Object
			{
			public:
				typedef Ptr<WinRegion>	Ptr;

				friend bool IsEqual(WinRegion::Ptr Region1, WinRegion::Ptr Region2);
			protected:
				HRGN					FHandle;
			public:
				WinRegion(vint Left, vint Top, vint Right, vint Bottom, bool Rectangle);
				WinRegion(RECT Rect, bool Rectangle);
				WinRegion(vint Left, vint Top, vint Right, vint Bottom, vint EllipseWidth, vint EllipseHeight);
				WinRegion(POINT* Points, vint Count, bool Alternate);
				WinRegion(WinRegion::Ptr Region);
				WinRegion(WinRegion::Ptr Region1, WinRegion::Ptr Region2, vint CombineMode);
				WinRegion(HRGN RegionHandle);
				~WinRegion();

				HRGN					GetHandle();
				bool					ContainPoint(POINT Point);
				bool					ContainRect(RECT Rect);
				RECT					GetBoundRect();
				void					Move(vint OffsetX, vint OffsetY);
			};

			class WinTransform : public Object
			{
			protected:
				XFORM					FTransform;
			public:
				WinTransform(XFORM Transform);
				WinTransform(const WinTransform& Transform);

				WinTransform&			operator=(const WinTransform& Transform);
				WinTransform			operator*(const WinTransform& Transform);
				const XFORM*			GetHandle()const;

				static WinTransform		Translate(float OffsetX, float OffsetY);
				static WinTransform		Scale(float ScaleX, float ScaleY);
				static WinTransform		Rotate(float Angle);
				static WinTransform		Rotate(float Cos, float Sin);
				static WinTransform		ReflectX();
				static WinTransform		ReflectY();
				static WinTransform		Reflect(float VectorX, float VectorY);
				static WinTransform		Reflect(float OriginX, float OriginY, float VectorX, float VectorY);
				static WinTransform		AxisV(float Xx, float Xy, float Yx, float Yy);
				static WinTransform		AxisA(float AngleX, float LenX, float AngleY, float LenY);
			};
		
/*********************************************************************************************************
Images
*********************************************************************************************************/

			class WinDC;
			class WinControlDC;
			class WinProxyDC;
			class WinImageDC;

			class WinMetaFileBuilder : public Object
			{
				friend class WinMetaFile;
			protected:
				vint					FWidth;
				vint					FHeight;
				WinProxyDC*				FDC;

				void					Create(vint Width, vint Height);
				void					Draw(HENHMETAFILE Handle);
				void					Destroy();
			public:

				WinMetaFileBuilder(vint Width, vint Height);
				~WinMetaFileBuilder();

				void					LoadFrom(WinMetaFile* File);
				void					SaveTo(WinMetaFile* File);
				void					LoadFrom(WString FileName);
				void					SaveTo(WString FileName);
				WinDC*					GetWinDC();
				vint					GetWidth();
				vint					GetHeight();
			};

			class WinMetaFile : public Object
			{
				friend class WinMetaFileBuilder;
			protected:
				HENHMETAFILE			FHandle;
				vint					FWidth;
				vint					FHeight;
			public:
				WinMetaFile(WString FileName);
				WinMetaFile(WinMetaFileBuilder* Builder);
				~WinMetaFile();

				HENHMETAFILE			GetHandle();
				vint					GetWidth();
				vint					GetHeight();
			};

			class WinBitmap : public Object
			{
			public:
				typedef Ptr<WinBitmap>		Ptr;
				enum BitmapBits
				{
					vbb2Bits,
					vbb24Bits,
					vbb32Bits
				};
			protected:
				BitmapBits				FBits;
				vint					FWidth;
				vint					FHeight;
				WinImageDC*				FDC;
				HBITMAP					FHandle;
				BYTE**					FScanLines;
				bool					FAlphaChannelBuilt;

				vint					GetBitsFromBB(BitmapBits BB);
				vint					GetLineBytes(vint Width, BitmapBits BB);
				void					FillBitmapInfoHeader(vint Width, vint Height, BitmapBits Bits, BITMAPINFOHEADER* Header);
				HBITMAP					CreateDDB(vint Width, vint Height, BitmapBits Bits);
				HBITMAP					CreateDIB(vint Width, vint Height, BitmapBits Bits, BYTE**& ScanLines);
				void					Constructor(vint Width, vint Height, BitmapBits Bits, bool DIBSections);
			public:
				WinBitmap(vint Width, vint Height, BitmapBits Bits, bool DIBSections);
				WinBitmap(WString FileName, bool Use32Bits, bool DIBSections);
				~WinBitmap();

				void					SaveToStream(stream::IStream& Output, bool DIBV5ClipboardFormat);
				void					SaveToFile(WString FileName);

				WinDC*					GetWinDC();
				vint					GetWidth();
				vint					GetHeight();
				vint					GetLineBytes();
				BYTE**					GetScanLines();
				HBITMAP					GetBitmap();
				BitmapBits				GetBitmapBits();
				void					FillCompatibleHeader(BITMAPINFOHEADER* Header);

				bool					CanBuildAlphaChannel();
				bool					IsAlphaChannelBuilt();
				void					BuildAlphaChannel(bool autoPremultiply);
				void					GenerateTrans(COLORREF Color);
				void					GenerateAlpha(BYTE Alpha);
				void					GenerateTransAlpha(COLORREF Color, BYTE Alpha);
				void					GenerateLuminance();
				void					GenerateGrayLevel();
				void					Generate(BYTE(*Function)(COLORREF));
			};

/*********************************************************************************************************
Resources
*********************************************************************************************************/

			class WinBrush : public Object
			{
			public:
				typedef Ptr<WinBrush>	Ptr;
			protected:
				HBRUSH					FHandle;
				unsigned char*			FDIBMemory;
			public:
				WinBrush();
				WinBrush(COLORREF Color);
				WinBrush(vint Hatch, COLORREF Color);
				WinBrush(WinBitmap::Ptr Bitmap);
				~WinBrush();

				HBRUSH					GetHandle();
			};

			class WinPen : public Object
			{
			public:
				typedef Ptr<WinPen>		Ptr;
			protected:
				HPEN					FHandle;
				unsigned char*			FDIBMemory;
			public:
				WinPen(vint Style, vint Width, COLORREF Color);
				WinPen(vint Style, vint EndCap, vint Join, vint Width, COLORREF Color, DWORD styleCount = 0, const DWORD* styleArray = nullptr);
				WinPen(vint Style, vint EndCap, vint Join, vint Hatch, vint Width, COLORREF Color);
				WinPen(WinBitmap::Ptr DIB, vint Style, vint EndCap, vint Join, vint Width);
				~WinPen();

				HPEN					GetHandle();
			};

			class WinFont : public Object
			{
			public:
				typedef Ptr<WinFont>		Ptr;
			protected:
				LOGFONT					FFontInfo;
				HFONT					FHandle;
			public:
				WinFont(WString Name, vint Height, vint Width, vint Escapement, vint Orientation, vint Weight, bool Italic, bool Underline, bool StrikeOut, bool Antialise);
				WinFont(LOGFONT* FontInfo);
				~WinFont();

				HFONT					GetHandle();
				LOGFONT*				GetInfo();
			};

/*********************************************************************************************************
Device Context
*********************************************************************************************************/

			extern WinBrush::Ptr		CreateDefaultBrush();
			extern WinPen::Ptr			CreateDefaultPen();
			extern WinFont::Ptr			CreateDefaultFont();

			class IWinResourceService : public Interface
			{
			public:
				virtual WinPen::Ptr		GetDefaultPen()=0;
				virtual WinBrush::Ptr	GetDefaultBrush()=0;
				virtual WinFont::Ptr	GetDefaultFont()=0;
			};
			extern IWinResourceService*	GetDefaultResourceService();
			extern void					SetDefaultResourceService(IWinResourceService* Service);

			class WinDC : public Object
			{
			protected:
				HDC						FHandle;

				WinPen::Ptr				FPen;
				WinBrush::Ptr			FBrush;
				WinFont::Ptr			FFont;

				HPEN					FOldPen;
				HBRUSH					FOldBrush;
				HFONT					FOldFont;

				void					Init();
			public:
				WinDC();
				~WinDC();

				HDC						GetHandle();

				WinPen::Ptr				GetPen();
				WinBrush::Ptr			GetBrush();
				WinFont::Ptr			GetFont();
				void					SetPen(WinPen::Ptr Pen);
				void					SetBrush(WinBrush::Ptr Brush);
				void					SetFont(WinFont::Ptr Font);
				COLORREF				GetBackColor();
				void					SetBackColor(COLORREF Color);
				COLORREF				GetTextColor();
				void					SetTextColor(COLORREF Color);
				bool					GetBackTransparent();
				void					SetBackTransparent(bool Transparent);
				POINT					GetBrushOrigin();
				void					SetBrushOrigin(POINT Point);
				int						SetRasterOperation(int rop2);

				void					DrawBuffer(vint X, vint Y, const wchar_t* Text, vint CharCount);
				void					DrawBuffer(vint X, vint Y, const wchar_t* Text, vint CharCount, vint TabWidth, vint TabOriginX);
				void					DrawBuffer(RECT Rect, const wchar_t* Text, vint CharCount, UINT Format);
				void					DrawString(vint X, vint Y, WString Text);
				void					DrawString(vint X, vint Y, WString Text, vint TabWidth, vint TabOriginX);
				void					DrawString(RECT Rect, WString Text, UINT Format);

				SIZE					MeasureString(WString Text, vint TabSize=-1);
				SIZE					MeasureBuffer(const wchar_t* Text, vint CharCount, vint TabSize=-1);
				SIZE					MeasureBuffer(const wchar_t* Text, vint TabSize=-1);
				SIZE					MeasureWrapLineString(WString Text, vint MaxWidth);
				SIZE					MeasureWrapLineBuffer(const wchar_t* Text, vint CharCount, vint MaxWidth);
				SIZE					MeasureWrapLineBuffer(const wchar_t* Text, vint MaxWidth);

				void					FillRegion(WinRegion::Ptr Region);
				void					FrameRegion(WinRegion::Ptr Region, vint BlockWidth, vint BlockHeight);

				void					MoveTo(vint X, vint Y);
				void					LineTo(vint X, vint Y);
				void					Rectangle(vint Left, vint Top, vint Right, vint Bottom);
				void					Rectangle(RECT Rect);
				void					FocusRectangle(vint Left, vint Top, vint Right, vint Bottom);
				void					FocusRectangle(RECT Rect);
				void					FillRect(vint Left, vint Top, vint Right, vint Bottom);
				void					FillRect(RECT Rect);
				void					Ellipse(vint Left, vint Top, vint Right, vint Bottom);
				void					Ellipse(RECT Rect);
				void					RoundRect(vint Left, vint Top, vint Right, vint Bottom, vint EllipseWidth, vint EllipseHeight);
				void					RoundRect(RECT Rect, vint EllipseWidth, vint EllipseHeight);
				void					PolyLine(const POINT* Points, vint Count);
				void					PolyLineTo(const POINT* Points, vint Count);
				void					PolyGon(const POINT* Points, vint Count);
				void					PolyBezier(const POINT* Points, vint Count);
				void					PolyBezierTo(const POINT* Points, vint Count);
				void					PolyDraw(const POINT* Points, const BYTE* Actions, vint PointCount);
				void					Arc(RECT Bound, POINT Start, POINT End);
				void					Arc(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY);
				void					ArcTo(RECT Bound, POINT Start, POINT End);
				void					ArcTo(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY);
				void					AngleArc(vint X, vint Y, vint Radius, float StartAngle, float SweepAngle);
				void					AngleArc(vint X, vint Y, vint Radius, double StartAngle, double SweepAngle);
				void					Chord(RECT Bound, POINT Start, POINT End);
				void					Chord(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY);
				void					Pie(RECT Bound, POINT Start, POINT End);
				void					Pie(vint Left, vint Top, vint Right, vint Bottom, vint StartX, vint StartY, vint EndX, vint EndY);
				void					GradientRectH(TRIVERTEX* Vertices, vint VerticesCount, GRADIENT_RECT* Rectangles, vint RectangleCount);
				void					GradientRectV(TRIVERTEX* Vertices, vint VerticesCount, GRADIENT_RECT* Rectangles, vint RectangleCount);
				void					GradientTriangle(TRIVERTEX* Vertices, vint VerticesCount, GRADIENT_TRIANGLE* Triangles, vint TriangleCount);

				void					BeginPath();
				void					EndPath();
				void					ClosePath();
				void					WidenPath();
				void					DiscardPath();
				void					DrawPath();
				void					FillPath();
				void					DrawAndFillPath();
				WinRegion::Ptr			RegionFromPath();

				bool					PointInClip(POINT Point);
				bool					RectInClip(RECT Rect);
				void					ClipPath(vint CombineMode);
				void					ClipRegion(WinRegion::Ptr Region);
				void					RemoveClip();
				void					MoveClip(vint OffsetX, vint OffsetY);
				void					CombineClip(WinRegion::Ptr Region, vint CombineMode);
				void					IntersetClipRect(RECT Rect);
				void					ExcludeClipRect(RECT Rect);
				WinRegion::Ptr			GetClipRegion();
				RECT					GetClipBoundRect();

				WinTransform			GetTransform();
				void					SetTransform(const WinTransform& Transform);

				void					Copy(vint dstX, vint dstY, vint dstW, vint dstH, WinDC* Source, vint srcX, vint srcY, DWORD DrawROP=SRCCOPY);
				void					Copy(RECT dstRect, WinDC* Source, POINT srcPos, DWORD DrawROP=SRCCOPY);
				void					Copy(vint dstX, vint dstY, vint dstW, vint dstH, WinDC* Source, vint srcX, vint srcY ,vint srcW, vint srcH, DWORD DrawROP=SRCCOPY);
				void					Copy(RECT dstRect, WinDC* Source, RECT srcRect, DWORD DrawROP=SRCCOPY);
				void					Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC* Source, vint srcX, vint srcY, vint srcW, vint srcH);
				void					Copy(POINT UpperLeft, POINT UpperRight, POINT LowerLeft, WinDC* Source, RECT srcRect);
				void					CopyTrans(vint dstX, vint dstY, vint dstW, vint dstH, WinDC* Source, vint srcX, vint srcY ,vint srcW, vint srcH, COLORREF Color);
				void					CopyTrans(RECT dstRect, WinDC* Source, RECT srcRect, COLORREF Color);

				void					Draw(vint dstX, vint dstY, WinMetaFile* MetaFile);
				void					Draw(POINT Pos, WinMetaFile* MetaFile);
				void					Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinMetaFile* MetaFile);
				void					Draw(RECT Rect, WinMetaFile* MetaFile);

				void					Draw(vint dstX, vint dstY, WinBitmap::Ptr Bitmap);
				void					Draw(POINT Pos, WinBitmap::Ptr Bitmap);
				void					Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap);
				void					Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos);
				void					Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY, vint srcW, vint srcH);
				void					Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect);

				void					Draw(vint dstX, vint dstY, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(POINT Pos, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, unsigned char Alpha);
				void					Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY, unsigned char Alpha);
				void					Draw(RECT Rect, WinBitmap::Ptr Bitmap, POINT Pos, unsigned char Alpha);
				void					Draw(vint dstX, vint dstY, vint dstW, vint dstH, WinBitmap::Ptr Bitmap, vint srcX, vint srcY, vint srcW, vint srcH, unsigned char Alpha);
				void					Draw(RECT dstRect, WinBitmap::Ptr Bitmap, RECT srcRect, unsigned char Alpha);
			};

			class WinControlDC : public WinDC
			{
			protected:
				HWND					FControlHandle;
			public:
				WinControlDC(HWND Handle);
				~WinControlDC();
			};

			class WinProxyDC : public WinDC
			{
			public:
				WinProxyDC();
				~WinProxyDC();

				void					Initialize(HDC Handle);
			};

			class WinImageDC : public WinDC
			{
			public:
				WinImageDC();
				~WinImageDC();
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSWINDOWSGDI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSGDI
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSWINDOWSGDI

#include <MLang.h>

namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			
/***********************************************************************
Raw API Rendering Element
***********************************************************************/

			class GuiGDIElement;

			/// <summary>GDI Rendering event arguments.</summary>
			struct GuiGDIElementEventArgs : compositions::GuiEventArgs
			{
			public:
				/// <summary>The element that raised this event.</summary>
				GuiGDIElement*				element;
				/// <summary>The device context to draw. The HDC handle can be retrived using dc->GetHandle(), but it is recommended that using the WinDC class directly.</summary>
				windows::WinDC*				dc;
				/// <summary>The range for rendering.</summary>
				Rect						bounds;

				GuiGDIElementEventArgs(GuiGDIElement* _element, windows::WinDC* _dc, Rect _bounds)
					:element(_element)
					,dc(_dc)
					,bounds(_bounds)
				{
				}
			};

			/// <summary>
			/// Defines an element for customized rendering using GDI.
			/// </summary>
			class GuiGDIElement : public GuiElementBase<GuiGDIElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiGDIElement, L"GDIElement")
			protected:
				GuiGDIElement();
			public:
				/// <summary>Rendering event.</summary>
				compositions::GuiGraphicsEvent<GuiGDIElementEventArgs>		Rendering;
			};
		}

		namespace elements_windows_gdi
		{

/***********************************************************************
Functionality
***********************************************************************/

			class IWindowsGDIRenderTarget : public elements::IGuiGraphicsRenderTarget
			{
			public:
				virtual windows::WinDC*					GetDC()=0;
			};

			class IWindowsGDIResourceManager : public Interface
			{
			public:
				virtual Ptr<windows::WinPen>				GetFocusRectanglePen()=0;
				virtual Ptr<windows::WinPen>				CreateGdiPen(Color color)=0;
				virtual void								DestroyGdiPen(Color color)=0;
				virtual Ptr<windows::WinBrush>				CreateGdiBrush(Color color)=0;
				virtual void								DestroyGdiBrush(Color color)=0;
				virtual Ptr<windows::WinFont>				CreateGdiFont(const FontProperties& fontProperties)=0;
				virtual void								DestroyGdiFont(const FontProperties& fontProperties)=0;
				virtual Ptr<elements::text::CharMeasurer>	CreateCharMeasurer(const FontProperties& fontProperties)=0;
				virtual void								DestroyCharMeasurer(const FontProperties& fontProperties)=0;

				virtual Ptr<windows::WinBitmap>				GetBitmap(INativeImageFrame* frame, bool enabled)=0;
				virtual void								DestroyBitmapCache(INativeImageFrame* frame)=0;
			};

			extern IWindowsGDIResourceManager*				GetWindowsGDIResourceManager();

/***********************************************************************
OS Supporting
***********************************************************************/

			class IWindowsGDIObjectProvider : public Interface
			{
			public:
				virtual windows::WinDC*						GetNativeWindowDC(INativeWindow* window)=0;
				virtual IWindowsGDIRenderTarget*			GetBindedRenderTarget(INativeWindow* window)=0;
				virtual void								SetBindedRenderTarget(INativeWindow* window, IWindowsGDIRenderTarget* renderTarget)=0;
				virtual IWICImagingFactory*					GetWICImagingFactory()=0;
				virtual IWICBitmap*							GetWICBitmap(INativeImageFrame* frame)=0;
				virtual IMLangFontLink2*					GetMLangFontLink()=0;
			};

			extern IWindowsGDIObjectProvider*				GetWindowsGDIObjectProvider();
			extern void										SetWindowsGDIObjectProvider(IWindowsGDIObjectProvider* provider);
		}
	}
}

extern void RendererMainGDI();

#endif

/***********************************************************************
.\GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSRENDERERSWINDOWSGDI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSGDI
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRENDERERSWINDOWSGDI


namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{
			using namespace elements;

/***********************************************************************
Renderers
***********************************************************************/

			class GuiFocusRectangleElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiFocusRectangleElement, GuiFocusRectangleElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Ptr<windows::WinPen>	pen;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidBorderElement, GuiSolidBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DBorderElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DBorderElement, Gui3DBorderElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				Ptr<windows::WinPen>	pen1;
				Ptr<windows::WinPen>	pen2;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class Gui3DSplitterElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(Gui3DSplitterElement, Gui3DSplitterElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor1;
				Color					oldColor2;
				Ptr<windows::WinPen>	pen1;
				Ptr<windows::WinPen>	pen2;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Color					oldColor;
				Ptr<windows::WinPen>	pen;
				Ptr<windows::WinBrush>	brush;

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiGradientBackgroundElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, IWindowsGDIRenderTarget)
			protected:
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiInnerShadowElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiInnerShadowElement, GuiInnerShadowElementRenderer, IWindowsGDIRenderTarget)
			protected:
				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiInnerShadowElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiSolidLabelElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiSolidLabelElement, GuiSolidLabelElementRenderer, IWindowsGDIRenderTarget)
			protected:
				FontProperties			oldFont;
				Ptr<windows::WinFont>	font;
				vint					oldMaxWidth;

				void					UpdateMinSize();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiSolidLabelElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiImageFrameElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiImageFrameElement, GuiImageFrameElementRenderer, IWindowsGDIRenderTarget)
			protected:
				Ptr<windows::WinBitmap>		bitmap;

				void					UpdateBitmap();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiImageFrameElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiPolygonElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiPolygonElement, GuiPolygonElementRenderer, IWindowsGDIRenderTarget)
			protected:
				POINT*							points;
				vint								pointCount;
				Color							oldPenColor;
				Color							oldBrushColor;
				Ptr<windows::WinPen>			pen;
				Ptr<windows::WinBrush>			brush;

				void							InitializeInternal();
				void							FinalizeInternal();
				void							RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiPolygonElementRenderer();
				~GuiPolygonElementRenderer();

				void							Render(Rect bounds)override;
				void							OnElementStateChanged()override;
			};

			class GuiColorizedTextElementRenderer : public Object, public IGuiGraphicsRenderer, protected GuiColorizedTextElement::ICallback
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiColorizedTextElement, GuiColorizedTextElementRenderer, IWindowsGDIRenderTarget)

			public:
				struct ColorItemResource
				{
					Color						text;
					Color						background;
					Ptr<windows::WinBrush>		backgroundBrush;
				};

				struct ColorEntryResource
				{
					ColorItemResource			normal;
					ColorItemResource			selectedFocused;
					ColorItemResource			selectedUnfocused;

					bool						operator==(const ColorEntryResource& value){return false;}
					bool						operator!=(const ColorEntryResource& value){return true;}
				};

				typedef collections::Array<ColorEntryResource>			ColorArray;
			protected:
				FontProperties			oldFont;
				Ptr<windows::WinFont>	font;
				ColorArray				colors;
				Color					oldCaretColor;
				Ptr<windows::WinPen>	caretPen;

				void					DestroyColors();
				void					ColorChanged();
				void					FontChanged();

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};

			class GuiGDIElementRenderer : public Object, public IGuiGraphicsRenderer
			{
				DEFINE_GUI_GRAPHICS_RENDERER(GuiGDIElement, GuiGDIElementRenderer, IWindowsGDIRenderTarget)

			protected:

				void					InitializeInternal();
				void					FinalizeInternal();
				void					RenderTargetChangedInternal(IWindowsGDIRenderTarget* oldRenderTarget, IWindowsGDIRenderTarget* newRenderTarget);
			public:
				GuiGDIElementRenderer();
				~GuiGDIElementRenderer();

				void					Render(Rect bounds)override;
				void					OnElementStateChanged()override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\WINDOWSGDI\GUIGRAPHICSUNISCRIBE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation::Renderer

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSUNISCRIBE
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSUNISCRIBE

#include <usp10.h>

namespace vl
{
	namespace presentation
	{
		namespace elements_windows_gdi
		{
			using namespace elements;
			using namespace collections;
			using namespace windows;

/***********************************************************************
UniscribeColor
***********************************************************************/

			struct UniscribeColorRange
			{
				vint							start;
				vint							end;

				UniscribeColorRange(){}
				UniscribeColorRange(vint _start, vint _end):start(_start),end(_end){}

				bool operator==(const UniscribeColorRange& range) const { return start==range.start; }
				bool operator!=(const UniscribeColorRange& range) const { return start!=range.start; }
				bool operator<(const UniscribeColorRange& range) const { return start<range.start; }
				bool operator<=(const UniscribeColorRange& range) const { return start<=range.start; }
				bool operator>(const UniscribeColorRange& range) const { return start>range.start; }
				bool operator>=(const UniscribeColorRange& range) const { return start>=range.start; }
			};

			struct UniscribeColor
			{
				Color							fontColor;
				Color							backgroundColor;

				UniscribeColor(){}
				UniscribeColor(Color _fontColor, Color _backgroundColor):fontColor(_fontColor),backgroundColor(_backgroundColor){}

				bool operator==(const UniscribeColor& color) const { return fontColor==color.fontColor && backgroundColor==color.backgroundColor; }
				bool operator!=(const UniscribeColor& color) const { return fontColor!=color.fontColor || backgroundColor!=color.backgroundColor; }
			};
		}
	}

	template<>
	struct POD<presentation::elements_windows_gdi::UniscribeColorRange>
	{
		static const bool Result=true;
	};

	template<>
	struct POD<presentation::elements_windows_gdi::UniscribeColor>
	{
		static const bool Result=true;
	};

	namespace presentation
	{
		namespace elements_windows_gdi
		{

			typedef Nullable<IGuiGraphicsParagraph::InlineObjectProperties>	InlineObject;

/***********************************************************************
UniscribeFragment
***********************************************************************/

			struct UniscribeFragment
			{
				typedef Dictionary<UniscribeColorRange, UniscribeColor>		ColorRangeMap;

				//***************************** Document Data (Text)
				ColorRangeMap									colors;
				FontProperties									fontStyle;
				const WString									text;
				Ptr<WinFont>									fontObject;
				//***************************** Document Data (Element)
				InlineObject									inlineObjectProperties;
				List<Ptr<UniscribeFragment>>					cachedTextFragment;

				UniscribeFragment(const WString& _text);

				WString							GetFingerprint();
				void							CutColors(vint start, vint length);
				void							UpdateOverlappedColors(vint start, vint length, Color UniscribeColor::* colorField, Color color);
				void							DefragmentColors();
				UniscribeColor					GetCharColor(vint charIndex);
				Ptr<UniscribeFragment>			Copy(vint start, vint length);
			};

/***********************************************************************
UniscribeGlyphData
***********************************************************************/

			struct UniscribeGlyphData
			{
				//***************************** Uniscribe Data
				Array<WORD>						glyphs;
				Array<SCRIPT_VISATTR>			glyphVisattrs;
				Array<int>						glyphAdvances;
				Array<GOFFSET>					glyphOffsets;
				Array<WORD>						charCluster;
				ABC								runAbc;
				SCRIPT_ANALYSIS					sa;

				UniscribeGlyphData();

				void							ClearUniscribeData(vint glyphCount, vint length);
				bool							BuildUniscribeData(WinDC* dc, SCRIPT_ITEM* scriptItem, SCRIPT_CACHE& scriptCache, const wchar_t* runText, vint length, List<vint>& breakings, List<bool>& breakingAvailabilities);
				void							BuildUniscribeData(WinDC* dc, SCRIPT_ITEM* scriptItem, SCRIPT_LOGATTR* charLogattrs, const wchar_t* runText, vint length);
			};

/***********************************************************************
UniscribeItem
***********************************************************************/

			class UniscribeItem : public Object
			{
			public:
				//***************************** Uniscribe Data
				SCRIPT_ITEM						scriptItem;
				vint							startFromLine;
				vint							length;
				const wchar_t*					itemText;
				Array<SCRIPT_LOGATTR>			charLogattrs;

				UniscribeItem();
				~UniscribeItem();

				void							ClearUniscribeData();
				bool							BuildUniscribeData();
				bool							IsRightToLeft();
			};

/***********************************************************************
UniscribeRun
***********************************************************************/

			class UniscribeRun : public Object
			{
			public:
				struct RunFragmentBounds
				{
					vint						startFromRun;
					vint						length;
					Rect						bounds;
				};

				class IRendererCallback : public Interface
				{
				public:
					virtual WinDC*									GetWinDC() = 0;
					virtual Point									GetParagraphOffset() = 0;
					virtual IGuiGraphicsParagraphCallback*			GetParagraphCallback() = 0;
				};
				
				//***************************** Document Data
				UniscribeFragment*				documentFragment;
				UniscribeItem*					scriptItem;
				//***************************** Uniscribe Data
				vint							startFromLine;
				vint							startFromFragment;
				vint							length;
				const wchar_t*					runText;
				//***************************** Layout Data
				List<RunFragmentBounds>			fragmentBounds;

				UniscribeRun();
				~UniscribeRun();

				virtual bool					BuildUniscribeData(WinDC* dc, List<vint>& breakings)=0;
				virtual vint					SumWidth(vint charStart, vint charLength)=0;
				virtual vint					SumHeight()=0;
				virtual vint					SumTextHeight()=0;
				virtual void					SearchForLineBreak(vint tempStart, vint maxWidth, bool firstRun, vint& charLength, vint& charAdvances)=0;
				virtual void					Render(IRendererCallback* callback, vint fragmentBoundsIndex, vint offsetX, vint offsetY, bool renderBackground)=0;
			};

/***********************************************************************
UniscribeTextRun
***********************************************************************/

			class UniscribeTextRun : public UniscribeRun
			{
			public:
				//***************************** Uniscribe Data
				SCRIPT_CACHE					scriptCache;
				vint							advance;
				UniscribeGlyphData				wholeGlyph;
				bool							needFontFallback;

				UniscribeTextRun();
				~UniscribeTextRun();

				void							ClearUniscribeData();
				void							SearchSingleGlyphCluster(vint charStart, vint& charLength, vint& cluster, vint& nextCluster);
				void							SearchSingleChar(vint charStart, vint& charLength, vint& cluster, vint& nextCluster);
				void							SearchGlyphCluster(vint charStart, vint charLength, vint& cluster, vint& nextCluster);
				bool							BuildUniscribeData(WinDC* dc, List<vint>& breakings)override;
				vint							SumWidth(vint charStart, vint charLength)override;
				vint							SumHeight()override;
				vint							SumTextHeight()override;
				void							SearchForLineBreak(vint tempStart, vint maxWidth, bool firstRun, vint& charLength, vint& charAdvances)override;
				void							Render(IRendererCallback* callback, vint fragmentBoundsIndex, vint offsetX, vint offsetY, bool renderBackground)override;
			};

/***********************************************************************
UniscribeElementRun
***********************************************************************/

			class UniscribeEmbeddedObjectRun : public UniscribeRun
			{
			public:
				//***************************** Document Data
				IGuiGraphicsParagraph::InlineObjectProperties	properties;

				UniscribeEmbeddedObjectRun();
				~UniscribeEmbeddedObjectRun();

				bool							BuildUniscribeData(WinDC* dc, List<vint>& breakings)override;
				vint							SumWidth(vint charStart, vint charLength)override;
				vint							SumHeight()override;
				vint							SumTextHeight()override;
				void							SearchForLineBreak(vint tempStart, vint maxWidth, bool firstRun, vint& charLength, vint& charAdvances)override;
				void							Render(IRendererCallback* callback, vint fragmentBoundsIndex, vint offsetX, vint offsetY, bool renderBackground)override;
			};

/***********************************************************************
UniscribeVirtualLine
***********************************************************************/

			class UniscribeVirtualLine : Object
			{
			public:
				//***************************** Document Data
				vint							startFromLine;
				vint							length;
				const wchar_t*					runText;
				//***************************** Layout Data
				vint							firstRunIndex;
				vint							firstRunBoundsIndex;
				vint							lastRunIndex;
				vint							lastRunBoundsIndex;
				Rect							bounds;

				UniscribeVirtualLine();
			};

/***********************************************************************
UniscribeLine
***********************************************************************/

			class UniscribeLine : public Object
			{
			public:
				//***************************** Document Data
				List<Ptr<UniscribeFragment>>	documentFragments;
				vint							startFromParagraph;
				WString							lineText;
				//***************************** Uniscribe Data
				List<Ptr<UniscribeItem>>		scriptItems;
				List<Ptr<UniscribeRun>>			scriptRuns;
				//***************************** Layout Data
				List<Ptr<UniscribeVirtualLine>>	virtualLines;
				Rect							bounds;

				UniscribeLine();

				void							ClearUniscribeData();
				bool							BuildUniscribeData(WinDC* dc);
				void							Layout(vint availableWidth, Alignment alignment, vint top, vint& totalHeight);
				void							Render(UniscribeRun::IRendererCallback* callback, vint offsetX, vint offsetY, bool renderBackground);
			};

/***********************************************************************
UniscribeParagraph
***********************************************************************/

			class UniscribeParagraph : public Object
			{
			public:
				//***************************** Document Data
				List<Ptr<UniscribeFragment>>	documentFragments;
				Alignment						paragraphAlignment;
				WString							paragraphText;
				bool							built;
				//***************************** Uniscribe Data
				List<Ptr<UniscribeLine>>		lines;
				//***************************** Layout Data
				vint							lastAvailableWidth;
				Rect							bounds;

				UniscribeParagraph();
				~UniscribeParagraph();

				void							ClearUniscribeData();
				bool							BuildUniscribeData(WinDC* dc);
				void							Layout(vint availableWidth, Alignment alignment);
				void							Render(UniscribeRun::IRendererCallback* callback, bool renderBackground);

				void							SearchFragment(vint start, vint length, vint& fs, vint& ss, vint& fe, vint& se);
				bool							CutFragment(vint fs, vint ss, vint fe, vint se, vint& f1, vint& f2);
				void							CutFragmentColors(vint fs, vint ss, vint fe, vint se, Color UniscribeColor::* colorField, Color color);

				bool							SetFont(vint start, vint length, const WString& value);
				bool							SetSize(vint start, vint length, vint value);
				bool							SetStyle(vint start, vint length, bool bold, bool italic, bool underline, bool strikeline);
				bool							SetColor(vint start, vint length, Color value);
				bool							SetBackgroundColor(vint start, vint length, Color value);
				bool							SetInlineObject(vint start, vint length, const IGuiGraphicsParagraph::InlineObjectProperties& properties);
				InlineObject					ResetInlineObject(vint start, vint length);

				void							GetLineIndexFromTextPos(vint textPos, vint& frontLine, vint& backLine);
				void							GetVirtualLineIndexFromTextPos(vint textPos, vint lineIndex, vint& frontLine, vint& backLine);
				void							GetItemIndexFromTextPos(vint textPos, vint lineIndex, vint& frontItem, vint& backItem);
				Rect							GetCaretBoundsWithLine(vint caret, vint lineIndex, vint virtualLineIndex, bool frontSide);
				vint							GetCaretFromXWithTextRunBounds(vint x, vint lineIndex, vint runIndex, vint runBoundsIndex);
				vint							GetCaretFromXWithLine(vint x, vint lineIndex, vint virtualLineIndex);
				InlineObject					GetInlineObjectFromXWithLine(vint x, vint lineIndex, vint virtualLineIndex, vint& start, vint& length);
				vint							GetLineY(vint lineIndex);
				vint							GetVirtualLineY(vint lineIndex, vint virtualLineIndex);
				vint							GetLineIndexFromY(vint y);
				vint							GetVirtualLineIndexFromY(vint y, vint lineIndex);

				vint							GetCaret(vint comparingCaret, IGuiGraphicsParagraph::CaretRelativePosition position, bool& preferFrontSide);
				Rect							GetCaretBounds(vint caret, bool frontSide);
				vint							GetCaretFromPoint(Point point);
				InlineObject					GetInlineObjectFromPoint(Point point, vint& start, vint& length);
				vint							GetNearestCaretFromTextPos(vint textPos, bool frontSide);
				bool							IsValidCaret(vint caret);
				bool							IsValidTextPos(vint textPos);
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSIMAGESERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSIMAGESERIVCE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSIMAGESERIVCE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsImageFrame : public Object, public INativeImageFrame
			{
			protected:
				INativeImage*													image;
				ComPtr<IWICBitmap>												frameBitmap;
				collections::Dictionary<void*, Ptr<INativeImageFrameCache>>		caches;

				void										Initialize(IWICBitmapSource* bitmapSource);
			public:
				WindowsImageFrame(INativeImage* _image, IWICBitmapFrameDecode* frameDecode);
				WindowsImageFrame(INativeImage* _image, IWICBitmap* sourceBitmap);
				~WindowsImageFrame();

				INativeImage*								GetImage()override;
				Size										GetSize()override;
				bool										SetCache(void* key, Ptr<INativeImageFrameCache> cache)override;
				Ptr<INativeImageFrameCache>					GetCache(void* key)override;
				Ptr<INativeImageFrameCache>					RemoveCache(void* key)override;
				IWICBitmap*									GetFrameBitmap();
				void										SaveBitmapToStream(stream::IStream& stream);
			};

			class WindowsImage : public Object, public INativeImage
			{
			protected:
				INativeImageService*						imageService;
				ComPtr<IWICBitmapDecoder>					bitmapDecoder;
				collections::Array<Ptr<WindowsImageFrame>>	frames;
			public:
				WindowsImage(INativeImageService* _imageService, IWICBitmapDecoder* _bitmapDecoder);
				~WindowsImage();

				INativeImageService*						GetImageService()override;
				FormatType									GetFormat()override;
				vint										GetFrameCount()override;
				INativeImageFrame*							GetFrame(vint index)override;
				void										SaveToStream(stream::IStream& stream, FormatType formatType)override;
			};

			class WindowsBitmapImage : public Object, public INativeImage
			{
			protected:
				INativeImageService*						imageService;
				Ptr<WindowsImageFrame>						frame;
				FormatType									formatType;
			public:
				WindowsBitmapImage(INativeImageService* _imageService, IWICBitmap* sourceBitmap, FormatType _formatType);
				~WindowsBitmapImage();

				INativeImageService*						GetImageService()override;
				FormatType									GetFormat()override;
				vint										GetFrameCount()override;
				INativeImageFrame*							GetFrame(vint index)override;
				void										SaveToStream(stream::IStream& stream, FormatType formatType)override;
			};

			class WindowsImageService : public Object, public INativeImageService
			{
			protected:
				ComPtr<IWICImagingFactory>					imagingFactory;
			public:
				WindowsImageService();
				~WindowsImageService();

				Ptr<INativeImage>							CreateImageFromFile(const WString& path);
				Ptr<INativeImage>							CreateImageFromMemory(void* buffer, vint length);
				Ptr<INativeImage>							CreateImageFromStream(stream::IStream& stream);
				Ptr<INativeImage>							CreateImageFromHBITMAP(HBITMAP handle);
				Ptr<INativeImage>							CreateImageFromHICON(HICON handle);
				IWICImagingFactory*							GetImagingFactory();
			};

			extern IWICImagingFactory*						GetWICImagingFactory();
			extern IWICBitmap*								GetWICBitmap(INativeImageFrame* frame);
			extern Ptr<INativeImage>						CreateImageFromHBITMAP(HBITMAP handle);
			extern Ptr<INativeImage>						CreateImageFromHICON(HICON handle);
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\WINNATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_WINNATIVEWINDOW
#define VCZH_PRESENTATION_WINDOWS_WINNATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		namespace windows
		{

/***********************************************************************
Windows Platform Native Controller
***********************************************************************/

			class INativeMessageHandler : public Interface
			{
			public:
				virtual void								BeforeHandle(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool& skip) = 0;
				virtual void								AfterHandle(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool& skip, LRESULT& result) = 0;
			};

			class IWindowsForm : public Interface
			{
			public:
				virtual HWND								GetWindowHandle() = 0;
				virtual Interface*							GetGraphicsHandler() = 0;
				virtual void								SetGraphicsHandler(Interface* handler) = 0;
				virtual bool								InstallMessageHandler(Ptr<INativeMessageHandler> handler) = 0;
				virtual bool								UninstallMessageHandler(Ptr<INativeMessageHandler> handler) = 0;
			};

			extern void										SetWindowDefaultIcon(UINT resourceId);
			extern INativeController*						CreateWindowsNativeController(HINSTANCE hInstance);
			extern IWindowsForm*							GetWindowsFormFromHandle(HWND hwnd);
			extern IWindowsForm*							GetWindowsForm(INativeWindow* window);
			extern void										DestroyWindowsNativeController(INativeController* controller);
			extern void										EnableCrossKernelCrashing();
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\DIRECT2D\WINDIRECT2DAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Direct2D Provider for Windows Implementation

Interfaces:
***********************************************************************/
#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINDIRECT2DAPPLICATION
#define VCZH_PRESENTATION_WINDOWS_GDI_WINDIRECT2DAPPLICATION

#include <d3d11_1.h>

namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			extern ID2D1Factory*						GetDirect2DFactory();
			extern IDWriteFactory*						GetDirectWriteFactory();
			extern ID3D11Device*						GetD3D11Device();
		}
	}
}

extern int WinMainDirect2D(HINSTANCE hInstance, void(*RendererMain)());

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSRESOURCESERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSRESOURCESERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSRESOURCESERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsCursor : public Object, public INativeCursor
			{
			protected:
				HCURSOR										handle;
				bool										isSystemCursor;
				SystemCursorType							systemCursorType;
			public:
				WindowsCursor(HCURSOR _handle);
				WindowsCursor(SystemCursorType type);

				bool										IsSystemCursor()override;
				SystemCursorType							GetSystemCursorType()override;
				HCURSOR										GetCursorHandle();
			};

			class WindowsResourceService : public Object, public INativeResourceService
			{
			protected:
				collections::Array<Ptr<WindowsCursor>>		systemCursors;
				FontProperties								defaultFont;
			public:
				WindowsResourceService();

				INativeCursor*								GetSystemCursor(INativeCursor::SystemCursorType type)override;
				INativeCursor*								GetDefaultSystemCursor()override;
				FontProperties								GetDefaultFont()override;
				void										SetDefaultFont(const FontProperties& value)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSCLIPBOARDSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCLIPBOARDSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCLIPBOARDSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsClipboardService;

			class WindowsClipboardReader : public Object, public INativeClipboardReader
			{
				friend class WindowsClipboardService;
			protected:
				WindowsClipboardService*		service;
				bool							ContainsFormat(UINT format);

			public:
				WindowsClipboardReader(WindowsClipboardService* _service);
				~WindowsClipboardReader();

				bool							ContainsText()override;
				WString							GetText()override;

				bool							ContainsDocument()override;
				Ptr<DocumentModel>				GetDocument()override;

				bool							ContainsImage()override;
				Ptr<INativeImage>				GetImage()override;

				void							CloseClipboard();
			};

			class WindowsClipboardWriter : public Object, public INativeClipboardWriter
			{
				friend class WindowsClipboardService;
			protected:
				WindowsClipboardService*		service;
				Nullable<WString>				textData;
				Ptr<DocumentModel>				documentData;
				Ptr<INativeImage>				imageData;

				void							SetClipboardData(UINT format, stream::MemoryStream& memoryStream);
			public:
				WindowsClipboardWriter(WindowsClipboardService* _service);
				~WindowsClipboardWriter();

				void							SetText(const WString& value)override;
				void							SetDocument(Ptr<DocumentModel> value)override;
				void							SetImage(Ptr<INativeImage> value)override;
				bool							Submit()override;
			};

			class WindowsClipboardService : public Object, public INativeClipboardService
			{
				friend class WindowsClipboardReader;
				friend class WindowsClipboardWriter;
			protected:
				HWND							ownerHandle;
				UINT							WCF_Document;
				UINT							WCF_RTF;
				UINT							WCF_HTML;
				WindowsClipboardReader*			reader = nullptr;

			public:
				WindowsClipboardService();

				Ptr<INativeClipboardReader>		ReadClipboard()override;
				Ptr<INativeClipboardWriter>		WriteClipboard()override;

				void							SetOwnerHandle(HWND handle);
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSASYNCSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSASYNCSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSASYNCSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsAsyncService : public INativeAsyncService
			{
			protected:
				struct TaskItem
				{
					Semaphore*							semaphore;
					Func<void()>						proc;

					TaskItem();
					TaskItem(Semaphore* _semaphore, const Func<void()>& _proc);
					~TaskItem();
				};

				class DelayItem : public Object, public INativeDelay
				{
				public:
					DelayItem(WindowsAsyncService* _service, const Func<void()>& _proc, bool _executeInMainThread, vint milliseconds);
					~DelayItem();

					WindowsAsyncService*				service;
					Func<void()>						proc;
					ExecuteStatus						status;
					DateTime							executeTime;
					bool								executeInMainThread;

					ExecuteStatus						GetStatus()override;
					bool								Delay(vint milliseconds)override;
					bool								Cancel()override;
				};
			protected:
				vint									mainThreadId;
				SpinLock								taskListLock;
				collections::List<TaskItem>				taskItems;
				collections::List<Ptr<DelayItem>>		delayItems;
			public:
				WindowsAsyncService();
				~WindowsAsyncService();

				void									ExecuteAsyncTasks();
				bool									IsInMainThread(INativeWindow* window)override;
				void									InvokeAsync(const Func<void()>& proc)override;
				void									InvokeInMainThread(INativeWindow* window, const Func<void()>& proc)override;
				bool									InvokeInMainThreadAndWait(INativeWindow* window, const Func<void()>& proc, vint milliseconds)override;
				Ptr<INativeDelay>						DelayExecute(const Func<void()>& proc, vint milliseconds)override;
				Ptr<INativeDelay>						DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSSCREENSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSSCREENSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSSCREENSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsScreen : public Object, public INativeScreen
			{
				friend class WindowsScreenService;
			protected:
				HMONITOR										monitor;

			public:
				WindowsScreen();

				NativeRect										GetBounds()override;
				NativeRect										GetClientBounds()override;
				WString											GetName()override;
				bool											IsPrimary()override;
				double											GetScalingX()override;
				double											GetScalingY()override;
			};

			class WindowsScreenService : public Object, public INativeScreenService
			{
				typedef HWND (*HandleRetriver)(INativeWindow*);
			protected:
				collections::List<Ptr<WindowsScreen>>			screens;
				HandleRetriver									handleRetriver;

			public:

				struct MonitorEnumProcData
				{
					WindowsScreenService*						screenService;
					vint										currentScreen;
				};

				WindowsScreenService(HandleRetriver _handleRetriver);

				static BOOL CALLBACK							MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData);
				void											RefreshScreenInformation();
				vint											GetScreenCount()override;
				INativeScreen*									GetScreen(vint index)override;
				INativeScreen*									GetScreen(INativeWindow* window)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSCALLBACKSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCALLBACKSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSCALLBACKSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsCallbackService : public Object, public INativeCallbackService
			{
			protected:
				collections::List<INativeControllerListener*>	listeners;

			public:
				WindowsCallbackService();

				bool											InstallListener(INativeControllerListener* listener)override;
				bool											UninstallListener(INativeControllerListener* listener)override;

				void											InvokeMouseHook(WPARAM message, NativePoint location);
				void											InvokeGlobalTimer();
				void											InvokeClipboardUpdated();
				void											InvokeNativeWindowCreated(INativeWindow* window);
				void											InvokeNativeWindowDestroyed(INativeWindow* window);
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSINPUTSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSINPUTSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSINPUTSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsInputService : public Object, public INativeInputService
			{
			protected:
				HWND									ownerHandle;
				HHOOK									mouseHook;
				bool									isTimerEnabled;
				HOOKPROC								mouseProc;

				collections::Array<WString>				keyNames;
				collections::Dictionary<WString, VKEY>	keys;

				WString									GetKeyNameInternal(VKEY code);
				void									InitializeKeyNames();
			public:
				WindowsInputService(HOOKPROC _mouseProc);

				void									SetOwnerHandle(HWND handle);
				void									StartHookMouse()override;
				void									StopHookMouse()override;
				bool									IsHookingMouse()override;
				void									StartTimer()override;
				void									StopTimer()override;
				bool									IsTimerEnabled()override;
				bool									IsKeyPressing(VKEY code)override;
				bool									IsKeyToggled(VKEY code)override;
				WString									GetKeyName(VKEY code)override;
				VKEY									GetKey(const WString& name)override;
			};

			extern bool									WinIsKeyPressing(VKEY code);
			extern bool									WinIsKeyToggled(VKEY code);
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\SERVICESIMPL\WINDOWSDIALOGSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Windows Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSDIALOGSERVICE
#define VCZH_PRESENTATION_WINDOWS_SERVICESIMPL_WINDOWSDIALOGSERVICE


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			class WindowsDialogService : public INativeDialogService
			{
				typedef HWND (*HandleRetriver)(INativeWindow*);
			protected:
				HandleRetriver									handleRetriver;

			public:
				WindowsDialogService(HandleRetriver _handleRetriver);

				MessageBoxButtonsOutput			ShowMessageBox(INativeWindow* window, const WString& text, const WString& title, MessageBoxButtonsInput buttons, MessageBoxDefaultButton defaultButton, MessageBoxIcons icon, MessageBoxModalOptions modal)override;
				bool							ShowColorDialog(INativeWindow* window, Color& selection, bool selected, ColorDialogCustomColorOptions customColorOptions, Color* customColors)override;
				bool							ShowFontDialog(INativeWindow* window, FontProperties& selectionFont, Color& selectionColor, bool selected, bool showEffect, bool forceFontExist)override;
				bool							ShowFileDialog(INativeWindow* window, collections::List<WString>& selectionFileNames, vint& selectionFilterIndex, FileDialogTypes dialogType, const WString& title, const WString& initialFileName, const WString& initialDirectory, const WString& defaultExtension, const WString& filter, FileDialogOptions options)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\WINDOWS\GDI\WINGDIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::GDI Provider for Windows Implementation

Interfaces:
***********************************************************************/
#ifndef VCZH_PRESENTATION_WINDOWS_GDI_WINGDIAPPLICATION
#define VCZH_PRESENTATION_WINDOWS_GDI_WINGDIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace windows
		{
			extern WinDC*									GetNativeWindowDC(INativeWindow* window);
			extern HDC										GetNativeWindowHDC(INativeWindow* window);
		}
	}
}

extern int WinMainGDI(HINSTANCE hInstance, void(*RendererMain)());

#endif
