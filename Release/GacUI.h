/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "Vlpp.h"
#include "VlppWorkflowLibrary.h"

/***********************************************************************
.\GUITYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Common Types

Classes:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUITYPES
#define VCZH_PRESENTATION_GUITYPES


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

/***********************************************************************
Enumerations
***********************************************************************/
		
		/// <summary>
		/// Defines an alignment direction.
		/// </summary>
		enum class Alignment
		{
			/// <summary>Aligned to the left side.</summary>
			Left=0,
			/// <summary>Aligned to the top side.</summary>
			Top=0,
			/// <summary>Aligned to the center.</summary>
			Center=1,
			/// <summary>Aligned to the right side.</summary>
			Right=2,
			/// <summary>Aligned to the bottom side.</summary>
			Bottom=2,
		};

		/// <summary>Axis direction.</summary>
		enum class AxisDirection
		{
			/// <summary>X:left, Y:down.</summary>
			LeftDown,
			/// <summary>X:right, Y:down.</summary>
			RightDown,
			/// <summary>X:left, Y:up.</summary>
			LeftUp,
			/// <summary>X:right, Y:up.</summary>
			RightUp,
			/// <summary>X:down, Y:left.</summary>
			DownLeft,
			/// <summary>X:down, Y:right.</summary>
			DownRight,
			/// <summary>X:up, Y:left.</summary>
			UpLeft,
			/// <summary>X:up, Y:right.</summary>
			UpRight,
		};

/***********************************************************************
TextPos
***********************************************************************/
		
		/// <summary>
		/// Represents the position in multiple lines of text.
		/// </summary>
		struct TextPos
		{
			/// <summary>
			/// Row number.
			/// </summary>
			vint			row;
			/// <summary>
			/// Column number. If a line has 4 characters, there are 5 available column numbers(from 0 to 4) in this line.
			/// </summary>
			vint			column;

			TextPos()
				:row(0) ,column(0)
			{
			}

			TextPos(vint _row, vint _column)
				:row(_row) ,column(_column)
			{
			}

			vint Compare(const TextPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const TextPos& value)const {return Compare(value)==0;}
			bool operator!=(const TextPos& value)const {return Compare(value)!=0;}
			bool operator<(const TextPos& value)const {return Compare(value)<0;}
			bool operator<=(const TextPos& value)const {return Compare(value)<=0;}
			bool operator>(const TextPos& value)const {return Compare(value)>0;}
			bool operator>=(const TextPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
GridPos
***********************************************************************/
		
		/// <summary>
		/// Represents the cell position in a grid.
		/// </summary>
		struct GridPos
		{
			/// <summary>
			/// Row number.
			/// </summary>
			vint			row;
			/// <summary>
			/// Column number. If a line has 4 characters, there are 5 available column numbers(from 0 to 4) in this line.
			/// </summary>
			vint			column;

			GridPos()
				:row(0) ,column(0)
			{
			}

			GridPos(vint _row, vint _column)
				:row(_row) ,column(_column)
			{
			}

			vint Compare(const GridPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const GridPos& value)const {return Compare(value)==0;}
			bool operator!=(const GridPos& value)const {return Compare(value)!=0;}
			bool operator<(const GridPos& value)const {return Compare(value)<0;}
			bool operator<=(const GridPos& value)const {return Compare(value)<=0;}
			bool operator>(const GridPos& value)const {return Compare(value)>0;}
			bool operator>=(const GridPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
Coordinate
***********************************************************************/

		/// <summary>
		/// Represents a position in the local window coordinate space, which is DPI awared.
		/// </summary>
		using GuiCoordinate = vint;
		
		/// <summary>
		/// Represents a position in the global screen coordinate space.
		/// </summary>
		struct NativeCoordinate
		{
			vint				value;

			NativeCoordinate() :value(0) {}
			NativeCoordinate(vint _value) :value(_value) {}
			NativeCoordinate(const NativeCoordinate& _value) = default;
			NativeCoordinate(NativeCoordinate&& _value) = default;
			NativeCoordinate& operator=(const NativeCoordinate& _value) = default;
			NativeCoordinate& operator=(NativeCoordinate&& _value) = default;

			inline bool operator==(NativeCoordinate c)const { return value == c.value; };
			inline bool operator!=(NativeCoordinate c)const { return value != c.value; };
			inline bool operator<(NativeCoordinate c)const { return value < c.value; };
			inline bool operator<=(NativeCoordinate c)const { return value <= c.value; };
			inline bool operator>(NativeCoordinate c)const { return value > c.value; };
			inline bool operator>=(NativeCoordinate c)const { return value >= c.value; };

			inline NativeCoordinate operator+(NativeCoordinate c)const { return value + c.value; };
			inline NativeCoordinate operator-(NativeCoordinate c)const { return value - c.value; };
			inline NativeCoordinate operator*(NativeCoordinate c)const { return value * c.value; };
			inline NativeCoordinate operator/(NativeCoordinate c)const { return value / c.value; };

			inline NativeCoordinate& operator+=(NativeCoordinate c) { value += c.value; return *this; };
			inline NativeCoordinate& operator-=(NativeCoordinate c) { value -= c.value; return *this; };
			inline NativeCoordinate& operator*=(NativeCoordinate c) { value *= c.value; return *this; };
			inline NativeCoordinate& operator/=(NativeCoordinate c) { value /= c.value; return *this; };
		};

/***********************************************************************
Point
***********************************************************************/
		
		/// <summary>
		/// Represents a position in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Point_
		{
			/// <summary>
			/// Position in x dimension.
			/// </summary>
			T				x;
			/// <summary>
			/// Position in y dimension.
			/// </summary>
			T				y;

			Point_()
				:x(0), y(0)
			{
			}

			Point_(T _x, T _y)
				:x(_x), y(_y)
			{
			}

			bool operator==(Point_<T> point)const
			{
				return x == point.x && y == point.y;
			}

			bool operator!=(Point_<T> point)const
			{
				return x != point.x || y != point.y;
			}
		};

		using Point = Point_<GuiCoordinate>;
		using NativePoint = Point_<NativeCoordinate>;

/***********************************************************************
Size
***********************************************************************/
		
		/// <summary>
		/// Represents a size in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Size_
		{
			/// <summary>
			/// Size in x dimension.
			/// </summary>
			T				x;
			/// <summary>
			/// Size in y dimension.
			/// </summary>
			T				y;

			Size_()
				:x(0), y(0)
			{
			}

			Size_(T _x, T _y)
				:x(_x), y(_y)
			{
			}

			bool operator==(Size_<T> size)const
			{
				return x == size.x && y == size.y;
			}

			bool operator!=(Size_<T> size)const
			{
				return x != size.x || y != size.y;
			}
		};

		using Size = Size_<GuiCoordinate>;
		using NativeSize = Size_<NativeCoordinate>;

/***********************************************************************
Rectangle
***********************************************************************/
		
		/// <summary>
		/// Represents a bounds in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Rect_
		{
			/// <summary>
			/// Left.
			/// </summary>
			T				x1;
			/// <summary>
			/// Top.
			/// </summary>
			T				y1;
			/// <summary>
			/// Left + Width.
			/// </summary>
			T				x2;
			/// <summary>
			/// Top + Height.
			/// </summary>
			T				y2;

			Rect_()
				:x1(0), y1(0), x2(0), y2(0)
			{
			}

			Rect_(T _x1, T _y1, T _x2, T _y2)
				:x1(_x1), y1(_y1), x2(_x2), y2(_y2)
			{
			}

			Rect_(Point_<T> p, Size_<T> s)
				:x1(p.x), y1(p.y), x2(p.x + s.x), y2(p.y + s.y)
			{
			}

			bool operator==(Rect_<T> rect)const
			{
				return x1 == rect.x1 && y1 == rect.y1 && x2 == rect.x2 && y2 == rect.y2;
			}

			bool operator!=(Rect_<T> rect)const
			{
				return x1 != rect.x1 || y1 != rect.y1 || x2 != rect.x2 || y2 != rect.y2;
			}

			Point_<T> LeftTop()const
			{
				return Point_<T>(x1, y1);
			}

			Point_<T> RightBottom()const
			{
				return Point_<T>(x2, y2);
			}

			Size_<T> GetSize()const
			{
				return Size_<T>(x2 - x1, y2 - y1);
			}

			T Left()const
			{
				return x1;
			}

			T Right()const
			{
				return x2;
			}

			T Width()const
			{
				return x2 - x1;
			}

			T Top()const
			{
				return y1;
			}

			T Bottom()const
			{
				return y2;
			}

			T Height()const
			{
				return y2 - y1;
			}

			void Expand(T x, T y)
			{
				x1 -= x;
				y1 -= y;
				x2 += x;
				y2 += y;
			}

			void Expand(Size_<T> s)
			{
				x1 -= s.x;
				y1 -= s.y;
				x2 += s.x;
				y2 += s.y;
			}

			void Move(T x, T y)
			{
				x1 += x;
				y1 += y;
				x2 += x;
				y2 += y;
			}

			void Move(Size_<T> s)
			{
				x1 += s.x;
				y1 += s.y;
				x2 += s.x;
				y2 += s.y;
			}

			bool Contains(Point_<T> p)
			{
				return x1 <= p.x && p.x < x2 && y1 <= p.y && p.y < y2;
			}
		};

		using Rect = Rect_<GuiCoordinate>;
		using NativeRect = Rect_<NativeCoordinate>;

/***********************************************************************
2D operations
***********************************************************************/

		template<typename T>
		inline Point_<T> operator+(Point_<T> p, Size_<T> s)
		{
			return Point_<T>(p.x + s.x, p.y + s.y);
		}

		template<typename T>
		inline Point_<T> operator+(Size_<T> s, Point_<T> p)
		{
			return Point_<T>(p.x + s.x, p.y + s.y);
		}

		template<typename T>
		inline Point_<T> operator-(Point_<T> p, Size_<T> s)
		{
			return Point_<T>(p.x - s.x, p.y - s.y);
		}

		template<typename T>
		inline Size_<T> operator-(Point_<T> p1, Point_<T> p2)
		{
			return Size_<T>(p1.x - p2.x, p1.y - p2.y);
		}

		template<typename T>
		inline Size_<T> operator+(Size_<T> s1, Size_<T> s2)
		{
			return Size_<T>(s1.x + s2.x, s1.y + s2.y);
		}

		template<typename T>
		inline Size_<T> operator-(Size_<T> s1, Size_<T> s2)
		{
			return Size_<T>(s1.x - s2.x, s1.y - s2.y);
		}

		template<typename T>
		inline Size_<T> operator*(Size_<T> s, vint i)
		{
			return Size_<T>(s.x*i, s.y*i);
		}

		template<typename T>
		inline Size_<T> operator/(Size_<T> s, vint i)
		{
			return Size_<T>(s.x / i, s.y / i);
		}

		template<typename T>
		inline Point_<T> operator+=(Point_<T>& s1, Size_<T> s2)
		{
			s1.x += s2.x;
			s1.y += s2.y;
			return s1;
		}

		template<typename T>
		inline Point_<T> operator-=(Point_<T>& s1, Size_<T> s2)
		{
			s1.x -= s2.x;
			s1.y -= s2.y;
			return s1;
		}

		template<typename T>
		inline Size_<T> operator+=(Size_<T>& s1, Size_<T> s2)
		{
			s1.x += s2.x;
			s1.y += s2.y;
			return s1;
		}

		template<typename T>
		inline Size_<T> operator-=(Size_<T>& s1, Size_<T> s2)
		{
			s1.x -= s2.x;
			s1.y -= s2.y;
			return s1;
		}

/***********************************************************************
Color
***********************************************************************/
		
		/// <summary>Represents a 32bit RGBA color. Values of separate components can be accessed using fields "r", "g", "b" and "a".</summary>
		struct Color
		{
			union
			{
				struct
				{
					unsigned char r;
					unsigned char g;
					unsigned char b;
					unsigned char a;
				};
				vuint32_t value;
			};

			Color()
				:r(0), g(0), b(0), a(255)
			{
			}

			Color(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a=255)
				:r(_r), g(_g), b(_b), a(_a)
			{
			}

			vint Compare(Color color)const
			{
				return value-color.value;
			}

			static Color Parse(const WString& value)
			{
				const wchar_t* code=L"0123456789ABCDEF";
				if((value.Length()==7 || value.Length()==9) && value[0]==L'#')
				{
					vint index[8]={15, 15, 15, 15, 15, 15, 15, 15};
					for(vint i=0;i<value.Length()-1;i++)
					{
						index[i]=wcschr(code, value[i+1])-code;
						if(index[i]<0 || index[i]>15)
						{
							return Color();
						}
					}

					Color c;
					c.r=(unsigned char)(index[0]*16+index[1]);
					c.g=(unsigned char)(index[2]*16+index[3]);
					c.b=(unsigned char)(index[4]*16+index[5]);
					c.a=(unsigned char)(index[6]*16+index[7]);
					return c;
				}
				return Color();
			}

			WString ToString()const
			{
				const wchar_t* code=L"0123456789ABCDEF";
				wchar_t result[10]=L"#00000000";
				result[1]=code[r/16];
				result[2]=code[r%16];
				result[3]=code[g/16];
				result[4]=code[g%16];
				result[5]=code[b/16];
				result[6]=code[b%16];
				if(a==255)
				{
					result[7]=L'\0';
				}
				else
				{
					result[7]=code[a/16];
					result[8]=code[a%16];
				}
				return result;
			}

			bool operator==(Color color)const {return Compare(color)==0;}
			bool operator!=(Color color)const {return Compare(color)!=0;}
			bool operator<(Color color)const {return Compare(color)<0;}
			bool operator<=(Color color)const {return Compare(color)<=0;}
			bool operator>(Color color)const {return Compare(color)>0;}
			bool operator>=(Color color)const {return Compare(color)>=0;}
		};

/***********************************************************************
Margin
***********************************************************************/
		
		/// <summary>
		/// Represents a margin in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Margin_
		{
			/// <summary>
			/// The left margin.
			/// </summary>
			T			left;
			/// <summary>
			/// The top margin.
			/// </summary>
			T			top;
			/// <summary>
			/// The right margin.
			/// </summary>
			T			right;
			/// <summary>
			/// The bottom margin.
			/// </summary>
			T			bottom;

			Margin_()
				:left(0), top(0), right(0), bottom(0)
			{
			}

			Margin_(T _left, T _top, T _right, T _bottom)
				:left(_left), top(_top), right(_right), bottom(_bottom)
			{
			}

			bool operator==(Margin_<T> margin)const
			{
				return left==margin.left && top==margin.top && right==margin.right && bottom==margin.bottom;
			}

			bool operator!=(Margin_<T> margin)const
			{
				return left!=margin.left || top!=margin.top || right!=margin.right || bottom!=margin.bottom;
			}
		};

		using Margin = Margin_<GuiCoordinate>;
		using NativeMargin = Margin_<NativeCoordinate>;

/***********************************************************************
Resources
***********************************************************************/
		
		/// <summary>
		/// Represents a font configuration.
		/// </summary>
		struct FontProperties
		{
			/// <summary>
			/// Font family (or font name, usually).
			/// </summary>
			WString				fontFamily;
			/// <summary>
			/// Font size in pixel.
			/// </summary>
			vint				size;
			/// <summary>
			/// True if the font is bold.
			/// </summary>
			bool				bold;
			/// <summary>
			/// True if the font is italic.
			/// </summary>
			bool				italic;
			/// <summary>
			/// True if the font has a underline.
			/// </summary>
			bool				underline;
			/// <summary>
			/// True if the font has a strikeline.
			/// </summary>
			bool				strikeline;
			/// <summary>
			/// True if the font has anti alias rendering.
			/// </summary>
			bool				antialias;
			/// <summary>
			/// True if the font has anti alias rendering in vertical direction.
			/// </summary>
			bool				verticalAntialias;

			FontProperties()
				:size(0)
				,bold(false)
				,italic(false)
				,underline(false)
				,strikeline(false)
				,antialias(true)
				,verticalAntialias(false)
			{
			}
			
			vint Compare(const FontProperties& value)const
			{
				vint result=0;
				
				result=WString::Compare(fontFamily, value.fontFamily);
				if(result!=0) return result;

				result=size-value.size;
				if(result!=0) return result;

				result=(vint)bold-(vint)value.bold;
				if(result!=0) return result;

				result=(vint)italic-(vint)value.italic;
				if(result!=0) return result;

				result=(vint)underline-(vint)value.underline;
				if(result!=0) return result;

				result=(vint)strikeline-(vint)value.strikeline;
				if(result!=0) return result;

				result=(vint)antialias-(vint)value.antialias;
				if(result!=0) return result;

				return 0;
			}

			bool operator==(const FontProperties& value)const {return Compare(value)==0;}
			bool operator!=(const FontProperties& value)const {return Compare(value)!=0;}
			bool operator<(const FontProperties& value)const {return Compare(value)<0;}
			bool operator<=(const FontProperties& value)const {return Compare(value)<=0;}
			bool operator>(const FontProperties& value)const {return Compare(value)>0;}
			bool operator>=(const FontProperties& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
Keys
***********************************************************************/

#define GUI_DEFINE_KEYBOARD_CODE(ITEM)											\
/*																				\
 * Virtual Keys, Standard Set													\
 */																				\
ITEM(LBUTTON,             0x01)													\
ITEM(RBUTTON,             0x02)													\
ITEM(CANCEL,              0x03)													\
ITEM(MBUTTON,             0x04)		/* NOT contiguous with L & RBUTTON */		\
ITEM(XBUTTON1,            0x05)		/* NOT contiguous with L & RBUTTON */		\
ITEM(XBUTTON2,            0x06)		/* NOT contiguous with L & RBUTTON */		\
ITEM(BACK,                0x08)													\
ITEM(TAB,                 0x09)													\
ITEM(CLEAR,               0x0C)													\
ITEM(RETURN,              0x0D)													\
ITEM(SHIFT,               0x10)													\
ITEM(CONTROL,             0x11)													\
ITEM(MENU,                0x12)													\
ITEM(PAUSE,               0x13)													\
ITEM(CAPITAL,             0x14)													\
ITEM(KANA_HANGUL,         0x15)													\
ITEM(JUNJA,               0x17)													\
ITEM(FINAL,               0x18)													\
ITEM(HANJA,               0x19)													\
ITEM(KANJI,               0x19)													\
ITEM(ESCAPE,              0x1B)													\
ITEM(CONVERT,             0x1C)													\
ITEM(NONCONVERT,          0x1D)													\
ITEM(ACCEPT,              0x1E)													\
ITEM(MODECHANGE,          0x1F)													\
ITEM(SPACE,               0x20)													\
ITEM(PRIOR,               0x21)													\
ITEM(NEXT,                0x22)													\
ITEM(END,                 0x23)													\
ITEM(HOME,                0x24)													\
ITEM(LEFT,                0x25)													\
ITEM(UP,                  0x26)													\
ITEM(RIGHT,               0x27)													\
ITEM(DOWN,                0x28)													\
ITEM(SELECT,              0x29)													\
ITEM(PRINT,               0x2A)													\
ITEM(EXECUTE,             0x2B)													\
ITEM(SNAPSHOT,            0x2C)													\
ITEM(INSERT,              0x2D)													\
ITEM(DELETE,              0x2E)													\
ITEM(HELP,                0x2F)													\
/*																				\
 * VKEY_0 - VKEY_9 are the same as ASCII '0' - '9' (0x30 - 0x39)				\
 * VKEY_A - VKEY_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)				\
 */																				\
ITEM(0,                   0x30)													\
ITEM(1,                   0x31)													\
ITEM(2,                   0x32)													\
ITEM(3,                   0x33)													\
ITEM(4,                   0x34)													\
ITEM(5,                   0x35)													\
ITEM(6,                   0x36)													\
ITEM(7,                   0x37)													\
ITEM(8,                   0x38)													\
ITEM(9,                   0x39)													\
ITEM(A,                   0x41)													\
ITEM(B,                   0x42)													\
ITEM(C,                   0x43)													\
ITEM(D,                   0x44)													\
ITEM(E,                   0x45)													\
ITEM(F,                   0x46)													\
ITEM(G,                   0x47)													\
ITEM(H,                   0x48)													\
ITEM(I,                   0x49)													\
ITEM(J,                   0x4A)													\
ITEM(K,                   0x4B)													\
ITEM(L,                   0x4C)													\
ITEM(M,                   0x4D)													\
ITEM(N,                   0x4E)													\
ITEM(O,                   0x4F)													\
ITEM(P,                   0x50)													\
ITEM(Q,                   0x51)													\
ITEM(R,                   0x52)													\
ITEM(S,                   0x53)													\
ITEM(T,                   0x54)													\
ITEM(U,                   0x55)													\
ITEM(V,                   0x56)													\
ITEM(W,                   0x57)													\
ITEM(X,                   0x58)													\
ITEM(Y,                   0x59)													\
ITEM(Z,                   0x5A)													\
ITEM(LWIN,                0x5B)													\
ITEM(RWIN,                0x5C)													\
ITEM(APPS,                0x5D)													\
ITEM(SLEEP,               0x5F)													\
ITEM(NUMPAD0,             0x60)													\
ITEM(NUMPAD1,             0x61)													\
ITEM(NUMPAD2,             0x62)													\
ITEM(NUMPAD3,             0x63)													\
ITEM(NUMPAD4,             0x64)													\
ITEM(NUMPAD5,             0x65)													\
ITEM(NUMPAD6,             0x66)													\
ITEM(NUMPAD7,             0x67)													\
ITEM(NUMPAD8,             0x68)													\
ITEM(NUMPAD9,             0x69)													\
ITEM(MULTIPLY,            0x6A)													\
ITEM(ADD,                 0x6B)													\
ITEM(SEPARATOR,           0x6C)													\
ITEM(SUBTRACT,            0x6D)													\
ITEM(DECIMAL,             0x6E)													\
ITEM(DIVIDE,              0x6F)													\
ITEM(F1,                  0x70)													\
ITEM(F2,                  0x71)													\
ITEM(F3,                  0x72)													\
ITEM(F4,                  0x73)													\
ITEM(F5,                  0x74)													\
ITEM(F6,                  0x75)													\
ITEM(F7,                  0x76)													\
ITEM(F8,                  0x77)													\
ITEM(F9,                  0x78)													\
ITEM(F10,                 0x79)													\
ITEM(F11,                 0x7A)													\
ITEM(F12,                 0x7B)													\
ITEM(F13,                 0x7C)													\
ITEM(F14,                 0x7D)													\
ITEM(F15,                 0x7E)													\
ITEM(F16,                 0x7F)													\
ITEM(F17,                 0x80)													\
ITEM(F18,                 0x81)													\
ITEM(F19,                 0x82)													\
ITEM(F20,                 0x83)													\
ITEM(F21,                 0x84)													\
ITEM(F22,                 0x85)													\
ITEM(F23,                 0x86)													\
ITEM(F24,                 0x87)													\
ITEM(NUMLOCK,             0x90)													\
ITEM(SCROLL,              0x91)													\
/*																				\
 * NEC PC-9800 kbd definitions													\
 */																				\
ITEM(OEM_NEC_EQUAL,       0x92)		/* '=' key on numpad */						\
/*																				\
 * Fujitsu/OASYS kbd definitions												\
 */																				\
ITEM(OEM_FJ_JISHO,        0x92)		/* 'Dictionary' key */						\
ITEM(OEM_FJ_MASSHOU,      0x93)		/* 'Unregister word' key */					\
ITEM(OEM_FJ_TOUROKU,      0x94)		/* 'Register word' key */					\
ITEM(OEM_FJ_LOYA,         0x95)		/* 'Left OYAYUBI' key */					\
ITEM(OEM_FJ_ROYA,         0x96)		/* 'Right OYAYUBI' key */					\
/*																				\
 * VKEY_L* & VKEY_R* - left and right Alt, Ctrl and Shift virtual keys.			\
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().				\
 * No other API or message will distinguish left and right keys in this way.	\
 */																				\
ITEM(LSHIFT,              0xA0)													\
ITEM(RSHIFT,              0xA1)													\
ITEM(LCONTROL,            0xA2)													\
ITEM(RCONTROL,            0xA3)													\
ITEM(LMENU,               0xA4)													\
ITEM(RMENU,               0xA5)													\
ITEM(BROWSER_BACK,        0xA6)													\
ITEM(BROWSER_FORWARD,     0xA7)													\
ITEM(BROWSER_REFRESH,     0xA8)													\
ITEM(BROWSER_STOP,        0xA9)													\
ITEM(BROWSER_SEARCH,      0xAA)													\
ITEM(BROWSER_FAVORITES,   0xAB)													\
ITEM(BROWSER_HOME,        0xAC)													\
ITEM(VOLUME_MUTE,         0xAD)													\
ITEM(VOLUME_DOWN,         0xAE)													\
ITEM(VOLUME_UP,           0xAF)													\
ITEM(MEDIA_NEXT_TRACK,    0xB0)													\
ITEM(MEDIA_PREV_TRACK,    0xB1)													\
ITEM(MEDIA_STOP,          0xB2)													\
ITEM(MEDIA_PLAY_PAUSE,    0xB3)													\
ITEM(LAUNCH_MAIL,         0xB4)													\
ITEM(LAUNCH_MEDIA_SELECT, 0xB5)													\
ITEM(LAUNCH_APP1,         0xB6)													\
ITEM(LAUNCH_APP2,         0xB7)													\
ITEM(OEM_1,               0xBA)		/* ';:' for US */							\
ITEM(OEM_PLUS,            0xBB)		/* '+' any country */						\
ITEM(OEM_COMMA,           0xBC)		/* ',' any country */						\
ITEM(OEM_MINUS,           0xBD)		/* '-' any country */						\
ITEM(OEM_PERIOD,          0xBE)		/* '.' any country */						\
ITEM(OEM_2,               0xBF)		/* '/?' for US */							\
ITEM(OEM_3,               0xC0)		/* '`~' for US */							\
ITEM(OEM_4,               0xDB)		/* '[{' for US */							\
ITEM(OEM_5,               0xDC)		/* '\|' for US */							\
ITEM(OEM_6,               0xDD)		/* ']}' for US */							\
ITEM(OEM_7,               0xDE)		/* ''"' for US */							\
ITEM(OEM_8,               0xDF)													\
/*																				\
 * Various extended or enhanced keyboards										\
 */																				\
ITEM(OEM_AX,              0xE1)		/* 'AX' key on Japanese AX kbd */			\
ITEM(OEM_102,             0xE2)		/* "<>" or "\|" on RT 102-key kbd */		\
ITEM(ICO_HELP,            0xE3)		/* Help key on ICO */						\
ITEM(ICO_00,              0xE4)		/* 00 key on ICO */							\
ITEM(PROCESSKEY,          0xE5)													\
ITEM(ICO_CLEAR,           0xE6)													\
ITEM(PACKET,              0xE7)													\
/*																				\
 * Nokia/Ericsson definitions													\
 */																				\
ITEM(OEM_RESET,           0xE9)													\
ITEM(OEM_JUMP,            0xEA)													\
ITEM(OEM_PA1,             0xEB)													\
ITEM(OEM_PA2,             0xEC)													\
ITEM(OEM_PA3,             0xED)													\
ITEM(OEM_WSCTRL,          0xEE)													\
ITEM(OEM_CUSEL,           0xEF)													\
ITEM(OEM_ATTN,            0xF0)													\
ITEM(OEM_FINISH,          0xF1)													\
ITEM(OEM_COPY,            0xF2)													\
ITEM(OEM_AUTO,            0xF3)													\
ITEM(OEM_ENLW,            0xF4)													\
ITEM(OEM_BACKTAB,         0xF5)													\
ITEM(ATTN,                0xF6)													\
ITEM(CRSEL,               0xF7)													\
ITEM(EXSEL,               0xF8)													\
ITEM(EREOF,               0xF9)													\
ITEM(PLAY,                0xFA)													\
ITEM(ZOOM,                0xFB)													\
ITEM(NONAME,              0xFC)													\
ITEM(PA1,                 0xFD)													\
ITEM(OEM_CLEAR,           0xFE)													\
/*																				\
 * Friendly names for common keys (US)											\
 */																				\
ITEM(SEMICOLON,           0xBA)		/* OEM_1 */									\
ITEM(SLASH,               0xBF)		/* OEM_2 */									\
ITEM(GRAVE_ACCENT,        0xC0)		/* OEM_3 */									\
ITEM(RIGHT_BRACKET,       0xDB)		/* OEM_4 */									\
ITEM(BACKSLASH,           0xDC)		/* OEM_5 */									\
ITEM(LEFT_BRACKET,        0xDD)		/* OEM_6 */									\
ITEM(APOSTROPHE,          0xDE)		/* OEM_7 */									\

#define GUI_DEFINE_KEYBOARD_CODE_ENUM_ITEM(NAME, CODE) _##NAME = CODE,
		enum class VKEY
		{
			_UNKNOWN = -1,
			GUI_DEFINE_KEYBOARD_CODE(GUI_DEFINE_KEYBOARD_CODE_ENUM_ITEM)
		};
#undef GUI_DEFINE_KEYBOARD_CODE_ENUM_ITEM
		static bool operator == (VKEY a, VKEY b) { return (vint)a == (vint)b; }
		static bool operator != (VKEY a, VKEY b) { return (vint)a != (vint)b; }
		static bool operator <  (VKEY a, VKEY b) { return (vint)a <  (vint)b; }
		static bool operator <= (VKEY a, VKEY b) { return (vint)a <= (vint)b; }
		static bool operator >  (VKEY a, VKEY b) { return (vint)a >  (vint)b; }
		static bool operator >= (VKEY a, VKEY b) { return (vint)a >= (vint)b; }
		static VKEY operator &  (VKEY a, VKEY b) { return (VKEY)((vint)a & (vint)b); }
		static VKEY operator |  (VKEY a, VKEY b) { return (VKEY)((vint)a | (vint)b); }

	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSAXIS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSAXIS
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSAXIS


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Axis Interface
***********************************************************************/

			/// <summary>Represents the four directions that is accessable by keyboard.</summary>
			enum class KeyDirection
			{
				/// <summary>The up direction.</summary>
				Up,
				/// <summary>The down direction.</summary>
				Down,
				/// <summary>The left direction.</summary>
				Left,
				/// <summary>The right direction.</summary>
				Right,
				/// <summary>The home direction.</summary>
				Home,
				/// <summary>The end direction.</summary>
				End,
				/// <summary>The page up direction.</summary>
				PageUp,
				/// <summary>The page down direction.</summary>
				PageDown,
				/// <summary>The page left direction.</summary>
				PageLeft,
				/// <summary>The page right direction.</summary>
				PageRight,
			};
				
			/// <summary>Item coordinate transformer for a <see cref="GuiListControl"/>. In all functions in this interface, real coordinate is in the list control's container space, virtual coordinate is in a space that the transformer created.</summary>
			class IGuiAxis : public virtual IDescriptable, public Description<IGuiAxis>
			{
			public:
				/// <summary>Translate real size to virtual size.</summary>
				/// <returns>The virtual size.</returns>
				/// <param name="size">The real size.</param>
				virtual Size								RealSizeToVirtualSize(Size size)=0;
				/// <summary>Translate virtual size to real size.</summary>
				/// <returns>The real size.</returns>
				/// <param name="size">The virtual size.</param>
				virtual Size								VirtualSizeToRealSize(Size size)=0;
				/// <summary>Translate real point to virtual point.</summary>
				/// <returns>The virtual point.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="point">The real point.</param>
				virtual Point								RealPointToVirtualPoint(Size realFullSize, Point point)=0;
				/// <summary>Translate virtual point to real point.</summary>
				/// <returns>The real point.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="point">The virtual point.</param>
				virtual Point								VirtualPointToRealPoint(Size realFullSize, Point point)=0;
				/// <summary>Translate real bounds to virtual bounds.</summary>
				/// <returns>The virtual bounds.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="rect">The real bounds.</param>
				virtual Rect								RealRectToVirtualRect(Size realFullSize, Rect rect)=0;
				/// <summary>Translate virtual bounds to real bounds.</summary>
				/// <returns>The real bounds.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="rect">The virtual bounds.</param>
				virtual Rect								VirtualRectToRealRect(Size realFullSize, Rect rect)=0;
				/// <summary>Translate real margin to margin size.</summary>
				/// <returns>The virtual margin.</returns>
				/// <param name="margin">The real margin.</param>
				virtual Margin								RealMarginToVirtualMargin(Margin margin)=0;
				/// <summary>Translate virtual margin to margin size.</summary>
				/// <returns>The real margin.</returns>
				/// <param name="margin">The virtual margin.</param>
				virtual Margin								VirtualMarginToRealMargin(Margin margin)=0;
				/// <summary>Translate real key direction to virtual key direction.</summary>
				/// <returns>The virtual key direction.</returns>
				/// <param name="key">The real key direction.</param>
				virtual KeyDirection						RealKeyDirectionToVirtualKeyDirection(KeyDirection key)=0;
			};

/***********************************************************************
Axis Implementation
***********************************************************************/

			/// <summary>Default item coordinate transformer. This transformer doesn't transform any coordinate.</summary>
			class GuiDefaultAxis : public Object, virtual public IGuiAxis, public Description<GuiDefaultAxis>
			{
			public:
				/// <summary>Create the transformer.</summary>
				GuiDefaultAxis();
				~GuiDefaultAxis();

				Size										RealSizeToVirtualSize(Size size)override;
				Size										VirtualSizeToRealSize(Size size)override;
				Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
				Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
				Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
				Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
				Margin										RealMarginToVirtualMargin(Margin margin)override;
				Margin										VirtualMarginToRealMargin(Margin margin)override;
				KeyDirection								RealKeyDirectionToVirtualKeyDirection(KeyDirection key)override;
			};
				
			/// <summary>Axis aligned item coordinate transformer. This transformer transforms coordinates by changing the axis direction.</summary>
			class GuiAxis : public Object, virtual public IGuiAxis, public Description<GuiAxis>
			{
			protected:
				AxisDirection								axisDirection;

			public:
				/// <summary>Create the transformer with a specified axis direction.</summary>
				/// <param name="_axisDirection">The specified axis direction.</param>
				GuiAxis(AxisDirection _axisDirection);
				~GuiAxis();

				/// <summary>Get the specified axis direction.</summary>
				/// <returns>The specified axis direction.</returns>
				AxisDirection								GetDirection();
				Size										RealSizeToVirtualSize(Size size)override;
				Size										VirtualSizeToRealSize(Size size)override;
				Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
				Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
				Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
				Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
				Margin										RealMarginToVirtualMargin(Margin margin)override;
				Margin										VirtualMarginToRealMargin(Margin margin)override;
				KeyDirection								RealKeyDirectionToVirtualKeyDirection(KeyDirection key)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSELEMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsComposition;

			extern void											InvokeOnCompositionStateChanged(compositions::GuiGraphicsComposition* composition);
		}

		namespace elements
		{
			class IGuiGraphicsElement;
			class IGuiGraphicsElementFactory;
			class IGuiGraphicsRenderer;
			class IGuiGraphicsRendererFactory;
			class IGuiGraphicsRenderTarget;

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// This is the interface for graphics elements.
			/// Graphics elements usually contains some information and helper functions for visible things.
			/// An graphics elements should be created using ElementType::Create.
			/// </summary>
			class IGuiGraphicsElement : public virtual IDescriptable, public Description<IGuiGraphicsElement>
			{
				friend class compositions::GuiGraphicsComposition;
			protected:

				virtual void									SetOwnerComposition(compositions::GuiGraphicsComposition* composition) = 0;
			public:
				/// <summary>
				/// Access the <see cref="IGuiGraphicsElementFactory"></see> that is used to create this graphics elements.
				/// </summary>
				/// <returns>Returns the related factory.</returns>
				virtual IGuiGraphicsElementFactory*				GetFactory() = 0;
				/// <summary>
				/// Access the associated <see cref="IGuiGraphicsRenderer"></see> for this graphics element.
				/// </summary>
				/// <returns>Returns the related renderer.</returns>
				virtual IGuiGraphicsRenderer*					GetRenderer() = 0;
				/// <summary>
				/// Get the owner composition.
				/// </summary>
				/// <returns>The owner composition.</returns>
				virtual compositions::GuiGraphicsComposition*	GetOwnerComposition() = 0;
			};

			/// <summary>
			/// This is the interface for graphics element factories.
			/// Graphics element factories should be registered using [M:vl.presentation.elements.GuiGraphicsResourceManager.RegisterElementFactory].
			/// </summary>
			class IGuiGraphicsElementFactory : public Interface
			{
			public:
				/// <summary>
				/// Get the name representing the kind of graphics element to be created.
				/// </summary>
				/// <returns>Returns the name of graphics elements.</returns>
				virtual WString							GetElementTypeName()=0;
				/// <summary>
				/// Create a <see cref="IGuiGraphicsElement"></see>.
				/// </summary>
				/// <returns>Returns the created graphics elements.</returns>
				virtual IGuiGraphicsElement*			Create()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderers.
			/// </summary>
			class IGuiGraphicsRenderer : public Interface
			{
			public:
				/// <summary>
				/// Access the graphics <see cref="IGuiGraphicsRendererFactory"></see> that is used to create this graphics renderer.
				/// </summary>
				/// <returns>Returns the related factory.</returns>
				virtual IGuiGraphicsRendererFactory*	GetFactory()=0;

				/// <summary>
				/// Initialize the grpahics renderer by binding a <see cref="IGuiGraphicsElement"></see> to it.
				/// </summary>
				/// <param name="element">The graphics element to bind.</param>
				virtual void							Initialize(IGuiGraphicsElement* element)=0;
				/// <summary>
				/// Release all resources that used by this renderer.
				/// </summary>
				virtual void							Finalize()=0;
				/// <summary>
				/// Set a <see cref="IGuiGraphicsRenderTarget"></see> to this element.
				/// </summary>
				/// <param name="renderTarget">The graphics render target. It can be NULL.</param>
				virtual void							SetRenderTarget(IGuiGraphicsRenderTarget* renderTarget)=0;
				/// <summary>
				/// Render the graphics element using a specified bounds.
				/// </summary>
				/// <param name="bounds">Bounds to decide the size and position of the binded graphics element.</param>
				virtual void							Render(Rect bounds)=0;
				/// <summary>
				/// Notify that the state in the binded graphics element is changed. This function is usually called by the element itself.
				/// </summary>
				virtual void							OnElementStateChanged()=0;
				/// <summary>
				/// Calculate the minimum size using the binded graphics element and its state.
				/// </summary>
				/// <returns>The minimum size.</returns>
				virtual Size							GetMinSize()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderer factories.
			/// Graphics renderers should be registered using [M:vl.presentation.elements.GuiGraphicsResourceManager.RegisterRendererFactory]. 
			/// </summary>
			class IGuiGraphicsRendererFactory : public Interface
			{
			public:
				/// <summary>
				/// Create a <see cref="IGuiGraphicsRenderer"></see>.
				/// </summary>
				/// <returns>Returns the created graphics renderer.</returns>
				virtual IGuiGraphicsRenderer*			Create()=0;
			};

			enum RenderTargetFailure
			{
				None,
				ResizeWhileRendering,
				LostDevice,
			};

			/// <summary>
			/// This is the interface for graphics renderer targets.
			/// </summary>
			class IGuiGraphicsRenderTarget : public Interface
			{
			public:
				/// <summary>
				/// Notify the target to prepare for rendering.
				/// </summary>
				virtual void							StartRendering()=0;
				/// <summary>
				/// Notify the target to stop rendering.
				/// </summary>
				/// <returns>Returns false to recreate render target.</returns>
				virtual RenderTargetFailure				StopRendering()=0;
				/// <summary>
				/// Apply a clipper to the render target.
				/// The result clipper is combined by all clippers in the clipper stack maintained by the render target.
				/// </summary>
				/// <param name="clipper">The clipper to push.</param>
				virtual void							PushClipper(Rect clipper)=0;
				/// <summary>
				/// Remove the last pushed clipper from the clipper stack.
				/// </summary>
				virtual void							PopClipper()=0;
				/// <summary>
				/// Get the combined clipper
				/// </summary>
				/// <returns>The combined clipper</returns>
				virtual Rect							GetClipper()=0;
				/// <summary>
				/// Test is the combined clipper is as large as the render target.
				/// </summary>
				/// <returns>Return true if the combined clipper is as large as the render target.</returns>
				virtual bool							IsClipperCoverWholeTarget()=0;
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\GUINATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window

Interfaces:
  INativeController						: Interface for Operating System abstraction

Renderers:
  GUI_GRAPHICS_RENDERER_GDI
  GUI_GRAPHICS_RENDERER_DIRECT2D
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUINATIVEWINDOW
#define VCZH_PRESENTATION_GUINATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		class GuiImageData;
		class DocumentModel;
		class INativeWindow;
		class INativeWindowListener;
		class INativeController;
		class INativeControllerListener;

/***********************************************************************
System Object
***********************************************************************/

		/// <summary>
		/// Represents a screen.
		/// </summary>
		class INativeScreen : public virtual IDescriptable, public Description<INativeScreen>
		{
		public:
			/// <summary>
			/// Get the bounds of the screen.
			/// </summary>
			/// <returns>The bounds of the screen.</returns>
			virtual NativeRect			GetBounds()=0;
			/// <summary>
			/// Get the bounds of the screen client area.
			/// </summary>
			/// <returns>The bounds of the screen client area.</returns>
			virtual NativeRect			GetClientBounds()=0;
			/// <summary>
			/// Get the name of the screen.
			/// </summary>
			/// <returns>The name of the screen.</returns>
			virtual WString				GetName()=0;
			/// <summary>
			/// Test is the screen is a primary screen.
			/// </summary>
			/// <returns>Returns true if the screen is a primary screen.</returns>
			virtual bool				IsPrimary()=0;
			/// <summary>
			/// Get the scaling for the screen's horizontal edge. For example, in Windows when you have a 96 DPI, this function returns 1.0.
			/// </summary>
			virtual double				GetScalingX() = 0;
			/// <summary>
			/// Get the scaling for the screen's vertical edge. For example, in Windows when you have a 96 DPI, this function returns 1.0.
			/// </summary>
			virtual double				GetScalingY() = 0;
		};
		
		/// <summary>
		/// Represents a cursor.
		/// </summary>
		class INativeCursor : public virtual IDescriptable, public Description<INativeCursor>
		{
		public:
			/// <summary>
			/// Represents a predefined cursor type.
			/// </summary>
			enum SystemCursorType
			{
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Small waiting cursor.
				/// </summary>
				SmallWaiting,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]large waiting cursor.
				/// </summary>
				LargeWaiting,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Arrow cursor.
				/// </summary>
				Arrow,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Cross cursor.
				/// </summary>
				Cross,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Hand cursor.
				/// </summary>
				Hand,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Help cursor.
				/// </summary>
				Help,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]I beam cursor.
				/// </summary>
				IBeam,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing in all direction cursor.
				/// </summary>
				SizeAll,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing NE-SW cursor.
				/// </summary>
				SizeNESW,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing N-S cursor.
				/// </summary>
				SizeNS,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing NW-SE cursor.
				/// </summary>
				SizeNWSE,
				/// <summary>
				/// [T:vl.presentation.INativeCursor.SystemCursorType]Sizing W-E cursor.
				/// </summary>
				SizeWE,
				LastSystemCursor=SizeWE,
			};

			static const vint			SystemCursorCount=LastSystemCursor+1;
		public:
			/// <summary>
			/// Test is the cursor a system provided cursor.
			/// </summary>
			/// <returns>Returns true if the cursor a system provided cursor.</returns>
			virtual bool				IsSystemCursor()=0;
			/// <summary>
			/// Get the cursor type if the cursor a system provided cursor.
			/// </summary>
			/// <returns>The cursor type.</returns>
			virtual SystemCursorType	GetSystemCursorType()=0;
		};

/***********************************************************************
Image Object
***********************************************************************/

		class INativeImageService;
		class INativeImage;
		class INativeImageFrame;
		
		/// <summary>
		/// Represents a customized cache object for an image frame.
		/// </summary>
		class INativeImageFrameCache : public Interface
		{
		public:
			/// <summary>
			/// Called when this cache object is attached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that attached to.</param>
			virtual void						OnAttach(INativeImageFrame* frame)=0;
			/// <summary>
			/// Called when this cache object is detached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that detached from.</param>
			virtual void						OnDetach(INativeImageFrame* frame)=0;
		};

		/// <summary>
		/// Represents an image frame.
		/// </summary>
		class INativeImageFrame : public virtual IDescriptable, public Description<INativeImageFrame>
		{
		public:
			/// <summary>
			/// Get the image that owns this frame.
			/// </summary>
			/// <returns>The image that owns this frame.</returns>
			virtual INativeImage*				GetImage()=0;
			/// <summary>
			/// Get the size of this frame.
			/// </summary>
			/// <returns>The size of this frame.</returns>
			virtual Size						GetSize()=0;

			/// <summary>
			/// Attach a customized cache object to this image frame and bind to a key.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			/// <param name="cache">The customized cache object.</param>
			virtual bool						SetCache(void* key, Ptr<INativeImageFrameCache> cache)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key.
			/// </summary>
			/// <returns>The attached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	GetCache(void* key)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key, and then detach it.
			/// </summary>
			/// <returns>The detached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	RemoveCache(void* key)=0;
		};
		
		/// <summary>
		/// Represents an image.
		/// </summary>
		class INativeImage : public virtual IDescriptable, public Description<INativeImage>
		{
		public:
			/// <summary>
			/// Represents an image format.
			/// </summary>
			enum FormatType
			{
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Bitmap format.
				/// </summary>
				Bmp,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]GIF format.
				/// </summary>
				Gif,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Icon format.
				/// </summary>
				Icon,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]JPEG format.
				/// </summary>
				Jpeg,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]PNG format.
				/// </summary>
				Png,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]TIFF format.
				/// </summary>
				Tiff,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]WMP format.
				/// </summary>
				Wmp,
				/// <summary>
				/// [T:vl.presentation.INativeImage.FormatType]Unknown format.
				/// </summary>
				Unknown,
			};
			
			/// <summary>
			/// Get the image service that creates this image.
			/// </summary>
			/// <returns>The image service that creates this image.</returns>
			virtual INativeImageService*		GetImageService()=0;
			/// <summary>
			/// Get the image format.
			/// </summary>
			/// <returns>The image format.</returns>
			virtual FormatType					GetFormat()=0;
			/// <summary>
			/// Get the number of frames in this image.
			/// </summary>
			/// <returns>The number of frames in this image.</returns>
			virtual vint						GetFrameCount()=0;
			/// <summary>
			/// Get the frame in this image by a specified frame index.
			/// </summary>
			/// <returns>The frame in this image by a specified frame index.</returns>
			/// <param name="index">The specified frame index.</param>
			virtual INativeImageFrame*			GetFrame(vint index)=0;
			/// <summary>
			/// Save the image to a stream.
			/// </summary>
			/// <param name="stream">The stream.</param>
			/// <param name="formatType">The format of the image.</param>
			virtual void						SaveToStream(stream::IStream& stream, FormatType formatType = FormatType::Unknown) = 0;
		};
		
		/// <summary>
		/// Image service. To access this service, use [M:vl.presentation.INativeController.ImageService].
		/// </summary>
		class INativeImageService : public virtual IDescriptable, public Description<INativeImageService>
		{
		public:
			/// <summary>
			/// Create an image from file.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="path">The file path.</param>
			virtual Ptr<INativeImage>			CreateImageFromFile(const WString& path)=0;

			/// <summary>
			/// Create an image from memory.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="buffer">The memory pointer.</param>
			/// <param name="length">The memory length.</param>
			virtual Ptr<INativeImage>			CreateImageFromMemory(void* buffer, vint length)=0;

			/// <summary>
			/// Create an image from stream.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="stream">The stream.</param>
			virtual Ptr<INativeImage>			CreateImageFromStream(stream::IStream& stream)=0;
		};

/***********************************************************************
Native Window
***********************************************************************/
		
		/// <summary>
		/// Represents a window.
		/// </summary>
		class INativeWindow : public Interface, public Description<INativeWindow>
		{
		public:
			/// <summary>
			/// Convert point from native coordinate to GUI coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual Point				Convert(NativePoint value) = 0;
			/// <summary>
			/// Convert point from GUI coordinate to native coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual NativePoint			Convert(Point value) = 0;
			/// <summary>
			/// Convert size from native coordinate to GUI coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual Size				Convert(NativeSize value) = 0;
			/// <summary>
			/// Convert size from GUI coordinate to native coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual NativeSize			Convert(Size value) = 0;
			/// <summary>
			/// Convert margin from native coordinate to GUI coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual Margin				Convert(NativeMargin value) = 0;
			/// <summary>
			/// Convert margin from GUI coordinate to native coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual NativeMargin		Convert(Margin value) = 0;

			/// <summary>
			/// Get the bounds of the window.
			/// </summary>
			/// <returns>The bounds of the window.</returns>
			virtual NativeRect			GetBounds()=0;
			/// <summary>
			/// Set the bounds of the window.
			/// </summary>
			/// <param name="bounds">The bounds of the window.</param>
			virtual void				SetBounds(const NativeRect& bounds)=0;
			/// <summary>
			/// Get the client size of the window.
			/// </summary>
			/// <returns>The client size of the window.</returns>
			virtual NativeSize			GetClientSize()=0;
			/// <summary>
			/// Set the client size of the window.
			/// </summary>
			/// <param name="size">The client size of the window.</param>
			virtual void				SetClientSize(NativeSize size)=0;
			/// <summary>
			/// Get the client bounds in screen space.
			/// </summary>
			/// <returns>The client bounds in screen space.</returns>
			virtual NativeRect			GetClientBoundsInScreen()=0;
			
			/// <summary>
			/// Get the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <returns>The title of the window.</returns>
			virtual WString				GetTitle()=0;
			/// <summary>
			/// Set the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <param name="title">The title of the window.</param>
			virtual void				SetTitle(WString title)=0;
			/// <summary>
			/// Get the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <returns>The mouse cursor of the window.</returns>
			virtual INativeCursor*		GetWindowCursor()=0;
			/// <summary>
			/// Set the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <param name="cursor">The mouse cursor of the window.</param>
			virtual void				SetWindowCursor(INativeCursor* cursor)=0;
			/// <summary>
			/// Get the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <returns>The caret point of the window.</returns>
			virtual NativePoint			GetCaretPoint()=0;
			/// <summary>
			/// Set the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <param name="point">The caret point of the window.</param>
			virtual void				SetCaretPoint(NativePoint point)=0;
			
			/// <summary>
			/// Get the parent window. A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <returns>The parent window.</returns>
			virtual INativeWindow*		GetParent()=0;
			/// <summary>
			/// Set the parent window. A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <param name="parent">The parent window.</param>
			virtual void				SetParent(INativeWindow* parent)=0;
			/// <summary>
			/// Test is the window always pass the focus to its parent window.
			/// </summary>
			/// <returns>Returns true if the window always pass the focus to its parent window.</returns>
			virtual bool				GetAlwaysPassFocusToParent()=0;
			/// <summary>
			/// Enable or disble always passing the focus to its parent window.
			/// </summary>
			/// <param name="value">True to enable always passing the focus to its parent window.</param>
			virtual void				SetAlwaysPassFocusToParent(bool value)=0;

			/// <summary>
			/// Enable the window customized frame mode.
			/// </summary>
			virtual void				EnableCustomFrameMode()=0;
			/// <summary>
			/// Disable the window customized frame mode.
			/// </summary>
			virtual void				DisableCustomFrameMode()=0;
			/// <summary>
			/// Test is the window customized frame mode enabled.
			/// </summary>
			/// <returns>Returns true if the window customized frame mode is enabled.</returns>
			virtual bool				IsCustomFrameModeEnabled()=0;
			/// <summary>
			/// Get the amount of the border. The window template may need this value to calculate where to put the client area.
			/// </summary>
			/// <returns>Returns the amount of the border.</returns>
			virtual NativeMargin		GetCustomFramePadding() = 0;

			/// <summary>Window size state.</summary>
			enum WindowSizeState
			{
				/// <summary>Minimized.</summary>
				Minimized,
				/// <summary>Restored.</summary>
				Restored,
				/// <summary>Maximized.</summary>
				Maximized,
			};

			/// <summary>
			/// Get the icon.
			/// </summary>
			/// <returns>Returns the icon.</returns>
			virtual Ptr<GuiImageData>	GetIcon()=0;
			/// <summary>
			/// Set the icon.
			/// </summary>
			/// <param name="icon">The icon. Set to null to use the default icon.</param>
			virtual void				SetIcon(Ptr<GuiImageData> icon)=0;

			/// <summary>
			/// Get the window size state.
			/// </summary>
			/// <returns>Returns the window size state.</returns>
			virtual WindowSizeState		GetSizeState()=0;
			/// <summary>
			/// Show the window.
			/// </summary>
			virtual void				Show()=0;
			/// <summary>
			/// Show the window without activation.
			/// </summary>
			virtual void				ShowDeactivated()=0;
			/// <summary>
			/// Restore the window.
			/// </summary>
			virtual void				ShowRestored()=0;
			/// <summary>
			/// Maximize the window.
			/// </summary>
			virtual void				ShowMaximized()=0;
			/// <summary>
			/// Minimize the window.
			/// </summary>
			virtual void				ShowMinimized()=0;
			/// <summary>
			/// Hide the window.
			/// </summary>
			/// <param name="closeWindow">Set to true to really close the window. Or the window will just be hidden. This parameter only affect the main window.</param>
			virtual void				Hide(bool closeWindow)=0;
			/// <summary>
			/// Test is the window visible.
			/// </summary>
			/// <returns>Returns true if the window is visible.</returns>
			virtual bool				IsVisible()=0;

			/// <summary>
			/// Enable the window.
			/// </summary>
			virtual void				Enable()=0;
			/// <summary>
			/// Disable the window.
			/// </summary>
			virtual void				Disable()=0;
			/// <summary>
			/// Test is the window enabled.
			/// </summary>
			/// <returns>Returns true if the window is enabled.</returns>
			virtual bool				IsEnabled()=0;
			
			/// <summary>
			/// Set focus to the window.
			/// </summary>
			virtual void				SetFocus()=0;
			/// <summary>
			/// Test is the window focused.
			/// </summary>
			/// <returns>Returns true if the window is focused.</returns>
			virtual bool				IsFocused()=0;
			/// <summary>
			/// Activate to the window.
			/// </summary>
			virtual void				SetActivate()=0;
			/// <summary>
			/// Test is the window activated.
			/// </summary>
			/// <returns>Returns true if the window is activated.</returns>
			virtual bool				IsActivated()=0;
			
			/// <summary>
			/// Show the icon in the task bar.
			/// </summary>
			virtual void				ShowInTaskBar()=0;
			/// <summary>
			/// Hide the icon in the task bar.
			/// </summary>
			virtual void				HideInTaskBar()=0;
			/// <summary>
			/// Test is the window icon appeared in the task bar.
			/// </summary>
			/// <returns>Returns true if the window icon appears in the task bar.</returns>
			virtual bool				IsAppearedInTaskBar()=0;
			
			/// <summary>
			/// Enable activation to the window.
			/// </summary>
			virtual void				EnableActivate()=0;
			/// <summary>
			/// Disable activation to the window.
			/// </summary>
			virtual void				DisableActivate()=0;
			/// <summary>
			/// Test is the window allowed to be activated.
			/// </summary>
			/// <returns>Returns true if the window is allowed to be activated.</returns>
			virtual bool				IsEnabledActivate()=0;
			
			/// <summary>
			/// Require mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				RequireCapture()=0;
			/// <summary>
			/// Release mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				ReleaseCapture()=0;
			/// <summary>
			/// Test if the window is capturing mouse messages.
			/// </summary>
			/// <returns>Returns true if the window is capturing mouse messages.</returns>
			virtual bool				IsCapturing()=0;

			/// <summary>
			/// Test is the maximize box visible.
			/// </summary>
			/// <returns>Returns true if the maximize box is visible.</returns>
			virtual bool				GetMaximizedBox()=0;
			/// <summary>
			/// Make the maximize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the maximize box visible.</param>
			virtual void				SetMaximizedBox(bool visible)=0;
			/// <summary>
			/// Test is the minimize box visible.
			/// </summary>
			/// <returns>Returns true if the minimize box is visible.</returns>
			virtual bool				GetMinimizedBox()=0;
			/// <summary>
			/// Make the minimize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the minimize box visible.</param>
			virtual void				SetMinimizedBox(bool visible)=0;
			/// <summary>
			/// Test is the border visible.
			/// </summary>
			/// <returns>Returns true if the border is visible.</returns>
			virtual bool				GetBorder()=0;
			/// <summary>
			/// Make the border visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the border visible.</param>
			virtual void				SetBorder(bool visible)=0;
			/// <summary>
			/// Test is the size box visible.
			/// </summary>
			/// <returns>Returns true if the size box is visible.</returns>
			virtual bool				GetSizeBox()=0;
			/// <summary>
			/// Make the size box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the size box visible.</param>
			virtual void				SetSizeBox(bool visible)=0;
			/// <summary>
			/// Test is the icon visible.
			/// </summary>
			/// <returns>Returns true if the icon is visible.</returns>
			virtual bool				GetIconVisible()=0;
			/// <summary>
			/// Make the icon visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the icon visible.</param>
			virtual void				SetIconVisible(bool visible)=0;
			/// <summary>
			/// Test is the title bar visible.
			/// </summary>
			/// <returns>Returns true if the title bar is visible.</returns>
			virtual bool				GetTitleBar()=0;
			/// <summary>
			/// Make the title bar visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the title bar visible.</param>
			virtual void				SetTitleBar(bool visible)=0;
			/// <summary>
			/// Test is the window always on top of the desktop.
			/// </summary>
			/// <returns>Returns true if the window is always on top of the desktop.</returns>
			virtual bool				GetTopMost()=0;
			/// <summary>
			/// Make the window always or never on top of the desktop.
			/// </summary>
			/// <param name="topmost">True to make the window always  on top of the desktop.</param>
			virtual void				SetTopMost(bool topmost)=0;

			/// <summary>
			/// Supress the system's Alt+X hot key
			/// </summary>
			virtual void				SupressAlt() = 0;
			
			/// <summary>
			/// Install an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to install.</param>
			virtual bool				InstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Uninstall an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to uninstall.</param>
			virtual bool				UninstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Redraw the content of the window.
			/// </summary>
			virtual void				RedrawContent()=0;
		};

		/// <summary>
		/// Mouse message information.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct WindowMouseInfo_
		{
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the left mouse button is pressed.</summary>
			bool						left;
			/// <summary>True if the middle mouse button is pressed.</summary>
			bool						middle;
			/// <summary>True if the right mouse button is pressed.</summary>
			bool						right;
			/// <summary>The mouse position of x dimension.</summary>
			T							x;
			/// <summary>The mouse position of y dimension.</summary>
			T							y;
			/// <summary>The delta of the wheel.</summary>
			vint						wheel;
			/// <summary>True if the mouse is in the non-client area.</summary>
			bool						nonClient;
		};

		using WindowMouseInfo = WindowMouseInfo_<GuiCoordinate>;
		using NativeWindowMouseInfo = WindowMouseInfo_<NativeCoordinate>;
		
		/// <summary>
		/// Key message information.
		/// </summary>
		struct NativeWindowKeyInfo
		{
			/// <summary>Key code of the key that sends this message.</summary>
			VKEY						code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
			/// <summary>True if this repeated event is generated because a key is holding down.</summary>
			bool						autoRepeatKeyDown;
		};

		using WindowKeyInfo = NativeWindowKeyInfo;
		
		/// <summary>
		/// Character message information.
		/// </summary>
		struct NativeWindowCharInfo
		{
			/// <summary>Character that sends this message.</summary>
			wchar_t						code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
		};

		using WindowCharInfo = NativeWindowCharInfo;
		
		/// <summary>
		/// Represents a message listener to an <see cref="INativeWindow"/>.
		/// </summary>
		class INativeWindowListener : public Interface
		{
		public:
			/// <summary>Hit test result for a native window.</summary>
			enum HitTestResult
			{
				/// <summary>Border that doesn't contain sizing functionalitiy.</summary>
				BorderNoSizing,
				/// <summary>Left border.</summary>
				BorderLeft,
				/// <summary>Right border.</summary>
				BorderRight,
				/// <summary>Top border.</summary>
				BorderTop,
				/// <summary>Bottom border.</summary>
				BorderBottom,
				/// <summary>Left top border.</summary>
				BorderLeftTop,
				/// <summary>Right top border.</summary>
				BorderRightTop,
				/// <summary>Left bottom border.</summary>
				BorderLeftBottom,
				/// <summary>Right bottom border.</summary>
				BorderRightBottom,
				/// <summary>Title</summary>
				Title,
				/// <summary>Minimum button.</summary>
				ButtonMinimum,
				/// <summary>Maximum button.</summary>
				ButtonMaximum,
				/// <summary>Close button.</summary>
				ButtonClose,
				/// <summary>Client button.</summary>
				Client,
				/// <summary>Icon.</summary>
				Icon,
				/// <summary>Let the OS window layer decide.</summary>
				NoDecision,
			};

			/// <summary>
			/// Perform a hit test.
			/// </summary>
			/// <returns>Returns the hit test result. If "NoDecision" is returned, the native window provider should call the OS window layer to do the hit test.</returns>
			/// <param name="location">The location to do the hit test. This location is in the window space (not the client space).</param>
			virtual HitTestResult		HitTest(NativePoint location);
			/// <summary>
			/// Called when the window is moving.
			/// </summary>
			/// <param name="bounds">The bounds. Message handler can change the bounds.</param>
			/// <param name="fixSizeOnly">True if the message raise only want the message handler to change the size.</param>
			virtual void				Moving(NativeRect& bounds, bool fixSizeOnly);
			/// <summary>
			/// Called when the window is moved.
			/// </summary>
			virtual void				Moved();
			/// <summary>
			/// Called when the dpi associated with this window is changed.
			/// </summary>
			virtual void				DpiChanged();
			/// <summary>
			/// Called when the window is enabled.
			/// </summary>
			virtual void				Enabled();
			/// <summary>
			/// Called when the window is disabled.
			/// </summary>
			virtual void				Disabled();
			/// <summary>
			/// Called when the window got the focus.
			/// </summary>
			virtual void				GotFocus();
			/// <summary>
			/// Called when the window lost the focus.
			/// </summary>
			virtual void				LostFocus();
			/// <summary>
			/// Called when the window is activated.
			/// </summary>
			virtual void				Activated();
			/// <summary>
			/// Called when the window is deactivated.
			/// </summary>
			virtual void				Deactivated();
			/// <summary>
			/// Called when the window is opened.
			/// </summary>
			virtual void				Opened();
			/// <summary>
			/// Called when the window is closing.
			/// </summary>
			/// <param name="cancel">Change the value to true to prevent the windows from being closed.</param>
			virtual void				Closing(bool& cancel);
			/// <summary>
			/// Called when the window is closed.
			/// </summary>
			virtual void				Closed();
			/// <summary>
			/// Called when the window is painting.
			/// </summary>
			virtual void				Paint();
			/// <summary>
			/// Called when the window is destroying.
			/// </summary>
			virtual void				Destroying();
			/// <summary>
			/// Called when the window is destroyed.
			/// </summary>
			virtual void				Destroyed();
			
			/// <summary>
			/// Called when the left mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal mouse wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				HorizontalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal vertical wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				VerticalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse is moving on the window.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MouseMoving(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse entered the window.
			/// </summary>
			virtual void				MouseEntered();
			/// <summary>
			/// Called when the mouse leaved the window.
			/// </summary>
			virtual void				MouseLeaved();
			
			/// <summary>
			/// Called a key is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyDown(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a key is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyUp(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a system key is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				SysKeyDown(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a system key is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				SysKeyUp(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called an input character is generated.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				Char(const NativeWindowCharInfo& info);
		};

/***********************************************************************
Native Window Services
***********************************************************************/

		/// <summary>
		/// System resource service. To access this service, use [M:vl.presentation.INativeController.ResourceService].
		/// </summary>
		class INativeResourceService : public virtual IDescriptable, public Description<INativeResourceService>
		{
		public:
			/// <summary>
			/// Get a cached cursor object using a predefined system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			/// <param name="type">The predefined system cursor type.</param>
			virtual INativeCursor*			GetSystemCursor(INativeCursor::SystemCursorType type)=0;
			/// <summary>
			/// Get a cached cursor object using a default system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			virtual INativeCursor*			GetDefaultSystemCursor()=0;

			/// <summary>
			/// Get the default font configuration of the system.
			/// </summary>
			/// <returns>The default font configuration of the system.</returns>
			virtual FontProperties			GetDefaultFont()=0;
			/// <summary>
			/// Override the default font configuration for the current process, only available GacUI library.
			/// </summary>
			/// <param name="value">The font configuration to override.</param>
			virtual void					SetDefaultFont(const FontProperties& value)=0;
		};

		/// <summary>
		/// Delay execution controller.
		/// </summary>
		class INativeDelay : public virtual IDescriptable, public Description<INativeDelay>
		{
		public:
			/// <summary>Delay execution controller status.</summary>
			enum ExecuteStatus
			{
				/// <summary>Pending.</summary>
				Pending,
				/// <summary>Executing.</summary>
				Executing,
				/// <summary>Executed.</summary>
				Executed,
				/// <summary>Canceled.</summary>
				Canceled,
			};

			/// <summary>Get the current status.</summary>
			/// <returns>The current status.</returns>
			virtual ExecuteStatus			GetStatus()=0;
			/// <summary>If the current task is pending, execute the task after a specified period.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="milliseconds">A specified period.</param>
			virtual bool					Delay(vint milliseconds)=0;
			/// <summary>If the current task is pending, cancel the task.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool					Cancel()=0;
		};
		
		/// <summary>
		/// Asynchronized operation service. GacUI is not a thread safe library except for this service. To access this service, use [M:vl.presentation.INativeController.AsyncService].
		/// </summary>
		class INativeAsyncService : public virtual IDescriptable, public Description<INativeAsyncService>
		{
		public:

			/// <summary>
			/// Test is the current thread the main thread.
			/// </summary>
			/// <returns>Returns true if the current thread is the main thread.</returns>
			/// <param name="window">A window to access the corressponding main thread.</param>
			virtual bool					IsInMainThread(INativeWindow* window)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument asynchronisly.
			/// </summary>
			/// <param name="proc">The specified function.</param>
			virtual void					InvokeAsync(const Func<void()>& proc)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread.
			/// </summary>
			/// <param name="window">A window to access the corressponding main thread.</param>
			/// <param name="proc">The specified function.</param>
			virtual void					InvokeInMainThread(INativeWindow* window, const Func<void()>& proc)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread and wait for the function to complete or timeout.
			/// </summary>
			/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
			/// <param name="window">A window to access the corressponding main thread.</param>
			/// <param name="proc">The specified function.</param>
			/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
			virtual bool					InvokeInMainThreadAndWait(INativeWindow* window, const Func<void()>& proc, vint milliseconds=-1)=0;
			/// <summary>
			/// Delay execute a specified function with an specified argument asynchronisly.
			/// </summary>
			/// <returns>The Delay execution controller for this task.</returns>
			/// <param name="proc">The specified function.</param>
			/// <param name="milliseconds">Time to delay.</param>
			virtual Ptr<INativeDelay>		DelayExecute(const Func<void()>& proc, vint milliseconds)=0;
			/// <summary>
			/// Delay execute a specified function with an specified argument in the main thread.
			/// </summary>
			/// <returns>The Delay execution controller for this task.</returns>
			/// <param name="proc">The specified function.</param>
			/// <param name="milliseconds">Time to delay.</param>
			virtual Ptr<INativeDelay>		DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds)=0;
		};

		/// <summary>
		/// Clipboard reader.
		/// </summary>
		class INativeClipboardReader : public virtual IDescriptable, public Description<INativeClipboardReader>
		{
		public:
			/// <summary>Test is there a text in the clipboard.</summary>
			/// <returns>Returns true if there is a text in the clipboard.</returns>
			virtual bool					ContainsText() = 0;

			/// <summary>Get the text from the clipboard.</summary>
			/// <returns>The text.</returns>
			virtual WString					GetText() = 0;

			/// <summary>Test is there a document in the clipboard.</summary>
			/// <returns>Returns true if there is a document in the clipboard.</returns>
			virtual bool					ContainsDocument() = 0;

			/// <summary>Get the document from the clipboard.</summary>
			/// <returns>The document.</returns>
			virtual Ptr<DocumentModel>		GetDocument() = 0;

			/// <summary>Test is there an image in the clipboard.</summary>
			/// <returns>Returns true if there is an image in the clipboard.</returns>
			virtual bool					ContainsImage() = 0;

			/// <summary>Get the image from the clipboard.</summary>
			/// <returns>The image.</returns>
			virtual Ptr<INativeImage>		GetImage() = 0;
		};

		/// <summary>
		/// Clipboard writer.
		/// </summary>
		class INativeClipboardWriter : public virtual IDescriptable, public Description<INativeClipboardWriter>
		{
		public:
			/// <summary>Prepare a text for the clipboard.</summary>
			/// <param name="value">The text.</param>
			virtual void					SetText(const WString& value) = 0;

			/// <summary>Prepare a document for the clipboard.</summary>
			/// <param name="value">The document.</param>
			virtual void					SetDocument(Ptr<DocumentModel> value) = 0;

			/// <summary>Prepare an image for the clipboard.</summary>
			/// <param name="value">The image.</param>
			virtual void					SetImage(Ptr<INativeImage> value) = 0;

			/// <summary>Send all data to the clipboard.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool					Submit() = 0;
		};
		
		/// <summary>
		/// Clipboard service. To access this service, use [M:vl.presentation.INativeController.ClipboardService].
		/// </summary>
		class INativeClipboardService : public virtual IDescriptable, public Description<INativeClipboardService>
		{
		public:
			/// <summary>Read clipboard.</summary>
			/// <returns>The clipboard reader.</returns>
			virtual Ptr<INativeClipboardReader>		ReadClipboard() = 0;
			/// <summary>Write clipboard.</summary>
			/// <returns>The clipboard writer.</returns>
			virtual Ptr<INativeClipboardWriter>		WriteClipboard() = 0;
		};
		
		/// <summary>
		/// Screen information service. To access this service, use [M:vl.presentation.INativeController.ScreenService].
		/// </summary>
		class INativeScreenService : public virtual IDescriptable, public Description<INativeScreenService>
		{
		public:
			/// <summary>
			/// Get the number of all available screens.
			/// </summary>
			///  <returns>The number of all available screens.</returns>
			virtual vint					GetScreenCount()=0;
			/// <summary>
			/// Get the screen object by a specified screen index.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="index">The specified screen index.</param>
			virtual INativeScreen*			GetScreen(vint index)=0;
			/// <summary>
			/// Get the screen object where the main part of the specified window is inside.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="window">The specified window.</param>
			virtual INativeScreen*			GetScreen(INativeWindow* window)=0;
		};
		
		/// <summary>
		/// Window service. To access this service, use [M:vl.presentation.INativeController.WindowService].
		/// </summary>
		class INativeWindowService : public virtual Interface
		{
		public:
			/// <summary>
			/// Create a window.
			/// </summary>
			/// <returns>The created window.</returns>
			virtual INativeWindow*			CreateNativeWindow() = 0;
			/// <summary>
			/// Destroy a window.
			/// </summary>
			/// <param name="window">The window to destroy.</param>
			virtual void					DestroyNativeWindow(INativeWindow* window) = 0;
			/// <summary>
			/// Get the main window.
			/// </summary>
			/// <returns>The main window.</returns>
			virtual INativeWindow*			GetMainWindow() = 0;
			/// <summary>
			/// Get the window that under a specified position in screen space.
			/// </summary>
			/// <returns>The window that under a specified position in screen space.</returns>
			/// <param name="location">The specified position in screen space.</param>
			virtual INativeWindow*			GetWindow(NativePoint location) = 0;
			/// <summary>
			/// Make the specified window a main window, show that window, and wait until the windows is closed.
			/// </summary>
			/// <param name="window">The specified window.</param>
			virtual void					Run(INativeWindow* window) = 0;
		};
		
		/// <summary>
		/// User input service. To access this service, use [M:vl.presentation.INativeController.InputService].
		/// </summary>
		class INativeInputService : public virtual IDescriptable, public Description<INativeInputService>
		{
		public:
			/// <summary>
			/// Start to reveive global mouse message.
			/// </summary>
			virtual void					StartHookMouse()=0;
			/// <summary>
			/// Stop to receive global mouse message.
			/// </summary>
			virtual void					StopHookMouse()=0;
			/// <summary>
			/// Test is the global mouse message receiving enabled.
			/// </summary>
			/// <returns>Returns true if the global mouse message receiving is enabled.</returns>
			virtual bool					IsHookingMouse()=0;
			
			/// <summary>
			/// Start to reveive global timer message.
			/// </summary>
			virtual void					StartTimer()=0;
			/// <summary>
			/// Stop to receive global timer message.
			/// </summary>
			virtual void					StopTimer()=0;
			/// <summary>
			/// Test is the global timer message receiving enabled.
			/// </summary>
			/// <returns>Returns true if the global timer message receiving is enabled.</returns>
			virtual bool					IsTimerEnabled()=0;
			
			/// <summary>
			/// Test is the specified key pressing.
			/// </summary>
			/// <returns>Returns true if the specified key is pressing.</returns>
			/// <param name="code">The key code to test.</param>
			virtual bool					IsKeyPressing(VKEY code)=0;
			/// <summary>
			/// Test is the specified key toggled.
			/// </summary>
			/// <returns>Returns true if the specified key is toggled.</returns>
			/// <param name="code">The key code to test.</param>
			virtual bool					IsKeyToggled(VKEY code)=0;

			/// <summary>
			/// Get the name of a key.
			/// </summary>
			/// <returns>The name of a key.</returns>
			/// <param name="code">The key code.</param>
			virtual WString					GetKeyName(VKEY code)=0;
			/// <summary>
			/// Get the key from a name.
			/// </summary>
			/// <returns>The key, returns -1 if the key name doesn't exist.</returns>
			/// <param name="name">Key name</param>
			virtual VKEY					GetKey(const WString& name)=0;
		};
		
		/// <summary>
		/// Callback service. To access this service, use [M:vl.presentation.INativeController.CallbackService].
		/// </summary>
		class INativeCallbackService : public virtual Interface
		{
		public:
			/// <summary>
			/// Install a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to install.</param>
			virtual bool					InstallListener(INativeControllerListener* listener)=0;
			/// <summary>
			/// Uninstall a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to uninstall.</param>
			virtual bool					UninstallListener(INativeControllerListener* listener)=0;
		};


		/// <summary>
		/// Dialog service. To access this service, use [M:vl.presentation.INativeController.DialogService].
		/// </summary>
		class INativeDialogService : public virtual Interface
		{
		public:
			/// <summary>
			/// Message box button combination for displaying a message box.
			/// </summary>
			enum MessageBoxButtonsInput
			{
				/// <summary>Display OK.</summary>
				DisplayOK,
				/// <summary>Display OK, Cancel.</summary>
				DisplayOKCancel,
				/// <summary>Display Yes, No.</summary>
				DisplayYesNo,
				/// <summary>Display Yes, No, Cancel.</summary>
				DisplayYesNoCancel,
				/// <summary>Display Retry, Cancel.</summary>
				DisplayRetryCancel,
				/// <summary>Display Abort, Retry, Ignore.</summary>
				DisplayAbortRetryIgnore,
				/// <summary>Display Cancel, TryAgain, Continue.</summary>
				DisplayCancelTryAgainContinue,
			};

			/// <summary>
			/// Message box button to indicate what the user selected.
			/// </summary>
			enum MessageBoxButtonsOutput
			{
				/// <summary>Select OK.</summary>
				SelectOK,
				/// <summary>Select Cancel.</summary>
				SelectCancel,
				/// <summary>Select Yes.</summary>
				SelectYes,
				/// <summary>Select No.</summary>
				SelectNo,
				/// <summary>Select Retry.</summary>
				SelectRetry,
				/// <summary>Select Abort.</summary>
				SelectAbort,
				/// <summary>Select Ignore.</summary>
				SelectIgnore,
				/// <summary>Select TryAgain.</summary>
				SelectTryAgain,
				/// <summary>Select Continue.</summary>
				SelectContinue,
			};

			/// <summary>
			/// Message box default button.
			/// </summary>
			enum MessageBoxDefaultButton
			{
				/// <summary>First.</summary>
				DefaultFirst,
				/// <summary>Second.</summary>
				DefaultSecond,
				/// <summary>Third.</summary>
				DefaultThird,
			};

			/// <summary>
			/// Message box icons.
			/// </summary>
			enum MessageBoxIcons
			{
				/// <summary>No icon.</summary>
				IconNone,
				/// <summary>Error icon.</summary>
				IconError,
				/// <summary>Question icon.</summary>
				IconQuestion,
				/// <summary>Warning icon.</summary>
				IconWarning,
				/// <summary>Information icon.</summary>
				IconInformation,
			};

			/// <summary>
			/// Message box model options.
			/// </summary>
			enum MessageBoxModalOptions
			{
				/// <summary>Disable the current window.</summary>
				ModalWindow,
				/// <summary>Disable all windows in the application.</summary>
				ModalTask,
				/// <summary>Top most message box in the whole system.</summary>
				ModalSystem,
			};

			/// <summary>Show a message box.</summary>
			/// <returns>Returns the user selected button.</returns>
			/// <param name="window">The current window. This argument can be null.</param>
			/// <param name="text">The content of the message box.</param>
			/// <param name="title">The title of the message box.</param>
			/// <param name="buttons">The display button combination of the message box.</param>
			/// <param name="defaultButton">The default button of the message box.</param>
			/// <param name="icon">The icon of the message box.</param>
			/// <param name="modal">The modal option of the message box.</param>
			virtual MessageBoxButtonsOutput			ShowMessageBox(INativeWindow* window, const WString& text, const WString& title=L"", MessageBoxButtonsInput buttons=DisplayOK, MessageBoxDefaultButton defaultButton=DefaultFirst, MessageBoxIcons icon=IconNone, MessageBoxModalOptions modal=ModalWindow)=0;

			/// <summary>
			/// Color dialog custom color options
			/// </summary>
			enum ColorDialogCustomColorOptions
			{
				/// <summary>Disable the custom color panel.</summary>
				CustomColorDisabled,
				/// <summary>Enable the custom color panel.</summary>
				CustomColorEnabled,
				/// <summary>Open the custom color panel at the beginning.</summary>
				CustomColorOpened,
			};

			/// <summary>Show a color dialog.</summary>
			/// <returns>Returns true if the user selected the OK button.</returns>
			/// <param name="window">The current window.</param>
			/// <param name="selection">The color that the user selected.</param>
			/// <param name="selected">Make the color dialog selected the color specified in the "selection" parameter at the beginning.</param>
			/// <param name="customColorOptions">Custom color panel options.</param>
			/// <param name="customColors">The initial 16 colors in custom color boxes. This argument can be null.</param>
			virtual bool							ShowColorDialog(INativeWindow* window, Color& selection, bool selected=false, ColorDialogCustomColorOptions customColorOptions=CustomColorEnabled, Color* customColors=0)=0;

			/// <summary>Show a font dialog.</summary>
			/// <returns>Returns true if the user selected the OK button.</returns>
			/// <param name="window">The current window.</param>
			/// <param name="selectionFont">The font that the user selected.</param>
			/// <param name="selectionColor">The color that the user selected.</param>
			/// <param name="selected">Make the font dialog selected the font specified in the "selectionFont" and "selectionColor" parameters at the beginning.</param>
			/// <param name="showEffect">Enable the user to edit some extended font properties.</param>
			/// <param name="forceFontExist">Force the user to select existing font.</param>
			virtual bool							ShowFontDialog(INativeWindow* window, FontProperties& selectionFont, Color& selectionColor, bool selected=false, bool showEffect=true, bool forceFontExist=true)=0;
			
			/// <summary>
			/// File dialog type.
			/// </summary>
			enum FileDialogTypes
			{
				/// <summary>Open file dialog.</summary>
				FileDialogOpen,
				/// <summary>Open file dialog with preview.</summary>
				FileDialogOpenPreview,
				/// <summary>Save file dialog.</summary>
				FileDialogSave,
				/// <summary>Save file dialog with preview.</summary>
				FileDialogSavePreview,
			};

			/// <summary>
			/// File dialog options.
			/// </summary>
			enum FileDialogOptions
			{
				/// <summary>Allow multiple selection.</summary>
				FileDialogAllowMultipleSelection = 1,
				/// <summary>Prevent the user to select unexisting files.</summary>
				FileDialogFileMustExist = 2,
				/// <summary>Show the "Read Only" check box.</summary>
				FileDialogShowReadOnlyCheckBox = 4,
				/// <summary>Dereference link files.</summary>
				FileDialogDereferenceLinks = 8,
				/// <summary>Show the "Network" button.</summary>
				FileDialogShowNetworkButton = 16,
				/// <summary>Prompt if a new file is going to be created.</summary>
				FileDialogPromptCreateFile = 32,
				/// <summary>Promt if a existing file is going to be overwritten.</summary>
				FileDialogPromptOverwriteFile = 64,
				/// <summary>Prevent the user to select an unexisting directory.</summary>
				FileDialogDirectoryMustExist = 128,
				/// <summary>Add user selected files to "Recent" directory.</summary>
				FileDialogAddToRecent = 256,
			};

			/// <summary>Show a file dialog.</summary>
			/// <returns>Returns true if the user selected the OK button.</returns>
			/// <param name="window">The current window.</param>
			/// <param name="selectionFileNames">The file names that the user selected.</param>
			/// <param name="selectionFilterIndex">The filter that the user selected.</param>
			/// <param name="dialogType">The type of the file dialog.</param>
			/// <param name="title">The title of the file dialog.</param>
			/// <param name="initialFileName">The initial file name.</param>
			/// <param name="initialDirectory">The initial directory.</param>
			/// <param name="defaultExtension">The default file extension.</param>
			/// <param name="filter">The file name filter like L"Text Files|*.txt|All Files|*.*".</param>
			/// <param name="options">File dialog options. Multiple options can be combined using the "|" operator.</param>
			virtual bool							ShowFileDialog(INativeWindow* window, collections::List<WString>& selectionFileNames, vint& selectionFilterIndex, FileDialogTypes dialogType, const WString& title, const WString& initialFileName, const WString& initialDirectory, const WString& defaultExtension, const WString& filter, FileDialogOptions options)=0;
		};

		inline INativeDialogService::FileDialogOptions operator|(INativeDialogService::FileDialogOptions a, INativeDialogService::FileDialogOptions b)
		{
			return static_cast<INativeDialogService::FileDialogOptions>(static_cast<vuint64_t>(a) | static_cast<vuint64_t>(b));
		}

		inline INativeDialogService::FileDialogOptions operator&(INativeDialogService::FileDialogOptions a, INativeDialogService::FileDialogOptions b)
		{
			return static_cast<INativeDialogService::FileDialogOptions>(static_cast<vuint64_t>(a) & static_cast<vuint64_t>(b));
		}

/***********************************************************************
Native Window Controller
***********************************************************************/

		/// <summary>
		/// Global native system service controller. Use [M:vl.presentation.GetCurrentController] to access this controller.
		/// </summary>
		class INativeController : public virtual IDescriptable, public Description<INativeController>
		{
		public:
			/// <summary>
			/// Get the callback service.
			/// </summary>
			/// <returns>The callback service</returns>
			virtual INativeCallbackService*			CallbackService()=0;
			/// <summary>
			/// Get the system resource service.
			/// </summary>
			/// <returns>The system resource service</returns>
			virtual INativeResourceService*			ResourceService()=0;
			/// <summary>
			/// Get the asynchronized operation service.
			/// </summary>
			/// <returns>The asynchronized operation service</returns>
			virtual INativeAsyncService*			AsyncService()=0;
			/// <summary>
			/// Get the clipboard service.
			/// </summary>
			/// <returns>The clipboard service</returns>
			virtual INativeClipboardService*		ClipboardService()=0;
			/// <summary>
			/// Get the image service.
			/// </summary>
			/// <returns>The image service</returns>
			virtual INativeImageService*			ImageService()=0;
			/// <summary>
			/// Get the screen information service.
			/// </summary>
			/// <returns>The screen information service</returns>
			virtual INativeScreenService*			ScreenService()=0;
			/// <summary>
			/// Get the window service.
			/// </summary>
			/// <returns>The window service</returns>
			virtual INativeWindowService*			WindowService()=0;
			/// <summary>
			/// Get the user input service.
			/// </summary>
			/// <returns>The user input service</returns>
			virtual INativeInputService*			InputService()=0;
			/// <summary>
			/// Get the dialog service.
			/// </summary>
			/// <returns>The user dialog service</returns>
			virtual INativeDialogService*			DialogService()=0;
			/// <summary>
			/// Get the file path of the current executable.
			/// </summary>
			/// <returns>The file path of the current executable.</returns>
			virtual WString							GetExecutablePath()=0;
		};
		
		/// <summary>
		/// Represents a global message listener to an <see cref="INativeController"/>.
		/// </summary>
		class INativeControllerListener : public Interface
		{
		public:
			/// <summary>
			/// Called when the left mouse button is pressed. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>.
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					LeftButtonDown(NativePoint position);
			/// <summary>
			/// Called when the left mouse button is released. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					LeftButtonUp(NativePoint position);
			/// <summary>
			/// Called when the right mouse button is pressed. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					RightButtonDown(NativePoint position);
			/// <summary>
			/// Called when the right mouse button is released. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					RightButtonUp(NativePoint position);
			/// <summary>
			/// Called when the mouse is moving. To receive or not receive this message, use <see cref="INativeInputService::StartHookMouse"/> or <see cref="INativeInputService::StopHookMouse"/>
			/// </summary>
			/// <param name="position">The mouse position in the screen space.</param>
			virtual void					MouseMoving(NativePoint position);
			/// <summary>
			/// Called when the global timer message raised. To receive or not receive this message, use <see cref="INativeInputService::StartTimer"/> or <see cref="INativeInputService::StopTimer"/>
			/// </summary>
			virtual void					GlobalTimer();
			/// <summary>
			/// Called when the content of the clipboard is updated.
			/// </summary>
			virtual void					ClipboardUpdated();
			/// <summary>
			/// Called when a window is created.
			/// </summary>
			/// <param name="window">The created window.</param>
			virtual void					NativeWindowCreated(INativeWindow* window);
			/// <summary>
			/// Called when a window is destroying.
			/// </summary>
			/// <param name="window">The destroying window.</param>
			virtual void					NativeWindowDestroying(INativeWindow* window);
		};

		/// <summary>
		/// Get the global native system service controller.
		/// </summary>
		/// <returns>The global native system service controller.</returns>
		extern								INativeController* GetCurrentController();
		/// <summary>
		/// Set the global native system service controller.
		/// </summary>
		/// <param name="controller">The global native system service controller.</param>
		extern void							SetCurrentController(INativeController* controller);
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSEVENTRECEIVER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Event Model

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSEVENTRECEIVER
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSEVENTRECEIVER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace tree
			{
				class INodeProvider;
			}
		}
	}
}

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsComposition;

/***********************************************************************
Event
***********************************************************************/

			class IGuiGraphicsEventHandler : public virtual IDescriptable, public Description<IGuiGraphicsEventHandler>
			{
			public:
				class Container
				{
				public:
					Ptr<IGuiGraphicsEventHandler>	handler;
				};

				virtual bool IsAttached() = 0;
			};

			template<typename T>
			class GuiGraphicsEvent : public Object, public Description<GuiGraphicsEvent<T>>
			{
			public:
				typedef void(RawFunctionType)(GuiGraphicsComposition*, T&);
				typedef Func<RawFunctionType>						FunctionType;
				typedef T											ArgumentType;
				
				class FunctionHandler : public Object, public IGuiGraphicsEventHandler
				{
				public:
					bool					isAttached = true;
					FunctionType			handler;

					FunctionHandler(const FunctionType& _handler)
						:handler(_handler)
					{
					}

					bool IsAttached()override
					{
						return isAttached;
					}

					void Execute(GuiGraphicsComposition* sender, T& argument)
					{
						handler(sender, argument);
					}
				};
			protected:
				struct HandlerNode
				{
					Ptr<FunctionHandler>								handler;
					Ptr<HandlerNode>									next;
				};

				GuiGraphicsComposition*									sender;
				Ptr<HandlerNode>										handlers;

				bool Attach(Ptr<FunctionHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler = &handlers;
					while (*currentHandler)
					{
						if ((*currentHandler)->handler == handler)
						{
							return false;
						}
						else
						{
							currentHandler = &(*currentHandler)->next;
						}
					}
					(*currentHandler) = new HandlerNode;
					(*currentHandler)->handler = handler;
					return true;
				}
			public:
				GuiGraphicsEvent(GuiGraphicsComposition* _sender=0)
					:sender(_sender)
				{
				}

				~GuiGraphicsEvent()
				{
				}

				GuiGraphicsComposition* GetAssociatedComposition()
				{
					return sender;
				}

				void SetAssociatedComposition(GuiGraphicsComposition* _sender)
				{
					sender=_sender;
				}

				template<typename TClass, typename TMethod>
				Ptr<IGuiGraphicsEventHandler> AttachMethod(TClass* receiver, TMethod TClass::* method)
				{
					auto handler=MakePtr<FunctionHandler>(FunctionType(receiver, method));
					Attach(handler);
					return handler;
				}

				Ptr<IGuiGraphicsEventHandler> AttachFunction(RawFunctionType* function)
				{
					auto handler = MakePtr<FunctionHandler>(FunctionType(function));
					Attach(handler);
					return handler;
				}

				Ptr<IGuiGraphicsEventHandler> AttachFunction(const FunctionType& function)
				{
					auto handler = MakePtr<FunctionHandler>(function);
					Attach(handler);
					return handler;
				}

				template<typename TLambda>
				Ptr<IGuiGraphicsEventHandler> AttachLambda(const TLambda& lambda)
				{
					auto handler = MakePtr<FunctionHandler>(FunctionType(lambda));
					Attach(handler);
					return handler;
				}

				bool Detach(Ptr<IGuiGraphicsEventHandler> handler)
				{
					auto typedHandler = handler.Cast<FunctionHandler>();
					if (!typedHandler)
					{
						return false;
					}

					auto currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler == typedHandler)
						{
							(*currentHandler)->handler->isAttached = false;

							auto next=(*currentHandler)->next;
							(*currentHandler)=next;
							return true;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					return false;
				}

				void ExecuteWithNewSender(T& argument, GuiGraphicsComposition* newSender)
				{
					auto currentHandler=&handlers;
					while(*currentHandler)
					{
						(*currentHandler)->handler->Execute(newSender?newSender:sender, argument);
						currentHandler=&(*currentHandler)->next;
					}
				}

				void Execute(T& argument)
				{
					ExecuteWithNewSender(argument, 0);
				}

				void Execute(const T& argument)
				{
					auto t = argument;
					ExecuteWithNewSender(t, 0);
				}
			};

/***********************************************************************
Predefined Events
***********************************************************************/

			/// <summary>Notify event arguments.</summary>
			struct GuiEventArgs : public Object, public AggregatableDescription<GuiEventArgs>
			{
				/// <summary>The event raiser composition.</summary>
				GuiGraphicsComposition*		compositionSource;
				/// <summary>The nearest parent of the event raiser composition that contains an event receiver. If the event raiser composition contains an event receiver, it will be the event raiser composition.</summary>
				GuiGraphicsComposition*		eventSource;
				/// <summary>Set this field to true will stop the event routing. This is a signal that the event is properly handeled, and the event handler want to override the default behavior.</summary>
				bool						handled;

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiEventArgs()
					:compositionSource(0)
					,eventSource(0)
					,handled(false)
				{
				}

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiEventArgs(GuiGraphicsComposition* composition)
					:compositionSource(composition)
					,eventSource(composition)
					,handled(false)
				{
				}

				~GuiEventArgs()
				{
					FinalizeAggregation();
				}
			};
			
			/// <summary>Request event arguments.</summary>
			struct GuiRequestEventArgs : public GuiEventArgs, public Description<GuiRequestEventArgs>
			{
				/// <summary>Set this field to false in event handlers will stop the corresponding action.</summary>
				bool		cancel;
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiRequestEventArgs()
					:cancel(false)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiRequestEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,cancel(false)
				{
				}
			};
			
			/// <summary>Keyboard event arguments.</summary>
			struct GuiKeyEventArgs : public GuiEventArgs, public WindowKeyInfo, public Description<GuiKeyEventArgs>
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiKeyEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiKeyEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Char input event arguments.</summary>
			struct GuiCharEventArgs : public GuiEventArgs, public WindowCharInfo, public Description<GuiCharEventArgs>
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiCharEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiCharEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Mouse event arguments.</summary>
			struct GuiMouseEventArgs : public GuiEventArgs, public WindowMouseInfo, public Description<GuiMouseEventArgs>
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiMouseEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			/// <summary>Control signal.</summary>
			enum class ControlSignal
			{
				/// <summary>Render target changed.</summary>
				RenderTargetChanged,
				/// <summary>Render target changed.</summary>
				ParentLineChanged,
				/// <summary>Service added changed.</summary>
				ServiceAdded,
			};

			/// <summary>Control signal event arguments.</summary>
			struct GuiControlSignalEventArgs : public GuiEventArgs, public Description<GuiControlSignalEventArgs>
			{
				/// <summary>The event raiser composition.</summary>
				ControlSignal				controlSignal = ControlSignal::ParentLineChanged;

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiControlSignalEventArgs()
				{
				}

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiControlSignalEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiEventArgs>				GuiNotifyEvent;
			typedef GuiGraphicsEvent<GuiRequestEventArgs>		GuiRequestEvent;
			typedef GuiGraphicsEvent<GuiKeyEventArgs>			GuiKeyEvent;
			typedef GuiGraphicsEvent<GuiCharEventArgs>			GuiCharEvent;
			typedef GuiGraphicsEvent<GuiMouseEventArgs>			GuiMouseEvent;
			typedef GuiGraphicsEvent<GuiControlSignalEventArgs>	GuiControlSignalEvent;

/***********************************************************************
Predefined Item Events
***********************************************************************/
			
			/// <summary>Item event arguments.</summary>
			struct GuiItemEventArgs : public GuiEventArgs, public Description<GuiItemEventArgs>
			{
				/// <summary>Item index.</summary>
				vint			itemIndex;

				GuiItemEventArgs()
					:itemIndex(-1)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiItemEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};
			
			/// <summary>Item mouse event arguments.</summary>
			struct GuiItemMouseEventArgs : public GuiMouseEventArgs, public Description<GuiItemMouseEventArgs>
			{
				/// <summary>Item index.</summary>
				vint			itemIndex;

				GuiItemMouseEventArgs()
					:itemIndex(-1)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiItemMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiItemEventArgs>			GuiItemNotifyEvent;
			typedef GuiGraphicsEvent<GuiItemMouseEventArgs>		GuiItemMouseEvent;

/***********************************************************************
Predefined Node Events
***********************************************************************/
			
			/// <summary>Node event arguments.</summary>
			struct GuiNodeEventArgs : public GuiEventArgs, public Description<GuiNodeEventArgs>
			{
				/// <summary>Tree node.</summary>
				controls::tree::INodeProvider*		node;

				GuiNodeEventArgs()
					:node(0)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiNodeEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,node(0)
				{
				}
			};
			
			/// <summary>Node mouse event arguments.</summary>
			struct GuiNodeMouseEventArgs : public GuiMouseEventArgs, public Description<GuiNodeMouseEventArgs>
			{
				/// <summary>Tree node.</summary>
				controls::tree::INodeProvider*		node;

				GuiNodeMouseEventArgs()
					:node(0)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiNodeMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,node(0)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiNodeEventArgs>			GuiNodeNotifyEvent;
			typedef GuiGraphicsEvent<GuiNodeMouseEventArgs>		GuiNodeMouseEvent;

/***********************************************************************
Event Receiver
***********************************************************************/

			/// <summary>
			/// Contains all available user input events for a <see cref="GuiGraphicsComposition"/>. Almost all events are routed events. Routed events means, not only the activated composition receives the event, all it direct or indirect parents receives the event. The argument(all derives from <see cref="GuiEventArgs"/>) for the event will store the original event raiser composition.
			/// </summary>
			class GuiGraphicsEventReceiver : public Object
			{
			protected:
				GuiGraphicsComposition*			sender;
			public:
				GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender);
				~GuiGraphicsEventReceiver();

				GuiGraphicsComposition*			GetAssociatedComposition();

				/// <summary>Left mouse button down event.</summary>
				GuiMouseEvent					leftButtonDown;
				/// <summary>Left mouse button up event.</summary>
				GuiMouseEvent					leftButtonUp;
				/// <summary>Left mouse button double click event.</summary>
				GuiMouseEvent					leftButtonDoubleClick;
				/// <summary>Middle mouse button down event.</summary>
				GuiMouseEvent					middleButtonDown;
				/// <summary>Middle mouse button up event.</summary>
				GuiMouseEvent					middleButtonUp;
				/// <summary>Middle mouse button double click event.</summary>
				GuiMouseEvent					middleButtonDoubleClick;
				/// <summary>Right mouse button down event.</summary>
				GuiMouseEvent					rightButtonDown;
				/// <summary>Right mouse button up event.</summary>
				GuiMouseEvent					rightButtonUp;
				/// <summary>Right mouse button double click event.</summary>
				GuiMouseEvent					rightButtonDoubleClick;
				/// <summary>Horizontal wheel scrolling event.</summary>
				GuiMouseEvent					horizontalWheel;
				/// <summary>Vertical wheel scrolling event.</summary>
				GuiMouseEvent					verticalWheel;
				/// <summary>Mouse move event.</summary>
				GuiMouseEvent					mouseMove;
				/// <summary>Mouse enter event.</summary>
				GuiNotifyEvent					mouseEnter;
				/// <summary>Mouse leave event.</summary>
				GuiNotifyEvent					mouseLeave;
				
				/// <summary>Preview key event.</summary>
				GuiKeyEvent						previewKey;
				/// <summary>Key down event.</summary>
				GuiKeyEvent						keyDown;
				/// <summary>Key up event.</summary>
				GuiKeyEvent						keyUp;
				/// <summary>System key down event.</summary>
				GuiKeyEvent						systemKeyDown;
				/// <summary>System key up event.</summary>
				GuiKeyEvent						systemKeyUp;
				/// <summary>Preview char input event.</summary>
				GuiCharEvent					previewCharInput;
				/// <summary>Char input event.</summary>
				GuiCharEvent					charInput;
				/// <summary>Got focus event.</summary>
				GuiNotifyEvent					gotFocus;
				/// <summary>Lost focus event.</summary>
				GuiNotifyEvent					lostFocus;
				/// <summary>Caret notify event. This event is raised when a caret graph need to change the visibility state.</summary>
				GuiNotifyEvent					caretNotify;
				/// <summary>Clipboard notify event. This event is raised when the content in the system clipboard is changed.</summary>
				GuiNotifyEvent					clipboardNotify;
				/// <summary>Render target changed event. This event is raised when the render target of this composition is changed.</summary>
				GuiNotifyEvent					renderTargetChanged;
			};
		}
	}

/***********************************************************************
Workflow to C++ Codegen Helpers
***********************************************************************/

	namespace __vwsn
	{
		template<typename T>
		struct EventHelper<presentation::compositions::GuiGraphicsEvent<T>>
		{
			using Event = presentation::compositions::GuiGraphicsEvent<T>;
			using Sender = presentation::compositions::GuiGraphicsComposition;
			using IGuiGraphicsEventHandler = presentation::compositions::IGuiGraphicsEventHandler;
			using Handler = Func<void(Sender*, T*)>;

			class EventHandlerImpl : public Object, public reflection::description::IEventHandler
			{
			public:
				Ptr<IGuiGraphicsEventHandler> handler;

				EventHandlerImpl(Ptr<IGuiGraphicsEventHandler> _handler)
					:handler(_handler)
				{
				}

				bool IsAttached()override
				{
					return handler->IsAttached();
				}
			};

			static Ptr<reflection::description::IEventHandler> Attach(Event& e, Handler handler)
			{
				return MakePtr<EventHandlerImpl>(e.AttachLambda([=](Sender* sender, T& args)
				{
					handler(sender, &args);
				}));
			}

			static bool Detach(Event& e, Ptr<reflection::description::IEventHandler> handler)
			{
				auto impl = handler.Cast<EventHandlerImpl>();
				if (!impl) return false;
				return e.Detach(impl->handler);
			}

			static auto Invoke(Event& e)
			{
				return [&](Sender* sender, T* args)
				{
					e.ExecuteWithNewSender(*args, sender);
				};
			}
		};
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSCOMPOSITIONBASE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSCOMPOSITIONBASE
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSCOMPOSITIONBASE


namespace vl
{
	namespace presentation
	{
		template<typename T>
		using ItemProperty = Func<T(const reflection::description::Value&)>;

		template<typename T>
		using WritableItemProperty = Func<T(const reflection::description::Value&, T, bool)>;

		template<typename T>
		using TemplateProperty = Func<T*(const reflection::description::Value&)>;

		namespace templates
		{
			class GuiTemplate;
		}

		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{
			class GuiGraphicsHost;

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// Represents a composition for <see cref="elements::IGuiGraphicsElement"/>. A composition is a way to define the size and the position using the information from graphics elements and sub compositions.
			/// When a graphics composition is destroyed, all sub composition will be destroyed. The life cycle of the contained graphics element is partially controlled by the smart pointer to the graphics element inside the composition.
			/// </summary>
			class GuiGraphicsComposition : public Object, public Description<GuiGraphicsComposition>
			{
				typedef collections::List<GuiGraphicsComposition*> CompositionList;

				friend class controls::GuiControl;
				friend class GuiGraphicsHost;
				friend void InvokeOnCompositionStateChanged(compositions::GuiGraphicsComposition* composition);
			public:
				/// <summary>
				/// Minimum size limitation.
				/// </summary>
				enum MinSizeLimitation
				{
					/// <summary>No limitation for the minimum size.</summary>
					NoLimit,
					/// <summary>Minimum size of this composition is the minimum size of the contained graphics element.</summary>
					LimitToElement,
					/// <summary>Minimum size of this composition is combiniation of sub compositions and the minimum size of the contained graphics element.</summary>
					LimitToElementAndChildren,
				};

			protected:

				struct GraphicsHostRecord
				{
					GuiGraphicsHost*						host = nullptr;
					elements::IGuiGraphicsRenderTarget*		renderTarget = nullptr;
					INativeWindow*							nativeWindow = nullptr;
				};

			protected:
				CompositionList								children;
				GuiGraphicsComposition*						parent = nullptr;
				Ptr<elements::IGuiGraphicsElement>			ownedElement;
				bool										visible = true;
				bool										transparentToMouse = false;
				MinSizeLimitation							minSizeLimitation = MinSizeLimitation::NoLimit;

				Ptr<compositions::GuiGraphicsEventReceiver>	eventReceiver;
				GraphicsHostRecord*							relatedHostRecord = nullptr;
				controls::GuiControl*						associatedControl = nullptr;
				INativeCursor*								associatedCursor = nullptr;
				INativeWindowListener::HitTestResult		associatedHitTestResult = INativeWindowListener::NoDecision;

				Margin										margin;
				Margin										internalMargin;
				Size										preferredMinSize;

				bool										isRendering = false;

				virtual void								OnControlParentChanged(controls::GuiControl* control);
				virtual void								OnChildInserted(GuiGraphicsComposition* child);
				virtual void								OnChildRemoved(GuiGraphicsComposition* child);
				virtual void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent);
				virtual void								OnParentLineChanged();
				virtual void								OnRenderContextChanged();
				
				void										UpdateRelatedHostRecord(GraphicsHostRecord* record);
				void										SetAssociatedControl(controls::GuiControl* control);
				void										InvokeOnCompositionStateChanged();

				static bool									SharedPtrDestructorProc(DescriptableObject* obj, bool forceDisposing);
			public:
				GuiGraphicsComposition();
				~GuiGraphicsComposition();

				bool										IsRendering();

				/// <summary>Get the parent composition.</summary>
				/// <returns>The parent composition.</returns>
				GuiGraphicsComposition*						GetParent();
				/// <summary>Get all child compositions ordered by z-order from low to high.</summary>
				/// <returns>Child compositions.</returns>
				const CompositionList&						Children();
				/// <summary>Add a composition as a child.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to add.</param>
				bool										AddChild(GuiGraphicsComposition* child);
				/// <summary>Add a composition as a child with a specified z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The z-order. 0 means the lowest position.</param>
				/// <param name="child">The child composition to add.</param>
				bool										InsertChild(vint index, GuiGraphicsComposition* child);
				/// <summary>Remove a child composition.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to remove.</param>
				bool										RemoveChild(GuiGraphicsComposition* child);
				/// <summary>Move a child composition to a new z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to move.</param>
				/// <param name="newIndex">The new z-order. 0 means the lowest position.</param>
				bool										MoveChild(GuiGraphicsComposition* child, vint newIndex);

				/// <summary>Get the contained graphics element.</summary>
				/// <returns>The contained graphics element.</returns>
				Ptr<elements::IGuiGraphicsElement>			GetOwnedElement();
				/// <summary>Set the contained graphics element.</summary>
				/// <param name="element">The new graphics element to set.</param>
				void										SetOwnedElement(Ptr<elements::IGuiGraphicsElement> element);
				/// <summary>Get the visibility of the composition.</summary>
				/// <returns>Returns true if the composition is visible.</returns>
				bool										GetVisible();
				/// <summary>Set the visibility of the composition.</summary>
				/// <param name="value">Set to true to make the composition visible.</param>
				void										SetVisible(bool value);
				/// <summary>Get the minimum size limitation of the composition.</summary>
				/// <returns>The minimum size limitation of the composition.</returns>
				MinSizeLimitation							GetMinSizeLimitation();
				/// <summary>Set the minimum size limitation of the composition.</summary>
				/// <param name="value">The minimum size limitation of the composition.</param>
				void										SetMinSizeLimitation(MinSizeLimitation value);
				/// <summary>Get the binded render target.</summary>
				/// <returns>The binded render target.</returns>
				elements::IGuiGraphicsRenderTarget*			GetRenderTarget();

				/// <summary>Render the composition using an offset.</summary>
				/// <param name="offset">The offset.</param>
				void										Render(Size offset);
				/// <summary>Get the event receiver object. All user input events can be found in this object. If an event receiver is never been requested from the composition, the event receiver will not be created, and all route events will not pass through this event receiver(performance will be better).</summary>
				/// <returns>The event receiver.</returns>
				compositions::GuiGraphicsEventReceiver*		GetEventReceiver();
				/// <summary>Test if any event receiver has already been requested.</summary>
				/// <returns>Returns true if any event receiver has already been requested.</returns>
				bool										HasEventReceiver();
				/// <summary>Find a deepest composition that under a specified location. If the location is inside a compsition but not hit any sub composition, this function will return this composition.</summary>
				/// <returns>The deepest composition that under a specified location.</returns>
				/// <param name="location">The specified location.</param>
				/// <param name="forMouseEvent">Find a composition for mouse event, it will ignore all compositions that are transparent to mouse events.</param>
				GuiGraphicsComposition*						FindComposition(Point location, bool forMouseEvent);
				/// <summary>Get is this composition transparent to mouse events.</summary>
				/// <returns>Returns true if this composition is transparent to mouse events, which means it just passes all mouse events to the composition under it.</returns>
				bool										GetTransparentToMouse();
				/// <summary>Set is the composition transparent to mouse events.</summary>
				/// <param name="value">Set to true to make this composition transparent to mouse events.</param>
				void										SetTransparentToMouse(bool value);
				/// <summary>Get the bounds in the top composition space.</summary>
				/// <returns>The bounds in the top composition space.</returns>
				Rect										GetGlobalBounds();

				/// <summary>Get the associated control. A control is associated to a composition only when the composition represents the bounds of this control. Such a composition usually comes from a control template.</summary>
				/// <returns>The associated control.</returns>
				controls::GuiControl*						GetAssociatedControl();
				/// <summary>Get the associated graphics host. A graphics host is associated to a composition only when the composition becomes the bounds of the graphics host.</summary>
				/// <returns>The associated graphics host.</returns>
				GuiGraphicsHost*							GetAssociatedHost();
				/// <summary>Get the associated cursor.</summary>
				/// <returns>The associated cursor.</returns>
				INativeCursor*								GetAssociatedCursor();
				/// <summary>Set the associated cursor.</summary>
				/// <param name="cursor">The associated cursor.</param>
				void										SetAssociatedCursor(INativeCursor* cursor);
				/// <summary>Get the associated hit test result.</summary>
				/// <returns>The associated hit test result.</returns>
				INativeWindowListener::HitTestResult		GetAssociatedHitTestResult();
				/// <summary>Set the associated hit test result.</summary>
				/// <param name="value">The associated hit test result.</param>
				void										SetAssociatedHitTestResult(INativeWindowListener::HitTestResult value);
				
				/// <summary>Get the related control. A related control is the deepest control that contains this composition.</summary>
				/// <returns>The related control.</returns>
				controls::GuiControl*						GetRelatedControl();
				/// <summary>Get the related graphics host. A related graphics host is the graphics host that contains this composition.</summary>
				/// <returns>The related graphics host.</returns>
				GuiGraphicsHost*							GetRelatedGraphicsHost();
				/// <summary>Get the related control host. A related control host is the control host that contains this composition.</summary>
				/// <returns>The related control host.</returns>
				controls::GuiControlHost*					GetRelatedControlHost();
				/// <summary>Get the related cursor. A related cursor is from the deepest composition that contains this composition and associated with a cursor.</summary>
				/// <returns>The related cursor.</returns>
				INativeCursor*								GetRelatedCursor();
				
				/// <summary>Get the margin.</summary>
				/// <returns>The margin.</returns>
				virtual Margin								GetMargin();
				/// <summary>Set the margin.</summary>
				/// <param name="value">The margin.</param>
				virtual void								SetMargin(Margin value);
				/// <summary>Get the internal margin.</summary>
				/// <returns>The internal margin.</returns>
				virtual Margin								GetInternalMargin();
				/// <summary>Set the internal margin.</summary>
				/// <param name="value">The internal margin.</param>
				virtual void								SetInternalMargin(Margin value);
				/// <summary>Get the preferred minimum size.</summary>
				/// <returns>The preferred minimum size.</returns>
				virtual Size								GetPreferredMinSize();
				/// <summary>Set the preferred minimum size.</summary>
				/// <param name="value">The preferred minimum size.</param>
				virtual void								SetPreferredMinSize(Size value);
				/// <summary>Get the client area.</summary>
				/// <returns>The client area.</returns>
				virtual Rect								GetClientArea();
				/// <summary>Force to calculate layout and size immediately</summary>
				virtual void								ForceCalculateSizeImmediately();
				
				/// <summary>Test is the size calculation affected by the parent.</summary>
				/// <returns>Returns true if the size calculation is affected by the parent.</returns>
				virtual bool								IsSizeAffectParent()=0;
				/// <summary>Get the preferred minimum client size.</summary>
				/// <returns>The preferred minimum client size.</returns>
				virtual Size								GetMinPreferredClientSize()=0;
				/// <summary>Get the preferred bounds.</summary>
				/// <returns>The preferred bounds.</returns>
				virtual Rect								GetPreferredBounds()=0;
				/// <summary>Get the bounds.</summary>
				/// <returns>The bounds.</returns>
				virtual Rect								GetBounds()=0;
			};

			/// <summary>
			/// A general implementation for <see cref="GuiGraphicsComposition"/>.
			/// </summary>
			class GuiGraphicsSite : public GuiGraphicsComposition, public Description<GuiGraphicsSite>
			{
			protected:
				Rect								previousBounds;

				/// <summary>Calculate the final bounds from an expected bounds.</summary>
				/// <returns>The final bounds according to some configuration like margin, minimum size, etc..</returns>
				/// <param name="expectedBounds">The expected bounds.</param>
				virtual Rect						GetBoundsInternal(Rect expectedBounds);

				void								UpdatePreviousBounds(Rect bounds);
			public:
				GuiGraphicsSite();
				~GuiGraphicsSite();

				/// <summary>Event that will be raised when the final bounds is changed.</summary>
				compositions::GuiNotifyEvent		BoundsChanged;
				
				bool								IsSizeAffectParent()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetPreferredBounds()override;
			};

/***********************************************************************
Helper Functions
***********************************************************************/

			/// <summary>Call [M:vl.presentation.controls.GuiInstanceRootObject.FinalizeInstance] in all child root objects.</summary>
			/// <param name="value">The container control to notify.</param>
			extern void								NotifyFinalizeInstance(controls::GuiControl* value);

			/// <summary>Call [M:vl.presentation.controls.GuiInstanceRootObject.FinalizeInstance] in all child root objects.</summary>
			/// <param name="value">The container composition to notify.</param>
			extern void								NotifyFinalizeInstance(GuiGraphicsComposition* value);

			/// <summary>Safely remove and delete a control.</summary>
			/// <param name="value">The control to delete.</param>
			extern void								SafeDeleteControl(controls::GuiControl* value);

			/// <summary>Safely remove and delete a composition. If some sub compositions are controls, those controls will be deleted too.</summary>
			/// <param name="value">The composition to delete.</param>
			extern void								SafeDeleteComposition(GuiGraphicsComposition* value);
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSBASICCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSBASICCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSBASICCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Basic Compositions
***********************************************************************/
			
			/// <summary>
			/// Represents a composition for the client area in an <see cref="INativeWindow"/>.
			/// </summary>
			class GuiWindowComposition : public GuiGraphicsSite, public Description<GuiWindowComposition>
			{
			public:
				GuiWindowComposition();
				~GuiWindowComposition();

				Rect								GetBounds()override;
				void								SetMargin(Margin value)override;
			};

			/// <summary>
			/// Represents a composition that is free to change the expected bounds.
			/// </summary>
			class GuiBoundsComposition : public GuiGraphicsSite, public Description<GuiBoundsComposition>
			{
			protected:
				bool								sizeAffectParent = true;
				Rect								compositionBounds;
				Margin								alignmentToParent{ -1,-1,-1,-1 };
				
			public:
				GuiBoundsComposition();
				~GuiBoundsComposition();

				/// <summary>Get if the parent composition's size calculation is aware of the configuration of this composition. If you want to bind Bounds, PreferredMinSize, AlignmentToParent or other similar properties to some properties of parent compositions, this property should be set to false to prevent from infinite size glowing.</summary>
				/// <returns>Returns true if it is awared.</returns>
				bool								GetSizeAffectParent();
				/// <summary>Set if the parent composition's size calculation is aware of the configuration of this composition.</summary>
				/// <param name="value">Set to true to be awared.</param>
				void								SetSizeAffectParent(bool value);
				
				bool								IsSizeAffectParent()override;
				Rect								GetPreferredBounds()override;
				Rect								GetBounds()override;
				/// <summary>Set the expected bounds.</summary>
				/// <param name="value">The expected bounds.</param>
				void								SetBounds(Rect value);

				/// <summary>Get the alignment to its parent. -1 in each alignment component means that the corressponding side is not aligned to its parent.</summary>
				/// <returns>The alignment to its parent.</returns>
				Margin								GetAlignmentToParent();
				/// <summary>Set the alignment to its parent. -1 in each alignment component means that the corressponding side is not aligned to its parent.</summary>
				/// <param name="value">The alignment to its parent.</param>
				void								SetAlignmentToParent(Margin value);
				/// <summary>Test is the composition aligned to its parent.</summary>
				/// <returns>Returns true if the composition is aligned to its parent.</returns>
				bool								IsAlignedToParent();
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\INCLUDEFORWARD.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_INCLUDEFORWARD
#define VCZH_PRESENTATION_COMPOSITION_INCLUDEFORWARD


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiTableComposition;
			class GuiCellComposition;
			class GuiTableSplitterCompositionBase;
			class GuiRowSplitterComposition;
			class GuiColumnSplitterComposition;

			class GuiStackComposition;
			class GuiStackItemComposition;
			class GuiFlowComposition;
			class GuiFlowItemComposition;

			class GuiSideAlignedComposition;
			class GuiPartialViewComposition;

			class GuiResponsiveCompositionBase;
			class GuiResponsiveViewComposition;
			class GuiResponsiveSharedComposition;
			class GuiResponsiveFixedComposition;
			class GuiResponsiveStackComposition;
			class GuiResponsiveGroupComposition;
			class GuiResponsiveContainerComposition;

			class GuiSharedSizeItemComposition;
			class GuiSharedSizeRootComposition;

			class GuiRepeatCompositionBase;
			class GuiRepeatStackComposition;
			class GuiRepeatFlowComposition;
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSHOST\GUIGRAPHICSHOST_ALT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_ALT
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_ALT


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Alt-Combined Shortcut Key Interfaces
***********************************************************************/

			class IGuiAltActionHost;
			
			/// <summary>IGuiAltAction is the handler when an alt-combined shortcut key is activated.</summary>
			class IGuiAltAction : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				static bool								IsLegalAlt(const WString& alt);

				virtual const WString&					GetAlt() = 0;
				virtual bool							IsAltEnabled() = 0;
				virtual bool							IsAltAvailable() = 0;
				virtual GuiGraphicsComposition*			GetAltComposition() = 0;
				virtual IGuiAltActionHost*				GetActivatingAltHost() = 0;
				virtual void							OnActiveAlt() = 0;
			};
			
			/// <summary>IGuiAltActionContainer enumerates multiple <see cref="IGuiAltAction"/>.</summary>
			class IGuiAltActionContainer : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				virtual vint							GetAltActionCount() = 0;
				virtual IGuiAltAction*					GetAltAction(vint index) = 0;
			};
			
			/// <summary>IGuiAltActionHost is an alt-combined shortcut key host. A host can also be entered or leaved, with multiple sub actions enabled or disabled.</summary>
			class IGuiAltActionHost : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				static void								CollectAltActionsFromControl(controls::GuiControl* control, bool includeThisControl, collections::Group<WString, IGuiAltAction*>& actions);
				
				virtual GuiGraphicsComposition*			GetAltComposition() = 0;
				virtual IGuiAltActionHost*				GetPreviousAltHost() = 0;
				virtual void							OnActivatedAltHost(IGuiAltActionHost* previousHost) = 0;
				virtual void							OnDeactivatedAltHost() = 0;
				virtual void							CollectAltActions(collections::Group<WString, IGuiAltAction*>& actions) = 0;
			};

			/// <summary>Default implementation for <see cref="IGuiAltActionHost"/></summary>
			class GuiAltActionHostBase : public virtual IGuiAltActionHost
			{
			private:
				GuiGraphicsComposition*					composition = nullptr;
				controls::GuiControl*					control = nullptr;
				bool									includeControl = true;
				IGuiAltActionHost*						previousHost = nullptr;

			protected:
				void									SetAltComposition(GuiGraphicsComposition* _composition);
				void									SetAltControl(controls::GuiControl* _control, bool _includeControl);

			public:
				GuiGraphicsComposition*					GetAltComposition()override;
				IGuiAltActionHost*						GetPreviousAltHost()override;
				void									OnActivatedAltHost(IGuiAltActionHost* _previousHost)override;
				void									OnDeactivatedAltHost()override;
				void									CollectAltActions(collections::Group<WString, IGuiAltAction*>& actions)override;
			};

/***********************************************************************
Alt-Combined Shortcut Key Interfaces Helpers
***********************************************************************/

			class GuiAltActionManager : public Object
			{
				typedef collections::Dictionary<WString, IGuiAltAction*>					AltActionMap;
				typedef collections::Dictionary<WString, controls::GuiControl*>				AltControlMap;
			protected:
				controls::GuiControlHost*				controlHost = nullptr;
				IGuiAltActionHost*						currentAltHost = nullptr;
				AltActionMap							currentActiveAltActions;
				AltControlMap							currentActiveAltTitles;
				WString									currentAltPrefix;
				VKEY									supressAltKey = VKEY::_UNKNOWN;

				void									EnterAltHost(IGuiAltActionHost* host);
				void									LeaveAltHost();
				bool									EnterAltKey(wchar_t key);
				void									LeaveAltKey();
				void									CreateAltTitles(const collections::Group<WString, IGuiAltAction*>& actions);
				vint									FilterTitles();
				void									ClearAltHost();
			public:
				GuiAltActionManager(controls::GuiControlHost* _controlHost);
				~GuiAltActionManager();

				void									CloseAltHost();
				bool									KeyDown(const NativeWindowKeyInfo& info);
				bool									KeyUp(const NativeWindowKeyInfo& info);
				bool									SysKeyDown(const NativeWindowKeyInfo& info);
				bool									SysKeyUp(const NativeWindowKeyInfo& info);
				bool									Char(const NativeWindowCharInfo& info);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSHOST\GUIGRAPHICSHOST_TAB.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_TAB
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_TAB


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Tab-Combined Shortcut Key Interfaces
***********************************************************************/
			
			/// <summary>IGuiTabAction is the handler when an tab-combined shortcut key is activated.</summary>
			class IGuiTabAction : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				virtual bool							GetAcceptTabInput() = 0;
				virtual vint							GetTabPriority() = 0;
				virtual bool							IsTabEnabled() = 0;
				virtual bool							IsTabAvailable() = 0;
			};

/***********************************************************************
Tab-Combined Shortcut Key Interfaces Helpers
***********************************************************************/

			class GuiTabActionManager : public Object
			{
				using ControlList = collections::List<controls::GuiControl*>;
			protected:
				controls::GuiControlHost*				controlHost = nullptr;
				ControlList								controlsInOrder;
				bool									available = true;
				bool									supressTabOnce = false;

				void									BuildControlList();
				controls::GuiControl*					GetNextFocusControl(controls::GuiControl* focusedControl, vint offset);
			public:
				GuiTabActionManager(controls::GuiControlHost* _controlHost);
				~GuiTabActionManager();

				void									InvalidateTabOrderCache();
				bool									KeyDown(const NativeWindowKeyInfo& info, GuiGraphicsComposition* focusedComposition);
				bool									Char(const NativeWindowCharInfo& info);
			};
		}
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIRESOURCE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIRESOURCE
#define VCZH_PRESENTATION_RESOURCES_GUIRESOURCE


namespace vl
{
	namespace workflow
	{
		class IWfCompilerCallback;
	}

	namespace presentation
	{
		class GuiResourceItem;
		class GuiResourceFolder;
		class GuiResource;

/***********************************************************************
Helper Functions
***********************************************************************/

		/// <summary>Get the folder path from a file path. The result folder path is ended with a separator.</summary>
		/// <returns>The folder path.</returns>
		/// <param name="filePath">The file path.</param>
		extern WString								GetFolderPath(const WString& filePath);
		/// <summary>Get the file name from a file path.</summary>
		/// <returns>The file name.</returns>
		/// <param name="filePath">The file path.</param>
		extern WString								GetFileName(const WString& filePath);
		/// <summary>Load a text file.</summary>
		/// <returns>Returns true if the operation succeeded.</returns>
		/// <param name="filePath">The text file path.</param>
		/// <param name="text">The text file content, if succeeded.</param>
		extern bool									LoadTextFile(const WString& filePath, WString& text);
		/// <summary>Test is a text a resource url and extract the protocol and the path.</summary>
		/// <returns>Returns true if the text is a resource url.</returns>
		/// <param name="text">The text.</param>
		/// <param name="protocol">The extracted protocol.</param>
		/// <param name="path">The extracted path.</param>
		extern bool									IsResourceUrl(const WString& text, WString& protocol, WString& path);

		extern void									HexToBinary(stream::IStream& stream, const WString& hexText);
		extern WString								BinaryToHex(stream::IStream& stream);

/***********************************************************************
Global String Key
***********************************************************************/

		struct GlobalStringKey
		{
		public:
			static GlobalStringKey					Empty;
			static GlobalStringKey					_InferType;
			static GlobalStringKey					_Set;
			static GlobalStringKey					_Ref;
			static GlobalStringKey					_Bind;
			static GlobalStringKey					_Format;
			static GlobalStringKey					_Str;
			static GlobalStringKey					_Eval;
			static GlobalStringKey					_Uri;
			static GlobalStringKey					_ControlTemplate;
			static GlobalStringKey					_ItemTemplate;

		private:
			vint									key = -1;

		public:
			static vint Compare(GlobalStringKey a, GlobalStringKey b){ return a.key - b.key; }
			bool operator==(GlobalStringKey g)const{ return key == g.key; }
			bool operator!=(GlobalStringKey g)const{ return key != g.key; }
			bool operator<(GlobalStringKey g)const{ return key < g.key; }
			bool operator<=(GlobalStringKey g)const{ return key <= g.key; }
			bool operator>(GlobalStringKey g)const{ return key > g.key; }
			bool operator>=(GlobalStringKey g)const{ return key >= g.key; }

			static GlobalStringKey					Get(const WString& string);
			vint									ToKey()const;
			WString									ToString()const;
		};

/***********************************************************************
Resource Image
***********************************************************************/
			
		/// <summary>
		/// Represnets an image to display.
		/// </summary>
		class GuiImageData : public Object, public Description<GuiImageData>
		{
		protected:
			Ptr<INativeImage>				image;
			vint							frameIndex;

		public:
			/// <summary>Create an empty image data.</summary>
			GuiImageData();
			/// <summary>Create an image data with a specified image and a frame index.</summary>
			/// <param name="_image">The specified image.</param>
			/// <param name="_frameIndex">The specified frame index.</param>
			GuiImageData(Ptr<INativeImage> _image, vint _frameIndex);
			~GuiImageData();

			/// <summary>Get the specified image.</summary>
			/// <returns>The specified image.</returns>
			Ptr<INativeImage>				GetImage();
			/// <summary>Get the specified frame index.</summary>
			/// <returns>The specified frame index.</returns>
			vint							GetFrameIndex();
		};

/***********************************************************************
Resource String
***********************************************************************/

		/// <summary>Represents a text resource.</summary>
		class GuiTextData : public Object, public Description<GuiTextData>
		{
		protected:
			WString							text;

		public:
			/// <summary>Create an empty text data.</summary>
			GuiTextData();
			/// <summary>Create a text data with a specified text.</summary>
			/// <param name="_text">The specified text.</param>
			GuiTextData(const WString& _text);
			
			/// <summary>Get the specified text.</summary>
			/// <returns>The specified text.</returns>
			WString							GetText();
		};

/***********************************************************************
Resource Structure
***********************************************************************/

		/// <summary>Resource node base.</summary>
		class GuiResourceNodeBase : public Object, public Description<GuiResourceNodeBase>
		{
			friend class GuiResourceFolder;
		protected:
			GuiResourceFolder*						parent;
			WString									name;
			WString									fileContentPath;
			WString									fileAbsolutePath;
			
		public:
			GuiResourceNodeBase();
			~GuiResourceNodeBase();

			/// <summary>Get the containing folder. Returns null means that this is the root resource node.</summary>
			/// <returns>The containing folder.</returns>
			GuiResourceFolder*						GetParent();
			/// <summary>Get the name of this resource node.</summary>
			/// <returns>The name of this resource node .</returns>
			const WString&							GetName();
			/// <summary>Get the resource path of this resource node</summary>
			/// <returns>The resource path of this resource node .</returns>
			WString									GetResourcePath();
			/// <summary>Get the file content path of this resource node. When saving the resource, if the path is not empty, the path will be serialized instead of the content.</summary>
			/// <returns>The file content path of this resource node .</returns>
			const WString&							GetFileContentPath();
			/// <summary>Get the absolute file content path of this resource node. This path points to an existing file containing the content.</summary>
			/// <returns>The file absolute path of this resource node .</returns>
			const WString&							GetFileAbsolutePath();
			/// <summary>Set the file content path of this resource node.</summary>
			/// <param name="content">The file content path of this resource node .</param>
			/// <param name="absolute">The file absolute path of this resource node .</param>
			void									SetFileContentPath(const WString& content, const WString& absolute);
		};

		struct GuiResourceLocation
		{
			WString									resourcePath;
			WString									filePath;

			GuiResourceLocation() = default;
			GuiResourceLocation(const WString& _resourcePath, const WString& _filePath);
			GuiResourceLocation(Ptr<GuiResourceNodeBase> node);

			bool operator==(const GuiResourceLocation& b)const { return resourcePath == b.resourcePath && filePath == b.filePath; }
			bool operator!=(const GuiResourceLocation& b)const { return !(*this == b); }
		};

		struct GuiResourceTextPos
		{
			GuiResourceLocation						originalLocation;
			vint									row = parsing::ParsingTextPos::UnknownValue;
			vint									column = parsing::ParsingTextPos::UnknownValue;

			GuiResourceTextPos() = default;
			GuiResourceTextPos(GuiResourceLocation location, parsing::ParsingTextPos position);

			bool operator==(const GuiResourceTextPos& b)const { return originalLocation == b.originalLocation && row == b.row && column == b.column; }
			bool operator!=(const GuiResourceTextPos& b)const { return !(*this == b); }
		};

		struct GuiResourceError
		{
		public:
			using List = collections::List<GuiResourceError>;

			GuiResourceLocation						location;
			GuiResourceTextPos						position;
			WString									message;

			GuiResourceError() = default;
			GuiResourceError(GuiResourceTextPos _position, const WString& _message);
			GuiResourceError(GuiResourceLocation _location, const WString& _message);
			GuiResourceError(GuiResourceLocation _location, GuiResourceTextPos _position, const WString& _message);

			bool operator==(const GuiResourceError& b)const { return location == b.location && position == b.position && message == b.message; }
			bool operator!=(const GuiResourceError& b)const { return !(*this == b); }

			static void								Transform(GuiResourceLocation _location, GuiResourceError::List& errors, collections::List<Ptr<parsing::ParsingError>>& parsingErrors);
			static void								Transform(GuiResourceLocation _location, GuiResourceError::List& errors, collections::List<Ptr<parsing::ParsingError>>& parsingErrors, parsing::ParsingTextPos offset);
			static void								Transform(GuiResourceLocation _location, GuiResourceError::List& errors, collections::List<Ptr<parsing::ParsingError>>& parsingErrors, GuiResourceTextPos offset);
			static void								SortAndLog(List& errors, collections::List<WString>& output, const WString& workingDirectory = WString::Empty);
		};

		class DocumentModel;
		class GuiResourcePathResolver;
		struct GuiResourcePrecompileContext;
		struct GuiResourceInitializeContext;
		class IGuiResourcePrecompileCallback;
		
		/// <summary>Resource item.</summary>
		class GuiResourceItem : public GuiResourceNodeBase, public Description<GuiResourceItem>
		{
			friend class GuiResourceFolder;
		protected:
			Ptr<DescriptableObject>					content;
			WString									typeName;
			
		public:
			/// <summary>Create a resource item.</summary>
			GuiResourceItem();
			~GuiResourceItem();

			/// <summary>Get the type of this resource item.</summary>
			/// <returns>The type name.</returns>
			const WString&							GetTypeName();
			
			/// <summary>Get the contained object for this resource item.</summary>
			/// <returns>The contained object.</returns>
			Ptr<DescriptableObject>					GetContent();
			/// <summary>Set the containd object for this resource item.</summary>
			/// <param name="_typeName">The type name of this contained object.</param>
			/// <param name="value">The contained object.</param>
			void									SetContent(const WString& _typeName, Ptr<DescriptableObject> value);

			/// <summary>Get the contained object as an image.</summary>
			/// <returns>The contained object.</returns>
			Ptr<GuiImageData>						AsImage();
			/// <summary>Get the contained object as an xml.</summary>
			/// <returns>The contained object.</returns>
			Ptr<parsing::xml::XmlDocument>			AsXml();
			/// <summary>Get the contained object as a string.</summary>
			/// <returns>The contained object.</returns>
			Ptr<GuiTextData>						AsString();
			/// <summary>Get the contained object as a document model.</summary>
			/// <returns>The contained object.</returns>
			Ptr<DocumentModel>						AsDocument();
		};
		
		/// <summary>Resource folder. A resource folder contains many sub folders and sub items.</summary>
		class GuiResourceFolder : public GuiResourceNodeBase, public Description<GuiResourceFolder>
		{
		protected:
			typedef collections::Dictionary<WString, Ptr<GuiResourceItem>>		ItemMap;
			typedef collections::Dictionary<WString, Ptr<GuiResourceFolder>>	FolderMap;
			typedef collections::List<Ptr<GuiResourceItem>>						ItemList;
			typedef collections::List<Ptr<GuiResourceFolder>>					FolderList;

			struct DelayLoading
			{
				WString								type;
				WString								workingDirectory;
				Ptr<GuiResourceItem>				preloadResource;
			};

			typedef collections::List<DelayLoading>								DelayLoadingList;

			WString									importUri;
			ItemMap									items;
			FolderMap								folders;

			void									LoadResourceFolderFromXml(DelayLoadingList& delayLoadings, const WString& containingFolder, Ptr<parsing::xml::XmlElement> folderXml, GuiResourceError::List& errors);
			void									SaveResourceFolderToXml(Ptr<parsing::xml::XmlElement> xmlParent);
			void									CollectTypeNames(collections::List<WString>& typeNames);
			void									LoadResourceFolderFromBinary(DelayLoadingList& delayLoadings, stream::internal::ContextFreeReader& reader, collections::List<WString>& typeNames, GuiResourceError::List& errors);
			void									SaveResourceFolderToBinary(stream::internal::ContextFreeWriter& writer, collections::List<WString>& typeNames);
			void									PrecompileResourceFolder(GuiResourcePrecompileContext& context, IGuiResourcePrecompileCallback* callback, GuiResourceError::List& errors);
			void									InitializeResourceFolder(GuiResourceInitializeContext& context, GuiResourceError::List& errors);
			void									ImportFromUri(const WString& uri, GuiResourceTextPos position, GuiResourceError::List& errors);
		public:
			/// <summary>Create a resource folder.</summary>
			GuiResourceFolder();
			~GuiResourceFolder();

			///<summary>Get the import uri for this folder.</summary>
			///<returns>The import uri for this folder. Returns an empty string for non-import folders</returns>
			const WString&							GetImportUri();
			///<summary>Set the import uri for this folder.</summary>
			///<param name="uri">The import uri for this folder. Set an empty string for non-import folders</param>
			void									SetImportUri(const WString& uri);

			/// <summary>Get all sub items.</summary>
			/// <returns>All sub items.</returns>
			const ItemList&							GetItems();
			/// <summary>Get the item of a specified name.</summary>
			/// <returns>The item of a specified name.</returns>
			/// <param name="name">The specified name.</param>
			Ptr<GuiResourceItem>					GetItem(const WString& name);
			/// <summary>Add a resource item.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="name">The name of this resource item.</param>
			/// <param name="item">The resource item.</param>
			bool									AddItem(const WString& name, Ptr<GuiResourceItem> item);
			/// <summary>Remove a resource item of a specified name.</summary>
			/// <returns>Returns the removed resource item if this operation succeeded.</returns>
			/// <param name="name">The name of this resource item.</param>
			Ptr<GuiResourceItem>					RemoveItem(const WString& name);
			/// <summary>Remove all resource item.</summary>
			void									ClearItems();
			
			/// <summary>Get all sub folders.</summary>
			/// <returns>All sub folders.</returns>
			const FolderList&						GetFolders();
			/// <summary>Get the folder of a specified name.</summary>
			/// <returns>The folder of a specified name.</returns>
			/// <param name="name">The specified name.</param>
			Ptr<GuiResourceFolder>					GetFolder(const WString& name);
			/// <summary>Add a resource folder.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="name">The name of this resource folder.</param>
			/// <param name="folder">The resource folder.</param>
			bool									AddFolder(const WString& name, Ptr<GuiResourceFolder> folder);
			/// <summary>Remove a resource folder of a specified name.</summary>
			/// <returns>Returns the removed resource folder if this operation succeeded.</returns>
			/// <param name="name">The name of this resource folder.</param>
			Ptr<GuiResourceFolder>					RemoveFolder(const WString& name);
			/// <summary>Remove all resource folders.</summary>
			void									ClearFolders();

			/// <summary>Get a contained resource object using a path like "Packages\Application\Name".</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<DescriptableObject>					GetValueByPath(const WString& path);
			/// <summary>Get a resource folder using a path like "Packages\Application\Name\".</summary>
			/// <returns>The resource folder.</returns>
			/// <param name="path">The path.</param>
			Ptr<GuiResourceFolder>					GetFolderByPath(const WString& path);
			/// <summary>Create a contained resource object using a path like "Packages\Application\Name".</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="path">The path.</param>
			/// <param name="typeName">The type name of this contained object.</param>
			/// <param name="value">The contained object.</param>
			bool									CreateValueByPath(const WString& path, const WString& typeName, Ptr<DescriptableObject> value);
		};

/***********************************************************************
Resource
***********************************************************************/

		enum class GuiResourceUsage
		{
			DataOnly,
			InstanceClass,
		};

		/// <summary>Resource metadata.</summary>
		class GuiResourceMetadata : public Object
		{
		public:
			WString									name;
			WString									version;
			collections::List<WString>				dependencies;

			void									LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, GuiResourceLocation location, GuiResourceError::List& errors);
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
		};
		
		/// <summary>Resource. A resource is a root resource folder that does not have a name.</summary>
		class GuiResource : public GuiResourceFolder, public Description<GuiResource>
		{
		protected:
			WString									workingDirectory;
			Ptr<GuiResourceMetadata>				metadata;

			static void								ProcessDelayLoading(Ptr<GuiResource> resource, DelayLoadingList& delayLoadings, GuiResourceError::List& errors);
		public:
			static const wchar_t*					CurrentVersionString;

			/// <summary>Create a resource.</summary>
			GuiResource();
			~GuiResource();

			/// <summary>Get the metadata of the resource.</summary>
			/// <returns>The metadata.</returns>
			Ptr<GuiResourceMetadata>				GetMetadata();

			/// <summary>Get the directory where the resource is load.</summary>
			/// <returns>The directory.</returns>
			WString									GetWorkingDirectory();

			/// <summary>Load a resource from an xml file. If the xml file refers other files, they will be loaded as well.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="xml">The xml document.</param>
			/// <param name="filePath">The file path of the resource.</param>
			/// <param name="workingDirectory">The working directory for loading external resources.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<GuiResource>					LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, const WString& filePath, const WString& workingDirectory, GuiResourceError::List& errors);

			/// <summary>Load a resource from an xml file. If the xml file refers other files, they will be loaded as well.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="filePath">The file path of the xml file.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<GuiResource>					LoadFromXml(const WString& filePath, GuiResourceError::List& errors);

			/// <summary>Save the resource to xml.</summary>
			/// <returns>The xml.</returns>
			Ptr<parsing::xml::XmlDocument>			SaveToXml();
			
			/// <summary>Load a precompiled resource from a stream.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="stream">The stream.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<GuiResource>					LoadPrecompiledBinary(stream::IStream& stream, GuiResourceError::List& errors);

			/// <summary>Load a precompiled resource from a stream. This function will hit an assert if there are errors.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="stream">The stream.</param>
			static Ptr<GuiResource>					LoadPrecompiledBinary(stream::IStream& stream);
			
			/// <summary>Save the precompiled resource to a stream.</summary>
			/// <param name="stream">The stream.</param>
			void									SavePrecompiledBinary(stream::IStream& stream);

			/// <summary>Precompile this resource to improve performance.</summary>
			/// <returns>The resource folder contains all precompiled result. The folder will be added to the resource if there is no error.</returns>
			/// <param name="callback">A callback to receive progress.</param>
			/// <param name="errors">All collected errors during precompiling a resource.</param>
			Ptr<GuiResourceFolder>					Precompile(IGuiResourcePrecompileCallback* callback, GuiResourceError::List& errors);

			/// <summary>Initialize a precompiled resource.</summary>
			/// <param name="usage">In which role an application is initializing this resource.</param>
			/// <param name="errors">All collected errors during initializing a resource.</param>
			void									Initialize(GuiResourceUsage usage, GuiResourceError::List& errors);
			
			/// <summary>Get a contained document model using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<DocumentModel>						GetDocumentByPath(const WString& path);
			/// <summary>Get a contained image using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<GuiImageData>						GetImageByPath(const WString& path);
			/// <summary>Get a contained xml using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<parsing::xml::XmlDocument>			GetXmlByPath(const WString& path);
			/// <summary>Get a contained string object using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			WString									GetStringByPath(const WString& path);
		};

/***********************************************************************
Resource Path Resolver
***********************************************************************/

		/// <summary>Represents a symbol resolver for loading a resource of a certain protocol.</summary>
		class IGuiResourcePathResolver : public IDescriptable, public Description<IGuiResourcePathResolver>
		{
		public:
			/// <summary>Load a resource when the descriptor is something like a protocol-prefixed uri.</summary>
			/// <returns>The loaded resource. Returns null if failed to load.</returns>
			/// <param name="path">The path.</param>
			virtual Ptr<DescriptableObject>					ResolveResource(const WString& path)=0;
		};

		/// <summary>Represents an <see cref="IGuiResourcePathResolver"/> factory.</summary>
		class IGuiResourcePathResolverFactory : public IDescriptable, public Description<IGuiResourcePathResolverFactory>
		{
		public:
			/// <summary>Get the protocol for this resolver.</summary>
			/// <returns>The protocol.</returns>
			virtual WString									GetProtocol()=0;

			/// <summary>Create an <see cref="IGuiResourcePathResolver"/> object.</summary>
			/// <returns>The created resolver.</returns>
			/// <param name="resource">The resource context.</param>
			/// <param name="workingDirectory">The working directory context.</param>
			virtual Ptr<IGuiResourcePathResolver>			CreateResolver(Ptr<GuiResource> resource, const WString& workingDirectory)=0;
		};
		
		/// <summary>Represents a symbol resolver for loading a resource.</summary>
		class GuiResourcePathResolver : public Object, public Description<GuiResourcePathResolver>
		{
			typedef collections::Dictionary<WString, Ptr<IGuiResourcePathResolver>>		ResolverMap;
		protected:
			ResolverMap										resolvers;
			Ptr<GuiResource>								resource;
			WString											workingDirectory;

		public:
			/// <summary>Create a resolver.</summary>
			/// <param name="_resource">The resource context.</param>
			/// <param name="_workingDirectory">The working directory context.</param>
			GuiResourcePathResolver(Ptr<GuiResource> _resource, const WString& _workingDirectory);
			~GuiResourcePathResolver();

			/// <summary>Load a resource when the descriptor is something like a protocol-prefixed uri.</summary>
			/// <returns>The loaded resource. Returns null if failed to load.</returns>
			/// <param name="protocol">The protocol.</param>
			/// <param name="path">The path.</param>
			Ptr<DescriptableObject>							ResolveResource(const WString& protocol, const WString& path);
		};

/***********************************************************************
Resource Type Resolver
***********************************************************************/

		class IGuiResourceTypeResolver_Precompile;
		class IGuiResourceTypeResolver_Initialize;
		class IGuiResourceTypeResolver_DirectLoadXml;
		class IGuiResourceTypeResolver_DirectLoadStream;
		class IGuiResourceTypeResolver_IndirectLoad;

		/// <summary>Represents a symbol type for loading a resource.</summary>
		class IGuiResourceTypeResolver : public virtual IDescriptable, public Description<IGuiResourceTypeResolver>
		{
		public:
			/// <summary>Get the type of the resource that load by this resolver.</summary>
			/// <returns>The type.</returns>
			virtual WString										GetType() = 0;
			/// <summary>Test is this resource able to serialize in an XML resource or not.</summary>
			/// <returns>Returns true if this resource is able to serialize in an XML resource.</returns>
			virtual bool										XmlSerializable() = 0;
			/// <summary>Test is this resource able to serialize in a precompiled binary resource or not.</summary>
			/// <returns>Returns true if this resource is able to serialize in a precompiled binary resource.</returns>
			virtual bool										StreamSerializable() = 0;
			
			/// <summary>Get the precompiler for the type resolver.</summary>
			/// <returns>Returns null if the type resolve does not support precompiling.</returns>
			virtual IGuiResourceTypeResolver_Precompile*		Precompile(){ return 0; }
			/// <summary>Get the initializer for the type resolver.</summary>
			/// <returns>Returns null if the type resolve does not support initializing.</returns>
			virtual IGuiResourceTypeResolver_Initialize*		Initialize(){ return 0; }
			/// <summary>Get the object for convert the resource between xml and object.</summary>
			/// <returns>Returns null if the type resolver does not have this ability.</returns>
			virtual IGuiResourceTypeResolver_DirectLoadXml*		DirectLoadXml(){ return 0; }
			/// <summary>Get the object for convert the resource between stream and object.</summary>
			/// <returns>Returns null if the type resolver does not have this ability.</returns>
			virtual IGuiResourceTypeResolver_DirectLoadStream*	DirectLoadStream(){ return 0; }
			/// <summary>Get the object for convert the resource between the preload type and the current type.</summary>
			/// <returns>Returns null if the type resolver does not have this ability.</returns>
			virtual IGuiResourceTypeResolver_IndirectLoad*		IndirectLoad(){ return 0; }
		};

		/// <summary>Provide a context for resource precompiling</summary>
		struct GuiResourcePrecompileContext
		{
			typedef collections::Dictionary<Ptr<DescriptableObject>, Ptr<DescriptableObject>>	PropertyMap;

			/// <summary>Progress callback.</summary>
			workflow::IWfCompilerCallback*						compilerCallback = nullptr;
			/// <summary>The folder to contain compiled objects.</summary>
			Ptr<GuiResourceFolder>								targetFolder;
			/// <summary>The root resource object.</summary>
			GuiResource*										rootResource = nullptr;
			/// <summary>Indicate the pass index of this precompiling pass.</summary>
			vint												passIndex = -1;
			/// <summary>The path resolver. This is only for delay load resource.</summary>
			Ptr<GuiResourcePathResolver>						resolver;
			/// <summary>Additional properties for resource item contents</summary>
			PropertyMap											additionalProperties;
		};

		/// <summary>
		///		Represents a precompiler for resources of a specified type.
		///		Current resources that needs precompiling:
		///		Workflow:
		///			Pass  0: Collect workflow scripts / Compile localized strings / Generate ClassNameRecord
		///			Pass  1: Compile workflow scripts
		///		Instance:
		///			Pass  2: Collect instance types													/ Compile animation types
		///			Pass  3: Compile
		///			Pass  4: Generate instance types with event handler functions to TemporaryClass	/ Compile animation types
		///			Pass  5: Compile
		///			Pass  6: Generate instance types with everything to InstanceCtor				/ Compile animation types
		///			Pass  7: Compile
		/// </summary>
		class IGuiResourceTypeResolver_Precompile : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_Precompile>
		{
		public:
			enum PassNames
			{
				Workflow_Collect					= 0,
				Workflow_Compile					= 1,
				Workflow_Max						= Workflow_Compile,

				Instance_CollectInstanceTypes		= 2,
				Instance_CompileInstanceTypes		= 3,
				Instance_CollectEventHandlers		= 4,
				Instance_CompileEventHandlers		= 5,
				Instance_GenerateInstanceClass		= 6,
				Instance_CompileInstanceClass		= 7,
				Instance_Max						= Instance_CompileInstanceClass,
			};

			enum PassSupport
			{
				NotSupported,
				PerResource,
				PerPass,
			};

			/// <summary>Get the maximum pass index that the precompiler needs.</summary>
			/// <returns>Returns the maximum pass index. The precompiler doesn't not need to response to every pass.</returns>
			virtual vint										GetMaxPassIndex() = 0;
			/// <summary>Get how this resolver supports precompiling.</summary>
			/// <param name="passIndex">The pass index.</param>
			/// <returns>Returns how this resolver supports precompiling.</returns>
			virtual PassSupport									GetPassSupport(vint passIndex) = 0;
			/// <summary>Precompile the resource item.</summary>
			/// <param name="resource">The resource to precompile.</param>
			/// <param name="context">The context for precompiling.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual void										PerResourcePrecompile(Ptr<GuiResourceItem> resource, GuiResourcePrecompileContext& context, GuiResourceError::List& errors) = 0;
			/// <summary>Precompile for a pass.</summary>
			/// <param name="context">The context for precompiling.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual void										PerPassPrecompile(GuiResourcePrecompileContext& context, GuiResourceError::List& errors) = 0;
		};

		class IGuiResourcePrecompileCallback : public virtual IDescriptable, public Description<IGuiResourcePrecompileCallback>
		{
		public:
			virtual workflow::IWfCompilerCallback*				GetCompilerCallback() = 0;
			virtual void										OnPerPass(vint passIndex) = 0;
			virtual void										OnPerResource(vint passIndex, Ptr<GuiResourceItem> resource) = 0;
		};

		/// <summary>Provide a context for resource initializing</summary>
		struct GuiResourceInitializeContext : GuiResourcePrecompileContext
		{
			GuiResourceUsage									usage;
		};

		/// <summary>
		///		Represents a precompiler for resources of a specified type.
		///		Current resources that needs precompiling:
		///			Pass 0: Script		(initialize view model scripts)
		///			Pass 1: Script		(initialize shared scripts)
		///			Pass 2: Script		(initialize instance scripts)
		/// </summary>
		class IGuiResourceTypeResolver_Initialize : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_Initialize>
		{
		public:
			/// <summary>Get the maximum pass index that the initializer needs.</summary>
			/// <returns>Returns the maximum pass index. The initializer doesn't not need to response to every pass.</returns>
			virtual vint										GetMaxPassIndex() = 0;
			/// <summary>Initialize the resource item.</summary>
			/// <param name="resource">The resource to initializer.</param>
			/// <param name="context">The context for initializing.</param>
			/// <param name="errors">All collected errors during initializing a resource.</param>
			virtual void										Initialize(Ptr<GuiResourceItem> resource, GuiResourceInitializeContext& context, GuiResourceError::List& errors) = 0;
		};

		/// <summary>Represents a symbol type for loading a resource without a preload type.</summary>
		class IGuiResourceTypeResolver_DirectLoadXml : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_DirectLoadXml>
		{
		public:
			/// <summary>Serialize a resource to an xml element. This function is called if this type resolver does not have a preload type.</summary>
			/// <returns>The serialized xml element.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="content">The object to serialize.</param>
			virtual Ptr<parsing::xml::XmlElement>				Serialize(Ptr<GuiResourceItem> resource, Ptr<DescriptableObject> content) = 0;

			/// <summary>Load a resource for a type inside an xml element.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="element">The xml element.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlElement> element, GuiResourceError::List& errors) = 0;

			/// <summary>Load a resource for a type from a file.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="path">The file path.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<GuiResourceItem> resource, const WString& path, GuiResourceError::List& errors) = 0;
		};

		/// <summary>Represents a symbol type for loading a resource without a preload type.</summary>
		class IGuiResourceTypeResolver_DirectLoadStream : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_DirectLoadStream>
		{
		public:
			/// <summary>Serialize a precompiled resource to a stream.</summary>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="content">The content to serialize.</param>
			/// <param name="stream">The stream.</param>
			virtual void										SerializePrecompiled(Ptr<GuiResourceItem> resource, Ptr<DescriptableObject> content, stream::IStream& stream) = 0;

			/// <summary>Load a precompiled resource from a stream.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="stream">The stream.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResourcePrecompiled(Ptr<GuiResourceItem> resource, stream::IStream& stream, GuiResourceError::List& errors) = 0;
		};

		/// <summary>Represents a symbol type for loading a resource with a preload type.</summary>
		class IGuiResourceTypeResolver_IndirectLoad : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_IndirectLoad>
		{
		public:
			/// <summary>Get the preload type to load the resource before loading itself.</summary>
			/// <returns>The preload type. Returns an empty string to indicate that there is no preload type for this resolver.</returns>
			virtual WString										GetPreloadType() = 0;
			/// <summary>Get the delay load feature for this resolver.</summary>
			/// <returns>Returns true if this type need to delay load.</returns>
			virtual bool										IsDelayLoad() = 0;

			/// <summary>Serialize a resource to a resource in preload type.</summary>
			/// <returns>The serialized resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="content">The object to serialize.</param>
			virtual Ptr<DescriptableObject>						Serialize(Ptr<GuiResourceItem> resource, Ptr<DescriptableObject> content) = 0;

			/// <summary>Load a resource for a type from a resource loaded by the preload type resolver.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="resolver">The path resolver. This is only for delay load resource.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<GuiResourceItem> resource, Ptr<GuiResourcePathResolver> resolver, GuiResourceError::List& errors) = 0;
		};

/***********************************************************************
Resource Resolver Manager
***********************************************************************/

		/// <summary>A resource resolver manager.</summary>
		class IGuiResourceResolverManager : public IDescriptable, public Description<IGuiResourceResolverManager>
		{
		public:
			/// <summary>Get the <see cref="IGuiResourcePathResolverFactory"/> for a protocol.</summary>
			/// <returns>The factory.</returns>
			/// <param name="protocol">The protocol.</param>
			virtual IGuiResourcePathResolverFactory*			GetPathResolverFactory(const WString& protocol) = 0;
			/// <summary>Set the <see cref="IGuiResourcePathResolverFactory"/> for a protocol.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="factory">The factory.</param>
			virtual bool										SetPathResolverFactory(Ptr<IGuiResourcePathResolverFactory> factory) = 0;
			/// <summary>Get the <see cref="IGuiResourceTypeResolver"/> for a resource type.</summary>
			/// <returns>The resolver.</returns>
			/// <param name="type">The resource type.</param>
			virtual IGuiResourceTypeResolver*					GetTypeResolver(const WString& type) = 0;
			/// <summary>Set the <see cref="IGuiResourceTypeResolver"/> for a resource type.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="resolver">The resolver.</param>
			virtual bool										SetTypeResolver(Ptr<IGuiResourceTypeResolver> resolver) = 0;
			/// <summary>Get the maximum precompiling pass index.</summary>
			/// <returns>The maximum precompiling pass index.</returns>
			virtual vint										GetMaxPrecompilePassIndex() = 0;
			/// <summary>Get the maximum initializing pass index.</summary>
			/// <returns>The maximum initializing pass index.</returns>
			virtual vint										GetMaxInitializePassIndex() = 0;
			/// <summary>Get names of all per resource resolvers for a pass.</summary>
			/// <param name="passIndex">The pass index.</param>
			/// <param name="names">Names of resolvers</param>
			virtual void										GetPerResourceResolverNames(vint passIndex, collections::List<WString>& names) = 0;
			/// <summary>Get names of all per pass resolvers for a pass.</summary>
			/// <param name="passIndex">The pass index.</param>
			/// <param name="names">Names of resolvers</param>
			virtual void										GetPerPassResolverNames(vint passIndex, collections::List<WString>& names) = 0;
		};
		
		extern IGuiResourceResolverManager*						GetResourceResolverManager();
		extern void												DecompressStream(const char** buffer, bool compress, vint rows, vint block, vint remain, stream::IStream& outputStream);
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUICONTROLSHARED.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLSHARED
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLSHARED


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControlHost;
			class GuiCustomControl;

			/// <summary>The visual state for button.</summary>
			enum class ButtonState
			{
				/// <summary>Normal state.</summary>
				Normal,
				/// <summary>Active state (when the cursor is hovering on a button).</summary>
				Active,
				/// <summary>Pressed state (when the buttin is being pressed).</summary>
				Pressed,
			};

			/// <summary>Represents the sorting state of list view items related to this column.</summary>
			enum class ColumnSortingState
			{
				/// <summary>Not sorted.</summary>
				NotSorted,
				/// <summary>Ascending.</summary>
				Ascending,
				/// <summary>Descending.</summary>
				Descending,
			};

			/// <summary>Represents the order of tab pages.</summary>
			enum class TabPageOrder
			{
				/// <summary>Unknown.</summary>
				Unknown,
				/// <summary>Left to right.</summary>
				LeftToRight,
				/// <summary>Right to left.</summary>
				RightToLeft,
				/// <summary>Top to bottom.</summary>
				TopToBottom,
				/// <summary>Bottom to top.</summary>
				BottomToTop,
			};

			/// <summary>A command executor for the combo box to change the control state.</summary>
			class ITextBoxCommandExecutor : public virtual IDescriptable, public Description<ITextBoxCommandExecutor>
			{
			public:
				/// <summary>Override the text content in the control.</summary>
				/// <param name="value">The new text content.</param>
				virtual void						UnsafeSetText(const WString& value) = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IScrollCommandExecutor : public virtual IDescriptable, public Description<IScrollCommandExecutor>
			{
			public:
				/// <summary>Do small decrement.</summary>
				virtual void						SmallDecrease() = 0;
				/// <summary>Do small increment.</summary>
				virtual void						SmallIncrease() = 0;
				/// <summary>Do big decrement.</summary>
				virtual void						BigDecrease() = 0;
				/// <summary>Do big increment.</summary>
				virtual void						BigIncrease() = 0;

				/// <summary>Change to total size of the scroll.</summary>
				/// <param name="value">The total size.</param>
				virtual void						SetTotalSize(vint value) = 0;
				/// <summary>Change to page size of the scroll.</summary>
				/// <param name="value">The page size.</param>
				virtual void						SetPageSize(vint value) = 0;
				/// <summary>Change to position of the scroll.</summary>
				/// <param name="value">The position.</param>
				virtual void						SetPosition(vint value) = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class ITabCommandExecutor : public virtual IDescriptable, public Description<ITabCommandExecutor>
			{
			public:
				/// <summary>Select a tab page.</summary>
				/// <param name="index">The specified position for the tab page.</param>
				/// <param name="setFocus">Set to true to set focus to the tab control.</param>
				virtual void						ShowTab(vint index, bool setFocus) = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IDatePickerCommandExecutor : public virtual IDescriptable, public Description<IDatePickerCommandExecutor>
			{
			public:
				/// <summary>Called when the date has been changed.</summary>
				virtual void						NotifyDateChanged() = 0;
				/// <summary>Called when navigated to a date.</summary>
				virtual void						NotifyDateNavigated() = 0;
				/// <summary>Called when selected a date.</summary>
				virtual void						NotifyDateSelected() = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IRibbonGroupCommandExecutor : public virtual IDescriptable, public Description<IRibbonGroupCommandExecutor>
			{
			public:
				/// <summary>Called when the expand button is clicked.</summary>
				virtual void						NotifyExpandButtonClicked() = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IRibbonGalleryCommandExecutor : public virtual IDescriptable, public Description<IRibbonGalleryCommandExecutor>
			{
			public:
				/// <summary>Called when the scroll up button is clicked.</summary>
				virtual void						NotifyScrollUp() = 0;
				/// <summary>Called when the scroll down button is clicked.</summary>
				virtual void						NotifyScrollDown() = 0;
				/// <summary>Called when the dropdown button is clicked.</summary>
				virtual void						NotifyDropdown() = 0;
			};

			class GuiInstanceRootObject;

			/// <summary>
			/// Represnets a component.
			/// </summary>
			class GuiComponent : public Object, public Description<GuiComponent>
			{
			public:
				GuiComponent();
				~GuiComponent();

				virtual void							Attach(GuiInstanceRootObject* rootObject);
				virtual void							Detach(GuiInstanceRootObject* rootObject);
			};

/***********************************************************************
Animation
***********************************************************************/

			/// <summary>Animation.</summary>
			class IGuiAnimation abstract : public virtual IDescriptable, public Description<IGuiAnimation>
			{
			public:
				/// <summary>Called when the animation is about to play the first frame.</summary>
				virtual void							Start() = 0;

				/// <summary>Called when the animation is about to pause.</summary>
				virtual void							Pause() = 0;

				/// <summary>Called when the animation is about to resume.</summary>
				virtual void							Resume() = 0;

				/// <summary>Play the animation. The animation should calculate the time itself to determine the content of the current state of animating objects.</summary>
				virtual void							Run() = 0;

				/// <summary>Test if the animation has ended.</summary>
				/// <returns>Returns true if the animation has ended.</returns>
				virtual bool							GetStopped() = 0;

				/// <summary>Create a finite animation.</summary>
				/// <returns>Returns the created animation.</returns>
				/// <param name="run">The animation callback for each frame.</param>
				/// <param name="milliseconds">The length of the animation.</param>
				static Ptr<IGuiAnimation>				CreateAnimation(const Func<void(vuint64_t)>& run, vuint64_t milliseconds);

				/// <summary>Create an infinite animation.</summary>
				/// <returns>Returns the created animation.</returns>
				/// <param name="run">The animation callback for each frame.</param>
				static Ptr<IGuiAnimation>				CreateAnimation(const Func<void(vuint64_t)>& run);
			};

/***********************************************************************
Root Object
***********************************************************************/

			class RootObjectTimerCallback;

			/// <summary>Represnets a root GUI object.</summary>
			class GuiInstanceRootObject abstract : public Description<GuiInstanceRootObject>
			{
				friend class RootObjectTimerCallback;
				typedef collections::List<Ptr<description::IValueSubscription>>		SubscriptionList;
			protected:
				Ptr<GuiResourcePathResolver>					resourceResolver;
				SubscriptionList								subscriptions;
				collections::SortedList<GuiComponent*>			components;
				Ptr<RootObjectTimerCallback>					timerCallback;
				collections::SortedList<Ptr<IGuiAnimation>>		runningAnimations;
				collections::SortedList<Ptr<IGuiAnimation>>		pendingAnimations;
				bool											finalized = false;

				virtual controls::GuiControlHost*				GetControlHostForInstance() = 0;
				void											InstallTimerCallback(controls::GuiControlHost* controlHost);
				bool											UninstallTimerCallback(controls::GuiControlHost* controlHost);
				void											OnControlHostForInstanceChanged();
				void											StartPendingAnimations();
			public:
				GuiInstanceRootObject();
				~GuiInstanceRootObject();

				/// <summary>Clear all subscriptions and components.</summary>
				void											FinalizeInstance();

				/// <summary>Test has the object been finalized.</summary>
				/// <returns>Returns true if this object has been finalized.</returns>
				bool											IsFinalized();

				void											FinalizeInstanceRecursively(templates::GuiTemplate* thisObject);
				void											FinalizeInstanceRecursively(GuiCustomControl* thisObject);
				void											FinalizeInstanceRecursively(GuiControlHost* thisObject);
				void											FinalizeGeneralInstance(GuiInstanceRootObject* thisObject);

				/// <summary>Set the resource resolver to connect the current root object to the resource creating it.</summary>
				/// <param name="resolver">The resource resolver</param>
				void											SetResourceResolver(Ptr<GuiResourcePathResolver> resolver);
				/// <summary>Resolve a resource using the current resource resolver.</summary>
				/// <returns>The loaded resource. Returns null if failed to load.</returns>
				/// <param name="protocol">The protocol.</param>
				/// <param name="path">The path.</param>
				/// <param name="ensureExist">Set to true and it will throw an exception if the resource doesn't exist.</param>
				Ptr<DescriptableObject>							ResolveResource(const WString& protocol, const WString& path, bool ensureExist);

				/// <summary>Add a subscription. When this control host is disposing, all attached subscriptions will be deleted.</summary>
				/// <returns>Returns null if this operation failed.</returns>
				/// <param name="subscription">The subscription to test.</param>
				Ptr<description::IValueSubscription>			AddSubscription(Ptr<description::IValueSubscription> subscription);
				/// <summary>Clear all subscriptions.</summary>
				void											UpdateSubscriptions();

				/// <summary>Add a component. When this control host is disposing, all attached components will be deleted.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="component">The component to add.</param>
				bool											AddComponent(GuiComponent* component);

				/// <summary>Add a control host as a component. When this control host is disposing, all attached components will be deleted.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="controlHost">The controlHost to add.</param>
				bool											AddControlHostComponent(GuiControlHost* controlHost);

				/// <summary>Add an animation. The animation will be paused if the root object is removed from a window.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="animation">The animation.</param>
				bool											AddAnimation(Ptr<IGuiAnimation> animation);

				/// <summary>Kill an animation.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="animation">The animation.</param>
				bool											KillAnimation(Ptr<IGuiAnimation> animation);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUIANIMATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUIANIMATION
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUIANIMATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class IGuiAnimationCoroutine : public Object, public Description<IGuiAnimationCoroutine>
			{
			public:
				class IImpl : public virtual IGuiAnimation, public Description<IImpl>
				{
				public:
					virtual void			OnPlayAndWait(Ptr<IGuiAnimation> animation) = 0;
					virtual void			OnPlayInGroup(Ptr<IGuiAnimation> animation, vint groupId) = 0;
					virtual void			OnWaitForGroup(vint groupId) = 0;
				};

				typedef Func<Ptr<description::ICoroutine>(IImpl*)>	Creator;

				static void					WaitAndPause(IImpl* impl, vuint64_t milliseconds);
				static void					PlayAndWaitAndPause(IImpl* impl, Ptr<IGuiAnimation> animation);
				static void					PlayInGroupAndPause(IImpl* impl, Ptr<IGuiAnimation> animation, vint groupId);
				static void					WaitForGroupAndPause(IImpl* impl, vint groupId);
				static void					ReturnAndExit(IImpl* impl);
				static Ptr<IGuiAnimation>	Create(const Creator& creator);
			};
		}
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIDOCUMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIDOCUMENT
#define VCZH_PRESENTATION_RESOURCES_GUIDOCUMENT


namespace vl
{
	namespace presentation
	{
		class DocumentTextRun;
		class DocumentStylePropertiesRun;
		class DocumentStyleApplicationRun;
		class DocumentHyperlinkRun;
		class DocumentImageRun;
		class DocumentEmbeddedObjectRun;
		class DocumentParagraphRun;

/***********************************************************************
Rich Content Document (style)
***********************************************************************/

		struct DocumentFontSize
		{
			double							size = 0;
			bool							relative = false;

			DocumentFontSize()
			{
			}

			DocumentFontSize(double _size, bool _relative)
				:size(_size)
				, relative(_relative)
			{
			}

			static DocumentFontSize			Parse(const WString& value);
			WString							ToString()const;

			bool operator==(const DocumentFontSize& value)const
			{
				return size == value.size && relative == value.relative;
			}

			bool operator!=(const DocumentFontSize& value)const
			{
				return size != value.size || relative != value.relative;
			}
		};

		/// <summary>Represents a text style.</summary>
		class DocumentStyleProperties : public Object, public Description<DocumentStyleProperties>
		{
		public:
			/// <summary>Font face.</summary>
			Nullable<WString>				face;
			/// <summary>Font size.</summary>
			Nullable<DocumentFontSize>		size;
			/// <summary>Font color.</summary>
			Nullable<Color>					color;
			/// <summary>Font color.</summary>
			Nullable<Color>					backgroundColor;
			/// <summary>Bold.</summary>
			Nullable<bool>					bold;
			/// <summary>Italic.</summary>
			Nullable<bool>					italic;
			/// <summary>Underline.</summary>
			Nullable<bool>					underline;
			/// <summary>Strikeline.</summary>
			Nullable<bool>					strikeline;
			/// <summary>Antialias.</summary>
			Nullable<bool>					antialias;
			/// <summary>Vertical antialias.</summary>
			Nullable<bool>					verticalAntialias;
		};

/***********************************************************************
Rich Content Document (run)
***********************************************************************/

		/// <summary>Pepresents a logical run of a rich content document.</summary>
		class DocumentRun : public Object, public Description<DocumentRun>
		{
		public:
			/// <summary>A visitor interface for <see cref="DocumentRun"/>.</summary>
			class IVisitor : public Interface
			{
			public:
				/// <summary>Visit operation for <see cref="DocumentTextRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentTextRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentStylePropertiesRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentStylePropertiesRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentStyleApplicationRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentStyleApplicationRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentHyperlinkRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentHyperlinkRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentImageRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentImageRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentEmbeddedObjectRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentEmbeddedObjectRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentParagraphRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentParagraphRun* run)=0;
			};

			DocumentRun(){}

			/// <summary>Accept a <see cref="IVisitor"/> and trigger the selected visit operation.</summary>
			/// <param name="visitor">The visitor.</param>
			virtual void					Accept(IVisitor* visitor)=0;
		};
		
		/// <summary>Pepresents a container run.</summary>
		class DocumentContainerRun : public DocumentRun, public Description<DocumentContainerRun>
		{
			typedef collections::List<Ptr<DocumentRun>>			RunList;
		public:
			/// <summary>Sub runs.</summary>
			RunList							runs;
		};
		
		/// <summary>Pepresents a content run.</summary>
		class DocumentContentRun : public DocumentRun, public Description<DocumentContentRun>
		{
		public:
			/// <summary>Get representation text.</summary>
			/// <returns>The representation text.</returns>
			virtual WString					GetRepresentationText()=0;
		};

		//-------------------------------------------------------------------------

		/// <summary>Pepresents a text run.</summary>
		class DocumentTextRun : public DocumentContentRun, public Description<DocumentTextRun>
		{
		public:
			/// <summary>Run text.</summary>
			WString							text;

			DocumentTextRun(){}

			WString							GetRepresentationText()override{return text;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents a inline object run.</summary>
		class DocumentInlineObjectRun : public DocumentContentRun, public Description<DocumentInlineObjectRun>
		{
		public:
			/// <summary>Size of the inline object.</summary>
			Size							size;
			/// <summary>Baseline of the inline object.</summary>
			vint							baseline;

			DocumentInlineObjectRun():baseline(-1){}
		};
				
		/// <summary>Pepresents a image run.</summary>
		class DocumentImageRun : public DocumentInlineObjectRun, public Description<DocumentImageRun>
		{
		public:
			static const wchar_t*			RepresentationText;

			/// <summary>The image.</summary>
			Ptr<INativeImage>				image;
			/// <summary>The frame index.</summary>
			vint							frameIndex;
			/// <summary>The image source string.</summary>
			WString							source;

			DocumentImageRun():frameIndex(0){}
			
			WString							GetRepresentationText()override{return RepresentationText;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents an embedded object run.</summary>
		class DocumentEmbeddedObjectRun : public DocumentInlineObjectRun, public Description<DocumentImageRun>
		{
		public:
			static const wchar_t*			RepresentationText;

			/// <summary>The object name.</summary>
			WString							name;
			
			WString							GetRepresentationText()override{return RepresentationText;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};

		//-------------------------------------------------------------------------
				
		/// <summary>Pepresents a style properties run.</summary>
		class DocumentStylePropertiesRun : public DocumentContainerRun, public Description<DocumentStylePropertiesRun>
		{
		public:
			/// <summary>Style properties.</summary>
			Ptr<DocumentStyleProperties>	style;

			DocumentStylePropertiesRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents a style application run.</summary>
		class DocumentStyleApplicationRun : public DocumentContainerRun, public Description<DocumentStyleApplicationRun>
		{
		public:
			/// <summary>Style name.</summary>
			WString							styleName;

			DocumentStyleApplicationRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
		
		/// <summary>Pepresents a hyperlink text run.</summary>
		class DocumentHyperlinkRun : public DocumentStyleApplicationRun, public Description<DocumentHyperlinkRun>
		{
		public:
			class Package : public Object, public Description<Package>
			{
			public:
				collections::List<Ptr<DocumentHyperlinkRun>>		hyperlinks;
				vint												row = -1;
				vint												start = -1;
				vint												end = -1;
			};

			/// <summary>Style name for normal state.</summary>
			WString							normalStyleName;
			/// <summary>Style name for active state.</summary>
			WString							activeStyleName;
			/// <summary>The reference of the hyperlink.</summary>
			WString							reference;

			DocumentHyperlinkRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents a paragraph run.</summary>
		class DocumentParagraphRun : public DocumentContainerRun, public Description<DocumentParagraphRun>
		{
		public:
			/// <summary>Paragraph alignment.</summary>
			Nullable<Alignment>				alignment;

			DocumentParagraphRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}

			WString							GetText(bool skipNonTextContent);
			void							GetText(stream::TextWriter& writer, bool skipNonTextContent);
		};

/***********************************************************************
Rich Content Document (model)
***********************************************************************/

		/// <summary>Represents a text style.</summary>
		class DocumentStyle : public Object, public Description<DocumentStyle>
		{
		public:
			/// <summary>Parent style name, could be #Default, #Context, #NormalLink, #ActiveLink or style name of others</summary>
			WString							parentStyleName;

			/// <summary>Properties of this style.</summary>
			Ptr<DocumentStyleProperties>	styles;

			/// <summary>Resolved properties of this style using parent styles.</summary>
			Ptr<DocumentStyleProperties>	resolvedStyles;
		};

		/// <summary>Represents a rich content document model.</summary>
		class DocumentModel : public Object, public Description<DocumentModel>
		{
		public:
			static const wchar_t*			DefaultStyleName;
			static const wchar_t*			SelectionStyleName;
			static const wchar_t*			ContextStyleName;
			static const wchar_t*			NormalLinkStyleName;
			static const wchar_t*			ActiveLinkStyleName;
		public:
			/// <summary>Represents a resolved style.</summary>
			struct ResolvedStyle
			{
				/// <summary>The style of the text.</summary>
				FontProperties				style;
				/// <summary>The color of the text.</summary>
				Color						color;
				/// <summary>The background color of the text.</summary>
				Color						backgroundColor;

				ResolvedStyle()
				{
				}

				ResolvedStyle(const FontProperties& _style, Color _color, Color _backgroundColor)
					:style(_style)
					,color(_color)
					,backgroundColor(_backgroundColor)
				{
				}
			};

			struct RunRange
			{
				vint			start;
				vint			end;
			};

			typedef collections::Dictionary<DocumentRun*, RunRange>						RunRangeMap;
		private:
			typedef collections::List<Ptr<DocumentParagraphRun>>						ParagraphList;
			typedef collections::Dictionary<WString, Ptr<DocumentStyle>>				StyleMap;
		public:
			/// <summary>All paragraphs.</summary>
			ParagraphList							paragraphs;
			/// <summary>All available styles. These will not be persistant.</summary>
			StyleMap								styles;
			
			DocumentModel();

			static void								MergeStyle(Ptr<DocumentStyleProperties> style, Ptr<DocumentStyleProperties> parent);
			void									MergeBaselineStyle(Ptr<DocumentStyleProperties> style, const WString& styleName);
			void									MergeBaselineStyle(Ptr<DocumentModel> baselineDocument, const WString& styleName);
			void									MergeBaselineStyles(Ptr<DocumentModel> baselineDocument);
			void									MergeDefaultFont(const FontProperties& defaultFont);
			ResolvedStyle							GetStyle(Ptr<DocumentStyleProperties> sp, const ResolvedStyle& context);
			ResolvedStyle							GetStyle(const WString& styleName, const ResolvedStyle& context);

			WString									GetText(bool skipNonTextContent);
			void									GetText(stream::TextWriter& writer, bool skipNonTextContent);
			
			bool									CheckEditRange(TextPos begin, TextPos end, RunRangeMap& relatedRanges);
			Ptr<DocumentModel>						CopyDocument(TextPos begin, TextPos end, bool deepCopy);
			Ptr<DocumentModel>						CopyDocument();
			bool									CutParagraph(TextPos position);
			bool									CutEditRange(TextPos begin, TextPos end);
			bool									EditContainer(TextPos begin, TextPos end, const Func<void(DocumentParagraphRun*, RunRangeMap&, vint, vint)>& editor);
			
			vint									EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> replaceToModel, bool copy);
			vint									EditRunNoCopy(TextPos begin, TextPos end, const collections::Array<Ptr<DocumentParagraphRun>>& runs);
			vint									EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
			bool									EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
			Ptr<DocumentImageRun>					EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
			bool									EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=NormalLinkStyleName, const WString& activeStyleName=ActiveLinkStyleName);
			bool									RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
			Ptr<DocumentHyperlinkRun::Package>		GetHyperlink(vint paragraphIndex, vint begin, vint end);
			bool									EditStyleName(TextPos begin, TextPos end, const WString& styleName);
			bool									RemoveStyleName(TextPos begin, TextPos end);
			bool									RenameStyle(const WString& oldStyleName, const WString& newStyleName);
			bool									ClearStyle(TextPos begin, TextPos end);
			Ptr<DocumentStyleProperties>			SummarizeStyle(TextPos begin, TextPos end);
			Nullable<WString>						SummarizeStyleName(TextPos begin, TextPos end);
			Nullable<Alignment>						SummarizeParagraphAlignment(TextPos begin, TextPos end);

			/// <summary>Load a document model from an xml.</summary>
			/// <returns>The loaded document model.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="xml">The xml document.</param>
			/// <param name="resolver">A document resolver to resolve symbols in non-embedded objects like image.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<DocumentModel>		LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<parsing::xml::XmlDocument> xml, Ptr<GuiResourcePathResolver> resolver, GuiResourceError::List& errors);

			/// <summary>Save a document model to an xml.</summary>
			/// <returns>The saved xml document.</returns>
			Ptr<parsing::xml::XmlDocument>	SaveToXml();
		};
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSDOCUMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Layout Engine
***********************************************************************/

			class IGuiGraphicsParagraph;
			class IGuiGraphicsLayoutProvider;

			/// <summary>Represents a paragraph of a layouted rich text content.</summary>
			class IGuiGraphicsParagraph : public IDescriptable, public Description<IGuiGraphicsParagraph>
			{
			public:
				static const vint		NullInteractionId = -1;

				/// <summary>Text style. Items in this enumeration type can be combined.</summary>
				enum TextStyle
				{
					/// <summary>Bold.</summary>
					Bold=1,
					/// <summary>Italic.</summary>
					Italic=2,
					/// <summary>Underline.</summary>
					Underline=4,
					/// <summary>Strikeline.</summary>
					Strikeline=8,
				};

				/// <summary>Inline object break condition.</summary>
				enum BreakCondition
				{
					/// <summary>Stay together with the previous run if possible.</summary>
					StickToPreviousRun,
					/// <summary>Stay together with the next run if possible.</summary>
					StickToNextRun,
					/// <summary>Treat as a single run.</summary>
					Alone,
				};

				/// <summary>Caret relative position.</summary>
				enum CaretRelativePosition
				{
					/// <summary>The first caret position.</summary>
					CaretFirst,
					/// <summary>The last caret position.</summary>
					CaretLast,
					/// <summary>The first caret position of the current line.</summary>
					CaretLineFirst,
					/// <summary>The last caret position of the current line.</summary>
					CaretLineLast,
					/// <summary>The relative left caret position.</summary>
					CaretMoveLeft,
					/// <summary>The relative right caret position.</summary>
					CaretMoveRight,
					/// <summary>The relative up caret position.</summary>
					CaretMoveUp,
					/// <summary>The relative down caret position.</summary>
					CaretMoveDown,
				};

				/// <summary>Inline object properties.</summary>
				struct InlineObjectProperties
				{
					/// <summary>The size of the inline object.</summary>
					Size						size;
					/// <summary>The baseline of the inline object.If the baseline is at the bottom, then set the baseline to -1.</summary>
					vint						baseline = -1;
					/// <summary>The break condition of the inline object.</summary>
					BreakCondition				breakCondition;
					/// <summary>The background image, nullable.</summary>
					Ptr<IGuiGraphicsElement>	backgroundImage;
					/// <summary>The id for callback. If the value is -1, then no callback will be received .</summary>
					vint						callbackId = -1;

					InlineObjectProperties()
						:baseline(-1)
					{
					}
				};

				/// <summary>Get the <see cref="IGuiGraphicsLayoutProvider"/> object that created this paragraph.</summary>
				/// <returns>The layout provider object.</returns>
				virtual IGuiGraphicsLayoutProvider*			GetProvider()=0;
				/// <summary>Get the associated <see cref="IGuiGraphicsRenderTarget"/> to this paragraph.</summary>
				/// <returns>The associated render target.</returns>
				virtual IGuiGraphicsRenderTarget*			GetRenderTarget()=0;
				/// <summary>Get if line auto-wrapping is enabled for this paragraph.</summary>
				/// <returns>Return true if line auto-wrapping is enabled for this paragraph.</returns>
				virtual bool								GetWrapLine()=0;
				/// <summary>Set if line auto-wrapping is enabled for this paragraph.</summary>
				/// <param name="value">True if line auto-wrapping is enabled for this paragraph.</param>
				virtual void								SetWrapLine(bool value)=0;
				/// <summary>Get the max width for this paragraph. If there is no max width limitation, it returns -1.</summary>
				/// <returns>The max width for this paragraph.</returns>
				virtual vint								GetMaxWidth()=0;
				/// <summary>Set the max width for this paragraph. If the max width is set to -1, the max width limitation will be removed.</summary>
				/// <param name="value">The max width.</param>
				virtual void								SetMaxWidth(vint value)=0;
				/// <summary>Get the horizontal alignment for this paragraph.</summary>
				/// <returns>The alignment.</returns>
				virtual Alignment							GetParagraphAlignment()=0;
				/// <summary>Set the horizontal alignment for this paragraph.</summary>
				/// <param name="value">The alignment.</param>
				virtual void								SetParagraphAlignment(Alignment value)=0;

				/// <summary>Replace the font within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The font.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetFont(vint start, vint length, const WString& value)=0;
				/// <summary>Replace the size within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The size.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetSize(vint start, vint length, vint value)=0;
				/// <summary>Replace the text style within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The text style.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetStyle(vint start, vint length, TextStyle value)=0;
				/// <summary>Replace the color within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The color.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetColor(vint start, vint length, Color value)=0;
				/// <summary>Replace the background color within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The background color.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetBackgroundColor(vint start, vint length, Color value)=0;
				/// <summary>Bind an <see cref="IGuiGraphicsElement"/> to a range of text.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="properties">The properties for the inline object.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetInlineObject(vint start, vint length, const InlineObjectProperties& properties)=0;
				/// <summary>Unbind all inline objects to a range of text.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								ResetInlineObject(vint start, vint length)=0;

				/// <summary>Get the layouted height of the text. The result depends on rich styled text and the two important properties that can be set using <see cref="SetWrapLine"/> and <see cref="SetMaxWidth"/>.</summary>
				/// <returns>The layouted height.</returns>
				virtual vint								GetHeight()=0;
				/// <summary>Make the caret visible so that it will be rendered in the paragraph.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="color">The color of the caret.</param>
				/// <param name="frontSide">Set to true to display the caret for the character before it.</param>
				virtual bool								OpenCaret(vint caret, Color color, bool frontSide)=0;
				/// <summary>Make the caret invisible.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								CloseCaret()=0;
				/// <summary>Render the graphics element using a specified bounds.</summary>
				/// <param name="bounds">Bounds to decide the size and position of the binded graphics element.</param>
				virtual void								Render(Rect bounds)=0;

				/// <summary>Get a new caret from the old caret with a relative position.</summary>
				/// <returns>The new caret. Returns -1 if failed.</returns>
				/// <param name="comparingCaret">The caret to compare. If the position is CaretFirst or CaretLast, this argument is ignored.</param>
				/// <param name="position">The relative position.</param>
				/// <param name="preferFrontSide">Only for CaretMoveUp and CaretMoveDown. Set to true to make the caret prefer to get closer to the character before it. After this function is called, this argument stored the suggested side for displaying the new caret.</param>
				virtual vint								GetCaret(vint comparingCaret, CaretRelativePosition position, bool& preferFrontSide)=0;
				/// <summary>Get the bounds of the caret.</summary>
				/// <returns>The bounds whose width is 0. Returns an empty Rect value if failed.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="frontSide">Set to true to get the bounds of the front side, otherwise the back side. If only one side is valid, this argument is ignored.</param>
				virtual Rect								GetCaretBounds(vint caret, bool frontSide)=0;
				/// <summary>Get the caret from a specified position.</summary>
				/// <returns>The caret. Returns -1 if failed.</returns>
				/// <param name="point">The point.</param>
				virtual vint								GetCaretFromPoint(Point point)=0;
				/// <summary>Get the inline object from a specified position.</summary>
				/// <returns>The inline object. Returns null if failed.</returns>
				/// <param name="point">The point.</param>
				/// <param name="start">Get the start position of this element.</param>
				/// <param name="length">Get the length of this element.</param>
				virtual Nullable<InlineObjectProperties>	GetInlineObjectFromPoint(Point point, vint& start, vint& length)=0;
				/// <summary>Get the nearest caret from a text position.</summary>
				/// <returns>The caret. Returns -1 if failed. If the text position is a caret, then the result will be the text position itself without considering the frontSide argument.</returns>
				/// <param name="textPos">The caret to compare. If the position is CaretFirst or CaretLast, this argument is ignored.</param>
				/// <param name="frontSide">Set to true to search in front of the text position, otherwise the opposite position.</param>
				virtual vint								GetNearestCaretFromTextPos(vint textPos, bool frontSide)=0;
				/// <summary>Test is the caret valid.</summary>
				/// <returns>Returns true if the caret is valid.</returns>
				/// <param name="caret">The caret to test.</param>
				virtual bool								IsValidCaret(vint caret)=0;
				/// <summary>Test is the text position valid.</summary>
				/// <returns>Returns true if the text position is valid.</returns>
				/// <param name="textPos">The text position to test.</param>
				virtual bool								IsValidTextPos(vint textPos)=0;
			};

			/// <summary>Paragraph callback</summary>
			class IGuiGraphicsParagraphCallback : public IDescriptable, public Description<IGuiGraphicsParagraphCallback>
			{
			public:
				/// <summary>Called when an inline object with a valid callback id is being rendered.</summary>
				/// <returns>Returns the new size of the rendered inline object.</returns>
				/// <param name="callbackId">The callback id of the inline object</param>
				/// <param name="location">The location of the inline object, relative to the left-top corner of this paragraph.</param>
				virtual Size								OnRenderInlineObject(vint callbackId, Rect location) = 0;
			};

			/// <summary>Renderer awared rich text document layout engine provider interface.</summary>
			class IGuiGraphicsLayoutProvider : public IDescriptable, public Description<IGuiGraphicsLayoutProvider>
			{
			public:
				/// <summary>Create a paragraph with internal renderer device dependent objects initialized.</summary>
				/// <param name="text">The text used to fill the paragraph.</param>
				/// <param name="renderTarget">The render target that the created paragraph will render to.</param>
				/// <param name="callback">A callback to receive necessary information when the paragraph is being rendered.</param>
				/// <returns>The created paragraph object.</returns>
				virtual Ptr<IGuiGraphicsParagraph>			CreateParagraph(const WString& text, IGuiGraphicsRenderTarget* renderTarget, IGuiGraphicsParagraphCallback* callback)=0;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSRESOURCEMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Resource Manager
***********************************************************************/

			/// <summary>
			/// This is a class for managing grpahics element factories and graphics renderer factories
			/// </summary>
			class GuiGraphicsResourceManager : public Object
			{
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsElementFactory>>		elementFactoryMap;
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsRendererFactory>>		rendererFactoryMap;
			protected:
				elementFactoryMap						elementFactories;
				rendererFactoryMap						rendererFactories;
			public:
				/// <summary>
				/// Create a graphics resource manager without any predefined factories
				/// </summary>
				GuiGraphicsResourceManager();
				~GuiGraphicsResourceManager();

				/// <summary>
				/// Register a <see cref="IGuiGraphicsElementFactory"></see> using the element type from <see cref="IGuiGraphicsElementFactory::GetElementTypeName"></see>.
				/// </summary>
				/// <param name="factory">The instance of the graphics element factory to register.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool							RegisterElementFactory(IGuiGraphicsElementFactory* factory);
				/// <summary>
				/// Register a <see cref="IGuiGraphicsRendererFactory"></see> and bind it to a registered <see cref="IGuiGraphicsElementFactory"></see>.
				/// </summary>
				/// <param name="elementTypeName">The element type to represent a graphics element factory.</param>
				/// <param name="factory">The instance of the graphics renderer factory to register.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool							RegisterRendererFactory(const WString& elementTypeName, IGuiGraphicsRendererFactory* factory);
				/// <summary>
				/// Get the instance of a registered <see cref="IGuiGraphicsElementFactory"></see> that is binded to a specified element type.
				/// </summary>
				/// <returns>Returns the element factory.</returns>
				/// <param name="elementTypeName">The element type to get a corresponding graphics element factory.</param>
				virtual IGuiGraphicsElementFactory*		GetElementFactory(const WString& elementTypeName);
				/// <summary>
				/// Get the instance of a registered <see cref="IGuiGraphicsRendererFactory"></see> that is binded to a specified element type.
				/// </summary>
				/// <returns>Returns the renderer factory.</returns>
				/// <param name="elementTypeName">The element type to get a corresponding graphics renderer factory.</param>
				virtual IGuiGraphicsRendererFactory*	GetRendererFactory(const WString& elementTypeName);
				/// <summary>
				/// Get the instance of a <see cref="IGuiGraphicsRenderTarget"></see> that is binded to an <see cref="INativeWindow"></see>.
				/// </summary>
				/// <param name="window">The specified window.</param>
				/// <returns>Returns the render target.</returns>
				virtual IGuiGraphicsRenderTarget*		GetRenderTarget(INativeWindow* window)=0;
				/// <summary>
				/// Recreate the render target for the specified window.
				/// </summary>
				/// <param name="window">The specified window.</param>
				virtual void							RecreateRenderTarget(INativeWindow* window) = 0;
				/// <summary>
				/// Resize the render target to fit the current window size.
				/// </summary>
				/// <param name="window">The specified window.</param>
				virtual void							ResizeRenderTarget(INativeWindow* window) = 0;
				/// <summary>
				/// Get the renderer awared rich text document layout engine provider object.
				/// </summary>
				/// <returns>Returns the layout provider.</returns>
				virtual IGuiGraphicsLayoutProvider*		GetLayoutProvider()=0;
			};

			/// <summary>
			/// Get the current <see cref="GuiGraphicsResourceManager"></see>.
			/// </summary>
			/// <returns>Returns the current resource manager.</returns>
			extern GuiGraphicsResourceManager*			GetGuiGraphicsResourceManager();
			/// <summary>
			/// Set the current <see cref="GuiGraphicsResourceManager"></see>.
			/// </summary>
			/// <param name="resourceManager">The resource manager to set.</param>
			extern void									SetGuiGraphicsResourceManager(GuiGraphicsResourceManager* resourceManager);
			/// <summary>
			/// Helper function to register a <see cref="IGuiGraphicsElementFactory"></see> with a <see cref="IGuiGraphicsRendererFactory"></see> and bind them together.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="elementFactory">The element factory to register.</param>
			/// <param name="rendererFactory">The renderer factory to register.</param>
			extern bool									RegisterFactories(IGuiGraphicsElementFactory* elementFactory, IGuiGraphicsRendererFactory* rendererFactory);

/***********************************************************************
Helpers
***********************************************************************/

			template<typename TElement>
			class GuiElementBase : public Object, public IGuiGraphicsElement, public Description<TElement>
			{
			public:
				class Factory : public Object, public IGuiGraphicsElementFactory
				{
				public:
					WString GetElementTypeName()
					{
						return TElement::GetElementTypeName();
					}
					IGuiGraphicsElement* Create()
					{
						auto element = new TElement;
						element->factory = this;
						IGuiGraphicsRendererFactory* rendererFactory = GetGuiGraphicsResourceManager()->GetRendererFactory(GetElementTypeName());
						if (rendererFactory)
						{
							element->renderer = rendererFactory->Create();
							element->renderer->Initialize(element);
						}
						return element;
					}
				};
			protected:
				IGuiGraphicsElementFactory*				factory = nullptr;
				Ptr<IGuiGraphicsRenderer>				renderer;
				compositions::GuiGraphicsComposition*	ownerComposition = nullptr;

				void SetOwnerComposition(compositions::GuiGraphicsComposition* composition)override
				{
					ownerComposition = composition;
				}

				void InvokeOnCompositionStateChanged()
				{
					if (ownerComposition)
					{
						compositions::InvokeOnCompositionStateChanged(ownerComposition);
					}
				}

				void InvokeOnElementStateChanged()
				{
					if (renderer)
					{
						renderer->OnElementStateChanged();
					}
					InvokeOnCompositionStateChanged();
				}
			public:
				static TElement* Create()
				{
					auto factory = GetGuiGraphicsResourceManager()->GetElementFactory(TElement::GetElementTypeName());
					CHECK_ERROR(factory != nullptr, L"This element is not supported by the selected renderer.");
					return dynamic_cast<TElement*>(factory->Create());
				}

				~GuiElementBase()
				{
					if (renderer)
					{
						renderer->Finalize();
					}
				}

				IGuiGraphicsElementFactory* GetFactory()override
				{
					return factory;
				}

				IGuiGraphicsRenderer* GetRenderer()override
				{
					return renderer.Obj();
				}

				compositions::GuiGraphicsComposition* GetOwnerComposition()override
				{
					return ownerComposition;
				}
			};

#define DEFINE_GUI_GRAPHICS_ELEMENT(TELEMENT, ELEMENT_TYPE_NAME)\
				friend class GuiElementBase<TELEMENT>;\
			public:\
				static WString GetElementTypeName()\
				{\
					return ELEMENT_TYPE_NAME;\
				}\

#define DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, TTARGET)\
			public:\
				class Factory : public Object, public IGuiGraphicsRendererFactory\
				{\
				public:\
					IGuiGraphicsRenderer* Create()\
					{\
						TRENDERER* renderer=new TRENDERER;\
						renderer->factory=this;\
						renderer->element=0;\
						renderer->renderTarget=0;\
						return renderer;\
					}\
				};\
			protected:\
				IGuiGraphicsRendererFactory*	factory;\
				TELEMENT*						element;\
				TTARGET*						renderTarget;\
				Size							minSize;\
			public:\
				static void Register()\
				{\
					RegisterFactories(new TELEMENT::Factory, new TRENDERER::Factory);\
				}\
				IGuiGraphicsRendererFactory* GetFactory()override\
				{\
					return factory;\
				}\
				void Initialize(IGuiGraphicsElement* _element)override\
				{\
					element=dynamic_cast<TELEMENT*>(_element);\
					InitializeInternal();\
				}\
				void Finalize()override\
				{\
					FinalizeInternal();\
				}\
				void SetRenderTarget(IGuiGraphicsRenderTarget* _renderTarget)override\
				{\
					TTARGET* oldRenderTarget=renderTarget;\
					renderTarget=dynamic_cast<TTARGET*>(_renderTarget);\
					RenderTargetChangedInternal(oldRenderTarget, renderTarget);\
				}\
				Size GetMinSize()override\
				{\
					return minSize;\
				}\

#define DEFINE_CACHED_RESOURCE_ALLOCATOR(TKEY, TVALUE)\
			public:\
				static const vint DeadPackageMax=32;\
				struct Package\
				{\
					TVALUE							resource;\
					vint								counter;\
					bool operator==(const Package& package)const{return false;}\
					bool operator!=(const Package& package)const{return true;}\
				};\
				struct DeadPackage\
				{\
					TKEY							key;\
					TVALUE							value;\
					bool operator==(const DeadPackage& package)const{return false;}\
					bool operator!=(const DeadPackage& package)const{return true;}\
				};\
				Dictionary<TKEY, Package>			aliveResources;\
				List<DeadPackage>					deadResources;\
			public:\
				TVALUE Create(const TKEY& key)\
				{\
					vint index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values().Get(index);\
						package.counter++;\
						aliveResources.Set(key, package);\
						return package.resource;\
					}\
					TVALUE resource;\
					for(vint i=0;i<deadResources.Count();i++)\
					{\
						if(deadResources[i].key==key)\
						{\
							DeadPackage deadPackage=deadResources[i];\
							deadResources.RemoveAt(i);\
							resource=deadPackage.value;\
							break;\
						}\
					}\
					if(!resource)\
					{\
						resource=CreateInternal(key);\
					}\
					Package package;\
					package.resource=resource;\
					package.counter=1;\
					aliveResources.Add(key, package);\
					return package.resource;\
				}\
				void Destroy(const TKEY& key)\
				{\
					vint index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values().Get(index);\
						package.counter--;\
						if(package.counter==0)\
						{\
							aliveResources.Remove(key);\
							if(deadResources.Count()==DeadPackageMax)\
							{\
								deadResources.RemoveAt(DeadPackageMax-1);\
							}\
							DeadPackage deadPackage;\
							deadPackage.key=key;\
							deadPackage.value=package.resource;\
							deadResources.Insert(0, deadPackage);\
						}\
						else\
						{\
							aliveResources.Set(key, package);\
						}\
					}\
				}
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Elements
***********************************************************************/

			/// <summary>
			/// Defines a shape for some <see cref="IGuiGraphicsElement"></see>.
			/// </summary>
			enum class ElementShapeType
			{
				/// <summary>Rectangle shape.</summary>
				Rectangle,
				/// <summary>Ellipse shape.</summary>
				Ellipse,
				/// <summary>Round rectangle shape.</summary>
				RoundRect,
			};

			/// <summary>
			/// Defines a shape for some <see cref="IGuiGraphicsElement"></see>.
			/// </summary>
			struct ElementShape
			{
				ElementShapeType		shapeType = ElementShapeType::Rectangle;
				int						radiusX = 0;
				int						radiusY = 0;

				bool operator==(const ElementShape& value)const { return shapeType == value.shapeType && radiusX == value.radiusX && radiusY == value.radiusY; }
				bool operator!=(const ElementShape& value)const { return !(*this == value); }
			};

			/// <summary>
			/// Defines a focus rectangle with a thickness of one pixel.
			/// </summary>
			class GuiFocusRectangleElement : public GuiElementBase<GuiFocusRectangleElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiFocusRectangleElement, L"FocusRectangle")
			protected:

				GuiFocusRectangleElement();
			public:
			};

			/// <summary>
			/// Defines a border element with a thickness of one pixel.
			/// </summary>
			class GuiSolidBorderElement : public GuiElementBase<GuiSolidBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBorderElement, L"SolidBorder")
			protected:
				Color					color;
				ElementShape			shape;

				GuiSolidBorderElement();
			public:
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape			GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape value);
			};
			
			/// <summary>
			/// Defines a 3D-like rectangle element with a thickness of two pixels.
			/// </summary>
			class Gui3DBorderElement : public GuiElementBase<Gui3DBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DBorderElement, L"3DBorder")
			protected:
				Color					color1;
				Color					color2;

				Gui3DBorderElement();
			public:
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new left-top color.</param>
				void					SetColor1(Color value);
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new right-bottom color.</param>
				void					SetColor2(Color value);
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
			};
			
			/// <summary>
			/// Defines a 3D-like splitter element with a thickness of two pixels.
			/// </summary>
			class Gui3DSplitterElement : public GuiElementBase<Gui3DSplitterElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DSplitterElement, L"3DSplitter")
			public:
				/// <summary>
				/// Defines a direction of the <see cref="Gui3DSplitterElement"></see>.
				/// </summary>
				enum Direction
				{
					/// <summary>Horizontal direction.</summary>
					Horizontal,
					/// <summary>Vertical direction.</summary>
					Vertical,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;

				Gui3DSplitterElement();
			public:
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new left-top color.</param>
				void					SetColor1(Color value);
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new right-bottom color.</param>
				void					SetColor2(Color value);
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
			};

			/// <summary>
			/// Defines a color-filled element without border.
			/// </summary>
			class GuiSolidBackgroundElement : public GuiElementBase<GuiSolidBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBackgroundElement, L"SolidBackground")
			protected:
				Color					color;
				ElementShape			shape;

				GuiSolidBackgroundElement();
			public:
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape			GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape value);
			};
			
			/// <summary>
			/// Defines a color-filled gradient element without border.
			/// </summary>
			class GuiGradientBackgroundElement : public GuiElementBase<GuiGradientBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiGradientBackgroundElement, L"GradientBackground")
			public:
				/// <summary>
				/// Defines a direction of the <see cref="GuiGradientBackgroundElement"></see>.
				/// </summary>
				enum Direction
				{
					/// <summary>Horizontal direction.</summary>
					Horizontal,
					/// <summary>vertical direction.</summary>
					Vertical,
					/// <summary>Slash direction.</summary>
					Slash,
					/// <summary>Back slash direction.</summary>
					Backslash,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;
				ElementShape			shape;

				GuiGradientBackgroundElement();
			public:
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new left-top color.</param>
				void					SetColor1(Color value);
				/// <summary>
				/// Get the right bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new right-bottom color.</param>
				void					SetColor2(Color value);
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape			GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape value);
			};

			/// <summary>
			/// Defines a gradient border for shadow.
			/// </summary>
			class GuiInnerShadowElement : public GuiElementBase<GuiInnerShadowElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiInnerShadowElement, L"InnerShadow")
			protected:
				Color					color;
				vint					thickness = 0;

				GuiInnerShadowElement();
			public:
				/// <summary>
				/// Get the shadow color.
				/// </summary>
				/// <returns>The shadow color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the shadow color.
				/// </summary>
				/// <param name="value">The new shadow color.</param>
				void					SetColor(Color value);

				/// <summary>
				/// Get the thickness.
				/// </summary>
				/// <returns>The thickness.</returns>
				vint					GetThickness();
				/// <summary>
				/// Set the thickness.
				/// </summary>
				/// <param name="value">The new thickness.</param>
				void					SetThickness(vint value);
			};
			
			/// <summary>
			/// Defines an element of a plain text.
			/// </summary>
			class GuiSolidLabelElement : public GuiElementBase<GuiSolidLabelElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidLabelElement, L"SolidLabel");
			protected:
				Color					color;
				FontProperties			fontProperties;
				WString					text;
				Alignment				hAlignment;
				Alignment				vAlignment;
				bool					wrapLine;
				bool					ellipse;
				bool					multiline;
				bool					wrapLineHeightCalculation;

				GuiSolidLabelElement();
			public:
				/// <summary>
				/// Get the text color.
				/// </summary>
				/// <returns>The text color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the text color.
				/// </summary>
				/// <param name="value">The new text color.</param>
				void					SetColor(Color value);
				
				/// <summary>
				/// Get the text font.
				/// </summary>
				/// <returns>The text font.</returns>
				const FontProperties&	GetFont();
				/// <summary>
				/// Set the text font.
				/// </summary>
				/// <param name="value">The new text font.</param>
				void					SetFont(const FontProperties& value);
				
				/// <summary>
				/// Get the text.
				/// </summary>
				/// <returns>The text.</returns>
				const WString&			GetText();
				/// <summary>
				/// Set the text.
				/// </summary>
				/// <param name="value">The new text.</param>
				void					SetText(const WString& value);
				
				/// <summary>
				/// Get the horizontal alignment of the text.
				/// </summary>
				/// <returns>The horizontal alignment of the text.</returns>
				Alignment				GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the text.
				/// </summary>
				/// <returns>The vertical alignment of the text.</returns>
				Alignment				GetVerticalAlignment();
				/// <summary>
				/// Set the horizontal alignment of the text.
				/// </summary>
				/// <param name="value">The new horizontal alignment of the text.</param>
				void					SetHorizontalAlignment(Alignment value);
				/// <summary>
				/// Set the vertical alignment of the text.
				/// </summary>
				/// <param name="value">The vertical alignment of the text.</param>
				void					SetVerticalAlignment(Alignment value);
				/// <summary>
				/// Set alignments in both directions of the text.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the text.</param>
				/// <param name="vertical">The vertical alignment of the text.</param>
				void					SetAlignments(Alignment horizontal, Alignment vertical);
				
				/// <summary>
				/// Get if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <returns>Return true if line auto-wrapping is enabled for this text.</returns>
				bool					GetWrapLine();
				/// <summary>
				/// Set if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <param name="value">True if line auto-wrapping is enabled for this text.</param>
				void					SetWrapLine(bool value);
				
				/// <summary>
				/// Get if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <returns>Return true if ellipse is enabled for this text.</returns>
				bool					GetEllipse();
				/// <summary>
				/// Set if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <param name="value">True if ellipse is enabled for this text.</param>
				void					SetEllipse(bool value);
				
				/// <summary>
				/// Get if multiple lines is enabled for this text.
				/// </summary>
				/// <returns>Return true if multiple lines is enabled for this text.</returns>
				bool					GetMultiline();
				/// <summary>
				/// Set if multiple lines is enabled for this text.
				/// </summary>
				/// <param name="value">True if multiple lines is enabled for this text.</param>
				void					SetMultiline(bool value);

				/// <summary>
				/// Get if the element calculates the min height when wrap line is enabled.
				/// </summary>
				/// <returns>Return true if the element calculates the min height when wrap line is enabled.</returns>
				bool					GetWrapLineHeightCalculation();
				/// <summary>
				/// Set if the element calculates the min height when wrap line is enabled.
				/// </summary>
				/// <param name="value">True if the element calculates the min height when wrap line is enabled.</param>
				void					SetWrapLineHeightCalculation(bool value);
			};

			/// <summary>
			/// Defines an element containing an image.
			/// </summary>
			class GuiImageFrameElement : public GuiElementBase<GuiImageFrameElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiImageFrameElement, L"ImageFrame");
			protected:
				Ptr<INativeImage>		image;
				vint					frameIndex;
				Alignment				hAlignment;
				Alignment				vAlignment;
				bool					stretch;
				bool					enabled;

				GuiImageFrameElement();
			public:
				/// <summary>
				/// Get the containing image.
				/// </summary>
				/// <returns>The contining picture.</returns>
				Ptr<INativeImage>		GetImage();
				/// <summary>
				/// Get the index of the frame in the containing image.
				/// </summary>
				/// <returns>The index of the frame in the containing image</returns>
				vint					GetFrameIndex();
				/// <summary>
				/// Set the containing image.
				/// </summary>
				/// <param name="value">The new containing image.</param>
				void					SetImage(Ptr<INativeImage> value);
				/// <summary>
				/// Set  the frame index.
				/// </summary>
				/// <param name="value">The new frameIndex.</param>
				void					SetFrameIndex(vint value);
				/// <summary>
				/// Set the containing image and the frame index.
				/// </summary>
				/// <param name="_image">The new containing image.</param>
				/// <param name="_frameIndex">The new frameIndex.</param>
				void					SetImage(Ptr<INativeImage> _image, vint _frameIndex);
				
				/// <summary>
				/// Get the horizontal alignment of the image.
				/// </summary>
				/// <returns>The horizontal alignment of the image.</returns>
				Alignment				GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the image.
				/// </summary>
				/// <returns>The vertical alignment of the image.</returns>
				Alignment				GetVerticalAlignment();
				/// <summary>
				/// Set the horizontal alignment of the text.
				/// </summary>
				/// <param name="value">The new horizontal alignment of the text.</param>
				void					SetHorizontalAlignment(Alignment value);
				/// <summary>
				/// Set the vertical alignment of the text.
				/// </summary>
				/// <param name="value">The vertical alignment of the text.</param>
				void					SetVerticalAlignment(Alignment value);
				/// <summary>
				/// Set alignments in both directions of the image.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the image.</param>
				/// <param name="vertical">The vertical alignment of the image.</param>
				void					SetAlignments(Alignment horizontal, Alignment vertical);

				/// <summary>
				/// Get if stretching is enabled for this image.
				/// </summary>
				/// <returns>Return true if stretching is enabled for this image.</returns>
				bool					GetStretch();
				/// <summary>
				/// Set if stretching is enabled for this image.
				/// </summary>
				/// <param name="value">True if stretching is enabled for this image.</param>
				void					SetStretch(bool value);

				/// <summary>
				/// Get if the image is rendered as enabled.
				/// </summary>
				/// <returns>Return true if the image is rendered as enabled.</returns>
				bool					GetEnabled();
				/// <summary>
				/// Set if the image is rendered as enabled.
				/// </summary>
				/// <param name="value">True if the image is rendered as enabled.</param>
				void					SetEnabled(bool value);
			};

			/// <summary>
			/// Defines a polygon element with a thickness of one pixel.
			/// </summary>
			class GuiPolygonElement : public GuiElementBase<GuiPolygonElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiPolygonElement, L"Polygon");

				typedef collections::Array<Point>			PointArray;
			protected:
				Size							size;
				PointArray						points;
				Color							borderColor;
				Color							backgroundColor;

				GuiPolygonElement();
			public:
				/// <summary>
				/// Get a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <returns>The suggested size.</returns>
				Size					GetSize();
				/// <summary>
				/// Set a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <param name="value">The new size.</param>
				void					SetSize(Size value);

				/// <summary>
				/// Get a point of the polygon element using an index.
				/// </summary>
				/// <param name="index">The index to access a point.</param>
				/// <returns>The point of the polygon element associated with the index.</returns>
				const Point&			GetPoint(vint index);
				/// <summary>
				/// Get the number of points
				/// </summary>
				/// <returns>The number of points.</returns>
				vint					GetPointCount();
				/// <summary>
				/// Set all points to the polygon element.
				/// </summary>
				/// <param name="p">A pointer to a buffer that stores all points.</param>
				/// <param name="count">The number of points.</param>
				void					SetPoints(const Point* p, vint count);


				/// <summary>
				/// Get all points.
				/// </summary>
				/// <returns>All points</returns>
				const PointArray&		GetPointsArray();
				/// <summary>
				/// Set all points.
				/// </summary>
				/// <param name="value">All points</param>
				void					SetPointsArray(const PointArray& value);
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetBorderColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetBorderColor(Color value);
				/// <summary>
				/// Get the background color.
				/// </summary>
				/// <returns>The background color.</returns>
				Color					GetBackgroundColor();
				/// <summary>
				/// Set the background color.
				/// </summary>
				/// <param name="value">The new background color.</param>
				void					SetBackgroundColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSDOCUMENTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

			namespace visitors
			{
				class SetPropertiesVisitor;
			}

/***********************************************************************
Rich Content Document (element)
***********************************************************************/

			/// <summary>Defines a rich text document element for rendering complex styled document.</summary>
			class GuiDocumentElement : public GuiElementBase<GuiDocumentElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiDocumentElement, L"RichDocument");
			public:
				/// <summary>Callback interface for this element.</summary>
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					/// <summary>Called when the rendering is started.</summary>
					virtual void							OnStartRender() = 0;

					/// <summary>Called when the rendering is finished.</summary>
					virtual void							OnFinishRender() = 0;

					/// <summary>Called when an embedded object is being rendered.</summary>
					/// <returns>Returns the new size of the rendered embedded object.</returns>
					/// <param name="name">The name of the embedded object</param>
					/// <param name="location">The location of the embedded object, relative to the left-top corner of this element.</param>
					virtual Size							OnRenderEmbeddedObject(const WString& name, const Rect& location) = 0;
				};

				class GuiDocumentElementRenderer : public Object, public IGuiGraphicsRenderer, private IGuiGraphicsParagraphCallback
				{
					friend class visitors::SetPropertiesVisitor;

					DEFINE_GUI_GRAPHICS_RENDERER(GuiDocumentElement, GuiDocumentElementRenderer, IGuiGraphicsRenderTarget)
				protected:
					struct EmbeddedObject
					{
						WString								name;
						Size								size;
						vint								start;
						bool								resized = false;
					};

					typedef collections::Dictionary<vint, Ptr<EmbeddedObject>>		IdEmbeddedObjectMap;
					typedef collections::Dictionary<WString, vint>					NameIdMap;
					typedef collections::List<vint>									FreeIdList;

					struct ParagraphCache
					{
						WString								fullText;
						Ptr<IGuiGraphicsParagraph>			graphicsParagraph;
						IdEmbeddedObjectMap					embeddedObjects;
						vint								selectionBegin;
						vint								selectionEnd;

						ParagraphCache()
							:selectionBegin(-1)
							,selectionEnd(-1)
						{
						}
					};

					typedef collections::Array<Ptr<ParagraphCache>>		ParagraphCacheArray;
					typedef collections::Array<vint>					ParagraphHeightArray;

				private:

					Size									OnRenderInlineObject(vint callbackId, Rect location)override;
				protected:
					vint									paragraphDistance;
					vint									lastMaxWidth;
					vint									cachedTotalHeight;
					IGuiGraphicsLayoutProvider*				layoutProvider;
					ParagraphCacheArray						paragraphCaches;
					ParagraphHeightArray					paragraphHeights;

					TextPos									lastCaret;
					Color									lastCaretColor;
					bool									lastCaretFrontSide;

					NameIdMap								nameCallbackIdMap;
					FreeIdList								freeCallbackIds;
					vint									usedCallbackIds = 0;

					vint									renderingParagraph = -1;
					Point									renderingParagraphOffset;

					void									InitializeInternal();
					void									FinalizeInternal();
					void									RenderTargetChangedInternal(IGuiGraphicsRenderTarget* oldRenderTarget, IGuiGraphicsRenderTarget* newRenderTarget);
					Ptr<ParagraphCache>						EnsureAndGetCache(vint paragraphIndex, bool createParagraph);
					bool									GetParagraphIndexFromPoint(Point point, vint& top, vint& index);
				public:
					GuiDocumentElementRenderer();

					void									Render(Rect bounds)override;
					void									OnElementStateChanged()override;
					void									NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
					Ptr<DocumentHyperlinkRun::Package>		GetHyperlinkFromPoint(Point point);

					void									OpenCaret(TextPos caret, Color color, bool frontSide);
					void									CloseCaret(TextPos caret);
					void									SetSelection(TextPos begin, TextPos end);
					TextPos									CalculateCaret(TextPos comparingCaret, IGuiGraphicsParagraph::CaretRelativePosition position, bool& preferFrontSide);
					TextPos									CalculateCaretFromPoint(Point point);
					Rect									GetCaretBounds(TextPos caret, bool frontSide);
				};

			protected:
				Ptr<DocumentModel>							document;
				ICallback*									callback = nullptr;
				TextPos										caretBegin;
				TextPos										caretEnd;
				bool										caretVisible;
				bool										caretFrontSide;
				Color										caretColor;

				void										UpdateCaret();

				GuiDocumentElement();
			public:
				/// <summary>Get the callback.</summary>
				/// <returns>The callback.</returns>
				ICallback*									GetCallback();
				/// <summary>Set the callback.</summary>
				/// <param name="value">The callback.</param>
				void										SetCallback(ICallback* value);
				
				/// <summary>Get the document.</summary>
				/// <returns>The document.</returns>
				Ptr<DocumentModel>							GetDocument();
				/// <summary>Set the document. When a document is set to this element, modifying the document without invoking <see cref="NotifyParagraphUpdated"/> will lead to undefined behavior.</summary>
				/// <param name="value">The document.</param>
				void										SetDocument(Ptr<DocumentModel> value);
				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos										GetCaretBegin();
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos										GetCaretEnd();
				/// <summary>
				/// Get the prefer side for the caret.
				/// </summary>
				/// <returns>Returns true if the caret is rendered for the front side.</returns>
				bool										IsCaretEndPreferFrontSide();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="begin">The begin position of the selection area.</param>
				/// <param name="end">The end position of the selection area.</param>
				/// <param name="frontSide">Set to true to show the caret for the character before it. This argument is ignored if begin and end are the same.</param>
				void										SetCaret(TextPos begin, TextPos end, bool frontSide);
				/// <summary>
				/// Get the caret visibility.
				/// </summary>
				/// <returns>Returns true if the caret will be rendered.</returns>
				bool										GetCaretVisible();
				/// <summary>
				/// Set the caret visibility.
				/// </summary>
				/// <param name="value">True if the caret will be rendered.</param>
				void										SetCaretVisible(bool value);
				/// <summary>
				/// Get the color of the caret.
				/// </summary>
				/// <returns>The color of the caret.</returns>
				Color										GetCaretColor();
				/// <summary>
				/// Set the color of the caret.
				/// </summary>
				/// <param name="value">The color of the caret.</param>
				void										SetCaretColor(Color value);

				/// <summary>Calculate a caret using a specified comparing caret and a relative position.</summary>
				/// <returns>The calculated caret.</returns>
				/// <param name="comparingCaret">The comparing caret.</param>
				/// <param name="position">The relative position.</param>
				/// <param name="preferFrontSide">Specify the side for the comparingCaret. Retrive the suggested side for the new caret. If the return caret equals compareCaret, this output is ignored.</param>
				TextPos										CalculateCaret(TextPos comparingCaret, IGuiGraphicsParagraph::CaretRelativePosition position, bool& preferFrontSide);
				/// <summary>Calculate a caret using a specified point.</summary>
				/// <returns>The calculated caret.</returns>
				/// <param name="point">The specified point.</param>
				TextPos										CalculateCaretFromPoint(Point point);
				/// <summary>Get the bounds of a caret.</summary>
				/// <returns>The bounds.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="frontSide">Set to true to get the bounds for the character before it.</param>
				Rect										GetCaretBounds(TextPos caret, bool frontSide);

				/// <summary>Notify that some paragraphs are updated.</summary>
				/// <param name="index">The start paragraph index.</param>
				/// <param name="oldCount">The number of paragraphs to be updated.</param>
				/// <param name="newCount">The number of updated paragraphs.</param>
				/// <param name="updatedText">Set to true to notify that the text is updated.</param>
				void										NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
				/// <summary>Edit run in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="model">The new run.</param>
				/// <param name="copy">Set to true to copy the model before editing. Otherwise, objects inside the model will be used directly</param>
				void										EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> model, bool copy);
				/// <summary>Edit text in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="frontSide">Set to true to use the text style in front of the specified range.</param>
				/// <param name="text">The new text.</param>
				void										EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
				/// <summary>Edit style in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="style">The new style.</param>
				void										EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
				/// <summary>Edit image in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="image">The new image.</param>
				void										EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
				/// <summary>Set hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="reference">The reference of the hyperlink.</param>
				/// <param name="normalStyleName">The normal style name of the hyperlink.</param>
				/// <param name="activeStyleName">The active style name of the hyperlink.</param>
				void										EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=DocumentModel::NormalLinkStyleName, const WString& activeStyleName=DocumentModel::ActiveLinkStyleName);
				/// <summary>Remove hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
				/// <summary>Edit style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="styleName">The new style name.</param>
				void										EditStyleName(TextPos begin, TextPos end, const WString& styleName);
				/// <summary>Remove style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveStyleName(TextPos begin, TextPos end);
				/// <summary>Rename a style.</summary>
				/// <param name="oldStyleName">The name of the style.</param>
				/// <param name="newStyleName">The new name.</param>
				void										RenameStyle(const WString& oldStyleName, const WString& newStyleName);
				/// <summary>Clear all styles in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										ClearStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the text style in a specified range.</summary>
				/// <returns>The text style summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Ptr<DocumentStyleProperties>				SummarizeStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the style name in a specified range.</summary>
				/// <returns>The style name summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<WString>							SummarizeStyleName(TextPos begin, TextPos end);
				/// <summary>Set the alignment of paragraphs in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="alignments">The alignment for each paragraph.</param>
				void										SetParagraphAlignment(TextPos begin, TextPos end, const collections::Array<Nullable<Alignment>>& alignments);
				/// <summary>Summarize the text alignment in a specified range.</summary>
				/// <returns>The text alignment summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<Alignment>							SummarizeParagraphAlignment(TextPos begin, TextPos end);

				/// <summary>Get hyperlink from point.</summary>
				/// <returns>Corressponding hyperlink id. Returns -1 indicates that the point is not in a hyperlink.</returns>
				/// <param name="point">The point to get the hyperlink id.</param>
				Ptr<DocumentHyperlinkRun::Package>			GetHyperlinkFromPoint(Point point);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSTEXTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			class GuiColorizedTextElement;

/***********************************************************************
Colorized Plain Text (model)
***********************************************************************/

			namespace text
			{
				/// <summary>
				/// Represents the extra information of a character to display.
				/// </summary>
				struct CharAtt
				{
					/// <summary>
					/// The distance from the head of the line to the right side of this character in pixel.
					/// </summary>
					vuint32_t						rightOffset;
					/// <summary>
					/// The color index of the character. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
					/// </summary>
					vuint32_t						colorIndex;
				};
				
				/// <summary>
				/// Represents a line of characters.
				/// </summary>
				struct TextLine
				{
					static const vint				BlockSize=32;
					static const vint				MaxWidth=0xFFFF;
					
					/// <summary>
					/// A character buffer starts from the first character of this line.
					/// </summary>
					wchar_t*						text;
					/// <summary>
					/// A extra information buffer starts from the first character of this line.
					/// </summary>
					CharAtt*						att;
					/// <summary>
					/// The number of available <see cref="CharAtt::rightOffset"/> in the buffer.
					/// </summary>
					vint								availableOffsetCount;
					/// <summary>
					/// The number of elements in the allocated buffer memory.
					/// </summary>
					vint								bufferLength;
					/// <summary>
					/// The number of available characters in the buffer.
					/// </summary>
					vint								dataLength;
					/// <summary>
					/// The internal lexical analyzer state of a colorizer when it parses to the end of this line. -1 means that this state is not available.
					/// </summary>
					vint								lexerFinalState;
					/// <summary>
					/// The internal context sensitive state of a colorizer when it parses to the end of this line. -1 means that this state is not available.
					/// </summary>
					vint								contextFinalState;

					TextLine();
					~TextLine();

					static vint						CalculateBufferLength(vint dataLength);
					bool							operator==(const TextLine& value)const{return false;}
					bool							operator!=(const TextLine& value)const{return true;}

					/// <summary>
					/// Initialize the <see cref="TextLine"/> instance to be an empty line.
					/// </summary>
					void							Initialize();
					/// <summary>
					/// Release all resources used in this line.
					/// </summary>
					void							Finalize();
					/// <summary>
					/// Test is the line initialized.
					/// </summary>
					/// <returns>Returns true if the line is initialized.</returns>
					bool							IsReady();
					/// <summary>
					/// Modify the characters in the line by replacing characters.
					/// </summary>
					/// <returns>Returns true if the modification succeeded.</returns>
					/// <param name="start">The position of the first character to be replaced.</param>
					/// <param name="count">The number of characters to be replaced.</param>
					/// <param name="input">The buffer to the characters to write into this line.</param>
					/// <param name="inputCount">The numbers of the characters to write into this line.</param>
					bool							Modify(vint start, vint count, const wchar_t* input, vint inputCount);
					/// <summary>
					/// Split a text line into two by the position. The current line contains characters before this position. This function returns a new text line contains characters after this position.
					/// </summary>
					/// <returns>The new text line.</returns>
					/// <param name="index">.</param>
					TextLine						Split(vint index);
					/// <summary>
					/// Append a text line after the this text line, and finalize the input text line.
					/// </summary>
					/// <param name="line">The text line that contains all characters and color indices to append and be finalized.</param>
					void							AppendAndFinalize(TextLine& line);
				};

#if defined VCZH_MSVC
				/// <summary>Test if a wchar_t is the first character of a surrogate pair.</summary>
				/// <param name="c">The character to test.</param>
				/// <returns>Returns true if it is the first character of a surrogate pair.</returns>
				inline bool UTF16SPFirst(wchar_t c)
				{
					return 0xD800 <= c && c < 0xDC00;
				}

				/// <summary>Test if a wchar_t is the second character of a surrogate pair.</summary>
				/// <param name="c">The character to test.</param>
				/// <returns>Returns true if it is the second character of a surrogate pair.</returns>
				inline bool UTF16SPSecond(wchar_t c)
				{
					return 0xDC00 <= c && c < 0xDFFF;
				}
#endif

				/// <summary>
				/// A unicode code point.
				/// In Windows, when the first character is not the leading character of a surrogate pair, the second character is ignored.
				/// In other platforms which treat wchar_t as a UTF-32 character, the second character is ignored.
				/// </summary>
				struct UnicodeCodePoint
				{
#if defined VCZH_MSVC
					wchar_t							characters[2];

					UnicodeCodePoint(wchar_t c) :characters{ c,0 } {}
					UnicodeCodePoint(wchar_t c1, wchar_t c2) :characters{ c1,c2 } {}
#elif defined VCZH_GCC
					wchar_t							character;

					UnicodeCodePoint(wchar_t c) :character(c) {}
#endif

					vuint32_t GetCodePoint()const
					{
#if defined VCZH_MSVC
						if (UTF16SPFirst(characters[0]) && UTF16SPSecond(characters[1]))
						{
							return (wchar_t)(characters[0] - 0xD800) * 0x400 + (wchar_t)(characters[1] - 0xDC00) + 0x10000;
						}
						else
						{
							return (vuint32_t)characters[0];
						}
#elif defined VCZH_GCC
						return (vuint32_t)character;
#endif
					}
				};

				/// <summary>
				/// An abstract class for character size measuring in differect rendering technology.
				/// </summary>
				class CharMeasurer : public virtual IDescriptable
				{
				protected:
					IGuiGraphicsRenderTarget*		oldRenderTarget = nullptr;
					vint							rowHeight;
					vint							widths[65536];
					
					/// <summary>
					/// Measure the width of a character.
					/// </summary>
					/// <returns>The width in pixel.</returns>
					/// <param name="codePoint">The unicode code point to measure.</param>
					/// <param name="renderTarget">The render target which the character is going to be rendered. This is a pure virtual member function to be overrided.</param>
					virtual vint					MeasureWidthInternal(UnicodeCodePoint codePoint, IGuiGraphicsRenderTarget* renderTarget)=0;
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height in pixel.</returns>
					/// <param name="renderTarget">The render target which the character is going to be rendered.</param>
					virtual vint					GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)=0;
				public:

					/// <summary>
					/// Initialize a character measurer.
					/// </summary>
					/// <param name="_rowHeight">The default character height in pixel before the character measurer is binded to a render target.</param>
					CharMeasurer(vint _rowHeight);
					~CharMeasurer();

					/// <summary>
					/// Bind a render target to this character measurer.
					/// </summary>
					/// <param name="value">The render target to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Measure the width of a character using the binded render target.
					/// </summary>
					/// <returns>The width of a character, in pixel.</returns>
					/// <param name="codePoint">The unicode code point to measure.</param>
					vint							MeasureWidth(UnicodeCodePoint codePoint);
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height of a character, in pixel.</returns>
					vint							GetRowHeight();
				};

				/// <summary>
				/// A class to maintain multiple lines of text buffer.
				/// </summary>
				class TextLines : public Object, public Description<TextLines>
				{
					typedef collections::List<TextLine>		TextLineList;
				protected:
					GuiColorizedTextElement*		ownerElement;
					TextLineList					lines;
					CharMeasurer*					charMeasurer;
					IGuiGraphicsRenderTarget*		renderTarget;
					vint							tabWidth;
					vint							tabSpaceCount;
					wchar_t							passwordChar;
				public:
					TextLines(GuiColorizedTextElement* _ownerElement);
					~TextLines();

					/// <summary>
					/// Returns the number of text lines.
					/// </summary>
					/// <returns>The number of text lines.</returns>
					vint							GetCount();
					/// <summary>
					/// Returns the text line of a specified row number.
					/// </summary>
					/// <returns>The related text line object.</returns>
					/// <param name="row">The specified row number.</param>
					TextLine&						GetLine(vint row);
					/// <summary>
					/// Returns the binded <see cref="CharMeasurer"/>.
					/// </summary>
					/// <returns>The binded <see cref="CharMeasurer"/>.</returns>
					CharMeasurer*					GetCharMeasurer();
					/// <summary>
					/// Binded a <see cref="CharMeasurer"/>.
					/// </summary>
					/// <param name="value">The <see cref="CharMeasurer"/> to bind.</param>
					void							SetCharMeasurer(CharMeasurer* value);
					/// <summary>
					/// Returns the binded <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <returns>The binded <see cref="IGuiGraphicsRenderTarget"/>.</returns>
					IGuiGraphicsRenderTarget*		GetRenderTarget();
					/// <summary>
					/// Binded a <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <param name="value">The <see cref="IGuiGraphicsRenderTarget"/> to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Returns a string from a specified range of the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					/// <param name="start">The start position.</param>
					/// <param name="end">The end position.</param>
					WString							GetText(TextPos start, TextPos end);
					/// <summary>
					/// Returns the whole string in the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					WString							GetText();
					/// <summary>
					/// Set the string to the text lines. This operation will modified every <see cref="TextLine"/> objects.
					/// </summary>
					/// <param name="value">The string to set into the text lines.</param>
					void							SetText(const WString& value);
					
					/// <summary>
					/// Remove text lines in a specified range.
					/// </summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="start">The first row number.</param>
					/// <param name="count">The number of text lines to be removed.</param>
					bool							RemoveLines(vint start, vint count);
					/// <summary>
					/// Test is a text position available in the text lines.
					/// </summary>
					/// <returns>Returns true if this position is available.</returns>
					/// <param name="pos">The text position to test.</param>
					bool							IsAvailable(TextPos pos);
					/// <summary>
					/// Normalize a text position to be available.
					/// </summary>
					/// <returns>The normalized text position.</returns>
					/// <param name="pos">The text position to normalize.</param>
					TextPos							Normalize(TextPos pos);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="inputs">The buffer to the string buffers to replace into the text lines.</param>
					/// <param name="inputCounts">The numbers of characters for each string buffer.</param>
					/// <param name="rows">The number of string buffers.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t** inputs, vint* inputCounts, vint rows);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The buffer to the string to replace into the text lines.</param>
					/// <param name="inputCount">The number of characters to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input, vint inputCount);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const WString& input);
					/// <summary>
					/// Remove every text lines.
					/// </summary>
					void							Clear();
					
					/// <summary>
					/// Clear all cached <see cref="CharAtt::rightOffset"/>.
					/// </summary>
					void							ClearMeasurement();
					/// <summary>
					/// Returns the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <returns>The number of spaces to replace a tab character for rendering.</returns>
					vint							GetTabSpaceCount();
					/// <summary>
					/// Set the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <param name="value">The number of spaces to replace a tab character for rendering.</param>
					void							SetTabSpaceCount(vint value);
					/// <summary>
					/// Measure all characters in a specified row.
					/// </summary>
					/// <param name="row">The specified row number.</param>
					void							MeasureRow(vint row);
					/// <summary>
					/// Returns the width of a specified row.
					/// </summary>
					/// <returns>The width of a specified row, in pixel.</returns>
					/// <param name="row">The specified row number.</param>
					vint							GetRowWidth(vint row);
					/// <summary>
					/// Returns the height of a row.
					/// </summary>
					/// <returns>The height of a row, in pixel.</returns>
					vint							GetRowHeight();
					/// <summary>
					/// Returns the total width of the text lines.
					/// </summary>
					/// <returns>The width of the text lines, in pixel.</returns>
					vint							GetMaxWidth();
					/// <summary>
					/// Returns the total height of the text lines.
					/// </summary>
					/// <returns>The height of the text lines, in pixel.</returns>
					vint							GetMaxHeight();
					/// <summary>
					/// Get the text position near to specified point.
					/// </summary>
					/// <returns>The text position.</returns>
					/// <param name="point">The specified point, in pixel.</param>
					TextPos							GetTextPosFromPoint(Point point);
					/// <summary>
					/// Get the point of a specified text position.
					/// </summary>
					/// <returns>The point, in pixel. Returns (-1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Point							GetPointFromTextPos(TextPos pos);
					/// <summary>
					/// Get the bounds of a specified text position.
					/// </summary>
					/// <returns>The bounds, in pixel. Returns (-1, -1, -1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Rect							GetRectFromTextPos(TextPos pos);
					/// <summary>
					/// Get the password mode displaying character.
					/// </summary>
					/// <returns>The password mode displaying character. Returns L'\0' means the password mode is not activated.</returns>
					wchar_t							GetPasswordChar();
					/// <summary>
					/// Set the password mode displaying character.
					/// </summary>
					/// <param name="value">The password mode displaying character. Set to L'\0' to deactivate the password mode.</param>
					void							SetPasswordChar(wchar_t value);
				};
				
				/// <summary>
				/// Represents colors of a character.
				/// </summary>
				struct ColorItem
				{
					/// <summary>
					/// Text color.
					/// </summary>
					Color							text;
					/// <summary>
					/// Background color.
					/// </summary>
					Color							background;

					bool							operator==(const ColorItem& value)const { return text == value.text && background == value.background; }
					bool							operator!=(const ColorItem& value)const { return !(*this == value); }
				};
				
				/// <summary>
				/// Represents color entry in a color table. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
				/// </summary>
				struct ColorEntry
				{
					/// <summary>
					/// Colors in normal state.
					/// </summary>
					ColorItem						normal;
					/// <summary>
					/// Colors in focused and selected state.
					/// </summary>
					ColorItem						selectedFocused;
					/// <summary>
					/// Colors in not focused and selected state.
					/// </summary>
					ColorItem						selectedUnfocused;

					bool							operator==(const ColorEntry& value)const {return normal == value.normal && selectedFocused == value.selectedFocused && selectedUnfocused == value.selectedUnfocused;}
					bool							operator!=(const ColorEntry& value)const {return !(*this == value);}
				};
			}

/***********************************************************************
Colorized Plain Text (element)
***********************************************************************/
			
			/// <summary>
			/// Defines a text element with separate color configuration for each character.
			/// </summary>
			class GuiColorizedTextElement : public GuiElementBase<GuiColorizedTextElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiColorizedTextElement, L"ColorizedText");

				friend class text::TextLines;
				typedef collections::Array<text::ColorEntry>			ColorArray;
			public:
				/// <summary>
				/// An callback interface. Member functions will be called when colors or fonts of a <see cref="GuiColorizedTextElement"/> changed.
				/// </summary>
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					/// <summary>
					/// Called when the color table of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					ColorChanged()=0;
					/// <summary>
					/// Called when the font configuration of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					FontChanged()=0;
				};
			protected:
				ICallback*							callback;
				ColorArray							colors;
				FontProperties						font;
				Point								viewPosition;
				bool								isVisuallyEnabled;
				bool								isFocused;

				TextPos								caretBegin;
				TextPos								caretEnd;
				bool								caretVisible;
				Color								caretColor;

				text::TextLines						lines;

				GuiColorizedTextElement();
			public:
				/// <summary>
				/// Get the internal <see cref="text::TextLines"/> object that stores all characters and colors.
				/// </summary>
				/// <returns>The internal <see cref="text::TextLines"/> object.</returns>
				text::TextLines&					GetLines();
				/// <summary>
				/// Get the binded callback object.
				/// </summary>
				/// <returns>The binded callback object.</returns>
				ICallback*							GetCallback();
				/// <summary>
				/// Bind a callback object.
				/// </summary>
				/// <param name="value">The callback object to bind.</param>
				void								SetCallback(ICallback* value);
				
				/// <summary>
				/// Get the binded color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table.
				/// </summary>
				/// <returns>The binded color table.</returns>
				const ColorArray&					GetColors();
				/// <summary>
				/// Bind a color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table. <see cref="ICallback::ColorChanged"/> will be called.
				/// </summary>
				/// <param name="value">The color table to bind.</param>
				void								SetColors(const ColorArray& value);
				/// <summary>
				/// Reset color of all characters
				/// </summary>
				/// <param name="index">Color index of all characters.</param>
				void								ResetTextColorIndex(vint index);
				/// <summary>
				/// Get the font configuration for all characters.
				/// </summary>
				/// <returns>The font configuration.</returns>
				const FontProperties&				GetFont();
				/// <summary>
				/// Set the font configuration for all characters. <see cref="ICallback::FontChanged"/> will be called.
				/// </summary>
				/// <param name="value">The font configuration.</param>
				void								SetFont(const FontProperties& value);
				/// <summary>
				/// Get the password mode displaying character.
				/// </summary>
				/// <returns>The password mode displaying character. Returns L'\0' means the password mode is not activated.</returns>
				wchar_t								GetPasswordChar();
				/// <summary>
				/// Set the password mode displaying character.
				/// </summary>
				/// <param name="value">The password mode displaying character. Set to L'\0' to deactivate the password mode.</param>
				void								SetPasswordChar(wchar_t value);
				/// <summary>
				/// Get the left-top position of the visible bounds of characters.
				/// </summary>
				/// <returns>The left-top position of the visible bounds of characters.</returns>
				Point								GetViewPosition();
				/// <summary>
				/// Set the left-top position of the visible bounds of characters.
				/// </summary>
				/// <param name="value">The left-top position of the visible bounds of characters.</param>
				void								SetViewPosition(Point value);
				/// <summary>
				/// Get the enabling state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as an enabled element.</returns>
				bool								GetVisuallyEnabled();
				/// <summary>
				/// Set the enabling state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as an enabled element.</param>
				void								SetVisuallyEnabled(bool value);
				/// <summary>
				/// Get the focused state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as a focused element.</returns>
				bool								GetFocused();
				/// <summary>
				/// Set the focused state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as a focused element.</param>
				void								SetFocused(bool value);
				
				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos								GetCaretBegin();
				/// <summary>
				/// Set the begin position of the selection area.
				/// </summary>
				/// <param name="value">The begin position of the selection area.</param>
				void								SetCaretBegin(TextPos value);
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos								GetCaretEnd();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="value">The end position of the selection area.</param>
				void								SetCaretEnd(TextPos value);
				/// <summary>
				/// Get the caret visibility.
				/// </summary>
				/// <returns>Returns true if the caret will be rendered.</returns>
				bool								GetCaretVisible();
				/// <summary>
				/// Set the caret visibility.
				/// </summary>
				/// <param name="value">True if the caret will be rendered.</param>
				void								SetCaretVisible(bool value);
				/// <summary>
				/// Get the color of the caret.
				/// </summary>
				/// <returns>The color of the caret.</returns>
				Color								GetCaretColor();
				/// <summary>
				/// Set the color of the caret.
				/// </summary>
				/// <param name="value">The color of the caret.</param>
				void								SetCaretColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUICONTROLTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATES
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATES


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiButton;
			class GuiSelectableButton;
			class GuiListControl;
			class GuiComboBoxListControl;
			class GuiTextList;
			class GuiTabPage;
			class GuiScroll;
		}

		namespace templates
		{

#define GUI_TEMPLATE_PROPERTY_DECL(CLASS, TYPE, NAME, VALUE)\
			private:\
				TYPE NAME##_ = VALUE;\
			public:\
				TYPE Get##NAME();\
				void Set##NAME(TYPE const& value);\
				compositions::GuiNotifyEvent NAME##Changed;\

#define GUI_TEMPLATE_PROPERTY_IMPL(CLASS, TYPE, NAME, VALUE)\
			TYPE CLASS::Get##NAME()\
			{\
				return NAME##_;\
			}\
			void CLASS::Set##NAME(TYPE const& value)\
			{\
				if (NAME##_ != value)\
				{\
					NAME##_ = value;\
					NAME##Changed.Execute(compositions::GuiEventArgs(this));\
				}\
			}\

#define GUI_TEMPLATE_PROPERTY_EVENT_INIT(CLASS, TYPE, NAME, VALUE)\
			NAME##Changed.SetAssociatedComposition(this);

#define GUI_TEMPLATE_CLASS_DECL(CLASS, BASE)\
			class CLASS : public BASE, public AggregatableDescription<CLASS>\
			{\
			public:\
				CLASS();\
				~CLASS();\
				CLASS ## _PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)\
			};\

#define GUI_TEMPLATE_CLASS_IMPL(CLASS, BASE)\
			CLASS ## _PROPERTIES(GUI_TEMPLATE_PROPERTY_IMPL)\
			CLASS::CLASS()\
			{\
				CLASS ## _PROPERTIES(GUI_TEMPLATE_PROPERTY_EVENT_INIT)\
			}\
			CLASS::~CLASS()\
			{\
				FinalizeAggregation();\
			}\

#define GUI_CONTROL_TEMPLATE_DECL(F)\
			F(GuiControlTemplate,				GuiTemplate)				\
			F(GuiLabelTemplate,					GuiControlTemplate)			\
			F(GuiSinglelineTextBoxTemplate,		GuiControlTemplate)			\
			F(GuiDocumentLabelTemplate,			GuiControlTemplate)			\
			F(GuiWindowTemplate,				GuiControlTemplate)			\
			F(GuiMenuTemplate,					GuiWindowTemplate)			\
			F(GuiButtonTemplate,				GuiControlTemplate)			\
			F(GuiSelectableButtonTemplate,		GuiButtonTemplate)			\
			F(GuiToolstripButtonTemplate,		GuiSelectableButtonTemplate)\
			F(GuiListViewColumnHeaderTemplate,	GuiToolstripButtonTemplate)	\
			F(GuiComboBoxTemplate,				GuiToolstripButtonTemplate)	\
			F(GuiScrollTemplate,				GuiControlTemplate)			\
			F(GuiScrollViewTemplate,			GuiControlTemplate)			\
			F(GuiMultilineTextBoxTemplate,		GuiScrollViewTemplate)		\
			F(GuiDocumentViewerTemplate,		GuiScrollViewTemplate)		\
			F(GuiListControlTemplate,			GuiScrollViewTemplate)		\
			F(GuiTextListTemplate,				GuiListControlTemplate)		\
			F(GuiListViewTemplate,				GuiListControlTemplate)		\
			F(GuiTreeViewTemplate,				GuiListControlTemplate)		\
			F(GuiTabTemplate,					GuiControlTemplate)			\
			F(GuiDatePickerTemplate,			GuiControlTemplate)			\
			F(GuiDateComboBoxTemplate,			GuiComboBoxTemplate)		\
			F(GuiRibbonTabTemplate,				GuiTabTemplate)				\
			F(GuiRibbonGroupTemplate,			GuiControlTemplate)			\
			F(GuiRibbonIconLabelTemplate,		GuiControlTemplate)			\
			F(GuiRibbonButtonsTemplate,			GuiControlTemplate)			\
			F(GuiRibbonToolstripsTemplate,		GuiControlTemplate)			\
			F(GuiRibbonToolstripMenuTemplate,	GuiMenuTemplate)			\
			F(GuiRibbonGalleryTemplate,			GuiControlTemplate)			\
			F(GuiRibbonGalleryListTemplate,		GuiRibbonGalleryTemplate)	\

#define GUI_ITEM_TEMPLATE_DECL(F)\
			F(GuiTextListItemTemplate,			GuiListItemTemplate)		\
			F(GuiTreeItemTemplate,				GuiTextListItemTemplate)	\
			F(GuiGridCellTemplate,				GuiControlTemplate)			\
			F(GuiGridVisualizerTemplate,		GuiGridCellTemplate)		\
			F(GuiGridEditorTemplate,			GuiGridCellTemplate)		\

/***********************************************************************
GuiTemplate
***********************************************************************/

			/// <summary>Represents a user customizable template.</summary>
			class GuiTemplate : public compositions::GuiBoundsComposition, public controls::GuiInstanceRootObject, public Description<GuiTemplate>
			{
			protected:
				controls::GuiControlHost*		GetControlHostForInstance()override;
				void							OnParentLineChanged()override;
			public:
				/// <summary>Create a template.</summary>
				GuiTemplate();
				~GuiTemplate();
				
#define GuiTemplate_PROPERTIES(F)\
				F(GuiTemplate,	FontProperties,		Font,				{}	)\
				F(GuiTemplate,	description::Value,	Context,			{}	)\
				F(GuiTemplate,	WString,			Text,				{}	)\
				F(GuiTemplate,	bool,				VisuallyEnabled,	true)\

				GuiTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

/***********************************************************************
GuiListItemTemplate
***********************************************************************/

			class GuiListItemTemplate : public GuiTemplate, public AggregatableDescription<GuiListItemTemplate>
			{
			protected:
				controls::GuiListControl*	listControl = nullptr;

				virtual void				OnInitialize();
			public:
				GuiListItemTemplate();
				~GuiListItemTemplate();

#define GuiListItemTemplate_PROPERTIES(F)\
				F(GuiListItemTemplate, bool, Selected, false)\
				F(GuiListItemTemplate, vint, Index, 0)\

				GuiListItemTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)

				void						BeginEditListItem();
				void						EndEditListItem();
				void						Initialize(controls::GuiListControl* _listControl);
			};

/***********************************************************************
Control Template
***********************************************************************/

			enum class BoolOption
			{
				AlwaysTrue,
				AlwaysFalse,
				Customizable,
			};

#define GuiControlTemplate_PROPERTIES(F)\
				F(GuiControlTemplate, compositions::GuiGraphicsComposition*, ContainerComposition, this)\
				F(GuiControlTemplate, compositions::GuiGraphicsComposition*, FocusableComposition, nullptr)\
				F(GuiControlTemplate, bool, Focused, false)\

#define GuiLabelTemplate_PROPERTIES(F)\
				F(GuiLabelTemplate, Color, DefaultTextColor, {})\
				F(GuiLabelTemplate, Color, TextColor, {})\

#define GuiSinglelineTextBoxTemplate_PROPERTIES(F)\
				F(GuiSinglelineTextBoxTemplate, elements::text::ColorEntry, TextColor, {})\
				F(GuiSinglelineTextBoxTemplate, Color, CaretColor, {})\

#define GuiDocumentLabelTemplate_PROPERTIES(F)\
				F(GuiDocumentLabelTemplate, Ptr<DocumentModel>, BaselineDocument, {})\
				F(GuiDocumentLabelTemplate, Color, CaretColor, {})\

#define GuiWindowTemplate_PROPERTIES(F)\
				F(GuiWindowTemplate, BoolOption, MaximizedBoxOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, MinimizedBoxOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, BorderOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, SizeBoxOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, IconVisibleOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, TitleBarOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, bool, MaximizedBox, true)\
				F(GuiWindowTemplate, bool, MinimizedBox, true)\
				F(GuiWindowTemplate, bool, Border, true)\
				F(GuiWindowTemplate, bool, SizeBox, true)\
				F(GuiWindowTemplate, bool, IconVisible, true)\
				F(GuiWindowTemplate, bool, TitleBar, true)\
				F(GuiWindowTemplate, bool, Maximized, false)\
				F(GuiWindowTemplate, bool, Activated, false)\
				F(GuiWindowTemplate, TemplateProperty<GuiWindowTemplate>, TooltipTemplate, {})\
				F(GuiWindowTemplate, TemplateProperty<GuiLabelTemplate>, ShortcutKeyTemplate, {})\
				F(GuiWindowTemplate, bool, CustomFrameEnabled, true)\
				F(GuiWindowTemplate, Margin, CustomFramePadding, {})\
				F(GuiWindowTemplate, Ptr<GuiImageData>, Icon, {})\

#define GuiMenuTemplate_PROPERTIES(F)

#define GuiButtonTemplate_PROPERTIES(F)\
				F(GuiButtonTemplate, controls::ButtonState, State, controls::ButtonState::Normal)\

#define GuiSelectableButtonTemplate_PROPERTIES(F)\
				F(GuiSelectableButtonTemplate, bool, Selected, false)\

#define GuiToolstripButtonTemplate_PROPERTIES(F)\
				F(GuiToolstripButtonTemplate, TemplateProperty<GuiMenuTemplate>, SubMenuTemplate, {})\
				F(GuiToolstripButtonTemplate, bool, SubMenuExisting, false)\
				F(GuiToolstripButtonTemplate, bool, SubMenuOpening, false)\
				F(GuiToolstripButtonTemplate, controls::GuiButton*, SubMenuHost, nullptr)\
				F(GuiToolstripButtonTemplate, Ptr<GuiImageData>, LargeImage, {})\
				F(GuiToolstripButtonTemplate, Ptr<GuiImageData>, Image, {})\
				F(GuiToolstripButtonTemplate, WString, ShortcutText, {})\

#define GuiListViewColumnHeaderTemplate_PROPERTIES(F)\
				F(GuiListViewColumnHeaderTemplate, controls::ColumnSortingState, SortingState, controls::ColumnSortingState::NotSorted)\

#define GuiComboBoxTemplate_PROPERTIES(F)\
				F(GuiComboBoxTemplate, bool, TextVisible, true)\

#define GuiScrollTemplate_PROPERTIES(F)\
				F(GuiScrollTemplate, controls::IScrollCommandExecutor*, Commands, nullptr)\
				F(GuiScrollTemplate, vint, TotalSize, 100)\
				F(GuiScrollTemplate, vint, PageSize, 10)\
				F(GuiScrollTemplate, vint, Position, 0)\

#define GuiScrollViewTemplate_PROPERTIES(F)\
				F(GuiScrollViewTemplate, controls::GuiScroll*, HorizontalScroll, nullptr)\
				F(GuiScrollViewTemplate, controls::GuiScroll*, VerticalScroll, nullptr)\

#define GuiMultilineTextBoxTemplate_PROPERTIES(F)\
				F(GuiMultilineTextBoxTemplate, controls::ITextBoxCommandExecutor*, Commands, nullptr)\
				F(GuiMultilineTextBoxTemplate, elements::text::ColorEntry, TextColor, {})\
				F(GuiMultilineTextBoxTemplate, Color, CaretColor, {})\

#define GuiDocumentViewerTemplate_PROPERTIES(F)\
				F(GuiDocumentViewerTemplate, Ptr<DocumentModel>, BaselineDocument, {})\
				F(GuiDocumentViewerTemplate, Color, CaretColor, {})\

#define GuiListControlTemplate_PROPERTIES(F)\
				F(GuiListControlTemplate, TemplateProperty<GuiSelectableButtonTemplate>, BackgroundTemplate, {})\

#define GuiTextListTemplate_PROPERTIES(F)\
				F(GuiTextListTemplate, Color, TextColor, {})\
				F(GuiTextListTemplate, TemplateProperty<GuiSelectableButtonTemplate>, CheckBulletTemplate, {})\
				F(GuiTextListTemplate, TemplateProperty<GuiSelectableButtonTemplate>, RadioBulletTemplate, {})\

#define GuiListViewTemplate_PROPERTIES(F)\
				F(GuiListViewTemplate, TemplateProperty<GuiListViewColumnHeaderTemplate>, ColumnHeaderTemplate, {})\
				F(GuiListViewTemplate, Color, PrimaryTextColor, {})\
				F(GuiListViewTemplate, Color, SecondaryTextColor, {})\
				F(GuiListViewTemplate, Color, ItemSeparatorColor, {})\

#define GuiTreeViewTemplate_PROPERTIES(F)\
				F(GuiTreeViewTemplate, TemplateProperty<GuiSelectableButtonTemplate>, ExpandingDecoratorTemplate, {})\
				F(GuiTreeViewTemplate, Color, TextColor, {})\

#define GuiTabTemplate_PROPERTIES(F)\
				F(GuiTabTemplate, controls::ITabCommandExecutor*, Commands, nullptr)\
				F(GuiTabTemplate, Ptr<reflection::description::IValueObservableList>, TabPages, {})\
				F(GuiTabTemplate, controls::GuiTabPage*, SelectedTabPage, nullptr)\
				F(GuiTabTemplate, controls::TabPageOrder, TabOrder, controls::TabPageOrder::Unknown)\

#define GuiDatePickerTemplate_PROPERTIES(F)\
				F(GuiDatePickerTemplate, controls::IDatePickerCommandExecutor*, Commands, nullptr)\
				F(GuiDatePickerTemplate, Locale, DateLocale, {})\
				F(GuiDatePickerTemplate, DateTime, Date, {})\

#define GuiDateComboBoxTemplate_PROPERTIES(F)\
				F(GuiDateComboBoxTemplate, TemplateProperty<GuiDatePickerTemplate>, DatePickerTemplate, {})\

#define GuiRibbonTabTemplate_PROPERTIES(F)\
				F(GuiRibbonTabTemplate, compositions::GuiGraphicsComposition*, BeforeHeadersContainer, nullptr)\
				F(GuiRibbonTabTemplate, compositions::GuiGraphicsComposition*, AfterHeadersContainer, nullptr)\

#define GuiRibbonGroupTemplate_PROPERTIES(F)\
				F(GuiRibbonGroupTemplate, controls::IRibbonGroupCommandExecutor*, Commands, nullptr)\
				F(GuiRibbonGroupTemplate, bool, Expandable, false)\
				F(GuiRibbonGroupTemplate, bool, Collapsed, false)\
				F(GuiRibbonGroupTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeDropdownButtonTemplate, {})\
				F(GuiRibbonGroupTemplate, TemplateProperty<GuiMenuTemplate>, SubMenuTemplate, {})\

#define GuiRibbonIconLabelTemplate_PROPERTIES(F)\
				F(GuiRibbonIconLabelTemplate, Ptr<GuiImageData>, Image, {})\

#define GuiRibbonButtonsTemplate_PROPERTIES(F)\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeDropdownButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeSplitButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallDropdownButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallSplitButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallIconLabelTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconDropdownButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconSplitButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconLabelTemplate, {})\

#define GuiRibbonToolstripsTemplate_PROPERTIES(F)\
				F(GuiRibbonToolstripsTemplate, TemplateProperty<GuiControlTemplate>, ToolbarTemplate, {})\

#define GuiRibbonToolstripMenuTemplate_PROPERTIES(F)\
				F(GuiRibbonToolstripMenuTemplate, compositions::GuiGraphicsComposition*, ContentComposition, nullptr)\

#define GuiRibbonGalleryTemplate_PROPERTIES(F)\
				F(GuiRibbonGalleryTemplate, controls::IRibbonGalleryCommandExecutor*, Commands, nullptr)\
				F(GuiRibbonGalleryTemplate, bool, ScrollUpEnabled, true)\
				F(GuiRibbonGalleryTemplate, bool, ScrollDownEnabled, true)\

#define GuiRibbonGalleryListTemplate_PROPERTIES(F)\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiTextListTemplate>, ItemListTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiRibbonToolstripMenuTemplate>, MenuTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiControlTemplate>, HeaderTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiSelectableButtonTemplate>, BackgroundTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiScrollViewTemplate>, GroupContainerTemplate, {})\

/***********************************************************************
Item Template
***********************************************************************/
				
#define GuiListItemTemplate_PROPERTIES(F)\
				F(GuiListItemTemplate, bool, Selected, false)\
				F(GuiListItemTemplate, vint, Index, 0)\

#define GuiTextListItemTemplate_PROPERTIES(F)\
				F(GuiTextListItemTemplate, Color, TextColor, {})\
				F(GuiTextListItemTemplate, bool, Checked, false)\
				
#define GuiTreeItemTemplate_PROPERTIES(F)\
				F(GuiTreeItemTemplate, bool, Expanding, false)\
				F(GuiTreeItemTemplate, bool, Expandable, false)\
				F(GuiTreeItemTemplate, vint, Level, 0)\
				F(GuiTreeItemTemplate, Ptr<GuiImageData>, Image, {})\

#define GuiGridCellTemplate_PROPERTIES(F)\
				F(GuiGridCellTemplate, Color, PrimaryTextColor, {})\
				F(GuiGridCellTemplate, Color, SecondaryTextColor, {})\
				F(GuiGridCellTemplate, Color, ItemSeparatorColor, {})\
				F(GuiGridCellTemplate, Ptr<GuiImageData>, LargeImage, {})\
				F(GuiGridCellTemplate, Ptr<GuiImageData>, SmallImage, {})\

#define GuiGridVisualizerTemplate_PROPERTIES(F)\
				F(GuiGridVisualizerTemplate, description::Value, RowValue, {})\
				F(GuiGridVisualizerTemplate, description::Value, CellValue, {})\
				F(GuiGridVisualizerTemplate, bool, Selected, false)\

#define GuiGridEditorTemplate_PROPERTIES(F)\
				F(GuiGridEditorTemplate, description::Value, RowValue, {})\
				F(GuiGridEditorTemplate, description::Value, CellValue, {})\
				F(GuiGridEditorTemplate, bool, CellValueSaved, true)\
				F(GuiGridEditorTemplate, controls::GuiControl*, FocusControl, nullptr)\

/***********************************************************************
Template Declarations
***********************************************************************/

			GUI_CONTROL_TEMPLATE_DECL(GUI_TEMPLATE_CLASS_DECL)
			GUI_ITEM_TEMPLATE_DECL(GUI_TEMPLATE_CLASS_DECL)
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\GUIBASICCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			enum class ThemeName;
		}

		namespace controls
		{
			template<typename T, typename Enabled = YesType>
			struct QueryServiceHelper;

			template<typename T>
			struct QueryServiceHelper<T, typename RequiresConvertable<decltype(T::Identifier), const wchar_t* const>::YesNoType>
			{
				static WString GetIdentifier()
				{
					return WString(T::Identifier, false);
				}
			};

			template<typename T>
			struct QueryServiceHelper<T, typename RequiresConvertable<decltype(T::GetIdentifier()), WString>::YesNoType>
			{
				static WString GetIdentifier()
				{
					return MoveValue<WString>(T::GetIdentifier());
				}
			};

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// A helper object to test if a control has been deleted or not.
			/// </summary>
			class GuiDisposedFlag : public Object, public Description<GuiDisposedFlag>
			{
				friend class GuiControl;
			protected:
				GuiControl*								owner = nullptr;
				bool									disposed = false;

				void									SetDisposed();
			public:
				GuiDisposedFlag(GuiControl* _owner);
				~GuiDisposedFlag();

				bool									IsDisposed();
			};

			/// <summary>
			/// The base class of all controls.
			/// When the control is destroyed, it automatically destroys sub controls, and the bounds composition from the style controller.
			/// If you want to manually destroy a control, you should first remove it from its parent.
			/// The only way to remove a control from a parent control, is to remove the bounds composition from its parent composition. The same to inserting a control.
			/// </summary>
			class GuiControl
				: public Object
				, protected compositions::IGuiAltAction
				, protected compositions::IGuiTabAction
				, public Description<GuiControl>
			{
				friend class compositions::GuiGraphicsComposition;

			protected:
				using ControlList = collections::List<GuiControl*>;
				using ControlServiceMap = collections::Dictionary<WString, Ptr<IDescriptable>>;
				using ControlTemplatePropertyType = TemplateProperty<templates::GuiControlTemplate>;
				using IGuiGraphicsEventHandler = compositions::IGuiGraphicsEventHandler;

			private:
				theme::ThemeName						controlThemeName;
				ControlTemplatePropertyType				controlTemplate;
				templates::GuiControlTemplate*			controlTemplateObject = nullptr;
				Ptr<GuiDisposedFlag>					disposedFlag;

			public:
				Ptr<GuiDisposedFlag>					GetDisposedFlag();

			protected:
				compositions::GuiBoundsComposition*		boundsComposition = nullptr;
				compositions::GuiBoundsComposition*		containerComposition = nullptr;
				compositions::GuiGraphicsComposition*	focusableComposition = nullptr;
				compositions::GuiGraphicsEventReceiver*	eventReceiver = nullptr;

				bool									isFocused = false;
				Ptr<IGuiGraphicsEventHandler>			gotFocusHandler;
				Ptr<IGuiGraphicsEventHandler>			lostFocusHandler;

				bool									acceptTabInput = false;
				vint									tabPriority = -1;
				bool									isEnabled = true;
				bool									isVisuallyEnabled = true;
				bool									isVisible = true;
				WString									alt;
				WString									text;
				Nullable<FontProperties>				font;
				FontProperties							displayFont;
				description::Value						context;
				compositions::IGuiAltActionHost*		activatingAltHost = nullptr;
				ControlServiceMap						controlServices;

				GuiControl*								parent = nullptr;
				ControlList								children;
				description::Value						tag;
				GuiControl*								tooltipControl = nullptr;
				vint									tooltipWidth = 0;

				virtual void							BeforeControlTemplateUninstalled();
				virtual void							AfterControlTemplateInstalled(bool initialize);
				virtual void							CheckAndStoreControlTemplate(templates::GuiControlTemplate* value);
				virtual void							EnsureControlTemplateExists();
				virtual void							RebuildControlTemplate();
				virtual void							OnChildInserted(GuiControl* control);
				virtual void							OnChildRemoved(GuiControl* control);
				virtual void							OnParentChanged(GuiControl* oldParent, GuiControl* newParent);
				virtual void							OnParentLineChanged();
				virtual void							OnServiceAdded();
				virtual void							OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget);
				virtual void							OnBeforeReleaseGraphicsHost();
				virtual void							UpdateVisuallyEnabled();
				virtual void							UpdateDisplayFont();
				void									OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

				bool									IsControlVisibleAndEnabled();
				bool									IsAltEnabled()override;
				bool									IsAltAvailable()override;
				compositions::GuiGraphicsComposition*	GetAltComposition()override;
				compositions::IGuiAltActionHost*		GetActivatingAltHost()override;
				void									OnActiveAlt()override;
				bool									IsTabEnabled()override;
				bool									IsTabAvailable()override;

				static bool								SharedPtrDestructorProc(DescriptableObject* obj, bool forceDisposing);

			public:
				using ControlTemplateType = templates::GuiControlTemplate;

				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiControl(theme::ThemeName themeName);
				~GuiControl();

				/// <summary>Theme name changed event. This event will be raised when the theme name is changed.</summary>
				compositions::GuiNotifyEvent			ControlThemeNameChanged;
				/// <summary>Control template changed event. This event will be raised when the control template is changed.</summary>
				compositions::GuiNotifyEvent			ControlTemplateChanged;
				/// <summary>Control signal trigerred. This event will be raised because of multiple reason specified in the argument.</summary>
				compositions::GuiControlSignalEvent		ControlSignalTrigerred;
				/// <summary>Visible event. This event will be raised when the visibility state of the control is changed.</summary>
				compositions::GuiNotifyEvent			VisibleChanged;
				/// <summary>Enabled event. This event will be raised when the enabling state of the control is changed.</summary>
				compositions::GuiNotifyEvent			EnabledChanged;
				/// <summary>Focused event. This event will be raised when the focusing state of the control is changed.</summary>
				compositions::GuiNotifyEvent			FocusedChanged;
				/// <summary>
				/// Enabled event. This event will be raised when the visually enabling state of the control is changed. A visually enabling is combined by the enabling state and the parent's visually enabling state.
				/// A control is rendered as disabled, not only when the control itself is disabled, but also when the parent control is rendered as disabled.
				/// </summary>
				compositions::GuiNotifyEvent			VisuallyEnabledChanged;
				/// <summary>Alt changed event. This event will be raised when the associated Alt-combined shortcut key of the control is changed.</summary>
				compositions::GuiNotifyEvent			AltChanged;
				/// <summary>Text changed event. This event will be raised when the text of the control is changed.</summary>
				compositions::GuiNotifyEvent			TextChanged;
				/// <summary>Font changed event. This event will be raised when the font of the control is changed.</summary>
				compositions::GuiNotifyEvent			FontChanged;
				/// <summary>Display font changed event. This event will be raised when the display font of the control is changed.</summary>
				compositions::GuiNotifyEvent			DisplayFontChanged;
				/// <summary>Context changed event. This event will be raised when the font of the control is changed.</summary>
				compositions::GuiNotifyEvent			ContextChanged;

				void									InvokeOrDelayIfRendering(Func<void()> proc);

				/// <summary>A function to create the argument for notify events that raised by itself.</summary>
				/// <returns>The created argument.</returns>
				compositions::GuiEventArgs				GetNotifyEventArguments();
				/// <summary>Get the associated theme name.</summary>
				/// <returns>The theme name.</returns>
				theme::ThemeName						GetControlThemeName();
				/// <summary>Set the associated control theme name.</summary>
				/// <param name="value">The theme name.</param>
				void									SetControlThemeName(theme::ThemeName value);
				/// <summary>Get the associated control template.</summary>
				/// <returns>The control template.</returns>
				ControlTemplatePropertyType				GetControlTemplate();
				/// <summary>Set the associated control template.</summary>
				/// <param name="value">The control template.</param>
				void									SetControlTemplate(const ControlTemplatePropertyType& value);
				/// <summary>Set the associated control theme name and template and the same time.</summary>
				/// <param name="themeNameValue">The theme name.</param>
				/// <param name="controlTemplateValue">The control template.</param>
				void									SetControlThemeNameAndTemplate(theme::ThemeName themeNameValue, const ControlTemplatePropertyType& controlTemplateValue);
				/// <summary>Get the associated style controller.</summary>
				/// <returns>The associated style controller.</returns>
				templates::GuiControlTemplate*			GetControlTemplateObject();
				/// <summary>Get the bounds composition for the control.</summary>
				/// <returns>The bounds composition.</returns>
				compositions::GuiBoundsComposition*		GetBoundsComposition();
				/// <summary>Get the container composition for the control.</summary>
				/// <returns>The container composition.</returns>
				compositions::GuiGraphicsComposition*	GetContainerComposition();
				/// <summary>Get the focusable composition for the control. A focusable composition is the composition to be focused when the control is focused.</summary>
				/// <returns>The focusable composition.</returns>
				compositions::GuiGraphicsComposition*	GetFocusableComposition();
				/// <summary>Get the parent control.</summary>
				/// <returns>The parent control.</returns>
				GuiControl*								GetParent();
				/// <summary>Get the number of child controls.</summary>
				/// <returns>The number of child controls.</returns>
				vint									GetChildrenCount();
				/// <summary>Get the child control using a specified index.</summary>
				/// <returns>The child control.</returns>
				/// <param name="index">The specified index.</param>
				GuiControl*								GetChild(vint index);
				/// <summary>Put another control in the container composition of this control.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="control">The control to put in this control.</param>
				bool									AddChild(GuiControl* control);
				/// <summary>Test if a control owned by this control.</summary>
				/// <returns>Returns true if the control is owned by this control.</returns>
				/// <param name="control">The control to test.</param>
				bool									HasChild(GuiControl* control);
				
				/// <summary>Get the <see cref="GuiControlHost"/> that contains this control.</summary>
				/// <returns>The <see cref="GuiControlHost"/> that contains this control.</returns>
				virtual GuiControlHost*					GetRelatedControlHost();
				/// <summary>Test if this control is rendered as enabled.</summary>
				/// <returns>Returns true if this control is rendered as enabled.</returns>
				virtual bool							GetVisuallyEnabled();
				/// <summary>Test if this control is focused.</summary>
				/// <returns>Returns true if this control is focused.</returns>
				virtual bool							GetFocused();
				/// <summary>Test if this control accepts tab character input.</summary>
				/// <returns>Returns true if this control accepts tab character input.</returns>
				virtual bool							GetAcceptTabInput()override;
				/// <summary>Set if this control accepts tab character input.</summary>
				/// <param name="value">Set to true to make this control accept tab character input.</param>
				void									SetAcceptTabInput(bool value);
				/// <summary>Get the tab priority associated with this control.</summary>
				/// <returns>Returns he tab priority associated with this control.</returns>
				virtual vint							GetTabPriority()override;
				/// <summary>Associate a tab priority with this control.</summary>
				/// <param name="value">The tab priority to associate. TAB key will go through controls in the order of priority: 0, 1, 2, ..., -1. All negative numbers will be converted to -1. The priority of containers affects all children if it is not -1.</param>
				void									SetTabPriority(vint value);
				/// <summary>Test if this control is enabled.</summary>
				/// <returns>Returns true if this control is enabled.</returns>
				virtual bool							GetEnabled();
				/// <summary>Make the control enabled or disabled.</summary>
				/// <param name="value">Set to true to make the control enabled.</param>
				virtual void							SetEnabled(bool value);
				/// <summary>Test if this visible or invisible.</summary>
				/// <returns>Returns true if this control is visible.</returns>
				virtual bool							GetVisible();
				/// <summary>Make the control visible or invisible.</summary>
				/// <param name="value">Set to true to make the visible enabled.</param>
				virtual void							SetVisible(bool value);
				/// <summary>Get the Alt-combined shortcut key associated with this control.</summary>
				/// <returns>The Alt-combined shortcut key associated with this control.</returns>
				virtual const WString&					GetAlt()override;
				/// <summary>Associate a Alt-combined shortcut key with this control.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The Alt-combined shortcut key to associate. The key should contain only upper-case letters or digits.</param>
				virtual bool							SetAlt(const WString& value);
				/// <summary>Make the control as the parent of multiple Alt-combined shortcut key activatable controls.</summary>
				/// <param name="host">The alt action host object.</param>
				void									SetActivatingAltHost(compositions::IGuiAltActionHost* host);
				/// <summary>Get the text to display on the control.</summary>
				/// <returns>The text to display on the control.</returns>
				virtual const WString&					GetText();
				/// <summary>Set the text to display on the control.</summary>
				/// <param name="value">The text to display on the control.</param>
				virtual void							SetText(const WString& value);
				/// <summary>Get the font of this control.</summary>
				/// <returns>The font of this control.</returns>
				virtual const Nullable<FontProperties>&	GetFont();
				/// <summary>Set the font of this control.</summary>
				/// <param name="value">The font of this control.</param>
				virtual void							SetFont(const Nullable<FontProperties>& value);
				/// <summary>Get the font to render the text. If the font of this control is null, then the display font is either the parent control's display font, or the system's default font when there is no parent control.</summary>
				/// <returns>The font to render the text.</returns>
				virtual const FontProperties&			GetDisplayFont();
				/// <summary>Get the context of this control. The control template and all item templates (if it has) will see this context property.</summary>
				/// <returns>The context of this context.</returns>
				virtual description::Value				GetContext();
				/// <summary>Set the context of this control.</summary>
				/// <param name="value">The context of this control.</param>
				virtual void							SetContext(const description::Value& value);
				/// <summary>Focus this control.</summary>
				virtual void							SetFocus();

				/// <summary>Get the tag object of the control.</summary>
				/// <returns>The tag object of the control.</returns>
				description::Value						GetTag();
				/// <summary>Set the tag object of the control.</summary>
				/// <param name="value">The tag object of the control.</param>
				void									SetTag(const description::Value& value);
				/// <summary>Get the tooltip control of the control.</summary>
				/// <returns>The tooltip control of the control.</returns>
				GuiControl*								GetTooltipControl();
				/// <summary>Set the tooltip control of the control. The tooltip control will be released when this control is released. If you set a new tooltip control to replace the old one, the old one will not be owned by this control anymore, therefore user should release the old tooltip control manually.</summary>
				/// <returns>The old tooltip control.</returns>
				/// <param name="value">The tooltip control of the control.</param>
				GuiControl*								SetTooltipControl(GuiControl* value);
				/// <summary>Get the tooltip width of the control.</summary>
				/// <returns>The tooltip width of the control.</returns>
				vint									GetTooltipWidth();
				/// <summary>Set the tooltip width of the control.</summary>
				/// <param name="value">The tooltip width of the control.</param>
				void									SetTooltipWidth(vint value);
				/// <summary>Display the tooltip.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="location">The relative location to specify the left-top position of the tooltip.</param>
				bool									DisplayTooltip(Point location);
				/// <summary>Close the tooltip that owned by this control.</summary>
				void									CloseTooltip();

				/// <summary>Query a service using an identifier. If you want to get a service of type IXXX, use IXXX::Identifier as the identifier.</summary>
				/// <returns>The requested service. If the control doesn't support this service, it will be null.</returns>
				/// <param name="identifier">The identifier.</param>
				virtual IDescriptable*					QueryService(const WString& identifier);

				template<typename T>
				T* QueryTypedService()
				{
					return dynamic_cast<T*>(QueryService(QueryServiceHelper<T>::GetIdentifier()));
				}

				/// <summary>Add a service to this control dynamically. The added service cannot override existing services.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="identifier">The identifier. You are suggested to fill this parameter using the value from the interface's GetIdentifier function, or <see cref="QueryTypedService`1"/> will not work on this service.</param>
				/// <param name="value">The service.</param>
				bool									AddService(const WString& identifier, Ptr<IDescriptable> value);
			};

			/// <summary>Represnets a user customizable control.</summary>
			class GuiCustomControl : public GuiControl, public GuiInstanceRootObject, public AggregatableDescription<GuiCustomControl>
			{
			protected:
				controls::GuiControlHost*				GetControlHostForInstance()override;
				void									OnParentLineChanged()override;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiCustomControl(theme::ThemeName themeName);
				~GuiCustomControl();
			};

			template<typename T>
			class GuiObjectComponent : public GuiComponent
			{
			public:
				Ptr<T>				object;

				GuiObjectComponent()
				{
				}

				GuiObjectComponent(Ptr<T> _object)
					:object(_object)
				{
				}
			};

#define GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_3(UNIQUE) controlTemplateObject ## UNIQUE
#define GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_2(UNIQUE) GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_3(UNIQUE)
#define GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_2(__LINE__)

#define GUI_SPECIFY_CONTROL_TEMPLATE_TYPE_2(TEMPLATE, BASE_TYPE, NAME) \
			public: \
				using ControlTemplateType = templates::Gui##TEMPLATE; \
			private: \
				templates::Gui##TEMPLATE* NAME = nullptr; \
				void BeforeControlTemplateUninstalled_(); \
				void AfterControlTemplateInstalled_(bool initialize); \
			protected: \
				void BeforeControlTemplateUninstalled()override \
				{\
					BeforeControlTemplateUninstalled_(); \
					BASE_TYPE::BeforeControlTemplateUninstalled(); \
				}\
				void AfterControlTemplateInstalled(bool initialize)override \
				{\
					BASE_TYPE::AfterControlTemplateInstalled(initialize); \
					AfterControlTemplateInstalled_(initialize); \
				}\
				void CheckAndStoreControlTemplate(templates::GuiControlTemplate* value)override \
				{ \
					auto ct = dynamic_cast<templates::Gui##TEMPLATE*>(value); \
					CHECK_ERROR(ct, L"The assigned control template is not vl::presentation::templates::Gui" L ## # TEMPLATE L"."); \
					NAME = ct; \
					BASE_TYPE::CheckAndStoreControlTemplate(value); \
				} \
			public: \
				templates::Gui##TEMPLATE* GetControlTemplateObject(bool ensureExists) \
				{ \
					if (ensureExists) \
					{ \
						EnsureControlTemplateExists(); \
					} \
					return NAME; \
				} \
			private: \

#define GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TEMPLATE, BASE_TYPE) GUI_SPECIFY_CONTROL_TEMPLATE_TYPE_2(TEMPLATE, BASE_TYPE, GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME)

		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUIWINDOWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class IGuiShortcutKeyManager;
			class GuiGraphicsTimerManager;
		}

		namespace controls
		{

/***********************************************************************
Control Host
***********************************************************************/

			/// <summary>
			/// Represents a control that host by a <see cref="INativeWindow"/>.
			/// </summary>
			class GuiControlHost : public GuiControl, public GuiInstanceRootObject, protected INativeWindowListener, public Description<GuiControlHost>
			{
				friend class compositions::GuiGraphicsHost;
			protected:
				compositions::GuiGraphicsHost*					host;

				virtual void									OnNativeWindowChanged();
				virtual void									OnVisualStatusChanged();
			protected:
				static const vint								TooltipDelayOpenTime = 500;
				static const vint								TooltipDelayCloseTime = 500;
				static const vint								TooltipDelayLifeTime = 5000;

				Ptr<INativeDelay>								tooltipOpenDelay;
				Ptr<INativeDelay>								tooltipCloseDelay;
				Point											tooltipLocation;

				bool											calledDestroyed = false;
				bool											deleteWhenDestroyed = false;

				controls::GuiControlHost*						GetControlHostForInstance()override;
				GuiControl*										GetTooltipOwner(Point location);
				void											MoveIntoTooltipControl(GuiControl* tooltipControl, Point location);
				void											MouseMoving(const NativeWindowMouseInfo& info)override;
				void											MouseLeaved()override;
				void											Moved()override;
				void											Enabled()override;
				void											Disabled()override;
				void											GotFocus()override;
				void											LostFocus()override;
				void											Activated()override;
				void											Deactivated()override;
				void											Opened()override;
				void											Closing(bool& cancel)override;
				void											Closed()override;
				void											Destroying()override;

				virtual void									UpdateClientSizeAfterRendering(Size clientSize);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiControlHost(theme::ThemeName themeName);
				~GuiControlHost();
				
				/// <summary>Window got focus event.</summary>
				compositions::GuiNotifyEvent					WindowGotFocus;
				/// <summary>Window lost focus event.</summary>
				compositions::GuiNotifyEvent					WindowLostFocus;
				/// <summary>Window activated event.</summary>
				compositions::GuiNotifyEvent					WindowActivated;
				/// <summary>Window deactivated event.</summary>
				compositions::GuiNotifyEvent					WindowDeactivated;
				/// <summary>Window opened event.</summary>
				compositions::GuiNotifyEvent					WindowOpened;
				/// <summary>Window closing event.</summary>
				compositions::GuiRequestEvent					WindowClosing;
				/// <summary>Window closed event.</summary>
				compositions::GuiNotifyEvent					WindowClosed;
				/// <summary>Window destroying event.</summary>
				compositions::GuiNotifyEvent					WindowDestroying;

				/// <summary>Delete this control host after processing all events.</summary>
				void											DeleteAfterProcessingAllEvents();

				/// <summary>Get the internal <see cref="compositions::GuiGraphicsHost"/> object to host the window content.</summary>
				/// <returns>The internal <see cref="compositions::GuiGraphicsHost"/> object to host the window content.</returns>
				compositions::GuiGraphicsHost*					GetGraphicsHost();
				/// <summary>Get the main composition to host the window content.</summary>
				/// <returns>The main composition to host the window content.</returns>
				compositions::GuiGraphicsComposition*			GetMainComposition();
				/// <summary>Get the internal <see cref="INativeWindow"/> object to host the content.</summary>
				/// <returns>The the internal <see cref="INativeWindow"/> object to host the content.</returns>
				INativeWindow*									GetNativeWindow();
				/// <summary>Set the internal <see cref="INativeWindow"/> object to host the content.</summary>
				/// <param name="window">The the internal <see cref="INativeWindow"/> object to host the content.</param>
				void											SetNativeWindow(INativeWindow* window);
				/// <summary>Force to calculate layout and size immediately</summary>
				void											ForceCalculateSizeImmediately();
				
				/// <summary>Test is the window enabled.</summary>
				/// <returns>Returns true if the window is enabled.</returns>
				bool											GetEnabled()override;
				/// <summary>Enable or disable the window.</summary>
				/// <param name="value">Set to true to enable the window.</param>
				void											SetEnabled(bool value)override;
				/// <summary>Test is the window focused.</summary>
				/// <returns>Returns true if the window is focused.</returns>
				bool											GetFocused()override;
				/// <summary>Focus the window.</summary>
				void											SetFocused();
				/// <summary>Test is the window activated.</summary>
				/// <returns>Returns true if the window is activated.</returns>
				bool											GetActivated();
				/// <summary>Activate the window.</summary>
				void											SetActivated();
				/// <summary>Test is the window icon shown in the task bar.</summary>
				/// <returns>Returns true if the window is icon shown in the task bar.</returns>
				bool											GetShowInTaskBar();
				/// <summary>Show or hide the window icon in the task bar.</summary>
				/// <param name="value">Set to true to show the window icon in the task bar.</param>
				void											SetShowInTaskBar(bool value);
				/// <summary>Test is the window allowed to be activated.</summary>
				/// <returns>Returns true if the window is allowed to be activated.</returns>
				bool											GetEnabledActivate();
				/// <summary>Allow or forbid the window to be activated.</summary>
				/// <param name="value">Set to true to allow the window to be activated.</param>
				void											SetEnabledActivate(bool value);
				/// <summary>
				/// Test is the window always on top of the desktop.
				/// </summary>
				/// <returns>Returns true if the window is always on top of the desktop.</returns>
				bool											GetTopMost();
				/// <summary>
				/// Make the window always or never on top of the desktop.
				/// </summary>
				/// <param name="topmost">True to make the window always  on top of the desktop.</param>
				void											SetTopMost(bool topmost);

				/// <summary>Get the <see cref="compositions::IGuiShortcutKeyManager"/> attached with this control host.</summary>
				/// <returns>The shortcut key manager.</returns>
				compositions::IGuiShortcutKeyManager*			GetShortcutKeyManager();
				/// <summary>Attach or detach the <see cref="compositions::IGuiShortcutKeyManager"/> associated with this control host. When this control host is disposing, the associated shortcut key manager will be deleted if exists.</summary>
				/// <param name="value">The shortcut key manager. Set to null to detach the previous shortcut key manager from this control host.</param>
				void											SetShortcutKeyManager(compositions::IGuiShortcutKeyManager* value);
				/// <summary>Get the timer manager.</summary>
				/// <returns>The timer manager.</returns>
				compositions::GuiGraphicsTimerManager*			GetTimerManager();

				/// <summary>Get the client size of the window.</summary>
				/// <returns>The client size of the window.</returns>
				Size											GetClientSize();
				/// <summary>Set the client size of the window.</summary>
				/// <param name="value">The client size of the window.</param>
				void											SetClientSize(Size value);
				/// <summary>Get the location of the window in screen space.</summary>
				/// <returns>The location of the window.</returns>
				NativePoint										GetLocation();
				/// <summary>Set the location of the window in screen space.</summary>
				/// <param name="value">The location of the window.</param>
				void											SetLocation(NativePoint value);
				/// <summary>Set the location in screen space and the client size of the window.</summary>
				/// <param name="location">The location of the window.</param>
				/// <param name="size">The client size of the window.</param>
				void											SetBounds(NativePoint location, Size size);

				GuiControlHost*									GetRelatedControlHost()override;
				const WString&									GetText()override;
				void											SetText(const WString& value)override;

				/// <summary>Get the screen that contains the window.</summary>
				/// <returns>The screen that contains the window.</returns>
				INativeScreen*									GetRelatedScreen();
				/// <summary>
				/// Show the window.
				/// </summary>
				void											Show();
				/// <summary>
				/// Show the window without activation.
				/// </summary>
				void											ShowDeactivated();
				/// <summary>
				/// Restore the window.
				/// </summary>
				void											ShowRestored();
				/// <summary>
				/// Maximize the window.
				/// </summary>
				void											ShowMaximized();
				/// <summary>
				/// Minimize the window.
				/// </summary>
				void											ShowMinimized();
				/// <summary>
				/// Hide the window.
				/// </summary>
				void											Hide();
				/// <summary>
				/// Close the window and destroy the internal <see cref="INativeWindow"/> object.
				/// </summary>
				void											Close();
				/// <summary>Test is the window opened.</summary>
				/// <returns>Returns true if the window is opened.</returns>
				bool											GetOpening();
			};

/***********************************************************************
Window
***********************************************************************/

			/// <summary>
			/// Represents a normal window.
			/// </summary>
			class GuiWindow : public GuiControlHost, protected compositions::GuiAltActionHostBase, public AggregatableDescription<GuiWindow>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(WindowTemplate, GuiControlHost)
				friend class GuiApplication;
			protected:
				compositions::IGuiAltActionHost*		previousAltHost = nullptr;
				bool									hasMaximizedBox = true;
				bool									hasMinimizedBox = true;
				bool									hasBorder = true;
				bool									hasSizeBox = true;
				bool									isIconVisible = true;
				bool									hasTitleBar = true;
				Ptr<GuiImageData>						icon;
				
				void									UpdateCustomFramePadding(INativeWindow* window, templates::GuiWindowTemplate* ct);
				void									SyncNativeWindowProperties();
				void									Moved()override;
				void									DpiChanged()override;
				void									OnNativeWindowChanged()override;
				void									OnVisualStatusChanged()override;
				virtual void							MouseClickedOnOtherWindow(GuiWindow* window);
				
				void									OnWindowActivated(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowDeactivated(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiWindow(theme::ThemeName themeName);
				~GuiWindow();

				IDescriptable*							QueryService(const WString& identifier)override;

				/// <summary>Clipboard updated event.</summary>
				compositions::GuiNotifyEvent			ClipboardUpdated;

				/// <summary>Move the window to the center of the screen. If multiple screens exist, the window move to the screen that contains the biggest part of the window.</summary>
				void									MoveToScreenCenter();
				/// <summary>Move the window to the center of the specified screen.</summary>
				/// <param name="screen">The screen.</param>
				void									MoveToScreenCenter(INativeScreen* screen);
				
				/// <summary>
				/// Test is the maximize box visible.
				/// </summary>
				/// <returns>Returns true if the maximize box is visible.</returns>
				bool									GetMaximizedBox();
				/// <summary>
				/// Make the maximize box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the maximize box visible.</param>
				void									SetMaximizedBox(bool visible);
				/// <summary>
				/// Test is the minimize box visible.
				/// </summary>
				/// <returns>Returns true if the minimize box is visible.</returns>
				bool									GetMinimizedBox();
				/// <summary>
				/// Make the minimize box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the minimize box visible.</param>
				void									SetMinimizedBox(bool visible);
				/// <summary>
				/// Test is the border visible.
				/// </summary>
				/// <returns>Returns true if the border is visible.</returns>
				bool									GetBorder();
				/// <summary>
				/// Make the border visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the border visible.</param>
				void									SetBorder(bool visible);
				/// <summary>
				/// Test is the size box visible.
				/// </summary>
				/// <returns>Returns true if the size box is visible.</returns>
				bool									GetSizeBox();
				/// <summary>
				/// Make the size box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the size box visible.</param>
				void									SetSizeBox(bool visible);
				/// <summary>
				/// Test is the icon visible.
				/// </summary>
				/// <returns>Returns true if the icon is visible.</returns>
				bool									GetIconVisible();
				/// <summary>
				/// Make the icon visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the icon visible.</param>
				void									SetIconVisible(bool visible);
				/// <summary>
				/// Get the icon which replaces the default one.
				/// </summary>
				/// <returns>Returns the icon that replaces the default one.</returns>
				Ptr<GuiImageData>						GetIcon();
				/// <summary>
				/// Set the icon that replaces the default one.
				/// </summary>
				/// <param name="value">The icon that replaces the default one.</param>
				void									SetIcon(Ptr<GuiImageData> value);
				/// <summary>
				/// Test is the title bar visible.
				/// </summary>
				/// <returns>Returns true if the title bar is visible.</returns>
				bool									GetTitleBar();
				/// <summary>
				/// Make the title bar visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the title bar visible.</param>
				void									SetTitleBar(bool visible);
				/// <summary>
				/// Show a model window, get a callback when the window is closed.
				/// </summary>
				/// <param name="owner">The window to disable as a parent window.</param>
				/// <param name="callback">The callback to call after the window is closed.</param>
				void									ShowModal(GuiWindow* owner, const Func<void()>& callback);
				/// <summary>
				/// Show a model window, get a callback when the window is closed, and then delete itself.
				/// </summary>
				/// <param name="owner">The window to disable as a parent window.</param>
				/// <param name="callback">The callback to call after the window is closed.</param>
				void									ShowModalAndDelete(GuiWindow* owner, const Func<void()>& callback);
				/// <summary>
				/// Show a model window as an async operation, which ends when the window is closed.
				/// </summary>
				/// <returns>Returns true if the size box is visible.</returns>
				/// <param name="owner">The window to disable as a parent window.</param>
				Ptr<reflection::description::IAsync>	ShowModalAsync(GuiWindow* owner);
			};
			
			/// <summary>
			/// Represents a popup window. When the mouse click on other window or the desktop, the popup window will be closed automatically.
			/// </summary>
			class GuiPopup : public GuiWindow, public Description<GuiPopup>
			{
			protected:
				union PopupInfo
				{
					struct _s1 { NativePoint location; INativeScreen* screen; };
					struct _s2 { GuiControl* control; INativeWindow* controlWindow; Rect bounds; bool preferredTopBottomSide; };
					struct _s3 { GuiControl* control; INativeWindow* controlWindow; Point location; };
					struct _s4 { GuiControl* control; INativeWindow* controlWindow; bool preferredTopBottomSide; };

					_s1 _1;
					_s2 _2;
					_s3 _3;
					_s4 _4;

					PopupInfo() {}
				};
			protected:
				vint									popupType = -1;
				PopupInfo								popupInfo;

				void									UpdateClientSizeAfterRendering(Size clientSize)override;
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
				void									PopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									PopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);

				static bool								IsClippedByScreen(NativeSize size, NativePoint location, INativeScreen* screen);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, NativePoint location, INativeScreen* screen);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, GuiControl* control, INativeWindow* controlWindow, Rect bounds, bool preferredTopBottomSide);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, GuiControl* control, INativeWindow* controlWindow, Point location);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, GuiControl* control, INativeWindow* controlWindow, bool preferredTopBottomSide);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, vint popupType, const PopupInfo& popupInfo);

				void									ShowPopupInternal();
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiPopup(theme::ThemeName themeName);
				~GuiPopup();

				/// <summary>Test will the whole popup window be in the screen if the popup's left-top position is set to a specified value.</summary>
				/// <returns>Returns true if the whole popup window will be in the screen.</returns>
				/// <param name="location">The specified left-top position.</param>
				bool									IsClippedByScreen(Point location);
				/// <summary>Show the popup window with the left-top position set to a specified value. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="location">The specified left-top position.</param>
				/// <param name="screen">The expected screen. If you don't want to specify any screen, don't set this parameter.</param>
				void									ShowPopup(NativePoint location, INativeScreen* screen = 0);
				/// <summary>Show the popup window with the bounds set to a specified control-relative value. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="control">The control that owns this popup temporary. And the location is relative to this control.</param>
				/// <param name="bounds">The specified bounds.</param>
				/// <param name="preferredTopBottomSide">Set to true if the popup window is expected to be opened at the top or bottom side of that bounds.</param>
				void									ShowPopup(GuiControl* control, Rect bounds, bool preferredTopBottomSide);
				/// <summary>Show the popup window with the left-top position set to a specified control-relative value. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="control">The control that owns this popup temporary. And the location is relative to this control.</param>
				/// <param name="location">The specified left-top position.</param>
				void									ShowPopup(GuiControl* control, Point location);
				/// <summary>Show the popup window aligned with a specified control. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="control">The control that owns this popup temporary.</param>
				/// <param name="preferredTopBottomSide">Set to true if the popup window is expected to be opened at the top or bottom side of that control.</param>
				void									ShowPopup(GuiControl* control, bool preferredTopBottomSide);
			};

			/// <summary>Represents a tooltip window.</summary>
			class GuiTooltip : public GuiPopup, private INativeControllerListener, public Description<GuiTooltip>
			{
			protected:
				GuiControl*								temporaryContentControl;

				void									GlobalTimer()override;
				void									TooltipOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									TooltipClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTooltip(theme::ThemeName themeName);
				~GuiTooltip();

				/// <summary>Get the preferred content width.</summary>
				/// <returns>The preferred content width.</returns>
				vint									GetPreferredContentWidth();
				/// <summary>Set the preferred content width.</summary>
				/// <param name="value">The preferred content width.</param>
				void									SetPreferredContentWidth(vint value);

				/// <summary>Get the temporary content control.</summary>
				/// <returns>The temporary content control.</returns>
				GuiControl*								GetTemporaryContentControl();
				/// <summary>Set the temporary content control.</summary>
				/// <param name="control">The temporary content control.</param>
				void									SetTemporaryContentControl(GuiControl* control);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION
#define VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Application
***********************************************************************/

			/// <summary>Represents an GacUI application, for window management and asynchronized operation supporting. Use [M:vl.presentation.controls.GetApplication] to access the instance of this class.</summary>
			class GuiApplication : public Object, private INativeControllerListener, public Description<GuiApplication>
			{
				friend void GuiApplicationInitialize();
				friend class GuiWindow;
				friend class GuiPopup;
				friend class Ptr<GuiApplication>;
			private:
				void											InvokeClipboardNotify(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);
				void											LeftButtonDown(NativePoint position)override;
				void											LeftButtonUp(NativePoint position)override;
				void											RightButtonDown(NativePoint position)override;
				void											RightButtonUp(NativePoint position)override;
				void											ClipboardUpdated()override;
			protected:
				Locale											locale;
				GuiWindow*										mainWindow = nullptr;
				GuiWindow*										sharedTooltipOwnerWindow = nullptr;
				GuiControl*										sharedTooltipOwner = nullptr;
				GuiTooltip*										sharedTooltipControl = nullptr;
				bool											sharedTooltipHovering = false;
				bool											sharedTooltipClosing = false;
				collections::List<GuiWindow*>					windows;
				collections::SortedList<GuiPopup*>				openingPopups;

				GuiApplication();
				~GuiApplication();

				INativeWindow*									GetThreadContextNativeWindow(GuiControlHost* controlHost);
				void											RegisterWindow(GuiWindow* window);
				void											UnregisterWindow(GuiWindow* window);
				void											RegisterPopupOpened(GuiPopup* popup);
				void											RegisterPopupClosed(GuiPopup* popup);
				void											OnMouseDown(NativePoint location);
				void											TooltipMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											TooltipMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Locale changed event.</summary>
				Event<void()>									LocaleChanged;

				/// <summary>Returns the selected locale for all windows.</summary>
				/// <returns>The selected locale.</returns>
				Locale											GetLocale();
				/// <summary>Set the locale for all windows.</summary>
				/// <param name="value">The selected locale.</param>
				void											SetLocale(Locale value);

				/// <summary>Run a <see cref="GuiWindow"/> as the main window and show it. This function can only be called once in the entry point. When the main window is closed or hiden, the Run function will finished, and the application should prepare for finalization.</summary>
				/// <param name="_mainWindow">The main window.</param>
				void											Run(GuiWindow* _mainWindow);
				/// <summary>Get the main window.</summary>
				/// <returns>The main window.</returns>
				GuiWindow*										GetMainWindow();
				/// <summary>Get all created <see cref="GuiWindow"/> instances. This contains normal windows, popup windows, menus, or other types of windows that inherits from <see cref="GuiWindow"/>.</summary>
				/// <returns>All created <see cref="GuiWindow"/> instances.</returns>
				const collections::List<GuiWindow*>&			GetWindows();
				/// <summary>Get the <see cref="GuiWindow"/> instance that the mouse cursor are directly in.</summary>
				/// <returns>The <see cref="GuiWindow"/> instance that the mouse cursor are directly in.</returns>
				/// <param name="location">The mouse cursor.</param>
				GuiWindow*										GetWindow(NativePoint location);
				/// <summary>Show a tooltip.</summary>
				/// <param name="owner">The control that owns this tooltip temporary.</param>
				/// <param name="tooltip">The control as the tooltip content. This control is not owned by the tooltip. User should manually release this control if no longer needed (usually when the application exit).</param>
				/// <param name="preferredContentWidth">The preferred content width for this tooltip.</param>
				/// <param name="location">The relative location to specify the left-top position of the tooltip.</param>
				void											ShowTooltip(GuiControl* owner, GuiControl* tooltip, vint preferredContentWidth, Point location);
				/// <summary>Close the tooltip</summary>
				void											CloseTooltip();
				/// <summary>Get the tooltip owner. When the tooltip closed, it returns null.</summary>
				/// <returns>The tooltip owner.</returns>
				GuiControl*										GetTooltipOwner();
				/// <summary>Get the file path of the current executable.</summary>
				/// <returns>The file path of the current executable.</returns>
				WString											GetExecutablePath();
				/// <summary>Get the folder of the current executable.</summary>
				/// <returns>The folder of the current executable.</returns>
				WString											GetExecutableFolder();

				/// <summary>Test is the current thread the main thread for GUI.</summary>
				/// <returns>Returns true if the current thread is the main thread for GUI.</returns>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				bool											IsInMainThread(GuiControlHost* controlHost);
				/// <summary>Invoke a specified function asynchronously.</summary>
				/// <param name="proc">The specified function.</param>
				void											InvokeAsync(const Func<void()>& proc);
				/// <summary>Invoke a specified function in the main thread.</summary>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				/// <param name="proc">The specified function.</param>
				void											InvokeInMainThread(GuiControlHost* controlHost, const Func<void()>& proc);
				/// <summary>Invoke a specified function in the main thread and wait for the function to complete or timeout.</summary>
				/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				/// <param name="proc">The specified function.</param>
				/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
				bool											InvokeInMainThreadAndWait(GuiControlHost* controlHost, const Func<void()>& proc, vint milliseconds=-1);
				/// <summary>Delay execute a specified function with an specified argument asynchronisly.</summary>
				/// <returns>The Delay execution controller for this task.</returns>
				/// <param name="proc">The specified function.</param>
				/// <param name="milliseconds">Time to delay.</param>
				Ptr<INativeDelay>								DelayExecute(const Func<void()>& proc, vint milliseconds);
				/// <summary>Delay execute a specified function with an specified argument in the main thread.</summary>
				/// <returns>The Delay execution controller for this task.</returns>
				/// <param name="proc">The specified function.</param>
				/// <param name="milliseconds">Time to delay.</param>
				Ptr<INativeDelay>								DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds);
				/// <summary>Run the specified function in the main thread. If the caller is in the main thread, then run the specified function directly.</summary>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				/// <param name="proc">The specified function.</param>
				void											RunGuiTask(GuiControlHost* controlHost, const Func<void()>& proc);

				template<typename T>
				T RunGuiValue(GuiControlHost* controlHost, const Func<T()>& proc)
				{
					T result;
					RunGuiTask(controlHost, [&result, &proc]()
					{
						result=proc();
					});
					return result;
				}

				template<typename T>
				void InvokeLambdaInMainThread(GuiControlHost* controlHost, const T& proc)
				{
					InvokeInMainThread(controlHost, Func<void()>(proc));
				}
				
				template<typename T>
				bool InvokeLambdaInMainThreadAndWait(GuiControlHost* controlHost, const T& proc, vint milliseconds=-1)
				{
					return InvokeInMainThreadAndWait(controlHost, Func<void()>(proc), milliseconds);
				}
			};

/***********************************************************************
Plugin
***********************************************************************/

			/// <summary>Represents a plugin for the gui.</summary>
			class IGuiPlugin : public IDescriptable, public Description<IGuiPlugin>
			{
			public:
				/// <summary>Get the name of this plugin.</summary>
				/// <returns>Returns the name of the plugin.</returns>
				virtual WString									GetName() = 0;
				/// <summary>Get all dependencies of this plugin.</summary>
				/// <param name="dependencies">To receive all dependencies.</param>
				virtual void									GetDependencies(collections::List<WString>& dependencies) = 0;
				/// <summary>Called when the plugin manager want to load this plugin.</summary>
				virtual void									Load()=0;
				/// <summary>Called when the plugin manager want to unload this plugin.</summary>
				virtual void									Unload()=0;
			};

			/// <summary>Represents a plugin manager.</summary>
			class IGuiPluginManager : public IDescriptable, public Description<IGuiPluginManager>
			{
			public:
				/// <summary>Add a plugin before [F:vl.presentation.controls.IGuiPluginManager.Load] is called.</summary>
				/// <param name="plugin">The plugin.</param>
				virtual void									AddPlugin(Ptr<IGuiPlugin> plugin)=0;
				/// <summary>Load all plugins, and check if dependencies of all plugins are ready.</summary>
				virtual void									Load()=0;
				/// <summary>Unload all plugins.</summary>
				virtual void									Unload()=0;
				/// <returns>Returns true if all plugins are loaded.</returns>
				virtual bool									IsLoaded()=0;
			};

/***********************************************************************
Helper Functions
***********************************************************************/

			/// <summary>Get the global <see cref="GuiApplication"/> object.</summary>
			/// <returns>The global <see cref="GuiApplication"/> object.</returns>
			extern GuiApplication*								GetApplication();

			/// <summary>Get the global <see cref="IGuiPluginManager"/> object.</summary>
			/// <returns>The global <see cref="GuiApplication"/> object.</returns>
			extern IGuiPluginManager*							GetPluginManager();

			/// <summary>Destroy the global <see cref="IGuiPluginManager"/> object.</summary>
			extern void											DestroyPluginManager();
		}
	}
}

extern void GuiApplicationMain();

#define GUI_VALUE(x) vl::presentation::controls::GetApplication()->RunGuiValue(LAMBDA([&](){return (x);}))
#define GUI_RUN(x) vl::presentation::controls::GetApplication()->RunGuiTask([=](){x})

#define GUI_REGISTER_PLUGIN(TYPE)\
	class GuiRegisterPluginClass_##TYPE\
	{\
	public:\
		GuiRegisterPluginClass_##TYPE()\
		{\
			vl::presentation::controls::GetPluginManager()->AddPlugin(new TYPE);\
		}\
	} instance_GuiRegisterPluginClass_##TYPE;\

#define GUI_PLUGIN_NAME(NAME)\
	vl::WString GetName()override { return L ## #NAME; }\
	void GetDependencies(vl::collections::List<WString>& dependencies)override\

#define GUI_PLUGIN_DEPEND(NAME) dependencies.Add(L ## #NAME)

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUICOMMONTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICOMMONTEMPLATES
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICOMMONTEMPLATES


namespace vl
{
	namespace presentation
	{
		namespace templates
		{

/***********************************************************************
GuiCommonDatePickerLook
***********************************************************************/

			class GuiCommonDatePickerLook : public GuiTemplate, public Description<GuiCommonDatePickerLook>
			{
			protected:
				static const vint									DaysOfWeek = 7;
				static const vint									DayRows = 6;
				static const vint									DayRowStart = 2;
				static const vint									YearFirst = 1900;
				static const vint									YearLast = 2099;

				Color												backgroundColor;
				Color												primaryTextColor;
				Color												secondaryTextColor;
				DateTime											currentDate;
				Locale												dateLocale;
				FontProperties										font;

				TemplateProperty<GuiSelectableButtonTemplate>		dateButtonTemplate;
				TemplateProperty<GuiTextListTemplate>				dateTextListTemplate;
				TemplateProperty<GuiComboBoxTemplate>				dateComboBoxTemplate;

				controls::IDatePickerCommandExecutor*				commands = nullptr;
				bool												preventComboEvent = false;
				bool												preventButtonEvent = false;

				controls::GuiComboBoxListControl*					comboYear;
				controls::GuiTextList*								listYears;
				controls::GuiComboBoxListControl*					comboMonth;
				controls::GuiTextList*								listMonths;
				collections::Array<elements::GuiSolidLabelElement*>	labelDaysOfWeek;
				collections::Array<controls::GuiSelectableButton*>	buttonDays;
				collections::Array<elements::GuiSolidLabelElement*>	labelDays;
				collections::Array<DateTime>						dateDays;

				void												SetDay(const DateTime& day, vint& index, vint monthOffset);
				void												DisplayMonth(vint year, vint month);
				void												SelectDay(vint day);

				void												comboYearMonth_SelectedIndexChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												buttonDay_SelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

			public:
				GuiCommonDatePickerLook(Color _backgroundColor, Color _primaryTextColor, Color _secondaryTextColor);
				~GuiCommonDatePickerLook();

				compositions::GuiNotifyEvent						DateChanged;

				controls::IDatePickerCommandExecutor*				GetCommands();
				void												SetCommands(controls::IDatePickerCommandExecutor* value);
				TemplateProperty<GuiSelectableButtonTemplate>		GetDateButtonTemplate();
				void												SetDateButtonTemplate(const TemplateProperty<GuiSelectableButtonTemplate>& value);
				TemplateProperty<GuiTextListTemplate>				GetDateTextListTemplate();
				void												SetDateTextListTemplate(const TemplateProperty<GuiTextListTemplate>& value);
				TemplateProperty<GuiComboBoxTemplate>				GetDateComboBoxTemplate();
				void												SetDateComboBoxTemplate(const TemplateProperty<GuiComboBoxTemplate>& value);

				const Locale&										GetDateLocale();
				void												SetDateLocale(const Locale& value);
				const DateTime&										GetDate();
				void												SetDate(const DateTime& value);
				const FontProperties&								GetFont();
				void												SetFont(const FontProperties& value);
			};

/***********************************************************************
GuiCommonScrollViewLook
***********************************************************************/

			class GuiCommonScrollViewLook : public GuiTemplate, public Description<GuiCommonScrollViewLook>
			{
			protected:
				controls::GuiScroll*								horizontalScroll = nullptr;
				controls::GuiScroll*								verticalScroll = nullptr;
				compositions::GuiTableComposition*					tableComposition = nullptr;
				compositions::GuiCellComposition*					containerCellComposition = nullptr;
				compositions::GuiBoundsComposition*					containerComposition = nullptr;

				vint												defaultScrollSize = 12;
				TemplateProperty<GuiScrollTemplate>					hScrollTemplate;
				TemplateProperty<GuiScrollTemplate>					vScrollTemplate;

				void												UpdateTable();
				void												hScroll_OnVisibleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												vScroll_OnVisibleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiCommonScrollViewLook(vint _defaultScrollSize);
				~GuiCommonScrollViewLook();

				controls::GuiScroll*								GetHScroll();
				controls::GuiScroll*								GetVScroll();
				compositions::GuiGraphicsComposition*				GetContainerComposition();

				TemplateProperty<GuiScrollTemplate>					GetHScrollTemplate();
				void												SetHScrollTemplate(const TemplateProperty<GuiScrollTemplate>& value);
				TemplateProperty<GuiScrollTemplate>					GetVScrollTemplate();
				void												SetVScrollTemplate(const TemplateProperty<GuiScrollTemplate>& value);
			};

/***********************************************************************
GuiCommonScrollBehavior
***********************************************************************/

			class GuiCommonScrollBehavior : public controls::GuiComponent, public Description<GuiCommonScrollBehavior>
			{
			protected:
				bool												dragging = false;
				Point												location = { 0,0 };
				GuiScrollTemplate*									scrollTemplate = nullptr;

				void												SetScroll(vint totalPixels, vint newOffset);
				void												AttachHandle(compositions::GuiGraphicsComposition* handle);
			public:
				GuiCommonScrollBehavior();
				~GuiCommonScrollBehavior();

				void												AttachScrollTemplate(GuiScrollTemplate* value);
				void												AttachDecreaseButton(controls::GuiButton* button);
				void												AttachIncreaseButton(controls::GuiButton* button);
				void												AttachHorizontalScrollHandle(compositions::GuiPartialViewComposition* partialView);
				void												AttachVerticalScrollHandle(compositions::GuiPartialViewComposition* partialView);
				void												AttachHorizontalTrackerHandle(compositions::GuiPartialViewComposition* partialView);
				void												AttachVerticalTrackerHandle(compositions::GuiPartialViewComposition* partialView);

				vint												GetHorizontalTrackerHandlerPosition(compositions::GuiBoundsComposition* handle, vint totalSize, vint pageSize, vint position);
				vint												GetVerticalTrackerHandlerPosition(compositions::GuiBoundsComposition* handle, vint totalSize, vint pageSize, vint position);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUITHEMESTYLEFACTORY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY
#define VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY


namespace vl
{
	namespace presentation
	{
		namespace theme
		{
#define GUI_CONTROL_TEMPLATE_TYPES(F) \
			F(WindowTemplate,				Window)						\
			F(ControlTemplate,				CustomControl)				\
			F(WindowTemplate,				Tooltip)					\
			F(LabelTemplate,				Label)						\
			F(LabelTemplate,				ShortcutKey)				\
			F(ScrollViewTemplate,			ScrollView)					\
			F(ControlTemplate,				GroupBox)					\
			F(TabTemplate,					Tab)						\
			F(ComboBoxTemplate,				ComboBox)					\
			F(MultilineTextBoxTemplate,		MultilineTextBox)			\
			F(SinglelineTextBoxTemplate,	SinglelineTextBox)			\
			F(DocumentViewerTemplate,		DocumentViewer)				\
			F(DocumentLabelTemplate,		DocumentLabel)				\
			F(DocumentLabelTemplate,		DocumentTextBox)			\
			F(ListViewTemplate,				ListView)					\
			F(TreeViewTemplate,				TreeView)					\
			F(TextListTemplate,				TextList)					\
			F(SelectableButtonTemplate,		ListItemBackground)			\
			F(SelectableButtonTemplate,		TreeItemExpander)			\
			F(SelectableButtonTemplate,		CheckTextListItem)			\
			F(SelectableButtonTemplate,		RadioTextListItem)			\
			F(MenuTemplate,					Menu)						\
			F(ControlTemplate,				MenuBar)					\
			F(ControlTemplate,				MenuSplitter)				\
			F(ToolstripButtonTemplate,		MenuBarButton)				\
			F(ToolstripButtonTemplate,		MenuItemButton)				\
			F(ControlTemplate,				ToolstripToolBar)			\
			F(ToolstripButtonTemplate,		ToolstripButton)			\
			F(ToolstripButtonTemplate,		ToolstripDropdownButton)	\
			F(ToolstripButtonTemplate,		ToolstripSplitButton)		\
			F(ControlTemplate,				ToolstripSplitter)			\
			F(RibbonTabTemplate,			RibbonTab)					\
			F(RibbonGroupTemplate,			RibbonGroup)				\
			F(RibbonIconLabelTemplate,		RibbonIconLabel)			\
			F(RibbonIconLabelTemplate,		RibbonSmallIconLabel)		\
			F(RibbonButtonsTemplate,		RibbonButtons)				\
			F(RibbonToolstripsTemplate,		RibbonToolstrips)			\
			F(RibbonGalleryTemplate,		RibbonGallery)				\
			F(RibbonToolstripMenuTemplate,	RibbonToolstripMenu)		\
			F(RibbonGalleryListTemplate,	RibbonGalleryList)			\
			F(TextListTemplate,				RibbonGalleryItemList)		\
			F(ToolstripButtonTemplate,		RibbonSmallButton)			\
			F(ToolstripButtonTemplate,		RibbonSmallDropdownButton)	\
			F(ToolstripButtonTemplate,		RibbonSmallSplitButton)		\
			F(ToolstripButtonTemplate,		RibbonLargeButton)			\
			F(ToolstripButtonTemplate,		RibbonLargeDropdownButton)	\
			F(ToolstripButtonTemplate,		RibbonLargeSplitButton)		\
			F(ControlTemplate,				RibbonSplitter)				\
			F(ControlTemplate,				RibbonToolstripHeader)		\
			F(ButtonTemplate,				Button)						\
			F(SelectableButtonTemplate,		CheckBox)					\
			F(SelectableButtonTemplate,		RadioButton)				\
			F(DatePickerTemplate,			DatePicker)					\
			F(DateComboBoxTemplate,			DateComboBox)				\
			F(ScrollTemplate,				HScroll)					\
			F(ScrollTemplate,				VScroll)					\
			F(ScrollTemplate,				HTracker)					\
			F(ScrollTemplate,				VTracker)					\
			F(ScrollTemplate,				ProgressBar)				\

			enum class ThemeName
			{
				Unknown,
#define GUI_DEFINE_THEME_NAME(TEMPLATE, CONTROL) CONTROL,
				GUI_CONTROL_TEMPLATE_TYPES(GUI_DEFINE_THEME_NAME)
#undef GUI_DEFINE_THEME_NAME
			};

			/// <summary>Theme interface. A theme creates appropriate style controllers or style providers for default controls. Call [M:vl.presentation.theme.GetCurrentTheme] to access this interface.</summary>
			class ITheme : public virtual IDescriptable, public Description<ITheme>
			{
			public:
				virtual TemplateProperty<templates::GuiControlTemplate>				CreateStyle(ThemeName themeName) = 0;
			};

			class Theme;

			/// <summary>Partial control template collections. [F:vl.presentation.theme.GetCurrentTheme] will returns an object, which walks through multiple registered [T:vl.presentation.theme.ThemeTemplates] to create a correct template object for a control.</summary>
			class ThemeTemplates : public controls::GuiInstanceRootObject, public AggregatableDescription<ThemeTemplates>
			{
				friend class Theme;
			protected:
				ThemeTemplates*					previous = nullptr;
				ThemeTemplates*					next = nullptr;

				controls::GuiControlHost*		GetControlHostForInstance()override;
			public:
				~ThemeTemplates();

				WString							Name;

#define GUI_DEFINE_ITEM_PROPERTY(TEMPLATE, CONTROL) TemplateProperty<templates::Gui##TEMPLATE> CONTROL;
				GUI_CONTROL_TEMPLATE_TYPES(GUI_DEFINE_ITEM_PROPERTY)
#undef GUI_DEFINE_ITEM_PROPERTY
			};

			/// <summary>Get the current theme style factory object. Call <see cref="RegisterTheme"/> or <see cref="UnregisterTheme"/> to change the default theme.</summary>
			/// <returns>The current theme style factory object.</returns>
			extern ITheme*						GetCurrentTheme();
			extern void							InitializeTheme();
			extern void							FinalizeTheme();
			/// <summary>Register a control template collection object.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="theme">The control template collection object.</param>
			extern bool							RegisterTheme(Ptr<ThemeTemplates> theme);
			/// <summary>Unregister a control template collection object.</summary>
			/// <returns>The registered object. Returns null if it does not exist.</returns>
			/// <param name="name">The name of the theme.</param>
			extern Ptr<ThemeTemplates>			UnregisterTheme(const WString& name);
		}
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIRESOURCEMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIRESOURCEMANAGER
#define VCZH_PRESENTATION_REFLECTION_GUIRESOURCEMANAGER


namespace vl
{
	namespace presentation
	{

/***********************************************************************
IGuiResourceManager
***********************************************************************/

		class GuiResourceClassNameRecord : public Object, public Description<GuiResourceClassNameRecord>
		{
		public:
			collections::List<WString>								classNames;
			collections::Dictionary<WString, Ptr<GuiResourceItem>>	classResources;
		};

		class IGuiResourceManager : public IDescriptable, public Description<IGuiResourceManager>
		{
		public:
			virtual void								SetResource(Ptr<GuiResource> resource, GuiResourceError::List& errors, GuiResourceUsage usage = GuiResourceUsage::DataOnly) = 0;
			virtual Ptr<GuiResource>					GetResource(const WString& name) = 0;
			virtual Ptr<GuiResource>					GetResourceFromClassName(const WString& classFullName) = 0;
			virtual void								UnloadResource(const WString& name) = 0;
			virtual void								LoadResourceOrPending(stream::IStream& stream, GuiResourceError::List& errors, GuiResourceUsage usage = GuiResourceUsage::DataOnly) = 0;
			virtual void								LoadResourceOrPending(stream::IStream& stream, GuiResourceUsage usage = GuiResourceUsage::DataOnly) = 0;
			virtual void								GetPendingResourceNames(collections::List<WString>& names) = 0;
		};

		extern IGuiResourceManager*						GetResourceManager();
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSTABLECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSTABLECOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSTABLECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Table Compositions
***********************************************************************/

			/// <summary>
			/// Represnets a sizing configuration for a row or a column.
			/// </summary>
			struct GuiCellOption
			{
				/// <summary>Sizing algorithm</summary>
				enum ComposeType
				{
					/// <summary>Set the size to an absolute value.</summary>
					Absolute,
					/// <summary>Set the size to a percentage number of the whole table.</summary>
					Percentage,
					/// <summary>Set the size to the minimum size of the cell element.</summary>
					MinSize,
				};

				/// <summary>Sizing algorithm</summary>
				ComposeType		composeType;
				/// <summary>The absolute size when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Absolute.</summary>
				vint			absolute;
				/// <summary>The percentage number when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Percentage.</summary>
				double			percentage;

				GuiCellOption()
					:composeType(Absolute)
					,absolute(20)
					,percentage(0)
				{
				}

				bool operator==(const GuiCellOption& value){return false;}
				bool operator!=(const GuiCellOption& value){return true;}

				/// <summary>Creates an absolute sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The absolute size.</param>
				static GuiCellOption AbsoluteOption(vint value)
				{
					GuiCellOption option;
					option.composeType=Absolute;
					option.absolute=value;
					return option;
				}
				
				/// <summary>Creates an percantage sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The percentage number.</param>
				static GuiCellOption PercentageOption(double value)
				{
					GuiCellOption option;
					option.composeType=Percentage;
					option.percentage=value;
					return option;
				}
				
				/// <summary>Creates an minimum sizing option</summary>
				/// <returns>The created option.</returns>
				static GuiCellOption MinSizeOption()
				{
					GuiCellOption option;
					option.composeType=MinSize;
					return option;
				}
			};

			/// <summary>
			/// Represents a table composition.
			/// </summary>
			class GuiTableComposition : public GuiBoundsComposition, public Description<GuiTableComposition>
			{
				friend class GuiCellComposition;
				friend class GuiTableSplitterCompositionBase;
				friend class GuiRowSplitterComposition;
				friend class GuiColumnSplitterComposition;
			protected:
				vint										rows;
				vint										columns;
				vint										cellPadding;
				bool										borderVisible;
				vint										rowExtending;
				vint										columnExtending;
				collections::Array<GuiCellOption>			rowOptions;
				collections::Array<GuiCellOption>			columnOptions;
				collections::Array<GuiCellComposition*>		cellCompositions;
				
				collections::Array<Rect>					cellBounds;
				collections::Array<vint>					rowOffsets;
				collections::Array<vint>					columnOffsets;
				collections::Array<vint>					rowSizes;
				collections::Array<vint>					columnSizes;

				Size										tableContentMinSize;

				vint								GetSiteIndex(vint _rows, vint _columns, vint _row, vint _column);
				void								SetSitedCell(vint _row, vint _column, GuiCellComposition* cell);

				void								UpdateCellBoundsInternal(
														collections::Array<vint>& dimSizes,
														vint& dimSize, 
														vint& dimSizeWithPercentage,
														collections::Array<GuiCellOption>& dimOptions,
														vint GuiTableComposition::* dim1,
														vint GuiTableComposition::* dim2,
														vint (*getSize)(Size),
														vint (*getLocation)(GuiCellComposition*),
														vint (*getSpan)(GuiCellComposition*),
														vint (*getRow)(vint, vint),
														vint (*getCol)(vint, vint),
														vint maxPass
														);
				void								UpdateCellBoundsPercentages(
														collections::Array<vint>& dimSizes,
														vint dimSize,
														vint maxDimSize,
														collections::Array<GuiCellOption>& dimOptions
														);
				vint									UpdateCellBoundsOffsets(
														collections::Array<vint>& offsets,
														collections::Array<vint>& sizes,
														vint max
														);
				
				void								OnRenderContextChanged()override;
			public:
				GuiTableComposition();
				~GuiTableComposition();

				/// <summary>Event that will be raised with row numbers, column numbers or options are changed.</summary>
				compositions::GuiNotifyEvent		ConfigChanged;

				/// <summary>Get the number of rows.</summary>
				/// <returns>The number of rows.</returns>
				vint								GetRows();
				/// <summary>Get the number of columns.</summary>
				/// <returns>The number of columns.</returns>
				vint								GetColumns();
				/// <summary>Change the number of rows and columns.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_rows">The number of rows.</param>
				/// <param name="_columns">The number of columns.</param>
				bool								SetRowsAndColumns(vint _rows, vint _columns);
				/// <summary>Get the cell composition that covers the specified cell location.</summary>
				/// <returns>The cell composition that covers the specified cell location.</returns>
				/// <param name="_row">The number of rows.</param>
				/// <param name="_column">The number of columns.</param>
				GuiCellComposition*					GetSitedCell(vint _row, vint _column);

				/// <summary>Get the sizing option of the specified row.</summary>
				/// <returns>The sizing option of the specified row.</returns>
				/// <param name="_row">The specified row number.</param>
				GuiCellOption						GetRowOption(vint _row);
				/// <summary>Set the sizing option of the specified row.</summary>
				/// <param name="_row">The specified row number.</param>
				/// <param name="option">The sizing option of the specified row.</param>
				void								SetRowOption(vint _row, GuiCellOption option);
				/// <summary>Get the sizing option of the specified column.</summary>
				/// <returns>The sizing option of the specified column.</returns>
				/// <param name="_column">The specified column number.</param>
				GuiCellOption						GetColumnOption(vint _column);
				/// <summary>Set the sizing option of the specified column.</summary>
				/// <param name="_column">The specified column number.</param>
				/// <param name="option">The sizing option of the specified column.</param>
				void								SetColumnOption(vint _column, GuiCellOption option);

				/// <summary>Get the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <returns>The cell padding.</returns>
				vint								GetCellPadding();
				/// <summary>Set the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <param name="value">The cell padding.</param>
				void								SetCellPadding(vint value);
				/// <summary>Get the border visibility.</summary>
				/// <returns>Returns true means the border thickness equals to the cell padding, otherwise zero.</returns>
				bool								GetBorderVisible();
				/// <summary>Set the border visibility.</summary>
				/// <param name="value">Set to true to let the border thickness equal to the cell padding, otherwise zero.</param>
				void								SetBorderVisible(bool value);
				/// <summary>Get the cell area in the space of the table's parent composition's client area.</summary>
				/// <returns>The cell area.</returns>
				Rect								GetCellArea();
				/// <summary>Update the sizing of the table and cells after all rows' and columns' sizing options are prepared.</summary>
				void								UpdateCellBounds();
				
				void								ForceCalculateSizeImmediately()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
			};

			/// <summary>
			/// Represents a cell composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiCellComposition : public GuiGraphicsSite, public Description<GuiCellComposition>
			{
				friend class GuiTableComposition;
			protected:
				vint								row;
				vint								rowSpan;
				vint								column;
				vint								columnSpan;
				GuiTableComposition*				tableParent;
				Size								lastPreferredSize;
				
				void								ClearSitedCells(GuiTableComposition* table);
				void								SetSitedCells(GuiTableComposition* table);
				void								ResetSiteInternal();
				bool								SetSiteInternal(vint _row, vint _column, vint _rowSpan, vint _columnSpan);
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnTableRowsAndColumnsChanged();
			public:
				GuiCellComposition();
				~GuiCellComposition();

				/// <summary>Get the owner table composition.</summary>
				/// <returns>The owner table composition.</returns>
				GuiTableComposition*				GetTableParent();

				/// <summary>Get the row number for this cell composition.</summary>
				/// <returns>The row number for this cell composition.</returns>
				vint								GetRow();
				/// <summary>Get the total numbers of acrossed rows for this cell composition.</summary>
				/// <returns>The total numbers of acrossed rows for this cell composition.</returns>
				vint								GetRowSpan();
				/// <summary>Get the column number for this cell composition.</summary>
				/// <returns>The column number for this cell composition.</returns>
				vint								GetColumn();
				/// <summary>Get the total numbers of acrossed columns for this cell composition.</summary>
				/// <returns>The total numbers of acrossed columns for this cell composition.</returns>
				vint								GetColumnSpan();
				/// <summary>Set the position for this cell composition in the table.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_row">The row number for this cell composition.</param>
				/// <param name="_column">The column number for this cell composition.</param>
				/// <param name="_rowSpan">The total numbers of acrossed rows for this cell composition.</param>
				/// <param name="_columnSpan">The total numbers of acrossed columns for this cell composition.</param>
				bool								SetSite(vint _row, vint _column, vint _rowSpan, vint _columnSpan);

				Rect								GetBounds()override;
			};

			class GuiTableSplitterCompositionBase : public GuiGraphicsSite, public Description<GuiTableSplitterCompositionBase>
			{
			protected:
				GuiTableComposition*				tableParent;

				bool								dragging;
				Point								draggingPoint;
				
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnLeftButtonDown(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);
				void								OnLeftButtonUp(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);

				void								OnMouseMoveHelper(
														vint cellsBefore,
														vint GuiTableComposition::* cells,
														collections::Array<vint>& cellSizes,
														vint offset,
														GuiCellOption(GuiTableComposition::*getOption)(vint),
														void(GuiTableComposition::*setOption)(vint, GuiCellOption)
														);

				Rect								GetBoundsHelper(
														vint cellsBefore,
														vint GuiTableComposition::* cells,
														vint(Rect::* dimSize)()const,
														collections::Array<vint>& cellOffsets,
														vint Rect::* dimU1,
														vint Rect::* dimU2,
														vint Rect::* dimV1,
														vint Rect::* dimV2
														);
			public:
				GuiTableSplitterCompositionBase();
				~GuiTableSplitterCompositionBase();

				/// <summary>Get the owner table composition.</summary>
				/// <returns>The owner table composition.</returns>
				GuiTableComposition*				GetTableParent();
			};
			
			/// <summary>
			/// Represents a row splitter composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiRowSplitterComposition : public GuiTableSplitterCompositionBase, public Description<GuiRowSplitterComposition>
			{
			protected:
				vint								rowsToTheTop;
				
				void								OnMouseMove(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);
			public:
				GuiRowSplitterComposition();
				~GuiRowSplitterComposition();

				/// <summary>Get the number of rows that above the splitter.</summary>
				/// <returns>The number of rows that above the splitter.</returns>
				vint								GetRowsToTheTop();
				/// <summary>Set the number of rows that above the splitter.</summary>
				/// <param name="value">The number of rows that above the splitter</param>
				void								SetRowsToTheTop(vint value);

				Rect								GetBounds()override;
			};
			
			/// <summary>
			/// Represents a column splitter composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiColumnSplitterComposition : public GuiTableSplitterCompositionBase, public Description<GuiColumnSplitterComposition>
			{
			protected:
				vint								columnsToTheLeft;
				
				void								OnMouseMove(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);
			public:
				GuiColumnSplitterComposition();
				~GuiColumnSplitterComposition();

				/// <summary>Get the number of columns that before the splitter.</summary>
				/// <returns>The number of columns that before the splitter.</returns>
				vint								GetColumnsToTheLeft();
				/// <summary>Set the number of columns that before the splitter.</summary>
				/// <param name="value">The number of columns that before the splitter</param>
				void								SetColumnsToTheLeft(vint value);

				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSSTACKCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSTACKCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSTACKCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Stack Compositions
***********************************************************************/

			/// <summary>
			/// Represents a stack composition.
			/// </summary>
			class GuiStackComposition : public GuiBoundsComposition, public Description<GuiStackComposition>
			{
				friend class GuiStackItemComposition;

				typedef collections::List<GuiStackItemComposition*>				ItemCompositionList;
			public:
				/// <summary>Stack item layout direction.</summary>
				enum Direction
				{
					/// <summary>Stack items is layouted from left to right.</summary>
					Horizontal,
					/// <summary>Stack items is layouted from top to bottom.</summary>
					Vertical,
					/// <summary>Stack items is layouted from right to left.</summary>
					ReversedHorizontal,
					/// <summary>Stack items is layouted from bottom to top.</summary>
					ReversedVertical,
				};
			protected:
				Direction							direction = Horizontal;
				ItemCompositionList					stackItems;
				GuiStackItemComposition*			ensuringVisibleStackItem = nullptr;
				
				vint								padding = 0;
				vint								adjustment = 0;
				Margin								extraMargin;

				collections::Array<Rect>			stackItemBounds;
				Size								stackItemTotalSize;
				Rect								previousBounds;

				void								UpdateStackItemBounds();
				void								EnsureStackItemVisible();
				void								OnBoundsChanged(GuiGraphicsComposition* sender, GuiEventArgs& arguments);
				void								OnChildInserted(GuiGraphicsComposition* child)override;
				void								OnChildRemoved(GuiGraphicsComposition* child)override;
			public:
				GuiStackComposition();
				~GuiStackComposition();

				/// <summary>Get all stack items inside the stack composition.</summary>
				/// <returns>All stack items inside the stack composition.</returns>
				const ItemCompositionList&			GetStackItems();
				/// <summary>Insert a stack item at a specified position.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The position.</param>
				/// <param name="item">The statck item to insert.</param>
				bool								InsertStackItem(vint index, GuiStackItemComposition* item);
				
				/// <summary>Get the stack item layout direction.</summary>
				/// <returns>The stack item layout direction.</returns>
				Direction							GetDirection();
				/// <summary>Set the stack item layout direction.</summary>
				/// <param name="value">The stack item layout direction.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the stack item padding.</summary>
				/// <returns>The stack item padding.</returns>
				vint								GetPadding();
				/// <summary>Set the stack item padding.</summary>
				/// <param name="value">The stack item padding.</param>
				void								SetPadding(vint value);
				
				void								ForceCalculateSizeImmediately()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
				
				/// <summary>Get the extra margin inside the stack composition.</summary>
				/// <returns>The extra margin inside the stack composition.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin inside the stack composition.</summary>
				/// <param name="value">The extra margin inside the stack composition.</param>
				void								SetExtraMargin(Margin value);
				/// <summary>Test is any stack item clipped in the stack direction.</summary>
				/// <returns>Returns true if any stack item is clipped.</returns>
				bool								IsStackItemClipped();
				/// <summary>Make an item visible as complete as possible.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The index of the item.</param>
				bool								EnsureVisible(vint index);
			};
			
			/// <summary>
			/// Represents a stack item composition of a <see cref="GuiStackComposition"/>.
			/// </summary>
			class GuiStackItemComposition : public GuiGraphicsSite, public Description<GuiStackItemComposition>
			{
				friend class GuiStackComposition;
			protected:
				GuiStackComposition*				stackParent;
				Rect								bounds;
				Margin								extraMargin;

				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				Size								GetMinSize();
			public:
				GuiStackItemComposition();
				~GuiStackItemComposition();
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
				/// <summary>Set the expected bounds of a stack item. In most of the cases only the size of the bounds is used.</summary>
				/// <param name="value">The expected bounds of a stack item.</param>
				void								SetBounds(Rect value);
				
				/// <summary>Get the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for deciding the stack item layout.</summary>
				/// <returns>The extra margin for this stack item.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for deciding the stack item layout.</summary>
				/// <param name="value">The extra margin for this stack item.</param>
				void								SetExtraMargin(Margin value);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSFLOWCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSFLOWCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSFLOWCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
/***********************************************************************
Flow Compositions
***********************************************************************/

			/// <summary>
			/// Alignment for a row in a flow layout
			/// </summary>
			enum class FlowAlignment
			{
				/// <summary>Align to the left.</summary>
				Left,
				/// <summary>Align to the center.</summary>
				Center,
				/// <summary>Extend to the entire row.</summary>
				Extend,
			};
			
			/// <summary>
			/// Represents a flow composition.
			/// </summary>
			class GuiFlowComposition : public GuiBoundsComposition, public Description<GuiFlowComposition>
			{
				friend class GuiFlowItemComposition;

				typedef collections::List<GuiFlowItemComposition*>				ItemCompositionList;
			protected:
				Margin								extraMargin;
				vint								rowPadding = 0;
				vint								columnPadding = 0;
				FlowAlignment						alignment = FlowAlignment::Left;
				Ptr<IGuiAxis>						axis;

				ItemCompositionList					flowItems;
				collections::Array<Rect>			flowItemBounds;
				Rect								bounds;
				vint								minHeight = 0;
				bool								needUpdate = false;

				void								UpdateFlowItemBounds(bool forceUpdate);
				void								OnBoundsChanged(GuiGraphicsComposition* sender, GuiEventArgs& arguments);
				void								OnChildInserted(GuiGraphicsComposition* child)override;
				void								OnChildRemoved(GuiGraphicsComposition* child)override;
			public:
				GuiFlowComposition();
				~GuiFlowComposition();
				
				/// <summary>Get all flow items inside the flow composition.</summary>
				/// <returns>All flow items inside the flow composition.</returns>
				const ItemCompositionList&			GetFlowItems();
				/// <summary>Insert a flow item at a specified position.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The position.</param>
				/// <param name="item">The flow item to insert.</param>
				bool								InsertFlowItem(vint index, GuiFlowItemComposition* item);
				
				/// <summary>Get the extra margin inside the flow composition.</summary>
				/// <returns>The extra margin inside the flow composition.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin inside the flow composition.</summary>
				/// <param name="value">The extra margin inside the flow composition.</param>
				void								SetExtraMargin(Margin value);
				
				/// <summary>Get the distance between rows.</summary>
				/// <returns>The distance between rows.</returns>
				vint								GetRowPadding();
				/// <summary>Set the distance between rows.</summary>
				/// <param name="value">The distance between rows.</param>
				void								SetRowPadding(vint value);
				
				/// <summary>Get the distance between columns.</summary>
				/// <returns>The distance between columns.</returns>
				vint								GetColumnPadding();
				/// <summary>Set the distance between columns.</summary>
				/// <param name="value">The distance between columns.</param>
				void								SetColumnPadding(vint value);
				
				/// <summary>Get the axis of the layout.</summary>
				/// <returns>The axis.</returns>
				Ptr<IGuiAxis>						GetAxis();
				/// <summary>Set the axis of the layout.</summary>
				/// <param name="value">The axis.</param>
				void								SetAxis(Ptr<IGuiAxis> value);
				
				/// <summary>Get the alignment for rows.</summary>
				/// <returns>The alignment.</returns>
				FlowAlignment						GetAlignment();
				/// <summary>Set the alignment for rows.</summary>
				/// <param name="value">The alignment.</param>
				void								SetAlignment(FlowAlignment value);
				
				void								ForceCalculateSizeImmediately()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
			};
			
			/// <summary>
			/// Represnets a base line configuration for a flow item.
			/// </summary>
			struct GuiFlowOption
			{
				/// <summary>Base line calculation algorithm</summary>
				enum BaselineType
				{
					/// <summary>By percentage of the height from the top.</summary>
					Percentage,
					/// <summary>By a distance from the top.</summary>
					FromTop,
					/// <summary>By a distance from the bottom.</summary>
					FromBottom,
				};
				
				/// <summary>The base line calculation algorithm.</summary>
				BaselineType						baseline = FromBottom;
				/// <summary>The percentage value.</summary>
				double								percentage = 0.0;
				/// <summary>The distance value.</summary>
				vint								distance = 0;
			};
			
			/// <summary>
			/// Represents a flow item composition of a <see cref="GuiFlowComposition"/>.
			/// </summary>
			class GuiFlowItemComposition : public GuiGraphicsSite, public Description<GuiFlowItemComposition>
			{
				friend class GuiFlowComposition;
			protected:
				GuiFlowComposition*					flowParent;
				Rect								bounds;
				Margin								extraMargin;
				GuiFlowOption						option;

				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				Size								GetMinSize();
			public:
				GuiFlowItemComposition();
				~GuiFlowItemComposition();
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
				void								SetBounds(Rect value);
				
				/// <summary>Get the extra margin for this flow item. An extra margin is used to enlarge the bounds of the flow item, but only the non-extra part will be used for deciding the flow item layout.</summary>
				/// <returns>The extra margin for this flow item.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin for this flow item. An extra margin is used to enlarge the bounds of the flow item, but only the non-extra part will be used for deciding the flow item layout.</summary>
				/// <param name="value">The extra margin for this flow item.</param>
				void								SetExtraMargin(Margin value);

				/// <summary>Get the base line option for this flow item.</summary>
				/// <returns>The base line option.</returns>
				GuiFlowOption						GetFlowOption();
				/// <summary>Set the base line option for this flow item.</summary>
				/// <param name="value">The base line option.</param>
				void								SetFlowOption(GuiFlowOption value);
			};
		}
	}
}

#endif


/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSSPECIALIZEDCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSPECIALIZEDCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSPECIALIZEDCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Specialized Compositions
***********************************************************************/

			/// <summary>
			/// Represents a composition that is aligned to one border of the parent composition.
			/// </summary>
			class GuiSideAlignedComposition : public GuiGraphicsSite, public Description<GuiSideAlignedComposition>
			{
			public:
				/// <summary>The border to align.</summary>
				enum Direction
				{
					/// <summary>The left border.</summary>
					Left,
					/// <summary>The top border.</summary>
					Top,
					/// <summary>The right border.</summary>
					Right,
					/// <summary>The bottom border.</summary>
					Bottom,
				};
			protected:
				Direction							direction;
				vint								maxLength;
				double								maxRatio;
			public:
				GuiSideAlignedComposition();
				~GuiSideAlignedComposition();
				
				/// <summary>Get the border to align.</summary>
				/// <returns>The border to align.</returns>
				Direction							GetDirection();
				/// <summary>Set the border to align.</summary>
				/// <param name="value">The border to align.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the maximum length of this composition.</summary>
				/// <returns>The maximum length of this composition.</returns>
				vint								GetMaxLength();
				/// <summary>Set the maximum length of this composition.</summary>
				/// <param name="value">The maximum length of this composition.</param>
				void								SetMaxLength(vint value);
				/// <summary>Get the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <returns>The maximum ratio to limit the size according to the size of the parent.</returns>
				double								GetMaxRatio();
				/// <summary>Set the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <param name="value">The maximum ratio to limit the size according to the size of the parent.</param>
				void								SetMaxRatio(double value);
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};

			/// <summary>
			/// Represents a composition that its location and size are decided by the client area of the parent composition by setting ratios.
			/// </summary>
			class GuiPartialViewComposition : public GuiGraphicsSite, public Description<GuiPartialViewComposition>
			{
			protected:
				double								wRatio;
				double								wPageSize;
				double								hRatio;
				double								hPageSize;

			public:
				GuiPartialViewComposition();
				~GuiPartialViewComposition();
				
				/// <summary>Get the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <returns>The width ratio to decided the horizontal location.</returns>
				double								GetWidthRatio();
				/// <summary>Get the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the horizontal size.</returns>
				double								GetWidthPageSize();
				/// <summary>Get the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <returns>The height ratio to decided the vertical location.</returns>
				double								GetHeightRatio();
				/// <summary>Get the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the vertical size.</returns>
				double								GetHeightPageSize();
				/// <summary>Set the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The width ratio to decided the horizontal location.</param>
				void								SetWidthRatio(double value);
				/// <summary>Set the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the horizontal size.</param>
				void								SetWidthPageSize(double value);
				/// <summary>Set the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The height ratio to decided the vertical location.</param>
				void								SetHeightRatio(double value);
				/// <summary>Set the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the vertical size.</param>
				void								SetHeightPageSize(double value);
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSRESPONSIVECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSRESPONSIVECOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSRESPONSIVECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
GuiResponsiveCompositionBase
***********************************************************************/

			enum class ResponsiveDirection
			{
				Horizontal = 1,
				Vertical = 2,
				Both = 3,
			};

			/// <summary>Base class for responsive layout compositions.</summary>
			class GuiResponsiveCompositionBase abstract : public GuiBoundsComposition, public Description<GuiResponsiveCompositionBase>
			{
			protected:
				GuiResponsiveCompositionBase*		responsiveParent = nullptr;
				ResponsiveDirection					direction = ResponsiveDirection::Both;

				void								OnParentLineChanged()override;
				virtual void						OnResponsiveChildInserted(GuiResponsiveCompositionBase* child);
				virtual void						OnResponsiveChildRemoved(GuiResponsiveCompositionBase* child);
				virtual void						OnResponsiveChildLevelUpdated();

			public:
				GuiResponsiveCompositionBase();
				~GuiResponsiveCompositionBase();

				/// <summary>LevelCount changed event.</summary>
				GuiNotifyEvent						LevelCountChanged;
				/// <summary>CurrentLevel chagned event.</summary>
				GuiNotifyEvent						CurrentLevelChanged;

				/// <summary>Get the level count. A level count represents how many views this composition carries.</summary>
				/// <returns>The level count.</returns>
				virtual vint						GetLevelCount() = 0;
				/// <summary>Get the current level. Zero is the view with the smallest size.</summary>
				/// <returns>The current level.</returns>
				virtual vint						GetCurrentLevel() = 0;
				/// <summary>Switch to a smaller view.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool						LevelDown() = 0;
				/// <summary>Switch to a larger view.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool						LevelUp() = 0;

				/// <summary>Get all supported directions. If all directions of a child [T:vl.presentation.compositions.GuiResponsiveCompositionBase] are not supported, its view will not be changed when the parent composition changes its view .</summary>
				/// <returns>All supported directions.</returns>
				ResponsiveDirection					GetDirection();
				/// <summary>Set all supported directions.</summary>
				/// <param name="value">All supported directions.</param>
				void								SetDirection(ResponsiveDirection value);
			};

/***********************************************************************
GuiResponsiveViewComposition
***********************************************************************/

			class GuiResponsiveSharedCollection : public collections::ObservableListBase<controls::GuiControl*>
			{
			protected:
				GuiResponsiveViewComposition*		view = nullptr;

				void								BeforeInsert(vint index, controls::GuiControl* const& value)override;
				void								AfterInsert(vint index, controls::GuiControl* const& value)override;
				void								BeforeRemove(vint index, controls::GuiControl* const& value)override;
				void								AfterRemove(vint index, vint count)override;

			public:
				GuiResponsiveSharedCollection(GuiResponsiveViewComposition* _view);
				~GuiResponsiveSharedCollection();
			};

			class GuiResponsiveViewCollection : public collections::ObservableListBase<GuiResponsiveCompositionBase*>
			{
			protected:
				GuiResponsiveViewComposition*		view = nullptr;

				void								BeforeInsert(vint index, GuiResponsiveCompositionBase* const& value)override;
				void								AfterInsert(vint index, GuiResponsiveCompositionBase* const& value)override;
				void								BeforeRemove(vint index, GuiResponsiveCompositionBase* const& value)override;
				void								AfterRemove(vint index, vint count)override;

			public:
				GuiResponsiveViewCollection(GuiResponsiveViewComposition* _view);
				~GuiResponsiveViewCollection();
			};

			/// <summary>Represents a composition, which will pick up a shared control and install inside it, when it is displayed by a [T:vl.presentation.compositions.GuiResponsiveViewComposition]</summary>
			class GuiResponsiveSharedComposition : public GuiBoundsComposition, public Description<GuiResponsiveSharedComposition>
			{
			protected:
				GuiResponsiveViewComposition*		view = nullptr;
				controls::GuiControl*				shared = nullptr;

				void								SetSharedControl();
				void								OnParentLineChanged()override;

			public:
				GuiResponsiveSharedComposition();
				~GuiResponsiveSharedComposition();

				/// <summary>Get the selected shared control.</summary>
				/// <returns>The selected shared control.</returns>
				controls::GuiControl*				GetShared();
				/// <summary>Set the selected shared control, which should be stored in [M:vl.presentation.compositions.GuiResponsiveViewComposition.GetSharedControls].</summary>
				/// <param name="value">The selected shared control.</param>
				void								SetShared(controls::GuiControl* value);
			};

			/// <summary>A responsive layout composition defined by views of different sizes.</summary>
			class GuiResponsiveViewComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveViewComposition>
			{
				friend class GuiResponsiveSharedCollection;
				friend class GuiResponsiveViewCollection;
				friend class GuiResponsiveSharedComposition;
				using ControlSet = collections::SortedList<controls::GuiControl*>;
			protected:
				vint								levelCount = 1;
				vint								currentLevel = 0;
				bool								skipUpdatingLevels = false;
				GuiResponsiveCompositionBase*		currentView = nullptr;

				ControlSet							usedSharedControls;
				GuiResponsiveSharedCollection		sharedControls;
				GuiResponsiveViewCollection			views;
				bool								destructing = false;

				bool								CalculateLevelCount();
				bool								CalculateCurrentLevel();
				void								OnResponsiveChildLevelUpdated()override;

			public:
				GuiResponsiveViewComposition();
				~GuiResponsiveViewComposition();

				/// <summary>Before switch view event. This event happens between hiding the previous view and showing the next view. The itemIndex field can be used to access [M:vl.presentation.compositions.GuiResponsiveViewComposition.GetViews], it is not the level number.</summary>
				GuiItemNotifyEvent													BeforeSwitchingView;

				vint																GetLevelCount()override;
				vint																GetCurrentLevel()override;
				bool																LevelDown()override;
				bool																LevelUp()override;

				/// <summary>Get the current displaying view.</summary>
				/// <returns>The current displaying view.</returns>
				GuiResponsiveCompositionBase*										GetCurrentView();

				/// <summary>Get all shared controls. A shared control can jump between different views if it is contained in a [T:vl.presentation.compositions.GuiResponsiveSharedComposition]. This helps to keep control states during switching views.</summary>
				/// <returns>All shared controls.</returns>
				collections::ObservableListBase<controls::GuiControl*>&				GetSharedControls();

				/// <summary>Get all individual views to switch.</summary>
				/// <returns>All individual views to switch.</returns>
				collections::ObservableListBase<GuiResponsiveCompositionBase*>&		GetViews();
			};

/***********************************************************************
Others
***********************************************************************/

			/// <summary>A responsive layout composition which stop parent responsive composition to search its children.</summary>
			class GuiResponsiveFixedComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveFixedComposition>
			{
			protected:
				void					OnResponsiveChildLevelUpdated()override;

			public:
				GuiResponsiveFixedComposition();
				~GuiResponsiveFixedComposition();

				vint					GetLevelCount()override;
				vint					GetCurrentLevel()override;
				bool					LevelDown()override;
				bool					LevelUp()override;
			};

			/// <summary>A responsive layout composition which change its size by changing children's views one by one in one direction.</summary>
			class GuiResponsiveStackComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveStackComposition>
			{
				using ResponsiveChildList = collections::List<GuiResponsiveCompositionBase*>;
			protected:
				vint					levelCount = 1;
				vint					currentLevel = 0;
				ResponsiveChildList		responsiveChildren;

				bool					CalculateLevelCount();
				bool					CalculateCurrentLevel();
				void					OnResponsiveChildInserted(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildRemoved(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildLevelUpdated()override;
				bool					ChangeLevel(bool levelDown);

			public:
				GuiResponsiveStackComposition();
				~GuiResponsiveStackComposition();

				vint					GetLevelCount()override;
				vint					GetCurrentLevel()override;
				bool					LevelDown()override;
				bool					LevelUp()override;
			};

			/// <summary>A responsive layout composition which change its size by changing children's views at the same time.</summary>
			class GuiResponsiveGroupComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveGroupComposition>
			{
				using ResponsiveChildList = collections::List<GuiResponsiveCompositionBase*>;
			protected:
				vint					levelCount = 1;
				vint					currentLevel = 0;
				ResponsiveChildList		responsiveChildren;

				bool					CalculateLevelCount();
				bool					CalculateCurrentLevel();
				void					OnResponsiveChildInserted(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildRemoved(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildLevelUpdated()override;

			public:
				GuiResponsiveGroupComposition();
				~GuiResponsiveGroupComposition();

				vint					GetLevelCount()override;
				vint					GetCurrentLevel()override;
				bool					LevelDown()override;
				bool					LevelUp()override;
			};

/***********************************************************************
GuiResponsiveContainerComposition
***********************************************************************/

			/// <summary>A composition which will automatically tell its target responsive composition to switch between views according to its size.</summary>
			class GuiResponsiveContainerComposition : public GuiBoundsComposition, public Description<GuiResponsiveContainerComposition>
			{
			protected:
				GuiResponsiveCompositionBase*			responsiveTarget = nullptr;
				Size									upperLevelSize;

				void									AdjustLevel();
				void									OnBoundsChanged(GuiGraphicsComposition* sender, GuiEventArgs& arguments);

			public:
				GuiResponsiveContainerComposition();
				~GuiResponsiveContainerComposition();

				/// <summary>Get the responsive composition to control.</summary>
				/// <returns>The responsive composition to control.</returns>
				GuiResponsiveCompositionBase*			GetResponsiveTarget();
				/// <summary>Get the responsive composition to control.</summary>
				/// <param name="value">The responsive composition to control.</param>
				void									SetResponsiveTarget(GuiResponsiveCompositionBase* value);
			};
		}
	}
}

#endif


/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSSHAREDSIZECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSHAREDSIZECOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSHAREDSIZECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			/// <summary>A shared size composition that shares the same size with all other <see cref="GuiSharedSizeItemComposition"/> that has a same group name.</summary>
			class GuiSharedSizeItemComposition : public GuiBoundsComposition, public Description<GuiSharedSizeItemComposition>
			{
			protected:
				GuiSharedSizeRootComposition*						parentRoot = nullptr;
				WString												group;
				bool												sharedWidth = false;
				bool												sharedHeight = false;

				void												Update();
				void												OnParentLineChanged()override;
			public:
				GuiSharedSizeItemComposition();
				~GuiSharedSizeItemComposition();
				
				/// <summary>Get the group name of this item.</summary>
				/// <returns>The group name.</returns>
				const WString&										GetGroup();
				/// <summary>Set the group name of this item.</summary>
				/// <param name="value">The group name.</param>
				void												SetGroup(const WString& value);
				/// <summary>Test is the width of this item is shared.</summary>
				/// <returns>Returns true if the width of this item is shared.</returns>
				bool												GetSharedWidth();
				/// <summary>Enable or disable sharing the width of this item.</summary>
				/// <param name="value">Set to true to share the width of this item.</param>
				void												SetSharedWidth(bool value);
				/// <summary>Test is the height of this item is shared.</summary>
				/// <returns>Returns true if the height of this item is shared.</returns>
				bool												GetSharedHeight();
				/// <summary>Enable or disable sharing the height of this item.</summary>
				/// <param name="value">Set to true to share the height of this item.</param>
				void												SetSharedHeight(bool value);
			};

			/// <summary>A root composition that takes care of all direct or indirect <see cref="GuiSharedSizeItemComposition"/> to enable size sharing.</summary>
			class GuiSharedSizeRootComposition :public GuiBoundsComposition, public Description<GuiSharedSizeRootComposition>
			{
				friend class GuiSharedSizeItemComposition;
			protected:
				collections::Dictionary<WString, vint>				itemWidths;
				collections::Dictionary<WString, vint>				itemHeights;
				collections::List<GuiSharedSizeItemComposition*>	childItems;

				void												AddSizeComponent(collections::Dictionary<WString, vint>& sizes, const WString& group, vint sizeComponent);
				void												CollectSizes(collections::Dictionary<WString, vint>& widths, collections::Dictionary<WString, vint>& heights);
				void												AlignSizes(collections::Dictionary<WString, vint>& widths, collections::Dictionary<WString, vint>& heights);
			public:
				GuiSharedSizeRootComposition();
				~GuiSharedSizeRootComposition();

				void												ForceCalculateSizeImmediately()override;
				Rect												GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSREPEATCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSREPEATCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSREPEATCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			/// <summary>A base class for all bindable repeat compositions.</summary>
			class GuiRepeatCompositionBase : public Object, public Description<GuiRepeatCompositionBase>
			{
				using ItemStyleProperty = TemplateProperty<templates::GuiTemplate>;
				using IValueEnumerable = reflection::description::IValueEnumerable;
				using IValueList = reflection::description::IValueList;
			protected:
				ItemStyleProperty									itemTemplate;
				Ptr<IValueList>										itemSource;
				Ptr<EventHandler>									itemChangedHandler;

				virtual vint										GetRepeatCompositionCount() = 0;
				virtual GuiGraphicsComposition*						GetRepeatComposition(vint index) = 0;
				virtual GuiGraphicsComposition*						InsertRepeatComposition(vint index) = 0;
				virtual GuiGraphicsComposition*						RemoveRepeatComposition(vint index) = 0;

				void												OnItemChanged(vint index, vint oldCount, vint newCount);
				void												RemoveItem(vint index);
				void												InstallItem(vint index);
				void												ClearItems();
				void												InstallItems();
			public:
				GuiRepeatCompositionBase();
				~GuiRepeatCompositionBase();

				/// <summary>An event called after a new item is inserted.</summary>
				GuiItemNotifyEvent									ItemInserted;
				/// <summary>An event called before a new item is removed.</summary>
				GuiItemNotifyEvent									ItemRemoved;

				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				ItemStyleProperty									GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				void												SetItemTemplate(ItemStyleProperty value);

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<IValueEnumerable>								GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="value">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<IValueEnumerable> value);
			};

			/// <summary>Bindable stack composition.</summary>
			class GuiRepeatStackComposition : public GuiStackComposition, public GuiRepeatCompositionBase, public Description<GuiRepeatStackComposition>
			{
			protected:
				vint												GetRepeatCompositionCount()override;
				GuiGraphicsComposition*								GetRepeatComposition(vint index)override;
				GuiGraphicsComposition*								InsertRepeatComposition(vint index)override;
				GuiGraphicsComposition*								RemoveRepeatComposition(vint index)override;
			public:
			};

			/// <summary>Bindable flow composition.</summary>
			class GuiRepeatFlowComposition : public GuiFlowComposition, public GuiRepeatCompositionBase, public Description<GuiRepeatFlowComposition>
			{
			protected:
				vint												GetRepeatCompositionCount()override;
				GuiGraphicsComposition*								GetRepeatComposition(vint index)override;
				GuiGraphicsComposition*								InsertRepeatComposition(vint index)override;
				GuiGraphicsComposition*								RemoveRepeatComposition(vint index)override;
			public:
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\INCLUDEALL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_INCLUDEALL
#define VCZH_PRESENTATION_COMPOSITION_INCLUDEALL


#endif

/***********************************************************************
.\GRAPHICSHOST\GUIGRAPHICSHOST_SHORTCUTKEY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_SHORTCUTKEY
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_SHORTCUTKEY


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Shortcut Key Manager
***********************************************************************/

			class IGuiShortcutKeyManager;

			/// <summary>Shortcut key item.</summary>
			class IGuiShortcutKeyItem : public virtual IDescriptable, public Description<IGuiShortcutKeyItem>
			{
			public:
				/// <summary>Shortcut key executed event.</summary>
				GuiNotifyEvent							Executed;

				/// <summary>Get the associated <see cref="IGuiShortcutKeyManager"/> object.</summary>
				/// <returns>The associated shortcut key manager.</returns>
				virtual IGuiShortcutKeyManager*			GetManager()=0;
				/// <summary>Get the name represents the shortcut key combination for this item.</summary>
				/// <returns>The name represents the shortcut key combination for this item.</returns>
				virtual WString							GetName()=0;
			};
			
			/// <summary>Shortcut key manager item.</summary>
			class IGuiShortcutKeyManager : public virtual IDescriptable, public Description<IGuiShortcutKeyManager>
			{
			public:
				/// <summary>Get the number of shortcut key items that already attached to the manager.</summary>
				/// <returns>T number of shortcut key items that already attached to the manager.</returns>
				virtual vint							GetItemCount()=0;
				/// <summary>Get the <see cref="IGuiShortcutKeyItem"/> associated with the index.</summary>
				/// <returns>The shortcut key item.</returns>
				/// <param name="index">The index.</param>
				virtual IGuiShortcutKeyItem*			GetItem(vint index)=0;
				/// <summary>Execute shortcut key items using a key event info.</summary>
				/// <returns>Returns true if at least one shortcut key item is executed.</returns>
				/// <param name="info">The key event info.</param>
				virtual bool							Execute(const NativeWindowKeyInfo& info)=0;
			};

/***********************************************************************
Shortcut Key Manager Helpers
***********************************************************************/

			class GuiShortcutKeyManager;

			class GuiShortcutKeyItem : public Object, public IGuiShortcutKeyItem
			{
			protected:
				GuiShortcutKeyManager*			shortcutKeyManager;
				bool							ctrl;
				bool							shift;
				bool							alt;
				VKEY							key;

				void							AttachManager(GuiShortcutKeyManager* manager);
				void							DetachManager(GuiShortcutKeyManager* manager);
			public:
				GuiShortcutKeyItem(GuiShortcutKeyManager* _shortcutKeyManager, bool _ctrl, bool _shift, bool _alt, VKEY _key);
				~GuiShortcutKeyItem();

				IGuiShortcutKeyManager*			GetManager()override;
				WString							GetName()override;
				bool							CanActivate(const NativeWindowKeyInfo& info);
				bool							CanActivate(bool _ctrl, bool _shift, bool _alt, VKEY _key);
			};

			/// <summary>A default implementation for <see cref="IGuiShortcutKeyManager"/>.</summary>
			class GuiShortcutKeyManager : public Object, public IGuiShortcutKeyManager, public Description<GuiShortcutKeyManager>
			{
				typedef collections::List<Ptr<GuiShortcutKeyItem>>		ShortcutKeyItemList;
			protected:
				ShortcutKeyItemList				shortcutKeyItems;

			public:
				/// <summary>Create the shortcut key manager.</summary>
				GuiShortcutKeyManager();
				~GuiShortcutKeyManager();

				vint							GetItemCount()override;
				IGuiShortcutKeyItem*			GetItem(vint index)override;
				bool							Execute(const NativeWindowKeyInfo& info)override;

				/// <summary>Create a shortcut key item using a key combination. If the item for the key combination exists, this function returns the item that is created before.</summary>
				/// <returns>The created shortcut key item.</returns>
				/// <param name="ctrl">Set to true if the CTRL key is required.</param>
				/// <param name="shift">Set to true if the SHIFT key is required.</param>
				/// <param name="alt">Set to true if the ALT key is required.</param>
				/// <param name="key">The non-control key.</param>
				IGuiShortcutKeyItem*			CreateShortcut(bool ctrl, bool shift, bool alt, VKEY key);
				/// <summary>Destroy a shortcut key item using a key combination</summary>
				/// <returns>Returns true if the manager destroyed a existing shortcut key item.</returns>
				/// <param name="ctrl">Set to true if the CTRL key is required.</param>
				/// <param name="shift">Set to true if the SHIFT key is required.</param>
				/// <param name="alt">Set to true if the ALT key is required.</param>
				/// <param name="key">The non-control key.</param>
				bool							DestroyShortcut(bool ctrl, bool shift, bool alt, VKEY key);
				/// <summary>Get a shortcut key item using a key combination. If the item for the key combination does not exist, this function returns null.</summary>
				/// <returns>The shortcut key item.</returns>
				/// <param name="ctrl">Set to true if the CTRL key is required.</param>
				/// <param name="shift">Set to true if the SHIFT key is required.</param>
				/// <param name="alt">Set to true if the ALT key is required.</param>
				/// <param name="key">The non-control key.</param>
				IGuiShortcutKeyItem*			TryGetShortcut(bool ctrl, bool shift, bool alt, VKEY key);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSHOST\GUIGRAPHICSHOST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiWindow;
		}

		namespace compositions
		{

/***********************************************************************
Animation
***********************************************************************/

			/// <summary>
			/// Represents a timer callback object.
			/// </summary>
			class IGuiGraphicsTimerCallback : public virtual IDescriptable, public Description<IGuiGraphicsTimerCallback>
			{
			public:
				/// <summary>Called periodically.</summary>
				/// <returns>Returns false to indicate that this callback need to be removed.</returns>
				virtual bool					Play() = 0;
			};

			/// <summary>
			/// Timer callback manager.
			/// </summary>
			class GuiGraphicsTimerManager : public Object, public Description<GuiGraphicsTimerManager>
			{
				typedef collections::List<Ptr<IGuiGraphicsTimerCallback>>		CallbackList;
			protected:
				CallbackList					callbacks;

			public:
				GuiGraphicsTimerManager();
				~GuiGraphicsTimerManager();

				/// <summary>Add a new callback.</summary>
				/// <param name="callback">The new callback to add.</param>
				void							AddCallback(Ptr<IGuiGraphicsTimerCallback> callback);
				/// <summary>Called periodically.</summary>
				void							Play();
			};

/***********************************************************************
Host
***********************************************************************/

			/// <summary>
			/// GuiGraphicsHost hosts an <see cref="GuiWindowComposition"/> in an <see cref="INativeWindow"/>. The composition will fill the whole window.
			/// </summary>
			class GuiGraphicsHost : public Object, private INativeWindowListener, private INativeControllerListener, public Description<GuiGraphicsHost>
			{
				typedef collections::List<GuiGraphicsComposition*>							CompositionList;
				typedef GuiGraphicsComposition::GraphicsHostRecord							HostRecord;
				typedef collections::Pair<DescriptableObject*, vint>						ProcKey;
				typedef collections::List<Func<void()>>										ProcList;
				typedef collections::Dictionary<ProcKey, Func<void()>>						ProcMap;
			public:
				static const vuint64_t					CaretInterval = 500;

			protected:
				HostRecord								hostRecord;
				bool									supressPaint = false;
				bool									needRender = true;
				ProcList								afterRenderProcs;
				ProcMap									afterRenderKeyedProcs;

				GuiAltActionManager*					altActionManager = nullptr;
				GuiTabActionManager*					tabActionManager = nullptr;
				IGuiShortcutKeyManager*					shortcutKeyManager = nullptr;

				controls::GuiControlHost*				controlHost = nullptr;
				GuiWindowComposition*					windowComposition = nullptr;
				GuiGraphicsComposition*					focusedComposition = nullptr;
				NativeSize								previousClientSize;
				Size									minSize;
				Point									caretPoint;
				vuint64_t								lastCaretTime = 0;

				GuiGraphicsTimerManager					timerManager;
				GuiGraphicsComposition*					mouseCaptureComposition = nullptr;
				CompositionList							mouseEnterCompositions;
				void									RefreshRelatedHostRecord(INativeWindow* nativeWindow);

				void									DisconnectCompositionInternal(GuiGraphicsComposition* composition);
				void									MouseCapture(const NativeWindowMouseInfo& info);
				void									MouseUncapture(const NativeWindowMouseInfo& info);
				void									OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnMouseInput(const NativeWindowMouseInfo& info, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									RecreateRenderTarget();
				
			private:
				INativeWindowListener::HitTestResult	HitTest(NativePoint location)override;
				void									Moving(NativeRect& bounds, bool fixSizeOnly)override;
				void									Moved()override;
				void									DpiChanged()override;
				void									Paint()override;

				void									LeftButtonDown(const NativeWindowMouseInfo& info)override;
				void									LeftButtonUp(const NativeWindowMouseInfo& info)override;
				void									LeftButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									RightButtonDown(const NativeWindowMouseInfo& info)override;
				void									RightButtonUp(const NativeWindowMouseInfo& info)override;
				void									RightButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDown(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonUp(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									HorizontalWheel(const NativeWindowMouseInfo& info)override;
				void									VerticalWheel(const NativeWindowMouseInfo& info)override;
				void									MouseMoving(const NativeWindowMouseInfo& info)override;
				void									MouseEntered()override;
				void									MouseLeaved()override;

				void									KeyDown(const NativeWindowKeyInfo& info)override;
				void									KeyUp(const NativeWindowKeyInfo& info)override;
				void									SysKeyDown(const NativeWindowKeyInfo& info)override;
				void									SysKeyUp(const NativeWindowKeyInfo& info)override;
				void									Char(const NativeWindowCharInfo& info)override;

				void									GlobalTimer()override;
			public:
				GuiGraphicsHost(controls::GuiControlHost* _controlHost, GuiGraphicsComposition* boundsComposition);
				~GuiGraphicsHost();

				/// <summary>Get the associated window.</summary>
				/// <returns>The associated window.</returns>
				INativeWindow*							GetNativeWindow();
				/// <summary>Associate a window. A <see cref="GuiWindowComposition"/> will fill and appear in the window.</summary>
				/// <param name="_nativeWindow">The window to associated.</param>
				void									SetNativeWindow(INativeWindow* _nativeWindow);
				/// <summary>Get the main <see cref="GuiWindowComposition"/>. If a window is associated, everything that put into the main composition will be shown in the window.</summary>
				/// <returns>The main compositoin.</returns>
				GuiGraphicsComposition*					GetMainComposition();
				/// <summary>Render the main composition and all content to the associated window.</summary>
				/// <param name="forceUpdate">Set to true to force updating layout and then render.</param>
				void									Render(bool forceUpdate);
				/// <summary>Request a rendering</summary>
				void									RequestRender();
				/// <summary>Invoke a specified function after rendering.</summary>
				/// <param name="proc">The specified function.</param>
				/// <param name="key">A key to cancel a previous binded key if not null.</param>
				void									InvokeAfterRendering(const Func<void()>& proc, ProcKey key = { nullptr,-1 });

				/// <summary>Invalidte the internal tab order control list. Next time when TAB is pressed it will be rebuilt.</summary>
				void									InvalidateTabOrderCache();
				/// <summary>Get the <see cref="IGuiShortcutKeyManager"/> attached with this graphics host.</summary>
				/// <returns>The shortcut key manager.</returns>
				IGuiShortcutKeyManager*					GetShortcutKeyManager();
				/// <summary>Attach or detach the <see cref="IGuiShortcutKeyManager"/> associated with this graphics host. When this graphics host is disposing, the associated shortcut key manager will be deleted if exists.</summary>
				/// <param name="value">The shortcut key manager. Set to null to detach the previous shortcut key manager from this graphics host.</param>
				void									SetShortcutKeyManager(IGuiShortcutKeyManager* value);

				/// <summary>Set the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="composition">The composition to set focus. This composition should be or in the main composition.</param>
				bool									SetFocus(GuiGraphicsComposition* composition);
				/// <summary>Get the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>The focus composition.</returns>
				GuiGraphicsComposition*					GetFocusedComposition();
				/// <summary>Get the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <returns>The caret point.</returns>
				Point									GetCaretPoint();
				/// <summary>Set the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <param name="value">The caret point.</param>
				/// <param name="referenceComposition">The point space. If this argument is null, the "value" argument will use the point space of the client area in the main composition.</param>
				void									SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition=0);

				/// <summary>Get the timer manager.</summary>
				/// <returns>The timer manager.</returns>
				GuiGraphicsTimerManager*				GetTimerManager();
				/// <summary>Notify that a composition is going to disconnect from this graphics host. Generally this happens when a composition's parent line changes.</summary>
				/// <param name="composition">The composition to disconnect</param>
				void									DisconnectComposition(GuiGraphicsComposition* composition);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\GUILABELCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILABELCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILABELCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Label
***********************************************************************/

			/// <summary>A control to display a text.</summary>
			class GuiLabel : public GuiControl, public Description<GuiLabel>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(LabelTemplate, GuiControl)
			protected:
				Color									textColor;
				bool									textColorConsisted = true;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiLabel(theme::ThemeName themeName);
				~GuiLabel();

				/// <summary>Get the text color.</summary>
				/// <returns>The text color.</returns>
				Color									GetTextColor();
				/// <summary>Set the text color.</summary>
				/// <param name="value">The text color.</param>
				void									SetTextColor(Color value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUIBUTTONCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBUTTONCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBUTTONCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Buttons
***********************************************************************/

			/// <summary>A control with 3 phases state transffering when mouse click happens.</summary>
			class GuiButton : public GuiControl, public Description<GuiButton>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ButtonTemplate, GuiControl)
			protected:
				bool									clickOnMouseUp = true;
				bool									autoFocus = true;
				bool									keyPressing = false;
				bool									mousePressing = false;
				bool									mouseHoving = false;
				ButtonState								controlState = ButtonState::Normal;

				void									OnParentLineChanged()override;
				void									OnActiveAlt()override;
				bool									IsTabAvailable()override;
				void									UpdateControlState();
				void									CheckAndClick(compositions::GuiEventArgs& arguments);
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void									OnKeyUp(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void									OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiButton(theme::ThemeName themeName);
				~GuiButton();

				/// <summary>Mouse click event.</summary>
				compositions::GuiNotifyEvent			Clicked;

				/// <summary>Test is the <see cref="Clicked"/> event raised when left mouse button up.</summary>
				/// <returns>Returns true if this event is raised when left mouse button up</returns>
				bool									GetClickOnMouseUp();
				/// <summary>Set is the <see cref="Clicked"/> event raised when left mouse button up or not.</summary>
				/// <param name="value">Set to true to make this event raised when left mouse button up</param>
				void									SetClickOnMouseUp(bool value);

				/// <summary>Test if the button gets focus when it is clicked.</summary>
				/// <returns>Returns true if the button gets focus when it is clicked</returns>
				bool									GetAutoFocus();
				/// <summary>Set if the button gets focus when it is clicked.</summary>
				/// <param name="value">Set to true to make this button get focus when it is clicked.</param>
				void									SetAutoFocus(bool value);
			};

			/// <summary>A <see cref="GuiButton"/> with a selection state.</summary>
			class GuiSelectableButton : public GuiButton, public Description<GuiSelectableButton>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(SelectableButtonTemplate, GuiButton)
			public:
				/// <summary>Selection group controller. Control the selection state of all attached button.</summary>
				class GroupController : public GuiComponent, public Description<GroupController>
				{
				protected:
					collections::List<GuiSelectableButton*>	buttons;
				public:
					GroupController();
					~GroupController();

					/// <summary>Called when the group controller is attached to a <see cref="GuiSelectableButton"/>. use [M:vl.presentation.controls.GuiSelectableButton.SetGroupController] to attach or detach a group controller to or from a selectable button.</summary>
					/// <param name="button">The button to attach.</param>
					virtual void						Attach(GuiSelectableButton* button);
					/// <summary>Called when the group controller is deteched to a <see cref="GuiSelectableButton"/>. use [M:vl.presentation.controls.GuiSelectableButton.SetGroupController] to attach or detach a group controller to or from a selectable button.</summary>
					/// <param name="button">The button to detach.</param>
					virtual void						Detach(GuiSelectableButton* button);
					/// <summary>Called when the selection state of any <see cref="GuiSelectableButton"/> changed.</summary>
					/// <param name="button">The button that changed the selection state.</param>
					virtual void						OnSelectedChanged(GuiSelectableButton* button) = 0;
				};

				/// <summary>A mutex group controller, usually for radio buttons.</summary>
				class MutexGroupController : public GroupController, public Description<MutexGroupController>
				{
				protected:
					bool								suppress;
				public:
					MutexGroupController();
					~MutexGroupController();

					void								OnSelectedChanged(GuiSelectableButton* button)override;
				};

			protected:
				GroupController*						groupController = nullptr;
				bool									autoSelection = true;
				bool									isSelected = false;

				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiSelectableButton(theme::ThemeName themeName);
				~GuiSelectableButton();

				/// <summary>Group controller changed event.</summary>
				compositions::GuiNotifyEvent			GroupControllerChanged;
				/// <summary>Auto selection changed event.</summary>
				compositions::GuiNotifyEvent			AutoSelectionChanged;
				/// <summary>Selected changed event.</summary>
				compositions::GuiNotifyEvent			SelectedChanged;

				/// <summary>Get the attached group controller.</summary>
				/// <returns>The attached group controller.</returns>
				virtual GroupController*				GetGroupController();
				/// <summary>Set the attached group controller.</summary>
				/// <param name="value">The attached group controller.</param>
				virtual void							SetGroupController(GroupController* value);

				/// <summary>Get the auto selection state. True if the button is automatically selected or unselected when the button is clicked.</summary>
				/// <returns>The auto selection state.</returns>
				virtual bool							GetAutoSelection();
				/// <summary>Set the auto selection state. True if the button is automatically selected or unselected when the button is clicked.</summary>
				/// <param name="value">The auto selection state.</param>
				virtual void							SetAutoSelection(bool value);

				/// <summary>Get the selected state.</summary>
				/// <returns>The selected state.</returns>
				virtual bool							GetSelected();
				/// <summary>Set the selected state.</summary>
				/// <param name="value">The selected state.</param>
				virtual void							SetSelected(bool value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUISCROLLCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUISCROLLCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUISCROLLCONTROLS


namespace vl
{
	namespace presentation
	{

		namespace controls
		{

/***********************************************************************
Scrolls
***********************************************************************/

			/// <summary>A scroll control, which represents a one dimension sub range of a whole range.</summary>
			class GuiScroll : public GuiControl, public Description<GuiScroll>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ScrollTemplate, GuiControl)
			protected:
				class CommandExecutor : public Object, public IScrollCommandExecutor
				{
				protected:
					GuiScroll*							scroll;
				public:
					CommandExecutor(GuiScroll* _scroll);
					~CommandExecutor();

					void								SmallDecrease()override;
					void								SmallIncrease()override;
					void								BigDecrease()override;
					void								BigIncrease()override;

					void								SetTotalSize(vint value)override;
					void								SetPageSize(vint value)override;
					void								SetPosition(vint value)override;
				};

				Ptr<CommandExecutor>					commandExecutor;
				vint									totalSize = 100;
				vint									pageSize = 10;
				vint									position = 0;
				vint									smallMove = 1;
				vint									bigMove = 10;
				bool									autoFocus = true;

				void									OnActiveAlt()override;
				bool									IsTabAvailable()override;
				void									OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void									OnMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiScroll(theme::ThemeName themeName);
				~GuiScroll();
				
				/// <summary>Total size changed event.</summary>
				compositions::GuiNotifyEvent			TotalSizeChanged;
				/// <summary>Page size changed event.</summary>
				compositions::GuiNotifyEvent			PageSizeChanged;
				/// <summary>Position changed event.</summary>
				compositions::GuiNotifyEvent			PositionChanged;
				/// <summary>Small move changed event.</summary>
				compositions::GuiNotifyEvent			SmallMoveChanged;
				/// <summary>Big move changed event.</summary>
				compositions::GuiNotifyEvent			BigMoveChanged;
				
				/// <summary>Get the total size.</summary>
				/// <returns>The total size.</returns>
				virtual vint							GetTotalSize();
				/// <summary>Set the total size.</summary>
				/// <param name="value">The total size.</param>
				virtual void							SetTotalSize(vint value);
				/// <summary>Get the page size.</summary>
				/// <returns>The page size.</returns>
				virtual vint							GetPageSize();
				/// <summary>Set the page size.</summary>
				/// <param name="value">The page size.</param>
				virtual void							SetPageSize(vint value);
				/// <summary>Get the position.</summary>
				/// <returns>The position.</returns>
				virtual vint							GetPosition();
				/// <summary>Set the position.</summary>
				/// <param name="value">The position.</param>
				virtual void							SetPosition(vint value);
				/// <summary>Get the small move.</summary>
				/// <returns>The small move.</returns>
				virtual vint							GetSmallMove();
				/// <summary>Set the small move.</summary>
				/// <param name="value">The small move.</param>
				virtual void							SetSmallMove(vint value);
				/// <summary>Get the big move.</summary>
				/// <returns>The big move.</returns>
				virtual vint							GetBigMove();
				/// <summary>Set the big move.</summary>
				/// <param name="value">The big move.</param>
				virtual void							SetBigMove(vint value);
				
				/// <summary>Get the minimum possible position.</summary>
				/// <returns>The minimum possible position.</returns>
				vint									GetMinPosition();
				/// <summary>Get the maximum possible position.</summary>
				/// <returns>The maximum possible position.</returns>
				vint									GetMaxPosition();

				/// <summary>Test if the scroll gets focus when it is clicked.</summary>
				/// <returns>Returns true if the scroll gets focus when it is clicked</returns>
				bool									GetAutoFocus();
				/// <summary>Set if the scroll gets focus when it is clicked.</summary>
				/// <param name="value">Set to true to make this scroll get focus when it is clicked.</param>
				void									SetAutoFocus(bool value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUICONTAINERCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
Tab Control
***********************************************************************/

			class GuiTabPageList;
			class GuiTab;

			/// <summary>Represnets a tab page control.</summary>
			class GuiTabPage : public GuiCustomControl, public AggregatableDescription<GuiTabPage>
			{
				friend class GuiTabPageList;
			protected:
				GuiTab*											tab = nullptr;

				bool											IsAltAvailable()override;
			public:
				/// <summary>Create a tab page control with a specified style controller.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTabPage(theme::ThemeName themeName);
				~GuiTabPage();

				GuiTab*											GetOwnerTab();
			};

			class GuiTabPageList : public collections::ObservableList<GuiTabPage*>
			{
			protected:
				GuiTab*											tab;

				bool											QueryInsert(vint index, GuiTabPage* const& value)override;
				void											AfterInsert(vint index, GuiTabPage* const& value)override;
				void											BeforeRemove(vint index, GuiTabPage* const& value)override;
			public:
				GuiTabPageList(GuiTab* _tab);
				~GuiTabPageList();
			};

			/// <summary>Represents a container with multiple named tabs.</summary>
			class GuiTab : public GuiControl, public Description<GuiTab>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TabTemplate, GuiControl)
				friend class GuiTabPageList;
			protected:
				class CommandExecutor : public Object, public ITabCommandExecutor
				{
				protected:
					GuiTab*										tab;

				public:
					CommandExecutor(GuiTab* _tab);
					~CommandExecutor();

					void										ShowTab(vint index, bool setFocus)override;
				};

				Ptr<CommandExecutor>							commandExecutor;
				GuiTabPageList									tabPages;
				GuiTabPage*										selectedPage = nullptr;

				void											OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTab(theme::ThemeName themeName);
				~GuiTab();

				/// <summary>Selected page changed event.</summary>
				compositions::GuiNotifyEvent					SelectedPageChanged;

				/// <summary>Get all pages.</summary>
				/// <returns>All pages.</returns>
				collections::ObservableList<GuiTabPage*>&		GetPages();

				/// <summary>Get the selected page.</summary>
				/// <returns>The selected page.</returns>
				GuiTabPage*										GetSelectedPage();
				/// <summary>Set the selected page.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The selected page.</param>
				bool											SetSelectedPage(GuiTabPage* value);
			};

/***********************************************************************
Scroll View
***********************************************************************/

			/// <summary>A control with a vertical scroll bar and a horizontal scroll bar to perform partial viewing.</summary>
			class GuiScrollView : public GuiControl, public Description<GuiScrollView>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ScrollViewTemplate, GuiControl)

				using IEventHandler = compositions::IGuiGraphicsEventHandler;
			protected:
				bool									supressScrolling = false;
				Ptr<IEventHandler>						hScrollHandler;
				Ptr<IEventHandler>						vScrollHandler;
				Ptr<IEventHandler>						hWheelHandler;
				Ptr<IEventHandler>						vWheelHandler;
				Ptr<IEventHandler>						containerBoundsChangedHandler;
				bool									horizontalAlwaysVisible = true;
				bool									verticalAlwaysVisible = true;

				void									UpdateDisplayFont()override;

				void									OnContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalWheel(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnVerticalWheel(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									CallUpdateView();
				bool									AdjustView(Size fullSize);

				/// <summary>Calculate the full size of the content.</summary>
				/// <returns>The full size of the content.</returns>
				virtual Size							QueryFullSize()=0;
				/// <summary>Update the visible content using a view bounds. The view bounds is in the space from (0,0) to full size.</summary>
				/// <param name="viewBounds">The view bounds.</param>
				virtual void							UpdateView(Rect viewBounds)=0;
				/// <summary>Calculate the small move of the scroll bar.</summary>
				/// <returns>The small move of the scroll bar.</returns>
				virtual vint							GetSmallMove();
				/// <summary>Calculate the big move of the scroll bar.</summary>
				/// <returns>The big move of the scroll bar.</returns>
				virtual Size							GetBigMove();
				
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiScrollView(theme::ThemeName themeName);
				~GuiScrollView();

				/// <summary>Force to update contents and scroll bars.</summary>
				void									CalculateView();
				/// <summary>Get the view size.</summary>
				/// <returns>The view size.</returns>
				Size									GetViewSize();
				/// <summary>Get the view bounds.</summary>
				/// <returns>The view bounds.</returns>
				Rect									GetViewBounds();
				
				/// <summary>Get the position of the left-top corner of the view bounds.</summary>
				/// <returns>The view position.</returns>
				Point									GetViewPosition();
				/// <summary>Set the position of the left-top corner of the view bounds.</summary>
				/// <param name="value">The position.</param>
				void									SetViewPosition(Point value);
				
				/// <summary>Get the horizontal scroll control.</summary>
				/// <returns>The horizontal scroll control.</returns>
				GuiScroll*								GetHorizontalScroll();
				/// <summary>Get the vertical scroll control.</summary>
				/// <returns>The vertical scroll control.</returns>
				GuiScroll*								GetVerticalScroll();
				/// <summary>Test is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <returns>Returns true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</returns>
				bool									GetHorizontalAlwaysVisible();
				/// <summary>Set is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <param name="value">Set to true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</param>
				void									SetHorizontalAlwaysVisible(bool value);
				/// <summary>Test is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <returns>Returns true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</returns>
				bool									GetVerticalAlwaysVisible();
				/// <summary>Set is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <param name="value">Set to true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</param>
				void									SetVerticalAlwaysVisible(bool value);
			};
			
			/// <summary>A control container with a vertical scroll bar and a horizontal scroll bar to perform partial viewing. When controls are added, removed, moved or resized, the scroll bars will adjust automatically.</summary>
			class GuiScrollContainer : public GuiScrollView, public Description<GuiScrollContainer>
			{
			protected:
				bool									extendToFullWidth = false;
				bool									extendToFullHeight = false;

				Size									QueryFullSize()override;
				void									UpdateView(Rect viewBounds)override;
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiScrollContainer(theme::ThemeName themeName);
				~GuiScrollContainer();
				
				/// <summary>Test does the content container always extend its width to fill the scroll container.</summary>
				/// <returns>Return true if the content container always extend its width to fill the scroll container.</returns>
				bool									GetExtendToFullWidth();
				/// <summary>Set does the content container always extend its width to fill the scroll container.</summary>
				/// <param name="value">Set to true if the content container always extend its width to fill the scroll container.</param>
				void									SetExtendToFullWidth(bool value);

				/// <summary>Test does the content container always extend its height to fill the scroll container.</summary>
				/// <returns>Return true if the content container always extend its height to fill the scroll container.</returns>
				bool									GetExtendToFullHeight();
				/// <summary>Set does the content container always extend its height to fill the scroll container.</summary>
				/// <param name="value">Set to true if the content container always extend its height to fill the scroll container.</param>
				void									SetExtendToFullHeight(bool value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUIDIALOGS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDIALOGS
#define VCZH_PRESENTATION_CONTROLS_GUIDIALOGS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiWindow;

/***********************************************************************
Dialogs
***********************************************************************/

			/// <summary>Base class for dialogs.</summary>
			class GuiDialogBase abstract : public GuiComponent, public Description<GuiDialogBase>
			{
			protected:
				GuiInstanceRootObject*								rootObject = nullptr;

				GuiWindow*											GetHostWindow();
			public:
				GuiDialogBase();
				~GuiDialogBase();

				void												Attach(GuiInstanceRootObject* _rootObject);
				void												Detach(GuiInstanceRootObject* _rootObject);
			};
			
			/// <summary>Message dialog.</summary>
			class GuiMessageDialog : public GuiDialogBase, public Description<GuiMessageDialog>
			{
			protected:
				INativeDialogService::MessageBoxButtonsInput		input = INativeDialogService::DisplayOK;
				INativeDialogService::MessageBoxDefaultButton		defaultButton = INativeDialogService::DefaultFirst;
				INativeDialogService::MessageBoxIcons				icon = INativeDialogService::IconNone;
				INativeDialogService::MessageBoxModalOptions		modalOption = INativeDialogService::ModalWindow;
				WString												text;
				WString												title;

			public:
				/// <summary>Create a message dialog.</summary>
				GuiMessageDialog();
				~GuiMessageDialog();

				/// <summary>Get the button combination that appear on the dialog.</summary>
				/// <returns>The button combination.</returns>
				INativeDialogService::MessageBoxButtonsInput		GetInput();
				/// <summary>Set the button combination that appear on the dialog.</summary>
				/// <param name="value">The button combination.</param>
				void												SetInput(INativeDialogService::MessageBoxButtonsInput value);
				
				/// <summary>Get the default button for the selected button combination.</summary>
				/// <returns>The default button.</returns>
				INativeDialogService::MessageBoxDefaultButton		GetDefaultButton();
				/// <summary>Set the default button for the selected button combination.</summary>
				/// <param name="value">The default button.</param>
				void												SetDefaultButton(INativeDialogService::MessageBoxDefaultButton value);

				/// <summary>Get the icon that appears on the dialog.</summary>
				/// <returns>The icon.</returns>
				INativeDialogService::MessageBoxIcons				GetIcon();
				/// <summary>Set the icon that appears on the dialog.</summary>
				/// <param name="value">The icon.</param>
				void												SetIcon(INativeDialogService::MessageBoxIcons value);

				/// <summary>Get the way that how this dialog disable windows of the current process.</summary>
				/// <returns>The way that how this dialog disable windows of the current process.</returns>
				INativeDialogService::MessageBoxModalOptions		GetModalOption();
				/// <summary>Set the way that how this dialog disable windows of the current process.</summary>
				/// <param name="value">The way that how this dialog disable windows of the current process.</param>
				void												SetModalOption(INativeDialogService::MessageBoxModalOptions value);

				/// <summary>Get the text for the dialog.</summary>
				/// <returns>The text.</returns>
				const WString&										GetText();
				/// <summary>Set the text for the dialog.</summary>
				/// <param name="value">The text.</param>
				void												SetText(const WString& value);

				/// <summary>Get the title for the dialog.</summary>
				/// <returns>The title.</returns>
				const WString&										GetTitle();
				/// <summary>Set the title for the dialog. If the title is empty, the dialog will use the title of the window that host this dialog.</summary>
				/// <param name="value">The title.</param>
				void												SetTitle(const WString& value);
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns the clicked button.</returns>
				INativeDialogService::MessageBoxButtonsOutput		ShowDialog();
			};
			
			/// <summary>Color dialog.</summary>
			class GuiColorDialog : public GuiDialogBase, public Description<GuiColorDialog>
			{
			protected:
				bool												enabledCustomColor = true;
				bool												openedCustomColor = false;
				Color												selectedColor;
				bool												showSelection = true;
				collections::List<Color>							customColors;

			public:
				/// <summary>Create a color dialog.</summary>
				GuiColorDialog();
				~GuiColorDialog();

				/// <summary>Selected color changed event.</summary>
				compositions::GuiNotifyEvent						SelectedColorChanged;
				
				/// <summary>Get if the custom color panel is enabled for the dialog.</summary>
				/// <returns>Returns true if the color panel is enabled for the dialog.</returns>
				bool												GetEnabledCustomColor();
				/// <summary>Set if custom color panel is enabled for the dialog.</summary>
				/// <param name="value">Set to true to enable the custom color panel for the dialog.</param>
				void												SetEnabledCustomColor(bool value);
				
				/// <summary>Get if the custom color panel is opened by default when it is enabled.</summary>
				/// <returns>Returns true if the custom color panel is opened by default.</returns>
				bool												GetOpenedCustomColor();
				/// <summary>Set if the custom color panel is opened by default when it is enabled.</summary>
				/// <param name="value">Set to true to open custom color panel by default if it is enabled.</param>
				void												SetOpenedCustomColor(bool value);
				
				/// <summary>Get the selected color.</summary>
				/// <returns>The selected color.</returns>
				Color												GetSelectedColor();
				/// <summary>Set the selected color.</summary>
				/// <param name="value">The selected color.</param>
				void												SetSelectedColor(Color value);
				
				/// <summary>Get the list to access 16 selected custom colors on the palette. Colors in the list is guaranteed to have exactly 16 items after the dialog is closed.</summary>
				/// <returns>The list to access custom colors on the palette.</returns>
				collections::List<Color>&							GetCustomColors();
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "OK" button is clicked.</returns>
				bool												ShowDialog();
			};
			
			/// <summary>Font dialog.</summary>
			class GuiFontDialog : public GuiDialogBase, public Description<GuiFontDialog>
			{
			protected:
				FontProperties										selectedFont;
				Color												selectedColor;
				bool												showSelection = true;
				bool												showEffect = true;
				bool												forceFontExist = true;

			public:
				/// <summary>Create a font dialog.</summary>
				GuiFontDialog();
				~GuiFontDialog();

				/// <summary>Selected font changed event.</summary>
				compositions::GuiNotifyEvent						SelectedFontChanged;
				/// <summary>Selected color changed event.</summary>
				compositions::GuiNotifyEvent						SelectedColorChanged;
				
				/// <summary>Get the selected font.</summary>
				/// <returns>The selected font.</returns>
				const FontProperties&								GetSelectedFont();
				/// <summary>Set the selected font.</summary>
				/// <param name="value">The selected font.</param>
				void												SetSelectedFont(const FontProperties& value);
				
				/// <summary>Get the selected color.</summary>
				/// <returns>The selected color.</returns>
				Color												GetSelectedColor();
				/// <summary>Set the selected color.</summary>
				/// <param name="value">The selected color.</param>
				void												SetSelectedColor(Color value);
				
				/// <summary>Get if the selected font is already selected on the dialog when it is opened.</summary>
				/// <returns>Returns true if the selected font is already selected on the dialog when it is opened.</returns>
				bool												GetShowSelection();
				/// <summary>Set if the selected font is already selected on the dialog when it is opened.</summary>
				/// <param name="value">Set to true to select the selected font when the dialog is opened.</param>
				void												SetShowSelection(bool value);
				
				/// <summary>Get if the font preview is enabled.</summary>
				/// <returns>Returns true if the font preview is enabled.</returns>
				bool												GetShowEffect();
				/// <summary>Set if the font preview is enabled.</summary>
				/// <param name="value">Set to true to enable the font preview.</param>
				void												SetShowEffect(bool value);
				
				/// <summary>Get if the dialog only accepts an existing font.</summary>
				/// <returns>Returns true if the dialog only accepts an existing font.</returns>
				bool												GetForceFontExist();
				/// <summary>Set if the dialog only accepts an existing font.</summary>
				/// <param name="value">Set to true to let the dialog only accept an existing font.</param>
				void												SetForceFontExist(bool value);
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "OK" button is clicked.</returns>
				bool												ShowDialog();
			};
			
			/// <summary>Base class for file dialogs.</summary>
			class GuiFileDialogBase abstract : public GuiDialogBase, public Description<GuiFileDialogBase>
			{
			protected:
				WString												filter = L"All Files (*.*)|*.*";
				vint												filterIndex = 0;
				bool												enabledPreview = false;
				WString												title;
				WString												fileName;
				WString												directory;
				WString												defaultExtension;
				INativeDialogService::FileDialogOptions				options;

			public:
				GuiFileDialogBase();
				~GuiFileDialogBase();

				/// <summary>File name changed event.</summary>
				compositions::GuiNotifyEvent						FileNameChanged;
				/// <summary>Filter index changed event.</summary>
				compositions::GuiNotifyEvent						FilterIndexChanged;
				
				/// <summary>Get the filter.</summary>
				/// <returns>The filter.</returns>
				const WString&										GetFilter();
				/// <summary>Set the filter. The filter is formed by pairs of filter name and wildcard concatenated by "|", like "Text Files (*.txt)|*.txt|All Files (*.*)|*.*".</summary>
				/// <param name="value">The filter.</param>
				void												SetFilter(const WString& value);
				
				/// <summary>Get the filter index.</summary>
				/// <returns>The filter index.</returns>
				vint												GetFilterIndex();
				/// <summary>Set the filter index.</summary>
				/// <param name="value">The filter index.</param>
				void												SetFilterIndex(vint value);
				
				/// <summary>Get if the file preview is enabled.</summary>
				/// <returns>Returns true if the file preview is enabled.</returns>
				bool												GetEnabledPreview();
				/// <summary>Set if the file preview is enabled.</summary>
				/// <param name="value">Set to true to enable the file preview.</param>
				void												SetEnabledPreview(bool value);
				
				/// <summary>Get the title.</summary>
				/// <returns>The title.</returns>
				WString												GetTitle();
				/// <summary>Set the title.</summary>
				/// <param name="value">The title.</param>
				void												SetTitle(const WString& value);
				
				/// <summary>Get the selected file name.</summary>
				/// <returns>The selected file name.</returns>
				WString												GetFileName();
				/// <summary>Set the selected file name.</summary>
				/// <param name="value">The selected file name.</param>
				void												SetFileName(const WString& value);
				
				/// <summary>Get the default folder.</summary>
				/// <returns>The default folder.</returns>
				WString												GetDirectory();
				/// <summary>Set the default folder.</summary>
				/// <param name="value">The default folder.</param>
				void												SetDirectory(const WString& value);
				
				/// <summary>Get the default file extension.</summary>
				/// <returns>The default file extension.</returns>
				WString												GetDefaultExtension();
				/// <summary>Set the default file extension like "txt". If the user does not specify a file extension, the default file extension will be appended using "." after the file name.</summary>
				/// <param name="value">The default file extension.</param>
				void												SetDefaultExtension(const WString& value);
				
				/// <summary>Get the dialog options.</summary>
				/// <returns>The dialog options.</returns>
				INativeDialogService::FileDialogOptions				GetOptions();
				/// <summary>Set the dialog options.</summary>
				/// <param name="value">The dialog options.</param>
				void												SetOptions(INativeDialogService::FileDialogOptions value);
			};
			
			/// <summary>Open file dialog.</summary>
			class GuiOpenFileDialog : public GuiFileDialogBase, public Description<GuiOpenFileDialog>
			{
			protected:
				collections::List<WString>							fileNames;

			public:
				/// <summary>Create a open file dialog.</summary>
				GuiOpenFileDialog();
				~GuiOpenFileDialog();
				
				/// <summary>Get the list to access multiple selected file names.</summary>
				/// <returns>The list to access multiple selected file names.</returns>
				collections::List<WString>&							GetFileNames();
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "Open" button is clicked.</returns>
				bool												ShowDialog();
			};
			
			/// <summary>Save file dialog.</summary>
			class GuiSaveFileDialog : public GuiFileDialogBase, public Description<GuiSaveFileDialog>
			{
			public:
				/// <summary>Create a save file dialog.</summary>
				GuiSaveFileDialog();
				~GuiSaveFileDialog();

				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "Save" button is clicked.</returns>
				bool												ShowDialog();
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace templates
		{
			class GuiListItemTemplate;
		}

		namespace controls
		{

/***********************************************************************
List Control
***********************************************************************/

			/// <summary>Represents a list control. A list control automatically read data sources and creates corresponding data item control from the item template.</summary>
			class GuiListControl : public GuiScrollView, public Description<GuiListControl>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ListControlTemplate, GuiScrollView)
			public:
				class IItemProvider;

				using ItemStyle = templates::GuiListItemTemplate;
				using ItemStyleProperty = TemplateProperty<templates::GuiListItemTemplate>;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				/// <summary>Item provider callback. Item providers use this interface to notify item modification.</summary>
				class IItemProviderCallback : public virtual IDescriptable, public Description<IItemProviderCallback>
				{
				public:
					/// <summary>Called when an item provider callback object is attached to an item provider.</summary>
					/// <param name="provider">The item provider.</param>
					virtual void								OnAttached(IItemProvider* provider)=0;
					/// <summary>Called when items in the item provider is modified.</summary>
					/// <param name="start">The index of the first modified item.</param>
					/// <param name="count">The number of all modified items.</param>
					/// <param name="newCount">The number of new items. If items are inserted or removed, newCount may not equals to count.</param>
					virtual void								OnItemModified(vint start, vint count, vint newCount)=0;
				};

				/// <summary>Item arranger callback. Item arrangers use this interface to communicate with the list control. When setting positions for item controls, functions in this callback object is suggested to call because they use the result from the [T:vl.presentation.controls.compositions.IGuiAxis].</summary>
				class IItemArrangerCallback : public virtual IDescriptable, public Description<IItemArrangerCallback>
				{
				public:
					/// <summary>Request an item control representing an item in the item provider. This function is suggested to call when an item control gets into the visible area.</summary>
					/// <returns>The item control.</returns>
					/// <param name="itemIndex">The index of the item in the item provider.</param>
					/// <param name="itemComposition">The composition that represents the item. Set to null if the item style is expected to be put directly into the list control.</param>
					virtual ItemStyle*								RequestItem(vint itemIndex, compositions::GuiBoundsComposition* itemComposition)=0;
					/// <summary>Release an item control. This function is suggested to call when an item control gets out of the visible area.</summary>
					/// <param name="style">The item control.</param>
					virtual void									ReleaseItem(ItemStyle* style)=0;
					/// <summary>Update the view location. The view location is the left-top position in the logic space of the list control.</summary>
					/// <param name="value">The new view location.</param>
					virtual void									SetViewLocation(Point value)=0;
					/// <summary>Get the preferred size of an item control.</summary>
					/// <returns>The preferred size of an item control.</returns>
					/// <param name="style">The item control.</param>
					virtual Size									GetStylePreferredSize(compositions::GuiBoundsComposition* style)=0;
					/// <summary>Set the alignment of an item control.</summary>
					/// <param name="style">The item control.</param>
					/// <param name="margin">The new alignment.</param>
					virtual void									SetStyleAlignmentToParent(compositions::GuiBoundsComposition* style, Margin margin)=0;
					/// <summary>Get the bounds of an item control.</summary>
					/// <returns>The bounds of an item control.</returns>
					/// <param name="style">The item control.</param>
					virtual Rect									GetStyleBounds(compositions::GuiBoundsComposition* style)=0;
					/// <summary>Set the bounds of an item control.</summary>
					/// <param name="style">The item control.</param>
					/// <param name="bounds">The new bounds.</param>
					virtual void									SetStyleBounds(compositions::GuiBoundsComposition* style, Rect bounds)=0;
					/// <summary>Get the <see cref="compositions::GuiGraphicsComposition"/> that directly contains item controls.</summary>
					/// <returns>The <see cref="compositions::GuiGraphicsComposition"/> that directly contains item controls.</returns>
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					/// <summary>Notify the list control that the total size of all item controls are changed.</summary>
					virtual void									OnTotalSizeChanged()=0;
				};

				//-----------------------------------------------------------
				// Data Source Interfaces
				//-----------------------------------------------------------

				/// <summary>Item provider for a <see cref="GuiListControl"/>.</summary>
				class IItemProvider : public virtual IDescriptable, public Description<IItemProvider>
				{
				public:
					/// <summary>Attach an item provider callback to this item provider.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The item provider callback.</param>
					virtual bool								AttachCallback(IItemProviderCallback* value) = 0;
					/// <summary>Detach an item provider callback from this item provider.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The item provider callback.</param>
					virtual bool								DetachCallback(IItemProviderCallback* value) = 0;
					/// <summary>Increase the editing counter indicating that an [T:vl.presentation.templates.GuiListItemTemplate] is editing an item.</summary>
					virtual void								PushEditing() = 0;
					/// <summary>Decrease the editing counter indicating that an [T:vl.presentation.templates.GuiListItemTemplate] has stopped editing an item.</summary>
					/// <returns>Returns false if there is no supression before calling this function.</returns>
					virtual bool								PopEditing() = 0;
					/// <summary>Test if an [T:vl.presentation.templates.GuiListItemTemplate] is editing an item.</summary>
					/// <returns>Returns false if there is no editing.</returns>
					virtual bool								IsEditing() = 0;
					/// <summary>Get the number of items in this item proivder.</summary>
					/// <returns>The number of items in this item proivder.</returns>
					virtual vint								Count() = 0;

					/// <summary>Get the text representation of an item.</summary>
					/// <returns>The text representation of an item.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual WString								GetTextValue(vint itemIndex) = 0;
					/// <summary>Get the binding value of an item.</summary>
					/// <returns>The binding value of an item.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual description::Value					GetBindingValue(vint itemIndex) = 0;

					/// <summary>Request a view for this item provider. If the specified view is not supported, it returns null. If you want to get a view of type IXXX, use IXXX::Identifier as the identifier.</summary>
					/// <returns>The view object.</returns>
					/// <param name="identifier">The identifier for the requested view.</param>
					virtual IDescriptable*						RequestView(const WString& identifier) = 0;
				};

				//-----------------------------------------------------------
				// Item Layout Interfaces
				//-----------------------------------------------------------

				/// <summary>EnsureItemVisible result for item arranger.</summary>
				enum class EnsureItemVisibleResult
				{
					/// <summary>The requested item does not exist.</summary>
					ItemNotExists,
					/// <summary>The view location is moved.</summary>
					Moved,
					/// <summary>The view location is not moved.</summary>
					NotMoved,
				};
				
				/// <summary>Item arranger for a <see cref="GuiListControl"/>. Item arranger decides how to arrange and item controls. When implementing an item arranger, <see cref="IItemArrangerCallback"/> is suggested to use when calculating locations and sizes for item controls.</summary>
				class IItemArranger : public virtual IItemProviderCallback, public Description<IItemArranger>
				{
				public:
					/// <summary>Called when an item arranger in installed to a <see cref="GuiListControl"/>.</summary>
					/// <param name="value">The list control.</param>
					virtual void								AttachListControl(GuiListControl* value) = 0;
					/// <summary>Called when an item arranger in uninstalled from a <see cref="GuiListControl"/>.</summary>
					virtual void								DetachListControl() = 0;
					/// <summary>Get the binded item arranger callback object.</summary>
					/// <returns>The binded item arranger callback object.</returns>
					virtual IItemArrangerCallback*				GetCallback() = 0;
					/// <summary>Bind the item arranger callback object.</summary>
					/// <param name="value">The item arranger callback object to bind.</param>
					virtual void								SetCallback(IItemArrangerCallback* value) = 0;
					/// <summary>Get the total size of all data controls.</summary>
					/// <returns>The total size.</returns>
					virtual Size								GetTotalSize() = 0;
					/// <summary>Get the item style controller for an visible item index. If an item is not visible, it returns null.</summary>
					/// <returns>The item style controller.</returns>
					/// <param name="itemIndex">The item index.</param>
					virtual ItemStyle*							GetVisibleStyle(vint itemIndex) = 0;
					/// <summary>Get the item index for an visible item style controller. If an item is not visible, it returns -1.</summary>
					/// <returns>The item index.</returns>
					/// <param name="style">The item style controller.</param>
					virtual vint								GetVisibleIndex(ItemStyle* style) = 0;
					/// <summary>Reload all visible items.</summary>
					virtual void								ReloadVisibleStyles() = 0;
					/// <summary>Called when the visible area of item container is changed.</summary>
					/// <param name="bounds">The new visible area.</param>
					virtual void								OnViewChanged(Rect bounds) = 0;
					/// <summary>Find the item by an base item and a key direction.</summary>
					/// <returns>The item index that is found. Returns -1 if this operation failed.</returns>
					/// <param name="itemIndex">The base item index.</param>
					/// <param name="key">The key direction.</param>
					virtual vint								FindItem(vint itemIndex, compositions::KeyDirection key) = 0;
					/// <summary>Adjust the view location to make an item visible.</summary>
					/// <returns>Returns the result of this operation.</returns>
					/// <param name="itemIndex">The item index of the item to be made visible.</param>
					virtual EnsureItemVisibleResult				EnsureItemVisible(vint itemIndex) = 0;
					/// <summary>Get the adopted size for the view bounds.</summary>
					/// <returns>The adopted size, making the vids bounds just enough to display several items.</returns>
					/// <param name="expectedSize">The expected size, to provide a guidance.</param>
					virtual Size								GetAdoptedSize(Size expectedSize) = 0;
				};

			protected:

				//-----------------------------------------------------------
				// ItemCallback
				//-----------------------------------------------------------

				class ItemCallback : public IItemProviderCallback, public IItemArrangerCallback
				{
					typedef compositions::IGuiGraphicsEventHandler							BoundsChangedHandler;
					typedef collections::List<ItemStyle*>									StyleList;
					typedef collections::Dictionary<ItemStyle*, Ptr<BoundsChangedHandler>>	InstalledStyleMap;
				protected:
					GuiListControl*								listControl = nullptr;
					IItemProvider*								itemProvider = nullptr;
					InstalledStyleMap							installedStyles;

					Ptr<BoundsChangedHandler>					InstallStyle(ItemStyle* style, vint itemIndex, compositions::GuiBoundsComposition* itemComposition);
					ItemStyle*									UninstallStyle(vint index);
					void										OnStyleBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					ItemCallback(GuiListControl* _listControl);
					~ItemCallback();

					void										ClearCache();

					void										OnAttached(IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount)override;
					ItemStyle*									RequestItem(vint itemIndex, compositions::GuiBoundsComposition* itemComposition)override;
					void										ReleaseItem(ItemStyle* style)override;
					void										SetViewLocation(Point value)override;
					Size										GetStylePreferredSize(compositions::GuiBoundsComposition* style)override;
					void										SetStyleAlignmentToParent(compositions::GuiBoundsComposition* style, Margin margin)override;
					Rect										GetStyleBounds(compositions::GuiBoundsComposition* style)override;
					void										SetStyleBounds(compositions::GuiBoundsComposition* style, Rect bounds)override;
					compositions::GuiGraphicsComposition*		GetContainerComposition()override;
					void										OnTotalSizeChanged()override;
				};

				//-----------------------------------------------------------
				// State management
				//-----------------------------------------------------------

				Ptr<ItemCallback>								callback;
				Ptr<IItemProvider>								itemProvider;
				ItemStyleProperty								itemStyleProperty;
				Ptr<IItemArranger>								itemArranger;
				Ptr<compositions::IGuiAxis>						axis;
				Size											fullSize;
				bool											displayItemBackground = true;

				virtual void									OnItemModified(vint start, vint count, vint newCount);
				virtual void									OnStyleInstalled(vint itemIndex, ItemStyle* style);
				virtual void									OnStyleUninstalled(ItemStyle* style);
				
				void											OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void											OnBeforeReleaseGraphicsHost()override;
				Size											QueryFullSize()override;
				void											UpdateView(Rect viewBounds)override;
				
				void											OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											SetStyleAndArranger(ItemStyleProperty styleProperty, Ptr<IItemArranger> arranger);

				//-----------------------------------------------------------
				// Item event management
				//-----------------------------------------------------------

				class VisibleStyleHelper
				{
				public:
					Ptr<compositions::IGuiGraphicsEventHandler>		leftButtonDownHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		leftButtonUpHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		leftButtonDoubleClickHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		middleButtonDownHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		middleButtonUpHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		middleButtonDoubleClickHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		rightButtonDownHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		rightButtonUpHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		rightButtonDoubleClickHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		mouseMoveHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		mouseEnterHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		mouseLeaveHandler;
				};
				
				friend class collections::ArrayBase<Ptr<VisibleStyleHelper>>;
				collections::Dictionary<ItemStyle*, Ptr<VisibleStyleHelper>>		visibleStyles;

				void											UpdateDisplayFont()override;
				void											OnClientBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnVisuallyEnabledChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnContextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnItemMouseEvent(compositions::GuiItemMouseEvent& itemEvent, ItemStyle* style, compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											OnItemNotifyEvent(compositions::GuiItemNotifyEvent& itemEvent, ItemStyle* style, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											AttachItemEvents(ItemStyle* style);
				void											DetachItemEvents(ItemStyle* style);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider as a data source.</param>
				/// <param name="acceptFocus">Set to true if the list control is allowed to have a keyboard focus.</param>
				GuiListControl(theme::ThemeName themeName, IItemProvider* _itemProvider, bool acceptFocus=false);
				~GuiListControl();

				/// <summary>Style provider changed event.</summary>
				compositions::GuiNotifyEvent					ItemTemplateChanged;
				/// <summary>Arranger changed event.</summary>
				compositions::GuiNotifyEvent					ArrangerChanged;
				/// <summary>Coordinate transformer changed event.</summary>
				compositions::GuiNotifyEvent					AxisChanged;
				/// <summary>Adopted size invalidated.</summary>
				compositions::GuiNotifyEvent					AdoptedSizeInvalidated;

				/// <summary>Item left mouse button down event.</summary>
				compositions::GuiItemMouseEvent					ItemLeftButtonDown;
				/// <summary>Item left mouse button up event.</summary>
				compositions::GuiItemMouseEvent					ItemLeftButtonUp;
				/// <summary>Item left mouse button double click event.</summary>
				compositions::GuiItemMouseEvent					ItemLeftButtonDoubleClick;
				/// <summary>Item middle mouse button down event.</summary>
				compositions::GuiItemMouseEvent					ItemMiddleButtonDown;
				/// <summary>Item middle mouse button up event.</summary>
				compositions::GuiItemMouseEvent					ItemMiddleButtonUp;
				/// <summary>Item middle mouse button double click event.</summary>
				compositions::GuiItemMouseEvent					ItemMiddleButtonDoubleClick;
				/// <summary>Item right mouse button down event.</summary>
				compositions::GuiItemMouseEvent					ItemRightButtonDown;
				/// <summary>Item right mouse button up event.</summary>
				compositions::GuiItemMouseEvent					ItemRightButtonUp;
				/// <summary>Item right mouse button double click event.</summary>
				compositions::GuiItemMouseEvent					ItemRightButtonDoubleClick;
				/// <summary>Item mouse move event.</summary>
				compositions::GuiItemMouseEvent					ItemMouseMove;
				/// <summary>Item mouse enter event.</summary>
				compositions::GuiItemNotifyEvent				ItemMouseEnter;
				/// <summary>Item mouse leave event.</summary>
				compositions::GuiItemNotifyEvent				ItemMouseLeave;

				/// <summary>Get the item provider.</summary>
				/// <returns>The item provider.</returns>
				virtual IItemProvider*							GetItemProvider();
				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				virtual ItemStyleProperty						GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				virtual void									SetItemTemplate(ItemStyleProperty value);
				/// <summary>Get the item arranger.</summary>
				/// <returns>The item arranger.</returns>
				virtual IItemArranger*							GetArranger();
				/// <summary>Set the item arranger</summary>
				/// <param name="value">The new item arranger</param>
				virtual void									SetArranger(Ptr<IItemArranger> value);
				/// <summary>Get the item coordinate transformer.</summary>
				/// <returns>The item coordinate transformer.</returns>
				virtual compositions::IGuiAxis*					GetAxis();
				/// <summary>Set the item coordinate transformer</summary>
				/// <param name="value">The new item coordinate transformer</param>
				virtual void									SetAxis(Ptr<compositions::IGuiAxis> value);
				/// <summary>Adjust the view location to make an item visible.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="itemIndex">The item index of the item to be made visible.</param>
				virtual bool									EnsureItemVisible(vint itemIndex);
				/// <summary>Get the adopted size for the list control.</summary>
				/// <returns>The adopted size, making the list control just enough to display several items.</returns>
				/// <param name="expectedSize">The expected size, to provide a guidance.</param>
				virtual Size									GetAdoptedSize(Size expectedSize);
				/// <summary>Test if the list control displays predefined item background.</summary>
				/// <returns>Returns true if the list control displays predefined item background.</returns>
				bool											GetDisplayItemBackground();
				/// <summary>Set if the list control displays predefined item background.</summary>
				/// <param name="value">Set to true to display item background.</param>
				void											SetDisplayItemBackground(bool value);
			};

/***********************************************************************
Selectable List Control
***********************************************************************/

			/// <summary>Represents a list control that each item is selectable.</summary>
			class GuiSelectableListControl : public GuiListControl, public Description<GuiSelectableListControl>
			{
			protected:

				collections::SortedList<vint>					selectedItems;
				bool											multiSelect;
				vint											selectedItemIndexStart;
				vint											selectedItemIndexEnd;

				void											NotifySelectionChanged();
				void											OnItemModified(vint start, vint count, vint newCount)override;
				void											OnStyleInstalled(vint itemIndex, ItemStyle* style)override;
				virtual void									OnItemSelectionChanged(vint itemIndex, bool value);
				virtual void									OnItemSelectionCleared();
				void											OnItemLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void											OnItemRightButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);

				void											NormalizeSelectedItemIndexStartEnd();
				void											SetMultipleItemsSelectedSilently(vint start, vint end, bool selected);
				void											OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider as a data source.</param>
				GuiSelectableListControl(theme::ThemeName themeName, IItemProvider* _itemProvider);
				~GuiSelectableListControl();

				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent					SelectionChanged;

				/// <summary>Get the multiple selection mode.</summary>
				/// <returns>Returns true if multiple selection is enabled.</returns>
				bool											GetMultiSelect();
				/// <summary>Set the multiple selection mode.</summary>
				/// <param name="value">Set to true to enable multiple selection.</param>
				void											SetMultiSelect(bool value);
				
				/// <summary>Get indices of all selected items.</summary>
				/// <returns>Indices of all selected items.</returns>
				const collections::SortedList<vint>&			GetSelectedItems();
				/// <summary>Get the index of the selected item.</summary>
				/// <returns>Returns the index of the selected item. If there are multiple selected items, or there is no selected item, -1 will be returned.</returns>
				vint											GetSelectedItemIndex();
				/// <summary>Get the text of the selected item.</summary>
				/// <returns>Returns the text of the selected item. If there are multiple selected items, or there is no selected item, an empty string will be returned.</returns>
				WString											GetSelectedItemText();

				/// <summary>Get the selection status of an item.</summary>
				/// <returns>The selection status of an item.</returns>
				/// <param name="itemIndex">The index of the item.</param>
				bool											GetSelected(vint itemIndex);
				/// <summary>Set the selection status of an item.</summary>
				/// <param name="itemIndex">The index of the item.</param>
				/// <param name="value">Set to true to select the item.</param>
				void											SetSelected(vint itemIndex, bool value);
				/// <summary>Set the selection status of an item, and affect other selected item according to key status.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="itemIndex">The index of the item.</param>
				/// <param name="ctrl">Set to true if the control key is pressing.</param>
				/// <param name="shift">Set to true if the shift key is pressing.</param>
				/// <param name="leftButton">Set to true if clicked by left mouse button, otherwise right mouse button.</param>
				bool											SelectItemsByClick(vint itemIndex, bool ctrl, bool shift, bool leftButton);
				/// <summary>Set the selection status using keys.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="code">The key code that is pressing.</param>
				/// <param name="ctrl">Set to true if the control key is pressing.</param>
				/// <param name="shift">Set to true if the shift key is pressing.</param>
				bool											SelectItemsByKey(VKEY code, bool ctrl, bool shift);
				/// <summary>Unselect all items.</summary>
				void											ClearSelection();
			};

/***********************************************************************
Predefined ItemProvider
***********************************************************************/

			namespace list
			{
				/// <summary>Item provider base. This class provider common functionalities for item providers.</summary>
				class ItemProviderBase : public Object, public virtual GuiListControl::IItemProvider, public Description<ItemProviderBase>
				{
				protected:
					collections::List<GuiListControl::IItemProviderCallback*>	callbacks;
					vint														editingCounter = 0;
					bool														callingOnItemModified = false;

					virtual void								InvokeOnItemModified(vint start, vint count, vint newCount);
				public:
					/// <summary>Create the item provider.</summary>
					ItemProviderBase();
					~ItemProviderBase();

					bool										AttachCallback(GuiListControl::IItemProviderCallback* value)override;
					bool										DetachCallback(GuiListControl::IItemProviderCallback* value)override;
					void										PushEditing()override;
					bool										PopEditing()override;
					bool										IsEditing()override;
				};

				template<typename T>
				class ListProvider : public ItemProviderBase, public collections::ObservableListBase<T>
				{
				protected:
					void NotifyUpdateInternal(vint start, vint count, vint newCount)override
					{
						InvokeOnItemModified(start, count, newCount);
					}
				public:
					vint Count()override
					{
						return this->items.Count();
					}
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUITEXTLISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualTextList;
			class GuiTextList;

			namespace list
			{

/***********************************************************************
DefaultTextListItemTemplate
***********************************************************************/

				/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for <see cref="GuiVirtualTextList"/>.</summary>
				class ITextItemView : public virtual IDescriptable, public Description<ITextItemView>
				{
				public:
					/// <summary>The identifier for this view.</summary>
					static const wchar_t* const				Identifier;

					/// <summary>Get the check state of an item.</summary>
					/// <returns>The check state of an item.</returns>
					/// <param name="itemIndex">The index of an item.</param>
					virtual bool							GetChecked(vint itemIndex) = 0;
					/// <summary>Set the check state of an item without invoving any UI action.</summary>
					/// <param name="itemIndex">The index of an item.</param>
					/// <param name="value">The new check state.</param>
					virtual void							SetChecked(vint itemIndex, bool value) = 0;
				};

				class DefaultTextListItemTemplate : public templates::GuiTextListItemTemplate
				{
				protected:
					using BulletStyle = templates::GuiControlTemplate;

					GuiSelectableButton*					bulletButton = nullptr;
					elements::GuiSolidLabelElement*			textElement = nullptr;
					bool									supressEdit = false;

					virtual TemplateProperty<BulletStyle>	CreateBulletStyle();
					void									OnInitialize()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnCheckedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DefaultTextListItemTemplate();
					~DefaultTextListItemTemplate();
				};

				class DefaultCheckTextListItemTemplate : public DefaultTextListItemTemplate
				{
				protected:
					TemplateProperty<BulletStyle>			CreateBulletStyle()override;
				public:
				};

				class DefaultRadioTextListItemTemplate : public DefaultTextListItemTemplate
				{
				protected:
					TemplateProperty<BulletStyle>			CreateBulletStyle()override;
				public:
				};

/***********************************************************************
TextItemProvider
***********************************************************************/

				class TextItemProvider;

				/// <summary>Text item. This is the item data structure for [T:vl.presentation.controls.list.TextItemProvider].</summary>
				class TextItem : public Object, public Description<TextItem>
				{
					friend class TextItemProvider;
				protected:
					TextItemProvider*							owner;
					WString										text;
					bool										checked;

				public:
					/// <summary>Create an empty text item.</summary>
					TextItem();
					/// <summary>Create a text item with specified text and check state.</summary>
					/// <param name="_text">The text.</param>
					/// <param name="_checked">The check state.</param>
					TextItem(const WString& _text, bool _checked=false);
					~TextItem();

					bool										operator==(const TextItem& value)const;
					bool										operator!=(const TextItem& value)const;
					
					/// <summary>Get the text of this item.</summary>
					/// <returns>The text of this item.</returns>
					const WString&								GetText();
					/// <summary>Set the text of this item.</summary>
					/// <param name="value">The text of this item.</param>
					void										SetText(const WString& value);

					/// <summary>Get the check state of this item.</summary>
					/// <returns>The check state of this item.</returns>
					bool										GetChecked();
					/// <summary>Set the check state of this item.</summary>
					/// <param name="value">The check state of this item.</param>
					void										SetChecked(bool value);
				};

				/// <summary>Item provider for <see cref="GuiVirtualTextList"/> or <see cref="GuiSelectableListControl"/>.</summary>
				class TextItemProvider
					: public ListProvider<Ptr<TextItem>>
					, protected ITextItemView
					, public Description<TextItemProvider>
				{
					friend class TextItem;
					friend class vl::presentation::controls::GuiTextList;
				protected:
					GuiTextList*								listControl;

					void										AfterInsert(vint item, const Ptr<TextItem>& value)override;
					void										BeforeRemove(vint item, const Ptr<TextItem>& value)override;

					WString										GetTextValue(vint itemIndex)override;
					description::Value							GetBindingValue(vint itemIndex)override;
					bool										GetChecked(vint itemIndex)override;
					void										SetChecked(vint itemIndex, bool value)override;
				public:
					TextItemProvider();
					~TextItemProvider();

					IDescriptable*								RequestView(const WString& identifier)override;
				};
			}

/***********************************************************************
GuiVirtualTextList
***********************************************************************/

			enum class TextListView
			{
				Text,
				Check,
				Radio,
				Unknown,
			};

			/// <summary>Text list control in virtual mode.</summary>
			class GuiVirtualTextList : public GuiSelectableListControl, public Description<GuiVirtualTextList>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TextListTemplate, GuiSelectableListControl)
			protected:
				TextListView											view = TextListView::Unknown;

				void													OnStyleInstalled(vint itemIndex, ItemStyle* style)override;
				void													OnItemTemplateChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a Text list control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiVirtualTextList(theme::ThemeName themeName, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualTextList();

				/// <summary>Item checked changed event.</summary>
				compositions::GuiItemNotifyEvent						ItemChecked;

				/// <summary>Get the current view.</summary>
				/// <returns>The current view. After [M:vl.presentation.controls.GuiListControl.SetItemTemplate] is called, the current view is reset to Unknown.</returns>
				TextListView											GetView();
				/// <summary>Set the current view.</summary>
				/// <param name="_view">The current view.</param>
				void													SetView(TextListView _view);
			};

/***********************************************************************
GuiTextList
***********************************************************************/
			
			/// <summary>Text list control.</summary>
			class GuiTextList : public GuiVirtualTextList, public Description<GuiTextList>
			{
			protected:
				list::TextItemProvider*									items;
			public:
				/// <summary>Create a Text list control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTextList(theme::ThemeName themeName);
				~GuiTextList();

				/// <summary>Get all text items.</summary>
				/// <returns>All text items.</returns>
				list::TextItemProvider&									GetItems();

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				Ptr<list::TextItem>										GetSelectedItem();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUITREEVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
NodeItemProvider
***********************************************************************/

			namespace tree
			{
				class INodeProvider;
				class INodeRootProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				/// <summary>Callback object for <see cref="INodeProvider"/>. A node will invoke this callback to notify any content modification.</summary>
				class INodeProviderCallback : public virtual IDescriptable, public Description<INodeProviderCallback>
				{
				public:
					/// <summary>Called when this callback is attached to a node root.</summary>
					/// <param name="provider">The root node.</param>
					virtual void					OnAttached(INodeRootProvider* provider)=0;
					/// <summary>Called before sub items of a node are modified.</summary>
					/// <param name="parentNode">The node containing modified sub items.</param>
					/// <param name="start">The index of the first sub item.</param>
					/// <param name="count">The number of sub items to be modified.</param>
					/// <param name="newCount">The new number of modified sub items.</param>
					virtual void					OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)=0;
					/// <summary>Called after sub items of a node are modified.</summary>
					/// <param name="parentNode">The node containing modified sub items.</param>
					/// <param name="start">The index of the first sub item.</param>
					/// <param name="count">The number of sub items to be modified.</param>
					/// <param name="newCount">The new number of modified sub items.</param>
					virtual void					OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)=0;
					/// <summary>Called when a node is expanded.</summary>
					/// <param name="node">The node.</param>
					virtual void					OnItemExpanded(INodeProvider* node)=0;
					/// <summary>Called when a node is collapsed.</summary>
					/// <param name="node">The node.</param>
					virtual void					OnItemCollapsed(INodeProvider* node)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				/// <summary>Represents a node.</summary>
				class INodeProvider : public virtual IDescriptable, public Description<INodeProvider>
				{
				public:
					/// <summary>Get the expanding state of this node.</summary>
					/// <returns>Returns true if this node is expanded.</returns>
					virtual bool					GetExpanding()=0;
					/// <summary>Set the expanding state of this node.</summary>
					/// <param name="value">Set to true to expand this node.</param>
					virtual void					SetExpanding(bool value)=0;
					/// <summary>Calculate the number of total visible nodes of this node. The number of total visible nodes includes the node itself, and all total visible nodes of all visible sub nodes. If this node is collapsed, this number will be 1.</summary>
					/// <returns>The number of total visible nodes.</returns>
					virtual vint					CalculateTotalVisibleNodes()=0;

					/// <summary>Get the number of all sub nodes.</summary>
					/// <returns>The number of all sub nodes.</returns>
					virtual vint					GetChildCount()=0;
					/// <summary>Get the parent node.</summary>
					/// <returns>The parent node.</returns>
					virtual Ptr<INodeProvider>		GetParent()=0;
					/// <summary>Get the instance of a specified sub node.</summary>
					/// <returns>The instance of a specified sub node.</returns>
					/// <param name="index">The index of the sub node.</param>
					virtual Ptr<INodeProvider>		GetChild(vint index)=0;
					/// <summary>Increase the reference counter.</summary>
				};
				
				/// <summary>Represents a root node provider.</summary>
				class INodeRootProvider : public virtual IDescriptable, public Description<INodeRootProvider>
				{
				public:
					/// <summary>Get the instance of the root node.</summary>
					/// <returns>Returns the instance of the root node.</returns>
					virtual Ptr<INodeProvider>		GetRootNode()=0;
					/// <summary>Test does the provider provided an optimized algorithm to get an instance of a node by the index of all visible nodes. If this function returns true, [M:vl.presentation.controls.tree.INodeRootProvider.GetNodeByVisibleIndex] can be used.</summary>
					/// <returns>Returns true if such an algorithm is provided.</returns>
					virtual bool					CanGetNodeByVisibleIndex()=0;
					/// <summary>Get a node by the index in all visible nodes. This requires [M:vl.presentation.controls.tree.INodeRootProvider.CanGetNodeByVisibleIndex] returning true.</summary>
					/// <returns>The node for the index in all visible nodes.</returns>
					/// <param name="index">The index in all visible nodes.</param>
					virtual Ptr<INodeProvider>		GetNodeByVisibleIndex(vint index)=0;
					/// <summary>Attach an node provider callback to this node provider.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The node provider callback.</param>
					virtual bool					AttachCallback(INodeProviderCallback* value)=0;
					/// <summary>Detach an node provider callback from this node provider.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The node provider callback.</param>
					virtual bool					DetachCallback(INodeProviderCallback* value)=0;
					/// <summary>Get the primary text of a node.</summary>
					/// <returns>The primary text of a node.</returns>
					/// <param name="node">The node.</param>
					virtual WString					GetTextValue(INodeProvider* node) = 0;
					/// <summary>Get the binding value of a node.</summary>
					/// <returns>The binding value of a node.</returns>
					/// <param name="node">The node.</param>
					virtual description::Value		GetBindingValue(INodeProvider* node) = 0;
					/// <summary>Request a view for this node provider. If the specified view is not supported, it returns null. If you want to get a view of type IXXX, use IXXX::Identifier as the identifier.</summary>
					/// <returns>The view object.</returns>
					/// <param name="identifier">The identifier for the requested view.</param>
					virtual IDescriptable*			RequestView(const WString& identifier)=0;
				};
			}

			namespace tree
			{
				//-----------------------------------------------------------
				// Tree to ListControl (IItemProvider)
				//-----------------------------------------------------------

				/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for [T:vl.presentation.controls.tree.GuiVirtualTreeView]. [T:vl.presentation.controls.tree.NodeItemProvider] provides this view. In most of the cases, the NodeItemProvider class and this view is not required users to create, or even to touch. [T:vl.presentation.controls.GuiVirtualTreeListControl] already handled all of this.</summary>
				class INodeItemView : public virtual IDescriptable, public Description<INodeItemView>
				{
				public:
					/// <summary>The identifier of this view.</summary>
					static const wchar_t* const		Identifier;

					/// <summary>Get an instance of a node by the index in all visible nodes.</summary>
					/// <returns>The instance of a node by the index in all visible nodes.</returns>
					/// <param name="index">The index in all visible nodes.</param>
					virtual Ptr<INodeProvider>		RequestNode(vint index)=0;
					/// <summary>Get the index in all visible nodes of a node.</summary>
					/// <returns>The index in all visible nodes of a node.</returns>
					/// <param name="node">The node to calculate the index.</param>
					virtual vint					CalculateNodeVisibilityIndex(INodeProvider* node)=0;
				};

				/// <summary>This is a general implementation to convert an <see cref="INodeRootProvider"/> to a <see cref="GuiListControl::IItemProvider"/>.</summary>
				class NodeItemProvider
					: public list::ItemProviderBase
					, protected virtual INodeProviderCallback
					, public virtual INodeItemView
					, public Description<NodeItemProvider>
				{
					typedef collections::Dictionary<INodeProvider*, vint>			NodeIntMap;
				protected:
					Ptr<INodeRootProvider>			root;
					NodeIntMap						offsetBeforeChildModifieds;
					

					Ptr<INodeProvider>				GetNodeByOffset(Ptr<INodeProvider> provider, vint offset);
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
					vint							CalculateNodeVisibilityIndexInternal(INodeProvider* node);
					vint							CalculateNodeVisibilityIndex(INodeProvider* node)override;
					
					Ptr<INodeProvider>				RequestNode(vint index)override;
				public:
					/// <summary>Create an item provider using a node root provider.</summary>
					/// <param name="_root">The node root provider.</param>
					NodeItemProvider(Ptr<INodeRootProvider> _root);
					~NodeItemProvider();
					
					/// <summary>Get the owned node root provider.</summary>
					/// <returns>The node root provider.</returns>
					Ptr<INodeRootProvider>			GetRoot();
					vint							Count()override;
					WString							GetTextValue(vint itemIndex)override;
					description::Value				GetBindingValue(vint itemIndex)override;
					IDescriptable*					RequestView(const WString& identifier)override;
				};
			}

/***********************************************************************
MemoryNodeProvider
***********************************************************************/

			namespace tree
			{
				/// <summary>An in-memory <see cref="INodeProvider"/> implementation.</summary>
				class MemoryNodeProvider
					: public Object
					, public virtual INodeProvider
					, public Description<MemoryNodeProvider>
				{
					typedef collections::List<Ptr<MemoryNodeProvider>> ChildList;
					typedef collections::IEnumerator<Ptr<MemoryNodeProvider>> ChildListEnumerator;

				public:
					class NodeCollection : public collections::ObservableListBase<Ptr<MemoryNodeProvider>>
					{
						friend class MemoryNodeProvider;
					protected:
						vint						offsetBeforeChildModified = 0;
						MemoryNodeProvider*			ownerProvider;

						void						OnBeforeChildModified(vint start, vint count, vint newCount);
						void						OnAfterChildModified(vint start, vint count, vint newCount);
						bool						QueryInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
						bool						QueryRemove(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						BeforeInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						BeforeRemove(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						AfterInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						AfterRemove(vint index, vint count)override;

						NodeCollection();
					public:
					};

				protected:
					MemoryNodeProvider*				parent = nullptr;
					bool							expanding = false;
					vint							childCount = 0;
					vint							totalVisibleNodeCount = 1;
					Ptr<DescriptableObject>			data;
					NodeCollection					children;

					virtual INodeProviderCallback*	GetCallbackProxyInternal();
					void							OnChildTotalVisibleNodesChanged(vint offset);
				public:
					/// <summary>Create a node provider with a data object.</summary>
					/// <param name="_data">The data object.</param>
					MemoryNodeProvider(Ptr<DescriptableObject> _data = nullptr);
					~MemoryNodeProvider();

					/// <summary>Get the data object.</summary>
					/// <returns>The data object.</returns>
					Ptr<DescriptableObject>			GetData();
					/// <summary>Set the data object.</summary>
					/// <param name="value">The data object.</param>
					void							SetData(const Ptr<DescriptableObject>& value);
					/// <summary>Notify that the state in the binded data object is modified.</summary>
					void							NotifyDataModified();
					/// <summary>Get all sub nodes.</summary>
					/// <returns>All sub nodes.</returns>
					NodeCollection&					Children();

					bool							GetExpanding()override;
					void							SetExpanding(bool value)override;
					vint							CalculateTotalVisibleNodes()override;

					vint							GetChildCount()override;
					Ptr<INodeProvider>				GetParent()override;
					Ptr<INodeProvider>				GetChild(vint index)override;
				};

				/// <summary>A general implementation for <see cref="INodeRootProvider"/>.</summary>
				class NodeRootProviderBase : public virtual INodeRootProvider, protected virtual INodeProviderCallback, public Description<NodeRootProviderBase>
				{
					collections::List<INodeProviderCallback*>			callbacks;
				protected:
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
				public:
					/// <summary>Create a node root provider.</summary>
					NodeRootProviderBase();
					~NodeRootProviderBase();
					
					bool							CanGetNodeByVisibleIndex()override;
					Ptr<INodeProvider>				GetNodeByVisibleIndex(vint index)override;
					bool							AttachCallback(INodeProviderCallback* value)override;
					bool							DetachCallback(INodeProviderCallback* value)override;
					IDescriptable*					RequestView(const WString& identifier)override;
				};
				
				/// <summary>An in-memory <see cref="INodeRootProvider"/> implementation.</summary>
				class MemoryNodeRootProvider
					: public MemoryNodeProvider
					, public NodeRootProviderBase
					, public Description<MemoryNodeRootProvider>
				{
				protected:
					INodeProviderCallback*			GetCallbackProxyInternal()override;
				public:
					/// <summary>Create a node root provider.</summary>
					MemoryNodeRootProvider();
					~MemoryNodeRootProvider();

					Ptr<INodeProvider>				GetRootNode()override;
					/// <summary>Get the <see cref="MemoryNodeProvider"/> object from an <see cref="INodeProvider"/> object.</summary>
					/// <returns>The corresponding <see cref="MemoryNodeProvider"/> object.</returns>
					/// <param name="node">The node to get the memory node.</param>
					MemoryNodeProvider*				GetMemoryNode(INodeProvider* node);
				};
			}

/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			/// <summary>Tree list control in virtual node.</summary>
			class GuiVirtualTreeListControl : public GuiSelectableListControl, protected virtual tree::INodeProviderCallback, public Description<GuiVirtualTreeListControl>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TreeViewTemplate, GuiSelectableListControl)
			protected:
				void								OnAttached(tree::INodeRootProvider* provider)override;
				void								OnBeforeItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void								OnAfterItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void								OnItemExpanded(tree::INodeProvider* node)override;
				void								OnItemCollapsed(tree::INodeProvider* node)override;

			protected:
				tree::NodeItemProvider*				nodeItemProvider;
				tree::INodeItemView*				nodeItemView;

				void								OnItemMouseEvent(compositions::GuiNodeMouseEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void								OnItemNotifyEvent(compositions::GuiNodeNotifyEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void								OnNodeLeftButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiNodeMouseEventArgs& arguments);
			public:
				/// <summary>Create a tree list control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_nodeRootProvider">The node root provider for this control.</param>
				GuiVirtualTreeListControl(theme::ThemeName themeName, Ptr<tree::INodeRootProvider> _nodeRootProvider);
				~GuiVirtualTreeListControl();

				/// <summary>Node left mouse button down event.</summary>
				compositions::GuiNodeMouseEvent		NodeLeftButtonDown;
				/// <summary>Node left mouse button up event.</summary>
				compositions::GuiNodeMouseEvent		NodeLeftButtonUp;
				/// <summary>Node left mouse button double click event.</summary>
				compositions::GuiNodeMouseEvent		NodeLeftButtonDoubleClick;
				/// <summary>Node middle mouse button down event.</summary>
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDown;
				/// <summary>Node middle mouse button up event.</summary>
				compositions::GuiNodeMouseEvent		NodeMiddleButtonUp;
				/// <summary>Node middle mouse button double click event.</summary>
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDoubleClick;
				/// <summary>Node right mouse button down event.</summary>
				compositions::GuiNodeMouseEvent		NodeRightButtonDown;
				/// <summary>Node right mouse button up event.</summary>
				compositions::GuiNodeMouseEvent		NodeRightButtonUp;
				/// <summary>Node right mouse button double click event.</summary>
				compositions::GuiNodeMouseEvent		NodeRightButtonDoubleClick;
				/// <summary>Node mouse move event.</summary>
				compositions::GuiNodeMouseEvent		NodeMouseMove;
				/// <summary>Node mouse enter event.</summary>
				compositions::GuiNodeNotifyEvent	NodeMouseEnter;
				/// <summary>Node mouse leave event.</summary>
				compositions::GuiNodeNotifyEvent	NodeMouseLeave;
				/// <summary>Node expanded event.</summary>
				compositions::GuiNodeNotifyEvent	NodeExpanded;
				/// <summary>Node collapsed event.</summary>
				compositions::GuiNodeNotifyEvent	NodeCollapsed;

				/// <summary>Get the <see cref="tree::INodeItemView"/> from the item provider.</summary>
				/// <returns>The <see cref="tree::INodeItemView"/> from the item provider.</returns>
				tree::INodeItemView*				GetNodeItemView();
				/// <summary>Get the binded node root provider.</summary>
				/// <returns>The binded node root provider.</returns>
				tree::INodeRootProvider*			GetNodeRootProvider();
			};

/***********************************************************************
TreeViewItemRootProvider
***********************************************************************/

			namespace tree
			{
				/// <summary>The required <see cref="INodeRootProvider"/> view for [T:vl.presentation.controls.GuiVirtualTreeView].</summary>
				class ITreeViewItemView : public virtual IDescriptable, public Description<ITreeViewItemView>
				{
				public:
					/// <summary>The identifier of this view.</summary>
					static const wchar_t* const		Identifier;

					/// <summary>Get the image of a node.</summary>
					/// <returns>Get the image of a node.</returns>
					/// <param name="node">The node.</param>
					virtual Ptr<GuiImageData>		GetNodeImage(INodeProvider* node)=0;
				};

				/// <summary>A tree view item. This data structure is used in [T:vl.presentation.controls.tree.TreeViewItemRootProvider].</summary>
				class TreeViewItem : public Object, public Description<TreeViewItem>
				{
				public:
					/// <summary>The image of this item.</summary>
					Ptr<GuiImageData>				image;
					/// <summary>The text of this item.</summary>
					WString							text;
					/// <summary>Tag object.</summary>
					description::Value				tag;

					/// <summary>Create a tree view item.</summary>
					TreeViewItem();
					/// <summary>Create a tree view item with specified image and text.</summary>
					/// <param name="_image">The specified image.</param>
					/// <param name="_text">The specified text.</param>
					TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text);
				};

				/// <summary>The default implementation of <see cref="INodeRootProvider"/> for [T:vl.presentation.controls.GuiVirtualTreeView].</summary>
				class TreeViewItemRootProvider
					: public MemoryNodeRootProvider
					, public virtual ITreeViewItemView
					, public Description<TreeViewItemRootProvider>
				{
				protected:

					Ptr<GuiImageData>				GetNodeImage(INodeProvider* node)override;
					WString							GetTextValue(INodeProvider* node)override;
					description::Value				GetBindingValue(INodeProvider* node)override;
				public:
					/// <summary>Create a item root provider.</summary>
					TreeViewItemRootProvider();
					~TreeViewItemRootProvider();

					IDescriptable*					RequestView(const WString& identifier)override;

					/// <summary>Get the <see cref="TreeViewItem"/> object from a node.</summary>
					/// <returns>The <see cref="TreeViewItem"/> object.</returns>
					/// <param name="node">The node to get the tree view item.</param>
					Ptr<TreeViewItem>				GetTreeViewData(INodeProvider* node);
					/// <summary>Set the <see cref="TreeViewItem"/> object to a node.</summary>
					/// <param name="node">The node.</param>
					/// <param name="value">The <see cref="TreeViewItem"/> object.</param>
					void							SetTreeViewData(INodeProvider* node, Ptr<TreeViewItem> value);
					/// <summary>Notify the tree view control that the node is changed. This is required when content in a <see cref="TreeViewItem"/> is modified, but both <see cref="SetTreeViewData"/> or [M:vl.presentation.controls.tree.MemoryNodeProvider.SetData] are not called.</summary>
					/// <param name="node">The node.</param>
					void							UpdateTreeViewData(INodeProvider* node);
				};
			}

/***********************************************************************
GuiVirtualTreeView
***********************************************************************/
			
			/// <summary>Tree view control in virtual mode.</summary>
			class GuiVirtualTreeView : public GuiVirtualTreeListControl, public Description<GuiVirtualTreeView>
			{
			protected:
				tree::ITreeViewItemView*								treeViewItemView = nullptr;

				templates::GuiTreeItemTemplate*							GetStyleFromNode(tree::INodeProvider* node);
				void													SetStyleExpanding(tree::INodeProvider* node, bool expanding);
				void													SetStyleExpandable(tree::INodeProvider* node, bool expandable);
				void													OnAfterItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void													OnItemExpanded(tree::INodeProvider* node)override;
				void													OnItemCollapsed(tree::INodeProvider* node)override;
				void													OnStyleInstalled(vint itemIndex, ItemStyle* style)override;
			public:
				/// <summary>Create a tree view control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_nodeRootProvider">The node root provider for this control.</param>
				GuiVirtualTreeView(theme::ThemeName themeName, Ptr<tree::INodeRootProvider> _nodeRootProvider);
				~GuiVirtualTreeView();
			};

/***********************************************************************
GuiTreeView
***********************************************************************/
			
			/// <summary>Tree view control.</summary>
			class GuiTreeView : public GuiVirtualTreeView, public Description<GuiTreeView>
			{
			protected:
				Ptr<tree::TreeViewItemRootProvider>						nodes;
			public:
				/// <summary>Create a tree view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTreeView(theme::ThemeName themeName);
				~GuiTreeView();

				/// <summary>Get the <see cref="tree::TreeViewItemRootProvider"/> as a node root providerl.</summary>
				/// <returns>The <see cref="tree::TreeViewItemRootProvider"/> as a node root provider.</returns>
				Ptr<tree::TreeViewItemRootProvider>						Nodes();

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				Ptr<tree::TreeViewItem>									GetSelectedItem();
			};

/***********************************************************************
DefaultTreeItemTemplate
***********************************************************************/

			namespace tree
			{
				class DefaultTreeItemTemplate : public templates::GuiTreeItemTemplate
				{
				protected:
					GuiSelectableButton*					expandingButton = nullptr;
					compositions::GuiTableComposition*		table = nullptr;
					elements::GuiImageFrameElement*			imageElement = nullptr;
					elements::GuiSolidLabelElement*			textElement = nullptr;

					void									OnInitialize()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnExpandingChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnExpandableChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnLevelChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnImageChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void									OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DefaultTreeItemTemplate();
					~DefaultTreeItemTemplate();
				};
			}
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::tree::MemoryNodeProvider>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIMENUCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Menu Service
***********************************************************************/

			class GuiMenu;

			/// <summary>IGuiMenuService is a required service for menu item container.</summary>
			class IGuiMenuService : public virtual IDescriptable, public Description<IGuiMenuService>
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				/// <summary>Direction to decide the position for a menu with specified control.</summary>
				enum Direction
				{
					/// <summary>Aligned to the top or bottom side.</summary>
					Horizontal,
					/// <summary>Aligned to the left or right side.</summary>
					Vertical,
				};
			protected:
				GuiMenu*								openingMenu;
			public:
				IGuiMenuService();

				/// <summary>Get the parent service. This service represents the parent menu that host the menu item control that contains this menu.</summary>
				/// <returns>The parent service.</returns>
				virtual IGuiMenuService*				GetParentMenuService()=0;
				/// <summary>Get the preferred direction to open the sub menu.</summary>
				/// <returns>The preferred direction to open the sub menu.</returns>
				virtual Direction						GetPreferredDirection()=0;
				/// <summary>Test is this menu is active. When an menu is active, the sub menu is automatically opened when the corresponding menu item is opened.</summary>
				/// <returns>Returns true if this menu is active.</returns>
				virtual bool							IsActiveState()=0;
				/// <summary>Test all sub menu items are actived by mouse down.</summary>
				/// <returns>Returns true if all sub menu items are actived by mouse down.</returns>
				virtual bool							IsSubMenuActivatedByMouseDown()=0;

				/// <summary>Called when the menu item is executed.</summary>
				virtual void							MenuItemExecuted();
				/// <summary>Get the opening sub menu.</summary>
				/// <returns>The opening sub menu.</returns>
				virtual GuiMenu*						GetOpeningMenu();
				/// <summary>Called when the sub menu is opened.</summary>
				/// <param name="menu">The sub menu.</param>
				virtual void							MenuOpened(GuiMenu* menu);
				/// <summary>Called when the sub menu is closed.</summary>
				/// <param name="menu">The sub menu.</param>
				virtual void							MenuClosed(GuiMenu* menu);
			};

			/// <summary>IGuiMenuService is a required service to tell a ribbon group that this control has a dropdown to display.</summary>
			class IGuiMenuDropdownProvider : public virtual IDescriptable, public Description<IGuiMenuDropdownProvider>
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				/// <summary>Get the dropdown to display.</summary>
				/// <returns>The dropdown to display. Returns null to indicate the dropdown cannot be displaied temporary.</returns>
				virtual GuiMenu*						ProvideDropdownMenu() = 0;
			};

/***********************************************************************
Menu
***********************************************************************/

			/// <summary>Popup menu.</summary>
			class GuiMenu : public GuiPopup, protected IGuiMenuService, public Description<GuiMenu>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(MenuTemplate, GuiPopup)
			private:
				IGuiMenuService*						parentMenuService;
				bool									hideOnDeactivateAltHost = true;

				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;
				void									MenuItemExecuted()override;

			protected:
				GuiControl*								owner;

				void									OnDeactivatedAltHost()override;
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
				void									OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_owner">The owner menu item of the parent menu.</param>
				GuiMenu(theme::ThemeName themeName, GuiControl* _owner);
				~GuiMenu();

				/// <summary>Update the reference to the parent <see cref="IGuiMenuService"/>. This function is not required to call outside the menu or menu item control.</summary>
				void									UpdateMenuService();
				IDescriptable*							QueryService(const WString& identifier)override;

				/// <summary>Test if this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</summary>
				/// <returns>Returns true if this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</returns>
				bool									GetHideOnDeactivateAltHost();
				/// <summary>Set if this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</summary>
				/// <param name="value">Set to true to make this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</param>
				void									SetHideOnDeactivateAltHost(bool value);
			};
			
			/// <summary>Menu bar.</summary>
			class GuiMenuBar : public GuiControl, protected IGuiMenuService, public Description<GuiMenuBar>
			{
			private:
				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiMenuBar(theme::ThemeName themeName);
				~GuiMenuBar();
				
				IDescriptable*							QueryService(const WString& identifier)override;
			};

/***********************************************************************
MenuButton
***********************************************************************/

			/// <summary>Menu item.</summary>
			class GuiMenuButton : public GuiSelectableButton, private IGuiMenuDropdownProvider, public Description<GuiMenuButton>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ToolstripButtonTemplate, GuiSelectableButton)

				using IEventHandler = compositions::IGuiGraphicsEventHandler;
			protected:
				Ptr<IEventHandler>						hostClickedHandler;
				Ptr<IEventHandler>						hostMouseEnterHandler;
				Ptr<GuiImageData>						image;
				Ptr<GuiImageData>						largeImage;
				WString									shortcutText;
				GuiMenu*								subMenu;
				bool									ownedSubMenu;
				Size									preferredMenuClientSize;
				IGuiMenuService*						ownerMenuService;
				bool									cascadeAction;

				GuiButton*								GetSubMenuHost();
				bool									OpenSubMenuInternal();
				void									OnParentLineChanged()override;
				compositions::IGuiAltActionHost*		GetActivatingAltHost()override;

				void									OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				virtual IGuiMenuService::Direction		GetSubMenuDirection();

			private:
				GuiMenu*								ProvideDropdownMenu()override;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiMenuButton(theme::ThemeName themeName);
				~GuiMenuButton();

				/// <summary>Before sub menu opening event.</summary>
				compositions::GuiNotifyEvent			BeforeSubMenuOpening;
				/// <summary>After sub menu opening event.</summary>
				compositions::GuiNotifyEvent			AfterSubMenuOpening;
				/// <summary>Sub menu opening changed event.</summary>
				compositions::GuiNotifyEvent			SubMenuOpeningChanged;
				/// <summary>Large image changed event.</summary>
				compositions::GuiNotifyEvent			LargeImageChanged;
				/// <summary>Image changed event.</summary>
				compositions::GuiNotifyEvent			ImageChanged;
				/// <summary>Shortcut text changed event.</summary>
				compositions::GuiNotifyEvent			ShortcutTextChanged;

				/// <summary>Get the large image for the menu button.</summary>
				/// <returns>The large image for the menu button.</returns>
				Ptr<GuiImageData>						GetLargeImage();
				/// <summary>Set the large image for the menu button.</summary>
				/// <param name="value">The large image for the menu button.</param>
				void									SetLargeImage(Ptr<GuiImageData> value);
				/// <summary>Get the image for the menu button.</summary>
				/// <returns>The image for the menu button.</returns>
				Ptr<GuiImageData>						GetImage();
				/// <summary>Set the image for the menu button.</summary>
				/// <param name="value">The image for the menu button.</param>
				void									SetImage(Ptr<GuiImageData> value);
				/// <summary>Get the shortcut key text for the menu button.</summary>
				/// <returns>The shortcut key text for the menu button.</returns>
				const WString&							GetShortcutText();
				/// <summary>Set the shortcut key text for the menu button.</summary>
				/// <param name="value">The shortcut key text for the menu button.</param>
				void									SetShortcutText(const WString& value);

				/// <summary>Test does the sub menu exist.</summary>
				/// <returns>Returns true if the sub menu exists.</returns>
				bool									IsSubMenuExists();
				/// <summary>Get the sub menu. If the sub menu is not created, it returns null.</summary>
				/// <returns>The sub menu.</returns>
				GuiMenu*								GetSubMenu();
				/// <summary>Create the sub menu if necessary. The created sub menu is owned by this menu button.</summary>
				/// <returns>The created sub menu.</returns>
				/// <param name="subMenuTemplate">The style controller for the sub menu. Set to null to use the default control template.</param>
				GuiMenu*								CreateSubMenu(TemplateProperty<templates::GuiMenuTemplate> subMenuTemplate = {});
				/// <summary>Associate a sub menu if there is no sub menu binded in this menu button. The associated sub menu is not owned by this menu button if the "owned" argument is set to false.</summary>
				/// <param name="value">The sub menu to associate.</param>
				/// <param name="owned">Set to true if the menu is expected to be owned.</param>
				void									SetSubMenu(GuiMenu* value, bool owned);
				/// <summary>Destroy the sub menu if necessary.</summary>
				void									DestroySubMenu();
				/// <summary>Test is the sub menu owned by this menu button. If the sub menu is owned, both deleting this menu button or calling <see cref="DestroySubMenu"/> will delete the sub menu.</summary>
				/// <returns>Returns true if the sub menu is owned by this menu button.</returns>
				bool									GetOwnedSubMenu();

				/// <summary>Test is the sub menu opened.</summary>
				/// <returns>Returns true if the sub menu is opened.</returns>
				bool									GetSubMenuOpening();
				/// <summary>Open or close the sub menu.</summary>
				/// <param name="value">Set to true to open the sub menu.</param>
				void									SetSubMenuOpening(bool value);

				/// <summary>Get the preferred client size for the sub menu.</summary>
				/// <returns>The preferred client size for the sub menu.</returns>
				Size									GetPreferredMenuClientSize();
				/// <summary>Set the preferred client size for the sub menu.</summary>
				/// <param name="value">The preferred client size for the sub menu.</param>
				void									SetPreferredMenuClientSize(Size value);

				/// <summary>Test is cascade action enabled. If the cascade action is enabled, when the mouse enter this menu button, the sub menu will be automatically opened if the parent menu is in an active state (see <see cref="IGuiMenuService::IsActiveState"/>), closing the sub menu will also close the parent menu.</summary>
				/// <returns>Returns true if cascade action is enabled.</returns>
				bool									GetCascadeAction();
				/// <summary>Enable or disable cascade action.</summary>
				/// <param name="value">Set to true to enable cascade action.</param>
				void									SetCascadeAction(bool value);

				IDescriptable*							QueryService(const WString& identifier)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUICOMBOCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ComboBox Base
***********************************************************************/

			/// <summary>The base class of combo box control.</summary>
			class GuiComboBoxBase : public GuiMenuButton, public Description<GuiComboBoxBase>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ComboBoxTemplate, GuiMenuButton)
			protected:
				
				IGuiMenuService::Direction					GetSubMenuDirection()override;
				void										OnBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiComboBoxBase(theme::ThemeName themeName);
				~GuiComboBoxBase();
			};

/***********************************************************************
ComboBox with GuiListControl
***********************************************************************/

			/// <summary>Combo box list control. This control is a combo box with a list control in its popup.</summary>
			class GuiComboBoxListControl
				: public GuiComboBoxBase
				, private GuiListControl::IItemProviderCallback
				, public Description<GuiComboBoxListControl>
			{
			public:
				using ItemStyleProperty = TemplateProperty<templates::GuiTemplate>;

			protected:
				GuiSelectableListControl*					containedListControl = nullptr;
				vint										selectedIndex = -1;
				ItemStyleProperty							itemStyleProperty;
				templates::GuiTemplate*						itemStyleController = nullptr;
				Ptr<compositions::IGuiGraphicsEventHandler>	boundsChangedHandler;

				void										UpdateDisplayFont()override;
				void										BeforeControlTemplateUninstalled()override;
				void										AfterControlTemplateInstalled(bool initialize)override;
				void										RemoveStyleController();
				void										InstallStyleController(vint itemIndex);
				virtual void								DisplaySelectedContent(vint itemIndex);
				void										AdoptSubMenuSize();
				void										OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnContextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnVisuallyEnabledChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnAfterSubMenuOpening(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnListControlAdoptedSizeInvalidated(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnListControlBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnListControlItemMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void										OnListControlKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);

			private:
				// ===================== GuiListControl::IItemProviderCallback =====================

				void										OnAttached(GuiListControl::IItemProvider* provider)override;
				void										OnItemModified(vint start, vint count, vint newCount)override;
			public:
				/// <summary>Create a control with a specified default theme and a list control that will be put in the popup control to show all items.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_containedListControl">The list controller.</param>
				GuiComboBoxListControl(theme::ThemeName themeName, GuiSelectableListControl* _containedListControl);
				~GuiComboBoxListControl();
				
				/// <summary>Style provider changed event.</summary>
				compositions::GuiNotifyEvent				ItemTemplateChanged;
				/// <summary>Selected index changed event.</summary>
				compositions::GuiNotifyEvent				SelectedIndexChanged;
				
				/// <summary>Get the list control.</summary>
				/// <returns>The list control.</returns>
				GuiSelectableListControl*					GetContainedListControl();

				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				virtual ItemStyleProperty					GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				virtual void								SetItemTemplate(ItemStyleProperty value);
				
				/// <summary>Get the selected index.</summary>
				/// <returns>The selected index.</returns>
				vint										GetSelectedIndex();
				/// <summary>Set the selected index.</summary>
				/// <param name="value">The selected index.</param>
				void										SetSelectedIndex(vint value);

				/// <summary>Get the selected item.</summary>
				/// <returns>The selected item.</returns>
				description::Value							GetSelectedItem();
				/// <summary>Get the item provider in the list control.</summary>
				/// <returns>The item provider in the list control.</returns>
				GuiListControl::IItemProvider*				GetItemProvider();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\GUIDATETIMECONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATETIMECONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIDATETIMECONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
DatePicker
***********************************************************************/

			/// <summary>Date picker control that display a calendar.</summary>
			class GuiDatePicker : public GuiControl, protected compositions::GuiAltActionHostBase, public Description<GuiDatePicker>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DatePickerTemplate, GuiControl)
			protected:
				class CommandExecutor : public Object, public IDatePickerCommandExecutor
				{
				protected:
					GuiDatePicker*										datePicker;
				public:
					CommandExecutor(GuiDatePicker* _datePicker);
					~CommandExecutor();

					void												NotifyDateChanged()override;
					void												NotifyDateNavigated()override;
					void												NotifyDateSelected()override;
				};

				Ptr<CommandExecutor>									commandExecutor;
				DateTime												date;
				WString													dateFormat;
				Locale													dateLocale;
				compositions::IGuiAltActionHost*						previousAltHost = nullptr;
				bool													nestedAlt = false;

				void													UpdateText();
				bool													IsAltAvailable()override;
				compositions::IGuiAltActionHost*						GetActivatingAltHost()override;

			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_nestedAlt">Set to true to make this date picker an <see cref="compositions::IGuiAltActionHost"/>.</param>
				GuiDatePicker(theme::ThemeName themeName, bool _nestedAlt = true);
				~GuiDatePicker();

				/// <summary>Date changed event.</summary>
				compositions::GuiNotifyEvent							DateChanged;
				/// <summary>Date navigated event. Called when the current month is changed.</summary>
				compositions::GuiNotifyEvent							DateNavigated;
				/// <summary>Date selected event. Called when a day button is selected.</summary>
				compositions::GuiNotifyEvent							DateSelected;
				/// <summary>Date format changed event.</summary>
				compositions::GuiNotifyEvent							DateFormatChanged;
				/// <summary>Date locale changed event.</summary>
				compositions::GuiNotifyEvent							DateLocaleChanged;
				
				/// <summary>Get the displayed date.</summary>
				/// <returns>The date.</returns>
				const DateTime&											GetDate();
				/// <summary>Display a date.</summary>
				/// <param name="value">The date.</param>
				void													SetDate(const DateTime& value);
				/// <summary>Get the format.</summary>
				/// <returns>The format.</returns>
				const WString&											GetDateFormat();
				/// <summary>Set the format for the text of this control.</summary>
				/// <param name="value">The format.</param>
				void													SetDateFormat(const WString& value);
				/// <summary>Get the locale.</summary>
				/// <returns>The locale.</returns>
				const Locale&											GetDateLocale();
				/// <summary>Set the locale to display texts.</summary>
				/// <param name="value">The locale.</param>
				void													SetDateLocale(const Locale& value);

				void													SetText(const WString& value)override;
			};

/***********************************************************************
DateComboBox
***********************************************************************/
			
			/// <summary>A combo box control with a date picker control.</summary>
			class GuiDateComboBox : public GuiComboBoxBase, public Description<GuiDateComboBox>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DateComboBoxTemplate, GuiComboBoxBase)
			protected:
				GuiDatePicker*											datePicker;
				DateTime												selectedDate;
				
				void													UpdateText();
				void													NotifyUpdateSelectedDate();
				void													OnSubMenuOpeningChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateLocaleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateFormatChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateSelected(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiDateComboBox(theme::ThemeName themeName);
				~GuiDateComboBox();
				
				/// <summary>Selected data changed event.</summary>
				compositions::GuiNotifyEvent							SelectedDateChanged;
				
				void													SetFont(const Nullable<FontProperties>& value)override;
				/// <summary>Get the displayed date.</summary>
				/// <returns>The date.</returns>
				const DateTime&											GetSelectedDate();
				/// <summary>Display a date.</summary>
				/// <param name="value">The date.</param>
				void													SetSelectedDate(const DateTime& value);
				/// <summary>Get the date picker control.</summary>
				/// <returns>The date picker control.</returns>
				GuiDatePicker*											GetDatePicker();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTCONTROLITEMARRANGERS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLITEMARRANGERS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLITEMARRANGERS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Predefined ItemArranger
***********************************************************************/

			namespace list
			{

				/// <summary>Ranged item arranger. This arranger implements most of the common functionality for those arrangers that display a continuing subset of item at a time.</summary>
				class RangedItemArrangerBase : public Object, virtual public GuiListControl::IItemArranger, public Description<RangedItemArrangerBase>
				{
				protected:
					using ItemStyleRecord = collections::Pair<GuiListControl::ItemStyle*, GuiSelectableButton*>;
					typedef collections::List<ItemStyleRecord>	StyleList;

					GuiListControl*								listControl = nullptr;
					GuiListControl::IItemArrangerCallback*		callback = nullptr;
					GuiListControl::IItemProvider*				itemProvider = nullptr;

					bool										suppressOnViewChanged = false;
					Rect										viewBounds;
					vint										startIndex = 0;
					StyleList									visibleStyles;

				protected:

					void										InvalidateAdoptedSize();
					vint										CalculateAdoptedSize(vint expectedSize, vint count, vint itemSize);
					ItemStyleRecord								CreateStyle(vint index);
					void										DeleteStyle(ItemStyleRecord style);
					compositions::GuiBoundsComposition*			GetStyleBounds(ItemStyleRecord style);
					void										ClearStyles();
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds);
					virtual void								RearrangeItemBounds();

					virtual void								BeginPlaceItem(bool forMoving, Rect newBounds, vint& newStartIndex) = 0;
					virtual void								PlaceItem(bool forMoving, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent) = 0;
					virtual bool								IsItemOutOfViewBounds(vint index, ItemStyleRecord style, Rect bounds, Rect viewBounds) = 0;
					virtual bool								EndPlaceItem(bool forMoving, Rect newBounds, vint newStartIndex) = 0;
					virtual void								InvalidateItemSizeCache() = 0;
					virtual Size								OnCalculateTotalSize() = 0;
				public:
					/// <summary>Create the arranger.</summary>
					RangedItemArrangerBase();
					~RangedItemArrangerBase();

					void										OnAttached(GuiListControl::IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount)override;
					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemArrangerCallback*		GetCallback()override;
					void										SetCallback(GuiListControl::IItemArrangerCallback* value)override;
					Size										GetTotalSize()override;
					GuiListControl::ItemStyle*					GetVisibleStyle(vint itemIndex)override;
					vint										GetVisibleIndex(GuiListControl::ItemStyle* style)override;
					void										ReloadVisibleStyles()override;
					void										OnViewChanged(Rect bounds)override;
				};
				/// <summary>Free height item arranger. This arranger will cache heights of all items.</summary>
				class FreeHeightItemArranger : public RangedItemArrangerBase, public Description<FreeHeightItemArranger>
				{
				private:
					bool										pim_heightUpdated = false;

				protected:
					collections::Array<vint>					heights;
					collections::Array<vint>					offsets;
					vint										availableOffsetCount = 0;

					void										EnsureOffsetForItem(vint itemIndex);

					void										BeginPlaceItem(bool forMoving, Rect newBounds, vint& newStartIndex)override;
					void										PlaceItem(bool forMoving, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
					bool										IsItemOutOfViewBounds(vint index, ItemStyleRecord style, Rect bounds, Rect viewBounds)override;
					bool										EndPlaceItem(bool forMoving, Rect newBounds, vint newStartIndex)override;
					void										InvalidateItemSizeCache()override;
					Size										OnCalculateTotalSize()override;
				public:
					/// <summary>Create the arranger.</summary>
					FreeHeightItemArranger();
					~FreeHeightItemArranger();

					void										OnAttached(GuiListControl::IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount)override;
					vint										FindItem(vint itemIndex, compositions::KeyDirection key)override;
					GuiListControl::EnsureItemVisibleResult		EnsureItemVisible(vint itemIndex)override;
					Size										GetAdoptedSize(Size expectedSize)override;
				};
				
				/// <summary>Fixed height item arranger. This arranger lists all item with the same height value. This value is the maximum height of all minimum heights of displayed items.</summary>
				class FixedHeightItemArranger : public RangedItemArrangerBase, public Description<FixedHeightItemArranger>
				{
				private:
					vint										pi_width = 0;
					vint										pim_rowHeight = 0;

				protected:
					vint										rowHeight = 1;

					virtual vint								GetWidth();
					virtual vint								GetYOffset();

					void										BeginPlaceItem(bool forMoving, Rect newBounds, vint& newStartIndex)override;
					void										PlaceItem(bool forMoving, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
					bool										IsItemOutOfViewBounds(vint index, ItemStyleRecord style, Rect bounds, Rect viewBounds)override;
					bool										EndPlaceItem(bool forMoving, Rect newBounds, vint newStartIndex)override;
					void										InvalidateItemSizeCache()override;
					Size										OnCalculateTotalSize()override;
				public:
					/// <summary>Create the arranger.</summary>
					FixedHeightItemArranger();
					~FixedHeightItemArranger();

					vint										FindItem(vint itemIndex, compositions::KeyDirection key)override;
					GuiListControl::EnsureItemVisibleResult		EnsureItemVisible(vint itemIndex)override;
					Size										GetAdoptedSize(Size expectedSize)override;
				};

				/// <summary>Fixed size multiple columns item arranger. This arranger adjust all items in multiple lines with the same size. The width is the maximum width of all minimum widths of displayed items. The same to height.</summary>
				class FixedSizeMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedSizeMultiColumnItemArranger>
				{
				private:
					Size										pim_itemSize;

				protected:
					Size										itemSize{ 1,1 };

					void										CalculateRange(Size itemSize, Rect bounds, vint count, vint& start, vint& end);

					void										BeginPlaceItem(bool forMoving, Rect newBounds, vint& newStartIndex)override;
					void										PlaceItem(bool forMoving, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
					bool										IsItemOutOfViewBounds(vint index, ItemStyleRecord style, Rect bounds, Rect viewBounds)override;
					bool										EndPlaceItem(bool forMoving, Rect newBounds, vint newStartIndex)override;
					void										InvalidateItemSizeCache()override;
					Size										OnCalculateTotalSize()override;
				public:
					/// <summary>Create the arranger.</summary>
					FixedSizeMultiColumnItemArranger();
					~FixedSizeMultiColumnItemArranger();

					vint										FindItem(vint itemIndex, compositions::KeyDirection key)override;
					GuiListControl::EnsureItemVisibleResult		EnsureItemVisible(vint itemIndex)override;
					Size										GetAdoptedSize(Size expectedSize)override;
				};
				
				/// <summary>Fixed size multiple columns item arranger. This arranger adjust all items in multiple columns with the same height. The height is the maximum width of all minimum height of displayed items. Each item will displayed using its minimum width.</summary>
				class FixedHeightMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedHeightMultiColumnItemArranger>
				{
				private:
					vint										pi_currentWidth = 0;
					vint										pi_totalWidth = 0;
					vint										pim_itemHeight = 0;

				protected:
					vint										itemHeight;

					void										CalculateRange(vint itemHeight, Rect bounds, vint& rows, vint& startColumn);

					void										BeginPlaceItem(bool forMoving, Rect newBounds, vint& newStartIndex)override;
					void										PlaceItem(bool forMoving, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
					bool										IsItemOutOfViewBounds(vint index, ItemStyleRecord style, Rect bounds, Rect viewBounds)override;
					bool										EndPlaceItem(bool forMoving, Rect newBounds, vint newStartIndex)override;
					void										InvalidateItemSizeCache()override;
					Size										OnCalculateTotalSize()override;
				public:
					/// <summary>Create the arranger.</summary>
					FixedHeightMultiColumnItemArranger();
					~FixedHeightMultiColumnItemArranger();

					vint										FindItem(vint itemIndex, compositions::KeyDirection key)override;
					GuiListControl::EnsureItemVisibleResult		EnsureItemVisible(vint itemIndex)override;
					Size										GetAdoptedSize(Size expectedSize)override;
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			///<summary>List view column header control for detailed view.</summary>
			class GuiListViewColumnHeader : public GuiMenuButton, public Description<GuiListViewColumnHeader>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ListViewColumnHeaderTemplate, GuiMenuButton)
			protected:
				ColumnSortingState								columnSortingState = ColumnSortingState::NotSorted;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiListViewColumnHeader(theme::ThemeName themeName);
				~GuiListViewColumnHeader();

				bool											IsAltAvailable()override;

				/// <summary>Get the column sorting state.</summary>
				/// <returns>The column sorting state.</returns>
				ColumnSortingState								GetColumnSortingState();
				/// <summary>Set the column sorting state.</summary>
				/// <param name="value">The new column sorting state.</param>
				void											SetColumnSortingState(ColumnSortingState value);
			};

			/// <summary>List view base control. All list view controls inherit from this class.</summary>
			class GuiListViewBase : public GuiSelectableListControl, public Description<GuiListViewBase>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ListViewTemplate, GuiSelectableListControl)
			public:
				/// <summary>Create a list view base control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiListViewBase(theme::ThemeName themeName, GuiListControl::IItemProvider* _itemProvider);
				~GuiListViewBase();

				/// <summary>Column clicked event.</summary>
				compositions::GuiItemNotifyEvent				ColumnClicked;
			};

/***********************************************************************
ListView ItemStyleProvider
***********************************************************************/

			namespace list
			{
				/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for <see cref="GuiVirtualListView"/>.</summary>
				class IListViewItemView : public virtual IDescriptable, public Description<IListViewItemView>
				{
				public:
					/// <summary>The identifier for this view.</summary>
					static const wchar_t* const				Identifier;

					/// <summary>Get the small image of an item.</summary>
					/// <returns>The small image.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual Ptr<GuiImageData>				GetSmallImage(vint itemIndex) = 0;
					/// <summary>Get the large image of an item.</summary>
					/// <returns>The large image.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual Ptr<GuiImageData>				GetLargeImage(vint itemIndex) = 0;
					/// <summary>Get the text of an item.</summary>
					/// <returns>The text.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual WString							GetText(vint itemIndex) = 0;
					/// <summary>Get the sub item text of an item. If the sub item index out of range, it returns an empty string.</summary>
					/// <returns>The sub item text.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					/// <param name="index">The sub item index of the item.</param>
					virtual WString							GetSubItem(vint itemIndex, vint index) = 0;

					/// <summary>Get the number of data columns.</summary>
					/// <returns>The number of data columns.</returns>
					virtual vint											GetDataColumnCount() = 0;
					/// <summary>Get the column index of the index-th data column.</summary>
					/// <returns>The column index.</returns>
					/// <param name="index">The order of the data column.</param>
					virtual vint											GetDataColumn(vint index) = 0;

					/// <summary>Get the number of all columns.</summary>
					/// <returns>The number of all columns.</returns>
					virtual vint											GetColumnCount() = 0;
					/// <summary>Get the text of the column.</summary>
					/// <returns>The text of the column.</returns>
					/// <param name="index">The index of the column.</param>
					virtual WString											GetColumnText(vint index) = 0;
				};

/***********************************************************************
ListViewColumnItemArranger
***********************************************************************/

				/// <summary>List view column item arranger. This arranger contains column headers. When an column header is resized, all items will be notified via the [T:vl.presentation.controls.list.ListViewColumnItemArranger.IColumnItemView] for <see cref="GuiListControl::IItemProvider"/>.</summary>
				class ListViewColumnItemArranger : public FixedHeightItemArranger, public Description<ListViewColumnItemArranger>
				{
					typedef collections::List<GuiListViewColumnHeader*>					ColumnHeaderButtonList;
					typedef collections::List<compositions::GuiBoundsComposition*>		ColumnHeaderSplitterList;
				public:
					static const vint							SplitterWidth=8;
					
					/// <summary>Callback for [T:vl.presentation.controls.list.ListViewColumnItemArranger.IColumnItemView]. Column item view use this interface to notify column related modification.</summary>
					class IColumnItemViewCallback : public virtual IDescriptable, public Description<IColumnItemViewCallback>
					{
					public:
						/// <summary>Called when any column is changed (inserted, removed, text changed, etc.).</summary>
						virtual void							OnColumnChanged()=0;
					};
					
					/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for <see cref="ListViewColumnItemArranger"/>.</summary>
					class IColumnItemView : public virtual IDescriptable, public Description<IColumnItemView>
					{
					public:
						/// <summary>The identifier for this view.</summary>
						static const wchar_t* const								Identifier;
						
						/// <summary>Attach an column item view callback to this view.</summary>
						/// <returns>Returns true if this operation succeeded.</returns>
						/// <param name="value">The column item view callback.</param>
						virtual bool											AttachCallback(IColumnItemViewCallback* value)=0;
						/// <summary>Detach an column item view callback from this view.</summary>
						/// <returns>Returns true if this operation succeeded.</returns>
						/// <param name="value">The column item view callback.</param>
						virtual bool											DetachCallback(IColumnItemViewCallback* value)=0;

						/// <summary>Get the size of the column.</summary>
						/// <returns>The size of the column.</returns>
						/// <param name="index">The index of the column.</param>
						virtual vint											GetColumnSize(vint index)=0;
						/// <summary>Set the size of the column.</summary>
						/// <param name="index">The index of the column.</param>
						/// <param name="value">The new size of the column.</param>
						virtual void											SetColumnSize(vint index, vint value)=0;

						/// <summary>Get the popup binded to the column.</summary>
						/// <returns>The popup binded to the column.</returns>
						/// <param name="index">The index of the column.</param>
						virtual GuiMenu*										GetDropdownPopup(vint index)=0;
						/// <summary>Get the sorting state of the column.</summary>
						/// <returns>The sorting state of the column.</returns>
						/// <param name="index">The index of the column.</param>
						virtual ColumnSortingState								GetSortingState(vint index)=0;
					};
				protected:
					class ColumnItemViewCallback : public Object, public virtual IColumnItemViewCallback
					{
					protected:
						ListViewColumnItemArranger*				arranger;
					public:
						ColumnItemViewCallback(ListViewColumnItemArranger* _arranger);
						~ColumnItemViewCallback();

						void									OnColumnChanged();
					};

					GuiListViewBase*							listView = nullptr;
					IListViewItemView*							listViewItemView = nullptr;
					IColumnItemView*							columnItemView = nullptr;
					Ptr<ColumnItemViewCallback>					columnItemViewCallback;
					compositions::GuiStackComposition*			columnHeaders = nullptr;
					ColumnHeaderButtonList						columnHeaderButtons;
					ColumnHeaderSplitterList					columnHeaderSplitters;
					bool										splitterDragging = false;
					vint										splitterLatestX = 0;

					void										ColumnClicked(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnBoundsChanged(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void										RearrangeItemBounds()override;
					vint										GetWidth()override;
					vint										GetYOffset()override;
					Size										OnCalculateTotalSize()override;
					void										DeleteColumnButtons();
					void										RebuildColumns();
				public:
					ListViewColumnItemArranger();
					~ListViewColumnItemArranger();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
				};
			}

/***********************************************************************
ListViewItemProvider
***********************************************************************/

			namespace list
			{
				class ListViewItem;

				class ListViewSubItems : public collections::ObservableListBase<WString>
				{
					friend class ListViewItem;
				protected:
					ListViewItem*									owner;
					
					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
				};

				class ListViewItemProvider;

				/// <summary>List view item.</summary>
				class ListViewItem : public Object, public Description<ListViewItem>
				{
					friend class ListViewSubItems;
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*							owner;
					ListViewSubItems								subItems;
					Ptr<GuiImageData>								smallImage;
					Ptr<GuiImageData>								largeImage;
					WString											text;
					description::Value								tag;
					
					void											NotifyUpdate();
				public:
					/// <summary>Create a list view item.</summary>
					ListViewItem();
					
					/// <summary>Get all sub items of this item.</summary>
					/// <returns>All sub items of this item.</returns>
					ListViewSubItems&								GetSubItems();
					/// <summary>Get the small image of this item.</summary>
					/// <returns>The small image of this item.</returns>
					Ptr<GuiImageData>								GetSmallImage();
					/// <summary>Set the small image of this item.</summary>
					/// <param name="value">The small image of this item.</param>
					void											SetSmallImage(Ptr<GuiImageData> value);
					/// <summary>Get the large image of this item.</summary>
					/// <returns>The large image of this item.</returns>
					Ptr<GuiImageData>								GetLargeImage();
					/// <summary>Set the large image of this item.</summary>
					/// <param name="value">The large image of this item.</param>
					void											SetLargeImage(Ptr<GuiImageData> value);
					/// <summary>Get the text of this item.</summary>
					/// <returns>The text of this item.</returns>
					const WString&									GetText();
					/// <summary>Set the text of this item.</summary>
					/// <param name="value">The text of this item.</param>
					void											SetText(const WString& value);
					/// <summary>Get the tag of this item.</summary>
					/// <returns>The tag of this item.</returns>
					description::Value								GetTag();
					/// <summary>Set the tag of this item.</summary>
					/// <param name="value">The tag of this item.</param>
					void											SetTag(const description::Value& value);
				};

				class ListViewColumns;
				
				/// <summary>List view column.</summary>
				class ListViewColumn : public Object, public Description<ListViewColumn>
				{
					friend class ListViewColumns;
				protected:
					ListViewColumns*								owner = nullptr;
					WString											text;
					ItemProperty<WString>							textProperty;
					vint											size;
					bool											ownPopup = true;
					GuiMenu*										dropdownPopup = nullptr;
					ColumnSortingState								sortingState = ColumnSortingState::NotSorted;
					
					void											NotifyUpdate(bool affectItem);
				public:
					/// <summary>Create a column with the specified text and size.</summary>
					/// <param name="_text">The specified text.</param>
					/// <param name="_size">The specified size.</param>
					ListViewColumn(const WString& _text=L"", vint _size=160);
					~ListViewColumn();
					
					/// <summary>Get the text of this item.</summary>
					/// <returns>The text of this item.</returns>
					const WString&									GetText();
					/// <summary>Set the text of this item.</summary>
					/// <param name="value">The text of this item.</param>
					void											SetText(const WString& value);
					/// <summary>Get the text property of this item.</summary>
					/// <returns>The text property of this item.</returns>
					ItemProperty<WString>							GetTextProperty();
					/// <summary>Set the text property of this item.</summary>
					/// <param name="value">The text property of this item.</param>
					void											SetTextProperty(const ItemProperty<WString>& value);
					/// <summary>Get the size of this item.</summary>
					/// <returns>The size of this item.</returns>
					vint											GetSize();
					/// <summary>Set the size of this item.</summary>
					/// <param name="value">The size of this item.</param>
					void											SetSize(vint value);
					/// <summary>Test if the column owns the popup. Owned popup will be deleted in the destructor.</summary>
					/// <returns>Returns true if the column owns the popup.</returns>
					bool											GetOwnPopup();
					/// <summary>Set if the column owns the popup.</summary>
					/// <param name="value">Set to true to let the column own the popup.</param>
					void											SetOwnPopup(bool value);
					/// <summary>Get the dropdown context menu of this item.</summary>
					/// <returns>The dropdown context menu of this item.</returns>
					GuiMenu*										GetDropdownPopup();
					/// <summary>Set the dropdown context menu of this item.</summary>
					/// <param name="value">The dropdown context menu of this item.</param>
					void											SetDropdownPopup(GuiMenu* value);
					/// <summary>Get the sorting state of this item.</summary>
					/// <returns>The sorting state of this item.</returns>
					ColumnSortingState								GetSortingState();
					/// <summary>Set the sorting state of this item.</summary>
					/// <param name="value">The sorting state of this item.</param>
					void											SetSortingState(ColumnSortingState value);
				};

				class IListViewItemProvider : public virtual Interface
				{
				public:
					virtual void									NotifyAllItemsUpdate() = 0;
					virtual void									NotifyAllColumnsUpdate() = 0;
				};

				/// <summary>List view data column container.</summary>
				class ListViewDataColumns : public collections::ObservableListBase<vint>
				{
				protected:
					IListViewItemProvider*							itemProvider;

					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					/// <summary>Create a container.</summary>
					/// <param name="_itemProvider">The item provider in the same control to receive notifications.</param>
					ListViewDataColumns(IListViewItemProvider* _itemProvider);
					~ListViewDataColumns();
				};
				
				/// <summary>List view column container.</summary>
				class ListViewColumns : public collections::ObservableListBase<Ptr<ListViewColumn>>
				{
					friend class ListViewColumn;
				protected:
					IListViewItemProvider*							itemProvider;
					bool											affectItemFlag = true;

					void											NotifyColumnUpdated(vint column, bool affectItem);
					void											AfterInsert(vint index, const Ptr<ListViewColumn>& value)override;
					void											BeforeRemove(vint index, const Ptr<ListViewColumn>& value)override;
					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					/// <summary>Create a container.</summary>
					/// <param name="_itemProvider">The item provider in the same control to receive notifications.</param>
					ListViewColumns(IListViewItemProvider* _itemProvider);
					~ListViewColumns();
				};
				
				/// <summary>Item provider for <see cref="GuiListViewBase"/>.</summary>
				class ListViewItemProvider
					: public ListProvider<Ptr<ListViewItem>>
					, protected virtual IListViewItemProvider
					, public virtual IListViewItemView
					, public virtual ListViewColumnItemArranger::IColumnItemView
					, public Description<ListViewItemProvider>
				{
					friend class ListViewItem;
					friend class ListViewColumns;
					friend class ListViewDataColumns;
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					ListViewDataColumns									dataColumns;
					ListViewColumns										columns;
					ColumnItemViewCallbackList							columnItemViewCallbacks;

					void												AfterInsert(vint index, const Ptr<ListViewItem>& value)override;
					void												BeforeRemove(vint index, const Ptr<ListViewItem>& value)override;

					void												NotifyAllItemsUpdate()override;
					void												NotifyAllColumnsUpdate()override;

					Ptr<GuiImageData>									GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(vint itemIndex)override;
					WString												GetText(vint itemIndex)override;
					WString												GetSubItem(vint itemIndex, vint index)override;
					vint												GetDataColumnCount()override;
					vint												GetDataColumn(vint index)override;
					vint												GetColumnCount()override;
					WString												GetColumnText(vint index)override;;

					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint												GetColumnSize(vint index)override;
					void												SetColumnSize(vint index, vint value)override;
					GuiMenu*											GetDropdownPopup(vint index)override;
					ColumnSortingState									GetSortingState(vint index)override;

					WString												GetTextValue(vint itemIndex)override;
					description::Value									GetBindingValue(vint itemIndex)override;
				public:
					ListViewItemProvider();
					~ListViewItemProvider();

					IDescriptable*										RequestView(const WString& identifier)override;

					/// <summary>Get all data columns indices in columns.</summary>
					/// <returns>All data columns indices in columns.</returns>
					ListViewDataColumns&								GetDataColumns();
					/// <summary>Get all columns.</summary>
					/// <returns>All columns.</returns>
					ListViewColumns&									GetColumns();
				};
			}

/***********************************************************************
GuiVirtualListView
***********************************************************************/

			enum class ListViewView
			{
				BigIcon,
				SmallIcon,
				List,
				Tile,
				Information,
				Detail,
				Unknown,
			};
			
			/// <summary>List view control in virtual mode.</summary>
			class GuiVirtualListView : public GuiListViewBase, public Description<GuiVirtualListView>
			{
			protected:
				ListViewView											view = ListViewView::Unknown;

				void													OnStyleInstalled(vint itemIndex, ItemStyle* style)override;
				void													OnItemTemplateChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a list view control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiVirtualListView(theme::ThemeName themeName, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualListView();

				/// <summary>Get the current view.</summary>
				/// <returns>The current view. After [M:vl.presentation.controls.GuiListControl.SetItemTemplate] is called, the current view is reset to Unknown.</returns>
				ListViewView											GetView();
				/// <summary>Set the current view.</summary>
				/// <param name="_view">The current view.</param>
				void													SetView(ListViewView _view);
			};

/***********************************************************************
GuiListView
***********************************************************************/
			
			/// <summary>List view control in virtual mode.</summary>
			class GuiListView : public GuiVirtualListView, public Description<GuiListView>
			{
			protected:
				list::ListViewItemProvider*								items;
			public:
				/// <summary>Create a list view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiListView(theme::ThemeName themeName);
				~GuiListView();
				
				/// <summary>Get all list view items.</summary>
				/// <returns>All list view items.</returns>
				list::ListViewItemProvider&								GetItems();
				/// <summary>Get all data columns indices in columns.</summary>
				/// <returns>All data columns indices in columns.</returns>
				list::ListViewDataColumns&								GetDataColumns();
				/// <summary>Get all columns.</summary>
				/// <returns>All columns.</returns>
				list::ListViewColumns&									GetColumns();

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				Ptr<list::ListViewItem>									GetSelectedItem();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIBINDABLELISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBINDABLELISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBINDABLELISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			template<typename T>
			struct DefaultValueOf
			{
				static T Get()
				{
					return reflection::description::TypedValueSerializerProvider<T>::GetDefaultValue();
				}
			};

			template<typename T>
			struct DefaultValueOf<Ptr<T>>
			{
				static Ptr<T> Get()
				{
					return nullptr;
				}
			};

			template<>
			struct DefaultValueOf<description::Value>
			{
				static description::Value Get()
				{
					return description::Value();
				}
			};

			template<typename T>
			T ReadProperty(const description::Value& thisObject, const ItemProperty<T>& propertyName)
			{
				if (!thisObject.IsNull() && propertyName)
				{
					return propertyName(thisObject);
				}
				else
				{
					return DefaultValueOf<T>::Get();
				}
			}

			template<typename T>
			T ReadProperty(const description::Value& thisObject, const WritableItemProperty<T>& propertyName)
			{
				auto defaultValue = DefaultValueOf<T>::Get();
				if (!thisObject.IsNull() && propertyName)
				{
					return propertyName(thisObject, defaultValue, false);
				}
				else
				{
					return defaultValue;
				}
			}

			template<typename T>
			void WriteProperty(const description::Value& thisObject, const WritableItemProperty<T>& propertyName, const T& value)
			{
				if (!thisObject.IsNull() && propertyName)
				{
					propertyName(thisObject, value, true);
				}
			}

/***********************************************************************
GuiBindableTextList
***********************************************************************/

			/// <summary>A bindable Text list control.</summary>
			class GuiBindableTextList : public GuiVirtualTextList, public Description<GuiBindableTextList>
			{
			protected:
				class ItemSource
					: public list::ItemProviderBase
					, protected list::ITextItemView
				{
				protected:
					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			itemSource;

				public:
					ItemProperty<WString>							textProperty;
					WritableItemProperty<bool>						checkedProperty;

				public:
					ItemSource();
					~ItemSource();

					Ptr<description::IValueEnumerable>				GetItemSource();
					void											SetItemSource(Ptr<description::IValueEnumerable> _itemSource);

					description::Value								Get(vint index);
					void											UpdateBindingProperties();
					
					// ===================== GuiListControl::IItemProvider =====================

					WString											GetTextValue(vint itemIndex)override;
					description::Value								GetBindingValue(vint itemIndex)override;
					vint											Count()override;
					IDescriptable*									RequestView(const WString& identifier)override;
					
					// ===================== list::TextItemStyleProvider::ITextItemView =====================

					bool											GetChecked(vint itemIndex)override;
					void											SetChecked(vint itemIndex, bool value)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				/// <summary>Create a bindable Text list control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableTextList(theme::ThemeName themeName);
				~GuiBindableTextList();
				
				/// <summary>Text property name changed event.</summary>
				compositions::GuiNotifyEvent						TextPropertyChanged;
				/// <summary>Checked property name changed event.</summary>
				compositions::GuiNotifyEvent						CheckedPropertyChanged;

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<description::IValueEnumerable>					GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
				
				/// <summary>Get the text property name to get the item text from an item.</summary>
				/// <returns>The text property name.</returns>
				ItemProperty<WString>								GetTextProperty();
				/// <summary>Set the text property name to get the item text from an item.</summary>
				/// <param name="value">The text property name.</param>
				void												SetTextProperty(const ItemProperty<WString>& value);
				
				/// <summary>Get the checked property name to get the check state from an item.</summary>
				/// <returns>The checked property name.</returns>
				WritableItemProperty<bool>							GetCheckedProperty();
				/// <summary>Set the checked property name to get the check state from an item.</summary>
				/// <param name="value">The checked property name.</param>
				void												SetCheckedProperty(const WritableItemProperty<bool>& value);

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedItem();
			};

/***********************************************************************
GuiBindableListView
***********************************************************************/
			
			/// <summary>A bindable List view control.</summary>
			class GuiBindableListView : public GuiVirtualListView, public Description<GuiBindableListView>
			{
			protected:
				class ItemSource
					: public list::ItemProviderBase
					, protected virtual list::IListViewItemProvider
					, public virtual list::IListViewItemView
					, public virtual list::ListViewColumnItemArranger::IColumnItemView
				{
					typedef collections::List<list::ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					list::ListViewDataColumns						dataColumns;
					list::ListViewColumns							columns;
					ColumnItemViewCallbackList						columnItemViewCallbacks;
					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			itemSource;

				public:
					ItemProperty<Ptr<GuiImageData>>					largeImageProperty;
					ItemProperty<Ptr<GuiImageData>>					smallImageProperty;

				public:
					ItemSource();
					~ItemSource();

					Ptr<description::IValueEnumerable>				GetItemSource();
					void											SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
					
					description::Value								Get(vint index);
					void											UpdateBindingProperties();
					bool											NotifyUpdate(vint start, vint count);
					list::ListViewDataColumns&						GetDataColumns();
					list::ListViewColumns&							GetColumns();
					
					// ===================== list::IListViewItemProvider =====================

					void											NotifyAllItemsUpdate()override;
					void											NotifyAllColumnsUpdate()override;
					
					// ===================== GuiListControl::IItemProvider =====================

					WString											GetTextValue(vint itemIndex)override;
					description::Value								GetBindingValue(vint itemIndex)override;
					vint											Count()override;
					IDescriptable*									RequestView(const WString& identifier)override;

					// ===================== list::ListViewItemStyleProvider::IListViewItemView =====================

					Ptr<GuiImageData>								GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>								GetLargeImage(vint itemIndex)override;
					WString											GetText(vint itemIndex)override;
					WString											GetSubItem(vint itemIndex, vint index)override;
					vint											GetDataColumnCount()override;
					vint											GetDataColumn(vint index)override;
					vint											GetColumnCount()override;
					WString											GetColumnText(vint index)override;

					// ===================== list::ListViewColumnItemArranger::IColumnItemView =====================
						
					bool											AttachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool											DetachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint											GetColumnSize(vint index)override;
					void											SetColumnSize(vint index, vint value)override;
					GuiMenu*										GetDropdownPopup(vint index)override;
					ColumnSortingState								GetSortingState(vint index)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				/// <summary>Create a bindable List view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableListView(theme::ThemeName themeName);
				~GuiBindableListView();

				/// <summary>Get all data columns indices in columns.</summary>
				/// <returns>All data columns indices in columns.</returns>
				list::ListViewDataColumns&							GetDataColumns();
				/// <summary>Get all columns.</summary>
				/// <returns>All columns.</returns>
				list::ListViewColumns&								GetColumns();

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<description::IValueEnumerable>					GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
				
				/// <summary>Large image property name changed event.</summary>
				compositions::GuiNotifyEvent						LargeImagePropertyChanged;
				/// <summary>Small image property name changed event.</summary>
				compositions::GuiNotifyEvent						SmallImagePropertyChanged;
				
				/// <summary>Get the large image property name to get the large image from an item.</summary>
				/// <returns>The large image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetLargeImageProperty();
				/// <summary>Set the large image property name to get the large image from an item.</summary>
				/// <param name="value">The large image property name.</param>
				void												SetLargeImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);
				
				/// <summary>Get the small image property name to get the small image from an item.</summary>
				/// <returns>The small image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetSmallImageProperty();
				/// <summary>Set the small image property name to get the small image from an item.</summary>
				/// <param name="value">The small image property name.</param>
				void												SetSmallImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedItem();
			};

/***********************************************************************
GuiBindableTreeView
***********************************************************************/
			
			/// <summary>A bindable Tree view control.</summary>
			class GuiBindableTreeView : public GuiVirtualTreeView, public Description<GuiBindableTreeView>
			{
				using IValueEnumerable = reflection::description::IValueEnumerable;
			protected:
				class ItemSource;

				class ItemSourceNode
					: public Object
					, public virtual tree::INodeProvider
				{
					friend class ItemSource;
					typedef collections::List<Ptr<ItemSourceNode>>	NodeList;
				protected:
					description::Value								itemSource;
					ItemSource*										rootProvider;
					ItemSourceNode*									parent;
					tree::INodeProviderCallback*					callback;
					bool											expanding = false;

					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			childrenVirtualList;
					NodeList										children;

					Ptr<description::IValueReadonlyList>			PrepareValueList(const description::Value& inputItemSource);
					void											PrepareChildren(Ptr<description::IValueReadonlyList> newValueList);
					void											UnprepareChildren();
				public:
					ItemSourceNode(const description::Value& _itemSource, ItemSourceNode* _parent);
					ItemSourceNode(ItemSource* _rootProvider);
					~ItemSourceNode();

					description::Value								GetItemSource();
					void											SetItemSource(const description::Value& _itemSource);

					// ===================== tree::INodeProvider =====================

					bool											GetExpanding()override;
					void											SetExpanding(bool value)override;
					vint											CalculateTotalVisibleNodes()override;

					vint											GetChildCount()override;
					Ptr<tree::INodeProvider>						GetParent()override;
					Ptr<tree::INodeProvider>						GetChild(vint index)override;
				};

				class ItemSource
					: public tree::NodeRootProviderBase
					, public virtual tree::ITreeViewItemView
				{
					friend class ItemSourceNode;
				public:
					ItemProperty<WString>							textProperty;
					ItemProperty<Ptr<GuiImageData>>					imageProperty;
					ItemProperty<Ptr<IValueEnumerable>>				childrenProperty;
					Ptr<ItemSourceNode>								rootNode;

				public:
					ItemSource();
					~ItemSource();

					description::Value								GetItemSource();
					void											SetItemSource(const description::Value& _itemSource);

					void											UpdateBindingProperties(bool updateChildrenProperty);

					// ===================== tree::INodeRootProvider =====================

					Ptr<tree::INodeProvider>						GetRootNode()override;
					WString											GetTextValue(tree::INodeProvider* node)override;
					description::Value								GetBindingValue(tree::INodeProvider* node)override;
					IDescriptable*									RequestView(const WString& identifier)override;


					// ===================== tree::ITreeViewItemView =====================

					Ptr<GuiImageData>								GetNodeImage(tree::INodeProvider* node)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				/// <summary>Create a bindable Tree view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableTreeView(theme::ThemeName themeName);
				~GuiBindableTreeView();
				
				/// <summary>Text property name changed event.</summary>
				compositions::GuiNotifyEvent						TextPropertyChanged;
				/// <summary>Image property name changed event.</summary>
				compositions::GuiNotifyEvent						ImagePropertyChanged;
				/// <summary>Children property name changed event.</summary>
				compositions::GuiNotifyEvent						ChildrenPropertyChanged;

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				description::Value									GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(description::Value _itemSource);
				
				/// <summary>Get the text property name to get the item text from an item.</summary>
				/// <returns>The text property name.</returns>
				ItemProperty<WString>								GetTextProperty();
				/// <summary>Set the text property name to get the item text from an item.</summary>
				/// <param name="value">The text property name.</param>
				void												SetTextProperty(const ItemProperty<WString>& value);
				
				/// <summary>Get the image property name to get the image from an item.</summary>
				/// <returns>The image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetImageProperty();
				/// <summary>Set the image property name to get the image from an item.</summary>
				/// <param name="value">The image property name.</param>
				void												SetImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);
				
				/// <summary>Get the children property name to get the children from an item.</summary>
				/// <returns>The children property name.</returns>
				ItemProperty<Ptr<IValueEnumerable>>					GetChildrenProperty();
				/// <summary>Set the children property name to get the children from an item.</summary>
				/// <param name="value">The children property name.</param>
				void												SetChildrenProperty(const ItemProperty<Ptr<IValueEnumerable>>& value);

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedItem();
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDINTERFACES
#define VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDINTERFACES


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{

/***********************************************************************
Datagrid Interfaces
***********************************************************************/

				class IDataVisualizer;
				class IDataEditor;

				/// <summary>The data grid context.</summary>
				class IDataGridContext : public virtual IDescriptable, public Description<IDataGridContext>
				{
				public:
					virtual GuiListControl::IItemProvider*				GetItemProvider() = 0;
					virtual templates::GuiListViewTemplate*				GetListViewControlTemplate() = 0;
					virtual void										RequestSaveData() = 0;
				};

				/// <summary>The visualizer factory.</summary>
				class IDataVisualizerFactory : public virtual IDescriptable, public Description<IDataVisualizerFactory>
				{
				public:
					/// <summary>Create a data visualizer.</summary>
					/// <returns>The created data visualizer.</returns>
					/// <param name="dataGridContext">Context information of the data grid.</param>
					virtual Ptr<IDataVisualizer>						CreateVisualizer(IDataGridContext* dataGridContext) = 0;
				};

				/// <summary>The visualizer for each cell in [T:vl.presentation.controls.GuiVirtualDataGrid].</summary>
				class IDataVisualizer : public virtual IDescriptable, public Description<IDataVisualizer>
				{
				public:
					/// <summary>Get the factory object that creates this visualizer.</summary>
					/// <returns>The factory object.</returns>
					virtual IDataVisualizerFactory*						GetFactory() = 0;

					/// <summary>Get the template that renders the data. The data visualizer should maintain this template, and delete it when necessary.</summary>
					/// <returns>The template.</returns>
					virtual templates::GuiGridVisualizerTemplate*		GetTemplate() = 0;
					/// <summary>Notify that the template has been deleted during the deconstruction of UI objects.</summary>
					virtual void										NotifyDeletedTemplate() = 0;

					/// <summary>Called before visualizing a cell.</summary>
					/// <param name="itemProvider">The item provider.</param>
					/// <param name="row">The row number of the cell.</param>
					/// <param name="column">The column number of the cell.</param>
					virtual void										BeforeVisualizeCell(GuiListControl::IItemProvider* itemProvider, vint row, vint column) = 0;

					/// <summary>Set the selected state.</summary>
					/// <param name="value">Set to true to make this data visualizer looks selected.</param>
					virtual void										SetSelected(bool value) = 0;
				};

				/// <summary>The editor factory.</summary>
				class IDataEditorFactory : public virtual IDescriptable, public Description<IDataEditorFactory>
				{
				public:
					/// <summary>Create a data editor.</summary>
					/// <returns>The created data editor.</returns>
					/// <param name="dataGridContext">Context information of the data grid.</param>
					virtual Ptr<IDataEditor>							CreateEditor(IDataGridContext* dataGridContext) = 0;
				};

				/// <summary>The editor for each cell in [T:vl.presentation.controls.GuiVirtualDataGrid].</summary>
				class IDataEditor : public virtual IDescriptable, public Description<IDataEditor>
				{
				public:
					/// <summary>Get the factory object that creates this editor.</summary>
					/// <returns>The factory object.</returns>
					virtual IDataEditorFactory*							GetFactory() = 0;

					/// <summary>Get the template that edit the data. The data editor should maintain this template, and delete it when necessary.</summary>
					/// <returns>The template.</returns>
					virtual templates::GuiGridEditorTemplate*			GetTemplate() = 0;
					/// <summary>Notify that the template has been deleted during the deconstruction of UI objects.</summary>
					virtual void										NotifyDeletedTemplate() = 0;

					/// <summary>Called before editing a cell.</summary>
					/// <param name="itemProvider">The item provider.</param>
					/// <param name="row">The row number of the cell.</param>
					/// <param name="column">The column number of the cell.</param>
					virtual void										BeforeEditCell(GuiListControl::IItemProvider* itemProvider, vint row, vint column) = 0;

					/// <summary>Test if the edit has saved the data.</summary>
					/// <returns>Returns true if the data is saved.</returns>
					virtual bool										GetCellValueSaved() = 0;
				};

				/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for [T:vl.presentation.controls.GuiVirtualDataGrid].</summary>
				class IDataGridView : public virtual IDescriptable, public Description<IDataGridView>
				{
				public:
					/// <summary>The identifier for this view.</summary>
					static const wchar_t* const							Identifier;

					/// <summary>Test is a column sortable.</summary>
					/// <returns>Returns true if this column is sortable.</returns>
					/// <param name="column">The index of the column.</param>
					virtual bool										IsColumnSortable(vint column) = 0;
					/// <summary>Set the column sorting state to update the data.</summary>
					/// <param name="column">The index of the column. Set to -1 means go back to the unsorted state.</param>
					/// <param name="ascending">Set to true if the data is sorted in ascending order.</param>
					virtual void										SortByColumn(vint column, bool ascending) = 0;
					/// <summary>Get the sorted columm. If no column is under a sorted state, it returns -1.</summary>
					/// <returns>The column number.</returns>
					virtual vint										GetSortedColumn() = 0;
					/// <summary>Test is the sort order ascending. </summary>
					/// <returns>Returns true if the sort order is ascending.</returns>
					virtual bool										IsSortOrderAscending() = 0;

					/// <summary>Get the column span for the cell.</summary>
					/// <returns>The column span for the cell.</returns>
					/// <param name="row">The row number for the cell.</param>
					/// <param name="column">The column number for the cell.</param>
					virtual vint										GetCellSpan(vint row, vint column) = 0;
					/// <summary>Get the data visualizer factory that creates data visualizers for visualizing the cell.</summary>
					/// <returns>The data visualizer factory. The data grid control to use the predefined data visualizer if this function returns null.</returns>
					/// <param name="row">The row number for the cell.</param>
					/// <param name="column">The column number for the cell.</param>
					virtual IDataVisualizerFactory*						GetCellDataVisualizerFactory(vint row, vint column) = 0;
					/// <summary>Get the data editor factory that creates data editors for editing the cell.</summary>
					/// <returns>The data editor factory. Returns null to disable editing.</returns>
					/// <param name="row">The row number for the cell.</param>
					/// <param name="column">The column number for the cell.</param>
					virtual IDataEditorFactory*							GetCellDataEditorFactory(vint row, vint column) = 0;
					/// <summary>Get the binding value of a cell.</summary>
					/// <returns>The binding value of cell.</returns>
					/// <param name="row">The row index of the cell.</param>
					/// <param name="column">The column index of the cell.</param>
					virtual description::Value							GetBindingCellValue(vint row, vint column) = 0;
					/// <summary>Set the binding value of a cell.</summary>
					/// <param name="row">The row index of the cell.</param>
					/// <param name="column">The column index of the cell.</param>
					/// <param name="value">The value to set.</param>
					virtual void										SetBindingCellValue(vint row, vint column, const description::Value& value) = 0;
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDEXTENSIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAEXTENSIONS
#define VCZH_PRESENTATION_CONTROLS_GUIDATAEXTENSIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{

/***********************************************************************
Extension Bases
***********************************************************************/

				class DataVisualizerFactory;
				class DataEditorFactory;
				
				/// <summary>Base class for all data visualizers.</summary>
				class DataVisualizerBase : public Object, public virtual IDataVisualizer
				{
					friend class DataVisualizerFactory;
					using ItemTemplate = templates::GuiGridVisualizerTemplate;
				protected:
					DataVisualizerFactory*								factory = nullptr;
					IDataGridContext*									dataGridContext = nullptr;
					templates::GuiGridVisualizerTemplate*				visualizerTemplate = nullptr;

				public:
					/// <summary>Create the data visualizer.</summary>
					DataVisualizerBase();
					~DataVisualizerBase();

					IDataVisualizerFactory*								GetFactory()override;
					templates::GuiGridVisualizerTemplate*				GetTemplate()override;
					void												NotifyDeletedTemplate()override;
					void												BeforeVisualizeCell(GuiListControl::IItemProvider* itemProvider, vint row, vint column)override;
					void												SetSelected(bool value)override;
				};
				
				class DataVisualizerFactory : public Object, public virtual IDataVisualizerFactory, public Description<DataVisualizerFactory>
				{
					using ItemTemplate = templates::GuiGridVisualizerTemplate;
				protected:
					TemplateProperty<ItemTemplate>						templateFactory;
					Ptr<DataVisualizerFactory>							decoratedFactory;

					ItemTemplate*										CreateItemTemplate(controls::list::IDataGridContext* dataGridContext);
				public:
					DataVisualizerFactory(TemplateProperty<ItemTemplate> _templateFactory, Ptr<DataVisualizerFactory> _decoratedFactory = nullptr);
					~DataVisualizerFactory();

					Ptr<IDataVisualizer>								CreateVisualizer(IDataGridContext* dataGridContext)override;
				};
				
				/// <summary>Base class for all data editors.</summary>
				class DataEditorBase : public Object, public virtual IDataEditor
				{
					friend class DataEditorFactory;
					using ItemTemplate = templates::GuiGridEditorTemplate;
				protected:
					IDataEditorFactory*									factory = nullptr;
					IDataGridContext*									dataGridContext = nullptr;
					templates::GuiGridEditorTemplate*					editorTemplate = nullptr;

					void												OnCellValueChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					/// <summary>Create the data editor.</summary>
					DataEditorBase();
					~DataEditorBase();

					IDataEditorFactory*									GetFactory()override;
					templates::GuiGridEditorTemplate*					GetTemplate()override;
					void												NotifyDeletedTemplate()override;
					void												BeforeEditCell(GuiListControl::IItemProvider* itemProvider, vint row, vint column)override;
					bool												GetCellValueSaved()override;
				};
				
				class DataEditorFactory : public Object, public virtual IDataEditorFactory, public Description<DataEditorFactory>
				{
					using ItemTemplate = templates::GuiGridEditorTemplate;
				protected:
					TemplateProperty<ItemTemplate>						templateFactory;

				public:
					DataEditorFactory(TemplateProperty<ItemTemplate> _templateFactory);
					~DataEditorFactory();

					Ptr<IDataEditor>									CreateEditor(IDataGridContext* dataGridContext)override;
				};

/***********************************************************************
Visualizer Extensions
***********************************************************************/

				class MainColumnVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<MainColumnVisualizerTemplate>
				{
				protected:
					elements::GuiImageFrameElement*						image = nullptr;
					elements::GuiSolidLabelElement*						text = nullptr;

					void												OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnSmallImageChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					MainColumnVisualizerTemplate();
					~MainColumnVisualizerTemplate();
				};

				class SubColumnVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<SubColumnVisualizerTemplate>
				{
				protected:
					elements::GuiSolidLabelElement*						text = nullptr;

					void												OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												Initialize(bool fixTextColor);

					SubColumnVisualizerTemplate(bool fixTextColor);
				public:
					SubColumnVisualizerTemplate();
					~SubColumnVisualizerTemplate();
				};

				class HyperlinkVisualizerTemplate : public SubColumnVisualizerTemplate, public Description<HyperlinkVisualizerTemplate>
				{
				protected:
					void												label_MouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												label_MouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				public:
					HyperlinkVisualizerTemplate();
					~HyperlinkVisualizerTemplate();
				};

				class FocusRectangleVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<FocusRectangleVisualizerTemplate>
				{
				protected:
					compositions::GuiBoundsComposition*					focusComposition = nullptr;

					void												OnSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				public:
					FocusRectangleVisualizerTemplate();
					~FocusRectangleVisualizerTemplate();
				};

				class CellBorderVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<CellBorderVisualizerTemplate>
				{
				protected:
					elements::GuiSolidBorderElement*					border1 = nullptr;
					elements::GuiSolidBorderElement*					border2 = nullptr;

					void												OnItemSeparatorColorChanged(GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				public:
					CellBorderVisualizerTemplate();
					~CellBorderVisualizerTemplate();
				};
			}
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTVIEWITEMTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWITEMTEMPLATES
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWITEMTEMPLATES


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{
				class DefaultListViewItemTemplate : public templates::GuiListItemTemplate
				{
				public:
					DefaultListViewItemTemplate();
					~DefaultListViewItemTemplate();
				};

				class BigIconListViewItemTemplate : public DefaultListViewItemTemplate
				{
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;

					void									OnInitialize()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					BigIconListViewItemTemplate();
					~BigIconListViewItemTemplate();
				};

				class SmallIconListViewItemTemplate : public DefaultListViewItemTemplate
				{
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;

					void									OnInitialize()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					SmallIconListViewItemTemplate();
					~SmallIconListViewItemTemplate();
				};

				class ListListViewItemTemplate : public DefaultListViewItemTemplate
				{
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;

					void									OnInitialize()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					ListListViewItemTemplate();
					~ListListViewItemTemplate();
				};

				class TileListViewItemTemplate : public DefaultListViewItemTemplate
				{
					typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;
					compositions::GuiTableComposition*		textTable = nullptr;
					DataTextElementArray					dataTexts;

					elements::GuiSolidLabelElement*			CreateTextElement(vint textRow);
					void									ResetTextTable(vint textRows);
					void									OnInitialize()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					TileListViewItemTemplate();
					~TileListViewItemTemplate();
				};

				class InformationListViewItemTemplate : public DefaultListViewItemTemplate
				{
					typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;
					compositions::GuiTableComposition*		textTable = nullptr;
					DataTextElementArray					columnTexts;
					DataTextElementArray					dataTexts;
					elements::GuiSolidBackgroundElement*	bottomLine = nullptr;
					compositions::GuiBoundsComposition*		bottomLineComposition = nullptr;

					void									OnInitialize()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					InformationListViewItemTemplate();
					~InformationListViewItemTemplate();
				};

				class DetailListViewItemTemplate
					: public DefaultListViewItemTemplate
					, public virtual ListViewColumnItemArranger::IColumnItemViewCallback
				{
					typedef collections::Array<elements::GuiSolidLabelElement*>		SubItemList;
					typedef ListViewColumnItemArranger::IColumnItemView				IColumnItemView;
				protected:
					IColumnItemView*						columnItemView = nullptr;
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;
					compositions::GuiTableComposition*		textTable = nullptr;
					SubItemList								subItems;

					void									OnInitialize()override;
					void									OnColumnChanged()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DetailListViewItemTemplate();
					~DetailListViewItemTemplate();
				};
			}
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualDataGrid;

			namespace list
			{

/***********************************************************************
DefaultDataGridItemTemplate
***********************************************************************/

				class DefaultDataGridItemTemplate
					: public DefaultListViewItemTemplate
					, public ListViewColumnItemArranger::IColumnItemViewCallback
				{
				protected:
					compositions::GuiTableComposition*					textTable = nullptr;
					collections::Array<Ptr<IDataVisualizer>>			dataVisualizers;
					IDataEditor*										currentEditor = nullptr;

					IDataVisualizerFactory*								GetDataVisualizerFactory(vint row, vint column);
					IDataEditorFactory*									GetDataEditorFactory(vint row, vint column);
					vint												GetCellColumnIndex(compositions::GuiGraphicsComposition* composition);
					bool												IsInEditor(GuiVirtualDataGrid* dataGrid, compositions::GuiMouseEventArgs& arguments);
					void												OnCellButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void												OnCellLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void												OnCellRightButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void												OnColumnChanged()override;
					void												OnInitialize()override;
					void												OnSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnContextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DefaultDataGridItemTemplate();
					~DefaultDataGridItemTemplate();

					void												UpdateSubItemSize();
					bool												IsEditorOpened();
					void												NotifyOpenEditor(vint column, IDataEditor* editor);
					void												NotifyCloseEditor();
					void												NotifySelectCell(vint column);
					void												NotifyCellEdited();
				};
			}

/***********************************************************************
GuiVirtualDataGrid
***********************************************************************/

			/// <summary>Data grid control in virtual mode.</summary>
			class GuiVirtualDataGrid
				: public GuiVirtualListView
				, protected compositions::GuiAltActionHostBase
				, private list::IDataGridContext
				, public Description<GuiVirtualDataGrid>
			{
				friend class list::DefaultDataGridItemTemplate;
			protected:
				list::IListViewItemView*								listViewItemView = nullptr;
				list::ListViewColumnItemArranger::IColumnItemView*		columnItemView = nullptr;
				list::IDataGridView*									dataGridView = nullptr;
				Ptr<list::IDataVisualizerFactory>						defaultMainColumnVisualizerFactory;
				Ptr<list::IDataVisualizerFactory>						defaultSubColumnVisualizerFactory;

				bool													skipOnSelectionChanged = false;
				GridPos													selectedCell{ -1,-1 };
				Ptr<list::IDataEditor>									currentEditor;
				GridPos													currentEditorPos{ -1,-1 };
				bool													currentEditorOpeningEditor = false;

				compositions::IGuiAltActionHost*						GetActivatingAltHost()override;
				void													OnItemModified(vint start, vint count, vint newCount)override;
				void													OnStyleUninstalled(ItemStyle* style)override;

				void													NotifyCloseEditor();
				void													NotifySelectCell(vint row, vint column);
				bool													StartEdit(vint row, vint column);
				void													StopEdit();
				void													OnColumnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													OnSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void													OnKeyUp(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);

			public:
				templates::GuiListViewTemplate*							GetListViewControlTemplate()override;
				void													RequestSaveData()override;

			public:
				/// <summary>Create a data grid control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiVirtualDataGrid(theme::ThemeName themeName, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualDataGrid();

				/// <summary>Selected cell changed event.</summary>
				compositions::GuiNotifyEvent							SelectedCellChanged;

				IItemProvider*											GetItemProvider()override;

				/// <summary>Change the view to data grid's default view.</summary>
				void													SetViewToDefault();

				/// <summary>Get the row index and column index of the selected cell.</summary>
				/// <returns>The row index and column index of the selected cell.</returns>
				GridPos													GetSelectedCell();

				/// <summary>Select a cell.</summary>
				/// <returns>Returns true if the editor is opened.</returns>
				/// <param name="value">The row index and column index of the selected cell.</param>
				/// <param name="openEditor">Set to true to open an editor.</param>
				bool													SelectCell(const GridPos& value, bool openEditor);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIBINDABLEDATAGRID.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATASTRUCTURED
#define VCZH_PRESENTATION_CONTROLS_GUIDATASTRUCTURED


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiBindableDataGrid;

			namespace list
			{

/***********************************************************************
Interfaces
***********************************************************************/

				class IDataProcessorCallback : public virtual IDescriptable, public Description<IDataProcessorCallback>
				{
				public:
					virtual GuiListControl::IItemProvider*				GetItemProvider() = 0;
					virtual void										OnProcessorChanged() = 0;
				};

				class IDataFilter : public virtual IDescriptable, public Description<IDataFilter>
				{
				public:
					virtual void										SetCallback(IDataProcessorCallback* value) = 0;
					virtual bool										Filter(const description::Value& row) = 0;
				};

				class IDataSorter : public virtual IDescriptable, public Description<IDataSorter>
				{
				public:
					virtual void										SetCallback(IDataProcessorCallback* value) = 0;
					virtual vint										Compare(const description::Value& row1, const description::Value& row2) = 0;
				};

/***********************************************************************
Filter Extensions
***********************************************************************/

				/// <summary>Base class for <see cref="IDataFilter"/>.</summary>
				class DataFilterBase : public Object, public virtual IDataFilter, public Description<DataFilterBase>
				{
				protected:
					IDataProcessorCallback*								callback = nullptr;

					/// <summary>Called when the structure or properties for this filter is changed.</summary>
					void												InvokeOnProcessorChanged();
				public:
					DataFilterBase();

					void												SetCallback(IDataProcessorCallback* value)override;
				};
				
				/// <summary>Base class for a <see cref="IDataFilter"/> that contains multiple sub filters.</summary>
				class DataMultipleFilter : public DataFilterBase, public Description<DataMultipleFilter>
				{
				protected:
					collections::List<Ptr<IDataFilter>>		filters;

				public:
					DataMultipleFilter();

					/// <summary>Add a sub filter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub filter.</param>
					bool												AddSubFilter(Ptr<IDataFilter> value);
					/// <summary>Remove a sub filter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub filter.</param>
					bool												RemoveSubFilter(Ptr<IDataFilter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
				};

				/// <summary>A filter that keep a row if all sub filters agree.</summary>
				class DataAndFilter : public DataMultipleFilter, public Description<DataAndFilter>
				{
				public:
					/// <summary>Create the filter.</summary>
					DataAndFilter();

					bool												Filter(const description::Value& row)override;
				};
				
				/// <summary>A filter that keep a row if one of all sub filters agrees.</summary>
				class DataOrFilter : public DataMultipleFilter, public Description<DataOrFilter>
				{
				public:
					/// <summary>Create the filter.</summary>
					DataOrFilter();

					bool												Filter(const description::Value& row)override;
				};
				
				/// <summary>A filter that keep a row if the sub filter not agrees.</summary>
				class DataNotFilter : public DataFilterBase, public Description<DataNotFilter>
				{
				protected:
					Ptr<IDataFilter>							filter;
				public:
					/// <summary>Create the filter.</summary>
					DataNotFilter();
					
					/// <summary>Set a sub filter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub filter.</param>
					bool												SetSubFilter(Ptr<IDataFilter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
					bool												Filter(const description::Value& row)override;
				};

/***********************************************************************
Sorter Extensions
***********************************************************************/

				/// <summary>Base class for <see cref="IDataSorter"/>.</summary>
				class DataSorterBase : public Object, public virtual IDataSorter, public Description<DataSorterBase>
				{
				protected:
					IDataProcessorCallback*								callback = nullptr;

					/// <summary>Called when the structure or properties for this filter is changed.</summary>
					void												InvokeOnProcessorChanged();
				public:
					DataSorterBase();

					void												SetCallback(IDataProcessorCallback* value)override;
				};
				
				/// <summary>A multi-level <see cref="IDataSorter"/>.</summary>
				class DataMultipleSorter : public DataSorterBase, public Description<DataMultipleSorter>
				{
				protected:
					Ptr<IDataSorter>							leftSorter;
					Ptr<IDataSorter>							rightSorter;
				public:
					/// <summary>Create the sorter.</summary>
					DataMultipleSorter();
					
					/// <summary>Set the first sub sorter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub sorter.</param>
					bool												SetLeftSorter(Ptr<IDataSorter> value);
					/// <summary>Set the second sub sorter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub sorter.</param>
					bool												SetRightSorter(Ptr<IDataSorter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
					vint												Compare(const description::Value& row1, const description::Value& row2)override;
				};
				
				/// <summary>A reverse order <see cref="IDataSorter"/>.</summary>
				class DataReverseSorter : public DataSorterBase, public Description<DataReverseSorter>
				{
				protected:
					Ptr<IDataSorter>							sorter;
				public:
					/// <summary>Create the sorter.</summary>
					DataReverseSorter();
					
					/// <summary>Set the sub sorter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub sorter.</param>
					bool												SetSubSorter(Ptr<IDataSorter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
					vint												Compare(const description::Value& row1, const description::Value& row2)override;
				};

/***********************************************************************
DataColumn
***********************************************************************/

				class DataColumns;
				class DataProvider;

				/// <summary>Datagrid Column.</summary>
				class DataColumn : public Object, public Description<DataColumn>
				{
					friend class DataColumns;
					friend class DataProvider;
				protected:
					DataProvider*										dataProvider = nullptr;
					ItemProperty<WString>								textProperty;
					WritableItemProperty<description::Value>			valueProperty;
					WString												text;
					vint												size = 160;
					ColumnSortingState									sortingState = ColumnSortingState::NotSorted;
					bool												ownPopup = true;
					GuiMenu*											popup = nullptr;
					Ptr<IDataFilter>									associatedFilter;
					Ptr<IDataSorter>									associatedSorter;
					Ptr<IDataVisualizerFactory>							visualizerFactory;
					Ptr<IDataEditorFactory>								editorFactory;

					void												NotifyAllColumnsUpdate(bool affectItem);
				public:
					DataColumn();
					~DataColumn();

					/// <summary>Value property name changed event.</summary>
					compositions::GuiNotifyEvent						ValuePropertyChanged;
					/// <summary>Text property name changed event.</summary>
					compositions::GuiNotifyEvent						TextPropertyChanged;

					/// <summary>Get the text for the column.</summary>
					/// <returns>The text for the column.</returns>
					WString												GetText();
					/// <summary>Set the text for the column.</summary>
					/// <param name="value">The text for the column.</param>
					void												SetText(const WString& value);

					/// <summary>Get the size for the column.</summary>
					/// <returns>The size for the column.</returns>
					vint												GetSize();
					/// <summary>Set the size for the column.</summary>
					/// <param name="value">The size for the column.</param>
					void												SetSize(vint value);

					/// <summary>Test if the column owns the popup. Owned popup will be deleted in the destructor.</summary>
					/// <returns>Returns true if the column owns the popup.</returns>
					bool												GetOwnPopup();
					/// <summary>Set if the column owns the popup.</summary>
					/// <param name="value">Set to true to let the column own the popup.</param>
					void												SetOwnPopup(bool value);

					/// <summary>Get the popup for the column.</summary>
					/// <returns>The popup for the column.</returns>
					GuiMenu*											GetPopup();
					/// <summary>Set the popup for the column.</summary>
					/// <param name="value">The popup for the column.</param>
					void												SetPopup(GuiMenu* value);

					/// <summary>Get the filter for the column.</summary>
					/// <returns>The filter for the column.</returns>
					Ptr<IDataFilter>									GetFilter();
					/// <summary>Set the filter for the column.</summary>
					/// <param name="value">The filter.</param>
					void												SetFilter(Ptr<IDataFilter> value);

					/// <summary>Get the sorter for the column.</summary>
					/// <returns>The sorter for the column.</returns>
					Ptr<IDataSorter>									GetSorter();
					/// <summary>Set the sorter for the column.</summary>
					/// <param name="value">The sorter.</param>
					void												SetSorter(Ptr<IDataSorter> value);

					/// <summary>Get the visualizer factory for the column.</summary>
					/// <returns>The the visualizer factory for the column.</returns>
					Ptr<IDataVisualizerFactory>							GetVisualizerFactory();
					/// <summary>Set the visualizer factory for the column.</summary>
					/// <param name="value">The visualizer factory.</param>
					void												SetVisualizerFactory(Ptr<IDataVisualizerFactory> value);

					/// <summary>Get the editor factory for the column.</summary>
					/// <returns>The the editor factory for the column.</returns>
					Ptr<IDataEditorFactory>								GetEditorFactory();
					/// <summary>Set the editor factory for the column.</summary>
					/// <param name="value">The editor factory.</param>
					void												SetEditorFactory(Ptr<IDataEditorFactory> value);

					/// <summary>Get the text value from an item.</summary>
					/// <returns>The text value.</returns>
					/// <param name="row">The row index of the item.</param>
					WString												GetCellText(vint row);
					/// <summary>Get the cell value from an item.</summary>
					/// <returns>The cell value.</returns>
					/// <param name="row">The row index of the item.</param>
					description::Value									GetCellValue(vint row);
					/// <summary>Set the cell value to an item.</summary>
					/// <param name="row">The row index of the item.</param>
					/// <param name="value">The value property name.</param>
					void												SetCellValue(vint row, description::Value value);

					/// <summary>Get the text property name to get the cell text from an item.</summary>
					/// <returns>The text property name.</returns>
					ItemProperty<WString>								GetTextProperty();
					/// <summary>Set the text property name to get the cell text from an item.</summary>
					/// <param name="value">The text property name.</param>
					void												SetTextProperty(const ItemProperty<WString>& value);

					/// <summary>Get the value property name to get the cell value from an item.</summary>
					/// <returns>The value property name.</returns>
					WritableItemProperty<description::Value>			GetValueProperty();
					/// <summary>Set the value property name to get the cell value from an item.</summary>
					/// <param name="value">The value property name.</param>
					void												SetValueProperty(const WritableItemProperty<description::Value>& value);
				};

				class DataColumns : public collections::ObservableListBase<Ptr<DataColumn>>
				{
					friend class DataColumn;
				protected:
					DataProvider*										dataProvider = nullptr;
					bool												affectItemFlag = true;

					void												NotifyColumnUpdated(vint index, bool affectItem);
					void												NotifyUpdateInternal(vint start, vint count, vint newCount)override;
					bool												QueryInsert(vint index, const Ptr<DataColumn>& value)override;
					void												AfterInsert(vint index, const Ptr<DataColumn>& value)override;
					void												BeforeRemove(vint index, const Ptr<DataColumn>& value)override;
				public:
					DataColumns(DataProvider* _dataProvider);
					~DataColumns();
				};

/***********************************************************************
DataProvider
***********************************************************************/

				class DataProvider
					: public virtual ItemProviderBase
					, public virtual IListViewItemView
					, public virtual ListViewColumnItemArranger::IColumnItemView
					, public virtual IDataGridView
					, public virtual IDataProcessorCallback
					, public virtual IListViewItemProvider
					, public Description<DataProvider>
				{
					friend class DataColumn;
					friend class DataColumns;
					friend class controls::GuiBindableDataGrid;
				protected:
					ListViewDataColumns										dataColumns;
					DataColumns												columns;
					ListViewColumnItemArranger::IColumnItemViewCallback*	columnItemViewCallback = nullptr;
					Ptr<description::IValueReadonlyList>					itemSource;
					Ptr<EventHandler>										itemChangedEventHandler;

					Ptr<IDataFilter>										additionalFilter;
					Ptr<IDataFilter>										currentFilter;
					Ptr<IDataSorter>										currentSorter;
					collections::List<vint>									virtualRowToSourceRow;

					void													NotifyAllItemsUpdate()override;
					void													NotifyAllColumnsUpdate()override;
					GuiListControl::IItemProvider*							GetItemProvider()override;

					void													OnProcessorChanged()override;
					void													OnItemSourceModified(vint start, vint count, vint newCount);

					void													RebuildFilter();
					void													ReorderRows(bool invokeCallback);

				public:
					ItemProperty<Ptr<GuiImageData>>							largeImageProperty;
					ItemProperty<Ptr<GuiImageData>>							smallImageProperty;

				public:
					/// <summary>Create a data provider.</summary>
					DataProvider();
					~DataProvider();

					ListViewDataColumns&								GetDataColumns();
					DataColumns&										GetColumns();
					Ptr<description::IValueEnumerable>					GetItemSource();
					void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
					
					Ptr<IDataFilter>									GetAdditionalFilter();
					void												SetAdditionalFilter(Ptr<IDataFilter> value);

					// ===================== GuiListControl::IItemProvider =====================

					vint												Count()override;
					WString												GetTextValue(vint itemIndex)override;
					description::Value									GetBindingValue(vint itemIndex)override;
					IDescriptable*										RequestView(const WString& identifier)override;
					
					// ===================== list::IListViewItemProvider =====================

					Ptr<GuiImageData>									GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(vint itemIndex)override;
					WString												GetText(vint itemIndex)override;
					WString												GetSubItem(vint itemIndex, vint index)override;
					vint												GetDataColumnCount()override;
					vint												GetDataColumn(vint index)override;
					vint												GetColumnCount()override;
					WString												GetColumnText(vint index)override;
					
					// ===================== list::ListViewColumnItemArranger::IColumnItemView =====================
						
					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint												GetColumnSize(vint index)override;
					void												SetColumnSize(vint index, vint value)override;
					GuiMenu*											GetDropdownPopup(vint index)override;
					ColumnSortingState									GetSortingState(vint index)override;
					
					// ===================== list::IDataGridView =====================

					bool												IsColumnSortable(vint column)override;
					void												SortByColumn(vint column, bool ascending)override;
					vint												GetSortedColumn()override;
					bool												IsSortOrderAscending()override;
					
					vint												GetCellSpan(vint row, vint column)override;
					IDataVisualizerFactory*								GetCellDataVisualizerFactory(vint row, vint column)override;
					IDataEditorFactory*									GetCellDataEditorFactory(vint row, vint column)override;
					description::Value									GetBindingCellValue(vint row, vint column)override;
					void												SetBindingCellValue(vint row, vint column, const description::Value& value)override;
				};
			}

/***********************************************************************
GuiBindableDataGrid
***********************************************************************/

			/// <summary>A bindable Data grid control.</summary>
			class GuiBindableDataGrid : public GuiVirtualDataGrid, public Description<GuiBindableDataGrid>
			{
			protected:
				list::DataProvider*									dataProvider = nullptr;

			public:
				/// <summary>Create a bindable Data grid control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableDataGrid(theme::ThemeName themeName);
				~GuiBindableDataGrid();

				/// <summary>Get all data columns indices in columns.</summary>
				/// <returns>All data columns indices in columns.</returns>
				list::ListViewDataColumns&							GetDataColumns();
				/// <summary>Get all columns.</summary>
				/// <returns>All columns.</returns>
				list::DataColumns&									GetColumns();

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<description::IValueEnumerable>					GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);

				/// <summary>Get the additional filter.</summary>
				/// <returns>The additional filter.</returns>
				Ptr<list::IDataFilter>								GetAdditionalFilter();
				/// <summary>Set the additional filter. This filter will be composed with filters of all column to be the final filter.</summary>
				/// <param name="value">The additional filter.</param>
				void												SetAdditionalFilter(Ptr<list::IDataFilter> value);

				/// <summary>Large image property name changed event.</summary>
				compositions::GuiNotifyEvent						LargeImagePropertyChanged;
				/// <summary>Small image property name changed event.</summary>
				compositions::GuiNotifyEvent						SmallImagePropertyChanged;

				/// <summary>Get the large image property name to get the large image from an item.</summary>
				/// <returns>The large image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetLargeImageProperty();
				/// <summary>Set the large image property name to get the large image from an item.</summary>
				/// <param name="value">The large image property name.</param>
				void												SetLargeImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);

				/// <summary>Get the small image property name to get the small image from an item.</summary>
				/// <returns>The small image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetSmallImageProperty();
				/// <summary>Set the small image property name to get the small image from an item.</summary>
				/// <param name="value">The small image property name.</param>
				void												SetSmallImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);


				/// <summary>Get the selected cell.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedRowValue();

				/// <summary>Get the selected cell.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedCellValue();
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTGENERALOPERATIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTGENERALOPERATIONS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTGENERALOPERATIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Operations
***********************************************************************/
			
			/// <summary>An text edit callback for text box controls.</summary>
			class ICommonTextEditCallback : public virtual IDescriptable, public Description<ICommonTextEditCallback>
			{
			public:
				/// <summary>Callback data for text editing preview.</summary>
				struct TextEditPreviewStruct
				{
					/// <summary>The start position of the selection before replacing. This field can be modified.</summary>
					TextPos								originalStart;
					/// <summary>The end position of the selection before replacing. This field can be modified.</summary>
					TextPos								originalEnd;
					/// <summary>The text of the selection before replacing.</summary>
					WString								originalText;
					/// <summary>The text of the selection after replacing. This field can be modified.</summary>
					WString								inputText;
					/// <summary>The base edit version.</summary>
					vuint								editVersion = 0;
					/// <summary>True if this modification is raised by the keyboard.</summary>
					bool								keyInput = false;
				};

				/// <summary>Callback data for text editing.</summary>
				struct TextEditNotifyStruct
				{
					/// <summary>The start position of the selection before replacing.</summary>
					TextPos								originalStart;
					/// <summary>The end position of the selection before replacing.</summary>
					TextPos								originalEnd;
					/// <summary>The text of the selection before replacing.</summary>
					WString								originalText;
					/// <summary>The start position of the selection after replacing.</summary>
					TextPos								inputStart;
					/// <summary>The end position of the selection after replacing.</summary>
					TextPos								inputEnd;
					/// <summary>The text of the selection after replacing.</summary>
					WString								inputText;
					/// <summary>The created edit version.</summary>
					vuint								editVersion = 0;
					/// <summary>True if this modification is raised by the keyboard.</summary>
					bool								keyInput = false;
				};
				
				/// <summary>Callback data for text caret changing.</summary>
				struct TextCaretChangedStruct
				{
					/// <summary>The start position of the selection before caret changing.</summary>
					TextPos								oldBegin;
					/// <summary>The end position of the selection before caret changing.</summary>
					TextPos								oldEnd;
					/// <summary>The start position of the selection after caret changing.</summary>
					TextPos								newBegin;
					/// <summary>The end position of the selection after caret changing.</summary>
					TextPos								newEnd;
					/// <summary>The current edit version.</summary>
					vuint								editVersion = 0;
				};

				/// <summary>Called when the callback is attached to a text box control.</summary>
				/// <param name="element">The element that used in the text box control.</param>
				/// <param name="elementModifyLock">The lock that pretect the element.</param>
				/// <param name="ownerComposition">The owner composition of this element.</param>
				/// <param name="editVersion">The current edit version.</param>
				virtual void							Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock, compositions::GuiGraphicsComposition* ownerComposition, vuint editVersion)=0;
				/// <summary>Called when the callback is detached from a text box control.</summary>
				virtual void							Detach()=0;
				/// <summary>Called before the text is edited.</summary>
				/// <param name="arguments">The data for this callback.</param>
				virtual void							TextEditPreview(TextEditPreviewStruct& arguments)=0;
				/// <summary>Called after the text is edited and before the caret is changed.</summary>
				/// <param name="arguments">The data for this callback.</param>
				virtual void							TextEditNotify(const TextEditNotifyStruct& arguments)=0;
				/// <summary>Called after the caret is changed.</summary>
				/// <param name="arguments">The data for this callback.</param>
				virtual void							TextCaretChanged(const TextCaretChangedStruct& arguments)=0;
				/// <summary>Called after the text is edited and after the caret is changed.</summary>
				/// <param name="editVersion">The current edit version.</param>
				virtual void							TextEditFinished(vuint editVersion)=0;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTCOLORIZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiTextBoxColorizerBase
***********************************************************************/
			
			/// <summary>The base class of text box colorizer.</summary>
			class GuiTextBoxColorizerBase : public Object, public virtual ICommonTextEditCallback
			{
			public:
				typedef collections::Array<elements::text::ColorEntry>			ColorArray;
			protected:
				elements::GuiColorizedTextElement*			element;
				SpinLock*									elementModifyLock;
				volatile vint								colorizedLineCount;
				volatile bool								isColorizerRunning;
				volatile bool								isFinalizing;
				SpinLock									colorizerRunningEvent;

				static void									ColorizerThreadProc(void* argument);

				void										StartColorizer();
				void										StopColorizer(bool forever);
				void										StopColorizerForever();
			public:
				/// <summary>Create a colorrizer.</summary>
				GuiTextBoxColorizerBase();
				~GuiTextBoxColorizerBase();

				void										Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void										Detach()override;
				void										TextEditPreview(TextEditPreviewStruct& arguments)override;
				void										TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void										TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void										TextEditFinished(vuint editVersion)override;
				void										RestartColorizer();

				/// <summary>Get the lexical analyzer start state for the first line.</summary>
				/// <returns>The lexical analyzer start state for the first line.</returns>
				virtual vint								GetLexerStartState()=0;
				/// <summary>Get the context sensitive start state for the first line.</summary>
				/// <returns>The context sensitive start state for the first line.</returns>
				virtual vint								GetContextStartState()=0;
				/// <summary>Colorizer one line with a start state.</summary>
				/// <param name="lineIndex">Line index.</param>
				/// <param name="text">Text buffer.</param>
				/// <param name="colors">Color index buffer. The index should be in [0 .. [M:vl.presentation.controls.GuiTextBoxColorizerBase.GetColors]()-1].</param>
				/// <param name="length">The length of the buffer.</param>
				/// <param name="lexerState">The lexical analyzer state for this line. After executing this function, the new value of this argument indicates the new state.</param>
				/// <param name="contextState">The context sensitive state for this line. After executing this function, the new value of this argument indicates the new state.</param>
				virtual void								ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, vuint32_t* colors, vint length, vint& lexerState, vint& contextState)=0;
				/// <summary>Get the supported colors ordered by their indices.</summary>
				/// <returns>The supported colors ordered by their indices.</returns>
				virtual const ColorArray&					GetColors()=0;
			};

/***********************************************************************
GuiTextBoxRegexColorizer
***********************************************************************/

			/// <summary>Regex based colorizer.</summary>
			class GuiTextBoxRegexColorizer : public GuiTextBoxColorizerBase
			{
			protected:
				Ptr<regex::RegexLexer>										lexer;
				Ptr<regex::RegexLexerColorizer>								colorizer;
				void*														colorizerArgument[1] { nullptr };
				ColorArray													colors;

				elements::text::ColorEntry									defaultColor;
				collections::List<WString>									tokenRegexes;
				collections::List<elements::text::ColorEntry>				tokenColors;
				collections::List<elements::text::ColorEntry>				extraTokenColors;

				static void													ColorizerProc(void* argument, vint start, vint length, vint token);
			public:
				/// <summary>Create the colorizer.</summary>
				GuiTextBoxRegexColorizer();
				~GuiTextBoxRegexColorizer();

				/// <summary>Get the default color.</summary>
				/// <returns>The default color.</returns>
				elements::text::ColorEntry									GetDefaultColor();
				/// <summary>Get all regular expressions for tokens.</summary>
				/// <returns>All regular expressions for tokens.</returns>
				collections::List<WString>&									GetTokenRegexes();
				/// <summary>Get all colors for tokens.</summary>
				/// <returns>All colors for tokens.</returns>
				collections::List<elements::text::ColorEntry>&				GetTokenColors();
				/// <summary>Get all colors for extra tokens.</summary>
				/// <returns>All colors for extra tokens.</returns>
				collections::List<elements::text::ColorEntry>&				GetExtraTokenColors();
				/// <summary>Get the first token index for the first extra token.</summary>
				/// <returns>The first token index for the first extra token. Returns -1 if this operation failed.</returns>
				vint														GetExtraTokenIndexStart();
				
				/// <summary>Set the default color. Call [M:vl.presentation.controls.GuiTextBoxRegexColorizer.Setup] after finishing all configuration.</summary>
				/// <returns>Returns the token index of this token. Returns -1 if this operation failed.</returns>
				/// <param name="value">The default color.</param>
				bool														SetDefaultColor(elements::text::ColorEntry value);
				/// <summary>Add a token type. Call [M:vl.presentation.controls.GuiTextBoxRegexColorizer.Setup] after finishing all configuration.</summary>
				/// <returns>Returns the token index of this token. Returns -1 if this operation failed.</returns>
				/// <param name="regex">The regular expression for this token type.</param>
				/// <param name="color">The color for this token type.</param>
				vint														AddToken(const WString& regex, elements::text::ColorEntry color);
				/// <summary>Add an extra  token type. Call [M:vl.presentation.controls.GuiTextBoxRegexColorizer.Setup] after finishing all configuration.</summary>
				/// <returns>Returns the extra token index of this token. The token index for this token is regex-token-count + extra-token-index Returns -1 if this operation failed.</returns>
				/// <param name="color">The color for this token type.</param>
				vint														AddExtraToken(elements::text::ColorEntry color);
				/// <summary>Clear all token color settings.</summary>
				void														ClearTokens();
				/// <summary>Setup the colorizer. After that, the colorizer cannot be changed.</summary>
				void														Setup();
				/// <summary>Callback function to set context sensitive state and change token accordingly.</summary>
				/// <param name="lineIndex">Line index.</param>
				/// <param name="text">Text buffer.</param>
				/// <param name="start">The start position of the token.</param>
				/// <param name="length">The length of the token.</param>
				/// <param name="token">The token type. After executing this function, the new value of this argument indicates the new token type.</param>
				/// <param name="contextState">The context sensitive state. After executing this function, the new value of this argument indicates the new state.</param>
				virtual void												ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState);

				vint														GetLexerStartState()override;
				vint														GetContextStartState()override;
				void														ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, vuint32_t* colors, vint length, vint& lexerState, vint& contextState)override;
				const ColorArray&											GetColors()override;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTUNDOREDO.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO
#define VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiTextBoxCommonInterface;

/***********************************************************************
Undo Redo
***********************************************************************/

			class GuiGeneralUndoRedoProcessor : public Object
			{
			protected:
				class IEditStep : public Interface
				{
				public:
					virtual void							Undo()=0;
					virtual void							Redo()=0;
				};
				friend class collections::ArrayBase<Ptr<IEditStep>>;

			protected:
				collections::List<Ptr<IEditStep>>			steps;
				vint										firstFutureStep;
				vint										savedStep;
				bool										performingUndoRedo;

				void										PushStep(Ptr<IEditStep> step);
			public:
				GuiGeneralUndoRedoProcessor();
				~GuiGeneralUndoRedoProcessor();

				Event<void()>								UndoRedoChanged;
				Event<void()>								ModifiedChanged;

				bool										CanUndo();
				bool										CanRedo();
				void										ClearUndoRedo();
				bool										GetModified();
				void										NotifyModificationSaved();
				bool										Undo();
				bool										Redo();
			};

/***********************************************************************
Undo Redo (Text)
***********************************************************************/

			class GuiTextBoxUndoRedoProcessor : public GuiGeneralUndoRedoProcessor, public ICommonTextEditCallback
			{
			protected:
				class EditStep : public Object, public IEditStep
				{
				public:
					GuiTextBoxUndoRedoProcessor*			processor;
					TextEditNotifyStruct					arguments;
					
					void									Undo();
					void									Redo();
				};

				compositions::GuiGraphicsComposition*		ownerComposition;
			public:
				GuiTextBoxUndoRedoProcessor();
				~GuiTextBoxUndoRedoProcessor();

				void										Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void										Detach()override;
				void										TextEditPreview(TextEditPreviewStruct& arguments)override;
				void										TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void										TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void										TextEditFinished(vuint editVersion)override;
			};

/***********************************************************************
Undo Redo (Document)
***********************************************************************/

			class GuiDocumentUndoRedoProcessor : public GuiGeneralUndoRedoProcessor
			{
			public:
				struct ReplaceModelStruct
				{
					TextPos									originalStart;
					TextPos									originalEnd;
					Ptr<DocumentModel>						originalModel;
					TextPos									inputStart;
					TextPos									inputEnd;
					Ptr<DocumentModel>						inputModel;

					ReplaceModelStruct()
					{
					}
				};

				struct RenameStyleStruct
				{
					WString									oldStyleName;
					WString									newStyleName;

					RenameStyleStruct()
					{
					}
				};

				struct SetAlignmentStruct
				{
					vint									start;
					vint									end;
					collections::Array<Nullable<Alignment>>	originalAlignments;
					collections::Array<Nullable<Alignment>>	inputAlignments;
				};

			protected:
				elements::GuiDocumentElement*				element;
				compositions::GuiGraphicsComposition*		ownerComposition;
				
				class ReplaceModelStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					ReplaceModelStruct						arguments;
					
					void									Undo();
					void									Redo();
				};

				class RenameStyleStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					RenameStyleStruct						arguments;
					
					void									Undo();
					void									Redo();
				};

				class SetAlignmentStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					Ptr<SetAlignmentStruct>					arguments;
					
					void									Undo();
					void									Redo();
				};
			public:

				GuiDocumentUndoRedoProcessor();
				~GuiDocumentUndoRedoProcessor();

				void										Setup(elements::GuiDocumentElement* _element, compositions::GuiGraphicsComposition* _ownerComposition);
				void										OnReplaceModel(const ReplaceModelStruct& arguments);
				void										OnRenameStyle(const RenameStyleStruct& arguments);
				void										OnSetAlignment(Ptr<SetAlignmentStruct> arguments);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\GUIDOCUMENTVIEWER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDOCUMENTVIEWER
#define VCZH_PRESENTATION_CONTROLS_GUIDOCUMENTVIEWER


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiShortcutKeyManager;
		}

		namespace controls
		{

/***********************************************************************
GuiDocumentCommonInterface
***********************************************************************/

			class GuiDocumentCommonInterface;

			/// <summary>Embedded object in a document.</summary>
			class GuiDocumentItem : public Object, public Description<GuiDocumentItem>
			{
				friend class GuiDocumentCommonInterface;
			protected:
				bool										visible = false;
				WString										name;
				compositions::GuiBoundsComposition*			container;
				bool										owned = false;
			public:
				GuiDocumentItem(const WString& _name);
				~GuiDocumentItem();
				
				/// <summary>Get the container for all embedded controls and compositions in this item.</summary>
				/// <returns>The container.</returns>
				compositions::GuiGraphicsComposition*		GetContainer();

				/// <summary>Get the name of the document item.</summary>
				/// <returns>The name.</returns>
				WString										GetName();
			};
			
			/// <summary>Document displayer control common interface for displaying <see cref="DocumentModel"/>.</summary>
			class GuiDocumentCommonInterface abstract
				: protected virtual elements::GuiDocumentElement::ICallback
				, public Description<GuiDocumentCommonInterface>
			{
				typedef collections::Dictionary<WString, Ptr<GuiDocumentItem>>		DocumentItemMap;
			public:
				/// <summary>Represents the edit mode.</summary>
				enum EditMode
				{
					/// <summary>View the rich text only.</summary>
					ViewOnly,
					/// <summary>The rich text is selectable.</summary>
					Selectable,
					/// <summary>The rich text is editable.</summary>
					Editable,
				};
			protected:
				Ptr<DocumentModel>							baselineDocument;
				DocumentItemMap								documentItems;
				GuiControl*									documentControl = nullptr;
				elements::GuiDocumentElement*				documentElement = nullptr;
				compositions::GuiBoundsComposition*			documentComposition = nullptr;
				Ptr<DocumentHyperlinkRun::Package>			activeHyperlinks;
				bool										dragging = false;
				EditMode									editMode = EditMode::ViewOnly;

				Ptr<GuiDocumentUndoRedoProcessor>			undoRedoProcessor;
				Ptr<compositions::GuiShortcutKeyManager>	internalShortcutKeyManager;

			protected:
				void										InvokeUndoRedoChanged();
				void										InvokeModifiedChanged();
				void										UpdateCaretPoint();
				void										Move(TextPos caret, bool shift, bool frontSide);
				bool										ProcessKey(VKEY code, bool shift, bool ctrl);
				void										InstallDocumentViewer(GuiControl* _sender, compositions::GuiGraphicsComposition* _container, compositions::GuiGraphicsComposition* eventComposition, compositions::GuiGraphicsComposition* focusableComposition);
				void										SetActiveHyperlink(Ptr<DocumentHyperlinkRun::Package> package);
				void										ActivateActiveHyperlink(bool activate);
				void										AddShortcutCommand(VKEY key, const Func<void()>& eventHandler);
				void										EditTextInternal(TextPos begin, TextPos end, const Func<void(TextPos, TextPos, vint&, vint&)>& editor);
				void										EditStyleInternal(TextPos begin, TextPos end, const Func<void(TextPos, TextPos)>& editor);
				
				void										MergeBaselineAndDefaultFont(Ptr<DocumentModel> document);
				void										OnFontChanged();
				void										OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void										OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);
				void										OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				virtual Point								GetDocumentViewPosition();
				virtual void								EnsureRectVisible(Rect bounds);

				//================ callback

				void										OnStartRender()override;
				void										OnFinishRender()override;
				Size										OnRenderEmbeddedObject(const WString& name, const Rect& location)override;
			public:
				GuiDocumentCommonInterface();
				~GuiDocumentCommonInterface();

				/// <summary>Active hyperlink changed event.</summary>
				compositions::GuiNotifyEvent				ActiveHyperlinkChanged;
				/// <summary>Active hyperlink executed event.</summary>
				compositions::GuiNotifyEvent				ActiveHyperlinkExecuted;

				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent				SelectionChanged;
				/// <summary>Undo redo status changed event.</summary>
				compositions::GuiNotifyEvent				UndoRedoChanged;
				/// <summary>Modified status changed event.</summary>
				compositions::GuiNotifyEvent				ModifiedChanged;
				
				/// <summary>Get the document.</summary>
				/// <returns>The document.</returns>
				Ptr<DocumentModel>							GetDocument();
				/// <summary>Set the document. When a document is set to this element, modifying the document without invoking <see cref="NotifyParagraphUpdated"/> will lead to undefined behavior.</summary>
				/// <param name="value">The document.</param>
				void										SetDocument(Ptr<DocumentModel> value);

				//================ document items

				/// <summary>Add a document item. The name of the document item will display in the position of the &lt;object&gt; element with the same name in the document.</summary>
				/// <param name="value">The document item.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										AddDocumentItem(Ptr<GuiDocumentItem> value);

				/// <summary>Remove a document item.</summary>
				/// <param name="value">The document item.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										RemoveDocumentItem(Ptr<GuiDocumentItem> value);

				/// <summary>Get all document items.</summary>
				/// <returns>All document items.</returns>
				const DocumentItemMap&						GetDocumentItems();

				//================ caret operations

				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos										GetCaretBegin();
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos										GetCaretEnd();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="begin">The begin position of the selection area.</param>
				/// <param name="end">The end position of the selection area.</param>
				void										SetCaret(TextPos begin, TextPos end);
				/// <summary>Calculate a caret using a specified point.</summary>
				/// <returns>The calculated caret.</returns>
				/// <param name="point">The specified point.</param>
				TextPos										CalculateCaretFromPoint(Point point);
				/// <summary>Get the bounds of a caret.</summary>
				/// <returns>The bounds.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="frontSide">Set to true to get the bounds for the character before it.</param>
				Rect										GetCaretBounds(TextPos caret, bool frontSide);

				//================ editing operations

				/// <summary>Notify that some paragraphs are updated.</summary>
				/// <param name="index">The start paragraph index.</param>
				/// <param name="oldCount">The number of paragraphs to be updated.</param>
				/// <param name="newCount">The number of updated paragraphs.</param>
				/// <param name="updatedText">Set to true to notify that the text is updated.</param>
				void										NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
				/// <summary>Edit run in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="model">The new run.</param>
				/// <param name="copy">Set to true to copy the model before editing. Otherwise, objects inside the model will be used directly</param>
				void										EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> model, bool copy);
				/// <summary>Edit text in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="frontSide">Set to true to use the text style in front of the specified range.</param>
				/// <param name="text">The new text.</param>
				void										EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
				/// <summary>Edit style in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="style">The new style.</param>
				void										EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
				/// <summary>Edit image in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="image">The new image.</param>
				void										EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
				/// <summary>Set hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="reference">The reference of the hyperlink.</param>
				/// <param name="normalStyleName">The normal style name of the hyperlink.</param>
				/// <param name="activeStyleName">The active style name of the hyperlink.</param>
				void										EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=DocumentModel::NormalLinkStyleName, const WString& activeStyleName=DocumentModel::ActiveLinkStyleName);
				/// <summary>Remove hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
				/// <summary>Edit style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="styleName">The new style name.</param>
				void										EditStyleName(TextPos begin, TextPos end, const WString& styleName);
				/// <summary>Remove style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveStyleName(TextPos begin, TextPos end);
				/// <summary>Rename a style.</summary>
				/// <param name="oldStyleName">The name of the style.</param>
				/// <param name="newStyleName">The new name.</param>
				void										RenameStyle(const WString& oldStyleName, const WString& newStyleName);
				/// <summary>Clear all styles in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										ClearStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the text style in a specified range.</summary>
				/// <returns>The text style summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Ptr<DocumentStyleProperties>				SummarizeStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the style name in a specified range.</summary>
				/// <returns>The style name summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<WString>							SummarizeStyleName(TextPos begin, TextPos end);
				/// <summary>Set the alignment of paragraphs in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="alignments">The alignment for each paragraph.</param>
				void										SetParagraphAlignments(TextPos begin, TextPos end, const collections::Array<Nullable<Alignment>>& alignments);
				/// <summary>Set the alignment of paragraphs in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="alignment">The alignment for each paragraph.</param>
				void										SetParagraphAlignment(TextPos begin, TextPos end, Nullable<Alignment> alignment);
				/// <summary>Summarize the text alignment in a specified range.</summary>
				/// <returns>The text alignment summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<Alignment>							SummarizeParagraphAlignment(TextPos begin, TextPos end);

				//================ editing control

				/// <summary>Get the href attribute of the active hyperlink.</summary>
				/// <returns>The href attribute of the active hyperlink.</returns>
				WString										GetActiveHyperlinkReference();
				/// <summary>Get the edit mode of this control.</summary>
				/// <returns>The edit mode.</returns>
				EditMode									GetEditMode();
				/// <summary>Set the edit mode of this control.</summary>
				/// <param name="value">The edit mode.</param>
				void										SetEditMode(EditMode value);

				//================ selection operations

				/// <summary>Select all text.</summary>
				void										SelectAll();
				/// <summary>Get the selected text.</summary>
				/// <returns>The selected text.</returns>
				WString										GetSelectionText();
				/// <summary>Set the selected text.</summary>
				/// <param name="value">The selected text.</param>
				void										SetSelectionText(const WString& value);
				/// <summary>Get the selected model.</summary>
				/// <returns>The selected model.</returns>
				Ptr<DocumentModel>							GetSelectionModel();
				/// <summary>Set the selected model.</summary>
				/// <param name="value">The selected model.</param>
				void										SetSelectionModel(Ptr<DocumentModel> value);

				//================ clipboard operations

				/// <summary>Test can the selection be cut.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool										CanCut();
				/// <summary>Test can the selection be copied.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool										CanCopy();
				/// <summary>Test can the content in the clipboard be pasted.</summary>
				/// <returns>Returns true if the content in the clipboard can be pasted.</returns>
				bool										CanPaste();
				/// <summary>Cut the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Cut();
				/// <summary>Copy the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Copy();
				/// <summary>Paste the content from the clipboard and replace the selected text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Paste();

				//================ undo redo control

				/// <summary>Test can undo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool										CanUndo();
				/// <summary>Test can redo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool										CanRedo();
				/// <summary>Clear all undo and redo information.</summary>
				void										ClearUndoRedo();
				/// <summary>Test is the text box modified.</summary>
				/// <returns>Returns true if the text box is modified.</returns>
				bool										GetModified();
				/// <summary>Notify the text box that the current status is considered saved.</summary>
				void										NotifyModificationSaved();
				/// <summary>Perform the undo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Undo();
				/// <summary>Perform the redo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Redo();
			};

/***********************************************************************
GuiDocumentViewer
***********************************************************************/
			
			/// <summary>Scrollable document viewer for displaying <see cref="DocumentModel"/>.</summary>
			class GuiDocumentViewer : public GuiScrollContainer, public GuiDocumentCommonInterface, public Description<GuiDocumentViewer>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DocumentViewerTemplate, GuiScrollContainer)
			protected:

				void										UpdateDisplayFont()override;
				Point										GetDocumentViewPosition()override;
				void										EnsureRectVisible(Rect bounds)override;
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiDocumentViewer(theme::ThemeName themeName);
				~GuiDocumentViewer();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};

/***********************************************************************
GuiDocumentViewer
***********************************************************************/
			
			/// <summary>Static document viewer for displaying <see cref="DocumentModel"/>.</summary>
			class GuiDocumentLabel : public GuiControl, public GuiDocumentCommonInterface, public Description<GuiDocumentLabel>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DocumentLabelTemplate, GuiControl)
			protected:

				void										UpdateDisplayFont()override;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiDocumentLabel(theme::ThemeName themeName);
				~GuiDocumentLabel();
				
				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\INCLUDEFORWARD.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_INCLUDEFORWARD
#define VCZH_PRESENTATION_CONTROLS_INCLUDEFORWARD


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiCustomControl;
			class GuiLabel;
			class GuiButton;
			class GuiSelectableButton;
			class GuiScroll;
			class GuiTabPage;
			class GuiTab;
			class GuiScrollView;
			class GuiScrollContainer;
			class GuiControlHost;
			class GuiWindow;
			class GuiPopup;
			class GuiTooltip;
			class GuiListControl;
			class GuiSelectableListControl;
			class GuiVirtualTextList;
			class GuiTextList;
			class GuiListViewColumnHeader;
			class GuiListViewBase;
			class GuiVirtualListView;
			class GuiListView;
			class GuiMenu;
			class GuiMenuBar;
			class GuiMenuButton;
			class GuiVirtualTreeListControl;
			class GuiVirtualTreeView;
			class GuiTreeView;
			class GuiComboBoxBase;
			class GuiComboBoxListControl;
			class GuiToolstripMenu;
			class GuiToolstripMenuBar;
			class GuiToolstripToolBar;
			class GuiToolstripButton;
			class GuiToolstripNestedContainer;
			class GuiToolstripGroupContainer;
			class GuiToolstripGroup;
			class GuiRibbonTab;
			class GuiRibbonTabPage;
			class GuiRibbonGroup;
			class GuiRibbonIconLabel;
			class GuiRibbonButtons;
			class GuiRibbonToolstrips;
			class GuiRibbonGallery;
			class GuiRibbonToolstripMenu;
			class GuiBindableRibbonGalleryList;
			class GuiDocumentViewer;
			class GuiDocumentLabel;
			class GuiMultilineTextBox;
			class GuiSinglelineTextBox;
			class GuiVirtualDataGrid;
			class GuiDatePicker;
			class GuiDateComboBox;
			class GuiBindableTextList;
			class GuiBindableListView;
			class GuiBindableTreeView;
			class GuiBindableDataGrid;
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTAUTOCOMPLETE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTAUTOCOMPLETE
#define VCZH_PRESENTATION_CONTROLS_GUITEXTAUTOCOMPLETE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiTextBoxAutoCompleteBase
***********************************************************************/
			
			/// <summary>The base class of text box auto complete controller.</summary>
			class GuiTextBoxAutoCompleteBase : public Object, public virtual ICommonTextEditCallback
			{
			public:
				/// <summary>Represents an auto complete candidate item.</summary>
				struct AutoCompleteItem
				{
					/// <summary>Tag object for any purpose, e.g., data binding.</summary>
					description::Value								tag;
					/// <summary>Display text for the item.</summary>
					WString											text;
				};

				/// <summary>Auto complete control provider.</summary>
				class IAutoCompleteControlProvider : public virtual Interface
				{
				public:
					/// <summary>Get the auto complete control that will be installed in a popup to show candidate items.</summary>
					/// <returns>The auto complete control.</returns>
					virtual GuiControl*								GetAutoCompleteControl() = 0;

					/// <summary>Get the list control storing candidate items.</summary>
					/// <returns>The list control. It should be inside the auto complete control, or the auto complete control itself.</returns>
					virtual GuiSelectableListControl*				GetListControl() = 0;

					/// <summary>Store candidate items in the list control.</summary>
					/// <param name="items">Candidate items.</param>
					virtual void									SetSortedContent(const collections::List<AutoCompleteItem>& items) = 0;

					/// <summary>Get the numbers of all stored candidate items.</summary>
					/// <returns>The number of all stored candidate items.</returns>
					virtual vint									GetItemCount() = 0;

					/// <summary>Get the text of a specified item.</summary>
					/// <param name="index">The index of the item.</param>
					/// <returns>The text of the item.</returns>
					virtual WString									GetItemText(vint index) = 0;
				};

				class TextListControlProvider : public Object, public virtual IAutoCompleteControlProvider
				{
				protected:
					GuiTextList*									autoCompleteList;

				public:
					TextListControlProvider(TemplateProperty<templates::GuiTextListTemplate> controlTemplate = {});
					~TextListControlProvider();

					GuiControl*										GetAutoCompleteControl()override;
					GuiSelectableListControl*						GetListControl()override;
					void											SetSortedContent(const collections::List<AutoCompleteItem>& items)override;
					vint											GetItemCount()override;
					WString											GetItemText(vint index)override;
				};

			protected:
				elements::GuiColorizedTextElement*					element;
				SpinLock*											elementModifyLock;
				compositions::GuiGraphicsComposition*				ownerComposition;
				GuiPopup*											autoCompletePopup;
				Ptr<IAutoCompleteControlProvider>					autoCompleteControlProvider;
				TextPos												autoCompleteStartPosition;

				bool												IsPrefix(const WString& prefix, const WString& candidate);
			public:
				/// <summary>Create an auto complete.</summary>
				/// <param name="_autoCompleteControlProvider">A auto complete control provider. Set to null to use a default one.</param>
				GuiTextBoxAutoCompleteBase(Ptr<IAutoCompleteControlProvider> _autoCompleteControlProvider = nullptr);
				~GuiTextBoxAutoCompleteBase();

				void												Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void												Detach()override;
				void												TextEditPreview(TextEditPreviewStruct& arguments)override;
				void												TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void												TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void												TextEditFinished(vuint editVersion)override;

				/// <summary>Get the list state.</summary>
				/// <returns>Returns true if the list is visible.</returns>
				bool												IsListOpening();
				/// <summary>Notify the list to be visible.</summary>
				/// <param name="startPosition">The text position to show the list.</param>
				void												OpenList(TextPos startPosition);
				/// <summary>Notify the list to be invisible.</summary>
				void												CloseList();
				/// <summary>Set the content of the list.</summary>
				/// <param name="items">The content of the list.</param>
				void												SetListContent(const collections::List<AutoCompleteItem>& items);
				/// <summary>Get the last start position when the list is opened.</summary>
				/// <returns>The start position.</returns>
				TextPos												GetListStartPosition();
				/// <summary>Select the previous item.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												SelectPreviousListItem();
				/// <summary>Select the next item.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												SelectNextListItem();
				/// <summary>Apply the selected item into the text box.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												ApplySelectedListItem();
				/// <summary>Get the selected item.</summary>
				/// <returns>The text of the selected item. Returns empty if there is no selected item.</returns>
				WString												GetSelectedListItem();
				/// <summary>Highlight a candidate item in the list.</summary>
				/// <param name="editingText">The text to match an item.</param>
				void												HighlightList(const WString& editingText);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\GUITEXTCOMMONINTERFACE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiShortcutKeyManager;
		}

		namespace controls
		{

/***********************************************************************
Common Interface
***********************************************************************/

			/// <summary>Common interface for text box controls.</summary>
			class GuiTextBoxCommonInterface abstract : public Description<GuiTextBoxCommonInterface>
			{
				typedef collections::Array<elements::text::ColorEntry>			ColorArray;
			protected:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual TextPos									GetLeftWord(TextPos pos)=0;
					virtual TextPos									GetRightWord(TextPos pos)=0;
					virtual void									GetWord(TextPos pos, TextPos& begin, TextPos& end)=0;
					virtual vint									GetPageRows()=0;
					virtual bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)=0;
					virtual void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
					virtual void									ScrollToView(Point point)=0;
					virtual vint									GetTextMargin()=0;
				};

				class DefaultCallback : public Object, public ICallback, public Description<DefaultCallback>
				{
				protected:
					elements::GuiColorizedTextElement*				textElement;
					compositions::GuiGraphicsComposition*			textComposition;
					bool											readonly;
				public:
					DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition);
					~DefaultCallback();

					TextPos											GetLeftWord(TextPos pos)override;
					TextPos											GetRightWord(TextPos pos)override;
					void											GetWord(TextPos pos, TextPos& begin, TextPos& end)override;
					vint											GetPageRows()override;
					bool											BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
				};
			private:
				elements::GuiColorizedTextElement*					textElement;
				compositions::GuiGraphicsComposition*				textComposition;
				vuint												editVersion;
				GuiControl*											textControl;
				ICallback*											callback;
				bool												dragging;
				bool												readonly;
				Ptr<GuiTextBoxColorizerBase>						colorizer;
				Ptr<GuiTextBoxAutoCompleteBase>						autoComplete;
				Ptr<GuiTextBoxUndoRedoProcessor>					undoRedoProcessor;

				bool												filledDefaultColors = false;
				ColorArray											defaultColors;

				SpinLock											elementModifyLock;
				collections::List<Ptr<ICommonTextEditCallback>>		textEditCallbacks;
				Ptr<compositions::GuiShortcutKeyManager>			internalShortcutKeyManager;
				bool												preventEnterDueToAutoComplete;

				void												InvokeUndoRedoChanged();
				void												InvokeModifiedChanged();
				void												UpdateCaretPoint();
				void												Move(TextPos pos, bool shift);
				void												Modify(TextPos start, TextPos end, const WString& input, bool asKeyInput);
				bool												ProcessKey(VKEY code, bool shift, bool ctrl);
					
				void												OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void												OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void												OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);

			protected:

				void												Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl, compositions::GuiGraphicsComposition* eventComposition, compositions::GuiGraphicsComposition* focusableComposition);
				ICallback*											GetCallback();
				void												SetCallback(ICallback* value);
				bool												AttachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				bool												DetachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				void												AddShortcutCommand(VKEY key, const Func<void()>& eventHandler);
				elements::GuiColorizedTextElement*					GetTextElement();
				void												UnsafeSetText(const WString& value);

			public:
				GuiTextBoxCommonInterface();
				~GuiTextBoxCommonInterface();

				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent						SelectionChanged;
				/// <summary>Undo redo status changed event.</summary>
				compositions::GuiNotifyEvent						UndoRedoChanged;
				/// <summary>Modified status changed event.</summary>
				compositions::GuiNotifyEvent						ModifiedChanged;

				//================ clipboard operations

				/// <summary>Test can the selection be cut.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool												CanCut();
				/// <summary>Test can the selection be copied.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool												CanCopy();
				/// <summary>Test can the content in the clipboard be pasted.</summary>
				/// <returns>Returns true if the content in the clipboard can be pasted.</returns>
				bool												CanPaste();
				/// <summary>Cut the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Cut();
				/// <summary>Copy the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Copy();
				/// <summary>Paste the content from the clipboard and replace the selected text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Paste();

				//================ editing control

				/// <summary>Get the readonly mode.</summary>
				/// <returns>Returns true if the text box is readonly.</returns>
				bool												GetReadonly();
				/// <summary>Set the readonly mode.</summary>
				/// <param name="value">Set to true to make the texg box readonly.</param>
				void												SetReadonly(bool value);

				//================ text operations

				/// <summary>Select all text.</summary>
				void												SelectAll();
				/// <summary>Select (highlight) a part of text.</summary>
				/// <param name="begin">The begin position.</param>
				/// <param name="end">The end position. This is also the caret position.</param>
				void												Select(TextPos begin, TextPos end);
				/// <summary>Get the selected text.</summary>
				/// <returns>The selected text.</returns>
				WString												GetSelectionText();
				/// <summary>Set the selected text.</summary>
				/// <param name="value">The selected text.</param>
				void												SetSelectionText(const WString& value);
				/// <summary>Set the selected text and let to text box treat this changing as input by the keyboard.</summary>
				/// <param name="value">The selected text.</param>
				void												SetSelectionTextAsKeyInput(const WString& value);
				
				/// <summary>Get the text from a specified row number.</summary>
				/// <returns>The text from a specified row number.</returns>
				/// <param name="row">The specified row number.</param>
				WString												GetRowText(vint row);
				/// <summary>Get the number of rows.</summary>
				/// <returns>The number of rows.</returns>
				vint												GetRowCount();
				/// <summary>Get the text from a specified range.</summary>
				/// <returns>The text from a specified range.</returns>
				/// <param name="start">The specified start position.</param>
				/// <param name="end">The specified end position.</param>
				WString												GetFragmentText(TextPos start, TextPos end);

				/// <summary>Get the begin text position of the selection.</summary>
				/// <returns>The begin text position of the selection.</returns>
				TextPos												GetCaretBegin();
				/// <summary>Get the end text position of the selection.</summary>
				/// <returns>The end text position of the selection.</returns>
				TextPos												GetCaretEnd();
				/// <summary>Get the left-top text position of the selection.</summary>
				/// <returns>The left-top text position of the selection.</returns>
				TextPos												GetCaretSmall();
				/// <summary>Get the right-bottom text position of the selection.</summary>
				/// <returns>The right-bottom text position of the selection.</returns>
				TextPos												GetCaretLarge();

				//================ position query

				/// <summary>Get the width of a row.</summary>
				/// <returns>The width of a row in pixel.</returns>
				/// <param name="row">The specified row number</param>
				vint												GetRowWidth(vint row);
				/// <summary>Get the height of a row.</summary>
				/// <returns>The height of a row in pixel.</returns>
				vint												GetRowHeight();
				/// <summary>Get the maximum width of all rows.</summary>
				/// <returns>The maximum width of all rows.</returns>
				vint												GetMaxWidth();
				/// <summary>Get the total height of all rows.</summary>
				/// <returns>The total height of all rows.</returns>
				vint												GetMaxHeight();
				/// <summary>Get the nearest position of a character from a specified display position.</summary>
				/// <returns>Get the nearest position of a character.</returns>
				/// <param name="point">The specified display position.</param>
				TextPos												GetTextPosFromPoint(Point point);
				/// <summary>Get the display position of a character from a specified text position.</summary>
				/// <returns>Get the display position of a character.</returns>
				/// <param name="pos">The specified text position.</param>
				Point												GetPointFromTextPos(TextPos pos);
				/// <summary>Get the display bounds of a character from a specified text position.</summary>
				/// <returns>Get the display bounds of a character.</returns>
				/// <param name="pos">The specified text position.</param>
				Rect												GetRectFromTextPos(TextPos pos);
				/// <summary>Get the nearest text position from a specified display position.</summary>
				/// <returns>Get the nearest text position.</returns>
				/// <param name="point">The specified display position.</param>
				TextPos												GetNearestTextPos(Point point);

				//================ colorizing

				/// <summary>Get the current colorizer.</summary>
				/// <returns>The current colorizer.</returns>
				Ptr<GuiTextBoxColorizerBase>						GetColorizer();
				/// <summary>Set the current colorizer.</summary>
				/// <param name="value">The current colorizer.</param>
				void												SetColorizer(Ptr<GuiTextBoxColorizerBase> value);

				//================ auto complete

				/// <summary>Get the current auto complete controller.</summary>
				/// <returns>The current auto complete controller.</returns>
				Ptr<GuiTextBoxAutoCompleteBase>						GetAutoComplete();
				/// <summary>Set the current auto complete controller.</summary>
				/// <param name="value">The current auto complete controller.</param>
				void												SetAutoComplete(Ptr<GuiTextBoxAutoCompleteBase> value);

				//================ undo redo control

				/// <summary>Get the current edit version. When the control is modified, the edit version increased. Calling <see cref="NotifyModificationSaved"/> will not reset the edit version.</summary>
				/// <returns>The current edit version.</returns>
				vuint												GetEditVersion();
				/// <summary>Test can undo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool												CanUndo();
				/// <summary>Test can redo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool												CanRedo();
				/// <summary>Clear all undo and redo information.</summary>
				void												ClearUndoRedo();
				/// <summary>Test is the text box modified.</summary>
				/// <returns>Returns true if the text box is modified.</returns>
				bool												GetModified();
				/// <summary>Notify the text box that the current status is considered saved.</summary>
				void												NotifyModificationSaved();
				/// <summary>Perform the undo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Undo();
				/// <summary>Perform the redo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Redo();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\GUITEXTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
MultilineTextBox
***********************************************************************/

			/// <summary>Multiline text box control.</summary>
			class GuiMultilineTextBox : public GuiScrollView, public GuiTextBoxCommonInterface, public Description<GuiMultilineTextBox>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(MultilineTextBoxTemplate, GuiScrollView)
			public:
				static const vint							TextMargin=3;

				class CommandExecutor : public Object, public ITextBoxCommandExecutor
				{
				protected:
					GuiMultilineTextBox*					textBox;

				public:
					CommandExecutor(GuiMultilineTextBox* _textBox);
					~CommandExecutor();

					void									UnsafeSetText(const WString& value)override;
				};

			protected:
				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiMultilineTextBox*					textControl;
				public:
					TextElementOperatorCallback(GuiMultilineTextBox* _textControl);

					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};

			protected:
				Ptr<TextElementOperatorCallback>			callback;
				Ptr<CommandExecutor>						commandExecutor;
				elements::GuiColorizedTextElement*			textElement = nullptr;
				compositions::GuiBoundsComposition*			textComposition = nullptr;

				void										UpdateVisuallyEnabled()override;
				void										UpdateDisplayFont()override;
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				Size										QueryFullSize()override;
				void										UpdateView(Rect viewBounds)override;
				void										CalculateViewAndSetScroll();
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiMultilineTextBox(theme::ThemeName themeName);
				~GuiMultilineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};

/***********************************************************************
SinglelineTextBox
***********************************************************************/
			
			/// <summary>Single text box control.</summary>
			class GuiSinglelineTextBox : public GuiControl, public GuiTextBoxCommonInterface, public Description<GuiSinglelineTextBox>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(SinglelineTextBoxTemplate, GuiControl)
			public:
				static const vint							TextMargin=2;
				
			protected:
				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				public:
					TextElementOperatorCallback(GuiSinglelineTextBox* _textControl);

					bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};

			protected:
				Ptr<TextElementOperatorCallback>			callback;
				elements::GuiColorizedTextElement*			textElement = nullptr;
				compositions::GuiTableComposition*			textCompositionTable = nullptr;
				compositions::GuiCellComposition*			textComposition = nullptr;
				
				void										UpdateVisuallyEnabled()override;
				void										UpdateDisplayFont()override;
				void										RearrangeTextElement();
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiSinglelineTextBox(theme::ThemeName themeName);
				~GuiSinglelineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;

				/// <summary>
				/// Get the password mode displaying character.
				/// </summary>
				/// <returns>The password mode displaying character. Returns L'\0' means the password mode is not activated.</returns>
				wchar_t										GetPasswordChar();
				/// <summary>
				/// Set the password mode displaying character.
				/// </summary>
				/// <param name="value">The password mode displaying character. Set to L'\0' to deactivate the password mode.</param>
				void										SetPasswordChar(wchar_t value);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPCOMMAND.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class IGuiShortcutKeyItem;
		}

		namespace controls
		{
			/// <summary>A command for toolstrip controls.</summary>
			class GuiToolstripCommand : public GuiComponent, public Description<GuiToolstripCommand>
			{
			public:
				class ShortcutBuilder : public Object
				{
				public:
					WString									text;
					bool									ctrl;
					bool									shift;
					bool									alt;
					VKEY									key;
				};
			protected:
				Ptr<GuiImageData>							image;
				Ptr<GuiImageData>							largeImage;
				WString										text;
				compositions::IGuiShortcutKeyItem*			shortcutKeyItem = nullptr;
				bool										enabled = true;
				bool										selected = false;
				Ptr<compositions::IGuiGraphicsEventHandler>	shortcutKeyItemExecutedHandler;
				Ptr<ShortcutBuilder>						shortcutBuilder;

				GuiInstanceRootObject*						attachedRootObject = nullptr;
				Ptr<compositions::IGuiGraphicsEventHandler>	renderTargetChangedHandler;
				GuiControlHost*								shortcutOwner = nullptr;

				void										OnShortcutKeyItemExecuted(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnRenderTargetChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										InvokeDescriptionChanged();
				void										ReplaceShortcut(compositions::IGuiShortcutKeyItem* value, Ptr<ShortcutBuilder> builder);
				void										BuildShortcut(const WString& builderText);
				void										UpdateShortcutOwner();
			public:
				/// <summary>Create the command.</summary>
				GuiToolstripCommand();
				~GuiToolstripCommand();

				void										Attach(GuiInstanceRootObject* rootObject)override;
				void										Detach(GuiInstanceRootObject* rootObject)override;

				/// <summary>Executed event.</summary>
				compositions::GuiNotifyEvent				Executed;

				/// <summary>Description changed event, raised when any description property is modified.</summary>
				compositions::GuiNotifyEvent				DescriptionChanged;

				/// <summary>Get the large image for this command.</summary>
				/// <returns>The large image for this command.</returns>
				Ptr<GuiImageData>							GetLargeImage();
				/// <summary>Set the large image for this command.</summary>
				/// <param name="value">The large image for this command.</param>
				void										SetLargeImage(Ptr<GuiImageData> value);
				/// <summary>Get the image for this command.</summary>
				/// <returns>The image for this command.</returns>
				Ptr<GuiImageData>							GetImage();
				/// <summary>Set the image for this command.</summary>
				/// <param name="value">The image for this command.</param>
				void										SetImage(Ptr<GuiImageData> value);
				/// <summary>Get the text for this command.</summary>
				/// <returns>The text for this command.</returns>
				const WString&								GetText();
				/// <summary>Set the text for this command.</summary>
				/// <param name="value">The text for this command.</param>
				void										SetText(const WString& value);
				/// <summary>Get the shortcut key item for this command.</summary>
				/// <returns>The shortcut key item for this command.</returns>
				compositions::IGuiShortcutKeyItem*			GetShortcut();
				/// <summary>Set the shortcut key item for this command.</summary>
				/// <param name="value">The shortcut key item for this command.</param>
				void										SetShortcut(compositions::IGuiShortcutKeyItem* value);
				/// <summary>Get the shortcut builder for this command.</summary>
				/// <returns>The shortcut builder for this command.</returns>
				WString										GetShortcutBuilder();
				/// <summary>Set the shortcut builder for this command. When the command is attached to a window as a component without a shortcut, the command will try to convert the shortcut builder to a shortcut key item.</summary>
				/// <param name="value">The shortcut builder for this command.</param>
				void										SetShortcutBuilder(const WString& value);
				/// <summary>Get the enablility for this command.</summary>
				/// <returns>The enablility for this command.</returns>
				bool										GetEnabled();
				/// <summary>Set the enablility for this command.</summary>
				/// <param name="value">The enablility for this command.</param>
				void										SetEnabled(bool value);
				/// <summary>Get the selection for this command.</summary>
				/// <returns>The selection for this command.</returns>
				bool										GetSelected();
				/// <summary>Set the selection for this command.</summary>
				/// <param name="value">The selection for this command.</param>
				void										SetSelected(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPMENU.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Toolstrip Item Collection
***********************************************************************/

			/// <summary>IToolstripUpdateLayout is a required service for all menu item container.</summary>
			class IToolstripUpdateLayout : public IDescriptable
			{
			public:
				virtual void								UpdateLayout() = 0;
			};

			/// <summary>IToolstripUpdateLayout is a required service for a menu item which want to force the container to redo layout.</summary>
			class IToolstripUpdateLayoutInvoker : public IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const					Identifier;

				virtual void								SetCallback(IToolstripUpdateLayout* callback) = 0;
			};

			/// <summary>Toolstrip item collection.</summary>
			class GuiToolstripCollectionBase : public collections::ObservableListBase<GuiControl*>
			{
			public:

			protected:
				IToolstripUpdateLayout *					contentCallback;

				void										InvokeUpdateLayout();
				bool										QueryInsert(vint index, GuiControl* const& child)override;
				void										BeforeRemove(vint index, GuiControl* const& child)override;
				void										AfterInsert(vint index, GuiControl* const& child)override;
				void										AfterRemove(vint index, vint count)override;
			public:
				GuiToolstripCollectionBase(IToolstripUpdateLayout* _contentCallback);
				~GuiToolstripCollectionBase();
			};

			/// <summary>Toolstrip item collection.</summary>
			class GuiToolstripCollection : public GuiToolstripCollectionBase
			{
				using EventHandlerList = collections::List<Ptr<compositions::IGuiGraphicsEventHandler>>;
			protected:
				compositions::GuiStackComposition*			stackComposition;
				EventHandlerList							eventHandlers;

				void										UpdateItemVisibility(vint index, GuiControl* child);
				void										OnItemVisibleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										BeforeRemove(vint index, GuiControl* const& child)override;
				void										AfterInsert(vint index, GuiControl* const& child)override;
				void										AfterRemove(vint index, vint count)override;
			public:
				GuiToolstripCollection(IToolstripUpdateLayout* _contentCallback, compositions::GuiStackComposition* _stackComposition);
				~GuiToolstripCollection();
			};

/***********************************************************************
Toolstrip Container
***********************************************************************/

			/// <summary>Toolstrip menu.</summary>
			class GuiToolstripMenu : public GuiMenu, protected IToolstripUpdateLayout,  Description<GuiToolstripMenu>
			{
			protected:
				compositions::GuiSharedSizeRootComposition*		sharedSizeRootComposition;
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

				void											UpdateLayout()override;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_owner">The owner menu item of the parent menu.</param>
				GuiToolstripMenu(theme::ThemeName themeName, GuiControl* _owner);
				~GuiToolstripMenu();
				
				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

			/// <summary>Toolstrip menu bar.</summary>
			class GuiToolstripMenuBar : public GuiMenuBar, public Description<GuiToolstripMenuBar>
			{
			protected:
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiToolstripMenuBar(theme::ThemeName themeName);
				~GuiToolstripMenuBar();
				
				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

			/// <summary>Toolstrip tool bar.</summary>
			class GuiToolstripToolBar : public GuiControl, public Description<GuiToolstripToolBar>
			{
			protected:
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiToolstripToolBar(theme::ThemeName themeName);
				~GuiToolstripToolBar();
				
				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

/***********************************************************************
Toolstrip Component
***********************************************************************/

			/// <summary>Toolstrip button that can connect with a <see cref="GuiToolstripCommand"/>.</summary>
			class GuiToolstripButton : public GuiMenuButton, protected IToolstripUpdateLayoutInvoker, public Description<GuiToolstripButton>
			{
			protected:
				GuiToolstripCommand*							command;
				IToolstripUpdateLayout*							callback = nullptr;
				Ptr<compositions::IGuiGraphicsEventHandler>		descriptionChangedHandler;

				void											SetCallback(IToolstripUpdateLayout* _callback)override;
				void											OnActiveAlt()override;
				void											UpdateCommandContent();
				void											OnLayoutAwaredPropertyChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnCommandDescriptionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiToolstripButton(theme::ThemeName themeName);
				~GuiToolstripButton();

				/// <summary>Get the attached <see cref="GuiToolstripCommand"/>.</summary>
				/// <returns>The attached toolstrip command.</returns>
				GuiToolstripCommand*							GetCommand();
				/// <summary>Detach from the previous <see cref="GuiToolstripCommand"/> and attach to a new one. If the command is null, this function only do detaching.</summary>
				/// <param name="value">The new toolstrip command.</param>
				void											SetCommand(GuiToolstripCommand* value);

				/// <summary>Get the toolstrip sub menu. If the sub menu is not created, it returns null.</summary>
				/// <returns>The toolstrip sub menu.</returns>
				GuiToolstripMenu*								GetToolstripSubMenu();

				/// <summary>Get the toolstrip sub menu. If the sub menu is not created, it returns null.</summary>
				/// <returns>The toolstrip sub menu.</returns>
				GuiToolstripMenu*								EnsureToolstripSubMenu();
				/// <summary>Create the toolstrip sub menu if necessary. The created toolstrip sub menu is owned by this menu button.</summary>
				/// <param name="subMenuTemplate">The style controller for the toolstrip sub menu. Set to null to use the default control template.</param>
				void											CreateToolstripSubMenu(TemplateProperty<templates::GuiMenuTemplate> subMenuTemplate);

				IDescriptable*									QueryService(const WString& identifier)override;
			};

/***********************************************************************
Toolstrip Group
***********************************************************************/

			class GuiToolstripNestedContainer : public GuiControl, protected IToolstripUpdateLayout, protected IToolstripUpdateLayoutInvoker
			{
			protected:
				IToolstripUpdateLayout*							callback = nullptr;

				void											UpdateLayout()override;
				void											SetCallback(IToolstripUpdateLayout* _callback)override;
			public:
				GuiToolstripNestedContainer(theme::ThemeName themeName);
				~GuiToolstripNestedContainer();

				IDescriptable*									QueryService(const WString& identifier)override;
			};

			/// <summary>A toolstrip item, which is also a toolstrip item container, automatically maintaining splitters between items.</summary>
			class GuiToolstripGroupContainer : public GuiToolstripNestedContainer, public Description<GuiToolstripGroupContainer>
			{
			protected:
				class GroupCollection : public GuiToolstripCollectionBase
				{
				protected:
					GuiToolstripGroupContainer*					container;
					ControlTemplatePropertyType					splitterTemplate;

					void										BeforeRemove(vint index, GuiControl* const& child)override;
					void										AfterInsert(vint index, GuiControl* const& child)override;
					void										AfterRemove(vint index, vint count)override;
				public:
					GroupCollection(GuiToolstripGroupContainer* _container);
					~GroupCollection();

					ControlTemplatePropertyType					GetSplitterTemplate();
					void										SetSplitterTemplate(const ControlTemplatePropertyType& value);
					void										RebuildSplitters();
				};

			protected:
				compositions::GuiStackComposition*				stackComposition;
				theme::ThemeName								splitterThemeName;
				Ptr<GroupCollection>							groupCollection;

				void											OnParentLineChanged()override;
			public:
				GuiToolstripGroupContainer(theme::ThemeName themeName);
				~GuiToolstripGroupContainer();

				ControlTemplatePropertyType						GetSplitterTemplate();
				void											SetSplitterTemplate(const ControlTemplatePropertyType& value);

				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

			/// <summary>A toolstrip item, which is also a toolstrip item container.</summary>
			class GuiToolstripGroup : public GuiToolstripNestedContainer, public Description<GuiToolstripGroup>
			{
			protected:
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

				void											OnParentLineChanged()override;
			public:
				GuiToolstripGroup(theme::ThemeName themeName);
				~GuiToolstripGroup();

				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::GuiToolstripCollection>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIRIBBONCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIRIBBONCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIRIBBONCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Ribbon Containers
***********************************************************************/

			class GuiRibbonTabPage;
			class GuiRibbonGroup;

			/// <summary>Ribbon tab control, for displaying ribbon tab pages.</summary>
			class GuiRibbonTab : public GuiTab, public Description<GuiRibbonTab>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonTabTemplate, GuiTab)
			protected:
				compositions::GuiBoundsComposition*					beforeHeaders = nullptr;
				compositions::GuiBoundsComposition*					afterHeaders = nullptr;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonTab(theme::ThemeName themeName);
				~GuiRibbonTab();

				/// <summary>Get the composition representing the space before tabs.</summary>
				/// <returns>The composition representing the space before tabs.</returns>
				compositions::GuiGraphicsComposition*				GetBeforeHeaders();
				/// <summary>Get the composition representing the space after tabs.</summary>
				/// <returns>The composition representing the space after tabs.</returns>
				compositions::GuiGraphicsComposition*				GetAfterHeaders();
			};

			class GuiRibbonGroupCollection : public collections::ObservableListBase<GuiRibbonGroup*>
			{
			protected:
				GuiRibbonTabPage*									tabPage = nullptr;

				bool												QueryInsert(vint index, GuiRibbonGroup* const& value)override;
				void												AfterInsert(vint index, GuiRibbonGroup* const& value)override;
				void												AfterRemove(vint index, vint count)override;

			public:
				GuiRibbonGroupCollection(GuiRibbonTabPage* _tabPage);
				~GuiRibbonGroupCollection();
			};

			/// <summary>Ribbon tab page control, adding to the Pages property of a <see cref="GuiRibbonTab"/>.</summary>
			class GuiRibbonTabPage : public GuiTabPage, public Description<GuiRibbonTabPage>
			{
				friend class GuiRibbonGroupCollection;
			protected:
				bool												highlighted = false;
				GuiRibbonGroupCollection							groups;
				compositions::GuiResponsiveStackComposition*		responsiveStack = nullptr;
				compositions::GuiResponsiveContainerComposition*	responsiveContainer = nullptr;
				compositions::GuiStackComposition*					stack = nullptr;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonTabPage(theme::ThemeName themeName);
				~GuiRibbonTabPage();
				
				/// <summary>Highlighted changed event.</summary>
				compositions::GuiNotifyEvent						HighlightedChanged;

				/// <summary>Test if this is a highlighted tab page.</summary>
				/// <returns>Returns true if this is a highlighted tab page.</returns>
				bool												GetHighlighted();
				/// <summary>Set if this is a highlighted tab page.</summary>
				/// <param name="value">Set to true to highlight the tab page.</param>
				void												SetHighlighted(bool value);

				/// <summary>Get the collection of ribbon groups.</summary>
				/// <returns>The collection of ribbon groups.</returns>
				collections::ObservableListBase<GuiRibbonGroup*>&	GetGroups();
			};

			class GuiRibbonGroupItemCollection : public collections::ObservableListBase<GuiControl*>
			{
			protected:
				GuiRibbonGroup*										group = nullptr;

				bool												QueryInsert(vint index, GuiControl* const& value)override;
				void												AfterInsert(vint index, GuiControl* const& value)override;
				void												AfterRemove(vint index, vint count)override;

			public:
				GuiRibbonGroupItemCollection(GuiRibbonGroup* _group);
				~GuiRibbonGroupItemCollection();
			};

			/// <summary>Ribbon group control, adding to the Groups property of a <see cref="GuiRibbonTabPage"/>.</summary>
			class GuiRibbonGroup : public GuiControl, public Description<GuiRibbonGroup>
			{
				friend class GuiRibbonGroupItemCollection;
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonGroupTemplate, GuiControl)
			protected:

				class CommandExecutor : public Object, public IRibbonGroupCommandExecutor
				{
				protected:
					GuiRibbonGroup*									group;

				public:
					CommandExecutor(GuiRibbonGroup* _group);
					~CommandExecutor();

					void											NotifyExpandButtonClicked()override;
				};

				bool												expandable = false;
				Ptr<GuiImageData>									largeImage;
				GuiRibbonGroupItemCollection						items;
				compositions::GuiResponsiveStackComposition*		responsiveStack = nullptr;
				compositions::GuiStackComposition*					stack = nullptr;
				Ptr<CommandExecutor>								commandExecutor;

				compositions::GuiResponsiveViewComposition*			responsiveView = nullptr;
				compositions::GuiResponsiveFixedComposition*		responsiveFixedButton = nullptr;
				GuiToolstripButton*									dropdownButton = nullptr;
				GuiMenu*											dropdownMenu = nullptr;

				void												OnBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnBeforeSwitchingView(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void												OnBeforeSubMenuOpening(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonGroup(theme::ThemeName themeName);
				~GuiRibbonGroup();

				/// <summary>Expandable changed event.</summary>
				compositions::GuiNotifyEvent						ExpandableChanged;
				/// <summary>Expand button clicked event.</summary>
				compositions::GuiNotifyEvent						ExpandButtonClicked;
				/// <summary>Large image changed event.</summary>
				compositions::GuiNotifyEvent						LargeImageChanged;

				/// <summary>Test if this group is expandable. An expandable group will display an extra small button, which raises <see cref="ExpandButtonClicked"/>.</summary>
				/// <returns>Returns true if this group is expandable.</returns>
				bool												GetExpandable();
				/// <summary>Set if this group is expandable.</summary>
				/// <param name="value">Set to true to make this group is expandable.</param>
				void												SetExpandable(bool value);

				/// <summary>Get the large image for the collapsed ribbon group.</summary>
				/// <returns>The large image for the collapsed ribbon group.</returns>
				Ptr<GuiImageData>									GetLargeImage();
				/// <summary>Set the large image for the collapsed ribbon group.</summary>
				/// <param name="value">The large image for the collapsed ribbon group.</param>
				void												SetLargeImage(Ptr<GuiImageData> value);

				/// <summary>Get the collection of controls in this group.</summary>
				/// <returns>The collection of controls.</returns>
				collections::ObservableListBase<GuiControl*>&		GetItems();
			};

/***********************************************************************
Ribbon Buttons
***********************************************************************/

			/// <summary>Auto resizable ribbon icon label.</summary>
			class GuiRibbonIconLabel : public GuiControl, public Description<GuiRibbonIconLabel>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonIconLabelTemplate, GuiControl)
			protected:
				Ptr<GuiImageData>						image;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonIconLabel(theme::ThemeName themeName);
				~GuiRibbonIconLabel();

				/// <summary>Image changed event.</summary>
				compositions::GuiNotifyEvent			ImageChanged;

				/// <summary>Get the image for the menu button.</summary>
				/// <returns>The image for the menu button.</returns>
				Ptr<GuiImageData>						GetImage();
				/// <summary>Set the image for the menu button.</summary>
				/// <param name="value">The image for the menu button.</param>
				void									SetImage(Ptr<GuiImageData> value);
			};

			/// <summary>Represents the size of a ribbon button in a <see cref="GuiRibbonButtons"/> control.</summary>
			enum class RibbonButtonSize
			{
				/// <summary>Large icon with text.</summary>
				Large = 0,
				/// <summary>Small icon with text.</summary>
				Small = 1,
				/// <summary>Small icon only.</summary>
				Icon = 2,
			};

			class GuiRibbonButtons;

			class GuiRibbonButtonsItemCollection : public collections::ObservableListBase<GuiControl*>
			{
			protected:
				GuiRibbonButtons*										buttons = nullptr;

				bool													QueryInsert(vint index, GuiControl* const& value)override;
				void													AfterInsert(vint index, GuiControl* const& value)override;
				void													BeforeRemove(vint index, GuiControl* const& value)override;

			public:
				GuiRibbonButtonsItemCollection(GuiRibbonButtons* _buttons);
				~GuiRibbonButtonsItemCollection();
			};

			/// <summary>Auto resizable ribbon buttons.</summary>
			class GuiRibbonButtons : public GuiControl, public Description<GuiRibbonButtons>
			{
				friend class GuiRibbonButtonsItemCollection;
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonButtonsTemplate, GuiControl)
			protected:
				RibbonButtonSize										minSize;
				RibbonButtonSize										maxSize;
				compositions::GuiResponsiveViewComposition*				responsiveView = nullptr;
				compositions::GuiResponsiveFixedComposition*			views[3] = { nullptr,nullptr,nullptr };
				GuiRibbonButtonsItemCollection							buttons;
																		
				void													OnBeforeSwitchingView(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													SetButtonThemeName(compositions::GuiResponsiveCompositionBase* fixed, GuiControl* button);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_maxSize">Max allowed size.</param>
				/// <param name="_minSize">Min allowed size.</param>
				GuiRibbonButtons(theme::ThemeName themeName, RibbonButtonSize _maxSize, RibbonButtonSize _minSize);
				~GuiRibbonButtons();

				/// <summary>Get the collection of buttons. <see cref="GuiToolstripButton"/> is expected.</summary>
				/// <returns>The collection of buttons.</returns>
				collections::ObservableListBase<GuiControl*>&			GetButtons();
			};

/***********************************************************************
Ribbon Toolstrips
***********************************************************************/

			class GuiRibbonToolstrips;

			class GuiRibbonToolstripsGroupCollection : public collections::ObservableListBase<GuiToolstripGroup*>
			{
			protected:
				GuiRibbonToolstrips*									toolstrips = nullptr;

				bool													QueryInsert(vint index, GuiToolstripGroup* const& value)override;
				void													AfterInsert(vint index, GuiToolstripGroup* const& value)override;
				void													AfterRemove(vint index, vint count)override;

			public:
				GuiRibbonToolstripsGroupCollection(GuiRibbonToolstrips* _toolstrips);
				~GuiRibbonToolstripsGroupCollection();
			};

			/// <summary>Auto resizable ribbon toolstrips.</summary>
			class GuiRibbonToolstrips : public GuiControl, public Description<GuiRibbonToolstrips>
			{
				friend class GuiRibbonToolstripsGroupCollection;
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonToolstripsTemplate, GuiControl)
			protected:
				compositions::GuiResponsiveViewComposition*				responsiveView = nullptr;
				GuiToolstripToolBar*									toolbars[5] = { nullptr,nullptr,nullptr,nullptr,nullptr };
				GuiToolstripGroupContainer*								longContainers[2] = { nullptr,nullptr };
				GuiToolstripGroupContainer*								shortContainers[3] = { nullptr,nullptr,nullptr };
				compositions::GuiResponsiveFixedComposition*			views[2] = { nullptr,nullptr };
				GuiRibbonToolstripsGroupCollection						groups;

				void													OnBeforeSwitchingView(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													RearrangeToolstripGroups(vint viewIndex = -1);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonToolstrips(theme::ThemeName themeName);
				~GuiRibbonToolstrips();

				/// <summary>Get the collection of toolstrip groups. <see cref="GuiRibbonToolstrips"/> will decide the order of these toolstrip groups.</summary>
				/// <returns>The collection of toolstrip groups.</returns>
				collections::ObservableListBase<GuiToolstripGroup*>&	GetGroups();
			};

/***********************************************************************
Ribbon Gallery
***********************************************************************/

			/// <summary>Ribbon gallery, with scroll up, scroll down, dropdown buttons.</summary>
			class GuiRibbonGallery : public GuiControl, public Description<GuiRibbonGallery>
			{
				using ItemStyle = templates::GuiListItemTemplate;
				using ItemStyleProperty = TemplateProperty<templates::GuiListItemTemplate>;

				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonGalleryTemplate, GuiControl)
			protected:
				class CommandExecutor : public Object, public IRibbonGalleryCommandExecutor
				{
				protected:
					GuiRibbonGallery*									gallery;

				public:
					CommandExecutor(GuiRibbonGallery* _gallery);
					~CommandExecutor();

					void												NotifyScrollUp()override;
					void												NotifyScrollDown()override;
					void												NotifyDropdown()override;
				};

				bool													scrollUpEnabled = true;
				bool													scrollDownEnabled = true;
				Ptr<CommandExecutor>									commandExecutor;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonGallery(theme::ThemeName themeName);
				~GuiRibbonGallery();

				/// <summary>Scroll up enabled changed event.</summary>
				compositions::GuiNotifyEvent							ScrollUpEnabledChanged;
				/// <summary>Scroll down enabled changed event.</summary>
				compositions::GuiNotifyEvent							ScrollDownEnabledChanged;
				/// <summary>Scroll up button clicked event.</summary>
				compositions::GuiNotifyEvent							RequestedScrollUp;
				/// <summary>Scroll down button clicked event.</summary>
				compositions::GuiNotifyEvent							RequestedScrollDown;
				/// <summary>Dropdown button clicked event.</summary>
				compositions::GuiNotifyEvent							RequestedDropdown;

				/// <summary>Test if the scroll up button is enabled.</summary>
				/// <returns>Returns true if the scroll up button is enabled.</returns>
				bool													GetScrollUpEnabled();
				/// <summary>Set if the scroll up button is enabled.</summary>
				/// <param name="value">Set to true to enable the scroll up button.</param>
				void													SetScrollUpEnabled(bool value);

				/// <summary>Test if the scroll down button is enabled.</summary>
				/// <returns>Returns true if the scroll down button is enabled.</returns>
				bool													GetScrollDownEnabled();
				/// <summary>Set if the scroll down button is enabled.</summary>
				/// <param name="value">Set to true to enable the scroll down button.</param>
				void													SetScrollDownEnabled(bool value);
			};

			/// <summary>Resizable ribbon toolstrip menu with a space above of all menu items to display extra content.</summary>
			class GuiRibbonToolstripMenu : public GuiToolstripMenu, public Description<GuiRibbonToolstripMenu>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonToolstripMenuTemplate, GuiToolstripMenu)
			protected:
				compositions::GuiBoundsComposition*						contentComposition;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="owner">The owner menu item of the parent menu.</param>
				GuiRibbonToolstripMenu(theme::ThemeName themeName, GuiControl* owner);
				~GuiRibbonToolstripMenu();

				/// <summary>Get the composition representing the space above of menu items.</summary>
				/// <returns>The composition representing the space above of menu items.</returns>
				compositions::GuiGraphicsComposition*					GetContentComposition();
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIRIBBONGALLERYLIST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIRIBBONGALLERYLIST
#define VCZH_PRESENTATION_CONTROLS_GUIRIBBONGALLERYLIST


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Ribbon Gallery List
***********************************************************************/

			/// <summary>Represents the position of an item in the gallery list.</summary>
			struct GalleryPos
			{
				/// <summary>Group index.</summary>
				vint			group;
				/// <summary>Item index.</summary>
				vint			item;

				GalleryPos()
					:group(-1), item(-1)
				{
				}

				GalleryPos(vint _group, vint _item)
					:group(_group), item(_item)
				{
				}

				vint Compare(GalleryPos value)const
				{
					vint result = group - value.group;
					if (result != 0) return result;
					return item - value.item;
				}

				bool operator==(const GalleryPos& value)const { return Compare(value) == 0; }
				bool operator!=(const GalleryPos& value)const { return Compare(value) != 0; }
				bool operator<(const GalleryPos& value)const { return Compare(value)<0; }
				bool operator<=(const GalleryPos& value)const { return Compare(value) <= 0; }
				bool operator>(const GalleryPos& value)const { return Compare(value)>0; }
				bool operator>=(const GalleryPos& value)const { return Compare(value) >= 0; }
			};

			namespace list
			{
				class GroupedDataSource;

				/// <summary>A gallery group.</summary>
				class GalleryGroup : public Description<GalleryGroup>
				{
					friend class GroupedDataSource;
					using IValueList = reflection::description::IValueList;
				protected:
					Ptr<EventHandler>									eventHandler;
					WString												name;
					Ptr<IValueList>										itemValues;

				public:
					GalleryGroup();
					~GalleryGroup();

					/// <summary>Get the title of this group.</summary>
					/// <returns>The title of this group.</returns>
					WString												GetName();
					/// <summary>Get the all items of this group, could be null.</summary>
					/// <returns>All items of this group.</returns>
					Ptr<IValueList>										GetItemValues();
				};

				class GroupedDataSource : public Description<GroupedDataSource>
				{
					using IValueEnumerable = reflection::description::IValueEnumerable;
					using IValueList = reflection::description::IValueList;
					using IValueObservableList = reflection::description::IValueObservableList;
					using GalleryItemList = collections::ObservableList<reflection::description::Value>;
					using GalleryGroupList = collections::ObservableList<Ptr<GalleryGroup>>;

				protected:
					compositions::GuiGraphicsComposition*				associatedComposition;
					Ptr<IValueEnumerable>								itemSource;
					ItemProperty<WString>								titleProperty;
					ItemProperty<Ptr<IValueEnumerable>>					childrenProperty;

					GalleryItemList										joinedItemSource;
					GalleryGroupList									groupedItemSource;
					collections::List<vint>								cachedGroupItemCounts;
					Ptr<EventHandler>									groupChangedHandler;
					bool												ignoreGroupChanged = false;

					void												RebuildItemSource();
					Ptr<IValueList>										GetChildren(Ptr<IValueEnumerable> children);
					void												AttachGroupChanged(Ptr<GalleryGroup> group, vint index);
					void												OnGroupChanged(vint start, vint oldCount, vint newCount);
					void												OnGroupItemChanged(vint index, vint start, vint oldCount, vint newCount);
					vint												GetCountBeforeGroup(vint index);
					void												InsertGroupToJoined(vint index);
					void												RemoveGroupFromJoined(vint index);

				public:
					GroupedDataSource(compositions::GuiGraphicsComposition* _associatedComposition);
					~GroupedDataSource();

					/// <summary>Group enabled event.</summary>
					compositions::GuiNotifyEvent						GroupEnabledChanged;
					/// <summary>Group title property changed event.</summary>
					compositions::GuiNotifyEvent						GroupTitlePropertyChanged;
					/// <summary>Group children property changed event.</summary>
					compositions::GuiNotifyEvent						GroupChildrenPropertyChanged;

					/// <summary>Get the item source.</summary>
					/// <returns>The item source.</returns>
					Ptr<IValueEnumerable>								GetItemSource();
					/// <summary>Set the item source.</summary>
					/// <param name="value">The item source. Null is acceptable if you want to clear all data.</param>
					void												SetItemSource(Ptr<IValueEnumerable> value);

					/// <summary>Test if grouping is enabled. Enabled means there is really both GroupTitleProperty and GroupChildrenProperty is not empty.</summary>
					/// <returns>Returns true if grouping is enabled.</returns>
					bool												GetGroupEnabled();

					/// <summary>Get the group title property.</summary>
					/// <returns>The group title property.</returns>
					ItemProperty<WString>								GetGroupTitleProperty();
					/// <summary>Get the group title property.</summary>
					/// <param name="value">The group title property.</param>
					void												SetGroupTitleProperty(const ItemProperty<WString>& value);

					/// <summary>Get the group children property.</summary>
					/// <returns>The group children property.</returns>
					ItemProperty<Ptr<IValueEnumerable>>					GetGroupChildrenProperty();
					/// <summary>Get the group children property.</summary>
					/// <param name="value">The children title property.</param>
					void												SetGroupChildrenProperty(const ItemProperty<Ptr<IValueEnumerable>>& value);

					/// <summary>Get all groups.</summary>
					/// <returns>All groups.</returns>
					const GalleryGroupList&								GetGroups();
				};
			}

			namespace ribbon_impl
			{
				class GalleryItemArranger;
				class GalleryResponsiveLayout;
			}

			/// <summary>Auto resizable ribbon gallyer list.</summary>
			class GuiBindableRibbonGalleryList : public GuiRibbonGallery, public list::GroupedDataSource, private IGuiMenuDropdownProvider, public Description<GuiBindableRibbonGalleryList>
			{
				friend class ribbon_impl::GalleryItemArranger;

				using IValueEnumerable = reflection::description::IValueEnumerable;
				using IValueObservableList = reflection::description::IValueObservableList;
				using ItemStyleProperty = TemplateProperty<templates::GuiListItemTemplate>;

				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonGalleryListTemplate, GuiRibbonGallery)
			protected:
				ItemStyleProperty										itemStyle;
				GuiBindableTextList*									itemList;
				GuiRibbonToolstripMenu*									subMenu;
				vint													visibleItemCount = 1;
				bool													skipItemAppliedEvent = false;

				ribbon_impl::GalleryItemArranger*						itemListArranger;
				ribbon_impl::GalleryResponsiveLayout*					layout;
				GuiScrollContainer*										groupContainer;
				compositions::GuiRepeatStackComposition*				groupStack;

				void													UpdateLayoutSizeOffset();
				void													OnItemListSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnItemListItemMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													OnItemListItemMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													OnBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnRequestedDropdown(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnRequestedScrollUp(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnRequestedScrollDown(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void													MenuResetGroupTemplate();
				GuiControl*												MenuGetGroupHeader(vint groupIndex);
				compositions::GuiRepeatFlowComposition*					MenuGetGroupFlow(vint groupIndex);
				GuiSelectableButton*									MenuGetGroupItemBackground(vint groupIndex, vint itemIndex);

				void													StartPreview(vint index);
				void													StopPreview(vint index);

			private:
				GuiMenu*												ProvideDropdownMenu()override;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableRibbonGalleryList(theme::ThemeName themeName);
				~GuiBindableRibbonGalleryList();

				/// <summary>Item template changed event.</summary>
				compositions::GuiNotifyEvent							ItemTemplateChanged;
				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent							SelectionChanged;
				/// <summary>Preview started event.</summary>
				compositions::GuiItemNotifyEvent						PreviewStarted;
				/// <summary>Preview stopped event.</summary>
				compositions::GuiItemNotifyEvent						PreviewStopped;
				/// <summary>Item applied event.</summary>
				compositions::GuiItemNotifyEvent						ItemApplied;

				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				ItemStyleProperty										GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				void													SetItemTemplate(ItemStyleProperty value);

				/// <summary>Convert an item index to a gallery item position.</summary>
				/// <returns>The gallery item position.</returns>
				/// <param name="index">The item index.</param>
				GalleryPos												IndexToGalleryPos(vint index);
				/// <summary>Convert a gallery item position to an item index.</summary>
				/// <returns>The item index.</returns>
				/// <param name="pos">The gallery item position.</param>
				vint													GalleryPosToIndex(GalleryPos pos);

				/// <summary>Get the minimum number of items should be displayed.</summary>
				/// <returns>The minimum number of items should be displayed.</returns>
				vint													GetMinCount();
				/// <summary>Set the minimum number of items should be displayed.</summary>
				/// <param name="value">The minimum number of items should be displayed.</param>
				void													SetMinCount(vint value);

				/// <summary>Get the maximum number of items should be displayed.</summary>
				/// <returns>The maximum number of items should be displayed.</returns>
				vint													GetMaxCount();
				/// <summary>Set the maximum number of items should be displayed.</summary>
				/// <param name="value">The maximum number of items should be displayed.</param>
				void													SetMaxCount(vint value);

				/// <summary>Get the selected item index.</summary>
				/// <returns>The index of the selected item. If there are multiple selected items, or there is no selected item, -1 will be returned.</returns>
				vint													GetSelectedIndex();
				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value										GetSelectedItem();
				/// <summary>Select an item with <see cref="ItemApplied"/> event raised.</summary>
				/// <param name="index">The index of the item to select. Set to -1 to clear the selection.</param>
				void													ApplyItem(vint index);
				/// <summary>Select an item without <see cref="ItemApplied"/> event raised.</summary>
				/// <param name="index">The index of the item to select. Set to -1 to clear the selection.</param>
				void													SelectItem(vint index);

				/// <summary>Get the minimum items visible in the drop down menu.</summary>
				/// <returns>The minimum items visible in the drop down menu.</returns>
				vint													GetVisibleItemCount();
				/// <summary>Set minimum items visible in the drop down menu.</summary>
				/// <param name="value">The minimum items visible in the drop down menu.</param>
				void													SetVisibleItemCount(vint value);

				/// <summary>Get the dropdown menu.</summary>
				/// <returns>The dropdown menu.</returns>
				GuiToolstripMenu*										GetSubMenu();

				IDescriptable*											QueryService(const WString& identifier)override;
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\INCLUDEALL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_INCLUDEALL
#define VCZH_PRESENTATION_CONTROLS_INCLUDEALL





#endif

/***********************************************************************
.\GACUIREFLECTIONHELPER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection Helper

***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUIREFLECTIONHELPER
#define VCZH_PRESENTATION_GACUIREFLECTIONHELPER


namespace vl
{
	namespace reflection
	{
		namespace description
		{

/***********************************************************************
Serialization
***********************************************************************/

			template<>
			struct TypedValueSerializerProvider<presentation::Color>
			{
				static presentation::Color GetDefaultValue();
				static bool Serialize(const presentation::Color& input, WString& output);
				static bool Deserialize(const WString& input, presentation::Color& output);
				static IBoxedValue::CompareResult Compare(const presentation::Color& a, const presentation::Color& b);
			};

			template<>
			struct TypedValueSerializerProvider<presentation::DocumentFontSize>
			{
				static presentation::DocumentFontSize GetDefaultValue();
				static bool Serialize(const presentation::DocumentFontSize& input, WString& output);
				static bool Deserialize(const WString& input, presentation::DocumentFontSize& output);
				static IBoxedValue::CompareResult Compare(const presentation::DocumentFontSize& a, const presentation::DocumentFontSize& b);
			};

			template<>
			struct TypedValueSerializerProvider<presentation::GlobalStringKey>
			{
				static presentation::GlobalStringKey GetDefaultValue();
				static bool Serialize(const presentation::GlobalStringKey& input, WString& output);
				static bool Deserialize(const WString& input, presentation::GlobalStringKey& output);
				static IBoxedValue::CompareResult Compare(const presentation::GlobalStringKey& a, const presentation::GlobalStringKey& b);
			};

/***********************************************************************
External Functions
***********************************************************************/

			extern Ptr<presentation::INativeImage>							INativeImage_Constructor(const WString& path);
			extern presentation::INativeCursor*								INativeCursor_Constructor1();
			extern presentation::INativeCursor*								INativeCursor_Constructor2(presentation::INativeCursor::SystemCursorType type);

			template<typename T>
			Ptr<T> Element_Constructor()
			{
				return T::Create();
			}
			extern presentation::elements::text::TextLines*					GuiColorizedTextElement_GetLines(presentation::elements::GuiColorizedTextElement* thisObject);

			extern void														GuiTableComposition_SetRows(presentation::compositions::GuiTableComposition* thisObject, vint value);
			extern void														GuiTableComposition_SetColumns(presentation::compositions::GuiTableComposition* thisObject, vint value);
			extern void														IGuiAltActionHost_CollectAltActions(presentation::compositions::IGuiAltActionHost* host, collections::List<presentation::compositions::IGuiAltAction*>& actions);
		}
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIPARSERMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIPARSERMANAGER
#define VCZH_PRESENTATION_RESOURCES_GUIPARSERMANAGER


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Parser
***********************************************************************/

		/// <summary>Represents a parser.</summary>
		class IGuiGeneralParser : public IDescriptable, public Description<IGuiGeneralParser>
		{
		public:
		};

		template<typename T>
		class IGuiParser : public IGuiGeneralParser
		{
			using ErrorList = collections::List<Ptr<parsing::ParsingError>>;
		public:
			virtual Ptr<T>							ParseInternal(const WString& text, ErrorList& errors) = 0;

			Ptr<T> Parse(GuiResourceLocation location, const WString& text, collections::List<GuiResourceError>& errors)
			{
				ErrorList parsingErrors;
				auto result = ParseInternal(text, parsingErrors);
				GuiResourceError::Transform(location, errors, parsingErrors);
				return result;
			}

			Ptr<T> Parse(GuiResourceLocation location, const WString& text, parsing::ParsingTextPos position, collections::List<GuiResourceError>& errors)
			{
				ErrorList parsingErrors;
				auto result = ParseInternal(text, parsingErrors);
				GuiResourceError::Transform(location, errors, parsingErrors, position);
				return result;
			}

			Ptr<T> Parse(GuiResourceLocation location, const WString& text, GuiResourceTextPos position, collections::List<GuiResourceError>& errors)
			{
				ErrorList parsingErrors;
				auto result = ParseInternal(text, parsingErrors);
				GuiResourceError::Transform(location, errors, parsingErrors, position);
				return result;
			}
		};

/***********************************************************************
Parser Manager
***********************************************************************/

		/// <summary>Parser manager for caching parsing table globally.</summary>
		class IGuiParserManager : public IDescriptable, public Description<IGuiParserManager>
		{
		protected:
			typedef parsing::tabling::ParsingTable			Table;

		public:
			/// <summary>Get a parsing table by name.</summary>
			/// <returns>The parsing table.</returns>
			/// <param name="name">The name.</param>
			virtual Ptr<Table>						GetParsingTable(const WString& name)=0;
			/// <summary>Set a parsing table loader by name.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="name">The name.</param>
			/// <param name="loader">The parsing table loader.</param>
			virtual bool							SetParsingTable(const WString& name, Func<Ptr<Table>()> loader)=0;
			/// <summary>Get a parser.</summary>
			/// <returns>The parser.</returns>
			/// <param name="name">The name.</param>
			virtual Ptr<IGuiGeneralParser>			GetParser(const WString& name)=0;
			/// <summary>Set a parser by name.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="name">The name.</param>
			/// <param name="parser">The parser.</param>
			virtual bool							SetParser(const WString& name, Ptr<IGuiGeneralParser> parser)=0;

			template<typename T>
			Ptr<IGuiParser<T>>						GetParser(const WString& name);

			template<typename T>
			bool									SetTableParser(const WString& tableName, const WString& parserName, Ptr<T>(*function)(const WString&, Ptr<Table>, collections::List<Ptr<parsing::ParsingError>>&, vint));
		};

		/// <summary>Get the global <see cref="IGuiParserManager"/> object.</summary>
		/// <returns>The parser manager.</returns>
		extern IGuiParserManager*					GetParserManager();

/***********************************************************************
Strong Typed Table Parser
***********************************************************************/

		template<typename T>
		class GuiStrongTypedTableParser : public Object, public IGuiParser<T>
		{
		protected:
			typedef parsing::tabling::ParsingTable				Table;
			typedef Ptr<T>(ParserFunction)(const WString&, Ptr<Table>, collections::List<Ptr<parsing::ParsingError>>&, vint);
		protected:
			WString									name;
			Ptr<Table>								table;
			Func<ParserFunction>					function;

		public:
			GuiStrongTypedTableParser(const WString& _name, ParserFunction* _function)
				:name(_name)
				,function(_function)
			{
			}

			Ptr<T> ParseInternal(const WString& text, collections::List<Ptr<parsing::ParsingError>>& errors)override
			{
				if (!table)
				{
					table = GetParserManager()->GetParsingTable(name);
				}
				if (table)
				{
					collections::List<Ptr<parsing::ParsingError>> parsingErrors;
					auto result = function(text, table, parsingErrors, -1);
					if (parsingErrors.Count() > 0)
					{
						errors.Add(parsingErrors[0]);
					}
					return result;
				}
				return nullptr;
			}
		};

/***********************************************************************
Parser Manager
***********************************************************************/

		template<typename T>
		Ptr<IGuiParser<T>> IGuiParserManager::GetParser(const WString& name)
		{
			return GetParser(name).Cast<IGuiParser<T>>();
		}

		template<typename T>
		bool IGuiParserManager::SetTableParser(const WString& tableName, const WString& parserName, Ptr<T>(*function)(const WString&, Ptr<Table>, collections::List<Ptr<parsing::ParsingError>>&, vint))
		{
			Ptr<IGuiParser<T>> parser=new GuiStrongTypedTableParser<T>(tableName, function);
			return SetParser(parserName, parser);
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGEOPERATIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGEOPERATIONS
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGEOPERATIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ParsingInput
***********************************************************************/

			class RepeatingParsingExecutor;

			/// <summary>A data structure storing the parsing input for text box control.</summary>
			struct RepeatingParsingInput
			{
				/// <summary>The text box edit version of the code.</summary>
				vuint													editVersion = 0;
				/// <summary>The code.</summary>
				WString													code;
			};

/***********************************************************************
ParsingOutput
***********************************************************************/

			/// <summary>A data structure storing the parsing result for text box control.</summary>
			struct RepeatingParsingOutput
			{
				/// <summary>The parsed syntax tree.</summary>
				Ptr<parsing::ParsingTreeObject>							node;
				/// <summary>The text box edit version of the code.</summary>
				vuint													editVersion = 0;
				/// <summary>The code.</summary>
				WString													code;
				/// <summary>The cache created from [T:vl.presentation.controls.RepeatingParsingExecutor.IParsingAnalyzer].</summary>
				Ptr<DescriptableObject>									cache;
			};

/***********************************************************************
PartialParsingOutput
***********************************************************************/
			
			/// <summary>A data structure storing the parsing result for partial updating when a text box control is modified.</summary>
			struct RepeatingPartialParsingOutput
			{
				/// <summary>The input data.</summary>
				RepeatingParsingOutput									input;
				/// <summary>The rule name that can parse the code of the selected context.</summary>
				WString													rule;
				/// <summary>Range of the original context in the input.</summary>
				parsing::ParsingTextRange								originalRange;
				/// <summary>The original context in the syntax tree.</summary>
				Ptr<parsing::ParsingTreeObject>							originalNode;
				/// <summary>The modified context in the syntax tree.</summary>
				Ptr<parsing::ParsingTreeObject>							modifiedNode;
				/// <summary>The modified code of the selected context.</summary>
				WString													modifiedCode;
			};

/***********************************************************************
PartialParsingOutput
***********************************************************************/

			/// <summary>A data structure storing the information for a candidate item.</summary>
			struct ParsingCandidateItem
			{
				/// <summary>Semantic id.</summary>
				vint													semanticId = -1;
				/// <summary>Display name.</summary>
				WString													name;
				/// <summary>Tag object for any purpose, e.g., data binding.</summary>
				description::Value										tag;
			};

/***********************************************************************
ParsingContext
***********************************************************************/

			/// <summary>A data structure storing the context of a token.</summary>
			struct ParsingTokenContext
			{
				/// <summary>Token syntax tree for the selected token.</summary>
				parsing::ParsingTreeToken*								foundToken = nullptr;
				/// <summary>The object syntax tree parent of the token.</summary>
				parsing::ParsingTreeObject*								tokenParent = nullptr;
				/// <summary>Type of the parent.</summary>
				WString													type;
				/// <summary>Field of the parent that contains the token.</summary>
				WString													field;
				/// <summary>All acceptable semantic ids.</summary>
				Ptr<collections::List<vint>>							acceptableSemanticIds;

				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTreeNode* foundNode, RepeatingParsingExecutor* executor);
				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTextPos pos, parsing::ParsingTreeObject* rootNode, RepeatingParsingExecutor* executor);
				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTextRange range, parsing::ParsingTreeObject* rootNode, RepeatingParsingExecutor* executor);
			};

/***********************************************************************
RepeatingParsingExecutor
***********************************************************************/

			/// <summary>Repeating parsing executor.</summary>
			class RepeatingParsingExecutor : public RepeatingTaskExecutor<RepeatingParsingInput>, public Description<RepeatingParsingExecutor>
			{
			public:
				/// <summary>Callback.</summary>
				class ICallback : public virtual Interface
				{
				public:
					/// <summary>Callback when a parsing task is finished.</summary>
					/// <param name="output">the result of the parsing.</param>
					virtual void											OnParsingFinishedAsync(const RepeatingParsingOutput& output)=0;
					/// <summary>Callback when <see cref="RepeatingParsingExecutor"/> requires enabling or disabling automatically repeating calling to the SubmitTask function.</summary>
					/// <param name="enabled">Set to true to require an automatically repeating calling to the SubmitTask function</param>
					virtual void											RequireAutoSubmitTask(bool enabled)=0;
				};

				/// <summary>Parsing analyzer.</summary>
				class IParsingAnalyzer : public virtual Interface
				{
				private:
					parsing::ParsingTreeNode*								ToParent(parsing::ParsingTreeNode* node, const RepeatingPartialParsingOutput* output);
					parsing::ParsingTreeObject*								ToChild(parsing::ParsingTreeObject* node, const RepeatingPartialParsingOutput* output);
					Ptr<parsing::ParsingTreeNode>							ToChild(Ptr<parsing::ParsingTreeNode> node, const RepeatingPartialParsingOutput* output);

				protected:
					/// <summary>Get a syntax tree node's parent when the whole tree is in a partial modified state. You should use this function instead of ParsingTreeNode::GetParent when implementing this interface.</summary>
					/// <returns>Returns the parent node.</returns>
					/// <param name="node">The node.</param>
					/// <param name="output">The partial parsing output, which describes how the whole tree is partial modified.</param>
					parsing::ParsingTreeNode*								GetParent(parsing::ParsingTreeNode* node, const RepeatingPartialParsingOutput* output);
					/// <summary>Get a syntax tree node's member when the whole tree is in a partial modified state. You should use this function instead of ParsingTreeObject::GetMember when implementing this interface.</summary>
					/// <returns>Returns the member node.</returns>
					/// <param name="node">The node.</param>
					/// <param name="name">The name of the member.</param>
					/// <param name="output">The partial parsing output, which describes how the whole tree is partial modified.</param>
					Ptr<parsing::ParsingTreeNode>							GetMember(parsing::ParsingTreeObject* node, const WString& name, const RepeatingPartialParsingOutput* output);
					/// <summary>Get a syntax tree node's item when the whole tree is in a partial modified state. You should use this function instead of ParsingTreeArray::GetItem when implementing this interface.</summary>
					/// <returns>Returns the item node.</returns>
					/// <param name="node">The node.</param>
					/// <param name="index">The index of the item.</param>
					/// <param name="output">The partial parsing output, which describes how the whole tree is partial modified.</param>
					Ptr<parsing::ParsingTreeNode>							GetItem(parsing::ParsingTreeArray* node, vint index, const RepeatingPartialParsingOutput* output);

				public:
					/// <summary>Called when a <see cref="RepeatingParsingExecutor"/> is created.</summary>
					/// <param name="executor">The releated <see cref="RepeatingParsingExecutor"/>.</param>
					virtual void											Attach(RepeatingParsingExecutor* executor) = 0;

					/// <summary>Called when a <see cref="RepeatingParsingExecutor"/> is destroyed.</summary>
					/// <param name="executor">The releated <see cref="RepeatingParsingExecutor"/>.</param>
					virtual void											Detach(RepeatingParsingExecutor* executor) = 0;

					/// <summary>Called when a new parsing result is produced. A parsing analyzer can create a cache to be attached to the output containing anything necessary. This function does not run in UI thread.</summary>
					/// <param name="output">The new parsing result.</param>
					/// <returns>The created cache object, which can be null.</returns>
					virtual Ptr<DescriptableObject>							CreateCacheAsync(const RepeatingParsingOutput& output) = 0;

					/// <summary>Called when an semantic id for a token is needed. If an semantic id is returned, a context sensitive color can be assigned to this token. This functio does not run in UI thread, but it will only be called (for several times) after the cache object is initialized.</summary>
					/// <param name="tokenContext">The token context.</param>
					/// <param name="output">The current parsing result.</param>
					/// <returns>The semantic id.</returns>
					virtual vint											GetSemanticIdForTokenAsync(const ParsingTokenContext& tokenContext, const RepeatingParsingOutput& output) = 0;

					/// <summary>Called when multiple auto complete candidate items for a token is needed. If nothing is written into the "candidateItems" parameter and the grammar also doesn't provide static candidate items, nothing will popup. This functio does not run in UI thread, but it will only be called (for several times) after the cache object is initialized.</summary>
					/// <param name="tokenContext">The token context.</param>
					/// <param name="partialOutput">The partial parsing result. It contains the current parsing result, and an incremental parsing result. If the calculation of candidate items are is very context sensitive, then you should be very careful when traversing the syntax tree, by carefully looking at the "originalNode" and the "modifiedNode" in the "partialOutput" parameter.</param>
					/// <param name="candidateItems">The candidate items.</param>
					virtual void											GetCandidateItemsAsync(const ParsingTokenContext& tokenContext, const RepeatingPartialParsingOutput& partialOutput, collections::List<ParsingCandidateItem>& candidateItems) = 0;					

					/// <summary>Create a tag object for a candidate item without a tag object. An candidate item without a tag maybe created by calling <see cref="GetCandidateItemsAsync"/> or any token marked by a @Candidate attribute in the grammar.</summary>
					/// <param name="item">The candidate item.</param>
					/// <returns>The tag object. In most of the case this object is used for data binding or any other purpose when you want to customize the auto complete control. Returns null if the specified [T.vl.presentation.controls.GuiTextBoxAutoCompleteBase.IAutoCompleteControlProvider] can handle null tag correctly.</returns>
					virtual description::Value								CreateTagForCandidateItem(ParsingCandidateItem& item) = 0;
				};

				/// <summary>A base class for implementing a callback.</summary>
				class CallbackBase : public virtual ICallback, public virtual ICommonTextEditCallback
				{
				private:
					bool													callbackAutoPushing;
					elements::GuiColorizedTextElement*						callbackElement;
					SpinLock*												callbackElementModifyLock;

				protected:
					Ptr<RepeatingParsingExecutor>							parsingExecutor;

				public:
					CallbackBase(Ptr<RepeatingParsingExecutor> _parsingExecutor);
					~CallbackBase();

					void													RequireAutoSubmitTask(bool enabled)override;
					void													Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
					void													Detach()override;
					void													TextEditPreview(TextEditPreviewStruct& arguments)override;
					void													TextEditNotify(const TextEditNotifyStruct& arguments)override;
					void													TextCaretChanged(const TextCaretChangedStruct& arguments)override;
					void													TextEditFinished(vuint editVersion)override;
				};

				struct TokenMetaData
				{
					vint													tableTokenIndex;
					vint													lexerTokenIndex;
					vint													defaultColorIndex;
					bool													hasContextColor;
					bool													hasAutoComplete;
					bool													isCandidate;
					WString													unescapedRegexText;
				};

				struct FieldMetaData
				{
					vint													colorIndex;
					Ptr<collections::List<vint>>							semantics;
				};
			private:
				Ptr<parsing::tabling::ParsingGeneralParser>					grammarParser;
				WString														grammarRule;
				Ptr<IParsingAnalyzer>										analyzer;
				collections::List<ICallback*>								callbacks;
				collections::List<ICallback*>								activatedCallbacks;
				ICallback*													autoPushingCallback;

				typedef collections::Pair<WString, WString>					FieldDesc;
				collections::Dictionary<WString, vint>						tokenIndexMap;
				collections::SortedList<WString>							semanticIndexMap;
				collections::Dictionary<vint, TokenMetaData>				tokenMetaDatas;
				collections::Dictionary<FieldDesc, FieldMetaData>			fieldMetaDatas;

			protected:

				void														Execute(const RepeatingParsingInput& input)override;
				void														PrepareMetaData();

				/// <summary>Called when semantic analyzing is needed. It is encouraged to set the "cache" fields in "context" argument. If there is an <see cref="RepeatingParsingExecutor::IParsingAnalyzer"/> binded to the <see cref="RepeatingParsingExecutor"/>, this function can be automatically done.</summary>
				/// <param name="context">The parsing result.</param>
				virtual void												OnContextFinishedAsync(RepeatingParsingOutput& context);
			public:
				/// <summary>Initialize the parsing executor.</summary>
				/// <param name="_grammarParser">Parser generated from a grammar.</param>
				/// <param name="_grammarRule">The rule name to parse a complete code.</param>
				/// <param name="_analyzer">The parsing analyzer to create semantic metadatas, it can be null.</param>
				RepeatingParsingExecutor(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule, Ptr<IParsingAnalyzer> _analyzer = 0);
				~RepeatingParsingExecutor();
				
				/// <summary>Get the internal parser that parse the text.</summary>
				/// <returns>The internal parser.</returns>
				Ptr<parsing::tabling::ParsingGeneralParser>					GetParser();
				/// <summary>Detach callback.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														AttachCallback(ICallback* value);
				/// <summary>Detach callback.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														DetachCallback(ICallback* value);
				/// <summary>Activate a callback. Activating a callback means that the callback owner has an ability to watch a text box modification, e.g., an attached <see cref="ICommonTextEditCallback"/> that is also an <see cref="ICallback"/>. The <see cref="RepeatingParsingExecutor"/> may require one of the activated callback to push code for parsing automatically via a call to <see cref="ICallback::RequireAutoSubmitTask"/>.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														ActivateCallback(ICallback* value);
				/// <summary>Deactivate a callback. See <see cref="ActivateCallback"/> for deatils.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														DeactivateCallback(ICallback* value);
				/// <summary>Get the parsing analyzer.</summary>
				/// <returns>The parsing analyzer.</returns>
				Ptr<IParsingAnalyzer>										GetAnalyzer();

				vint														GetTokenIndex(const WString& tokenName);
				vint														GetSemanticId(const WString& name);
				WString														GetSemanticName(vint id);
				const TokenMetaData&										GetTokenMetaData(vint regexTokenIndex);
				const FieldMetaData&										GetFieldMetaData(const WString& type, const WString& field);

				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetAttribute(vint index, const WString& name, vint argumentCount);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetColorAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetContextColorAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetSemanticAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetCandidateAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetAutoCompleteAttribute(vint index);

				/*
				@Color(ColorName)
					field:	color of the token field when the token type is marked with @ContextColor
					token:	color of the token
				@ContextColor()
					token:	the color of the token may be changed if the token field is marked with @Color or @Semantic
				@Semantic(Type1, Type2, ...)
					field:	After resolved symbols for this field, only types of symbols that specified in the arguments are acceptable.
				@Candidate()
					token:	when the token can be available after the editing caret, than it will be in the auto complete list.
				@AutoComplete()
					token:	when the token is editing, an auto complete list will appear if possible
				*/
			};
		}
	}
}

#endif

/***********************************************************************
.\GACUI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Header Files and Common Namespaces

Global Objects:
	vl::reflection::description::					GetGlobalTypeManager
	vl::presentation::								GetParserManager
	vl::presentation::								GetResourceResolverManager
	vl::presentation::								GetCurrentController
	vl::presentation::								GetInstanceLoaderManager
	vl::presentation::elements::					GetGuiGraphicsResourceManager
	vl::presentation::controls::					GetApplication
	vl::presentation::controls::					GetPluginManager
	vl::presentation::theme::						GetCurrentTheme

	vl::presentation::windows::						GetDirect2DFactory
	vl::presentation::windows::						GetDirectWriteFactory
	vl::presentation::elements_windows_gdi::		GetWindowsGDIResourceManager
	vl::presentation::elements_windows_gdi::		GetWindowsGDIObjectProvider
	vl::presentation::elements_windows_d2d::		GetWindowsDirect2DResourceManager
	vl::presentation::elements_windows_d2d::		GetWindowsDirect2DObjectProvider
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUI
#define VCZH_PRESENTATION_GACUI


#ifdef GAC_HEADER_USE_NAMESPACE

using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::theme;
using namespace vl::presentation::templates;

#endif

extern int SetupWindowsGDIRenderer();
extern int SetupWindowsDirect2DRenderer();
extern int SetupOSXCoreGraphicsRenderer();

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGEAUTOCOMPLETE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGEAUTOCOMPLETE
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGEAUTOCOMPLETE

namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiGrammarAutoComplete
***********************************************************************/
			
			/// <summary>Grammar based auto complete controller.</summary>
			class GuiGrammarAutoComplete
				: public GuiTextBoxAutoCompleteBase
				, protected RepeatingParsingExecutor::CallbackBase
				, private RepeatingTaskExecutor<RepeatingParsingOutput>
			{
			public:

				/// <summary>The auto complete list data.</summary>
				struct AutoCompleteData : ParsingTokenContext
				{
					/// <summary>Available candidate tokens (in lexer token index).</summary>
					collections::List<vint>							candidates;
					/// <summary>Available candidate tokens (in lexer token index) that marked with @AutoCompleteCandidate().</summary>
					collections::List<vint>							shownCandidates;
					/// <summary>Candidate items.</summary>
					collections::List<ParsingCandidateItem>			candidateItems;
					/// <summary>The start position of the editing token in global coordination.</summary>
					TextPos											startPosition;
				};

				/// <summary>The analysed data from an input code.</summary>
				struct AutoCompleteContext : RepeatingPartialParsingOutput
				{
					/// <summary>The edit version of modified code.</summary>
					vuint											modifiedEditVersion = 0;
					/// <summary>The analysed auto complete list data.</summary>
					Ptr<AutoCompleteData>							autoComplete;
				};
			private:
				Ptr<parsing::tabling::ParsingGeneralParser>			grammarParser;
				collections::SortedList<WString>					leftRecursiveRules;
				bool												editing;

				SpinLock											editTraceLock;
				collections::List<TextEditNotifyStruct>				editTrace;

				SpinLock											contextLock;
				AutoCompleteContext									context;
				
				void												Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void												Detach()override;
				void												TextEditPreview(TextEditPreviewStruct& arguments)override;
				void												TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void												TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void												TextEditFinished(vuint editVersion)override;
				void												OnParsingFinishedAsync(const RepeatingParsingOutput& output)override;
				void												CollectLeftRecursiveRules();

				vint												UnsafeGetEditTraceIndex(vuint editVersion);
				TextPos												ChooseCorrectTextPos(TextPos pos, const regex::RegexTokens& tokens);
				void												ExecuteRefresh(AutoCompleteContext& newContext);

				bool												NormalizeTextPos(AutoCompleteContext& newContext, elements::text::TextLines& lines, TextPos& pos);
				void												ExecuteEdit(AutoCompleteContext& newContext);

				void												DeleteFutures(collections::List<parsing::tabling::ParsingState::Future*>& futures);
				regex::RegexToken*									TraverseTransitions(
																		parsing::tabling::ParsingState& state,
																		parsing::tabling::ParsingTransitionCollector& transitionCollector,
																		TextPos stopPosition,
																		collections::List<parsing::tabling::ParsingState::Future*>& nonRecoveryFutures,
																		collections::List<parsing::tabling::ParsingState::Future*>& recoveryFutures
																		);
				regex::RegexToken*									SearchValidInputToken(
																		parsing::tabling::ParsingState& state,
																		parsing::tabling::ParsingTransitionCollector& transitionCollector,
																		TextPos stopPosition,
																		AutoCompleteContext& newContext,
																		collections::SortedList<vint>& tableTokenIndices
																		);

				TextPos												GlobalTextPosToModifiedTextPos(AutoCompleteContext& newContext, TextPos pos);
				TextPos												ModifiedTextPosToGlobalTextPos(AutoCompleteContext& newContext, TextPos pos);
				void												ExecuteCalculateList(AutoCompleteContext& newContext);

				void												Execute(const RepeatingParsingOutput& input)override;
				void												PostList(const AutoCompleteContext& newContext, bool byGlobalCorrection);
				void												Initialize();
			protected:

				/// <summary>Called when the context of the code is selected. It is encouraged to set the "candidateItems" field in "context.autoComplete" during the call. If there is an <see cref="RepeatingParsingExecutor::IParsingAnalyzer"/> binded to the <see cref="RepeatingParsingExecutor"/>, this function can be automatically done.</summary>
				/// <param name="context">The selected context.</param>
				virtual void										OnContextFinishedAsync(AutoCompleteContext& context);

				/// <summary>Call this function in the derived class's destructor when it overrided <see cref="OnContextFinishedAsync"/>.</summary>
				void												EnsureAutoCompleteFinished();
			public:
				/// <summary>Create the auto complete controller with a created parsing executor.</summary>
				/// <param name="_parsingExecutor">The parsing executor.</param>
				GuiGrammarAutoComplete(Ptr<RepeatingParsingExecutor> _parsingExecutor);
				/// <summary>Create the auto complete controller with a specified grammar and start rule to create a <see cref="RepeatingParsingExecutor"/>.</summary>
				/// <param name="_grammarParser">Parser generated from a grammar.</param>
				/// <param name="_grammarRule"></param>
				GuiGrammarAutoComplete(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule);
				~GuiGrammarAutoComplete();

				/// <summary>Get the internal parsing executor.</summary>
				/// <returns>The parsing executor.</returns>
				Ptr<RepeatingParsingExecutor>						GetParsingExecutor();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGECOLORIZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGECOLORIZER
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGECOLORIZER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiGrammarColorizer
***********************************************************************/

			/// <summary>Grammar based colorizer.</summary>
			class GuiGrammarColorizer : public GuiTextBoxRegexColorizer, protected RepeatingParsingExecutor::CallbackBase
			{
				typedef collections::Pair<WString, WString>					FieldDesc;
				typedef collections::Dictionary<FieldDesc, vint>			FieldContextColors;
				typedef collections::Dictionary<FieldDesc, vint>			FieldSemanticColors;
				typedef elements::text::ColorEntry							ColorEntry;
			public:
				/// <summary>Context for doing semantic colorizing.</summary>
				struct SemanticColorizeContext : ParsingTokenContext
				{
					/// <summary>Output semantic id that comes from one the argument in the @Semantic attribute.</summary>
					vint													semanticId;
				};
			private:
				collections::Dictionary<WString, ColorEntry>				colorSettings;
				collections::Dictionary<vint, vint>							semanticColorMap;

				SpinLock													contextLock;
				RepeatingParsingOutput										context;

				void														OnParsingFinishedAsync(const RepeatingParsingOutput& output)override;
			protected:
				/// <summary>Called when the node is parsed successfully before restarting colorizing.</summary>
				/// <param name="context">The result of the parsing.</param>
				virtual void												OnContextFinishedAsync(const RepeatingParsingOutput& context);

				void														Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void														Detach()override;
				void														TextEditPreview(TextEditPreviewStruct& arguments)override;
				void														TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void														TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void														TextEditFinished(vuint editVersion)override;

				/// <summary>Called when a @SemanticColor attribute in a grammar is activated during colorizing to determine a color for the token. If there is an <see cref="RepeatingParsingExecutor::IParsingAnalyzer"/> binded to the <see cref="RepeatingParsingExecutor"/>, this function can be automatically done.</summary>
				/// <param name="context">Context for doing semantic colorizing.</param>
				/// <param name="input">The corressponding result from the <see cref="RepeatingParsingExecutor"/>.</param>
				virtual void												OnSemanticColorize(SemanticColorizeContext& context, const RepeatingParsingOutput& input);

				/// <summary>Call this function in the derived class's destructor when it overrided <see cref="OnSemanticColorize"/>.</summary>
				void														EnsureColorizerFinished();
			public:
				/// <summary>Create the colorizer with a created parsing executor.</summary>
				/// <param name="_parsingExecutor">The parsing executor.</param>
				GuiGrammarColorizer(Ptr<RepeatingParsingExecutor> _parsingExecutor);
				/// <summary>Create the colorizer with a specified grammar and start rule to create a <see cref="RepeatingParsingExecutor"/>.</summary>
				/// <param name="_grammarParser">Parser generated from a grammar.</param>
				/// <param name="_grammarRule"></param>
				GuiGrammarColorizer(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule);
				~GuiGrammarColorizer();

				/// <summary>Reset all color settings.</summary>
				void														BeginSetColors();
				/// <summary>Get all color names.</summary>
				/// <returns>All color names.</returns>
				const collections::SortedList<WString>&						GetColorNames();
				/// <summary>Get the color for a token theme name (@Color or @ContextColor("theme-name") in the grammar).</summary>
				/// <returns>The color.</returns>
				/// <param name="name">The token theme name.</param>
				ColorEntry													GetColor(const WString& name);
				/// <summary>Set a color for a token theme name (@Color or @ContextColor("theme-name") in the grammar).</summary>
				/// <param name="name">The token theme name.</param>
				/// <param name="entry">The color.</param>
				void														SetColor(const WString& name, const ColorEntry& entry);
				/// <summary>Set a color for a token theme name (@Color or @ContextColor("theme-name") in the grammar).</summary>
				/// <param name="name">The token theme name.</param>
				/// <param name="color">The color.</param>
				void														SetColor(const WString& name, const Color& color);
				/// <summary>Submit all color settings.</summary>
				void														EndSetColors();
				void														ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState)override;

				/// <summary>Get the internal parsing executor.</summary>
				/// <returns>The parsing executor.</returns>
				Ptr<RepeatingParsingExecutor>								GetParsingExecutor();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIRIBBONIMPL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIRIBBONIMPL
#define VCZH_PRESENTATION_CONTROLS_GUIRIBBONIMPL


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiBindableRibbonGalleryList;

/***********************************************************************
GalleryItemArranger
***********************************************************************/

			namespace ribbon_impl
			{
				class GalleryItemArranger : public list::RangedItemArrangerBase, public Description<GalleryItemArranger>
				{
				private:
					vint										pim_itemWidth = 0;
					bool										blockScrollUpdate = true;

				protected:
					GuiBindableRibbonGalleryList*				owner;
					vint										itemWidth = 1;
					vint										firstIndex = 0;

					void										BeginPlaceItem(bool forMoving, Rect newBounds, vint& newStartIndex)override;
					void										PlaceItem(bool forMoving, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
					bool										IsItemOutOfViewBounds(vint index, ItemStyleRecord style, Rect bounds, Rect viewBounds)override;
					bool										EndPlaceItem(bool forMoving, Rect newBounds, vint newStartIndex)override;
					void										InvalidateItemSizeCache()override;
					Size										OnCalculateTotalSize()override;
				public:
					GalleryItemArranger(GuiBindableRibbonGalleryList* _owner);
					~GalleryItemArranger();

					vint										FindItem(vint itemIndex, compositions::KeyDirection key)override;
					GuiListControl::EnsureItemVisibleResult		EnsureItemVisible(vint itemIndex)override;
					Size										GetAdoptedSize(Size expectedSize)override;

					void										ScrollUp();
					void										ScrollDown();
					void										UnblockScrollUpdate();
				};

				class GalleryResponsiveLayout : public compositions::GuiResponsiveCompositionBase, public Description<GalleryResponsiveLayout>
				{
				protected:
					vint										minCount = 0;
					vint										maxCount = 0;
					Size										sizeOffset;
					vint										itemCount = 0;
					vint										itemWidth = 1;

					void										UpdateMinSize();
				public:
					GalleryResponsiveLayout();
					~GalleryResponsiveLayout();

					vint										GetMinCount();
					vint										GetMaxCount();
					vint										GetItemWidth();
					Size										GetSizeOffset();
					vint										GetVisibleItemCount();

					void										SetMinCount(vint value);
					void										SetMaxCount(vint value);
					void										SetItemWidth(vint value);
					void										SetSizeOffset(Size value);

					vint										GetLevelCount()override;
					vint										GetCurrentLevel()override;
					bool										LevelDown()override;
					bool										LevelUp()override;
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\RESOURCES\GUIDOCUMENTCLIPBOARD.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTCLIPBOARD
#define VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTCLIPBOARD


namespace vl
{
	namespace presentation
	{
		extern void					ModifyDocumentForClipboard(Ptr<DocumentModel> model);
		extern Ptr<DocumentModel>	LoadDocumentFromClipboardStream(stream::IStream& stream);
		extern void					SaveDocumentToClipboardStream(Ptr<DocumentModel> model, stream::IStream& stream);

		extern void					SaveDocumentToRtf(Ptr<DocumentModel> model, AString& rtf);
		extern void					SaveDocumentToRtfStream(Ptr<DocumentModel> model, stream::IStream& stream);

		extern void					SaveDocumentToHtmlUtf8(Ptr<DocumentModel> model, AString& header, AString& content, AString& footer);
		extern void					SaveDocumentToHtmlClipboardStream(Ptr<DocumentModel> model, stream::IStream& stream);
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIDOCUMENTEDITOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTEDITOR
#define VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTEDITOR


namespace vl
{
	namespace presentation
	{
		typedef DocumentModel::RunRange			RunRange;
		typedef DocumentModel::RunRangeMap		RunRangeMap;

		namespace document_editor
		{
			extern void									GetRunRange(DocumentParagraphRun* run, RunRangeMap& runRanges);
			extern void									LocateStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, vint position, bool frontSide, collections::List<DocumentContainerRun*>& locatedRuns);
			extern Ptr<DocumentHyperlinkRun::Package>	LocateHyperlink(DocumentParagraphRun* run, RunRangeMap& runRanges, vint row, vint start, vint end);
			extern Ptr<DocumentStyleProperties>			CopyStyle(Ptr<DocumentStyleProperties> style);
			extern Ptr<DocumentRun>						CopyRun(DocumentRun* run);
			extern Ptr<DocumentRun>						CopyStyledText(collections::List<DocumentContainerRun*>& styleRuns, const WString& text);
			extern Ptr<DocumentRun>						CopyRunRecursively(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, bool deepCopy);
			extern void									CollectStyleName(DocumentParagraphRun* run, collections::List<WString>& styleNames);
			extern void									ReplaceStyleName(DocumentParagraphRun* run, const WString& oldStyleName, const WString& newStyleName);
			extern void									RemoveRun(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern void									CutRun(DocumentParagraphRun* run, RunRangeMap& runRanges, vint position, Ptr<DocumentRun>& leftRun, Ptr<DocumentRun>& rightRun);
			extern void									ClearUnnecessaryRun(DocumentParagraphRun* run, DocumentModel* model);
			extern void									AddStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, Ptr<DocumentStyleProperties> style);
			extern void									AddHyperlink(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, const WString& reference, const WString& normalStyleName, const WString& activeStyleName);
			extern void									AddStyleName(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, const WString& styleName);
			extern void									RemoveHyperlink(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern void									RemoveStyleName(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern void									ClearStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern Ptr<DocumentStyleProperties>			SummarizeStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, DocumentModel* model, vint start, vint end);
			extern Nullable<WString>					SummarizeStyleName(DocumentParagraphRun* run, RunRangeMap& runRanges, DocumentModel* model, vint start, vint end);
			extern void									AggregateStyle(Ptr<DocumentStyleProperties>& dst, Ptr<DocumentStyleProperties> src);
		}
	}
}

#endif
