/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "VlppGlrParser.h"
#include "VlppWorkflowLibrary.h"
#include "VlppReflection.h"
#include "VlppOS.h"
#include "Vlpp.h"
#include "VlppRegex.h"
#include "VlppParser.h"

/***********************************************************************
.\GUITYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Common Types

Classes:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUITYPES
#define VCZH_PRESENTATION_GUITYPES


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

/***********************************************************************
Enumerations
***********************************************************************/
		
		/// <summary>
		/// Defines an alignment direction.
		/// </summary>
		enum class Alignment
		{
			/// <summary>Aligned to the left side.</summary>
			Left=0,
			/// <summary>Aligned to the top side.</summary>
			Top=0,
			/// <summary>Aligned to the center.</summary>
			Center=1,
			/// <summary>Aligned to the right side.</summary>
			Right=2,
			/// <summary>Aligned to the bottom side.</summary>
			Bottom=2,
		};

		/// <summary>Axis direction.</summary>
		enum class AxisDirection
		{
			/// <summary>X:left, Y:down.</summary>
			LeftDown,
			/// <summary>X:right, Y:down.</summary>
			RightDown,
			/// <summary>X:left, Y:up.</summary>
			LeftUp,
			/// <summary>X:right, Y:up.</summary>
			RightUp,
			/// <summary>X:down, Y:left.</summary>
			DownLeft,
			/// <summary>X:down, Y:right.</summary>
			DownRight,
			/// <summary>X:up, Y:left.</summary>
			UpLeft,
			/// <summary>X:up, Y:right.</summary>
			UpRight,
		};

#define GUI_DEFINE_COMPARE_OPERATORS(TYPE)\
		auto operator<=>(const TYPE&) const = default;\

/***********************************************************************
TextPos
***********************************************************************/
		
		/// <summary>
		/// Represents the position in multiple lines of text.
		/// </summary>
		struct TextPos
		{
			/// <summary>
			/// Row number.
			/// </summary>
			vint			row;
			/// <summary>
			/// Column number. If a line has 4 characters, there are 5 available column numbers(from 0 to 4) in this line.
			/// </summary>
			vint			column;

			TextPos()
				:row(0) ,column(0)
			{
			}

			TextPos(vint _row, vint _column)
				:row(_row) ,column(_column)
			{
			}

			GUI_DEFINE_COMPARE_OPERATORS(TextPos)
		};

/***********************************************************************
GridPos
***********************************************************************/
		
		/// <summary>
		/// Represents the cell position in a grid.
		/// </summary>
		struct GridPos
		{
			/// <summary>
			/// Row number.
			/// </summary>
			vint			row;
			/// <summary>
			/// Column number. If a line has 4 characters, there are 5 available column numbers(from 0 to 4) in this line.
			/// </summary>
			vint			column;

			GridPos()
				:row(0) ,column(0)
			{
			}

			GridPos(vint _row, vint _column)
				:row(_row) ,column(_column)
			{
			}

			GUI_DEFINE_COMPARE_OPERATORS(GridPos)
		};

/***********************************************************************
Coordinate
***********************************************************************/

		/// <summary>
		/// Represents a position in the local window coordinate space, which is DPI awared.
		/// </summary>
		using GuiCoordinate = vint;
		
		/// <summary>
		/// Represents a position in the global screen coordinate space.
		/// </summary>
		struct NativeCoordinate
		{
			vint				value;

			NativeCoordinate() :value(0) {}
			NativeCoordinate(vint _value) :value(_value) {}
			NativeCoordinate(const NativeCoordinate& _value) = default;
			NativeCoordinate(NativeCoordinate&& _value) = default;
			NativeCoordinate& operator=(const NativeCoordinate& _value) = default;
			NativeCoordinate& operator=(NativeCoordinate&& _value) = default;

			GUI_DEFINE_COMPARE_OPERATORS(NativeCoordinate)

			inline NativeCoordinate operator+(NativeCoordinate c)const { return value + c.value; };
			inline NativeCoordinate operator-(NativeCoordinate c)const { return value - c.value; };
			inline NativeCoordinate operator*(NativeCoordinate c)const { return value * c.value; };
			inline NativeCoordinate operator/(NativeCoordinate c)const { return value / c.value; };

			inline NativeCoordinate& operator+=(NativeCoordinate c) { value += c.value; return *this; };
			inline NativeCoordinate& operator-=(NativeCoordinate c) { value -= c.value; return *this; };
			inline NativeCoordinate& operator*=(NativeCoordinate c) { value *= c.value; return *this; };
			inline NativeCoordinate& operator/=(NativeCoordinate c) { value /= c.value; return *this; };
		};

		inline vint CompareCoordinate(vint a, vint b) { return a - b; }
		inline vint CompareCoordinate(NativeCoordinate a, NativeCoordinate b) { return a.value - b.value; }

/***********************************************************************
Point
***********************************************************************/
		
		/// <summary>
		/// Represents a position in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Point_
		{
			/// <summary>
			/// Position in x dimension.
			/// </summary>
			T				x;
			/// <summary>
			/// Position in y dimension.
			/// </summary>
			T				y;

			Point_()
				:x(0), y(0)
			{
			}

			Point_(T _x, T _y)
				:x(_x), y(_y)
			{
			}

			GUI_DEFINE_COMPARE_OPERATORS(Point_<T>)
		};

		using Point = Point_<GuiCoordinate>;
		using NativePoint = Point_<NativeCoordinate>;

/***********************************************************************
Size
***********************************************************************/
		
		/// <summary>
		/// Represents a size in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Size_
		{
			/// <summary>
			/// Size in x dimension.
			/// </summary>
			T				x;
			/// <summary>
			/// Size in y dimension.
			/// </summary>
			T				y;

			Size_()
				:x(0), y(0)
			{
			}

			Size_(T _x, T _y)
				:x(_x), y(_y)
			{
			}

			GUI_DEFINE_COMPARE_OPERATORS(Size_<T>)
		};

		using Size = Size_<GuiCoordinate>;
		using NativeSize = Size_<NativeCoordinate>;

/***********************************************************************
Rectangle
***********************************************************************/
		
		/// <summary>
		/// Represents a bounds in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Rect_
		{
			/// <summary>
			/// Left.
			/// </summary>
			T				x1;
			/// <summary>
			/// Top.
			/// </summary>
			T				y1;
			/// <summary>
			/// Left + Width.
			/// </summary>
			T				x2;
			/// <summary>
			/// Top + Height.
			/// </summary>
			T				y2;

			Rect_()
				:x1(0), y1(0), x2(0), y2(0)
			{
			}

			Rect_(T _x1, T _y1, T _x2, T _y2)
				:x1(_x1), y1(_y1), x2(_x2), y2(_y2)
			{
			}

			Rect_(Point_<T> p, Size_<T> s)
				:x1(p.x), y1(p.y), x2(p.x + s.x), y2(p.y + s.y)
			{
			}

			GUI_DEFINE_COMPARE_OPERATORS(Rect_<T>)

			Point_<T> LeftTop() const
			{
				return Point_<T>(x1, y1);
			}

			Point_<T> RightBottom() const
			{
				return Point_<T>(x2, y2);
			}

			Size_<T> GetSize() const
			{
				return Size_<T>(x2 - x1, y2 - y1);
			}

			T Left() const
			{
				return x1;
			}

			T Right() const
			{
				return x2;
			}

			T Width() const
			{
				return x2 - x1;
			}

			T Top() const
			{
				return y1;
			}

			T Bottom() const
			{
				return y2;
			}

			T Height() const
			{
				return y2 - y1;
			}

			void Expand(T x, T y)
			{
				x1 -= x;
				y1 -= y;
				x2 += x;
				y2 += y;
			}

			void Expand(Size_<T> s)
			{
				x1 -= s.x;
				y1 -= s.y;
				x2 += s.x;
				y2 += s.y;
			}

			void Move(T x, T y)
			{
				x1 += x;
				y1 += y;
				x2 += x;
				y2 += y;
			}

			void Move(Size_<T> s)
			{
				x1 += s.x;
				y1 += s.y;
				x2 += s.x;
				y2 += s.y;
			}

			bool Contains(Point_<T> p) const
			{
				return x1 <= p.x && p.x < x2 && y1 <= p.y && p.y < y2;
			}

			bool Contains(Rect_<T> r) const
			{
				return x1 <= r.x1 && r.x2 <= x2 && y1 <= r.y1 && r.y2 <= y2;
			}

			Rect_<T> Intersect(Rect_<T> r)  const
			{
				Rect_<T> result = r;
				if (r.x1 < x1) r.x1 = x1;
				if (r.x2 > x2) r.x2 = x2;
				if (r.y1 < y1) r.y1 = y1;
				if (r.y2 > y2) r.y2 = y2;
				return r;
			}
		};

		using Rect = Rect_<GuiCoordinate>;
		using NativeRect = Rect_<NativeCoordinate>;

/***********************************************************************
2D operations
***********************************************************************/

		template<typename T>
		inline Point_<T> operator+(Point_<T> p, Size_<T> s)
		{
			return Point_<T>(p.x + s.x, p.y + s.y);
		}

		template<typename T>
		inline Point_<T> operator+(Size_<T> s, Point_<T> p)
		{
			return Point_<T>(p.x + s.x, p.y + s.y);
		}

		template<typename T>
		inline Point_<T> operator-(Point_<T> p, Size_<T> s)
		{
			return Point_<T>(p.x - s.x, p.y - s.y);
		}

		template<typename T>
		inline Size_<T> operator-(Point_<T> p1, Point_<T> p2)
		{
			return Size_<T>(p1.x - p2.x, p1.y - p2.y);
		}

		template<typename T>
		inline Size_<T> operator+(Size_<T> s1, Size_<T> s2)
		{
			return Size_<T>(s1.x + s2.x, s1.y + s2.y);
		}

		template<typename T>
		inline Size_<T> operator-(Size_<T> s1, Size_<T> s2)
		{
			return Size_<T>(s1.x - s2.x, s1.y - s2.y);
		}

		template<typename T>
		inline Size_<T> operator*(Size_<T> s, vint i)
		{
			return Size_<T>(s.x*i, s.y*i);
		}

		template<typename T>
		inline Size_<T> operator/(Size_<T> s, vint i)
		{
			return Size_<T>(s.x / i, s.y / i);
		}

		template<typename T>
		inline Point_<T> operator+=(Point_<T>& s1, Size_<T> s2)
		{
			s1.x += s2.x;
			s1.y += s2.y;
			return s1;
		}

		template<typename T>
		inline Point_<T> operator-=(Point_<T>& s1, Size_<T> s2)
		{
			s1.x -= s2.x;
			s1.y -= s2.y;
			return s1;
		}

		template<typename T>
		inline Size_<T> operator+=(Size_<T>& s1, Size_<T> s2)
		{
			s1.x += s2.x;
			s1.y += s2.y;
			return s1;
		}

		template<typename T>
		inline Size_<T> operator-=(Size_<T>& s1, Size_<T> s2)
		{
			s1.x -= s2.x;
			s1.y -= s2.y;
			return s1;
		}

/***********************************************************************
Color
***********************************************************************/
		
		/// <summary>Represents a 32bit RGBA color. Values of separate components can be accessed using fields "r", "g", "b" and "a".</summary>
		struct Color
		{
			union
			{
				struct
				{
					unsigned char r;
					unsigned char g;
					unsigned char b;
					unsigned char a;
				};
				vuint32_t value;
			};

			Color()
				:r(0), g(0), b(0), a(255)
			{
			}

			Color(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a=255)
				:r(_r), g(_g), b(_b), a(_a)
			{
			}

			std::strong_ordering operator<=>(const Color& c) const { return value <=> c.value; }
			bool operator==(const Color& c) const { return value == c.value; }

			static Color Parse(const WString& value)
			{
				const wchar_t* code=L"0123456789ABCDEF";
				if((value.Length()==7 || value.Length()==9) && value[0]==L'#')
				{
					vint index[8]={15, 15, 15, 15, 15, 15, 15, 15};
					for(vint i=0;i<value.Length()-1;i++)
					{
						index[i]=wcschr(code, value[i+1])-code;
						if(index[i]<0 || index[i]>15)
						{
							return Color();
						}
					}

					Color c;
					c.r=(unsigned char)(index[0]*16+index[1]);
					c.g=(unsigned char)(index[2]*16+index[3]);
					c.b=(unsigned char)(index[4]*16+index[5]);
					c.a=(unsigned char)(index[6]*16+index[7]);
					return c;
				}
				return Color();
			}

			WString ToString()const
			{
				const wchar_t* code=L"0123456789ABCDEF";
				wchar_t result[10]=L"#00000000";
				result[1]=code[r/16];
				result[2]=code[r%16];
				result[3]=code[g/16];
				result[4]=code[g%16];
				result[5]=code[b/16];
				result[6]=code[b%16];
				if(a==255)
				{
					result[7]=L'\0';
				}
				else
				{
					result[7]=code[a/16];
					result[8]=code[a%16];
				}
				return result;
			}
		};

/***********************************************************************
Margin
***********************************************************************/
		
		/// <summary>
		/// Represents a margin in a two dimensions space.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct Margin_
		{
			/// <summary>
			/// The left margin.
			/// </summary>
			T			left;
			/// <summary>
			/// The top margin.
			/// </summary>
			T			top;
			/// <summary>
			/// The right margin.
			/// </summary>
			T			right;
			/// <summary>
			/// The bottom margin.
			/// </summary>
			T			bottom;

			Margin_()
				:left(0), top(0), right(0), bottom(0)
			{
			}

			Margin_(T _left, T _top, T _right, T _bottom)
				:left(_left), top(_top), right(_right), bottom(_bottom)
			{
			}

			GUI_DEFINE_COMPARE_OPERATORS(Margin_<T>)
		};

		using Margin = Margin_<GuiCoordinate>;
		using NativeMargin = Margin_<NativeCoordinate>;

/***********************************************************************
Resources
***********************************************************************/
		
		/// <summary>
		/// Represents a font configuration.
		/// </summary>
		struct FontProperties
		{
			/// <summary>
			/// Font family (or font name, usually).
			/// </summary>
			WString				fontFamily;
			/// <summary>
			/// Font size in pixel.
			/// </summary>
			vint				size;
			/// <summary>
			/// True if the font is bold.
			/// </summary>
			bool				bold;
			/// <summary>
			/// True if the font is italic.
			/// </summary>
			bool				italic;
			/// <summary>
			/// True if the font has a underline.
			/// </summary>
			bool				underline;
			/// <summary>
			/// True if the font has a strikeline.
			/// </summary>
			bool				strikeline;
			/// <summary>
			/// True if the font has anti alias rendering.
			/// </summary>
			bool				antialias;
			/// <summary>
			/// True if the font has anti alias rendering in vertical direction.
			/// </summary>
			bool				verticalAntialias;

			FontProperties()
				:size(0)
				,bold(false)
				,italic(false)
				,underline(false)
				,strikeline(false)
				,antialias(true)
				,verticalAntialias(false)
			{
			}
			
			GUI_DEFINE_COMPARE_OPERATORS(FontProperties)
		};

/***********************************************************************
Keys
***********************************************************************/

#define GUI_DEFINE_KEYBOARD_CODE_BASIC(ITEM)									\
/*																				\
 * Virtual Keys, Standard Set													\
 */																				\
ITEM(LBUTTON,             0x01)													\
ITEM(RBUTTON,             0x02)													\
ITEM(CANCEL,              0x03)													\
ITEM(MBUTTON,             0x04)		/* NOT contiguous with L & RBUTTON */		\
ITEM(XBUTTON1,            0x05)		/* NOT contiguous with L & RBUTTON */		\
ITEM(XBUTTON2,            0x06)		/* NOT contiguous with L & RBUTTON */		\
ITEM(BACK,                0x08)													\
ITEM(TAB,                 0x09)													\
ITEM(CLEAR,               0x0C)													\
ITEM(RETURN,              0x0D)													\
ITEM(SHIFT,               0x10)													\
ITEM(CONTROL,             0x11)													\
ITEM(MENU,                0x12)													\
ITEM(PAUSE,               0x13)													\
ITEM(CAPITAL,             0x14)													\
ITEM(KANA_HANGUL,         0x15)													\
ITEM(JUNJA,               0x17)													\
ITEM(FINAL,               0x18)													\
ITEM(KANJI,               0x19)													\
ITEM(ESCAPE,              0x1B)													\
ITEM(CONVERT,             0x1C)													\
ITEM(NONCONVERT,          0x1D)													\
ITEM(ACCEPT,              0x1E)													\
ITEM(MODECHANGE,          0x1F)													\
ITEM(SPACE,               0x20)													\
ITEM(PRIOR,               0x21)													\
ITEM(NEXT,                0x22)													\
ITEM(END,                 0x23)													\
ITEM(HOME,                0x24)													\
ITEM(LEFT,                0x25)													\
ITEM(UP,                  0x26)													\
ITEM(RIGHT,               0x27)													\
ITEM(DOWN,                0x28)													\
ITEM(SELECT,              0x29)													\
ITEM(PRINT,               0x2A)													\
ITEM(EXECUTE,             0x2B)													\
ITEM(SNAPSHOT,            0x2C)													\
ITEM(INSERT,              0x2D)													\
ITEM(DELETE,              0x2E)													\
ITEM(HELP,                0x2F)													\
/*																				\
 * VKEY_0 - VKEY_9 are the same as ASCII '0' - '9' (0x30 - 0x39)				\
 * VKEY_A - VKEY_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)				\
 */																				\
ITEM(0,                   0x30)													\
ITEM(1,                   0x31)													\
ITEM(2,                   0x32)													\
ITEM(3,                   0x33)													\
ITEM(4,                   0x34)													\
ITEM(5,                   0x35)													\
ITEM(6,                   0x36)													\
ITEM(7,                   0x37)													\
ITEM(8,                   0x38)													\
ITEM(9,                   0x39)													\
ITEM(A,                   0x41)													\
ITEM(B,                   0x42)													\
ITEM(C,                   0x43)													\
ITEM(D,                   0x44)													\
ITEM(E,                   0x45)													\
ITEM(F,                   0x46)													\
ITEM(G,                   0x47)													\
ITEM(H,                   0x48)													\
ITEM(I,                   0x49)													\
ITEM(J,                   0x4A)													\
ITEM(K,                   0x4B)													\
ITEM(L,                   0x4C)													\
ITEM(M,                   0x4D)													\
ITEM(N,                   0x4E)													\
ITEM(O,                   0x4F)													\
ITEM(P,                   0x50)													\
ITEM(Q,                   0x51)													\
ITEM(R,                   0x52)													\
ITEM(S,                   0x53)													\
ITEM(T,                   0x54)													\
ITEM(U,                   0x55)													\
ITEM(V,                   0x56)													\
ITEM(W,                   0x57)													\
ITEM(X,                   0x58)													\
ITEM(Y,                   0x59)													\
ITEM(Z,                   0x5A)													\
ITEM(LWIN,                0x5B)													\
ITEM(RWIN,                0x5C)													\
ITEM(APPS,                0x5D)													\
ITEM(SLEEP,               0x5F)													\
ITEM(NUMPAD0,             0x60)													\
ITEM(NUMPAD1,             0x61)													\
ITEM(NUMPAD2,             0x62)													\
ITEM(NUMPAD3,             0x63)													\
ITEM(NUMPAD4,             0x64)													\
ITEM(NUMPAD5,             0x65)													\
ITEM(NUMPAD6,             0x66)													\
ITEM(NUMPAD7,             0x67)													\
ITEM(NUMPAD8,             0x68)													\
ITEM(NUMPAD9,             0x69)													\
ITEM(MULTIPLY,            0x6A)													\
ITEM(ADD,                 0x6B)													\
ITEM(SEPARATOR,           0x6C)													\
ITEM(SUBTRACT,            0x6D)													\
ITEM(DECIMAL,             0x6E)													\
ITEM(DIVIDE,              0x6F)													\
ITEM(F1,                  0x70)													\
ITEM(F2,                  0x71)													\
ITEM(F3,                  0x72)													\
ITEM(F4,                  0x73)													\
ITEM(F5,                  0x74)													\
ITEM(F6,                  0x75)													\
ITEM(F7,                  0x76)													\
ITEM(F8,                  0x77)													\
ITEM(F9,                  0x78)													\
ITEM(F10,                 0x79)													\
ITEM(F11,                 0x7A)													\
ITEM(F12,                 0x7B)													\
ITEM(F13,                 0x7C)													\
ITEM(F14,                 0x7D)													\
ITEM(F15,                 0x7E)													\
ITEM(F16,                 0x7F)													\
ITEM(F17,                 0x80)													\
ITEM(F18,                 0x81)													\
ITEM(F19,                 0x82)													\
ITEM(F20,                 0x83)													\
ITEM(F21,                 0x84)													\
ITEM(F22,                 0x85)													\
ITEM(F23,                 0x86)													\
ITEM(F24,                 0x87)													\
ITEM(NUMLOCK,             0x90)													\
ITEM(SCROLL,              0x91)													\
/*																				\
 * Fujitsu/OASYS kbd definitions												\
 */																				\
ITEM(OEM_FJ_JISHO,        0x92)		/* 'Dictionary' key */						\
ITEM(OEM_FJ_MASSHOU,      0x93)		/* 'Unregister word' key */					\
ITEM(OEM_FJ_TOUROKU,      0x94)		/* 'Register word' key */					\
ITEM(OEM_FJ_LOYA,         0x95)		/* 'Left OYAYUBI' key */					\
ITEM(OEM_FJ_ROYA,         0x96)		/* 'Right OYAYUBI' key */					\
/*																				\
 * VKEY_L* & VKEY_R* - left and right Alt, Ctrl and Shift virtual keys.			\
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().				\
 * No other API or message will distinguish left and right keys in this way.	\
 */																				\
ITEM(LSHIFT,              0xA0)													\
ITEM(RSHIFT,              0xA1)													\
ITEM(LCONTROL,            0xA2)													\
ITEM(RCONTROL,            0xA3)													\
ITEM(LMENU,               0xA4)													\
ITEM(RMENU,               0xA5)													\
ITEM(BROWSER_BACK,        0xA6)													\
ITEM(BROWSER_FORWARD,     0xA7)													\
ITEM(BROWSER_REFRESH,     0xA8)													\
ITEM(BROWSER_STOP,        0xA9)													\
ITEM(BROWSER_SEARCH,      0xAA)													\
ITEM(BROWSER_FAVORITES,   0xAB)													\
ITEM(BROWSER_HOME,        0xAC)													\
ITEM(VOLUME_MUTE,         0xAD)													\
ITEM(VOLUME_DOWN,         0xAE)													\
ITEM(VOLUME_UP,           0xAF)													\
ITEM(MEDIA_NEXT_TRACK,    0xB0)													\
ITEM(MEDIA_PREV_TRACK,    0xB1)													\
ITEM(MEDIA_STOP,          0xB2)													\
ITEM(MEDIA_PLAY_PAUSE,    0xB3)													\
ITEM(LAUNCH_MAIL,         0xB4)													\
ITEM(LAUNCH_MEDIA_SELECT, 0xB5)													\
ITEM(LAUNCH_APP1,         0xB6)													\
ITEM(LAUNCH_APP2,         0xB7)													\
ITEM(OEM_PLUS,            0xBB)		/* '+' any country */						\
ITEM(OEM_COMMA,           0xBC)		/* ',' any country */						\
ITEM(OEM_MINUS,           0xBD)		/* '-' any country */						\
ITEM(OEM_PERIOD,          0xBE)		/* '.' any country */						\
ITEM(OEM_8,               0xDF)													\
/*																				\
 * Various extended or enhanced keyboards										\
 */																				\
ITEM(OEM_AX,              0xE1)		/* 'AX' key on Japanese AX kbd */			\
ITEM(OEM_102,             0xE2)		/* "<>" or "\|" on RT 102-key kbd */		\
ITEM(ICO_HELP,            0xE3)		/* Help key on ICO */						\
ITEM(ICO_00,              0xE4)		/* 00 key on ICO */							\
ITEM(PROCESSKEY,          0xE5)													\
ITEM(ICO_CLEAR,           0xE6)													\
ITEM(PACKET,              0xE7)													\
/*																				\
 * Nokia/Ericsson definitions													\
 */																				\
ITEM(OEM_RESET,           0xE9)													\
ITEM(OEM_JUMP,            0xEA)													\
ITEM(OEM_PA1,             0xEB)													\
ITEM(OEM_PA2,             0xEC)													\
ITEM(OEM_PA3,             0xED)													\
ITEM(OEM_WSCTRL,          0xEE)													\
ITEM(OEM_CUSEL,           0xEF)													\
ITEM(OEM_ATTN,            0xF0)													\
ITEM(OEM_FINISH,          0xF1)													\
ITEM(OEM_COPY,            0xF2)													\
ITEM(OEM_AUTO,            0xF3)													\
ITEM(OEM_ENLW,            0xF4)													\
ITEM(OEM_BACKTAB,         0xF5)													\
ITEM(ATTN,                0xF6)													\
ITEM(CRSEL,               0xF7)													\
ITEM(EXSEL,               0xF8)													\
ITEM(EREOF,               0xF9)													\
ITEM(PLAY,                0xFA)													\
ITEM(ZOOM,                0xFB)													\
ITEM(NONAME,              0xFC)													\
ITEM(PA1,                 0xFD)													\
ITEM(OEM_CLEAR,           0xFE)													\
/*																				\
 * Friendly names for common keys (US)											\
 */																				\
ITEM(SEMICOLON,           0xBA)		/* OEM_1 */									\
ITEM(SLASH,               0xBF)		/* OEM_2 */									\
ITEM(GRAVE_ACCENT,        0xC0)		/* OEM_3 */									\
ITEM(RIGHT_BRACKET,       0xDB)		/* OEM_4 */									\
ITEM(BACKSLASH,           0xDC)		/* OEM_5 */									\
ITEM(LEFT_BRACKET,        0xDD)		/* OEM_6 */									\
ITEM(APOSTROPHE,          0xDE)		/* OEM_7 */									\

#define GUI_DEFINE_KEYBOARD_CODE_ADDITIONAL(ITEM)								\
ITEM(OEM_1,               0xBA)		/* ';:' for US */							\
ITEM(OEM_2,               0xBF)		/* '/?' for US */							\
ITEM(OEM_3,               0xC0)		/* '`~' for US */							\
ITEM(OEM_4,               0xDB)		/* '[{' for US */							\
ITEM(OEM_5,               0xDC)		/* '\|' for US */							\
ITEM(OEM_6,               0xDD)		/* ']}' for US */							\
ITEM(OEM_7,               0xDE)		/* ''"' for US */							\
ITEM(HANJA,               0x19)													\
/*																				\
 * NEC PC-9800 kbd definitions													\
 */																				\
ITEM(OEM_NEC_EQUAL,       0x92)		/* '=' key on numpad */						\

#define GUI_DEFINE_KEYBOARD_CODE(ITEM)											\
			GUI_DEFINE_KEYBOARD_CODE_BASIC(ITEM)								\
			GUI_DEFINE_KEYBOARD_CODE_ADDITIONAL(ITEM)							\


#define GUI_DEFINE_KEYBOARD_WINDOWS_NAME(ITEM)									\
ITEM(BACK,					L"Backspace")\
ITEM(TAB,					L"Tab")\
ITEM(RETURN,				L"Enter")\
ITEM(SHIFT,					L"Shift")\
ITEM(CONTROL,				L"Ctrl")\
ITEM(MENU,					L"Alt")\
ITEM(CAPITAL,				L"Caps Lock")\
ITEM(ESCAPE,				L"Esc")\
ITEM(SPACE,					L"Space")\
ITEM(PRIOR,					L"Page Up")\
ITEM(NEXT,					L"Page Down")\
ITEM(END,					L"End")\
ITEM(HOME,					L"Home")\
ITEM(LEFT,					L"Left")\
ITEM(UP,					L"Up")\
ITEM(RIGHT,					L"Right")\
ITEM(DOWN,					L"Down")\
ITEM(SNAPSHOT,				L"Sys Req")\
ITEM(INSERT,				L"Insert")\
ITEM(DELETE,				L"Delete")\
ITEM(0,						L"0")\
ITEM(1,						L"1")\
ITEM(2,						L"2")\
ITEM(3,						L"3")\
ITEM(4,						L"4")\
ITEM(5,						L"5")\
ITEM(6,						L"6")\
ITEM(7,						L"7")\
ITEM(8,						L"8")\
ITEM(9,						L"9")\
ITEM(A,						L"A")\
ITEM(B,						L"B")\
ITEM(C,						L"C")\
ITEM(D,						L"D")\
ITEM(E,						L"E")\
ITEM(F,						L"F")\
ITEM(G,						L"G")\
ITEM(H,						L"H")\
ITEM(I,						L"I")\
ITEM(J,						L"J")\
ITEM(K,						L"K")\
ITEM(L,						L"L")\
ITEM(M,						L"M")\
ITEM(N,						L"N")\
ITEM(O,						L"O")\
ITEM(P,						L"P")\
ITEM(Q,						L"Q")\
ITEM(R,						L"R")\
ITEM(S,						L"S")\
ITEM(T,						L"T")\
ITEM(U,						L"U")\
ITEM(V,						L"V")\
ITEM(W,						L"W")\
ITEM(X,						L"X")\
ITEM(Y,						L"Y")\
ITEM(Z,						L"Z")\
ITEM(NUMPAD0,				L"Num 0")\
ITEM(NUMPAD1,				L"Num 1")\
ITEM(NUMPAD2,				L"Num 2")\
ITEM(NUMPAD3,				L"Num 3")\
ITEM(NUMPAD4,				L"Num 4")\
ITEM(NUMPAD5,				L"Num 5")\
ITEM(NUMPAD6,				L"Num 6")\
ITEM(NUMPAD7,				L"Num 7")\
ITEM(NUMPAD8,				L"Num 8")\
ITEM(NUMPAD9,				L"Num 9")\
ITEM(MULTIPLY,				L"Num *")\
ITEM(ADD,					L"Num +")\
ITEM(SUBTRACT,				L"Num -")\
ITEM(DECIMAL,				L"Num Del")\
ITEM(DIVIDE,				L"/")\
ITEM(F1,					L"F1")\
ITEM(F2,					L"F2")\
ITEM(F3,					L"F3")\
ITEM(F4,					L"F4")\
ITEM(F5,					L"F5")\
ITEM(F6,					L"F6")\
ITEM(F7,					L"F7")\
ITEM(F8,					L"F8")\
ITEM(F9,					L"F9")\
ITEM(F10,					L"F10")\
ITEM(F11,					L"F11")\
ITEM(F12,					L"F12")\
ITEM(NUMLOCK,				L"Pause")\
ITEM(SCROLL,				L"Scroll Lock")\
ITEM(BROWSER_HOME,			L"M")\
ITEM(VOLUME_MUTE,			L"D")\
ITEM(VOLUME_DOWN,			L"C")\
ITEM(VOLUME_UP,				L"B")\
ITEM(MEDIA_NEXT_TRACK,		L"P")\
ITEM(MEDIA_PREV_TRACK,		L"Q")\
ITEM(MEDIA_STOP,			L"J")\
ITEM(MEDIA_PLAY_PAUSE,		L"G")\
ITEM(LAUNCH_APP2,			L"F")\
ITEM(OEM_PLUS,				L"=")\
ITEM(OEM_COMMA,				L",")\
ITEM(OEM_MINUS,				L"-")\
ITEM(OEM_PERIOD,			L".")\
ITEM(OEM_102,				L"\\")\
ITEM(SEMICOLON,				L";")\
ITEM(SLASH,					L"/")\
ITEM(GRAVE_ACCENT,			L"`")\
ITEM(RIGHT_BRACKET,			L"[")\
ITEM(BACKSLASH,				L"\\")\
ITEM(LEFT_BRACKET,			L"]")\
ITEM(APOSTROPHE,			L"'")\

#define GUI_DEFINE_KEYBOARD_CODE_ENUM_ITEM(NAME, CODE) KEY_##NAME = CODE,
		enum class VKEY
		{
			KEY_UNKNOWN = -1,
			KEY_MAXIMUM = 255,
			GUI_DEFINE_KEYBOARD_CODE(GUI_DEFINE_KEYBOARD_CODE_ENUM_ITEM)
		};
#undef GUI_DEFINE_KEYBOARD_CODE_ENUM_ITEM
		static auto operator <=> (VKEY a, VKEY b) { return (vint)a <=> (vint)b; }
		static VKEY operator &  (VKEY a, VKEY b) { return (VKEY)((vint)a & (vint)b); }
		static VKEY operator |  (VKEY a, VKEY b) { return (VKEY)((vint)a | (vint)b); }

	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\DATASOURCE_IITEMPROVIDER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_DATASOURCE_IITEMPROVIDER
#define VCZH_PRESENTATION_CONTROLS_DATASOURCE_IITEMPROVIDER


namespace vl::presentation::controls::list
{
	class IItemProvider;

/***********************************************************************
IItemProviderCallback
***********************************************************************/

	/// <summary>Item provider callback. Item providers use this interface to notify item modification.</summary>
	class IItemProviderCallback : public virtual IDescriptable, public Description<IItemProviderCallback>
	{
	public:
		/// <summary>Called when an item provider callback object is attached to an item provider.</summary>
		/// <param name="provider">The item provider.</param>
		virtual void								OnAttached(IItemProvider* provider)=0;
		/// <summary>Called when items in the item provider is modified.</summary>
		/// <param name="start">The index of the first modified item.</param>
		/// <param name="count">The number of all modified items.</param>
		/// <param name="newCount">The number of new items. If items are inserted or removed, newCount may not equals to count.</param>
		/// <param name="itemReferenceUpdated">True when items are replaced, false when only content in items are updated.</param>
		virtual void								OnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated)=0;
	};

/***********************************************************************
IItemProviderCallback
***********************************************************************/

	/// <summary>Item provider for a <see cref="GuiListControl"/>.</summary>
	class IItemProvider : public virtual IDescriptable, public Description<IItemProvider>
	{
	public:
		/// <summary>Attach an item provider callback to this item provider.</summary>
		/// <returns>Returns true if this operation succeeded.</returns>
		/// <param name="value">The item provider callback.</param>
		virtual bool								AttachCallback(IItemProviderCallback* value) = 0;
		/// <summary>Detach an item provider callback from this item provider.</summary>
		/// <returns>Returns true if this operation succeeded.</returns>
		/// <param name="value">The item provider callback.</param>
		virtual bool								DetachCallback(IItemProviderCallback* value) = 0;
		/// <summary>Increase the editing counter indicating that an [T:vl.presentation.templates.GuiListItemTemplate] is editing an item.</summary>
		virtual void								PushEditing() = 0;
		/// <summary>Decrease the editing counter indicating that an [T:vl.presentation.templates.GuiListItemTemplate] has stopped editing an item.</summary>
		/// <returns>Returns false if there is no supression before calling this function.</returns>
		virtual bool								PopEditing() = 0;
		/// <summary>Test if an [T:vl.presentation.templates.GuiListItemTemplate] is editing an item.</summary>
		/// <returns>Returns false if there is no editing.</returns>
		virtual bool								IsEditing() = 0;
		/// <summary>Get the number of items in this item proivder.</summary>
		/// <returns>The number of items in this item proivder.</returns>
		virtual vint								Count() = 0;

		/// <summary>Get the text representation of an item.</summary>
		/// <returns>The text representation of an item.</returns>
		/// <param name="itemIndex">The index of the item.</param>
		virtual WString								GetTextValue(vint itemIndex) = 0;
		/// <summary>Get the binding value of an item.</summary>
		/// <returns>The binding value of an item.</returns>
		/// <param name="itemIndex">The index of the item.</param>
		virtual description::Value					GetBindingValue(vint itemIndex) = 0;

		/// <summary>Request a view for this item provider. If the specified view is not supported, it returns null. If you want to get a view of type IXXX, use IXXX::Identifier as the identifier.</summary>
		/// <returns>The view object.</returns>
		/// <param name="identifier">The identifier for the requested view.</param>
		virtual IDescriptable*						RequestView(const WString& identifier) = 0;
	};
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\DATASOURCEIMPL_IITEMPROVIDER_ITEMPROVIDERBASE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_DATASOURCEIMPL_IITEMPROVIDER_ITEMPROVIDERBASE
#define VCZH_PRESENTATION_CONTROLS_DATASOURCEIMPL_IITEMPROVIDER_ITEMPROVIDERBASE


namespace vl::presentation::controls::list
{
/***********************************************************************
ItemProviderBase
***********************************************************************/

	/// <summary>Item provider base. This class provider common functionalities for item providers.</summary>
	class ItemProviderBase : public Object, public virtual IItemProvider, public Description<ItemProviderBase>
	{
	protected:
		collections::List<IItemProviderCallback*>	callbacks;
		vint										editingCounter = 0;
		bool										callingOnItemModified = false;

		virtual void								InvokeOnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated);
	public:
		/// <summary>Create the item provider.</summary>
		ItemProviderBase();
		~ItemProviderBase();

		bool										AttachCallback(IItemProviderCallback* value)override;
		bool										DetachCallback(IItemProviderCallback* value)override;
		void										PushEditing()override;
		bool										PopEditing()override;
		bool										IsEditing()override;
	};

/***********************************************************************
ListProvider<T>
***********************************************************************/

	template<typename T>
	class ListProvider : public ItemProviderBase, public collections::ObservableListBase<T>
	{
	protected:
		void NotifyUpdateInternal(vint start, vint count, vint newCount)override
		{
			InvokeOnItemModified(start, count, newCount, true);
		}
	public:
		vint Count()override
		{
			return this->items.Count();
		}
	};
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\DATASOURCE_INODEPROVIDER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_DATASOURCE_INODEPROVIDER
#define VCZH_PRESENTATION_CONTROLS_DATASOURCE_INODEPROVIDER


namespace vl::presentation::controls::tree
{
	class INodeProvider;
	class INodeRootProvider;

/***********************************************************************
INodeProviderCallback
***********************************************************************/

	/// <summary>Callback object for <see cref="INodeProvider"/>. A node will invoke this callback to notify any content modification.</summary>
	class INodeProviderCallback : public virtual IDescriptable, public Description<INodeProviderCallback>
	{
	public:
		/// <summary>Called when this callback is attached to a node root.</summary>
		/// <param name="provider">The root node.</param>
		virtual void					OnAttached(INodeRootProvider* provider)=0;
		/// <summary>Called before sub items of a node are modified.</summary>
		/// <param name="parentNode">The node containing modified sub items.</param>
		/// <param name="start">The index of the first sub item.</param>
		/// <param name="count">The number of sub items to be modified.</param>
		/// <param name="newCount">The new number of modified sub items.</param>
		/// <param name="itemReferenceUpdated">True when items are replaced, false when only content in items are updated.</param>
		virtual void					OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)=0;
		/// <summary>Called after sub items of a node are modified.</summary>
		/// <param name="parentNode">The node containing modified sub items.</param>
		/// <param name="start">The index of the first sub item.</param>
		/// <param name="count">The number of sub items to be modified.</param>
		/// <param name="newCount">The new number of modified sub items.</param>
		/// <param name="itemReferenceUpdated">True when items are replaced, false when only content in items are updated.</param>
		virtual void					OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)=0;
		/// <summary>Called when a node is expanded.</summary>
		/// <param name="node">The node.</param>
		virtual void					OnItemExpanded(INodeProvider* node)=0;
		/// <summary>Called when a node is collapsed.</summary>
		/// <param name="node">The node.</param>
		virtual void					OnItemCollapsed(INodeProvider* node)=0;
	};

/***********************************************************************
INodeProvider
***********************************************************************/

	/// <summary>Represents a node.</summary>
	class INodeProvider : public virtual IDescriptable, public Description<INodeProvider>
	{
	public:
		/// <summary>Get the expanding state of this node.</summary>
		/// <returns>Returns true if this node is expanded.</returns>
		virtual bool					GetExpanding()=0;
		/// <summary>Set the expanding state of this node.</summary>
		/// <param name="value">Set to true to expand this node.</param>
		virtual void					SetExpanding(bool value)=0;
		/// <summary>Calculate the number of total visible nodes of this node. The number of total visible nodes includes the node itself, and all total visible nodes of all visible sub nodes. If this node is collapsed, this number will be 1.</summary>
		/// <returns>The number of total visible nodes.</returns>
		virtual vint					CalculateTotalVisibleNodes()=0;
		/// <summary>Notify that the state in the binded data object is modified.</summary>
		virtual void					NotifyDataModified()=0;

		/// <summary>Get the number of all sub nodes.</summary>
		/// <returns>The number of all sub nodes.</returns>
		virtual vint					GetChildCount()=0;
		/// <summary>Get the parent node.</summary>
		/// <returns>The parent node.</returns>
		virtual Ptr<INodeProvider>		GetParent()=0;
		/// <summary>Get the instance of a specified sub node.</summary>
		/// <returns>The instance of a specified sub node.</returns>
		/// <param name="index">The index of the sub node.</param>
		virtual Ptr<INodeProvider>		GetChild(vint index)=0;
	};

/***********************************************************************
INodeRootProvider
***********************************************************************/
				
	/// <summary>Represents a root node provider.</summary>
	class INodeRootProvider : public virtual IDescriptable, public Description<INodeRootProvider>
	{
	public:
		/// <summary>Get the instance of the root node.</summary>
		/// <returns>Returns the instance of the root node.</returns>
		virtual Ptr<INodeProvider>		GetRootNode()=0;
		/// <summary>Test does the provider provided an optimized algorithm to get an instance of a node by the index of all visible nodes. If this function returns true, [M:vl.presentation.controls.tree.INodeRootProvider.GetNodeByVisibleIndex] can be used.</summary>
		/// <returns>Returns true if such an algorithm is provided.</returns>
		virtual bool					CanGetNodeByVisibleIndex()=0;
		/// <summary>Get a node by the index in all visible nodes. This requires [M:vl.presentation.controls.tree.INodeRootProvider.CanGetNodeByVisibleIndex] returning true.</summary>
		/// <returns>The node for the index in all visible nodes.</returns>
		/// <param name="index">The index in all visible nodes.</param>
		virtual Ptr<INodeProvider>		GetNodeByVisibleIndex(vint index)=0;
		/// <summary>Attach an node provider callback to this node provider.</summary>
		/// <returns>Returns true if this operation succeeded.</returns>
		/// <param name="value">The node provider callback.</param>
		virtual bool					AttachCallback(INodeProviderCallback* value)=0;
		/// <summary>Detach an node provider callback from this node provider.</summary>
		/// <returns>Returns true if this operation succeeded.</returns>
		/// <param name="value">The node provider callback.</param>
		virtual bool					DetachCallback(INodeProviderCallback* value)=0;
		/// <summary>Get the primary text of a node.</summary>
		/// <returns>The primary text of a node.</returns>
		/// <param name="node">The node.</param>
		virtual WString					GetTextValue(INodeProvider* node) = 0;
		/// <summary>Get the binding value of a node.</summary>
		/// <returns>The binding value of a node.</returns>
		/// <param name="node">The node.</param>
		virtual description::Value		GetBindingValue(INodeProvider* node) = 0;
		/// <summary>Request a view for this node provider. If the specified view is not supported, it returns null. If you want to get a view of type IXXX, use IXXX::Identifier as the identifier.</summary>
		/// <returns>The view object.</returns>
		/// <param name="identifier">The identifier for the requested view.</param>
		virtual IDescriptable*			RequestView(const WString& identifier)=0;
	};
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\DATASOURCEIMPL_IITEMPROVIDER_NODEITEMPROVIDER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_DATASOURCEIMPL_IITEMPROVIDER_NODEITEMPROVIDER
#define VCZH_PRESENTATION_CONTROLS_DATASOURCEIMPL_IITEMPROVIDER_NODEITEMPROVIDER


namespace vl::presentation::controls::tree
{
/***********************************************************************
INodeItemView
***********************************************************************/

	/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for [T:vl.presentation.controls.tree.GuiVirtualTreeView]. [T:vl.presentation.controls.tree.NodeItemProvider] provides this view. In most of the cases, the NodeItemProvider class and this view is not required users to create, or even to touch. [T:vl.presentation.controls.GuiVirtualTreeListControl] already handled all of this.</summary>
	class INodeItemView : public virtual IDescriptable, public Description<INodeItemView>
	{
	public:
		/// <summary>The identifier of this view.</summary>
		static const wchar_t* const		Identifier;

		/// <summary>Get an instance of a node by the index in all visible nodes.</summary>
		/// <returns>The instance of a node by the index in all visible nodes.</returns>
		/// <param name="index">The index in all visible nodes.</param>
		virtual Ptr<INodeProvider>		RequestNode(vint index)=0;
		/// <summary>Get the index in all visible nodes of a node.</summary>
		/// <returns>The index in all visible nodes of a node.</returns>
		/// <param name="node">The node to calculate the index.</param>
		virtual vint					CalculateNodeVisibilityIndex(INodeProvider* node)=0;
	};

/***********************************************************************
NodeItemProvider
***********************************************************************/

	/// <summary>This is a general implementation to convert an <see cref="INodeRootProvider"/> to a <see cref="GuiListControl::IItemProvider"/>.</summary>
	class NodeItemProvider
		: public list::ItemProviderBase
		, protected virtual INodeProviderCallback
		, public virtual INodeItemView
		, public Description<NodeItemProvider>
	{
		typedef collections::Dictionary<INodeProvider*, vint>			NodeIntMap;
	protected:
		Ptr<INodeRootProvider>			root;
		NodeIntMap						offsetBeforeChildModifieds;

		Ptr<INodeProvider>				GetNodeByOffset(Ptr<INodeProvider> provider, vint offset);
		void							OnAttached(INodeRootProvider* provider)override;
		void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
		void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
		void							OnItemExpanded(INodeProvider* node)override;
		void							OnItemCollapsed(INodeProvider* node)override;
		vint							CalculateNodeVisibilityIndexInternal(INodeProvider* node);
		vint							CalculateNodeVisibilityIndex(INodeProvider* node)override;
		
		Ptr<INodeProvider>				RequestNode(vint index)override;
	public:
		/// <summary>Create an item provider using a node root provider.</summary>
		/// <param name="_root">The node root provider.</param>
		NodeItemProvider(Ptr<INodeRootProvider> _root);
		~NodeItemProvider();
		
		/// <summary>Get the owned node root provider.</summary>
		/// <returns>The node root provider.</returns>
		Ptr<INodeRootProvider>			GetRoot();
		vint							Count()override;
		WString							GetTextValue(vint itemIndex)override;
		description::Value				GetBindingValue(vint itemIndex)override;
		IDescriptable*					RequestView(const WString& identifier)override;
	};
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\DATASOURCEIMPL_INODEPROVIDER_MEMORYNODEPROVIDER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_DATASOURCEIMPL_INODEPROVIDER_MEMORYNODEPROVIDER
#define VCZH_PRESENTATION_CONTROLS_DATASOURCEIMPL_INODEPROVIDER_MEMORYNODEPROVIDER


namespace vl::presentation::controls::tree
{
/***********************************************************************
MemoryNodeProvider
***********************************************************************/

	/// <summary>An in-memory <see cref="INodeProvider"/> implementation.</summary>
	class MemoryNodeProvider
		: public Object
		, public virtual INodeProvider
		, public Description<MemoryNodeProvider>
	{
		typedef collections::List<Ptr<MemoryNodeProvider>> ChildList;
		typedef collections::IEnumerator<Ptr<MemoryNodeProvider>> ChildListEnumerator;

	public:
		class NodeCollection : public collections::ObservableListBase<Ptr<MemoryNodeProvider>>
		{
			friend class MemoryNodeProvider;
		protected:
			vint						offsetBeforeChildModified = 0;
			MemoryNodeProvider*			ownerProvider;

			void						OnBeforeChildModified(vint start, vint count, vint newCount);
			void						OnAfterChildModified(vint start, vint count, vint newCount);
			bool						QueryInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
			bool						QueryRemove(vint index, Ptr<MemoryNodeProvider> const& child)override;
			void						BeforeInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
			void						BeforeRemove(vint index, Ptr<MemoryNodeProvider> const& child)override;
			void						AfterInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
			void						AfterRemove(vint index, vint count)override;

			NodeCollection();
		public:
		};

	protected:
		MemoryNodeProvider*				parent = nullptr;
		bool							expanding = false;
		vint							childCount = 0;
		vint							totalVisibleNodeCount = 1;
		Ptr<DescriptableObject>			data;
		NodeCollection					children;

		virtual INodeProviderCallback*	GetCallbackProxyInternal();
		void							OnChildTotalVisibleNodesChanged(vint offset);
	public:
		/// <summary>Create a node provider with a data object.</summary>
		/// <param name="_data">The data object.</param>
		MemoryNodeProvider(Ptr<DescriptableObject> _data = nullptr);
		~MemoryNodeProvider();

		/// <summary>Get the data object.</summary>
		/// <returns>The data object.</returns>
		Ptr<DescriptableObject>			GetData();
		/// <summary>Set the data object.</summary>
		/// <param name="value">The data object.</param>
		void							SetData(const Ptr<DescriptableObject>& value);
		/// <summary>Get all sub nodes.</summary>
		/// <returns>All sub nodes.</returns>
		NodeCollection&					Children();

		bool							GetExpanding()override;
		void							SetExpanding(bool value)override;
		vint							CalculateTotalVisibleNodes()override;
		void							NotifyDataModified()override;

		vint							GetChildCount()override;
		Ptr<INodeProvider>				GetParent()override;
		Ptr<INodeProvider>				GetChild(vint index)override;
	};

/***********************************************************************
NodeRootProviderBase
***********************************************************************/

	/// <summary>A general implementation for <see cref="INodeRootProvider"/>.</summary>
	class NodeRootProviderBase : public virtual INodeRootProvider, protected virtual INodeProviderCallback, public Description<NodeRootProviderBase>
	{
		collections::List<INodeProviderCallback*>			callbacks;
	protected:
		void							OnAttached(INodeRootProvider* provider)override;
		void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
		void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
		void							OnItemExpanded(INodeProvider* node)override;
		void							OnItemCollapsed(INodeProvider* node)override;
	public:
		/// <summary>Create a node root provider.</summary>
		NodeRootProviderBase();
		~NodeRootProviderBase();
		
		bool							CanGetNodeByVisibleIndex()override;
		Ptr<INodeProvider>				GetNodeByVisibleIndex(vint index)override;
		bool							AttachCallback(INodeProviderCallback* value)override;
		bool							DetachCallback(INodeProviderCallback* value)override;
		IDescriptable*					RequestView(const WString& identifier)override;
	};

/***********************************************************************
MemoryNodeRootProvider
***********************************************************************/
				
	/// <summary>An in-memory <see cref="INodeRootProvider"/> implementation.</summary>
	class MemoryNodeRootProvider
		: public MemoryNodeProvider
		, public NodeRootProviderBase
		, public Description<MemoryNodeRootProvider>
	{
	protected:
		INodeProviderCallback*			GetCallbackProxyInternal()override;
	public:
		/// <summary>Create a node root provider.</summary>
		MemoryNodeRootProvider();
		~MemoryNodeRootProvider();

		Ptr<INodeProvider>				GetRootNode()override;
		/// <summary>Get the <see cref="MemoryNodeProvider"/> object from an <see cref="INodeProvider"/> object.</summary>
		/// <returns>The corresponding <see cref="MemoryNodeProvider"/> object.</returns>
		/// <param name="node">The node to get the memory node.</param>
		MemoryNodeProvider*				GetMemoryNode(INodeProvider* node);
	};
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSAXIS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSAXIS
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSAXIS


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Axis Interface
***********************************************************************/

			/// <summary>Represents the four directions that is accessable by keyboard.</summary>
			enum class KeyDirection
			{
				/// <summary>The up direction.</summary>
				Up,
				/// <summary>The down direction.</summary>
				Down,
				/// <summary>The left direction.</summary>
				Left,
				/// <summary>The right direction.</summary>
				Right,
				/// <summary>The home direction.</summary>
				Home,
				/// <summary>The end direction.</summary>
				End,
				/// <summary>The page up direction.</summary>
				PageUp,
				/// <summary>The page down direction.</summary>
				PageDown,
				/// <summary>The page left direction.</summary>
				PageLeft,
				/// <summary>The page right direction.</summary>
				PageRight,
			};
				
			/// <summary>Item coordinate transformer for a <see cref="GuiListControl"/>. In all functions in this interface, real coordinate is in the list control's container space, virtual coordinate is in a space that the transformer created.</summary>
			class IGuiAxis : public virtual IDescriptable, public Description<IGuiAxis>
			{
			public:
				/// <summary>Translate real size to virtual size.</summary>
				/// <returns>The virtual size.</returns>
				/// <param name="size">The real size.</param>
				virtual Size								RealSizeToVirtualSize(Size size)=0;
				/// <summary>Translate virtual size to real size.</summary>
				/// <returns>The real size.</returns>
				/// <param name="size">The virtual size.</param>
				virtual Size								VirtualSizeToRealSize(Size size)=0;
				/// <summary>Translate real point to virtual point.</summary>
				/// <returns>The virtual point.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="point">The real point.</param>
				virtual Point								RealPointToVirtualPoint(Size realFullSize, Point point)=0;
				/// <summary>Translate virtual point to real point.</summary>
				/// <returns>The real point.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="point">The virtual point.</param>
				virtual Point								VirtualPointToRealPoint(Size realFullSize, Point point)=0;
				/// <summary>Translate real bounds to virtual bounds.</summary>
				/// <returns>The virtual bounds.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="rect">The real bounds.</param>
				virtual Rect								RealRectToVirtualRect(Size realFullSize, Rect rect)=0;
				/// <summary>Translate virtual bounds to real bounds.</summary>
				/// <returns>The real bounds.</returns>
				/// <param name="realFullSize">The real full size.</param>
				/// <param name="rect">The virtual bounds.</param>
				virtual Rect								VirtualRectToRealRect(Size realFullSize, Rect rect)=0;
				/// <summary>Translate real margin to margin size.</summary>
				/// <returns>The virtual margin.</returns>
				/// <param name="margin">The real margin.</param>
				virtual Margin								RealMarginToVirtualMargin(Margin margin)=0;
				/// <summary>Translate virtual margin to margin size.</summary>
				/// <returns>The real margin.</returns>
				/// <param name="margin">The virtual margin.</param>
				virtual Margin								VirtualMarginToRealMargin(Margin margin)=0;
				/// <summary>Translate real key direction to virtual key direction.</summary>
				/// <returns>The virtual key direction.</returns>
				/// <param name="key">The real key direction.</param>
				virtual KeyDirection						RealKeyDirectionToVirtualKeyDirection(KeyDirection key)=0;
			};

/***********************************************************************
Axis Implementation
***********************************************************************/

			/// <summary>Default item coordinate transformer. This transformer doesn't transform any coordinate.</summary>
			class GuiDefaultAxis : public Object, virtual public IGuiAxis, public Description<GuiDefaultAxis>
			{
			public:
				/// <summary>Create the transformer.</summary>
				GuiDefaultAxis();
				~GuiDefaultAxis();

				Size										RealSizeToVirtualSize(Size size)override;
				Size										VirtualSizeToRealSize(Size size)override;
				Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
				Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
				Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
				Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
				Margin										RealMarginToVirtualMargin(Margin margin)override;
				Margin										VirtualMarginToRealMargin(Margin margin)override;
				KeyDirection								RealKeyDirectionToVirtualKeyDirection(KeyDirection key)override;
			};
				
			/// <summary>Axis aligned item coordinate transformer. This transformer transforms coordinates by changing the axis direction.</summary>
			class GuiAxis : public Object, virtual public IGuiAxis, public Description<GuiAxis>
			{
			protected:
				AxisDirection								axisDirection;

			public:
				/// <summary>Create the transformer with a specified axis direction.</summary>
				/// <param name="_axisDirection">The specified axis direction.</param>
				GuiAxis(AxisDirection _axisDirection);
				~GuiAxis();

				/// <summary>Get the specified axis direction.</summary>
				/// <returns>The specified axis direction.</returns>
				AxisDirection								GetDirection();
				Size										RealSizeToVirtualSize(Size size)override;
				Size										VirtualSizeToRealSize(Size size)override;
				Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
				Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
				Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
				Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
				Margin										RealMarginToVirtualMargin(Margin margin)override;
				Margin										VirtualMarginToRealMargin(Margin margin)override;
				KeyDirection								RealKeyDirectionToVirtualKeyDirection(KeyDirection key)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSELEMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsComposition;
		}

		namespace elements
		{
			class IGuiGraphicsElement;
			class IGuiGraphicsRenderer;
			class IGuiGraphicsRendererFactory;
			class IGuiGraphicsRenderTarget;

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// This is the interface for graphics elements.
			/// Graphics elements usually contains some information and helper functions for visible things.
			/// An graphics elements should be created using ElementType::Create.
			/// </summary>
			class IGuiGraphicsElement : public virtual IDescriptable, public Description<IGuiGraphicsElement>
			{
				friend class compositions::GuiGraphicsComposition;
			protected:

				virtual void									SetOwnerComposition(compositions::GuiGraphicsComposition* composition) = 0;
			public:
				/// <summary>
				/// Access the associated <see cref="IGuiGraphicsRenderer"/> for this graphics element.
				/// </summary>
				/// <returns>Returns the related renderer.</returns>
				virtual IGuiGraphicsRenderer*					GetRenderer() = 0;
				/// <summary>
				/// Get the owner composition.
				/// </summary>
				/// <returns>The owner composition.</returns>
				virtual compositions::GuiGraphicsComposition*	GetOwnerComposition() = 0;
			};

			/// <summary>
			/// This is the interface for graphics renderers.
			/// </summary>
			class IGuiGraphicsRenderer : public Interface
			{
			public:
				/// <summary>
				/// Access the graphics <see cref="IGuiGraphicsRendererFactory"/> that is used to create this graphics renderer.
				/// </summary>
				/// <returns>Returns the related factory.</returns>
				virtual IGuiGraphicsRendererFactory*	GetFactory()=0;

				/// <summary>
				/// Initialize the grpahics renderer by binding a <see cref="IGuiGraphicsElement"/> to it.
				/// </summary>
				/// <param name="element">The graphics element to bind.</param>
				virtual void							Initialize(IGuiGraphicsElement* element)=0;
				/// <summary>
				/// Release all resources that used by this renderer.
				/// </summary>
				virtual void							Finalize()=0;
				/// <summary>
				/// Set a <see cref="IGuiGraphicsRenderTarget"/> to this element.
				/// </summary>
				/// <param name="renderTarget">The graphics render target. It can be NULL.</param>
				virtual void							SetRenderTarget(IGuiGraphicsRenderTarget* renderTarget)=0;
				/// <summary>
				/// Render the graphics element using a specified bounds.
				/// </summary>
				/// <param name="bounds">Bounds to decide the size and position of the binded graphics element.</param>
				virtual void							Render(Rect bounds)=0;
				/// <summary>
				/// Notify that the state in the binded graphics element is changed. This function is usually called by the element itself.
				/// </summary>
				virtual void							OnElementStateChanged()=0;
				/// <summary>
				/// Calculate the minimum size using the binded graphics element and its state.
				/// </summary>
				/// <returns>The minimum size.</returns>
				virtual Size							GetMinSize()=0;
			};

			/// <summary>
			/// This is the interface for graphics renderer factories.
			/// Graphics renderers should be registered using [M:vl.presentation.elements.GuiGraphicsResourceManager.RegisterRendererFactory]. 
			/// </summary>
			class IGuiGraphicsRendererFactory : public Interface
			{
			public:
				/// <summary>
				/// Create a <see cref="IGuiGraphicsRenderer"/>.
				/// </summary>
				/// <returns>Returns the created graphics renderer.</returns>
				virtual IGuiGraphicsRenderer*			Create()=0;
			};

			enum RenderTargetFailure
			{
				None,
				ResizeWhileRendering,
				LostDevice,
			};

			/// <summary>
			/// This is the interface for graphics renderer targets.
			/// </summary>
			class IGuiGraphicsRenderTarget : public Interface
			{
			public:
				/// <summary>
				/// Test if the target is doing hosted rendering.
				/// </summary>
				/// <returns>Returns true if the target is doing hosted rendering.</returns>
				virtual bool							IsInHostedRendering() = 0;
				/// <summary>
				/// Notify the target to start hosted rendering, <see cref="StartRendering()"/> and <see cref="StopRendering"/> will be called multiple times.
				/// </summary>
				virtual void							StartHostedRendering() = 0;
				/// <summary>
				/// Notify the target to stop hosted rendering
				/// </summary>
				/// <returns>Returns values other "None" to indicate device failure.</returns>
				virtual RenderTargetFailure				StopHostedRendering() = 0;

				/// <summary>
				/// Notify the target to prepare for rendering.
				/// </summary>
				virtual void							StartRendering() = 0;
				/// <summary>
				/// Notify the target to stop rendering.
				/// </summary>
				/// <returns>Returns values other "None" to indicate device failure.</returns>
				virtual RenderTargetFailure				StopRendering() = 0;

				/// <summary>
				/// Apply a clipper to the render target.
				/// The result clipper is combined by all clippers in the clipper stack maintained by the render target.
				/// </summary>
				/// <param name="clipper">The clipper to push.</param>
				/// <param name="generator">The object that generates this clipper. It could be null.</param>
				virtual void							PushClipper(Rect clipper, reflection::DescriptableObject* generator) = 0;
				/// <summary>
				/// Remove the last pushed clipper from the clipper stack.
				/// </summary>
				/// <param name="generator">The object that generates this clipper. It could be null.</param>
				virtual void							PopClipper(reflection::DescriptableObject* generator) = 0;
				/// <summary>
				/// Get the combined clipper
				/// </summary>
				/// <returns>The combined clipper</returns>
				virtual Rect							GetClipper() = 0;
				/// <summary>
				/// Test is the combined clipper is as large as the render target.
				/// </summary>
				/// <returns>Return true if the combined clipper is as large as the render target.</returns>
				virtual bool							IsClipperCoverWholeTarget() = 0;
			};

			/// <summary>
			/// This is a default implementation for <see cref="IGuiGraphicsRenderTarget"/>
			/// </summary>
			class GuiGraphicsRenderTarget : public Object, public IGuiGraphicsRenderTarget
			{
			protected:
				collections::List<Rect>					clippers;
				vint									clipperCoverWholeTargetCounter = 0;
				bool									hostedRendering = false;
				bool									rendering = false;

				virtual void							StartRenderingOnNativeWindow() = 0;
				virtual RenderTargetFailure				StopRenderingOnNativeWindow() = 0;

				virtual Size							GetCanvasSize() = 0;
				virtual void							AfterPushedClipper(Rect clipper, Rect validArea, reflection::DescriptableObject* generator) = 0;
				virtual void							AfterPushedClipperAndBecameInvalid(Rect clipper, reflection::DescriptableObject* generator) = 0;
				virtual void							AfterPoppedClipperAndBecameValid(Rect validArea, bool clipperExists, reflection::DescriptableObject* generator) = 0;
				virtual void							AfterPoppedClipper(Rect validArea, bool clipperExists, reflection::DescriptableObject* generator) = 0;
			public:

				bool									IsInHostedRendering() override;
				void									StartHostedRendering() override;
				RenderTargetFailure						StopHostedRendering() override;
				void									StartRendering() override;
				RenderTargetFailure						StopRendering() override;

				void									PushClipper(Rect clipper, reflection::DescriptableObject* generator) override;
				void									PopClipper(reflection::DescriptableObject* generator) override;
				Rect									GetClipper() override;
				bool									IsClipperCoverWholeTarget() override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSDOCUMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Layout Engine
***********************************************************************/

			class IGuiGraphicsParagraph;
			class IGuiGraphicsLayoutProvider;

			/// <summary>Represents a paragraph of a layouted rich text content.</summary>
			class IGuiGraphicsParagraph : public IDescriptable, public Description<IGuiGraphicsParagraph>
			{
			public:
				static const vint		NullInteractionId = -1;

				/// <summary>Text style. Items in this enumeration type can be combined.</summary>
				enum TextStyle
				{
					/// <summary>Bold.</summary>
					Bold=1,
					/// <summary>Italic.</summary>
					Italic=2,
					/// <summary>Underline.</summary>
					Underline=4,
					/// <summary>Strikeline.</summary>
					Strikeline=8,
				};

				/// <summary>Inline object break condition.</summary>
				enum BreakCondition
				{
					/// <summary>Stay together with the previous run if possible.</summary>
					StickToPreviousRun,
					/// <summary>Stay together with the next run if possible.</summary>
					StickToNextRun,
					/// <summary>Treat as a single run.</summary>
					Alone,
				};

				/// <summary>Caret relative position.</summary>
				enum CaretRelativePosition
				{
					/// <summary>The first caret position.</summary>
					CaretFirst,
					/// <summary>The last caret position.</summary>
					CaretLast,
					/// <summary>The first caret position of the current line.</summary>
					CaretLineFirst,
					/// <summary>The last caret position of the current line.</summary>
					CaretLineLast,
					/// <summary>The relative left caret position.</summary>
					CaretMoveLeft,
					/// <summary>The relative right caret position.</summary>
					CaretMoveRight,
					/// <summary>The relative up caret position.</summary>
					CaretMoveUp,
					/// <summary>The relative down caret position.</summary>
					CaretMoveDown,
				};

				/// <summary>Inline object properties.</summary>
				struct InlineObjectProperties
				{
					/// <summary>The size of the inline object.</summary>
					Size						size;
					/// <summary>The baseline of the inline object.If the baseline is at the bottom, then set the baseline to -1.</summary>
					vint						baseline = -1;
					/// <summary>The break condition of the inline object.</summary>
					BreakCondition				breakCondition;
					/// <summary>The background image, nullable.</summary>
					Ptr<IGuiGraphicsElement>	backgroundImage;
					/// <summary>The id for callback. If the value is -1, then no callback will be received .</summary>
					vint						callbackId = -1;

					InlineObjectProperties()
						:baseline(-1)
					{
					}
				};

				/// <summary>Get the <see cref="IGuiGraphicsLayoutProvider"/> object that created this paragraph.</summary>
				/// <returns>The layout provider object.</returns>
				virtual IGuiGraphicsLayoutProvider*			GetProvider()=0;
				/// <summary>Get the associated <see cref="IGuiGraphicsRenderTarget"/> to this paragraph.</summary>
				/// <returns>The associated render target.</returns>
				virtual IGuiGraphicsRenderTarget*			GetRenderTarget()=0;
				/// <summary>Get if line auto-wrapping is enabled for this paragraph.</summary>
				/// <returns>Return true if line auto-wrapping is enabled for this paragraph.</returns>
				virtual bool								GetWrapLine()=0;
				/// <summary>Set if line auto-wrapping is enabled for this paragraph.</summary>
				/// <param name="value">True if line auto-wrapping is enabled for this paragraph.</param>
				virtual void								SetWrapLine(bool value)=0;
				/// <summary>Get the max width for this paragraph. If there is no max width limitation, it returns -1.</summary>
				/// <returns>The max width for this paragraph.</returns>
				virtual vint								GetMaxWidth()=0;
				/// <summary>Set the max width for this paragraph. If the max width is set to -1, the max width limitation will be removed.</summary>
				/// <param name="value">The max width.</param>
				virtual void								SetMaxWidth(vint value)=0;
				/// <summary>Get the horizontal alignment for this paragraph.</summary>
				/// <returns>The alignment.</returns>
				virtual Alignment							GetParagraphAlignment()=0;
				/// <summary>Set the horizontal alignment for this paragraph.</summary>
				/// <param name="value">The alignment.</param>
				virtual void								SetParagraphAlignment(Alignment value)=0;

				/// <summary>Replace the font within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The font.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetFont(vint start, vint length, const WString& value)=0;
				/// <summary>Replace the size within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The size.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetSize(vint start, vint length, vint value)=0;
				/// <summary>Replace the text style within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The text style.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetStyle(vint start, vint length, TextStyle value)=0;
				/// <summary>Replace the color within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The color.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetColor(vint start, vint length, Color value)=0;
				/// <summary>Replace the background color within the specified range.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="value">The background color.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetBackgroundColor(vint start, vint length, Color value)=0;
				/// <summary>Bind an <see cref="IGuiGraphicsElement"/> to a range of text.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <param name="properties">The properties for the inline object.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								SetInlineObject(vint start, vint length, const InlineObjectProperties& properties)=0;
				/// <summary>Unbind all inline objects to a range of text.</summary>
				/// <param name="start">The position of the first character of the specified range.</param>
				/// <param name="length">The length of the specified range by character.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								ResetInlineObject(vint start, vint length)=0;

				/// <summary>Get the layouted height of the text. The result depends on rich styled text and the two important properties that can be set using <see cref="SetWrapLine"/> and <see cref="SetMaxWidth"/>.</summary>
				/// <returns>The layouted height.</returns>
				virtual vint								GetHeight()=0;
				/// <summary>Make the caret visible so that it will be rendered in the paragraph.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="color">The color of the caret.</param>
				/// <param name="frontSide">Set to true to display the caret for the character before it.</param>
				virtual bool								OpenCaret(vint caret, Color color, bool frontSide)=0;
				/// <summary>Make the caret invisible.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool								CloseCaret()=0;
				/// <summary>Render the graphics element using a specified bounds.</summary>
				/// <param name="bounds">Bounds to decide the size and position of the binded graphics element.</param>
				virtual void								Render(Rect bounds)=0;

				/// <summary>Get a new caret from the old caret with a relative position.</summary>
				/// <returns>The new caret. Returns -1 if failed.</returns>
				/// <param name="comparingCaret">The caret to compare. If the position is CaretFirst or CaretLast, this argument is ignored.</param>
				/// <param name="position">The relative position.</param>
				/// <param name="preferFrontSide">Only for CaretMoveUp and CaretMoveDown. Set to true to make the caret prefer to get closer to the character before it. After this function is called, this argument stored the suggested side for displaying the new caret.</param>
				virtual vint								GetCaret(vint comparingCaret, CaretRelativePosition position, bool& preferFrontSide)=0;
				/// <summary>Get the bounds of the caret.</summary>
				/// <returns>The bounds whose width is 0. Returns an empty Rect value if failed.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="frontSide">Set to true to get the bounds of the front side, otherwise the back side. If only one side is valid, this argument is ignored.</param>
				virtual Rect								GetCaretBounds(vint caret, bool frontSide)=0;
				/// <summary>Get the caret from a specified position.</summary>
				/// <returns>The caret. Returns -1 if failed.</returns>
				/// <param name="point">The point.</param>
				virtual vint								GetCaretFromPoint(Point point)=0;
				/// <summary>Get the inline object from a specified position.</summary>
				/// <returns>The inline object. Returns null if failed.</returns>
				/// <param name="point">The point.</param>
				/// <param name="start">Get the start position of this element.</param>
				/// <param name="length">Get the length of this element.</param>
				virtual Nullable<InlineObjectProperties>	GetInlineObjectFromPoint(Point point, vint& start, vint& length)=0;
				/// <summary>Get the nearest caret from a text position.</summary>
				/// <returns>The caret. Returns -1 if failed. If the text position is a caret, then the result will be the text position itself without considering the frontSide argument.</returns>
				/// <param name="textPos">The caret to compare. If the position is CaretFirst or CaretLast, this argument is ignored.</param>
				/// <param name="frontSide">Set to true to search in front of the text position, otherwise the opposite position.</param>
				virtual vint								GetNearestCaretFromTextPos(vint textPos, bool frontSide)=0;
				/// <summary>Test is the caret valid.</summary>
				/// <returns>Returns true if the caret is valid.</returns>
				/// <param name="caret">The caret to test.</param>
				virtual bool								IsValidCaret(vint caret)=0;
				/// <summary>Test is the text position valid.</summary>
				/// <returns>Returns true if the text position is valid.</returns>
				/// <param name="textPos">The text position to test.</param>
				virtual bool								IsValidTextPos(vint textPos)=0;
			};

			/// <summary>Paragraph callback</summary>
			class IGuiGraphicsParagraphCallback : public IDescriptable, public Description<IGuiGraphicsParagraphCallback>
			{
			public:
				/// <summary>Called when an inline object with a valid callback id is being rendered.</summary>
				/// <returns>Returns the new size of the rendered inline object.</returns>
				/// <param name="callbackId">The callback id of the inline object</param>
				/// <param name="location">The location of the inline object, relative to the left-top corner of this paragraph.</param>
				virtual Size								OnRenderInlineObject(vint callbackId, Rect location) = 0;
			};

			/// <summary>Renderer awared rich text document layout engine provider interface.</summary>
			class IGuiGraphicsLayoutProvider : public IDescriptable, public Description<IGuiGraphicsLayoutProvider>
			{
			public:
				/// <summary>Create a paragraph with internal renderer device dependent objects initialized.</summary>
				/// <param name="text">The text used to fill the paragraph.</param>
				/// <param name="renderTarget">The render target that the created paragraph will render to.</param>
				/// <param name="callback">A callback to receive necessary information when the paragraph is being rendered.</param>
				/// <returns>The created paragraph object.</returns>
				virtual Ptr<IGuiGraphicsParagraph>			CreateParagraph(const WString& text, IGuiGraphicsRenderTarget* renderTarget, IGuiGraphicsParagraphCallback* callback)=0;
			};
		}
	}
}

#endif

/***********************************************************************
.\NATIVEWINDOW\GUINATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window

Interfaces:
  INativeController						: Interface for Operating System abstraction
    INativeControllerListener
  INativeScreenService					: Screen Service
    INativeScreen
  INativeResourceService				: Resource Service
    INativeCursor
  INativeImageService					: Image Service
    INativeImageFrameCache
    INativeImageFrame
    INativeImage
  INativeWindowService					: Window Service
    INativeWindow
    INativeWindowListener
  INativeAsyncService					: Async Service
    INativeDelay
  INativeClipboardService				: Clipboard Service
    INativeClipboardReader
    INativeClipboardWriter
  INativeInputService					: Input Service
  INativeCallbackService				: Callback Service
  INativeDialogService					: Dialog Service

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUINATIVEWINDOW
#define VCZH_PRESENTATION_GUINATIVEWINDOW


namespace vl
{
	namespace presentation
	{

/***********************************************************************
INativeWindow
***********************************************************************/

		class GuiImageData;
		class DocumentModel;
		class INativeCursor;
		class INativeWindowListener;

		enum class BoolOption
		{
			AlwaysTrue,
			AlwaysFalse,
			Customizable,
		};

		struct NativeWindowFrameConfig
		{
			BoolOption MaximizedBoxOption = BoolOption::Customizable;
			BoolOption MinimizedBoxOption = BoolOption::Customizable;
			BoolOption BorderOption = BoolOption::Customizable;
			BoolOption SizeBoxOption = BoolOption::Customizable;
			BoolOption IconVisibleOption = BoolOption::Customizable;
			BoolOption TitleBarOption = BoolOption::Customizable;
			BoolOption CustomFrameEnabled = BoolOption::Customizable;

			auto operator<=>(const NativeWindowFrameConfig&) const = default;

			static const NativeWindowFrameConfig Default;
		};
		
		/// <summary>
		/// Represents a window.
		/// </summary>
		class INativeWindow : public Interface, public Description<INativeWindow>
		{
		public:
			/// <summary>
			/// Test if the window needs to actively refreshing itself.
			/// It should return true if it has an exclusive OS native window.
			/// </summary>
			/// <returns>Returns true if the window needs to actively refreshing itself.</returns>
			virtual bool				IsActivelyRefreshing() = 0;
			/// <summary>
			/// Get the rendering offset to the render target.
			/// It should return (0,0) if it has an exclusive OS native window.
			/// </summary>
			/// <returns>Returns the rendering offset to the render target.</returns>
			virtual NativeSize			GetRenderingOffset() = 0;

			/// <summary>
			/// Convert point from native coordinate to GUI coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual Point				Convert(NativePoint value) = 0;
			/// <summary>
			/// Convert point from GUI coordinate to native coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual NativePoint			Convert(Point value) = 0;
			/// <summary>
			/// Convert size from native coordinate to GUI coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual Size				Convert(NativeSize value) = 0;
			/// <summary>
			/// Convert size from GUI coordinate to native coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual NativeSize			Convert(Size value) = 0;
			/// <summary>
			/// Convert margin from native coordinate to GUI coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual Margin				Convert(NativeMargin value) = 0;
			/// <summary>
			/// Convert margin from GUI coordinate to native coordinate.
			/// </summary>
			/// <returns>The converted result.</returns>
			/// <param name="value">The coordinate to convert.</param>
			virtual NativeMargin		Convert(Margin value) = 0;

			/// <summary>
			/// Get the bounds of the window.
			/// </summary>
			/// <returns>The bounds of the window.</returns>
			virtual NativeRect			GetBounds()=0;
			/// <summary>
			/// Set the bounds of the window.
			/// </summary>
			/// <param name="bounds">The bounds of the window.</param>
			virtual void				SetBounds(const NativeRect& bounds)=0;
			/// <summary>
			/// Get the client size of the window.
			/// </summary>
			/// <returns>The client size of the window.</returns>
			virtual NativeSize			GetClientSize()=0;
			/// <summary>
			/// Set the client size of the window.
			/// </summary>
			/// <param name="size">The client size of the window.</param>
			virtual void				SetClientSize(NativeSize size)=0;
			/// <summary>
			/// Get the client bounds in screen space.
			/// </summary>
			/// <returns>The client bounds in screen space.</returns>
			virtual NativeRect			GetClientBoundsInScreen()=0;
			
			/// <summary>
			/// Get the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <returns>The title of the window.</returns>
			virtual WString				GetTitle()=0;
			/// <summary>
			/// Set the title of the window. A title will be displayed as a name of this window.
			/// </summary>
			/// <param name="title">The title of the window.</param>
			virtual void				SetTitle(const WString& title)=0;
			/// <summary>
			/// Get the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <returns>The mouse cursor of the window.</returns>
			virtual INativeCursor*		GetWindowCursor()=0;
			/// <summary>
			/// Set the mouse cursor of the window. When the mouse is on the window, the mouse cursor will be rendered.
			/// </summary>
			/// <param name="cursor">The mouse cursor of the window.</param>
			virtual void				SetWindowCursor(INativeCursor* cursor)=0;
			/// <summary>
			/// Get the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <returns>The caret point of the window.</returns>
			virtual NativePoint			GetCaretPoint()=0;
			/// <summary>
			/// Set the caret point of the window. When an input method editor is opened, the input text box will be located to the caret point.
			/// </summary>
			/// <param name="point">The caret point of the window.</param>
			virtual void				SetCaretPoint(NativePoint point)=0;
			
			/// <summary>
			/// Get the parent window.
			/// A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <returns>The parent window.</returns>
			virtual INativeWindow*		GetParent()=0;
			/// <summary>
			/// Set the parent window. A parent window doesn't contain a child window. It always displayed below the child windows. When a parent window is minimized or restored, so as its child windows.
			/// </summary>
			/// <param name="parent">The parent window.</param>
			virtual void				SetParent(INativeWindow* parent)=0;

			/// <summary>
			/// Window mode
			/// </summary>
			enum WindowMode
			{
				/// <summary>
				/// A normal window.
				/// </summary>
				Normal,
				/// <summary>
				/// A popup window.
				/// Such window is expected to be disabled activation, [M:vl.presentation.INativeWindow.DisableActivate] must be called manually.
				/// Such window is expected to have a parent window, [M:vl.presentation.INativeWindow.SetParent] must be called before [M:vl.presentation.INativeWindow.ShowDeactivated].
				/// This window is automatically closed when the top level window is deactivated or clicked.
				/// </summary>
				Popup,
				/// <summary>
				/// A tooltip window, just like Popup.
				/// </summary>
				Tooltip,
				/// <summary>
				/// A menu window, just like Menu.
				/// </summary>
				Menu,
			};

			/// <summary>
			/// Get the window mode. 
			/// </summary>
			/// <returns>The window mode.</summary>
			virtual WindowMode			GetWindowMode() = 0;

			/// <summary>
			/// Enable the window customized frame mode.
			/// </summary>
			virtual void				EnableCustomFrameMode()=0;
			/// <summary>
			/// Disable the window customized frame mode.
			/// </summary>
			virtual void				DisableCustomFrameMode()=0;
			/// <summary>
			/// Test is the window customized frame mode enabled.
			/// </summary>
			/// <returns>Returns true if the window customized frame mode is enabled.</returns>
			virtual bool				IsCustomFrameModeEnabled()=0;
			/// <summary>
			/// Get the amount of the border. The window template may need this value to calculate where to put the client area.
			/// </summary>
			/// <returns>Returns the amount of the border.</returns>
			virtual NativeMargin		GetCustomFramePadding() = 0;

			/// <summary>Window size state.</summary>
			enum WindowSizeState
			{
				/// <summary>Minimized.</summary>
				Minimized,
				/// <summary>Restored.</summary>
				Restored,
				/// <summary>Maximized.</summary>
				Maximized,
			};

			/// <summary>
			/// Get the icon.
			/// </summary>
			/// <returns>Returns the icon.</returns>
			virtual Ptr<GuiImageData>	GetIcon()=0;
			/// <summary>
			/// Set the icon.
			/// </summary>
			/// <param name="icon">The icon. Set to null to use the default icon.</param>
			virtual void				SetIcon(Ptr<GuiImageData> icon)=0;

			/// <summary>
			/// Get the window size state.
			/// </summary>
			/// <returns>Returns the window size state.</returns>
			virtual WindowSizeState		GetSizeState()=0;
			/// <summary>
			/// Show the window.
			/// If the window disabled activation, this function enables it again.
			/// </summary>
			virtual void				Show()=0;
			/// <summary>
			/// Show the window without activation.
			/// </summary>
			virtual void				ShowDeactivated()=0;
			/// <summary>
			/// Restore the window.
			/// </summary>
			virtual void				ShowRestored()=0;
			/// <summary>
			/// Maximize the window.
			/// </summary>
			virtual void				ShowMaximized()=0;
			/// <summary>
			/// Minimize the window.
			/// </summary>
			virtual void				ShowMinimized()=0;
			/// <summary>
			/// Hide the window.
			/// </summary>
			/// <param name="closeWindow">Set to true to really close the window. Or the window will just be hidden. This parameter only affect the main window.</param>
			virtual void				Hide(bool closeWindow)=0;
			/// <summary>
			/// Test is the window visible.
			/// </summary>
			/// <returns>Returns true if the window is visible.</returns>
			virtual bool				IsVisible()=0;

			/// <summary>
			/// Enable the window.
			/// </summary>
			virtual void				Enable()=0;
			/// <summary>
			/// Disable the window.
			/// </summary>
			virtual void				Disable()=0;
			/// <summary>
			/// Test is the window enabled.
			/// </summary>
			/// <returns>Returns true if the window is enabled.</returns>
			virtual bool				IsEnabled()=0;
			
			/// <summary>
			/// Activate to the window.
			/// If the window disabled activation, this function enables it again.
			/// </summary>
			virtual void				SetActivate()=0;
			/// <summary>
			/// Test is the window activated.
			/// </summary>
			/// <returns>Returns true if the window is activated.</returns>
			virtual bool				IsActivated()=0;
			/// <summary>
			/// Test is the window rendering as activated.
			/// </summary>
			/// <returns>Returns true if the window is rendering as activated.</returns>
			virtual bool				IsRenderingAsActivated() = 0;
			
			/// <summary>
			/// Show the icon in the task bar.
			/// </summary>
			virtual void				ShowInTaskBar()=0;
			/// <summary>
			/// Hide the icon in the task bar.
			/// </summary>
			virtual void				HideInTaskBar()=0;
			/// <summary>
			/// Test is the window icon appeared in the task bar.
			/// </summary>
			/// <returns>Returns true if the window icon appears in the task bar.</returns>
			virtual bool				IsAppearedInTaskBar()=0;
			
			/// <summary>
			/// Enable activation to the window.
			/// </summary>
			virtual void				EnableActivate()=0;
			/// <summary>
			/// Disable activation to the window.
			/// Clicking a window with activation disabled doesn't bring activation.
			/// Activation will be automatically enabled by calling <see cref="Show"/> or <see cref="SetActivate"/>.
			/// </summary>
			virtual void				DisableActivate()=0;
			/// <summary>
			/// Test is the window allowed to be activated.
			/// </summary>
			/// <returns>Returns true if the window is allowed to be activated.</returns>
			virtual bool				IsEnabledActivate()=0;
			
			/// <summary>
			/// Require mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// When the window becomes invisible after calling this function, the window will still receive mouse messages, if the OS supports this feature.
			/// Otherwise, the capturing must be released when the window becomes invisible.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				RequireCapture()=0;
			/// <summary>
			/// Release mouse message capturing to this window. If the capture is required, all mouse message will be send to this window.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool				ReleaseCapture()=0;
			/// <summary>
			/// Test if the window is capturing mouse messages.
			/// </summary>
			/// <returns>Returns true if the window is capturing mouse messages.</returns>
			virtual bool				IsCapturing()=0;

			/// <summary>
			/// Test is the maximize box visible.
			/// </summary>
			/// <returns>Returns true if the maximize box is visible.</returns>
			virtual bool				GetMaximizedBox()=0;
			/// <summary>
			/// Make the maximize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the maximize box visible.</param>
			virtual void				SetMaximizedBox(bool visible)=0;
			/// <summary>
			/// Test is the minimize box visible.
			/// </summary>
			/// <returns>Returns true if the minimize box is visible.</returns>
			virtual bool				GetMinimizedBox()=0;
			/// <summary>
			/// Make the minimize box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the minimize box visible.</param>
			virtual void				SetMinimizedBox(bool visible)=0;
			/// <summary>
			/// Test is the border visible.
			/// </summary>
			/// <returns>Returns true if the border is visible.</returns>
			virtual bool				GetBorder()=0;
			/// <summary>
			/// Make the border visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the border visible.</param>
			virtual void				SetBorder(bool visible)=0;
			/// <summary>
			/// Test is the size box visible.
			/// </summary>
			/// <returns>Returns true if the size box is visible.</returns>
			virtual bool				GetSizeBox()=0;
			/// <summary>
			/// Make the size box visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the size box visible.</param>
			virtual void				SetSizeBox(bool visible)=0;
			/// <summary>
			/// Test is the icon visible.
			/// </summary>
			/// <returns>Returns true if the icon is visible.</returns>
			virtual bool				GetIconVisible()=0;
			/// <summary>
			/// Make the icon visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the icon visible.</param>
			virtual void				SetIconVisible(bool visible)=0;
			/// <summary>
			/// Test is the title bar visible.
			/// </summary>
			/// <returns>Returns true if the title bar is visible.</returns>
			virtual bool				GetTitleBar()=0;
			/// <summary>
			/// Make the title bar visible or invisible.
			/// </summary>
			/// <param name="visible">True to make the title bar visible.</param>
			virtual void				SetTitleBar(bool visible)=0;
			/// <summary>
			/// Test is the window always on top of the desktop.
			/// </summary>
			/// <returns>Returns true if the window is always on top of the desktop.</returns>
			virtual bool				GetTopMost()=0;
			/// <summary>
			/// Make the window always or never on top of the desktop.
			/// </summary>
			/// <param name="topmost">True to make the window always  on top of the desktop.</param>
			virtual void				SetTopMost(bool topmost)=0;

			/// <summary>
			/// Supress the system's Alt+X hot key
			/// </summary>
			virtual void				SupressAlt() = 0;
			
			/// <summary>
			/// Install an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to install.</param>
			virtual bool				InstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Uninstall an message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The listener to uninstall.</param>
			virtual bool				UninstallListener(INativeWindowListener* listener)=0;
			/// <summary>
			/// Redraw the content of the window.
			/// </summary>
			virtual void				RedrawContent()=0;
		};

		/// <summary>
		/// Mouse message information.
		/// </summary>
		/// <typeparam name="T">Type of the coordinate.</typeparam>
		template<typename T>
		struct WindowMouseInfo_
		{
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the left mouse button is pressed.</summary>
			bool						left;
			/// <summary>True if the middle mouse button is pressed.</summary>
			bool						middle;
			/// <summary>True if the right mouse button is pressed.</summary>
			bool						right;
			/// <summary>The mouse position of x dimension.</summary>
			T							x;
			/// <summary>The mouse position of y dimension.</summary>
			T							y;
			/// <summary>The delta of the wheel.</summary>
			vint						wheel;
			/// <summary>True if the mouse is in the non-client area.</summary>
			bool						nonClient;
		};

		using WindowMouseInfo = WindowMouseInfo_<GuiCoordinate>;
		using NativeWindowMouseInfo = WindowMouseInfo_<NativeCoordinate>;
		
		/// <summary>
		/// Key message information.
		/// </summary>
		struct NativeWindowKeyInfo
		{
			/// <summary>Key code of the key that sends this message.</summary>
			VKEY						code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
			/// <summary>True if this repeated event is generated because a key is holding down.</summary>
			bool						autoRepeatKeyDown;
		};

		using WindowKeyInfo = NativeWindowKeyInfo;
		
		/// <summary>
		/// Character message information.
		/// </summary>
		struct NativeWindowCharInfo
		{
			/// <summary>Character that sends this message.</summary>
			wchar_t						code;
			/// <summary>True if the control button is pressed.</summary>
			bool						ctrl;
			/// <summary>True if the shift button is pressed.</summary>
			bool						shift;
			/// <summary>True if the alt button is pressed.</summary>
			bool						alt;
			/// <summary>True if the capslock button is pressed.</summary>
			bool						capslock;
		};

		using WindowCharInfo = NativeWindowCharInfo;
		
		/// <summary>
		/// Represents a message listener to an <see cref="INativeWindow"/>.
		/// </summary>
		class INativeWindowListener : public Interface
		{
		public:
			/// <summary>Hit test result for a native window.</summary>
			enum HitTestResult
			{
				/// <summary>Border that doesn't contain sizing functionalitiy.</summary>
				BorderNoSizing,
				/// <summary>Left border.</summary>
				BorderLeft,
				/// <summary>Right border.</summary>
				BorderRight,
				/// <summary>Top border.</summary>
				BorderTop,
				/// <summary>Bottom border.</summary>
				BorderBottom,
				/// <summary>Left top border.</summary>
				BorderLeftTop,
				/// <summary>Right top border.</summary>
				BorderRightTop,
				/// <summary>Left bottom border.</summary>
				BorderLeftBottom,
				/// <summary>Right bottom border.</summary>
				BorderRightBottom,
				/// <summary>Title</summary>
				Title,
				/// <summary>Minimum button.</summary>
				ButtonMinimum,
				/// <summary>Maximum button.</summary>
				ButtonMaximum,
				/// <summary>Close button.</summary>
				ButtonClose,
				/// <summary>Client button.</summary>
				Client,
				/// <summary>Icon.</summary>
				Icon,
				/// <summary>Let the OS window layer decide.</summary>
				NoDecision,
			};

			/// <summary>
			/// Perform a hit test.
			/// </summary>
			/// <returns>Returns the hit test result. If "NoDecision" is returned, the native window provider should call the OS window layer to do the hit test.</returns>
			/// <param name="location">The location to do the hit test. This location is in the window space (not the client space).</param>
			virtual HitTestResult		HitTest(NativePoint location);
			/// <summary>
			/// Called when the window is moving.
			/// </summary>
			/// <param name="bounds">The bounds. Message handler can change the bounds.</param>
			/// <param name="fixSizeOnly">True if the message raise only want the message handler to change the size, and keep the position unchanged.</param>
			/// <param name="draggingBorder">True if the message raise because the user is dragging the border to change the size.</param>
			virtual void				Moving(NativeRect& bounds, bool fixSizeOnly, bool draggingBorder);
			/// <summary>
			/// Called when the window is moved.
			/// </summary>
			virtual void				Moved();
			/// <summary>
			/// Called when the dpi associated with this window is changed.
			/// The native window should call DpiChanged(true) before DpiChanged(false).
			/// </summary>
			/// <param name="preparing">True for before changing phase, false for after changing phase.</param>
			virtual void				DpiChanged(bool preparing);
			/// <summary>
			/// Called when the window is enabled.
			/// </summary>
			virtual void				Enabled();
			/// <summary>
			/// Called when the window is disabled.
			/// </summary>
			virtual void				Disabled();
			/// <summary>
			/// Called when the window got the focus.
			/// </summary>
			virtual void				GotFocus();
			/// <summary>
			/// Called when the window lost the focus.
			/// </summary>
			virtual void				LostFocus();
			/// <summary>
			/// Called when the window is rending as activated.
			/// </summary>
			virtual void				RenderingAsActivated();
			/// <summary>
			/// Called when the window is rendering as deactivated.
			/// </summary>
			virtual void				RenderingAsDeactivated();
			/// <summary>
			/// Called when the window is opened.
			/// </summary>
			virtual void				Opened();
			/// <summary>
			/// Called when the window is closing.
			/// </summary>
			/// <param name="cancel">Change the value to true to prevent the windows from being closed.</param>
			virtual void				BeforeClosing(bool& cancel);
			/// <summary>
			/// Called when all <see cref="BeforeClosing"/> callback agree to close.
			/// </summary>
			virtual void				AfterClosing();
			/// <summary>
			/// Called when the window is closed.
			/// </summary>
			virtual void				Closed();
			/// <summary>
			/// Called when the window is painting.
			/// </summary>
			virtual void				Paint();
			/// <summary>
			/// Called when the window is destroying.
			/// </summary>
			virtual void				Destroying();
			/// <summary>
			/// Called when the window is destroyed.
			/// </summary>
			virtual void				Destroyed();
			
			/// <summary>
			/// Called when the left mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the left mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				LeftButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the right mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				RightButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDown(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonUp(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the middle mouse button performed a double click.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MiddleButtonDoubleClick(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal mouse wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				HorizontalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the horizontal vertical wheel scrolls.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				VerticalWheel(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse is moving on the window.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				MouseMoving(const NativeWindowMouseInfo& info);
			/// <summary>
			/// Called when the mouse entered the window.
			/// </summary>
			virtual void				MouseEntered();
			/// <summary>
			/// Called when the mouse leaved the window.
			/// </summary>
			virtual void				MouseLeaved();
			
			/// <summary>
			/// Called a key is pressed.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyDown(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called a key is released.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				KeyUp(const NativeWindowKeyInfo& info);
			/// <summary>
			/// Called an input character is generated.
			/// </summary>
			/// <param name="info">Detailed information to this message.</param>
			virtual void				Char(const NativeWindowCharInfo& info);

			/// <summary>
			/// Called to test if the window needs to be updated, only when <see cref="INativeWindow::IsActivelyRefreshing"/> returns false.
			/// </summary>
			/// <returns>Returns true if the window needs to be updated.</returns>
			virtual bool				NeedRefresh();
			/// <summary>
			/// Called to refresh the window, only when <see cref="INativeWindow::IsActivelyRefreshing"/> returns false.
			/// </summary>
			/// <returns>Returns true if the window needs to be updated.</returns>
			/// <param name="cleanBeforeRender">True when the whole render target needs to be cleaned.</param>
			virtual void				ForceRefresh(bool handleFailure, bool& updated, bool& failureByResized, bool& failureByLostDevice);
			/// <summary>
			/// Called when the frame config of a window is decided.
			/// This callback is only called in hosted mode.
			/// This callback is only called once on a window.
			/// </summary>
			virtual void				AssignFrameConfig(const NativeWindowFrameConfig& config);
		};

/***********************************************************************
INativeImageService
***********************************************************************/

		class INativeImageService;
		class INativeImage;
		class INativeImageFrame;
		
		/// <summary>
		/// Represents a customized cache object for an image frame.
		/// </summary>
		class INativeImageFrameCache : public Interface
		{
		public:
			/// <summary>
			/// Called when this cache object is attached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that attached to.</param>
			virtual void						OnAttach(INativeImageFrame* frame)=0;
			/// <summary>
			/// Called when this cache object is detached to an image frame.
			/// </summary>
			/// <param name="frame">The image frame that detached from.</param>
			virtual void						OnDetach(INativeImageFrame* frame)=0;
		};

		/// <summary>
		/// Represents an image frame.
		/// </summary>
		class INativeImageFrame : public virtual IDescriptable, public Description<INativeImageFrame>
		{
		public:
			/// <summary>
			/// Get the image that owns this frame.
			/// </summary>
			/// <returns>The image that owns this frame.</returns>
			virtual INativeImage*				GetImage()=0;
			/// <summary>
			/// Get the size of this frame.
			/// </summary>
			/// <returns>The size of this frame.</returns>
			virtual Size						GetSize()=0;

			/// <summary>
			/// Attach a customized cache object to this image frame and bind to a key.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			/// <param name="cache">The customized cache object.</param>
			virtual bool						SetCache(void* key, Ptr<INativeImageFrameCache> cache)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key.
			/// </summary>
			/// <returns>The attached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	GetCache(void* key)=0;
			/// <summary>
			/// Get the attached customized cache object that is already binded to a key, and then detach it.
			/// </summary>
			/// <returns>The detached customized cache object.</returns>
			/// <param name="key">The key binded with the customized cache object.</param>
			virtual Ptr<INativeImageFrameCache>	RemoveCache(void* key)=0;
		};
		
		/// <summary>
		/// Represents an image.
		/// </summary>
		class INativeImage : public virtual IDescriptable, public Description<INativeImage>
		{
		public:
			/// <summary>
			/// Represents an image format.
			/// </summary>
			enum FormatType
			{
				/// <summary>
				/// Bitmap format.
				/// </summary>
				Bmp,
				/// <summary>
				/// GIF format.
				/// </summary>
				Gif,
				/// <summary>
				/// Icon format.
				/// </summary>
				Icon,
				/// <summary>
				/// JPEG format.
				/// </summary>
				Jpeg,
				/// <summary>
				/// PNG format.
				/// </summary>
				Png,
				/// <summary>
				/// TIFF format.
				/// </summary>
				Tiff,
				/// <summary>
				/// WMP format.
				/// </summary>
				Wmp,
				/// <summary>
				/// Unknown format.
				/// </summary>
				Unknown,
			};
			
			/// <summary>
			/// Get the image service that creates this image.
			/// </summary>
			/// <returns>The image service that creates this image.</returns>
			virtual INativeImageService*		GetImageService()=0;
			/// <summary>
			/// Get the image format.
			/// </summary>
			/// <returns>The image format.</returns>
			virtual FormatType					GetFormat()=0;
			/// <summary>
			/// Get the number of frames in this image.
			/// </summary>
			/// <returns>The number of frames in this image.</returns>
			virtual vint						GetFrameCount()=0;
			/// <summary>
			/// Get the frame in this image by a specified frame index.
			/// </summary>
			/// <returns>The frame in this image by a specified frame index.</returns>
			/// <param name="index">The specified frame index.</param>
			virtual INativeImageFrame*			GetFrame(vint index)=0;
			/// <summary>
			/// Save the image to a stream.
			/// </summary>
			/// <param name="imageStream">The stream.</param>
			/// <param name="formatType">The format of the image.</param>
			virtual void						SaveToStream(stream::IStream& imageStream, FormatType formatType = FormatType::Unknown) = 0;
		};
		
		/// <summary>
		/// Image service. To access this service, use [M:vl.presentation.INativeController.ImageService].
		/// </summary>
		class INativeImageService : public virtual IDescriptable, public Description<INativeImageService>
		{
		public:
			/// <summary>
			/// Create an image from file.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="path">The file path.</param>
			virtual Ptr<INativeImage>			CreateImageFromFile(const WString& path)=0;

			/// <summary>
			/// Create an image from memory.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="buffer">The memory pointer.</param>
			/// <param name="length">The memory length.</param>
			virtual Ptr<INativeImage>			CreateImageFromMemory(void* buffer, vint length)=0;

			/// <summary>
			/// Create an image from stream.
			/// </summary>
			/// <returns>The created image.</returns>
			/// <param name="imageStream">The stream.</param>
			virtual Ptr<INativeImage>			CreateImageFromStream(stream::IStream& imageStream)=0;
		};

/***********************************************************************
INativeResourceService
***********************************************************************/
		
		/// <summary>
		/// Represents a cursor.
		/// </summary>
		class INativeCursor : public virtual IDescriptable, public Description<INativeCursor>
		{
		public:
			/// <summary>
			/// Represents a predefined cursor type.
			/// </summary>
			enum SystemCursorType
			{
				/// <summary>
				/// Small waiting cursor.
				/// </summary>
				SmallWaiting,
				/// <summary>
				/// large waiting cursor.
				/// </summary>
				LargeWaiting,
				/// <summary>
				/// Arrow cursor.
				/// </summary>
				Arrow,
				/// <summary>
				/// Cross cursor.
				/// </summary>
				Cross,
				/// <summary>
				/// Hand cursor.
				/// </summary>
				Hand,
				/// <summary>
				/// Help cursor.
				/// </summary>
				Help,
				/// <summary>
				/// I beam cursor.
				/// </summary>
				IBeam,
				/// <summary>
				/// Sizing in all direction cursor.
				/// </summary>
				SizeAll,
				/// <summary>
				/// Sizing NE-SW cursor.
				/// </summary>
				SizeNESW,
				/// <summary>
				/// Sizing N-S cursor.
				/// </summary>
				SizeNS,
				/// <summary>
				/// Sizing NW-SE cursor.
				/// </summary>
				SizeNWSE,
				/// <summary>
				/// Sizing W-E cursor.
				/// </summary>
				SizeWE,
				/// <summary>
				/// Number of available cursors, this is not an available cursor by itself.
				/// </summary>
				LastSystemCursor=SizeWE,
			};

			static const vint			SystemCursorCount=LastSystemCursor+1;
		public:
			/// <summary>
			/// Test is the cursor a system provided cursor.
			/// </summary>
			/// <returns>Returns true if the cursor a system provided cursor.</returns>
			virtual bool				IsSystemCursor()=0;
			/// <summary>
			/// Get the cursor type if the cursor a system provided cursor.
			/// </summary>
			/// <returns>The cursor type.</returns>
			virtual SystemCursorType	GetSystemCursorType()=0;
		};

		/// <summary>
		/// System resource service. To access this service, use [M:vl.presentation.INativeController.ResourceService].
		/// </summary>
		class INativeResourceService : public virtual IDescriptable, public Description<INativeResourceService>
		{
		public:
			/// <summary>
			/// Get a cached cursor object using a predefined system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			/// <param name="type">The predefined system cursor type.</param>
			virtual INativeCursor*			GetSystemCursor(INativeCursor::SystemCursorType type)=0;
			/// <summary>
			/// Get a cached cursor object using a default system cursor type;
			/// </summary>
			/// <returns>The cached cursor object.</returns>
			virtual INativeCursor*			GetDefaultSystemCursor()=0;

			/// <summary>
			/// Get the default font configuration of the system.
			/// </summary>
			/// <returns>The default font configuration of the system.</returns>
			virtual FontProperties			GetDefaultFont()=0;
			/// <summary>
			/// Override the default font configuration for the current process, only available GacUI library.
			/// </summary>
			/// <param name="value">The font configuration to override.</param>
			virtual void					SetDefaultFont(const FontProperties& value)=0;
			/// <summary>
			/// Enumerate all system fonts.
			/// </summary>
			/// <param name="fonts">The collection to receive all fonts.</param>
			virtual void					EnumerateFonts(collections::List<WString>& fonts)=0;
		};

/***********************************************************************
INativeAsyncService
***********************************************************************/

		/// <summary>
		/// Delay execution controller.
		/// </summary>
		class INativeDelay : public virtual IDescriptable, public Description<INativeDelay>
		{
		public:
			/// <summary>Delay execution controller status.</summary>
			enum ExecuteStatus
			{
				/// <summary>Pending.</summary>
				Pending,
				/// <summary>Executing.</summary>
				Executing,
				/// <summary>Executed.</summary>
				Executed,
				/// <summary>Canceled.</summary>
				Canceled,
			};

			/// <summary>Get the current status.</summary>
			/// <returns>The current status.</returns>
			virtual ExecuteStatus			GetStatus()=0;
			/// <summary>If the current task is pending, execute the task after a specified period.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="milliseconds">A specified period.</param>
			virtual bool					Delay(vint milliseconds)=0;
			/// <summary>If the current task is pending, cancel the task.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool					Cancel()=0;
		};
		
		/// <summary>
		/// Asynchronized operation service. GacUI is not a thread safe library except for this service. To access this service, use [M:vl.presentation.INativeController.AsyncService].
		/// </summary>
		class INativeAsyncService : public virtual IDescriptable, public Description<INativeAsyncService>
		{
		public:

			/// <summary>
			/// Test is the current thread the main thread.
			/// </summary>
			/// <returns>Returns true if the current thread is the main thread.</returns>
			/// <param name="window">A window to access the corressponding main thread.</param>
			virtual bool					IsInMainThread(INativeWindow* window)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument asynchronisly.
			/// </summary>
			/// <param name="proc">The specified function.</param>
			virtual void					InvokeAsync(const Func<void()>& proc)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread.
			/// </summary>
			/// <param name="window">A window to access the corressponding main thread.</param>
			/// <param name="proc">The specified function.</param>
			virtual void					InvokeInMainThread(INativeWindow* window, const Func<void()>& proc)=0;
			/// <summary>
			/// Invoke a specified function with an specified argument in the main thread and wait for the function to complete or timeout.
			/// </summary>
			/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
			/// <param name="window">A window to access the corressponding main thread.</param>
			/// <param name="proc">The specified function.</param>
			/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
			virtual bool					InvokeInMainThreadAndWait(INativeWindow* window, const Func<void()>& proc, vint milliseconds=-1)=0;
			/// <summary>
			/// Delay execute a specified function with an specified argument asynchronisly.
			/// </summary>
			/// <returns>The Delay execution controller for this task.</returns>
			/// <param name="proc">The specified function.</param>
			/// <param name="milliseconds">Time to delay.</param>
			virtual Ptr<INativeDelay>		DelayExecute(const Func<void()>& proc, vint milliseconds)=0;
			/// <summary>
			/// Delay execute a specified function with an specified argument in the main thread.
			/// </summary>
			/// <returns>The Delay execution controller for this task.</returns>
			/// <param name="proc">The specified function.</param>
			/// <param name="milliseconds">Time to delay.</param>
			virtual Ptr<INativeDelay>		DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds)=0;
		};

/***********************************************************************
INativeClipboardService
***********************************************************************/

		/// <summary>
		/// Clipboard reader.
		/// </summary>
		class INativeClipboardReader : public virtual IDescriptable, public Description<INativeClipboardReader>
		{
		public:
			/// <summary>Test is there a text in the clipboard.</summary>
			/// <returns>Returns true if there is a text in the clipboard.</returns>
			virtual bool					ContainsText() = 0;

			/// <summary>Get the text from the clipboard.</summary>
			/// <returns>The text.</returns>
			virtual WString					GetText() = 0;

			/// <summary>Test is there a document in the clipboard.</summary>
			/// <returns>Returns true if there is a document in the clipboard.</returns>
			virtual bool					ContainsDocument() = 0;

			/// <summary>Get the document from the clipboard.</summary>
			/// <returns>The document.</returns>
			virtual Ptr<DocumentModel>		GetDocument() = 0;

			/// <summary>Test is there an image in the clipboard.</summary>
			/// <returns>Returns true if there is an image in the clipboard.</returns>
			virtual bool					ContainsImage() = 0;

			/// <summary>Get the image from the clipboard.</summary>
			/// <returns>The image.</returns>
			virtual Ptr<INativeImage>		GetImage() = 0;
		};

		/// <summary>
		/// Clipboard writer.
		/// </summary>
		class INativeClipboardWriter : public virtual IDescriptable, public Description<INativeClipboardWriter>
		{
		public:
			/// <summary>Prepare a text for the clipboard.</summary>
			/// <param name="value">The text.</param>
			virtual void					SetText(const WString& value) = 0;

			/// <summary>Prepare a document for the clipboard.</summary>
			/// <param name="value">The document.</param>
			virtual void					SetDocument(Ptr<DocumentModel> value) = 0;

			/// <summary>Prepare an image for the clipboard.</summary>
			/// <param name="value">The image.</param>
			virtual void					SetImage(Ptr<INativeImage> value) = 0;

			/// <summary>Send all data to the clipboard.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool					Submit() = 0;
		};
		
		/// <summary>
		/// Clipboard service. To access this service, use [M:vl.presentation.INativeController.ClipboardService].
		/// </summary>
		class INativeClipboardService : public virtual IDescriptable, public Description<INativeClipboardService>
		{
		public:
			/// <summary>Read clipboard.</summary>
			/// <returns>The clipboard reader.</returns>
			virtual Ptr<INativeClipboardReader>		ReadClipboard() = 0;
			/// <summary>Write clipboard.</summary>
			/// <returns>The clipboard writer.</returns>
			virtual Ptr<INativeClipboardWriter>		WriteClipboard() = 0;
		};

/***********************************************************************
INativeScreenService
***********************************************************************/

		/// <summary>
		/// Represents a screen.
		/// </summary>
		class INativeScreen : public virtual IDescriptable, public Description<INativeScreen>
		{
		public:
			/// <summary>
			/// Get the bounds of the screen.
			/// </summary>
			/// <returns>The bounds of the screen.</returns>
			virtual NativeRect			GetBounds()=0;
			/// <summary>
			/// Get the bounds of the screen client area.
			/// </summary>
			/// <returns>The bounds of the screen client area.</returns>
			virtual NativeRect			GetClientBounds()=0;
			/// <summary>
			/// Get the name of the screen.
			/// </summary>
			/// <returns>The name of the screen.</returns>
			virtual WString				GetName()=0;
			/// <summary>
			/// Test is the screen is a primary screen.
			/// </summary>
			/// <returns>Returns true if the screen is a primary screen.</returns>
			virtual bool				IsPrimary()=0;
			/// <summary>
			/// Get the scaling for the screen's horizontal edge.
			/// </summary>
			/// <returns>The scaling. For example, in Windows when you have a 96 DPI, this function returns 1.0.</returns>
			virtual double				GetScalingX() = 0;
			/// <summary>
			/// Get the scaling for the screen's vertical edge.
			/// </summary>
			/// <returns>The scaling. For example, in Windows when you have a 96 DPI, this function returns 1.0.</returns>
			virtual double				GetScalingY() = 0;
		};
		
		/// <summary>
		/// Screen information service. To access this service, use [M:vl.presentation.INativeController.ScreenService].
		/// </summary>
		class INativeScreenService : public virtual IDescriptable, public Description<INativeScreenService>
		{
		public:
			/// <summary>
			/// Get the number of all available screens.
			/// </summary>
			///  <returns>The number of all available screens.</returns>
			virtual vint							GetScreenCount()=0;
			/// <summary>
			/// Get the screen object by a specified screen index.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="index">The specified screen index.</param>
			virtual INativeScreen*					GetScreen(vint index)=0;
			/// <summary>
			/// Get the screen object where the main part of the specified window is inside.
			/// </summary>
			/// <returns>The screen object.</returns>
			/// <param name="window">The specified window.</param>
			virtual INativeScreen*					GetScreen(INativeWindow* window)=0;
		};

/***********************************************************************
INativeWindowService
***********************************************************************/
		
		/// <summary>
		/// Window service. To access this service, use [M:vl.presentation.INativeController.WindowService].
		/// </summary>
		class INativeWindowService : public virtual Interface
		{
		public:
			/// <summary>
			/// Get the frame configuration for the main window.
			/// It limit values of frame properties and control template of the main window.
			/// This function must return "NativeWindowFrameConfig::Default",
			/// unless it is only designed to be used under hosted mode.
			/// </summary>
			/// <returns>The frame configuration for the main window.</returns>
			virtual const NativeWindowFrameConfig&	GetMainWindowFrameConfig()=0;
			/// <summary>
			/// Get the frame configuration for non-main windows.
			/// It limit values of frame properties and control template of all non-main windows.
			/// This function must return "NativeWindowFrameConfig::Default",
			/// unless it is only designed to be used under hosted mode.
			/// </summary>
			/// <returns>The frame configuration for non-main windows.</returns>
			virtual const NativeWindowFrameConfig&	GetNonMainWindowFrameConfig()=0;

			/// <summary>
			/// Create a window.
			/// </summary>
			/// <returns>The created window.</returns>
			/// <param name="windowMode">The window mode.</param>
			virtual INativeWindow*			CreateNativeWindow(INativeWindow::WindowMode windowMode) = 0;
			/// <summary>
			/// Destroy a window.
			/// </summary>
			/// <param name="window">The window to destroy.</param>
			virtual void					DestroyNativeWindow(INativeWindow* window) = 0;
			/// <summary>
			/// Get the main window.
			/// </summary>
			/// <returns>The main window.</returns>
			virtual INativeWindow*			GetMainWindow() = 0;
			/// <summary>
			/// Get the window that under a specified position in screen space.
			/// </summary>
			/// <returns>The window that under a specified position in screen space.</returns>
			/// <param name="location">The specified position in screen space.</param>
			virtual INativeWindow*			GetWindow(NativePoint location) = 0;
			/// <summary>
			/// Make the specified window a main window, show that window, process events, and wait until the windows is closed.
			/// </summary>
			/// <param name="window">The specified window.</param>
			virtual void					Run(INativeWindow* window) = 0;
			/// <summary>
			/// Process minimum necessary events and execute some async tasks.
			/// </summary>
			/// <returns>Return false when the main window has been closed and all finalizing are done.</returns>
			virtual bool					RunOneCycle() = 0;
		};

/***********************************************************************
INativeInputService
***********************************************************************/

		enum class NativeGlobalShortcutKeyResult : vint
		{
			NotSupported = -2,
			Occupied = -1,
			ValidIdBegins = 0,
		};
		
		/// <summary>
		/// User input service. To access this service, use [M:vl.presentation.INativeController.InputService].
		/// </summary>
		class INativeInputService : public virtual IDescriptable, public Description<INativeInputService>
		{
		public:
			/// <summary>
			/// Start to reveive global timer message.
			/// </summary>
			virtual void							StartTimer()=0;
			/// <summary>
			/// Stop to receive global timer message.
			/// </summary>
			virtual void							StopTimer()=0;
			/// <summary>
			/// Test is the global timer message receiving enabled.
			/// </summary>
			/// <returns>Returns true if the global timer message receiving is enabled.</returns>
			virtual bool							IsTimerEnabled()=0;
			
			/// <summary>
			/// Test is the specified key pressing.
			/// </summary>
			/// <returns>Returns true if the specified key is pressing.</returns>
			/// <param name="code">The key code to test.</param>
			virtual bool							IsKeyPressing(VKEY code)=0;
			/// <summary>
			/// Test is the specified key toggled.
			/// </summary>
			/// <returns>Returns true if the specified key is toggled.</returns>
			/// <param name="code">The key code to test.</param>
			virtual bool							IsKeyToggled(VKEY code)=0;

			/// <summary>
			/// Get the name of a key.
			/// </summary>
			/// <returns>The name of a key.</returns>
			/// <param name="code">The key code.</param>
			virtual WString							GetKeyName(VKEY code)=0;
			/// <summary>
			/// Get the key from a name.
			/// </summary>
			/// <returns>The key, returns -1 if the key name doesn't exist.</returns>
			/// <param name="name">Key name</param>
			virtual VKEY							GetKey(const WString& name)=0;

			/// <summary>
			/// Register a system-wide shortcut key that doesn't require any window to be foreground window.
			/// If the shortcut key is activated, <see cref="INativeControllerListener::GlobalShortcutKeyActivated"/> will be called.
			/// </summary>
			/// <param name="ctrl">Set to true if the CTRL key is required.</param>
			/// <param name="shift">Set to true if the SHIFT key is required.</param>
			/// <param name="alt">Set to true if the ALT key is required.</param>
			/// <param name="key">The non-control key.</param>
			/// <param name="id"></param>
			/// <returns>Returns the created id. If it fails, the id equals to one of an item in <see cref="NativeGlobalShortcutKeyResult"/> except "ValidIdBegins".</returns>
			virtual vint							RegisterGlobalShortcutKey(bool ctrl, bool shift, bool alt, VKEY key)=0;

			/// <summary>
			/// Unregister a system-wide shortcut key.
			/// </summary>
			/// <param name="id">The created id.</param>
			/// <returns>Returns true if this operation succeeded.</returns>
			virtual bool							UnregisterGlobalShortcutKey(vint id)=0;
		};

/***********************************************************************
INativeCallbackService
***********************************************************************/

		class INativeControllerListener;

		/// <summary>
		/// Callback invoker.
		/// </summary>
		class INativeCallbackInvoker : public virtual Interface
		{
		public:
			/// <summary>
			/// Invoke <see cref="INativeControllerListener::GlobalTimer"/> of all installed listeners. 
			/// </summary>
			virtual void					InvokeGlobalTimer()=0;
			/// <summary>
			/// Invoke <see cref="INativeControllerListener::ClipboardUpdated"/> of all installed listeners.
			/// </summary>
			virtual void					InvokeClipboardUpdated()=0;
			/// <summary>
			/// Invoke <see cref="INativeControllerListener::ClipboardUpdated"/> of all installed listeners.
			/// </summary>
			virtual void					InvokeGlobalShortcutKeyActivated(vint id) = 0;
			/// <summary>
			/// Invoke <see cref="INativeControllerListener::NativeWindowCreated"/> of all installed listeners.
			/// </summary>
			/// <param name="window">The argument to the callback.</param>
			virtual void					InvokeNativeWindowCreated(INativeWindow* window)=0;
			/// <summary>
			/// Invoke <see cref="INativeControllerListener::NativeWindowDestroying"/> of all installed listeners.
			/// </summary>
			/// <param name="window">The argument to the callback.</param>
			virtual void					InvokeNativeWindowDestroying(INativeWindow* window)=0;
		};
		
		/// <summary>
		/// Callback service. To access this service, use [M:vl.presentation.INativeController.CallbackService].
		/// </summary>
		class INativeCallbackService : public virtual Interface
		{
		public:
			/// <summary>
			/// Install a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to install.</param>
			virtual bool					InstallListener(INativeControllerListener* listener)=0;
			/// <summary>
			/// Uninstall a global message listener.
			/// </summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="listener">The global message listener to uninstall.</param>
			virtual bool					UninstallListener(INativeControllerListener* listener)=0;
			/// <summary>
			/// Get the invoker that invoke all listeners.
			/// </summary>
			/// <returns>The invoker.</returns>
			virtual INativeCallbackInvoker*	Invoker()=0;
		};

/***********************************************************************
INativeDialogService
***********************************************************************/

		/// <summary>
		/// Dialog service. To access this service, use [M:vl.presentation.INativeController.DialogService].
		/// </summary>
		class INativeDialogService : public virtual Interface
		{
		public:
			/// <summary>
			/// Message box button combination for displaying a message box.
			/// </summary>
			enum MessageBoxButtonsInput
			{
				/// <summary>Display OK.</summary>
				DisplayOK,
				/// <summary>Display OK, Cancel.</summary>
				DisplayOKCancel,
				/// <summary>Display Yes, No.</summary>
				DisplayYesNo,
				/// <summary>Display Yes, No, Cancel.</summary>
				DisplayYesNoCancel,
				/// <summary>Display Retry, Cancel.</summary>
				DisplayRetryCancel,
				/// <summary>Display Abort, Retry, Ignore.</summary>
				DisplayAbortRetryIgnore,
				/// <summary>Display Cancel, TryAgain, Continue.</summary>
				DisplayCancelTryAgainContinue,
			};

			/// <summary>
			/// Message box button to indicate what the user selected.
			/// </summary>
			enum MessageBoxButtonsOutput
			{
				/// <summary>Select OK.</summary>
				SelectOK,
				/// <summary>Select Cancel.</summary>
				SelectCancel,
				/// <summary>Select Yes.</summary>
				SelectYes,
				/// <summary>Select No.</summary>
				SelectNo,
				/// <summary>Select Retry.</summary>
				SelectRetry,
				/// <summary>Select Abort.</summary>
				SelectAbort,
				/// <summary>Select Ignore.</summary>
				SelectIgnore,
				/// <summary>Select TryAgain.</summary>
				SelectTryAgain,
				/// <summary>Select Continue.</summary>
				SelectContinue,
			};

			/// <summary>
			/// Message box default button.
			/// </summary>
			enum MessageBoxDefaultButton
			{
				/// <summary>First.</summary>
				DefaultFirst,
				/// <summary>Second.</summary>
				DefaultSecond,
				/// <summary>Third.</summary>
				DefaultThird,
			};

			/// <summary>
			/// Message box icons.
			/// </summary>
			enum MessageBoxIcons
			{
				/// <summary>No icon.</summary>
				IconNone,
				/// <summary>Error icon.</summary>
				IconError,
				/// <summary>Question icon.</summary>
				IconQuestion,
				/// <summary>Warning icon.</summary>
				IconWarning,
				/// <summary>Information icon.</summary>
				IconInformation,
			};

			/// <summary>
			/// Message box model options.
			/// </summary>
			enum MessageBoxModalOptions
			{
				/// <summary>Disable the current window.</summary>
				ModalWindow,
				/// <summary>Disable all windows in the application.</summary>
				ModalTask,
				/// <summary>Top most message box in the whole system.</summary>
				ModalSystem,
			};

			/// <summary>Show a message box.</summary>
			/// <returns>Returns the user selected button.</returns>
			/// <param name="window">The current window. This argument can be null.</param>
			/// <param name="text">The content of the message box.</param>
			/// <param name="title">The title of the message box.</param>
			/// <param name="buttons">The display button combination of the message box.</param>
			/// <param name="defaultButton">The default button of the message box.</param>
			/// <param name="icon">The icon of the message box.</param>
			/// <param name="modal">The modal option of the message box.</param>
			virtual MessageBoxButtonsOutput			ShowMessageBox(INativeWindow* window, const WString& text, const WString& title=L"", MessageBoxButtonsInput buttons=DisplayOK, MessageBoxDefaultButton defaultButton=DefaultFirst, MessageBoxIcons icon=IconNone, MessageBoxModalOptions modal=ModalWindow)=0;

			/// <summary>
			/// Color dialog custom color options
			/// </summary>
			enum ColorDialogCustomColorOptions
			{
				/// <summary>Disable the custom color panel.</summary>
				CustomColorDisabled,
				/// <summary>Enable the custom color panel.</summary>
				CustomColorEnabled,
				/// <summary>Open the custom color panel at the beginning.</summary>
				CustomColorOpened,
			};

			/// <summary>Show a color dialog.</summary>
			/// <returns>Returns true if the user selected the OK button.</returns>
			/// <param name="window">The current window.</param>
			/// <param name="selection">The color that the user selected.</param>
			/// <param name="selected">Make the color dialog selected the color specified in the "selection" parameter at the beginning.</param>
			/// <param name="customColorOptions">Custom color panel options.</param>
			/// <param name="customColors">The initial 16 colors in custom color boxes. This argument can be null.</param>
			virtual bool							ShowColorDialog(INativeWindow* window, Color& selection, bool selected=false, ColorDialogCustomColorOptions customColorOptions=CustomColorEnabled, Color* customColors=0)=0;

			/// <summary>Show a font dialog.</summary>
			/// <returns>Returns true if the user selected the OK button.</returns>
			/// <param name="window">The current window.</param>
			/// <param name="selectionFont">The font that the user selected.</param>
			/// <param name="selectionColor">The color that the user selected.</param>
			/// <param name="selected">Make the font dialog selected the font specified in the "selectionFont" and "selectionColor" parameters at the beginning.</param>
			/// <param name="showEffect">Enable the user to edit some extended font properties.</param>
			/// <param name="forceFontExist">Force the user to select existing font.</param>
			virtual bool							ShowFontDialog(INativeWindow* window, FontProperties& selectionFont, Color& selectionColor, bool selected=false, bool showEffect=true, bool forceFontExist=true)=0;
			
			/// <summary>
			/// File dialog type.
			/// </summary>
			enum FileDialogTypes
			{
				/// <summary>Open file dialog.</summary>
				FileDialogOpen,
				/// <summary>Open file dialog with preview.</summary>
				FileDialogOpenPreview,
				/// <summary>Save file dialog.</summary>
				FileDialogSave,
				/// <summary>Save file dialog with preview.</summary>
				FileDialogSavePreview,
			};

			/// <summary>
			/// File dialog option flags.
			/// </summary>
			enum FileDialogOptions
			{
				/// <summary>No option are selected.</summary>
				None = 0,
				/// <summary>Allow multiple selection.</summary>
				FileDialogAllowMultipleSelection = 1,
				/// <summary>Prevent the user to select unexisting files.</summary>
				FileDialogFileMustExist = 2,
				/// <summary>Show the "Read Only" check box.</summary>
				FileDialogShowReadOnlyCheckBox = 4,
				/// <summary>Dereference link files.</summary>
				FileDialogDereferenceLinks = 8,
				/// <summary>Show the "Network" button.</summary>
				FileDialogShowNetworkButton = 16,
				/// <summary>Prompt if a new file is going to be created.</summary>
				FileDialogPromptCreateFile = 32,
				/// <summary>Promt if a existing file is going to be overwritten.</summary>
				FileDialogPromptOverwriteFile = 64,
				/// <summary>Prevent the user to select an unexisting directory.</summary>
				FileDialogDirectoryMustExist = 128,
				/// <summary>Add user selected files to "Recent" directory.</summary>
				FileDialogAddToRecent = 256,
			};

			/// <summary>Show a file dialog.</summary>
			/// <returns>Returns true if the user selected the OK button.</returns>
			/// <param name="window">The current window.</param>
			/// <param name="selectionFileNames">The file names that the user selected.</param>
			/// <param name="selectionFilterIndex">The filter that the user selected.</param>
			/// <param name="dialogType">The type of the file dialog.</param>
			/// <param name="title">The title of the file dialog.</param>
			/// <param name="initialFileName">The initial file name.</param>
			/// <param name="initialDirectory">The initial directory.</param>
			/// <param name="defaultExtension">The default file extension.</param>
			/// <param name="filter">The file name filter like L"Text Files|*.txt|All Files|*.*".</param>
			/// <param name="options">File dialog options. Multiple options can be combined using the "|" operator.</param>
			virtual bool							ShowFileDialog(INativeWindow* window, collections::List<WString>& selectionFileNames, vint& selectionFilterIndex, FileDialogTypes dialogType, const WString& title, const WString& initialFileName, const WString& initialDirectory, const WString& defaultExtension, const WString& filter, FileDialogOptions options)=0;
		};

		inline INativeDialogService::FileDialogOptions operator|(INativeDialogService::FileDialogOptions a, INativeDialogService::FileDialogOptions b)
		{
			return static_cast<INativeDialogService::FileDialogOptions>(static_cast<vuint64_t>(a) | static_cast<vuint64_t>(b));
		}

		inline INativeDialogService::FileDialogOptions operator&(INativeDialogService::FileDialogOptions a, INativeDialogService::FileDialogOptions b)
		{
			return static_cast<INativeDialogService::FileDialogOptions>(static_cast<vuint64_t>(a) & static_cast<vuint64_t>(b));
		}

/***********************************************************************
Native Window Controller
***********************************************************************/

		/// <summary>
		/// Global native system service controller. Use [M:vl.presentation.GetCurrentController] to access this controller.
		/// </summary>
		class INativeController : public virtual IDescriptable, public Description<INativeController>
		{
		public:
			/// <summary>
			/// Get the callback service.
			/// </summary>
			/// <returns>The callback service</returns>
			virtual INativeCallbackService*			CallbackService()=0;
			/// <summary>
			/// Get the system resource service.
			/// </summary>
			/// <returns>The system resource service</returns>
			virtual INativeResourceService*			ResourceService()=0;
			/// <summary>
			/// Get the asynchronized operation service.
			/// </summary>
			/// <returns>The asynchronized operation service</returns>
			virtual INativeAsyncService*			AsyncService()=0;
			/// <summary>
			/// Get the clipboard service.
			/// </summary>
			/// <returns>The clipboard service</returns>
			virtual INativeClipboardService*		ClipboardService()=0;
			/// <summary>
			/// Get the image service.
			/// </summary>
			/// <returns>The image service</returns>
			virtual INativeImageService*			ImageService()=0;
			/// <summary>
			/// Get the screen information service.
			/// </summary>
			/// <returns>The screen information service</returns>
			virtual INativeScreenService*			ScreenService()=0;
			/// <summary>
			/// Get the window service.
			/// </summary>
			/// <returns>The window service</returns>
			virtual INativeWindowService*			WindowService()=0;
			/// <summary>
			/// Get the user input service.
			/// </summary>
			/// <returns>The user input service</returns>
			virtual INativeInputService*			InputService()=0;
			/// <summary>
			/// Get the dialog service.
			/// </summary>
			/// <returns>The user dialog service</returns>
			virtual INativeDialogService*			DialogService()=0;
			/// <summary>
			/// Get the file path of the current executable.
			/// </summary>
			/// <returns>The file path of the current executable.</returns>
			virtual WString							GetExecutablePath()=0;
		};
		
		/// <summary>
		/// Represents a global message listener to an <see cref="INativeController"/>.
		/// </summary>
		class INativeControllerListener : public Interface
		{
		public:
			/// <summary>
			/// Called when the global timer message raised. To receive or not receive this message, use <see cref="INativeInputService::StartTimer"/> or <see cref="INativeInputService::StopTimer"/>
			/// </summary>
			virtual void					GlobalTimer();
			/// <summary>
			/// Called when the content of the clipboard is updated.
			/// </summary>
			virtual void					ClipboardUpdated();
			/// <summary>
			/// Called when a registered system-wide shortcut key is activated.
			/// </summary>
			/// <param name="id"></param>
			virtual void					GlobalShortcutKeyActivated(vint id);
			/// <summary>
			/// Called when a window is created.
			/// </summary>
			/// <param name="window">The created window.</param>
			virtual void					NativeWindowCreated(INativeWindow* window);
			/// <summary>
			/// Called when a window is destroying.
			/// </summary>
			/// <param name="window">The destroying window.</param>
			virtual void					NativeWindowDestroying(INativeWindow* window);
		};

		/// <summary>
		/// Get the global native system service controller.
		/// </summary>
		/// <returns>The global native system service controller.</returns>
		extern								INativeController* GetCurrentController();
		/// <summary>
		/// Set the global native system service controller.
		/// </summary>
		/// <param name="controller">The global native system service controller.</param>
		extern void							SetNativeController(INativeController* controller);

#define GUI_SUBSTITUTABLE_SERVICES(F)	\
		F(Clipboard)					\
		F(Dialog)						\

#define GUI_UNSUBSTITUTABLE_SERVICES(F)	\
		F(Callback)						\
		F(Resource)						\
		F(Async)						\
		F(Image)						\
		F(Screen)						\
		F(Window)						\
		F(Input)						\

		class INativeServiceSubstitution : public Interface
		{
		public:

#define SUBSTITUTE_SERVICE(NAME)																			\
			virtual void					Substitute(INative##NAME##Service* service, bool optional) = 0;	\
			virtual void					Unsubstitute(INative##NAME##Service* service) = 0;				\

			GUI_SUBSTITUTABLE_SERVICES(SUBSTITUTE_SERVICE)
#undef SUBSTITUTE_SERVICE
		};

		extern INativeServiceSubstitution*	GetNativeServiceSubstitution();

/***********************************************************************
NativeImageFrameBase
***********************************************************************/

		/// <summary>
		/// A partial implementation for <see cref="INativeImageFrame"/>.
		/// </summary>
		class NativeImageFrameBase : public Object, public virtual INativeImageFrame
		{
			collections::Dictionary<void*, Ptr<INativeImageFrameCache>>		caches;
		public:
			NativeImageFrameBase();
			~NativeImageFrameBase();

			bool							SetCache(void* key, Ptr<INativeImageFrameCache> cache) override;
			Ptr<INativeImageFrameCache>		GetCache(void* key) override;
			Ptr<INativeImageFrameCache>		RemoveCache(void* key) override;
		};

/***********************************************************************
Helper Functions
***********************************************************************/

		/// <summary>
		/// Get a cursor according to the hit test result.
		/// </summary>
		/// <param name="hitTestResult">The hit test result.</param>
		/// <param name="resourceService">The resource service to get cursors.</param>
		/// <returns>Returns the cursor according to the hit test result. It could return nullptr when the cursor is not defined.</returns>
		extern INativeCursor*				GetCursorFromHitTest(INativeWindowListener::HitTestResult hitTestResult, INativeResourceService* resourceService);

		/// <summary>
		/// A helper function calling multiple <see cref="INativeWindowListener::HitTest"/>.
		/// </summary>
		/// <returns>The hit test result.</returns>
		template<typename T>
		INativeWindowListener::HitTestResult PerformHitTest(collections::LazyList<T> listeners, NativePoint location)
		{
			auto hitTestResult = INativeWindowListener::NoDecision;
			for (auto listener : listeners)
			{
				auto singleResult = listener->HitTest(location);
				CHECK_ERROR(
					hitTestResult == INativeWindowListener::NoDecision || singleResult == INativeWindowListener::NoDecision,
					L"vl::presentation::PerformHitTest(LazyList<T>, NativePoint)#Incompatible INativeWindowListener::HitTest() callback results occured."
					);
				if (singleResult != INativeWindowListener::NoDecision)
				{
					hitTestResult = singleResult;
				}
			}
			return hitTestResult;
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSCOMPOSITIONS\GUIGRAPHICSEVENTRECEIVER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Event Model

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSEVENTRECEIVER
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSEVENTRECEIVER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace tree
			{
				class INodeProvider;
			}
		}
	}
}

namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsComposition;

/***********************************************************************
Event
***********************************************************************/

			class IGuiGraphicsEventHandler : public virtual IDescriptable, public Description<IGuiGraphicsEventHandler>
			{
			public:
				class Container
				{
				public:
					Ptr<IGuiGraphicsEventHandler>	handler;
				};

				virtual bool IsAttached() = 0;
			};

			template<typename T>
			class GuiGraphicsEvent : public Object, public Description<GuiGraphicsEvent<T>>
			{
			public:
				typedef void(RawFunctionType)(GuiGraphicsComposition*, T&);
				typedef Func<RawFunctionType>						FunctionType;
				typedef T											ArgumentType;
				
				class FunctionHandler : public Object, public IGuiGraphicsEventHandler
				{
				public:
					bool					isAttached = true;
					FunctionType			handler;

					FunctionHandler(const FunctionType& _handler)
						:handler(_handler)
					{
					}

					bool IsAttached()override
					{
						return isAttached;
					}

					void Execute(GuiGraphicsComposition* sender, T& argument)
					{
						handler(sender, argument);
					}
				};
			protected:
				struct HandlerNode
				{
					Ptr<FunctionHandler>								handler;
					Ptr<HandlerNode>									next;
				};

				GuiGraphicsComposition*									sender;
				Ptr<HandlerNode>										handlers;

				bool Attach(Ptr<FunctionHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler = &handlers;
					while (*currentHandler)
					{
						if ((*currentHandler)->handler == handler)
						{
							return false;
						}
						else
						{
							currentHandler = &(*currentHandler)->next;
						}
					}
					(*currentHandler) = Ptr(new HandlerNode);
					(*currentHandler)->handler = handler;
					return true;
				}
			public:
				GuiGraphicsEvent(GuiGraphicsComposition* _sender=0)
					:sender(_sender)
				{
				}

				~GuiGraphicsEvent()
				{
				}

				GuiGraphicsComposition* GetAssociatedComposition()
				{
					return sender;
				}

				void SetAssociatedComposition(GuiGraphicsComposition* _sender)
				{
					sender=_sender;
				}

				template<typename TClass, typename TMethod>
				Ptr<IGuiGraphicsEventHandler> AttachMethod(TClass* receiver, TMethod TClass::* method)
				{
					auto handler=Ptr(new FunctionHandler(FunctionType(receiver, method)));
					Attach(handler);
					return handler;
				}

				Ptr<IGuiGraphicsEventHandler> AttachFunction(RawFunctionType* function)
				{
					auto handler = Ptr(new FunctionHandler(FunctionType(function)));
					Attach(handler);
					return handler;
				}

				Ptr<IGuiGraphicsEventHandler> AttachFunction(const FunctionType& function)
				{
					auto handler = Ptr(new FunctionHandler(function));
					Attach(handler);
					return handler;
				}

				template<typename TLambda>
				Ptr<IGuiGraphicsEventHandler> AttachLambda(const TLambda& lambda)
				{
					auto handler = Ptr(new FunctionHandler(FunctionType(lambda)));
					Attach(handler);
					return handler;
				}

				bool Detach(Ptr<IGuiGraphicsEventHandler> handler)
				{
					auto typedHandler = handler.Cast<FunctionHandler>();
					if (!typedHandler)
					{
						return false;
					}

					auto currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler == typedHandler)
						{
							(*currentHandler)->handler->isAttached = false;

							auto next=(*currentHandler)->next;
							(*currentHandler)=next;
							return true;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					return false;
				}

				void ExecuteWithNewSender(T& argument, GuiGraphicsComposition* newSender)
				{
					auto currentHandler=&handlers;
					while(*currentHandler)
					{
						(*currentHandler)->handler->Execute(newSender?newSender:sender, argument);
						currentHandler=&(*currentHandler)->next;
					}
				}

				void Execute(T& argument)
				{
					ExecuteWithNewSender(argument, 0);
				}

				void Execute(const T& argument)
				{
					auto t = argument;
					ExecuteWithNewSender(t, 0);
				}
			};

/***********************************************************************
Predefined Events
***********************************************************************/

			/// <summary>Notify event arguments.</summary>
			struct GuiEventArgs : public Object, public AggregatableDescription<GuiEventArgs>
			{
				/// <summary>The event raiser composition.</summary>
				GuiGraphicsComposition*		compositionSource;
				/// <summary>The nearest parent of the event raiser composition that contains an event receiver. If the event raiser composition contains an event receiver, it will be the event raiser composition.</summary>
				GuiGraphicsComposition*		eventSource;
				/// <summary>Set this field to true will stop the event routing. This is a signal that the event is properly handeled, and the event handler want to override the default behavior.</summary>
				bool						handled;

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiEventArgs()
					:compositionSource(0)
					,eventSource(0)
					,handled(false)
				{
				}

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiEventArgs(GuiGraphicsComposition* composition)
					:compositionSource(composition)
					,eventSource(composition)
					,handled(false)
				{
				}

				~GuiEventArgs()
				{
					FinalizeAggregation();
				}
			};
			
			/// <summary>Request event arguments.</summary>
			struct GuiRequestEventArgs : public GuiEventArgs, public Description<GuiRequestEventArgs>
			{
				/// <summary>Set this field to false in event handlers will stop the corresponding action.</summary>
				bool		cancel;
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiRequestEventArgs()
					:cancel(false)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiRequestEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,cancel(false)
				{
				}
			};
			
			/// <summary>Keyboard event arguments.</summary>
			struct GuiKeyEventArgs : public GuiEventArgs, public WindowKeyInfo, public Description<GuiKeyEventArgs>
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiKeyEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiKeyEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Char input event arguments.</summary>
			struct GuiCharEventArgs : public GuiEventArgs, public WindowCharInfo, public Description<GuiCharEventArgs>
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiCharEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiCharEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			/// <summary>Mouse event arguments.</summary>
			struct GuiMouseEventArgs : public GuiEventArgs, public WindowMouseInfo, public Description<GuiMouseEventArgs>
			{
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiMouseEventArgs()
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			/// <summary>Control signal.</summary>
			enum class ControlSignal
			{
				/// <summary>Render target changed.</summary>
				RenderTargetChanged,
				/// <summary>Render target changed.</summary>
				ParentLineChanged,
				/// <summary>Service added changed.</summary>
				ServiceAdded,
				/// <summary>The window need to update when data or layout is changed. This even only triggered on <see cref="controls::GuiControlHost"/>.</summary>
				UpdateRequested,
				/// <summary>The window finished all the updating works after data or layout is changed. This even only triggered on <see cref="controls::GuiControlHost"/>.</summary>
				UpdateFullfilled,
			};

			/// <summary>Control signal event arguments.</summary>
			struct GuiControlSignalEventArgs : public GuiEventArgs, public Description<GuiControlSignalEventArgs>
			{
				/// <summary>The event raiser composition.</summary>
				ControlSignal				controlSignal = ControlSignal::ParentLineChanged;

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to null.</summary>
				GuiControlSignalEventArgs()
				{
				}

				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiControlSignalEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiEventArgs>				GuiNotifyEvent;
			typedef GuiGraphicsEvent<GuiRequestEventArgs>		GuiRequestEvent;
			typedef GuiGraphicsEvent<GuiKeyEventArgs>			GuiKeyEvent;
			typedef GuiGraphicsEvent<GuiCharEventArgs>			GuiCharEvent;
			typedef GuiGraphicsEvent<GuiMouseEventArgs>			GuiMouseEvent;
			typedef GuiGraphicsEvent<GuiControlSignalEventArgs>	GuiControlSignalEvent;

/***********************************************************************
Predefined Item Events
***********************************************************************/
			
			/// <summary>Item event arguments.</summary>
			struct GuiItemEventArgs : public GuiEventArgs, public Description<GuiItemEventArgs>
			{
				/// <summary>Item index.</summary>
				vint			itemIndex;

				GuiItemEventArgs()
					:itemIndex(-1)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiItemEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};
			
			/// <summary>Item mouse event arguments.</summary>
			struct GuiItemMouseEventArgs : public GuiMouseEventArgs, public Description<GuiItemMouseEventArgs>
			{
				/// <summary>Item index.</summary>
				vint			itemIndex;

				GuiItemMouseEventArgs()
					:itemIndex(-1)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiItemMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiItemEventArgs>			GuiItemNotifyEvent;
			typedef GuiGraphicsEvent<GuiItemMouseEventArgs>		GuiItemMouseEvent;

/***********************************************************************
Predefined Node Events
***********************************************************************/
			
			/// <summary>Node event arguments.</summary>
			struct GuiNodeEventArgs : public GuiEventArgs, public Description<GuiNodeEventArgs>
			{
				/// <summary>Tree node.</summary>
				controls::tree::INodeProvider*		node;

				GuiNodeEventArgs()
					:node(0)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiNodeEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,node(0)
				{
				}
			};
			
			/// <summary>Node mouse event arguments.</summary>
			struct GuiNodeMouseEventArgs : public GuiMouseEventArgs, public Description<GuiNodeMouseEventArgs>
			{
				/// <summary>Tree node.</summary>
				controls::tree::INodeProvider*		node;

				GuiNodeMouseEventArgs()
					:node(0)
				{
				}
				
				/// <summary>Create an event arguments with <see cref="compositionSource"/> and <see cref="eventSource"/> set to a specified value.</summary>
				/// <param name="composition">The speciied value to set <see cref="compositionSource"/> and <see cref="eventSource"/>.</param>
				GuiNodeMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,node(0)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiNodeEventArgs>			GuiNodeNotifyEvent;
			typedef GuiGraphicsEvent<GuiNodeMouseEventArgs>		GuiNodeMouseEvent;

/***********************************************************************
Event Receiver
***********************************************************************/

			/// <summary>
			/// Contains all available user input events for a <see cref="GuiGraphicsComposition"/>. Almost all events are routed events. Routed events means, not only the activated composition receives the event, all it direct or indirect parents receives the event. The argument(all derives from <see cref="GuiEventArgs"/>) for the event will store the original event raiser composition.
			/// </summary>
			class GuiGraphicsEventReceiver : public Object
			{
			protected:
				GuiGraphicsComposition*			sender;
			public:
				GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender);
				~GuiGraphicsEventReceiver();

				GuiGraphicsComposition*			GetAssociatedComposition();

				/// <summary>Left mouse button down event.</summary>
				GuiMouseEvent					leftButtonDown;
				/// <summary>Left mouse button up event.</summary>
				GuiMouseEvent					leftButtonUp;
				/// <summary>Left mouse button double click event.</summary>
				GuiMouseEvent					leftButtonDoubleClick;
				/// <summary>Middle mouse button down event.</summary>
				GuiMouseEvent					middleButtonDown;
				/// <summary>Middle mouse button up event.</summary>
				GuiMouseEvent					middleButtonUp;
				/// <summary>Middle mouse button double click event.</summary>
				GuiMouseEvent					middleButtonDoubleClick;
				/// <summary>Right mouse button down event.</summary>
				GuiMouseEvent					rightButtonDown;
				/// <summary>Right mouse button up event.</summary>
				GuiMouseEvent					rightButtonUp;
				/// <summary>Right mouse button double click event.</summary>
				GuiMouseEvent					rightButtonDoubleClick;
				/// <summary>Horizontal wheel scrolling event.</summary>
				GuiMouseEvent					horizontalWheel;
				/// <summary>Vertical wheel scrolling event.</summary>
				GuiMouseEvent					verticalWheel;
				/// <summary>Mouse move event.</summary>
				GuiMouseEvent					mouseMove;
				/// <summary>Mouse enter event.</summary>
				GuiNotifyEvent					mouseEnter;
				/// <summary>Mouse leave event.</summary>
				GuiNotifyEvent					mouseLeave;
				
				/// <summary>Preview key event.</summary>
				GuiKeyEvent						previewKey;
				/// <summary>Key down event.</summary>
				GuiKeyEvent						keyDown;
				/// <summary>Key up event.</summary>
				GuiKeyEvent						keyUp;
				/// <summary>Preview char input event.</summary>
				GuiCharEvent					previewCharInput;
				/// <summary>Char input event.</summary>
				GuiCharEvent					charInput;
				/// <summary>Got focus event.</summary>
				GuiNotifyEvent					gotFocus;
				/// <summary>Lost focus event.</summary>
				GuiNotifyEvent					lostFocus;
				/// <summary>Caret notify event. This event is raised when a caret graph need to change the visibility state.</summary>
				GuiNotifyEvent					caretNotify;
				/// <summary>Clipboard notify event. This event is raised when the content in the system clipboard is changed.</summary>
				GuiNotifyEvent					clipboardNotify;
				/// <summary>Render target changed event. This event is raised when the render target of this composition is changed.</summary>
				GuiNotifyEvent					renderTargetChanged;
			};
		}
	}

/***********************************************************************
Workflow to C++ Codegen Helpers
***********************************************************************/

	namespace __vwsn
	{
		template<typename T>
		struct EventHelper<presentation::compositions::GuiGraphicsEvent<T>>
		{
			using Event = presentation::compositions::GuiGraphicsEvent<T>;
			using Sender = presentation::compositions::GuiGraphicsComposition;
			using IGuiGraphicsEventHandler = presentation::compositions::IGuiGraphicsEventHandler;
			using Handler = Func<void(Sender*, T*)>;

			class EventHandlerImpl : public Object, public reflection::description::IEventHandler
			{
			public:
				Ptr<IGuiGraphicsEventHandler> handler;

				EventHandlerImpl(Ptr<IGuiGraphicsEventHandler> _handler)
					:handler(_handler)
				{
				}

				bool IsAttached()override
				{
					return handler->IsAttached();
				}
			};

			static Ptr<reflection::description::IEventHandler> Attach(Event& e, Handler handler)
			{
				return Ptr(new EventHandlerImpl(e.AttachLambda([=](Sender* sender, T& args)
				{
					handler(sender, &args);
				})));
			}

			static bool Detach(Event& e, Ptr<reflection::description::IEventHandler> handler)
			{
				auto impl = handler.Cast<EventHandlerImpl>();
				if (!impl) return false;
				return e.Detach(impl->handler);
			}

			static auto Invoke(Event& e)
			{
				return [&](Sender* sender, T* args)
				{
					e.ExecuteWithNewSender(*args, sender);
				};
			}
		};
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSCOMPOSITIONS\GUIGRAPHICSCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSCOMPOSITION


namespace vl
{
	namespace presentation
	{
		template<typename T>
		using ItemProperty = Func<T(const reflection::description::Value&)>;

		template<typename T>
		using WritableItemProperty = Func<T(const reflection::description::Value&, T, bool)>;

		template<typename T>
		using TemplateProperty = Func<T*(const reflection::description::Value&)>;

		namespace templates
		{
			class GuiTemplate;
		}

		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{
			class GuiGraphicsComposition_Trivial;
			class GuiGraphicsComposition_Controlled;
			class GuiGraphicsComposition_Specialized;
			class GuiWindowComposition;
			class GuiGraphicsHost;

			extern void				InvokeOnCompositionStateChanged(compositions::GuiGraphicsComposition* composition);

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// Represents a composition for <see cref="elements::IGuiGraphicsElement"/>. A composition is a way to define the size and the position using the information from graphics elements and sub compositions.
			/// When a graphics composition is destroyed, all sub composition will be destroyed. The life cycle of the contained graphics element is partially controlled by the smart pointer to the graphics element inside the composition.
			/// </summary>
			class GuiGraphicsComposition : public Object, public Description<GuiGraphicsComposition>
			{
				typedef collections::List<GuiGraphicsComposition*> CompositionList;

				friend class GuiGraphicsComposition_Trivial;
				friend class GuiGraphicsComposition_Controlled;
				friend class GuiGraphicsComposition_Specialized;
				friend class GuiWindowComposition;
				friend class controls::GuiControl;
				friend class GuiGraphicsHost;

				friend void InvokeOnCompositionStateChanged(compositions::GuiGraphicsComposition* composition);
			public:
				/// <summary>
				/// Minimum size limitation.
				/// </summary>
				enum MinSizeLimitation
				{
					/// <summary>No limitation for the minimum size.</summary>
					NoLimit,
					/// <summary>Minimum size of this composition is the minimum size of the contained graphics element.</summary>
					LimitToElement,
					/// <summary>Minimum size of this composition is combiniation of sub compositions and the minimum size of the contained graphics element.</summary>
					LimitToElementAndChildren,
				};

			protected:

				struct GraphicsHostRecord
				{
					GuiGraphicsHost*						host = nullptr;
					elements::IGuiGraphicsRenderTarget*		renderTarget = nullptr;
					INativeWindow*							nativeWindow = nullptr;
				};

			private:
				bool										isRendering = false;

				CompositionList								children;
				GuiGraphicsComposition*						parent = nullptr;
				Ptr<elements::IGuiGraphicsElement>			ownedElement;
				bool										visible = true;
				bool										transparentToMouse = false;
				MinSizeLimitation							minSizeLimitation = MinSizeLimitation::NoLimit;

				Ptr<compositions::GuiGraphicsEventReceiver>	eventReceiver;
				GraphicsHostRecord*							relatedHostRecord = nullptr;
				controls::GuiControl*						associatedControl = nullptr;
				INativeCursor*								associatedCursor = nullptr;
				INativeWindowListener::HitTestResult		associatedHitTestResult = INativeWindowListener::NoDecision;

			protected:
				Margin										internalMargin;
				Size										preferredMinSize;

				virtual void								OnControlParentChanged(controls::GuiControl* control);
				virtual void								OnChildInserted(GuiGraphicsComposition* child);
				virtual void								OnChildRemoved(GuiGraphicsComposition* child);
				virtual void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent);
				virtual void								OnParentLineChanged();
				virtual void								OnCompositionStateChanged();
				virtual void								OnRenderContextChanged();
				
				void										UpdateRelatedHostRecord(GraphicsHostRecord* record);
				void										SetAssociatedControl(controls::GuiControl* control);
				void										InvokeOnCompositionStateChanged(bool forceRequestRender = false);

			private:
				static bool									SharedPtrDestructorProc(DescriptableObject* obj, bool forceDisposing);

				GuiGraphicsComposition();
			public:
				~GuiGraphicsComposition();

				bool										IsRendering();

				/// <summary>Get the parent composition.</summary>
				/// <returns>The parent composition.</returns>
				GuiGraphicsComposition*						GetParent();
				/// <summary>Get all child compositions ordered by z-order from low to high.</summary>
				/// <returns>Child compositions.</returns>
				const CompositionList&						Children();
				/// <summary>Add a composition as a child.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to add.</param>
				bool										AddChild(GuiGraphicsComposition* child);
				/// <summary>Add a composition as a child with a specified z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The z-order. 0 means the lowest position.</param>
				/// <param name="child">The child composition to add.</param>
				bool										InsertChild(vint index, GuiGraphicsComposition* child);
				/// <summary>Remove a child composition.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to remove.</param>
				bool										RemoveChild(GuiGraphicsComposition* child);
				/// <summary>Move a child composition to a new z-order.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="child">The child composition to move.</param>
				/// <param name="newIndex">The new z-order. 0 means the lowest position.</param>
				bool										MoveChild(GuiGraphicsComposition* child, vint newIndex);

				/// <summary>Get the contained graphics element.</summary>
				/// <returns>The contained graphics element.</returns>
				Ptr<elements::IGuiGraphicsElement>			GetOwnedElement();
				/// <summary>Set the contained graphics element.</summary>
				/// <param name="element">The new graphics element to set.</param>
				void										SetOwnedElement(Ptr<elements::IGuiGraphicsElement> element);
				/// <summary>Get the visibility of the composition.</summary>
				/// <returns>Returns true if the composition is visible.</returns>
				bool										GetVisible();
				/// <summary>Set the visibility of the composition.</summary>
				/// <param name="value">Set to true to make the composition visible.</param>
				void										SetVisible(bool value);
				/// <summary>Get the visibility of the composition all the way to the root.</summary>
				/// <returns>Returns true if the composition and all ancestors are visible.</returns>
				bool										GetEventuallyVisible();
				/// <summary>Get the minimum size limitation of the composition.</summary>
				/// <returns>The minimum size limitation of the composition.</returns>
				MinSizeLimitation							GetMinSizeLimitation();
				/// <summary>Set the minimum size limitation of the composition.</summary>
				/// <param name="value">The minimum size limitation of the composition.</param>
				void										SetMinSizeLimitation(MinSizeLimitation value);
				/// <summary>Get the binded render target.</summary>
				/// <returns>The binded render target.</returns>
				elements::IGuiGraphicsRenderTarget*			GetRenderTarget();

				/// <summary>Render the composition using an offset.</summary>
				/// <param name="offset">The offset.</param>
				void										Render(Size offset);
				/// <summary>Get the event receiver object. All user input events can be found in this object. If an event receiver is never been requested from the composition, the event receiver will not be created, and all route events will not pass through this event receiver(performance will be better).</summary>
				/// <returns>The event receiver.</returns>
				compositions::GuiGraphicsEventReceiver*		GetEventReceiver();
				/// <summary>Test if any event receiver has already been requested.</summary>
				/// <returns>Returns true if any event receiver has already been requested.</returns>
				bool										HasEventReceiver();
				/// <summary>Find a deepest composition that under a specified location. If the location is inside a compsition but not hit any sub composition, this function will return this composition.</summary>
				/// <returns>The deepest composition that under a specified location.</returns>
				/// <param name="location">The specified location.</param>
				/// <param name="forMouseEvent">Find a composition for mouse event, it will ignore all compositions that are transparent to mouse events.</param>
				GuiGraphicsComposition*						FindVisibleComposition(Point location, bool forMouseEvent);
				/// <summary>Get is this composition transparent to mouse events.</summary>
				/// <returns>Returns true if this composition is transparent to mouse events, which means it just passes all mouse events to the composition under it.</returns>
				bool										GetTransparentToMouse();
				/// <summary>Set is the composition transparent to mouse events.</summary>
				/// <param name="value">Set to true to make this composition transparent to mouse events.</param>
				void										SetTransparentToMouse(bool value);

				/// <summary>Get the associated control. A control is associated to a composition only when the composition represents the bounds of this control. Such a composition usually comes from a control template.</summary>
				/// <returns>The associated control.</returns>
				controls::GuiControl*						GetAssociatedControl();
				/// <summary>Get the associated graphics host. A graphics host is associated to a composition only when the composition becomes the bounds of the graphics host.</summary>
				/// <returns>The associated graphics host.</returns>
				GuiGraphicsHost*							GetAssociatedHost();
				/// <summary>Get the associated cursor.</summary>
				/// <returns>The associated cursor.</returns>
				INativeCursor*								GetAssociatedCursor();
				/// <summary>Set the associated cursor.</summary>
				/// <param name="cursor">The associated cursor.</param>
				void										SetAssociatedCursor(INativeCursor* cursor);
				/// <summary>Get the associated hit test result.</summary>
				/// <returns>The associated hit test result.</returns>
				INativeWindowListener::HitTestResult		GetAssociatedHitTestResult();
				/// <summary>Set the associated hit test result.</summary>
				/// <param name="value">The associated hit test result.</param>
				void										SetAssociatedHitTestResult(INativeWindowListener::HitTestResult value);
				
				/// <summary>Get the related control. A related control is the deepest control that contains this composition.</summary>
				/// <returns>The related control.</returns>
				controls::GuiControl*						GetRelatedControl();
				/// <summary>Get the related graphics host. A related graphics host is the graphics host that contains this composition.</summary>
				/// <returns>The related graphics host.</returns>
				GuiGraphicsHost*							GetRelatedGraphicsHost();
				/// <summary>Get the related control host. A related control host is the control host that contains this composition.</summary>
				/// <returns>The related control host.</returns>
				controls::GuiControlHost*					GetRelatedControlHost();
				/// <summary>Get the related cursor. A related cursor is from the deepest composition that contains this composition and associated with a cursor.</summary>
				/// <returns>The related cursor.</returns>
				INativeCursor*								GetRelatedCursor();
				/// <summary>Get the related hit test result. A related hit test result is from the deepest composition that contains this composition and associated with a hit test result.</summary>
				/// <returns>The related hit test result.</returns>
				INativeWindowListener::HitTestResult		GetRelatedHitTestResult();
				
				/// <summary>Get the internal margin.</summary>
				/// <returns>The internal margin.</returns>
				Margin										GetInternalMargin();
				/// <summary>Set the internal margin.</summary>
				/// <param name="value">The internal margin.</param>
				void										SetInternalMargin(Margin value);
				/// <summary>Get the preferred minimum size.</summary>
				/// <returns>The preferred minimum size.</returns>
				Size										GetPreferredMinSize();
				/// <summary>Set the preferred minimum size.</summary>
				/// <param name="value">The preferred minimum size.</param>
				void										SetPreferredMinSize(Size value);

			protected:
				Size										cachedMinSize;
				Rect										cachedBounds;

				virtual Size								Layout_CalculateMinSize() = 0;
				virtual Size								Layout_CalculateMinClientSizeForParent(Margin parentInternalMargin) = 0;
				virtual Rect								Layout_CalculateBounds(Size parentSize) = 0;

				/// <summary>
				/// Calculate a proper minimum size using all configurations in this class.
				/// All children's <see cref="Layout_UpdateMinSize"/> will be called.
				/// All children's <see cref="Layout_CalculateMinClientSizeForParent"/> will be called.
				/// </summary>
				/// <returns></returns>
				Size										Layout_CalculateMinSizeHelper();

				/// <summary>
				/// Update a size that affects <see cref="GetCachedMinSize"/> and <see cref="GetCachedMinClientSize"/>.
				/// </summary>
				/// <param name="value">The minimum size to update</param>
				void										Layout_SetCachedMinSize(Size value);

				/// <summary>
				/// Update a bounds that affects <see cref="GetCachedBounds"/> and <see cref="GetCachedClientArea"/> and <see cref="GetGlobalBounds"/>.
				/// </summary>
				/// <param name="value">The minimum size to update</param>
				void										Layout_SetCachedBounds(Rect value);

				/// <summary>
				/// Call <see cref="Layout_CalculateMinSize"/> and <see cref="Layout_SetCachedMinSize"/>.
				/// </summary>
				void										Layout_UpdateMinSize();

				/// <summary>
				/// Call <see cref="Layout_CalculateBounds"/> and <see cref="Layout_SetCachedBounds"/> and all children's <see cref="Layout_UpdateBounds"/>.
				/// </summary>
				/// <param name="parentBounds"></param>
				void										Layout_UpdateBounds(Size parentSize);
			public:

				/// <summary>Event that will be raised when the minimum size is updated.</summary>
				compositions::GuiNotifyEvent				CachedMinSizeChanged;

				/// <summary>Event that will be raised when the bounds is updated.</summary>
				compositions::GuiNotifyEvent				CachedBoundsChanged;

				/// <summary>Get the updated minimum size.</summary>
				/// <returns>The updated minimum size.</returns>
				Size										GetCachedMinSize();

				/// <summary>Get the updated minimum client size. It is the minimum size removing the internal margin.</summary>
				/// <returns>The updated minimum client size.</returns>
				Size										GetCachedMinClientSize();

				/// <summary>Get the updated bounds.</summary>
				/// <returns>The updated bounds.</returns>
				Rect										GetCachedBounds();

				/// <summary>Get the updated client bounds. It is the bounds removing the internal margin.</summary>
				/// <returns>The updated client bounds.</returns>
				Rect										GetCachedClientArea();

				/// <summary>Get the bounds in the top composition space.</summary>
				/// <returns>The bounds in the top composition space.</returns>
				Rect										GetGlobalBounds();

				/// <summary>
				/// Force this composition calculate its layout.
				/// </summary>
				void										ForceCalculateSizeImmediately();
			};

/***********************************************************************
Categories
***********************************************************************/

			/// <summary>
			/// A trivial composition is a composition that can be placed anywhere needed.
			/// This class is not reflectable, it is for classification only.
			/// All controlled children's minimum sizes are supposed to be done in <see cref="Layout_CalculateMinSize"/>.
			/// All controlled children's bounds are supposed to be done in <see cref="Layout_CalculateBounds"/>.
			/// </summary>
			class GuiGraphicsComposition_Trivial : public GuiGraphicsComposition
			{
			protected:
				GuiGraphicsComposition_Trivial() = default;
			};

			/// <summary>
			/// A controlled composition is a composition that must be placed inside a certain type of parent composition.
			/// Its layout calculation are taken over by its parent.
			/// This class is not reflectable, it is for classification only.
			/// </summary>
			class GuiGraphicsComposition_Controlled : public GuiGraphicsComposition
			{
			protected:
				GuiGraphicsComposition_Controlled() = default;

				Size Layout_CalculateMinSize()override
				{
					// Making Layout_UpdateMinSize does nothing
					return cachedMinSize;
				}

				Size Layout_CalculateMinClientSizeForParent(Margin parentInternalMargin) override
				{
					// A controlled composition could affect its parent's layout
					// but it is done inside the parent
					return { 0,0 };
				}

				Rect Layout_CalculateBounds(Size parentSize) override
				{
					// Making Layout_UpdateBounds does nothing
					return cachedBounds;
				}
			};

			/// <summary>
			/// A specialized composition is a composition that can be placed anywhere needed.
			/// But its layout calculation are designed for special purposes.
			/// This class is not reflectable, it is for classification only.
			/// </summary>
			class GuiGraphicsComposition_Specialized : public GuiGraphicsComposition
			{
			protected:
				GuiGraphicsComposition_Specialized() = default;

				Size Layout_CalculateMinSize()override
				{
					return Layout_CalculateMinSizeHelper();
				}

				Size Layout_CalculateMinClientSizeForParent(Margin parentInternalMargin) override
				{
					// A controlled composition could not affect its parent's layout
					return { 0,0 };
				}
			};

/***********************************************************************
Helper Functions
***********************************************************************/

			/// <summary>Call [M:vl.presentation.controls.GuiInstanceRootObject.FinalizeInstance] in all child root objects.</summary>
			/// <param name="value">The container control to notify.</param>
			extern void								NotifyFinalizeInstance(controls::GuiControl* value);

			/// <summary>Call [M:vl.presentation.controls.GuiInstanceRootObject.FinalizeInstance] in all child root objects.</summary>
			/// <param name="value">The container composition to notify.</param>
			extern void								NotifyFinalizeInstance(GuiGraphicsComposition* value);

			/// <summary>Safely remove and delete a control.</summary>
			/// <param name="value">The control to delete.</param>
			extern void								SafeDeleteControl(controls::GuiControl* value);

			/// <summary>Safely remove and delete a composition. If some sub compositions are controls, those controls will be deleted too.</summary>
			/// <param name="value">The composition to delete.</param>
			extern void								SafeDeleteComposition(GuiGraphicsComposition* value);
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSCOMPOSITIONS\GUIGRAPHICSBOUNDSCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSBOUNDSCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSBOUNDSCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Basic Compositions
***********************************************************************/

			/// <summary>
			/// Represents a composition that is free to change the expected bounds.
			/// </summary>
			class GuiBoundsComposition : public GuiGraphicsComposition_Trivial, public Description<GuiBoundsComposition>
			{
			protected:
				Rect								expectedBounds;
				Margin								alignmentToParent{ -1,-1,-1,-1 };

				Size								Layout_CalculateMinSize() override;
				Size								Layout_CalculateMinClientSizeForParent(Margin parentInternalMargin) override;
				Rect								Layout_CalculateBounds(Size parentSize) override;
			public:
				GuiBoundsComposition() = default;
				~GuiBoundsComposition() = default;

				/// <summary>Get the expected bounds.</summary>
				/// <returns>The expected bounds.</returns>
				Rect								GetExpectedBounds();
				/// <summary>Set the expected bounds.</summary>
				/// <param name="value">The expected bounds.</param>
				void								SetExpectedBounds(Rect value);

				/// <summary>Get the alignment to its parent. -1 in each alignment component means that the corressponding side is not aligned to its parent.</summary>
				/// <returns>The alignment to its parent.</returns>
				Margin								GetAlignmentToParent();
				/// <summary>Set the alignment to its parent. -1 in each alignment component means that the corressponding side is not aligned to its parent.</summary>
				/// <param name="value">The alignment to its parent.</param>
				void								SetAlignmentToParent(Margin value);
				/// <summary>Test is the composition aligned to its parent.</summary>
				/// <returns>Returns true if the composition is aligned to its parent.</returns>
				bool								IsAlignedToParent();
			};
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSCOMPOSITIONS\GUIGRAPHICSWINDOWCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSCOMPOSITIONBASE
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSCOMPOSITIONBASE


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiGraphicsHost;

			/// <summary>
			/// Represents a composition for the client area in an <see cref="INativeWindow"/>.
			/// </summary>
			class GuiWindowComposition : public GuiGraphicsComposition_Specialized, public Description<GuiWindowComposition>
			{
				friend class GuiGraphicsHost;
			protected:
				Rect						Layout_CalculateBounds(Size parentSize) override;

			public:
				GuiWindowComposition() = default;
				~GuiWindowComposition() = default;
			};
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSHOST\GUIGRAPHICSHOST_ALT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_ALT
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_ALT


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{

/***********************************************************************
Alt-Combined Shortcut Key Interfaces
***********************************************************************/

			class IGuiAltActionHost;
			
			/// <summary>IGuiAltAction is the handler when an alt-combined shortcut key is activated.</summary>
			class IGuiAltAction : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				static bool								IsLegalAlt(const WString& alt);

				virtual const WString&					GetAlt() = 0;
				virtual bool							IsAltEnabled() = 0;
				virtual bool							IsAltAvailable() = 0;
				virtual GuiGraphicsComposition*			GetAltComposition() = 0;
				virtual IGuiAltActionHost*				GetActivatingAltHost() = 0;
				virtual void							OnActiveAlt() = 0;
			};
			
			/// <summary>IGuiAltActionContainer enumerates multiple <see cref="IGuiAltAction"/>.</summary>
			class IGuiAltActionContainer : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				virtual vint							GetAltActionCount() = 0;
				virtual IGuiAltAction*					GetAltAction(vint index) = 0;
			};
			
			/// <summary>IGuiAltActionHost is an alt-combined shortcut key host. A host can also be entered or leaved, with multiple sub actions enabled or disabled.</summary>
			class IGuiAltActionHost : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				static void								CollectAltActionsFromControl(controls::GuiControl* control, bool includeThisControl, collections::Group<WString, IGuiAltAction*>& actions);
				
				virtual GuiGraphicsComposition*			GetAltComposition() = 0;
				virtual IGuiAltActionHost*				GetPreviousAltHost() = 0;
				virtual void							OnActivatedAltHost(IGuiAltActionHost* previousHost) = 0;
				virtual void							OnDeactivatedAltHost() = 0;
				virtual void							CollectAltActions(collections::Group<WString, IGuiAltAction*>& actions) = 0;
			};

			/// <summary>Default implementation for <see cref="IGuiAltActionHost"/></summary>
			class GuiAltActionHostBase : public virtual IGuiAltActionHost
			{
			private:
				GuiGraphicsComposition*					composition = nullptr;
				controls::GuiControl*					control = nullptr;
				bool									includeControl = true;
				IGuiAltActionHost*						previousHost = nullptr;

			protected:
				void									SetAltComposition(GuiGraphicsComposition* _composition);
				void									SetAltControl(controls::GuiControl* _control, bool _includeControl);

			public:
				GuiGraphicsComposition*					GetAltComposition()override;
				IGuiAltActionHost*						GetPreviousAltHost()override;
				void									OnActivatedAltHost(IGuiAltActionHost* _previousHost)override;
				void									OnDeactivatedAltHost()override;
				void									CollectAltActions(collections::Group<WString, IGuiAltAction*>& actions)override;
			};

/***********************************************************************
Alt-Combined Shortcut Key Interfaces Helpers
***********************************************************************/

			class GuiAltActionManager : public Object
			{
				typedef collections::Dictionary<WString, IGuiAltAction*>					AltActionMap;
				typedef collections::Dictionary<WString, controls::GuiControl*>				AltControlMap;
			protected:
				controls::GuiControlHost*				controlHost = nullptr;
				IGuiAltActionHost*						currentAltHost = nullptr;
				AltActionMap							currentActiveAltActions;
				AltControlMap							currentActiveAltTitles;
				WString									currentAltPrefix;
				VKEY									supressAltKey = VKEY::KEY_UNKNOWN;

				void									EnterAltHost(IGuiAltActionHost* host);
				void									LeaveAltHost();
				bool									EnterAltKey(wchar_t key);
				void									LeaveAltKey();
				void									CreateAltTitles(const collections::Group<WString, IGuiAltAction*>& actions);
				vint									FilterTitles();
				void									ClearAltHost();
			public:
				GuiAltActionManager(controls::GuiControlHost* _controlHost);
				~GuiAltActionManager();

				void									CloseAltHost();
				bool									KeyDown(const NativeWindowKeyInfo& info);
				bool									KeyUp(const NativeWindowKeyInfo& info);
				bool									Char(const NativeWindowCharInfo& info);
			};
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSHOST\GUIGRAPHICSHOST_SHORTCUTKEY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_SHORTCUTKEY
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_SHORTCUTKEY


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Shortcut Key Manager
***********************************************************************/

			class IGuiShortcutKeyManager;

			/// <summary>Shortcut key item.</summary>
			class IGuiShortcutKeyItem : public virtual IDescriptable, public Description<IGuiShortcutKeyItem>
			{
			public:
				/// <summary>Shortcut key executed event.</summary>
				GuiNotifyEvent							Executed;

				/// <summary>Get the associated <see cref="IGuiShortcutKeyManager"/> object.</summary>
				/// <returns>The associated shortcut key manager.</returns>
				virtual IGuiShortcutKeyManager*			GetManager()=0;
				/// <summary>Get the name represents the shortcut key combination for this item.</summary>
				/// <returns>The name represents the shortcut key combination for this item.</returns>
				virtual WString							GetName()=0;
			};
			
			/// <summary>Shortcut key manager item.</summary>
			class IGuiShortcutKeyManager : public virtual IDescriptable, public Description<IGuiShortcutKeyManager>
			{
			public:
				/// <summary>Get the number of shortcut key items that already attached to the manager.</summary>
				/// <returns>T number of shortcut key items that already attached to the manager.</returns>
				virtual vint							GetItemCount()=0;
				/// <summary>Get the <see cref="IGuiShortcutKeyItem"/> associated with the index.</summary>
				/// <returns>The shortcut key item.</returns>
				/// <param name="index">The index.</param>
				virtual IGuiShortcutKeyItem*			GetItem(vint index)=0;
				/// <summary>Execute shortcut key items using a key event info.</summary>
				/// <returns>Returns true if at least one shortcut key item is executed.</returns>
				/// <param name="info">The key event info.</param>
				virtual bool							Execute(const NativeWindowKeyInfo& info)=0;
				
				/// <summary>Get a shortcut key item using a key combination. If the item for the key combination does not exist, this function returns null.</summary>
				/// <returns>The shortcut key item.</returns>
				/// <param name="ctrl">Set to true if the CTRL key is required.</param>
				/// <param name="shift">Set to true if the SHIFT key is required.</param>
				/// <param name="alt">Set to true if the ALT key is required.</param>
				/// <param name="key">The non-control key.</param>
				virtual IGuiShortcutKeyItem*			TryGetShortcut(bool ctrl, bool shift, bool alt, VKEY key)=0;
				/// <summary>Create a shortcut key item using a key combination. If the item for the key combination exists, this function crashes.</summary>
				/// <returns>The created shortcut key item.</returns>
				/// <param name="ctrl">Set to true if the CTRL key is required.</param>
				/// <param name="shift">Set to true if the SHIFT key is required.</param>
				/// <param name="alt">Set to true if the ALT key is required.</param>
				/// <param name="key">The non-control key.</param>
				virtual IGuiShortcutKeyItem*			CreateNewShortcut(bool ctrl, bool shift, bool alt, VKEY key)=0;
				/// <summary>Create a shortcut key item using a key combination. If the item for the key combination exists, this function returns the item that is created before.</summary>
				/// <returns>The created shortcut key item.</returns>
				/// <param name="ctrl">Set to true if the CTRL key is required.</param>
				/// <param name="shift">Set to true if the SHIFT key is required.</param>
				/// <param name="alt">Set to true if the ALT key is required.</param>
				/// <param name="key">The non-control key.</param>
				virtual IGuiShortcutKeyItem*			CreateShortcutIfNotExist(bool ctrl, bool shift, bool alt, VKEY key)=0;
				/// <summary>Destroy a shortcut key item using a key combination</summary>
				/// <returns>Returns true if the manager destroyed a existing shortcut key item.</returns>
				/// <param name="item">The shortcut key item.</param>
				virtual bool							DestroyShortcut(IGuiShortcutKeyItem* item)=0;
			};

/***********************************************************************
Shortcut Key Manager Helpers
***********************************************************************/

			class GuiShortcutKeyManager;

			class GuiShortcutKeyItem : public Object, public IGuiShortcutKeyItem
			{
			protected:
				GuiShortcutKeyManager*			shortcutKeyManager;
				bool							global;
				bool							ctrl;
				bool							shift;
				bool							alt;
				VKEY							key;

			public:
				GuiShortcutKeyItem(GuiShortcutKeyManager* _shortcutKeyManager, bool _global, bool _ctrl, bool _shift, bool _alt, VKEY _key);
				~GuiShortcutKeyItem();

				IGuiShortcutKeyManager*			GetManager()override;
				WString							GetName()override;

				void							ReadKeyConfig(bool& _ctrl, bool& _shift, bool& _alt, VKEY& _key);
				bool							CanActivate(const NativeWindowKeyInfo& info);
				bool							CanActivate(bool _ctrl, bool _shift, bool _alt, VKEY _key);
				void							Execute();
			};

			/// <summary>A default implementation for <see cref="IGuiShortcutKeyManager"/>.</summary>
			class GuiShortcutKeyManager : public Object, public IGuiShortcutKeyManager, public Description<GuiShortcutKeyManager>
			{
				typedef collections::List<Ptr<GuiShortcutKeyItem>>		ShortcutKeyItemList;
			protected:
				ShortcutKeyItemList				shortcutKeyItems;
				
				virtual bool					IsGlobal();
				virtual bool					OnCreatingShortcut(GuiShortcutKeyItem* item);
				virtual void					OnDestroyingShortcut(GuiShortcutKeyItem* item);
				IGuiShortcutKeyItem*			CreateShortcutInternal(bool ctrl, bool shift, bool alt, VKEY key);
			public:
				/// <summary>Create the shortcut key manager.</summary>
				GuiShortcutKeyManager();
				~GuiShortcutKeyManager();

				vint							GetItemCount()override;
				IGuiShortcutKeyItem*			GetItem(vint index)override;
				bool							Execute(const NativeWindowKeyInfo& info)override;
				
				IGuiShortcutKeyItem*			TryGetShortcut(bool ctrl, bool shift, bool alt, VKEY key)override;
				IGuiShortcutKeyItem*			CreateNewShortcut(bool ctrl, bool shift, bool alt, VKEY key)override;
				IGuiShortcutKeyItem*			CreateShortcutIfNotExist(bool ctrl, bool shift, bool alt, VKEY key)override;
				bool							DestroyShortcut(IGuiShortcutKeyItem* item)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSHOST\GUIGRAPHICSHOST_TAB.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_TAB
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST_TAB


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{

/***********************************************************************
Tab-Combined Shortcut Key Interfaces
***********************************************************************/
			
			/// <summary>IGuiTabAction is the handler when an tab-combined shortcut key is activated.</summary>
			class IGuiTabAction : public virtual IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				virtual bool							GetAcceptTabInput() = 0;
				virtual vint							GetTabPriority() = 0;
				virtual bool							IsTabEnabled() = 0;
				virtual bool							IsTabAvailable() = 0;
			};

/***********************************************************************
Tab-Combined Shortcut Key Interfaces Helpers
***********************************************************************/

			class GuiTabActionManager : public Object
			{
				using ControlList = collections::List<controls::GuiControl*>;
			protected:
				controls::GuiControlHost*				controlHost = nullptr;
				ControlList								controlsInOrder;
				bool									available = true;
				bool									supressTabOnce = false;

				void									BuildControlList();
				controls::GuiControl*					GetNextFocusControl(controls::GuiControl* focusedControl, vint offset);
			public:
				GuiTabActionManager(controls::GuiControlHost* _controlHost);
				~GuiTabActionManager();

				void									InvalidateTabOrderCache();
				bool									KeyDown(const NativeWindowKeyInfo& info, GuiGraphicsComposition* focusedComposition);
				bool									Char(const NativeWindowCharInfo& info);
			};
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\GRAPHICSHOST\GUIGRAPHICSHOST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST
#define VCZH_PRESENTATION_HOST_GUIGRAPHICSHOST


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiWindow;
		}

		namespace compositions
		{

/***********************************************************************
Animation
***********************************************************************/

			/// <summary>
			/// Represents a timer callback object.
			/// </summary>
			class IGuiGraphicsTimerCallback : public virtual IDescriptable, public Description<IGuiGraphicsTimerCallback>
			{
			public:
				/// <summary>Called periodically.</summary>
				/// <returns>Returns false to indicate that this callback need to be removed.</returns>
				virtual bool					Play() = 0;
			};

			/// <summary>
			/// Timer callback manager.
			/// </summary>
			class GuiGraphicsTimerManager : public Object, public Description<GuiGraphicsTimerManager>
			{
				typedef collections::List<Ptr<IGuiGraphicsTimerCallback>>		CallbackList;
			protected:
				CallbackList					callbacks;

			public:
				GuiGraphicsTimerManager();
				~GuiGraphicsTimerManager();

				/// <summary>Add a new callback.</summary>
				/// <param name="callback">The new callback to add.</param>
				void							AddCallback(Ptr<IGuiGraphicsTimerCallback> callback);
				/// <summary>Called periodically.</summary>
				void							Play();
			};

/***********************************************************************
Host
***********************************************************************/

			/// <summary>
			/// GuiGraphicsHost hosts an <see cref="GuiWindowComposition"/> in an <see cref="INativeWindow"/>. The composition will fill the whole window.
			/// </summary>
			class GuiGraphicsHost : public Object, private INativeWindowListener, private INativeControllerListener, public Description<GuiGraphicsHost>
			{
				typedef collections::List<GuiGraphicsComposition*>							CompositionList;
				typedef GuiGraphicsComposition::GraphicsHostRecord							HostRecord;
				typedef collections::Pair<DescriptableObject*, vint>						ProcKey;
				typedef collections::List<Func<void()>>										ProcList;
				typedef collections::Dictionary<ProcKey, Func<void()>>						ProcMap;
			public:
				static const vuint64_t					CaretInterval = 500;

			protected:
				HostRecord								hostRecord;
				bool									supressPaint = false;
				bool									needRender = true;
				bool									renderingTriggeredInLastFrame = false;
				ProcList								afterRenderProcs;
				ProcMap									afterRenderKeyedProcs;

				GuiAltActionManager*					altActionManager = nullptr;
				GuiTabActionManager*					tabActionManager = nullptr;
				IGuiShortcutKeyManager*					shortcutKeyManager = nullptr;

				controls::GuiControlHost*				controlHost = nullptr;
				GuiWindowComposition*					windowComposition = nullptr;
				GuiGraphicsComposition*					focusedComposition = nullptr;
				NativeSize								previousClientSize;
				Size									minSize;
				Point									caretPoint;
				vuint64_t								lastCaretTime = 0;

				GuiGraphicsTimerManager					timerManager;
				GuiGraphicsComposition*					mouseCaptureComposition = nullptr;
				CompositionList							mouseEnterCompositions;
				void									RefreshRelatedHostRecord(INativeWindow* nativeWindow);

				void									SetFocusInternal(GuiGraphicsComposition* composition);
				void									DisconnectCompositionInternal(GuiGraphicsComposition* composition);
				void									MouseCapture(const NativeWindowMouseInfo& info);
				void									MouseUncapture(const NativeWindowMouseInfo& info);
				void									OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnMouseInput(const NativeWindowMouseInfo& info, bool capture, bool release, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);

				void									ResetRenderTarget();
				void									CreateRenderTarget();
				
			private:
				INativeWindowListener::HitTestResult	HitTest(NativePoint location)override;
				void									Moving(NativeRect& bounds, bool fixSizeOnly, bool draggingBorder)override;
				void									Moved()override;
				void									DpiChanged(bool preparing)override;
				void									Paint()override;

				void									LeftButtonDown(const NativeWindowMouseInfo& info)override;
				void									LeftButtonUp(const NativeWindowMouseInfo& info)override;
				void									LeftButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									RightButtonDown(const NativeWindowMouseInfo& info)override;
				void									RightButtonUp(const NativeWindowMouseInfo& info)override;
				void									RightButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDown(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonUp(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									HorizontalWheel(const NativeWindowMouseInfo& info)override;
				void									VerticalWheel(const NativeWindowMouseInfo& info)override;
				void									MouseMoving(const NativeWindowMouseInfo& info)override;
				void									MouseEntered()override;
				void									MouseLeaved()override;

				void									KeyDown(const NativeWindowKeyInfo& info)override;
				void									KeyUp(const NativeWindowKeyInfo& info)override;
				void									Char(const NativeWindowCharInfo& info)override;

				bool									NeedRefresh()override;
				void									ForceRefresh(bool handleFailure, bool& updated, bool& failureByResized, bool& failureByLostDevice)override;
				void									GlobalTimer()override;

				elements::RenderTargetFailure			Render(bool forceUpdate, bool handleFailure, bool& updated);

			public:
				GuiGraphicsHost(controls::GuiControlHost* _controlHost, GuiGraphicsComposition* boundsComposition);
				~GuiGraphicsHost();

				/// <summary>Get the associated window.</summary>
				/// <returns>The associated window.</returns>
				INativeWindow*							GetNativeWindow();
				/// <summary>Associate a window. A <see cref="GuiWindowComposition"/> will fill and appear in the window.</summary>
				/// <param name="_nativeWindow">The window to associated.</param>
				void									SetNativeWindow(INativeWindow* _nativeWindow);
				/// <summary>Get the main <see cref="GuiWindowComposition"/>. If a window is associated, everything that put into the main composition will be shown in the window.</summary>
				/// <returns>The main compositoin.</returns>
				GuiGraphicsComposition*					GetMainComposition();
				/// <summary>Request rendering.</summary>
				void									RequestRender();
				/// <summary>Request updating sizes of compositions.</summary>
				void									RequestUpdateSizeFromNativeWindow();
				/// <summary>Invoke a specified function after rendering.</summary>
				/// <param name="proc">The specified function.</param>
				/// <param name="key">A key to cancel a previous binded key if not null.</param>
				void									InvokeAfterRendering(const Func<void()>& proc, ProcKey key = { nullptr,-1 });

				/// <summary>Invalidte the internal tab order control list. Next time when TAB is pressed it will be rebuilt.</summary>
				void									InvalidateTabOrderCache();
				/// <summary>Get the <see cref="IGuiShortcutKeyManager"/> attached with this graphics host.</summary>
				/// <returns>The shortcut key manager.</returns>
				IGuiShortcutKeyManager*					GetShortcutKeyManager();
				/// <summary>Attach or detach the <see cref="IGuiShortcutKeyManager"/> associated with this graphics host. When this graphics host is disposing, the associated shortcut key manager will be deleted if exists.</summary>
				/// <param name="value">The shortcut key manager. Set to null to detach the previous shortcut key manager from this graphics host.</param>
				void									SetShortcutKeyManager(IGuiShortcutKeyManager* value);

				/// <summary>Set the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="composition">The composition to set focus. This composition should be or in the main composition.</param>
				bool									SetFocus(GuiGraphicsComposition* composition);
				/// <summary>Unset the focus composition. There will be no focus composition.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool									ClearFocus();
				/// <summary>Get the focus composition. A focused composition will receive keyboard messages.</summary>
				/// <returns>The focus composition.</returns>
				GuiGraphicsComposition*					GetFocusedComposition();
				/// <summary>Get the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <returns>The caret point.</returns>
				Point									GetCaretPoint();
				/// <summary>Set the caret point. A caret point is the position to place the edit box of the activated input method editor.</summary>
				/// <param name="value">The caret point.</param>
				/// <param name="referenceComposition">The point space. If this argument is null, the "value" argument will use the point space of the client area in the main composition.</param>
				void									SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition=0);

				/// <summary>Get the timer manager.</summary>
				/// <returns>The timer manager.</returns>
				GuiGraphicsTimerManager*				GetTimerManager();
				/// <summary>Notify that a composition is going to disconnect from this graphics host. Generally this happens when a composition's parent line changes.</summary>
				/// <param name="composition">The composition to disconnect</param>
				void									DisconnectComposition(GuiGraphicsComposition* composition);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\INCLUDEFORWARD.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_INCLUDEFORWARD
#define VCZH_PRESENTATION_COMPOSITION_INCLUDEFORWARD


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiWindowComposition;

			class GuiTableComposition;
			class GuiCellComposition;
			class GuiTableSplitterCompositionBase;
			class GuiRowSplitterComposition;
			class GuiColumnSplitterComposition;

			class GuiStackComposition;
			class GuiStackItemComposition;
			class GuiFlowComposition;
			class GuiFlowItemComposition;

			class GuiSideAlignedComposition;
			class GuiPartialViewComposition;

			class GuiResponsiveCompositionBase;
			class GuiResponsiveViewComposition;
			class GuiResponsiveSharedComposition;
			class GuiResponsiveFixedComposition;
			class GuiResponsiveStackComposition;
			class GuiResponsiveGroupComposition;
			class GuiResponsiveContainerComposition;

			class GuiSharedSizeItemComposition;
			class GuiSharedSizeRootComposition;

			class GuiRepeatCompositionBase;
			class GuiNonVirtialRepeatCompositionBase;
			class GuiRepeatStackComposition;
			class GuiRepeatFlowComposition;
			class GuiVirtualRepeatCompositionBase;
			class GuiRepeatFreeHeightItemComposition;
			class GuiRepeatFixedHeightItemComposition;
			class GuiRepeatFixedSizeMultiColumnItemComposition;
			class GuiRepeatFixedHeightMultiColumnItemComposition;
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSFLOWCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSFLOWCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSFLOWCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
/***********************************************************************
Flow Compositions
***********************************************************************/

			/// <summary>
			/// Alignment for a row in a flow layout
			/// </summary>
			enum class FlowAlignment
			{
				/// <summary>Align to the left.</summary>
				Left,
				/// <summary>Align to the center.</summary>
				Center,
				/// <summary>Align to the Right.</summary>
				Right,
				/// <summary>Extend to the entire row.</summary>
				Extend,
			};
			
			/// <summary>
			/// Represents a flow composition.
			/// </summary>
			class GuiFlowComposition : public GuiBoundsComposition, public Description<GuiFlowComposition>
			{
				friend class GuiFlowItemComposition;

				typedef collections::List<GuiFlowItemComposition*>				ItemCompositionList;
			private:
				bool								layout_invalid = true;
				vint								layout_lastVirtualWidth = 0;
				ItemCompositionList					layout_flowItems;
				vint								layout_minVirtualHeight = 0;

				void								Layout_UpdateFlowItemLayout(vint maxVirtualWidth);
				Size								Layout_UpdateFlowItemLayoutByConstraint(Size constraintSize);

			protected:
				Margin								extraMargin;
				vint								rowPadding = 0;
				vint								columnPadding = 0;
				FlowAlignment						alignment = FlowAlignment::Left;
				Ptr<IGuiAxis>						axis = Ptr(new GuiDefaultAxis);

				void								OnChildInserted(GuiGraphicsComposition* child) override;
				void								OnChildRemoved(GuiGraphicsComposition* child) override;
				void								OnCompositionStateChanged() override;
				Size								Layout_CalculateMinSize() override;
				Rect								Layout_CalculateBounds(Size parentSize) override;
			public:
				GuiFlowComposition() = default;
				~GuiFlowComposition() = default;
				
				/// <summary>Get all flow items inside the flow composition.</summary>
				/// <returns>All flow items inside the flow composition.</returns>
				const ItemCompositionList&			GetFlowItems();
				/// <summary>Insert a flow item at a specified position.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The position.</param>
				/// <param name="item">The flow item to insert.</param>
				bool								InsertFlowItem(vint index, GuiFlowItemComposition* item);
				
				/// <summary>Get the extra margin inside the flow composition.</summary>
				/// <returns>The extra margin inside the flow composition.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin inside the flow composition.</summary>
				/// <param name="value">The extra margin inside the flow composition.</param>
				void								SetExtraMargin(Margin value);
				
				/// <summary>Get the distance between rows.</summary>
				/// <returns>The distance between rows.</returns>
				vint								GetRowPadding();
				/// <summary>Set the distance between rows.</summary>
				/// <param name="value">The distance between rows.</param>
				void								SetRowPadding(vint value);
				
				/// <summary>Get the distance between columns.</summary>
				/// <returns>The distance between columns.</returns>
				vint								GetColumnPadding();
				/// <summary>Set the distance between columns.</summary>
				/// <param name="value">The distance between columns.</param>
				void								SetColumnPadding(vint value);
				
				/// <summary>Get the axis of the layout.</summary>
				/// <returns>The axis.</returns>
				Ptr<IGuiAxis>						GetAxis();
				/// <summary>Set the axis of the layout.</summary>
				/// <param name="value">The axis.</param>
				void								SetAxis(Ptr<IGuiAxis> value);
				
				/// <summary>Get the alignment for rows.</summary>
				/// <returns>The alignment.</returns>
				FlowAlignment						GetAlignment();
				/// <summary>Set the alignment for rows.</summary>
				/// <param name="value">The alignment.</param>
				void								SetAlignment(FlowAlignment value);
			};
			
			/// <summary>
			/// Represnets a base line configuration for a flow item.
			/// </summary>
			struct GuiFlowOption
			{
				/// <summary>
				/// Specify the the relationship between this item and the baseline of the row that this item currently belongs to.
				/// The height of a row is the maximum value of minimum heights of all items in it.
				/// </summary>
				enum BaselineType
				{
					/// <summary>Top of this item is "percentage" times of the item height above the baseline.</summary>
					Percentage,
					/// <summary>Top of this item is "distance" above the baseline.</summary>
					FromTop,
					/// <summary>Bottom of this item is "distance" below the baseline.</summary>
					FromBottom,
				};
				
				/// <summary>The base line calculation algorithm.</summary>
				BaselineType						baseline = FromBottom;
				/// <summary>The percentage value.</summary>
				double								percentage = 0.0;
				/// <summary>The distance value.</summary>
				vint								distance = 0;

				GUI_DEFINE_COMPARE_OPERATORS(GuiFlowOption)
			};
			
			/// <summary>
			/// Represents a flow item composition of a <see cref="GuiFlowComposition"/>.
			/// </summary>
			class GuiFlowItemComposition : public GuiGraphicsComposition_Controlled, public Description<GuiFlowItemComposition>
			{
				friend class GuiFlowComposition;
			private:
				GuiFlowComposition*					layout_flowParent = nullptr;
				Rect								layout_virtualBounds;

				void								Layout_SetFlowItemBounds(Size contentSize, Rect virtualBounds);
			protected:
				Margin								extraMargin;
				GuiFlowOption						option;

				void								OnParentLineChanged() override;

			public:
				GuiFlowItemComposition();
				~GuiFlowItemComposition() = default;
				
				/// <summary>Get the extra margin for this flow item. An extra margin is used to enlarge the bounds of the flow item, but only the non-extra part will be used for deciding the flow item layout.</summary>
				/// <returns>The extra margin for this flow item.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin for this flow item. An extra margin is used to enlarge the bounds of the flow item, but only the non-extra part will be used for deciding the flow item layout.</summary>
				/// <param name="value">The extra margin for this flow item.</param>
				void								SetExtraMargin(Margin value);

				/// <summary>Get the base line option for this flow item.</summary>
				/// <returns>The base line option.</returns>
				GuiFlowOption						GetFlowOption();
				/// <summary>Set the base line option for this flow item.</summary>
				/// <param name="value">The base line option.</param>
				void								SetFlowOption(GuiFlowOption value);
			};
		}
	}
}

#endif


/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSRESPONSIVECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSRESPONSIVECOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSRESPONSIVECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
GuiResponsiveCompositionBase
***********************************************************************/

			enum class ResponsiveDirection
			{
				Horizontal = 1,
				Vertical = 2,
				Both = 3,
			};

			/// <summary>Base class for responsive layout compositions.</summary>
			class GuiResponsiveCompositionBase abstract : public GuiBoundsComposition, public Description<GuiResponsiveCompositionBase>
			{
				friend class GuiResponsiveContainerComposition;
			protected:
				GuiResponsiveCompositionBase*		responsiveParent = nullptr;
				ResponsiveDirection					direction = ResponsiveDirection::Both;

				void								OnParentLineChanged()override;
				virtual void						OnResponsiveChildInserted(GuiResponsiveCompositionBase* child);
				virtual void						OnResponsiveChildRemoved(GuiResponsiveCompositionBase* child);
				virtual void						OnResponsiveChildLevelUpdated();

			public:
				GuiResponsiveCompositionBase();
				~GuiResponsiveCompositionBase() = default;

				/// <summary>LevelCount changed event.</summary>
				GuiNotifyEvent						LevelCountChanged;
				/// <summary>CurrentLevel chagned event.</summary>
				GuiNotifyEvent						CurrentLevelChanged;

				/// <summary>Get the level count. A level count represents how many views this composition carries.</summary>
				/// <returns>The level count.</returns>
				virtual vint						GetLevelCount() = 0;
				/// <summary>Get the current level. Zero is the view with the smallest size.</summary>
				/// <returns>The current level.</returns>
				virtual vint						GetCurrentLevel() = 0;
				/// <summary>Switch to a smaller view.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool						LevelDown() = 0;
				/// <summary>Switch to a larger view.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				virtual bool						LevelUp() = 0;

				/// <summary>Get all supported directions. If all directions of a child [T:vl.presentation.compositions.GuiResponsiveCompositionBase] are not supported, its view will not be changed when the parent composition changes its view .</summary>
				/// <returns>All supported directions.</returns>
				ResponsiveDirection					GetDirection();
				/// <summary>Set all supported directions.</summary>
				/// <param name="value">All supported directions.</param>
				void								SetDirection(ResponsiveDirection value);
			};

/***********************************************************************
GuiResponsiveViewComposition
***********************************************************************/

			class GuiResponsiveSharedCollection : public collections::ObservableListBase<controls::GuiControl*>
			{
			protected:
				GuiResponsiveViewComposition*		view = nullptr;

				void								BeforeInsert(vint index, controls::GuiControl* const& value)override;
				void								AfterInsert(vint index, controls::GuiControl* const& value)override;
				void								BeforeRemove(vint index, controls::GuiControl* const& value)override;
				void								AfterRemove(vint index, vint count)override;

			public:
				GuiResponsiveSharedCollection(GuiResponsiveViewComposition* _view);
				~GuiResponsiveSharedCollection() = default;
			};

			class GuiResponsiveViewCollection : public collections::ObservableListBase<GuiResponsiveCompositionBase*>
			{
			protected:
				GuiResponsiveViewComposition*		view = nullptr;

				void								BeforeInsert(vint index, GuiResponsiveCompositionBase* const& value)override;
				void								AfterInsert(vint index, GuiResponsiveCompositionBase* const& value)override;
				void								BeforeRemove(vint index, GuiResponsiveCompositionBase* const& value)override;
				void								AfterRemove(vint index, vint count)override;

			public:
				GuiResponsiveViewCollection(GuiResponsiveViewComposition* _view);
				~GuiResponsiveViewCollection() = default;
			};

			/// <summary>Represents a composition, which will pick up a shared control and install inside it, when it is displayed by a [T:vl.presentation.compositions.GuiResponsiveViewComposition]</summary>
			class GuiResponsiveSharedComposition : public GuiBoundsComposition, public Description<GuiResponsiveSharedComposition>
			{
			protected:
				GuiResponsiveViewComposition*		view = nullptr;
				controls::GuiControl*				shared = nullptr;

				void								SetSharedControl();
				void								OnParentLineChanged()override;

			public:
				GuiResponsiveSharedComposition();
				~GuiResponsiveSharedComposition() = default;

				/// <summary>Get the selected shared control.</summary>
				/// <returns>The selected shared control.</returns>
				controls::GuiControl*				GetShared();
				/// <summary>Set the selected shared control, which should be stored in [M:vl.presentation.compositions.GuiResponsiveViewComposition.GetSharedControls].</summary>
				/// <param name="value">The selected shared control.</param>
				void								SetShared(controls::GuiControl* value);
			};

			/// <summary>A responsive layout composition defined by views of different sizes.</summary>
			class GuiResponsiveViewComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveViewComposition>
			{
				friend class GuiResponsiveSharedCollection;
				friend class GuiResponsiveViewCollection;
				friend class GuiResponsiveSharedComposition;
				using ControlSet = collections::SortedList<controls::GuiControl*>;
			protected:
				vint								levelCount = 1;
				vint								currentLevel = 0;
				bool								skipUpdatingLevels = false;
				GuiResponsiveCompositionBase*		currentView = nullptr;

				ControlSet							usedSharedControls;
				GuiResponsiveSharedCollection		sharedControls;
				GuiResponsiveViewCollection			views;
				bool								destructing = false;

				bool								CalculateLevelCount();
				bool								CalculateCurrentLevel();
				void								OnResponsiveChildLevelUpdated()override;

			public:
				GuiResponsiveViewComposition();
				~GuiResponsiveViewComposition();

				/// <summary>Before switch view event. This event happens between hiding the previous view and showing the next view. The itemIndex field can be used to access [M:vl.presentation.compositions.GuiResponsiveViewComposition.GetViews], it is not the level number.</summary>
				GuiItemNotifyEvent													BeforeSwitchingView;

				vint																GetLevelCount()override;
				vint																GetCurrentLevel()override;
				bool																LevelDown()override;
				bool																LevelUp()override;

				/// <summary>Get the current displaying view.</summary>
				/// <returns>The current displaying view.</returns>
				GuiResponsiveCompositionBase*										GetCurrentView();

				/// <summary>Get all shared controls. A shared control can jump between different views if it is contained in a [T:vl.presentation.compositions.GuiResponsiveSharedComposition]. This helps to keep control states during switching views.</summary>
				/// <returns>All shared controls.</returns>
				collections::ObservableListBase<controls::GuiControl*>&				GetSharedControls();

				/// <summary>Get all individual views to switch.</summary>
				/// <returns>All individual views to switch.</returns>
				collections::ObservableListBase<GuiResponsiveCompositionBase*>&		GetViews();
			};

/***********************************************************************
Others
***********************************************************************/

			/// <summary>A responsive layout composition which stop parent responsive composition to search its children.</summary>
			class GuiResponsiveFixedComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveFixedComposition>
			{
			protected:
				void					OnResponsiveChildLevelUpdated()override;

			public:
				GuiResponsiveFixedComposition() = default;
				~GuiResponsiveFixedComposition() = default;

				vint					GetLevelCount()override;
				vint					GetCurrentLevel()override;
				bool					LevelDown()override;
				bool					LevelUp()override;
			};

			/// <summary>A responsive layout composition which change its size by changing children's views one by one in one direction.</summary>
			class GuiResponsiveStackComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveStackComposition>
			{
				using ResponsiveChildList = collections::List<GuiResponsiveCompositionBase*>;
			protected:
				vint					levelCount = 1;
				vint					currentLevel = 0;
				ResponsiveChildList		responsiveChildren;

				bool					CalculateLevelCount();
				bool					CalculateCurrentLevel();
				void					OnResponsiveChildInserted(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildRemoved(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildLevelUpdated()override;
				bool					ChangeLevel(bool levelDown);

			public:
				GuiResponsiveStackComposition() = default;
				~GuiResponsiveStackComposition() = default;

				vint					GetLevelCount()override;
				vint					GetCurrentLevel()override;
				bool					LevelDown()override;
				bool					LevelUp()override;
			};

			/// <summary>A responsive layout composition which change its size by changing children's views at the same time.</summary>
			class GuiResponsiveGroupComposition : public GuiResponsiveCompositionBase, public Description<GuiResponsiveGroupComposition>
			{
				using ResponsiveChildList = collections::List<GuiResponsiveCompositionBase*>;
			protected:
				vint					levelCount = 1;
				vint					currentLevel = 0;
				ResponsiveChildList		responsiveChildren;

				bool					CalculateLevelCount();
				bool					CalculateCurrentLevel();
				void					OnResponsiveChildInserted(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildRemoved(GuiResponsiveCompositionBase* child)override;
				void					OnResponsiveChildLevelUpdated()override;

			public:
				GuiResponsiveGroupComposition() = default;
				~GuiResponsiveGroupComposition() = default;

				vint					GetLevelCount()override;
				vint					GetCurrentLevel()override;
				bool					LevelDown()override;
				bool					LevelUp()override;
			};

/***********************************************************************
GuiResponsiveContainerComposition
***********************************************************************/

			/// <summary>A composition which will automatically tell its target responsive composition to switch between views according to its size.</summary>
			class GuiResponsiveContainerComposition : public GuiBoundsComposition, public Description<GuiResponsiveContainerComposition>
			{
			private:
				GuiResponsiveCompositionBase*			responsiveTarget = nullptr;
				Size									minSizeUpperBound;
				Size									minSizeLowerBound;
				bool									testX = false;
				bool									testY = false;

				std::strong_ordering					Layout_CompareSize(Size first, Size second);
				void									Layout_AdjustLevelUp(Size containerSize);
				void									Layout_AdjustLevelDown(Size containerSize);
			public:
				Rect									Layout_CalculateBounds(Size parentSize) override;

			public:
				GuiResponsiveContainerComposition();
				~GuiResponsiveContainerComposition() = default;

				/// <summary>Get the responsive composition to control.</summary>
				/// <returns>The responsive composition to control.</returns>
				GuiResponsiveCompositionBase*			GetResponsiveTarget();
				/// <summary>Get the responsive composition to control.</summary>
				/// <param name="value">The responsive composition to control.</param>
				void									SetResponsiveTarget(GuiResponsiveCompositionBase* value);
			};
		}
	}
}

#endif


/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSSHAREDSIZECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSHAREDSIZECOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSHAREDSIZECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			/// <summary>A shared size composition that shares the same size with all other <see cref="GuiSharedSizeItemComposition"/> that has a same group name.</summary>
			class GuiSharedSizeItemComposition : public GuiBoundsComposition, public Description<GuiSharedSizeItemComposition>
			{
				friend class GuiSharedSizeRootComposition;
			protected:
				GuiSharedSizeRootComposition*						parentRoot = nullptr;
				WString												group;
				bool												sharedWidth = false;
				bool												sharedHeight = false;
				Size												originalMinSize;

				void												OnParentLineChanged() override;
				Size												Layout_CalculateMinSize() override;
				Size												Layout_CalculateOriginalMinSize();
			public:
				GuiSharedSizeItemComposition();
				~GuiSharedSizeItemComposition() = default;
				
				/// <summary>Get the group name of this item.</summary>
				/// <returns>The group name.</returns>
				const WString&										GetGroup();
				/// <summary>Set the group name of this item.</summary>
				/// <param name="value">The group name.</param>
				void												SetGroup(const WString& value);
				/// <summary>Test is the width of this item is shared.</summary>
				/// <returns>Returns true if the width of this item is shared.</returns>
				bool												GetSharedWidth();
				/// <summary>Enable or disable sharing the width of this item.</summary>
				/// <param name="value">Set to true to share the width of this item.</param>
				void												SetSharedWidth(bool value);
				/// <summary>Test is the height of this item is shared.</summary>
				/// <returns>Returns true if the height of this item is shared.</returns>
				bool												GetSharedHeight();
				/// <summary>Enable or disable sharing the height of this item.</summary>
				/// <param name="value">Set to true to share the height of this item.</param>
				void												SetSharedHeight(bool value);
			};

			/// <summary>A root composition that takes care of all direct or indirect <see cref="GuiSharedSizeItemComposition"/> to enable size sharing.</summary>
			class GuiSharedSizeRootComposition :public GuiBoundsComposition, public Description<GuiSharedSizeRootComposition>
			{
				friend class GuiSharedSizeItemComposition;
			protected:
				collections::Dictionary<WString, vint>				itemWidths;
				collections::Dictionary<WString, vint>				itemHeights;
				collections::List<GuiSharedSizeItemComposition*>	childItems;

				void												AddSizeComponent(collections::Dictionary<WString, vint>& sizes, const WString& group, vint sizeComponent);
				void												CalculateOriginalMinSizes();
				void												CollectSizes(collections::Dictionary<WString, vint>& widths, collections::Dictionary<WString, vint>& heights);
				void												AlignSizes(collections::Dictionary<WString, vint>& widths, collections::Dictionary<WString, vint>& heights);

				Size												Layout_CalculateMinSize() override;
			public:
				GuiSharedSizeRootComposition() = default;
				~GuiSharedSizeRootComposition() = default;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSSPECIALIZEDCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSPECIALIZEDCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSPECIALIZEDCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Specialized Compositions
***********************************************************************/

			/// <summary>
			/// Represents a composition that is aligned to one border of the parent composition.
			/// </summary>
			class GuiSideAlignedComposition : public GuiGraphicsComposition_Specialized, public Description<GuiSideAlignedComposition>
			{
			public:
				/// <summary>The border to align.</summary>
				enum Direction
				{
					/// <summary>The left border.</summary>
					Left,
					/// <summary>The top border.</summary>
					Top,
					/// <summary>The right border.</summary>
					Right,
					/// <summary>The bottom border.</summary>
					Bottom,
				};
			protected:
				Direction							direction = Top;
				vint								maxLength = 10;
				double								maxRatio = 1.0;

				Rect								Layout_CalculateBounds(Size parentSize) override;

			public:
				GuiSideAlignedComposition() = default;
				~GuiSideAlignedComposition() = default;
				
				/// <summary>Get the border to align.</summary>
				/// <returns>The border to align.</returns>
				Direction							GetDirection();
				/// <summary>Set the border to align.</summary>
				/// <param name="value">The border to align.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the maximum length of this composition.</summary>
				/// <returns>The maximum length of this composition.</returns>
				vint								GetMaxLength();
				/// <summary>Set the maximum length of this composition.</summary>
				/// <param name="value">The maximum length of this composition.</param>
				void								SetMaxLength(vint value);
				/// <summary>Get the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <returns>The maximum ratio to limit the size according to the size of the parent.</returns>
				double								GetMaxRatio();
				/// <summary>Set the maximum ratio to limit the size according to the size of the parent.</summary>
				/// <param name="value">The maximum ratio to limit the size according to the size of the parent.</param>
				void								SetMaxRatio(double value);
			};

			/// <summary>
			/// Represents a composition that its location and size are decided by the client area of the parent composition by setting ratios.
			/// </summary>
			class GuiPartialViewComposition : public GuiGraphicsComposition_Specialized, public Description<GuiPartialViewComposition>
			{
			protected:
				double								wRatio = 0.0;
				double								wPageSize = 1.0;
				double								hRatio = 0.0;
				double								hPageSize = 1.0;

				Rect								Layout_CalculateBounds(Size parentSize) override;

			public:
				GuiPartialViewComposition() = default;
				~GuiPartialViewComposition() = default;
				
				/// <summary>Get the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <returns>The width ratio to decided the horizontal location.</returns>
				double								GetWidthRatio();
				/// <summary>Get the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the horizontal size.</returns>
				double								GetWidthPageSize();
				/// <summary>Get the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <returns>The height ratio to decided the vertical location.</returns>
				double								GetHeightRatio();
				/// <summary>Get the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <returns>The page size to decide the vertical size.</returns>
				double								GetHeightPageSize();
				/// <summary>Set the width ratio to decided the horizontal location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The width ratio to decided the horizontal location.</param>
				void								SetWidthRatio(double value);
				/// <summary>Set the page size to decide the horizontal size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the horizontal size.</param>
				void								SetWidthPageSize(double value);
				/// <summary>Set the height ratio to decided the vertical location. Value in [0, 1-pageSize].</summary>
				/// <param name="value">The height ratio to decided the vertical location.</param>
				void								SetHeightRatio(double value);
				/// <summary>Set the page size to decide the vertical size. Value in [0, 1].</summary>
				/// <param name="value">The page size to decide the vertical size.</param>
				void								SetHeightPageSize(double value);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSSTACKCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSTACKCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSSTACKCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Stack Compositions
***********************************************************************/

			/// <summary>
			/// Represents a stack composition.
			/// </summary>
			class GuiStackComposition : public GuiBoundsComposition, public Description<GuiStackComposition>
			{
				friend class GuiStackItemComposition;

				typedef collections::List<GuiStackItemComposition*>				ItemCompositionList;
			public:
				/// <summary>Stack item layout direction.</summary>
				enum Direction
				{
					/// <summary>Stack items is layouted from left to right.</summary>
					Horizontal,
					/// <summary>Stack items is layouted from top to bottom.</summary>
					Vertical,
					/// <summary>Stack items is layouted from right to left.</summary>
					ReversedHorizontal,
					/// <summary>Stack items is layouted from bottom to top.</summary>
					ReversedVertical,
				};

			private:
				bool								layout_invalid = true;
				ItemCompositionList					layout_stackItems;
				GuiStackItemComposition*			layout_ensuringVisibleStackItem = nullptr;
				vint								layout_adjustment = 0;
				Size								layout_stackItemTotalSize;

				void								Layout_UpdateStackItemMinSizes();
				void								Layout_UpdateStackItemBounds(Rect contentBounds);
			protected:

				Direction							direction = Horizontal;
				vint								padding = 0;
				Margin								extraMargin;

				void								OnChildInserted(GuiGraphicsComposition* child) override;
				void								OnChildRemoved(GuiGraphicsComposition* child) override;
				void								OnCompositionStateChanged() override;
				Size								Layout_CalculateMinSize() override;
				Rect								Layout_CalculateBounds(Size parentSize) override;
			public:
				GuiStackComposition() = default;
				~GuiStackComposition() = default;

				/// <summary>Get all stack items inside the stack composition.</summary>
				/// <returns>All stack items inside the stack composition.</returns>
				const ItemCompositionList&			GetStackItems();
				/// <summary>Insert a stack item at a specified position.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The position.</param>
				/// <param name="item">The statck item to insert.</param>
				bool								InsertStackItem(vint index, GuiStackItemComposition* item);
				
				/// <summary>Get the stack item layout direction.</summary>
				/// <returns>The stack item layout direction.</returns>
				Direction							GetDirection();
				/// <summary>Set the stack item layout direction.</summary>
				/// <param name="value">The stack item layout direction.</param>
				void								SetDirection(Direction value);
				/// <summary>Get the stack item padding.</summary>
				/// <returns>The stack item padding.</returns>
				vint								GetPadding();
				/// <summary>Set the stack item padding.</summary>
				/// <param name="value">The stack item padding.</param>
				void								SetPadding(vint value);
				
				/// <summary>Get the extra margin inside the stack composition.</summary>
				/// <returns>The extra margin inside the stack composition.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin inside the stack composition.</summary>
				/// <param name="value">The extra margin inside the stack composition.</param>
				void								SetExtraMargin(Margin value);
				/// <summary>Test is any stack item clipped in the stack direction.</summary>
				/// <returns>Returns true if any stack item is clipped.</returns>
				bool								IsStackItemClipped();
				/// <summary>Make an item visible as complete as possible.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="index">The index of the item.</param>
				bool								EnsureVisible(vint index);
			};
			
			/// <summary>
			/// Represents a stack item composition of a <see cref="GuiStackComposition"/>.
			/// </summary>
			class GuiStackItemComposition : public GuiGraphicsComposition_Controlled, public Description<GuiStackItemComposition>
			{
				friend class GuiStackComposition;
			private:
				GuiStackComposition*				layout_stackParent = nullptr;
				Point								layout_virtualOffset;

				void								Layout_SetStackItemBounds(Rect contentBounds, Point virtualOffset);

			protected:
				Margin								extraMargin;

				void								OnParentLineChanged() override;
			public:
				GuiStackItemComposition();
				~GuiStackItemComposition() = default;
				
				/// <summary>Get the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for deciding the stack item layout.</summary>
				/// <returns>The extra margin for this stack item.</returns>
				Margin								GetExtraMargin();
				/// <summary>Set the extra margin for this stack item. An extra margin is used to enlarge the bounds of the stack item, but only the non-extra part will be used for deciding the stack item layout.</summary>
				/// <param name="value">The extra margin for this stack item.</param>
				void								SetExtraMargin(Margin value);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSREPEATCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSREPEATCOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSREPEATCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			/// <summary>A base class for all bindable repeat compositions.</summary>
			class GuiRepeatCompositionBase : public Object, public Description<GuiRepeatCompositionBase>
			{
				using ItemStyleProperty = TemplateProperty<templates::GuiTemplate>;
				using IValueEnumerable = reflection::description::IValueEnumerable;
				using IValueList = reflection::description::IValueList;
			protected:
				ItemStyleProperty									itemTemplate;
				Ptr<IValueList>										itemSource;
				description::Value									itemContext;
				Ptr<EventHandler>									itemChangedHandler;

				virtual void										OnItemChanged(vint index, vint oldCount, vint newCount) = 0;
				virtual void										OnClearItems() = 0;
				virtual void										OnInstallItems() = 0;
				virtual void										OnUpdateContext() = 0;
			public:
				GuiRepeatCompositionBase();
				~GuiRepeatCompositionBase();

				/// <summary>Context changed event. This event raises when the context of the composition is changed.</summary>
				GuiNotifyEvent										ContextChanged;

				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				ItemStyleProperty									GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				void												SetItemTemplate(ItemStyleProperty value);

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<IValueEnumerable>								GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="value">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<IValueEnumerable> value);

				/// <summary>Get the context of this composition. The all item templates (if it has) will see this context property.</summary>
				/// <returns>The context of this composition.</returns>
				description::Value									GetContext();
				/// <summary>Set the context of this composition.</summary>
				/// <param name="value">The context of this composition.</param>
				void												SetContext(const description::Value& value);
			};

/***********************************************************************
GuiNonVirtialRepeatCompositionBase
***********************************************************************/

			/// <summary>A base class for all bindable repeat compositions.</summary>
			class GuiNonVirtialRepeatCompositionBase : public GuiRepeatCompositionBase, public Description<GuiNonVirtialRepeatCompositionBase>
			{
			protected:

				virtual vint										GetRepeatCompositionCount() = 0;
				virtual GuiGraphicsComposition*						GetRepeatComposition(vint index) = 0;
				virtual GuiGraphicsComposition*						InsertRepeatComposition(vint index) = 0;
				virtual GuiGraphicsComposition*						RemoveRepeatComposition(vint index) = 0;

				void												OnItemChanged(vint index, vint oldCount, vint newCount) override;
				void												OnClearItems() override;
				void												OnInstallItems() override;
				void												OnUpdateContext() override;

				void												RemoveItem(vint index);
				void												InstallItem(vint index);
			public:
				GuiNonVirtialRepeatCompositionBase();
				~GuiNonVirtialRepeatCompositionBase();

				/// <summary>An event called after a new item is inserted.</summary>
				GuiItemNotifyEvent									ItemInserted;
				/// <summary>An event called before a new item is removed.</summary>
				GuiItemNotifyEvent									ItemRemoved;
			};

			/// <summary>Bindable stack composition.</summary>
			class GuiRepeatStackComposition : public GuiStackComposition, public GuiNonVirtialRepeatCompositionBase, public Description<GuiRepeatStackComposition>
			{
			protected:
				vint												GetRepeatCompositionCount()override;
				GuiGraphicsComposition*								GetRepeatComposition(vint index)override;
				GuiGraphicsComposition*								InsertRepeatComposition(vint index)override;
				GuiGraphicsComposition*								RemoveRepeatComposition(vint index)override;

			public:
				GuiRepeatStackComposition();
				~GuiRepeatStackComposition();
			};

			/// <summary>Bindable flow composition.</summary>
			class GuiRepeatFlowComposition : public GuiFlowComposition, public GuiNonVirtialRepeatCompositionBase, public Description<GuiRepeatFlowComposition>
			{
			protected:
				vint												GetRepeatCompositionCount()override;
				GuiGraphicsComposition*								GetRepeatComposition(vint index)override;
				GuiGraphicsComposition*								InsertRepeatComposition(vint index)override;
				GuiGraphicsComposition*								RemoveRepeatComposition(vint index)override;

			public:
				GuiRepeatFlowComposition();
				~GuiRepeatFlowComposition();
			};

/***********************************************************************
GuiVirtualRepeatCompositionBase
***********************************************************************/

			/// <summary>Result for <see cref="GuiVirtualRepeatCompositionBase::EnsureItemVisible"/>.</summary>
			enum class VirtualRepeatEnsureItemVisibleResult
			{
				/// <summary>The requested item does not exist.</summary>
				ItemNotExists,
				/// <summary>The view location is moved.</summary>
				Moved,
				/// <summary>The view location is not moved.</summary>
				NotMoved,
			};

			enum class VirtualRepeatPlaceItemResult
			{
				None,
				HitLastItem,
				Restart,
			};

			enum class VirtualRepeatEndPlaceItemResult
			{
				None,
				TotalSizeUpdated,
			};

			/// <summary>This composition implements most of the common functionality that display a continuing subset of items at a time.</summary>
			class GuiVirtualRepeatCompositionBase : public GuiBoundsComposition, public GuiRepeatCompositionBase, public Description<GuiVirtualRepeatCompositionBase>
			{
			protected:
				using ItemStyleRecord = templates::GuiTemplate*;
				using StyleList = collections::List<ItemStyleRecord>;
				using StyleEventHandlerMap = collections::Dictionary<GuiGraphicsComposition*, Ptr<IGuiGraphicsEventHandler>>;

				Ptr<IGuiAxis>										axis = Ptr(new GuiDefaultAxis);
				bool												itemSourceUpdated = false;
				bool												useMinimumFullSize = false;
				Size												realFullSize;
				Size												realMinimumFullSize;
				Rect												viewBounds;
				vint												startIndex = 0;
				StyleList											visibleStyles;
				StyleEventHandlerMap								eventHandlers;

				virtual void										Layout_BeginPlaceItem(bool firstPhase, Rect newBounds, vint& newStartIndex) = 0;
				virtual VirtualRepeatPlaceItemResult				Layout_PlaceItem(bool firstPhase, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent) = 0;
				virtual VirtualRepeatEndPlaceItemResult				Layout_EndPlaceItem(bool firstPhase, Rect newBounds, vint newStartIndex) = 0;
				virtual void										Layout_EndLayout(bool totalSizeUpdated) = 0;
				virtual void										Layout_InvalidateItemSizeCache() = 0;
				virtual void										Layout_CalculateTotalSize(Size& full, Size& minimum) = 0;
				virtual Size										Layout_GetAdoptedSize(Size expected) = 0;

				virtual void										Layout_UpdateIndex(ItemStyleRecord style, vint index);
				void												Layout_UpdateViewBounds(Rect value, bool forceUpdateTotalSize);
				void												Layout_UpdateViewLocation(Point value);
				Rect												Layout_CalculateBounds(Size parentSize) override;
				void												Layout_ResetLayout();

				void												Layout_SetStyleAlignmentToParent(ItemStyleRecord style, Margin value);
				Size												Layout_GetStylePreferredSize(ItemStyleRecord style);
				Rect												Layout_GetStyleBounds(ItemStyleRecord style);
				void												Layout_SetStyleBounds(ItemStyleRecord style, Rect value);

				void												OnStyleCachedMinSizeChanged(GuiGraphicsComposition* sender, GuiEventArgs& arguments);
				void												AttachEventHandler(GuiGraphicsComposition* itemStyle);
				void												DetachEventHandler(GuiGraphicsComposition* itemStyle);
				void												OnChildRemoved(GuiGraphicsComposition* child)override;

				void												OnItemChanged(vint start, vint oldCount, vint newCount) override;
				void												OnClearItems() override;
				void												OnInstallItems() override;
				void												OnUpdateContext() override;
				virtual void										OnResetViewLocation();
				virtual ItemStyleRecord								CreateStyleInternal(vint index);
				virtual void										DeleteStyleInternal(ItemStyleRecord style);

				vint												CalculateAdoptedSize(vint expectedSize, vint count, vint itemSize);
				ItemStyleRecord										CreateStyle(vint index);
				void												DeleteStyle(ItemStyleRecord style);
				void												UpdateFullSize();
				void												OnViewChangedInternal(Rect oldBounds, Rect newBounds, bool forceUpdateTotalSize);

			public:
				/// <summary>Create the arranger.</summary>
				GuiVirtualRepeatCompositionBase();
				~GuiVirtualRepeatCompositionBase();

				/// <summary>Axis changed event.</summary>
				GuiNotifyEvent										AxisChanged;

				/// <summary>Total size changed event. This event raises when the total size of the content is changed.</summary>
				GuiNotifyEvent										TotalSizeChanged;

				/// <summary>View location changed event. This event raises when the view location of the content is changed.</summary>
				GuiNotifyEvent										ViewLocationChanged;

				/// <summary>This event raises when the adopted size of the content is potentially changed.</summary>
				GuiNotifyEvent										AdoptedSizeInvalidated;

				Ptr<IGuiAxis>										GetAxis();
				void												SetAxis(Ptr<IGuiAxis> value);

				bool												GetUseMinimumTotalSize();
				void												SetUseMinimumTotalSize(bool value);
				Size												GetTotalSize();
				Point												GetViewLocation();
				void												SetViewLocation(Point value);

				ItemStyleRecord										GetVisibleStyle(vint itemIndex);
				vint												GetVisibleIndex(ItemStyleRecord style);
				void												ResetLayout(bool recreateVisibleStyles);
				void												InvalidateLayout();

				Size												GetAdoptedSize(Size expectedSize);
				vint												FindItemByRealKeyDirection(vint itemIndex, compositions::KeyDirection key);
				virtual vint										FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key) = 0;
				virtual VirtualRepeatEnsureItemVisibleResult		EnsureItemVisible(vint itemIndex) = 0;
			};

			/// <summary>Free height repeat composition. This arranger will cache heights of all items.</summary>
			class GuiRepeatFreeHeightItemComposition : public GuiVirtualRepeatCompositionBase, public Description<GuiRepeatFreeHeightItemComposition>
			{
			private:
				bool												pi_heightUpdated = false;

			protected:
				collections::Array<vint>							heights;
				collections::Array<vint>							offsets;
				vint												availableOffsetCount = 0;

				void												EnsureOffsetForItem(vint itemIndex);

				void												Layout_BeginPlaceItem(bool firstPhase, Rect newBounds, vint& newStartIndex) override;
				VirtualRepeatPlaceItemResult						Layout_PlaceItem(bool firstPhase, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent) override;
				VirtualRepeatEndPlaceItemResult						Layout_EndPlaceItem(bool firstPhase, Rect newBounds, vint newStartIndex) override;
				void												Layout_EndLayout(bool totalSizeUpdated) override;
				void												Layout_InvalidateItemSizeCache() override;
				void												Layout_CalculateTotalSize(Size& full, Size& minimum) override;
				Size												Layout_GetAdoptedSize(Size expectedSize) override;

				void												OnItemChanged(vint start, vint oldCount, vint newCount) override;
				void												OnInstallItems() override;
			public:
				/// <summary>Create the arranger.</summary>
				GuiRepeatFreeHeightItemComposition() = default;
				~GuiRepeatFreeHeightItemComposition() = default;

				vint												FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key) override;
				VirtualRepeatEnsureItemVisibleResult				EnsureItemVisible(vint itemIndex) override;
			};
				
			/// <summary>Fixed height item arranger. This arranger lists all item with the same height value. This value is the maximum height of all minimum heights of displayed items.</summary>
			class GuiRepeatFixedHeightItemComposition : public GuiVirtualRepeatCompositionBase, public Description<GuiRepeatFixedHeightItemComposition>
			{
			private:
				vint												pi_width = 0;
				vint												pi_yoffset = 0;
				vint												pi_rowHeight = 0;

			protected:
				vint												rowHeight = 1;
				vint												itemWidth = -1;
				vint												itemYOffset = 0;

				void												Layout_BeginPlaceItem(bool firstPhase, Rect newBounds, vint& newStartIndex)override;
				VirtualRepeatPlaceItemResult						Layout_PlaceItem(bool firstPhase, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
				VirtualRepeatEndPlaceItemResult						Layout_EndPlaceItem(bool firstPhase, Rect newBounds, vint newStartIndex)override;
				void												Layout_EndLayout(bool totalSizeUpdated) override;
				void												Layout_InvalidateItemSizeCache()override;
				void												Layout_CalculateTotalSize(Size& full, Size& minimum)override;
				Size												Layout_GetAdoptedSize(Size expectedSize) override;
			public:
				/// <summary>Create the arranger.</summary>
				GuiRepeatFixedHeightItemComposition() = default;
				~GuiRepeatFixedHeightItemComposition() = default;

				vint												FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key)override;
				VirtualRepeatEnsureItemVisibleResult				EnsureItemVisible(vint itemIndex)override;

				vint												GetItemWidth();
				void												SetItemWidth(vint value);
				vint												GetItemYOffset();
				void												SetItemYOffset(vint value);
			};

			/// <summary>Fixed size multiple columns item arranger. This arranger adjust all items in multiple lines with the same size. The width is the maximum width of all minimum widths of displayed items. The same to height.</summary>
			class GuiRepeatFixedSizeMultiColumnItemComposition : public GuiVirtualRepeatCompositionBase, public Description<GuiRepeatFixedSizeMultiColumnItemComposition>
			{
			private:
				Size												pi_itemSize;

			protected:
				Size												itemSize{ 1,1 };

				void												Layout_BeginPlaceItem(bool firstPhase, Rect newBounds, vint& newStartIndex)override;
				VirtualRepeatPlaceItemResult						Layout_PlaceItem(bool firstPhase, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
				VirtualRepeatEndPlaceItemResult						Layout_EndPlaceItem(bool firstPhase, Rect newBounds, vint newStartIndex)override;
				void												Layout_EndLayout(bool totalSizeUpdated) override;
				void												Layout_InvalidateItemSizeCache()override;
				void												Layout_CalculateTotalSize(Size& full, Size& minimum)override;
				Size												Layout_GetAdoptedSize(Size expectedSize) override;
			public:
				/// <summary>Create the arranger.</summary>
				GuiRepeatFixedSizeMultiColumnItemComposition() = default;
				~GuiRepeatFixedSizeMultiColumnItemComposition() = default;

				vint												FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key)override;
				VirtualRepeatEnsureItemVisibleResult				EnsureItemVisible(vint itemIndex)override;
			};
			
			/// <summary>Fixed size multiple columns item arranger. This arranger adjust all items in multiple columns with the same height. The height is the maximum width of all minimum height of displayed items. Each item will displayed using its minimum width.</summary>
			class GuiRepeatFixedHeightMultiColumnItemComposition : public GuiVirtualRepeatCompositionBase, public Description<GuiRepeatFixedHeightMultiColumnItemComposition>
			{
			private:
				collections::List<vint>								pi_visibleItemWidths;
				collections::List<vint>								pi_visibleColumnWidths;
				collections::List<vint>								pi_visibleColumnOffsets;
				vint												pi_rows = 0;
				vint												pi_firstColumn = 0;
				vint												pi_itemHeight = 0;

			protected:
				vint												firstColumn = 0;
				vint												fullVisibleColumns = 0;
				vint												itemHeight = 1;

				void												FixColumnWidth(vint index);

				void												Layout_BeginPlaceItem(bool firstPhase, Rect newBounds, vint& newStartIndex)override;
				VirtualRepeatPlaceItemResult						Layout_PlaceItem(bool firstPhase, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
				VirtualRepeatEndPlaceItemResult						Layout_EndPlaceItem(bool firstPhase, Rect newBounds, vint newStartIndex)override;
				void												Layout_EndLayout(bool totalSizeUpdated) override;
				void												Layout_InvalidateItemSizeCache()override;
				void												Layout_CalculateTotalSize(Size& full, Size& minimum)override;
				Size												Layout_GetAdoptedSize(Size expectedSize) override;
			public:
				/// <summary>Create the arranger.</summary>
				GuiRepeatFixedHeightMultiColumnItemComposition() = default;
				~GuiRepeatFixedHeightMultiColumnItemComposition() = default;

				vint												FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key)override;
				VirtualRepeatEnsureItemVisibleResult				EnsureItemVisible(vint itemIndex)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\GUIGRAPHICSTABLECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSTABLECOMPOSITION
#define VCZH_PRESENTATION_COMPOSITION_GUIGRAPHICSTABLECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Table Compositions
***********************************************************************/

			/// <summary>
			/// Represnets a sizing configuration for a row or a column.
			/// </summary>
			struct GuiCellOption
			{
				/// <summary>Size configuration</summary>
				enum ComposeType
				{
					/// <summary>
					/// Set the size to an absolute value.
					/// The size will not change even if affected cell's minimum size is bigger that this.
					/// </summary>
					Absolute,
					/// <summary>
					/// Set the size to a percentage number of the whole table.
					/// </summary>
					Percentage,
					/// <summary>
					/// Set the size to the minimum size of the cell element.
					/// Only cells that take one row or column at this position are considered.
					/// </summary>
					MinSize,
				};

				/// <summary>Sizing algorithm</summary>
				ComposeType		composeType;
				/// <summary>The absolute size when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Absolute.</summary>
				vint			absolute;
				/// <summary>The percentage number when <see cref="GuiCellOption::composeType"/> is <see cref="ComposeType"/>::Percentage.</summary>
				double			percentage;

				GuiCellOption()
					:composeType(Absolute)
					,absolute(20)
					,percentage(0)
				{
				}

				GUI_DEFINE_COMPARE_OPERATORS(GuiCellOption)

				/// <summary>Creates an absolute sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The absolute size.</param>
				static GuiCellOption AbsoluteOption(vint value)
				{
					GuiCellOption option;
					option.composeType=Absolute;
					option.absolute=value;
					return option;
				}
				
				/// <summary>Creates an percantage sizing option</summary>
				/// <returns>The created option.</returns>
				/// <param name="value">The percentage number.</param>
				static GuiCellOption PercentageOption(double value)
				{
					GuiCellOption option;
					option.composeType=Percentage;
					option.percentage=value;
					return option;
				}
				
				/// <summary>Creates an minimum sizing option</summary>
				/// <returns>The created option.</returns>
				static GuiCellOption MinSizeOption()
				{
					GuiCellOption option;
					option.composeType=MinSize;
					return option;
				}
			};

			/// <summary>
			/// Represents a table composition.
			/// </summary>
			class GuiTableComposition : public GuiBoundsComposition, public Description<GuiTableComposition>
			{
				friend class GuiCellComposition;
				friend class GuiTableSplitterCompositionBase;
				friend class GuiRowSplitterComposition;
				friend class GuiColumnSplitterComposition;
			private:
				bool										layout_invalid = true;
				bool										layout_invalidCellBounds = false;
				Size										layout_lastTableSize;

				collections::Array<GuiCellComposition*>		layout_cellCompositions;
				collections::Array<Rect>					layout_cellBounds;
				collections::Array<vint>					layout_rowOffsets;
				collections::Array<vint>					layout_columnOffsets;
				collections::Array<vint>					layout_rowSizes;
				collections::Array<vint>					layout_columnSizes;
				vint										layout_rowTotal = 0;
				vint										layout_columnTotal = 0;
				vint										layout_rowTotalWithPercentage = 0;
				vint										layout_columnTotalWithPercentage = 0;
				vint										layout_rowExtending = 0;
				vint										layout_columnExtending = 0;

				Rect										Layout_CalculateCellArea(Rect tableBounds);
				void										Layout_UpdateCellBoundsInternal(
																collections::Array<vint>& dimSizes,
																vint& dimSize, 
																vint& dimSizeWithPercentage,
																collections::Array<GuiCellOption>& dimOptions,
																vint GuiTableComposition::* dim1,
																vint GuiTableComposition::* dim2,
																vint (*getSize)(Size),
																vint (*getLocation)(GuiCellComposition*),
																vint (*getSpan)(GuiCellComposition*),
																vint (*getRow)(vint, vint),
																vint (*getCol)(vint, vint)
																);
				void										Layout_UpdateCellBoundsPercentages(
																collections::Array<vint>& dimSizes,
																vint dimSize,
																vint maxDimSize,
																collections::Array<GuiCellOption>& dimOptions
																);
				vint										Layout_UpdateCellBoundsOffsets(
																collections::Array<vint>& offsets,
																collections::Array<vint>& sizes,
																vint max
																);
			protected:
				vint										rows = 0;
				vint										columns = 0;
				vint										cellPadding = 0;
				bool										borderVisible = true;
				collections::Array<GuiCellOption>			rowOptions;
				collections::Array<GuiCellOption>			columnOptions;

				vint										GetSiteIndex(vint _rows, vint _columns, vint _row, vint _column);
				void										SetSitedCell(vint _row, vint _column, GuiCellComposition* cell);
				void										OnCompositionStateChanged() override;
				Size										Layout_CalculateMinSize() override;
				Rect										Layout_CalculateBounds(Size parentSize) override;
			public:
				GuiTableComposition();
				~GuiTableComposition() = default;

				/// <summary>Event that will be raised with row numbers, column numbers or options are changed.</summary>
				compositions::GuiNotifyEvent		ConfigChanged;

				/// <summary>Get the number of rows.</summary>
				/// <returns>The number of rows.</returns>
				vint								GetRows();
				/// <summary>Get the number of columns.</summary>
				/// <returns>The number of columns.</returns>
				vint								GetColumns();
				/// <summary>Change the number of rows and columns.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_rows">The number of rows.</param>
				/// <param name="_columns">The number of columns.</param>
				bool								SetRowsAndColumns(vint _rows, vint _columns);
				/// <summary>Get the cell composition that covers the specified cell location.</summary>
				/// <returns>The cell composition that covers the specified cell location.</returns>
				/// <param name="_row">The number of rows.</param>
				/// <param name="_column">The number of columns.</param>
				GuiCellComposition*					GetSitedCell(vint _row, vint _column);

				/// <summary>Get the sizing option of the specified row.</summary>
				/// <returns>The sizing option of the specified row.</returns>
				/// <param name="_row">The specified row number.</param>
				GuiCellOption						GetRowOption(vint _row);
				/// <summary>Set the sizing option of the specified row.</summary>
				/// <param name="_row">The specified row number.</param>
				/// <param name="option">The sizing option of the specified row.</param>
				void								SetRowOption(vint _row, GuiCellOption option);
				/// <summary>Get the sizing option of the specified column.</summary>
				/// <returns>The sizing option of the specified column.</returns>
				/// <param name="_column">The specified column number.</param>
				GuiCellOption						GetColumnOption(vint _column);
				/// <summary>Set the sizing option of the specified column.</summary>
				/// <param name="_column">The specified column number.</param>
				/// <param name="option">The sizing option of the specified column.</param>
				void								SetColumnOption(vint _column, GuiCellOption option);

				/// <summary>Get the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <returns>The cell padding.</returns>
				vint								GetCellPadding();
				/// <summary>Set the cell padding. A cell padding is the distance between a table client area and a cell, or between two cells.</summary>
				/// <param name="value">The cell padding.</param>
				void								SetCellPadding(vint value);
				/// <summary>Get the border visibility.</summary>
				/// <returns>Returns true means the border thickness equals to the cell padding, otherwise zero.</returns>
				bool								GetBorderVisible();
				/// <summary>Set the border visibility.</summary>
				/// <param name="value">Set to true to let the border thickness equal to the cell padding, otherwise zero.</param>
				void								SetBorderVisible(bool value);
			};

			/// <summary>
			/// Represents a cell composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiCellComposition : public GuiGraphicsComposition_Controlled, public Description<GuiCellComposition>
			{
				friend class GuiTableComposition;
			private:
				GuiTableComposition*				layout_tableParent = nullptr;
			protected:
				vint								row = -1;
				vint								rowSpan = 1;
				vint								column = -1;
				vint								columnSpan = 1;
				
				void								ClearSitedCells(GuiTableComposition* table);
				void								SetSitedCells(GuiTableComposition* table);
				void								ResetSiteInternal();
				bool								SetSiteInternal(vint _row, vint _column, vint _rowSpan, vint _columnSpan);
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnTableRowsAndColumnsChanged();
				void								Layout_SetCellBounds();
			public:
				GuiCellComposition();
				~GuiCellComposition() = default;

				/// <summary>Get the owner table composition.</summary>
				/// <returns>The owner table composition.</returns>
				GuiTableComposition*				GetTableParent();

				/// <summary>Get the row number for this cell composition.</summary>
				/// <returns>The row number for this cell composition.</returns>
				vint								GetRow();
				/// <summary>Get the total numbers of acrossed rows for this cell composition.</summary>
				/// <returns>The total numbers of acrossed rows for this cell composition.</returns>
				vint								GetRowSpan();
				/// <summary>Get the column number for this cell composition.</summary>
				/// <returns>The column number for this cell composition.</returns>
				vint								GetColumn();
				/// <summary>Get the total numbers of acrossed columns for this cell composition.</summary>
				/// <returns>The total numbers of acrossed columns for this cell composition.</returns>
				vint								GetColumnSpan();
				/// <summary>Set the position for this cell composition in the table.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="_row">The row number for this cell composition.</param>
				/// <param name="_column">The column number for this cell composition.</param>
				/// <param name="_rowSpan">The total numbers of acrossed rows for this cell composition.</param>
				/// <param name="_columnSpan">The total numbers of acrossed columns for this cell composition.</param>
				bool								SetSite(vint _row, vint _column, vint _rowSpan, vint _columnSpan);
			};

			class GuiTableSplitterCompositionBase : public GuiGraphicsComposition_Specialized, public Description<GuiTableSplitterCompositionBase>
			{
			protected:
				GuiTableComposition*				tableParent = nullptr;

				bool								dragging = false;
				Point								draggingPoint;
				
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnLeftButtonDown(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);
				void								OnLeftButtonUp(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);

				void								OnMouseMoveHelper(
														vint cellsBefore,
														vint GuiTableComposition::* cells,
														collections::Array<vint>& cellSizes,
														vint offset,
														GuiCellOption(GuiTableComposition::*getOption)(vint),
														void(GuiTableComposition::*setOption)(vint, GuiCellOption)
														);

				Rect								GetBoundsHelper(
														vint cellsBefore,
														vint GuiTableComposition::* cells,
														vint(Rect::* dimSize)()const,
														collections::Array<vint>& cellOffsets,
														vint Rect::* dimU1,
														vint Rect::* dimU2,
														vint Rect::* dimV1,
														vint Rect::* dimV2
														);
			public:
				GuiTableSplitterCompositionBase();
				~GuiTableSplitterCompositionBase() = default;

				/// <summary>Get the owner table composition.</summary>
				/// <returns>The owner table composition.</returns>
				GuiTableComposition*				GetTableParent();
			};
			
			/// <summary>
			/// Represents a row splitter composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiRowSplitterComposition : public GuiTableSplitterCompositionBase, public Description<GuiRowSplitterComposition>
			{
			protected:
				vint								rowsToTheTop = 0;
				
				void								OnMouseMove(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);
				Rect								Layout_CalculateBounds(Size parentSize) override;
			public:
				GuiRowSplitterComposition();
				~GuiRowSplitterComposition() = default;

				/// <summary>Get the number of rows that above the splitter.</summary>
				/// <returns>The number of rows that above the splitter.</returns>
				vint								GetRowsToTheTop();
				/// <summary>Set the number of rows that above the splitter.</summary>
				/// <param name="value">The number of rows that above the splitter</param>
				void								SetRowsToTheTop(vint value);
			};
			
			/// <summary>
			/// Represents a column splitter composition of a <see cref="GuiTableComposition"/>.
			/// </summary>
			class GuiColumnSplitterComposition : public GuiTableSplitterCompositionBase, public Description<GuiColumnSplitterComposition>
			{
			protected:
				vint								columnsToTheLeft = 0;
				
				void								OnMouseMove(GuiGraphicsComposition* sender, GuiMouseEventArgs& arguments);
				Rect								Layout_CalculateBounds(Size parentSize) override;
			public:
				GuiColumnSplitterComposition();
				~GuiColumnSplitterComposition() = default;

				/// <summary>Get the number of columns that before the splitter.</summary>
				/// <returns>The number of columns that before the splitter.</returns>
				vint								GetColumnsToTheLeft();
				/// <summary>Set the number of columns that before the splitter.</summary>
				/// <param name="value">The number of columns that before the splitter</param>
				void								SetColumnsToTheLeft(vint value);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSCOMPOSITION\INCLUDEALL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_COMPOSITION_INCLUDEALL
#define VCZH_PRESENTATION_COMPOSITION_INCLUDEALL


#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSRESOURCEMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			extern void									InvokeOnCompositionStateChanged(compositions::GuiGraphicsComposition* composition);
		}

		namespace elements
		{

/***********************************************************************
Resource Manager
***********************************************************************/

			/// <summary>
			/// This is an interface for managing grpahics element factories and graphics renderer factories
			/// </summary>
			class IGuiGraphicsResourceManager : public Interface, public Description<INativeWindow>
			{
			public:
				/// <summary>
				/// Register a element type name.
				/// This function crashes when an element type has already been registered.
				/// </summary>
				/// <param name="elementTypeName">The element type.</param>
				/// <returns>A number identifies this element type.</returns>
				virtual vint							RegisterElementType(const WString& elementTypeName) = 0;
				/// <summary>
				/// Register a <see cref="IGuiGraphicsRendererFactory"/> and bind it to an registered element type from <see cref="RegisterElementType"/>.
				/// This function crashes when an element type has already been binded a renderer factory.
				/// </summary>
				/// <param name="elementType">The element type to represent a graphics element factory.</param>
				/// <param name="factory">The instance of the graphics renderer factory to register.</param>
				virtual void							RegisterRendererFactory(vint elementType, Ptr<IGuiGraphicsRendererFactory> factory) = 0;
				/// <summary>
				/// Get the instance of a registered <see cref="IGuiGraphicsRendererFactory"/> that is binded to a specified element type.
				/// </summary>
				/// <returns>Returns the renderer factory.</returns>
				/// <param name="elementType">The registered element type from <see cref="RegisterElementType"/> to get a binded graphics renderer factory.</param>
				virtual IGuiGraphicsRendererFactory*	GetRendererFactory(vint elementType) = 0;
				/// <summary>
				/// Get the instance of a <see cref="IGuiGraphicsRenderTarget"/> that is binded to an <see cref="INativeWindow"/>.
				/// </summary>
				/// <param name="window">The specified window.</param>
				/// <returns>Returns the render target.</returns>
				virtual IGuiGraphicsRenderTarget*		GetRenderTarget(INativeWindow* window) = 0;
				/// <summary>
				/// Recreate the render target for the specified window.
				/// </summary>
				/// <param name="window">The specified window.</param>
				virtual void							RecreateRenderTarget(INativeWindow* window) = 0;
				/// <summary>
				/// Resize the render target to fit the current window size.
				/// </summary>
				/// <param name="window">The specified window.</param>
				virtual void							ResizeRenderTarget(INativeWindow* window) = 0;
				/// <summary>
				/// Get the renderer awared rich text document layout engine provider object.
				/// </summary>
				/// <returns>Returns the layout provider.</returns>
				virtual IGuiGraphicsLayoutProvider*		GetLayoutProvider() = 0;
			};

			/// <summary>
			/// This is a default implementation for <see cref="IGuiGraphicsResourceManager"/>
			/// </summary>
			class GuiGraphicsResourceManager : public Object, public virtual IGuiGraphicsResourceManager
			{
			protected:
				collections::List<WString>								elementTypes;
				collections::Array<Ptr<IGuiGraphicsRendererFactory>>	rendererFactories;
			public:
				/// <summary>
				/// Create a graphics resource manager without any predefined factories
				/// </summary>
				GuiGraphicsResourceManager();
				~GuiGraphicsResourceManager();

				vint									RegisterElementType(const WString& elementTypeName);
				void									RegisterRendererFactory(vint elementType, Ptr<IGuiGraphicsRendererFactory> factory);
				IGuiGraphicsRendererFactory*			GetRendererFactory(vint elementType);
			};

			/// <summary>
			/// Get the current <see cref="GuiGraphicsResourceManager"/>.
			/// </summary>
			/// <returns>Returns the current resource manager.</returns>
			extern IGuiGraphicsResourceManager*			GetGuiGraphicsResourceManager();
			/// <summary>
			/// Set the current <see cref="GuiGraphicsResourceManager"/>.
			/// </summary>
			/// <param name="resourceManager">The resource manager to set.</param>
			extern void									SetGuiGraphicsResourceManager(IGuiGraphicsResourceManager* resourceManager);

/***********************************************************************
Helpers
***********************************************************************/

			template<typename TElement>
			class GuiElementBase : public Object, public IGuiGraphicsElement, public Description<TElement>
			{
			protected:
				Ptr<IGuiGraphicsRenderer>				renderer;
				compositions::GuiGraphicsComposition*	ownerComposition = nullptr;

				void SetOwnerComposition(compositions::GuiGraphicsComposition* composition)override
				{
					ownerComposition = composition;
				}

				void InvokeOnCompositionStateChanged()
				{
					if (ownerComposition)
					{
						compositions::InvokeOnCompositionStateChanged(ownerComposition);
					}
				}

				void InvokeOnElementStateChanged()
				{
					if (renderer)
					{
						renderer->OnElementStateChanged();
					}
					InvokeOnCompositionStateChanged();
				}
			public:
				static vint GetElementType()
				{
					static vint elementType = -1; 
					if (elementType == -1)
					{
						auto manager = GetGuiGraphicsResourceManager(); 
						CHECK_ERROR(manager != nullptr, L"SetGuiGraphicsResourceManager must be called before registering element types."); 
						elementType = manager->RegisterElementType(WString::Unmanaged(TElement::ElementTypeName)); 
					}
					return elementType; 
				}

				static TElement* Create()
				{
					auto rendererFactory = GetGuiGraphicsResourceManager()->GetRendererFactory(TElement::GetElementType());
					CHECK_ERROR(rendererFactory != nullptr, L"This element is not supported by the selected renderer.");

					auto element = new TElement;
					element->renderer = Ptr(rendererFactory->Create());
					element->renderer->Initialize(element);
					return element;
				}

				~GuiElementBase()
				{
					if (renderer)
					{
						renderer->Finalize();
					}
				}

				IGuiGraphicsRenderer* GetRenderer()override
				{
					return renderer.Obj();
				}

				compositions::GuiGraphicsComposition* GetOwnerComposition()override
				{
					return ownerComposition;
				}
			};

			template<typename TElement, typename TRenderer, typename TRenderTarget>
			class GuiElementRendererBase : public Object, public IGuiGraphicsRenderer
			{
			public:
				class Factory : public Object, public IGuiGraphicsRendererFactory
				{
				public:
					IGuiGraphicsRenderer* Create()
					{
						TRenderer* renderer=new TRenderer;
						renderer->factory=this;
						renderer->element=nullptr;
						renderer->renderTarget=nullptr;
						return renderer;
					}
				};
			protected:

				IGuiGraphicsRendererFactory*	factory;
				TElement*						element;
				TRenderTarget*					renderTarget;
				Size							minSize;

			public:
				static void Register()
				{
					auto manager = GetGuiGraphicsResourceManager();
					CHECK_ERROR(manager != nullptr, L"SetGuiGraphicsResourceManager must be called before registering element renderers.");
					manager->RegisterRendererFactory(TElement::GetElementType(), Ptr(new typename TRenderer::Factory));
				}

				IGuiGraphicsRendererFactory* GetFactory()override
				{
					return factory;
				}

				void Initialize(IGuiGraphicsElement* _element)override
				{
					element=dynamic_cast<TElement*>(_element);
					static_cast<TRenderer*>(this)->InitializeInternal();
				}

				void Finalize()override
				{
					static_cast<TRenderer*>(this)->FinalizeInternal();
				}

				void SetRenderTarget(IGuiGraphicsRenderTarget* _renderTarget)override
				{
					TRenderTarget* oldRenderTarget=renderTarget;
					renderTarget= static_cast<TRenderTarget*>(_renderTarget);
					static_cast<TRenderer*>(this)->RenderTargetChangedInternal(oldRenderTarget, renderTarget);
				}

				Size GetMinSize()override
				{
					return minSize;
				}
			};

			template<typename TAllocator, typename TKey, typename TValue>
			class GuiCachedResourceAllocatorBase : public Object
			{
			public:
				static const vint						DeadPackageMax = 32;

				struct Package
				{
					TValue								resource;
					vint								counter;
					std::partial_ordering operator<=>(const Package&) const { return std::partial_ordering::unordered; }
					bool operator==(const Package&)const { return false; }
				};

				struct DeadPackage
				{
					TKey								key;
					TValue								value;
					std::partial_ordering operator<=>(const DeadPackage&) const { return std::partial_ordering::unordered; }
					bool operator==(const DeadPackage&)const { return false; }
				};

				collections::Dictionary<TKey, Package>	aliveResources;
				collections::List<DeadPackage>			deadResources;

			public:

				TValue Create(const TKey& key)
				{
					vint index = aliveResources.Keys().IndexOf(key);
					if (index != -1)
					{
						Package package = aliveResources.Values().Get(index);
						package.counter++;
						aliveResources.Set(key, package);
						return package.resource;
					}
					TValue resource;
					for (vint i = 0; i < deadResources.Count(); i++)
					{
						if (deadResources[i].key == key)
						{
							DeadPackage deadPackage = deadResources[i];
							deadResources.RemoveAt(i);
							resource = deadPackage.value;
							break;
						}
					}
					if (!resource)
					{
						resource = static_cast<TAllocator*>(this)->CreateInternal(key);
					}
					Package package;
					package.resource = resource;
					package.counter = 1;
					aliveResources.Add(key, package);
					return package.resource;
				}

				void Destroy(const TKey& key)
				{
					vint index = aliveResources.Keys().IndexOf(key);
					if (index != -1)
					{
						Package package = aliveResources.Values().Get(index);
						package.counter--;
						if (package.counter == 0)
						{
							aliveResources.Remove(key);
							if (deadResources.Count() == DeadPackageMax)
							{
								deadResources.RemoveAt(DeadPackageMax - 1);
							}
							DeadPackage deadPackage;
							deadPackage.key = key;
							deadPackage.value = package.resource;
							deadResources.Insert(0, deadPackage);
						}
						else
						{
							aliveResources.Set(key, package);
						}
					}
				}
			};
		}
	}
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\HOSTED\GUIHOSTEDAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Hosted Application

Interfaces:
  GuiHostedController

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDAPPLICATION
#define VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDAPPLICATION


namespace vl::presentation
{
/***********************************************************************
IGuiHostedApplication
***********************************************************************/

	/// <summary>
	/// 
	/// </summary>
	class IGuiHostedApplication : public virtual Interface
	{
	public:

		virtual INativeWindow*				GetNativeWindowHost() = 0;
	};

	extern IGuiHostedApplication*			GetHostedApplication();
	extern void								SetHostedApplication(IGuiHostedApplication* _hostedApp);
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\HOSTED\GUIHOSTEDGRAPHICS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Hosted Window

Interfaces:
  IGuiGraphicsResourceManager

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDGRAPHICS
#define VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDGRAPHICS


namespace vl
{
	namespace presentation
	{
		class GuiHostedController;

		namespace elements
		{

/***********************************************************************
GuiHostedGraphicsResourceManager
***********************************************************************/

			class GuiHostedGraphicsResourceManager : public Object, public virtual IGuiGraphicsResourceManager
			{
				friend class vl::presentation::GuiHostedController;
			protected:
				GuiHostedController*				hostedController = nullptr;
				IGuiGraphicsResourceManager*		nativeManager = nullptr;

			public:
				GuiHostedGraphicsResourceManager(GuiHostedController* _hostedController, IGuiGraphicsResourceManager* _nativeManager);
				~GuiHostedGraphicsResourceManager();

				vint								RegisterElementType(const WString& elementTypeName) override;
				void								RegisterRendererFactory(vint elementType, Ptr<IGuiGraphicsRendererFactory> factory) override;
				IGuiGraphicsRendererFactory*		GetRendererFactory(vint elementType) override;
				IGuiGraphicsRenderTarget*			GetRenderTarget(INativeWindow* window) override;
				void								RecreateRenderTarget(INativeWindow* window) override;
				void								ResizeRenderTarget(INativeWindow* window) override;
				IGuiGraphicsLayoutProvider*			GetLayoutProvider() override;
			};
		}
	}
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\HOSTED\GUIHOSTEDWINDOWMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Hosted Window

Interfaces:
  Window<T>
  WindowManager<T>

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDWINDOWMANAGER
#define VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDWINDOWMANAGER


namespace vl
{
	namespace presentation
	{
		namespace hosted_window_manager
		{
			template<typename T>
			struct WindowManager;

/***********************************************************************
Window
***********************************************************************/

			template<typename T>
			struct Window
			{
				friend struct WindowManager<T>;
			protected:
				WindowManager<T>*							windowManager = nullptr;

			public:
				const T										id = {};
				Window<T>*									parent = nullptr;
				collections::List<Window<T>*>				children;

				NativeRect									bounds;
				bool										topMost = false;
				bool										visible = false;
				bool										enabled = true;
				bool										active = false;
				bool										renderedAsActive = false;

			protected:

				Window<T>* GetVisibleParent()
				{
					auto visibleParent = parent;
					while (visibleParent && !visibleParent->visible)
					{
						visibleParent = visibleParent->parent;
					}
					return visibleParent;
				}

				template<typename TWindows>
				void CollectVisibleSubTreeInSamePriority(TWindows& windows, bool inTopMostLevel)
				{
					if (visible)
					{
						windows.Add(this);
					}
					for (auto child : children)
					{
						if (inTopMostLevel || !child->topMost)
						{
							child->CollectVisibleSubTreeInSamePriority(windows, inTopMostLevel);
						}
					}
				}

				void EnsureChildrenMovedInFrontOf(bool eventuallyTopMost, Window<T>* baseline)
				{
					auto&& orderedWindows = eventuallyTopMost ? windowManager->topMostedWindowsInOrder : windowManager->ordinaryWindowsInOrder;
					vint order = -1;
					if (baseline) order = orderedWindows.IndexOf(baseline);
					if (order == -1) order = orderedWindows.Count();

					for (auto child : children)
					{
						if (eventuallyTopMost || !child->topMost)
						{
							if (child->visible)
							{
								vint childOrder = orderedWindows.IndexOf(child);
								if (childOrder == -1 || childOrder > order)
								{
									windowManager->ordinaryWindowsInOrder.Remove(child);
									windowManager->topMostedWindowsInOrder.Remove(child);
									orderedWindows.Insert(order, child);
								}
							}
							child->EnsureChildrenMovedInFrontOf(eventuallyTopMost || child->topMost, (child->visible ? child : baseline));
						}
					}
				}

				void EnsureMovedInFrontOf(collections::List<Window<T>*>& windowsInOrder, Window<T>* baseline, bool wasEventuallyTopMost, bool eventuallyTopMost)
				{
					vint maxOrder = -1;
					vint order = windowsInOrder.IndexOf(this);

					if (wasEventuallyTopMost && order == -1)
					{
						maxOrder = 0;
					}
					else if (baseline)
					{
						maxOrder = windowsInOrder.IndexOf(baseline);
					}
					else if (order == -1)
					{
						maxOrder = windowsInOrder.Count();
					}
					else
					{
						maxOrder = windowsInOrder.Count() - 1;
					}

					if (order == -1)
					{
						windowsInOrder.Insert(maxOrder, this);
						windowManager->needRefresh = true;
					}
					else if (order > maxOrder)
					{
						windowsInOrder.RemoveAt(order);
						windowsInOrder.Insert(maxOrder, this);
						windowManager->needRefresh = true;
					}
				}

				void FixWindowInOrder(bool wasEventuallyTopMost, bool isEventuallyTopMost)
				{
					if (!visible)
					{
						if (windowManager->ordinaryWindowsInOrder.Remove(this) || windowManager->topMostedWindowsInOrder.Remove(this))
						{
							windowManager->needRefresh = true;
						}
					}

					auto visibleParent = GetVisibleParent();

					if (visible)
					{

						if (isEventuallyTopMost)
						{
							if (windowManager->ordinaryWindowsInOrder.Remove(this))
							{
								windowManager->needRefresh = true;
							}

							if (visibleParent && !visibleParent->IsEventuallyTopMost())
							{
								visibleParent = nullptr;
							}
							EnsureMovedInFrontOf(windowManager->topMostedWindowsInOrder, visibleParent, wasEventuallyTopMost, true);
						}
						else
						{
							if (windowManager->topMostedWindowsInOrder.Remove(this))
							{
								windowManager->needRefresh = true;
							}
							EnsureMovedInFrontOf(windowManager->ordinaryWindowsInOrder, visibleParent, wasEventuallyTopMost, false);
						}
					}

					EnsureChildrenMovedInFrontOf(isEventuallyTopMost, (visible ? this : visibleParent));
				}

				void FixRenderedAsActive()
				{
					if (enabled && visible)
					{
						auto current = windowManager->activeWindow;
						while (current && current != this)
						{
							current = current->parent;
						}
						if (current == this && !renderedAsActive)
						{
							renderedAsActive = true;
							windowManager->OnActivated(this);
						}
					}
					else if (active)
					{
						Deactivate();
					}
					else if (renderedAsActive)
					{
						renderedAsActive = false;
						windowManager->OnDeactivated(this);
					}
				}

			public:
				Window(T _id)
					: id(_id)
				{
				}

				~Window()
				{
				}

				bool IsEventuallyTopMost()
				{
					bool result = visible && topMost;
					auto current = parent;
					while (current && !result)
					{
						result |= current->visible && current->topMost;
						current = current->parent;
					}
					return result;
				}

#define ENSURE_WINDOW_MANAGER CHECK_ERROR(windowManager, ERROR_MESSAGE_PREFIX L"This operation can only be called between window manager's RegisterWindow and Stop.")

				void SetParent(Window<T>* value)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::SetParent(Window<T>*)#"
					ENSURE_WINDOW_MANAGER;

					if (parent == value) return;
					CHECK_ERROR(
						!windowManager || windowManager->mainWindow != this || !value,
						ERROR_MESSAGE_PREFIX L"A main window should not have a parent window."
						);

					if (!value)
					{
						value = windowManager->mainWindow;
					}

					auto current = value;
					while (current)
					{
						CHECK_ERROR(current != this, ERROR_MESSAGE_PREFIX L"Parent window should not be cyclic.");
						current = current->parent;
					}

					if (parent)
					{
						parent->children.Remove(this);
					}
					parent = value;
					if (parent)
					{
						parent->children.Add(this);
					}
					bool isEventuallyTopMost = IsEventuallyTopMost();
					FixWindowInOrder(isEventuallyTopMost, isEventuallyTopMost);
#undef ERROR_MESSAGE_PREFIX
				}

				void SetBounds(const NativeRect& value)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::SetBounds(const NativeRect&)#"
					ENSURE_WINDOW_MANAGER;

					if (bounds == value) return;
					bounds = value;
					windowManager->needRefresh = true;
#undef ERROR_MESSAGE_PREFIX
				}

				void SetVisible(bool value)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::SetVisible(bool)#"
					ENSURE_WINDOW_MANAGER;

					if (visible == value) return;

					bool parentEventuallyTopMost = parent ? parent->IsEventuallyTopMost() : false;
					visible = value;
					FixRenderedAsActive();

					FixWindowInOrder(
						parentEventuallyTopMost || (!visible && topMost),
						parentEventuallyTopMost || (visible && topMost)
						);

					if (visible) windowManager->OnOpened(this); else windowManager->OnClosed(this);
#undef ERROR_MESSAGE_PREFIX
				}

				void SetTopMost(bool value)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::SetTopMost(bool)#"
					ENSURE_WINDOW_MANAGER;

					if (topMost == value) return;
					bool parentEventuallyTopMost = parent ? parent->IsEventuallyTopMost() : false;
					bool wasEventuallyTopMost = parentEventuallyTopMost || (visible && topMost);
					topMost = value;
					bool isEventuallyTopMost = parentEventuallyTopMost || (visible && topMost);
					FixWindowInOrder(wasEventuallyTopMost, isEventuallyTopMost);
#undef ERROR_MESSAGE_PREFIX
				}

				void SetEnabled(bool value)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::SetEnabled(bool)#"
					ENSURE_WINDOW_MANAGER;

					if (enabled == value) return;
					enabled = value;
					FixRenderedAsActive();

					windowManager->needRefresh = true;
					if (enabled) windowManager->OnEnabled(this); else windowManager->OnDisabled(this);
#undef ERROR_MESSAGE_PREFIX
				}

				void BringToFront()
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::BringToFront()#"
					ENSURE_WINDOW_MANAGER;

					bool eventuallyTopMost = IsEventuallyTopMost();
					auto&& orderedWindows = eventuallyTopMost ? windowManager->topMostedWindowsInOrder : windowManager->ordinaryWindowsInOrder;

					if (orderedWindows.Contains(this))
					{
						collections::SortedList<Window<T>*> windows;
						CollectVisibleSubTreeInSamePriority(windows, eventuallyTopMost);

						collections::List<Window<T>*> selected, remainings;
						for (auto window : orderedWindows)
						{
							if (windows.Contains(window))
							{
								selected.Add(window);
							}
							else
							{
								remainings.Add(window);
							}
						}

						if (collections::CompareEnumerable(selected, From(orderedWindows).Take(selected.Count())) != 0)
						{
							collections::CopyFrom(orderedWindows, selected);
							collections::CopyFrom(orderedWindows, remainings, true);
							windowManager->needRefresh = true;
						}
					}
					else
					{
						collections::List<Window<T>*> windows, remainings;
						CollectVisibleSubTreeInSamePriority(windows, eventuallyTopMost);

						CopyFrom(remainings, orderedWindows);
						orderedWindows.Clear();
						// TODO: (enumerable) foreach:reversed
						for (vint i = windows.Count() - 1; i >= 0; i--)
						{
							orderedWindows.Add(windows[i]);
						}
						CopyFrom(orderedWindows, remainings, true);
						windowManager->needRefresh = true;
					}
#undef ERROR_MESSAGE_PREFIX
				}

				void Activate()
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::Activate()#"
					ENSURE_WINDOW_MANAGER;

					if (active)
					{
						BringToFront();
						return;
					}
					if (!windowManager->mainWindow) return;
					if (!visible) return;
					if (!enabled) return;

					auto previous = windowManager->activeWindow;
					if (previous != this)
					{
						if (previous)
						{
							previous->active = false;
							windowManager->OnLostFocus(previous);
						}
						windowManager->activeWindow = this;
						active = true;
						windowManager->OnGotFocus(this);
					}

					vint previousCount = 0;
					vint thisCount = 0;
					Window<T>* commonParent = nullptr;
					{
						auto current = previous;
						while (current)
						{
							previousCount++;
							current = current->parent;
						}
					}
					{
						auto current = this;
						while (current)
						{
							thisCount++;
							current = current->parent;
						}
					}
					{
						auto previousStep = previous;
						auto thisStep = this;
						if (previousCount < thisCount)
						{
							while (thisCount-- != previousCount)
							{
								thisStep = thisStep->parent;
							}
						}
						else if (previousCount > thisCount)
						{
							while (previousCount-- != thisCount)
							{
								previousStep = previousStep->parent;
							}
						}

						while (previousStep && thisStep && previousStep != thisStep)
						{
							previousStep = previousStep->parent;
							thisStep = thisStep->parent;
						}
						commonParent = thisStep;
					}
					{
						auto current = previous;
						while (current != commonParent)
						{
							if (current->renderedAsActive)
							{
								current->renderedAsActive = false;
								windowManager->OnDeactivated(current);
							}
							current = current->parent;
						}
					}
					{
						auto current = this;
						while (current != commonParent)
						{
							if (current->enabled && !current->renderedAsActive)
							{
								current->renderedAsActive = true;
								windowManager->OnActivated(current);
							}
							current = current->parent;
						}
					}

					if (commonParent != previous || commonParent != this)
					{
						windowManager->needRefresh = true;
					}

					BringToFront();
#undef ERROR_MESSAGE_PREFIX
				}

				void Deactivate()
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::Window<T>::Deactivate()#"
					ENSURE_WINDOW_MANAGER;

					if (!windowManager->mainWindow) return;
					if (!active) return;
					active = false;
					renderedAsActive = false;
					windowManager->OnLostFocus(this);
					windowManager->OnDeactivated(this);

					if (windowManager->activeWindow == this)
					{
						auto current = parent;
						while (current && !current->enabled)
						{
							current = current->parent;
						}
						windowManager->activeWindow = current;
						windowManager->needRefresh = true;
						if (current)
						{
							current->active = true;
							windowManager->OnGotFocus(current);
						}
					}
#undef ERROR_MESSAGE_PREFIX
				}

				void Show()
				{
					SetVisible(true);
					Activate();
				}
#undef ENSURE_WINDOW_MANAGER
			};

/***********************************************************************
WindowManager
***********************************************************************/

			template<typename T>
			struct WindowManager
			{
				collections::Dictionary<T, Window<T>*>		registeredWindows;
				collections::List<Window<T>*>				topMostedWindowsInOrder;
				collections::List<Window<T>*>				ordinaryWindowsInOrder;

				Window<T>*									mainWindow = nullptr;
				Window<T>*									activeWindow = nullptr;
				bool										needRefresh = false;

				virtual void OnOpened(Window<T>* window) = 0;
				virtual void OnClosed(Window<T>* window) = 0;
				virtual void OnEnabled(Window<T>* window) = 0;
				virtual void OnDisabled(Window<T>* window) = 0;
				virtual void OnGotFocus(Window<T>* window) = 0;
				virtual void OnLostFocus(Window<T>* window) = 0;
				virtual void OnActivated(Window<T>* window) = 0;
				virtual void OnDeactivated(Window<T>* window) = 0;

				void RegisterWindow(Window<T>* window)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::WindowManager<T>::RegisterWindow(Window<T>*)#"
					CHECK_ERROR(!window->windowManager, ERROR_MESSAGE_PREFIX L"The window has been registered.");
					CHECK_ERROR(!registeredWindows.Keys().Contains(window->id), ERROR_MESSAGE_PREFIX L"The window has a duplicated key with an existing window.");
					CHECK_ERROR(!window->visible, ERROR_MESSAGE_PREFIX L"RegisterWindow must be called right after a window is created.");

					window->windowManager = this;
					registeredWindows.Add(window->id, window);
#undef ERROR_MESSAGE_PREFIX
				}

				void UnregisterWindow(Window<T>* window)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::WindowManager<T>::UnregisterWindow(Window<T>*)#"
					CHECK_ERROR(window->windowManager == this, ERROR_MESSAGE_PREFIX L"The window has not been registered.");
					CHECK_ERROR(window != mainWindow, ERROR_MESSAGE_PREFIX L"The main window cannot be unregistered before stopping the window manager.");
					if (mainWindow)
					{
						window->SetVisible(false);

						auto parent = window->parent;
						for (auto child : window->children)
						{
							child->parent = parent;
						}

						if (parent)
						{
							CopyFrom(parent->children, window->children, true);
							parent->children.Remove(window);
						}
						window->parent = nullptr;
						window->children.Clear();
					}

					registeredWindows.Remove(window->id);
					window->windowManager = nullptr;
#undef ERROR_MESSAGE_PREFIX
				}

				void Start(Window<T>* window)
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::WindowManager<T>::Start(Window<T>*)#"
					CHECK_ERROR(!mainWindow, ERROR_MESSAGE_PREFIX L"The window manager has started.");
					CHECK_ERROR(!window->parent, ERROR_MESSAGE_PREFIX L"A main window should not have a parent window.");

					mainWindow = window;
					for (auto normalWindow : registeredWindows.Values())
					{
						if (!normalWindow->parent && normalWindow != mainWindow)
						{
							normalWindow->parent = mainWindow;
							mainWindow->children.Add(normalWindow);
						}
					}
#undef ERROR_MESSAGE_PREFIX
				}

				void Stop()
				{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::hosted_window_manager::WindowManager<T>::Stop(Window<T>*)#"
					CHECK_ERROR(mainWindow, ERROR_MESSAGE_PREFIX L"The window manager has stopped.");
					mainWindow = nullptr;
					activeWindow = nullptr;
					ordinaryWindowsInOrder.Clear();
					topMostedWindowsInOrder.Clear();

					for (auto window : registeredWindows.Values())
					{
						window->parent = nullptr;
						window->children.Clear();

						if (window->active)
						{
							window->active = false;
							OnLostFocus(window);
						}

						if (window->renderedAsActive)
						{
							window->renderedAsActive = false;
							OnDeactivated(window);
						}

						if (window->visible)
						{
							window->visible = false;
							OnClosed(window);
						}
					}
#undef ERROR_MESSAGE_PREFIX
				}

				Window<T>* HitTest(NativePoint position)
				{
					for (auto window : topMostedWindowsInOrder)
					{
						if (!window->visible) continue;
						if (window->bounds.Contains(position)) return window;
					}

					for (auto window : ordinaryWindowsInOrder)
					{
						if (!window->visible) continue;
						if (window->bounds.Contains(position)) return window;
					}

					return nullptr;
				}
			};
		}
	}
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\HOSTED\GUIHOSTEDWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Hosted Window

Interfaces:
  GuiHostedWindow

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDWINDOW
#define VCZH_PRESENTATION_GUIHOSTEDCONTROLLER_GUIHOSTEDWINDOW


namespace vl
{
	namespace presentation
	{
		class GuiHostedWindow;
		class GuiHostedController;

/***********************************************************************
Proxy
***********************************************************************/

		struct GuiHostedWindowData
		{
			hosted_window_manager::Window<GuiHostedWindow*>		wmWindow;
			GuiHostedController*								controller = nullptr;
			INativeWindow::WindowMode							windowMode = INativeWindow::WindowMode::Normal;
			collections::List<INativeWindowListener*>			listeners;

			WString												windowTitle;
			INativeCursor*										windowCursor = nullptr;
			NativePoint											windowCaretPoint;
			Ptr<GuiImageData>									windowIcon;

			bool												windowMaximizedBox = true;
			bool												windowMinimizedBox = true;
			bool												windowBorder = true;
			bool												windowSizeBox = true;
			bool												windowIconVisible = true;
			bool												windowTitleBar = true;

			INativeWindow::WindowSizeState						windowSizeState = INativeWindow::Restored;
			bool												windowShowInTaskBar = true;
			bool												windowEnabledActivate = true;
			bool												windowCustomFrameMode = true;

			GuiHostedWindowData(GuiHostedController* _controller, GuiHostedWindow* _window, INativeWindow::WindowMode _windowMode)
				: wmWindow(_window)
				, controller(_controller)
				, windowMode(_windowMode)
			{
			}
		};

		class IGuiHostedWindowProxy
			: public virtual Interface
		{
		public:
			virtual void			CheckAndSyncProperties() = 0;

			virtual NativeRect		FixBounds(const NativeRect& bounds) = 0;
			virtual void			UpdateBounds() = 0;
			virtual void			UpdateTitle() = 0;
			virtual void			UpdateIcon() = 0;
			virtual void			UpdateEnabled() = 0;
			virtual void			UpdateTopMost() = 0;

			virtual void			UpdateMaximizedBox() = 0;
			virtual void			UpdateMinimizedBox() = 0;
			virtual void			UpdateBorderVisible() = 0;
			virtual void			UpdateSizeBox() = 0;
			virtual void			UpdateIconVisible() = 0;
			virtual void			UpdateTitleBar() = 0;

			virtual void			UpdateShowInTaskBar() = 0;
			virtual void			UpdateEnabledActivate() = 0;
			virtual void			UpdateCustomFrameMode() = 0;

			virtual void			Show() = 0;
			virtual void			ShowDeactivated() = 0;
			virtual void			ShowRestored() = 0;
			virtual void			ShowMaximized() = 0;
			virtual void			ShowMinimized() = 0;
			virtual void			Hide() = 0;
			virtual void			Close() = 0;
			virtual void			SetFocus() = 0;
		};

		extern Ptr<IGuiHostedWindowProxy>		CreatePlaceholderHostedWindowProxy(GuiHostedWindowData* data);
		extern Ptr<IGuiHostedWindowProxy>		CreateMainHostedWindowProxy(GuiHostedWindowData* data, INativeWindow* nativeWindow);
		extern Ptr<IGuiHostedWindowProxy>		CreateNonMainHostedWindowProxy(GuiHostedWindowData* data, INativeWindow* nativeWindow);

/***********************************************************************
GuiHostedWindow
***********************************************************************/

		class GuiHostedWindow
			: public Object
			, public INativeWindow
			, protected GuiHostedWindowData
		{
			friend class GuiHostedController;
		protected:
			Ptr<IGuiHostedWindowProxy>		proxy;

			void							BecomeMainWindow();
			void							BecomeNonMainWindow();
			void							BecomeFocusedWindow();
			void							BecomeHoveringWindow();

		public:
			GuiHostedWindow(GuiHostedController* _controller, INativeWindow::WindowMode _windowMode);
			~GuiHostedWindow();

			// =============================================================
			// INativeWindow
			// =============================================================

			bool							IsActivelyRefreshing() override;
			NativeSize						GetRenderingOffset() override;
			Point							Convert(NativePoint value) override;
			NativePoint						Convert(Point value) override;
			Size							Convert(NativeSize value) override;
			NativeSize						Convert(Size value) override;
			Margin							Convert(NativeMargin value) override;
			NativeMargin					Convert(Margin value) override;
			NativeRect						GetBounds() override;
			void							SetBounds(const NativeRect& bounds) override;
			NativeSize						GetClientSize() override;
			void							SetClientSize(NativeSize size) override;
			NativeRect						GetClientBoundsInScreen() override;
			WString							GetTitle() override;
			void							SetTitle(const WString& title) override;
			INativeCursor*					GetWindowCursor() override;
			void							SetWindowCursor(INativeCursor* cursor) override;
			NativePoint						GetCaretPoint() override;
			void							SetCaretPoint(NativePoint point) override;
			INativeWindow*					GetParent() override;
			void							SetParent(INativeWindow* parent) override;
			WindowMode						GetWindowMode() override;
			void							EnableCustomFrameMode() override;
			void							DisableCustomFrameMode() override;
			bool							IsCustomFrameModeEnabled() override;
			NativeMargin					GetCustomFramePadding() override;
			Ptr<GuiImageData>				GetIcon() override;
			void							SetIcon(Ptr<GuiImageData> icon) override;
			WindowSizeState					GetSizeState() override;
			void							Show() override;
			void							ShowDeactivated() override;
			void							ShowRestored() override;
			void							ShowMaximized() override;
			void							ShowMinimized() override;
			void							Hide(bool closeWindow) override;
			bool							IsVisible() override;
			void							Enable() override;
			void							Disable() override;
			bool							IsEnabled() override;
			void							SetActivate() override;
			bool							IsActivated() override;
			bool							IsRenderingAsActivated() override;
			void							ShowInTaskBar() override;
			void							HideInTaskBar() override;
			bool							IsAppearedInTaskBar() override;
			void							EnableActivate() override;
			void							DisableActivate() override;
			bool							IsEnabledActivate() override;
			bool							RequireCapture() override;
			bool							ReleaseCapture() override;
			bool							IsCapturing() override;
			bool							GetMaximizedBox() override;
			void							SetMaximizedBox(bool visible) override;
			bool							GetMinimizedBox() override;
			void							SetMinimizedBox(bool visible) override;
			bool							GetBorder() override;
			void							SetBorder(bool visible) override;
			bool							GetSizeBox() override;
			void							SetSizeBox(bool visible) override;
			bool							GetIconVisible() override;
			void							SetIconVisible(bool visible) override;
			bool							GetTitleBar() override;
			void							SetTitleBar(bool visible) override;
			bool							GetTopMost() override;
			void							SetTopMost(bool topmost) override;
			void							SupressAlt() override;
			bool							InstallListener(INativeWindowListener* listener) override;
			bool							UninstallListener(INativeWindowListener* listener) override;
			void							RedrawContent() override;
		};
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIPLUGINMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIPLUGINMANAGER
#define VCZH_PRESENTATION_RESOURCES_GUIPLUGINMANAGER


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Plugin
***********************************************************************/

		/// <summary>Represents a plugin for the gui.</summary>
		class IGuiPlugin : public IDescriptable, public Description<IGuiPlugin>
		{
		public:
			/// <summary>Get the name of this plugin.</summary>
			/// <returns>Returns the name of the plugin.</returns>
			virtual WString									GetName() = 0;
			/// <summary>Get all dependencies of this plugin.</summary>
			/// <param name="dependencies">To receive all dependencies.</param>
			virtual void									GetDependencies(collections::List<WString>& dependencies) = 0;
			/// <summary>Called when the plugin manager want to load this plugin.</summary>
			/// <param name="controllerUnrelatedPlugins">A plugin only loads when it does not use anything from a <see cref="INativeController"/>.</param>
			/// <param name="controllerRelatedPlugins">A plugin only loads when it use anything from a <see cref="INativeController"/>.</param>
			virtual void									Load(bool controllerUnrelatedPlugins, bool controllerRelatedPlugins)=0;
			/// <summary>Called when the plugin manager want to unload this plugin.</summary>
			/// <param name="controllerUnrelatedPlugins">A plugin only unloads when it does not use anything from a <see cref="INativeController"/>.</param>
			/// <param name="controllerRelatedPlugins">A plugin only unloads when it use anything from a <see cref="INativeController"/>.</param>
			virtual void									Unload(bool controllerUnrelatedPlugins, bool controllerRelatedPlugins)=0;
		};

		/// <summary>Represents a plugin manager.</summary>
		class IGuiPluginManager : public IDescriptable, public Description<IGuiPluginManager>
		{
		public:
			/// <summary>Add a plugin before [F:vl.presentation.controls.IGuiPluginManager.Load] is called.</summary>
			/// <param name="plugin">The plugin.</param>
			virtual void									AddPlugin(Ptr<IGuiPlugin> plugin)=0;
			/// <summary>Load all plugins, and check if dependencies of all plugins are ready.</summary>
			/// <param name="controllerUnrelatedPlugins">Load plugins that does not use anything from a <see cref="INativeController"/>.</param>
			/// <param name="controllerRelatedPlugins">Load plugins that it use anything from a <see cref="INativeController"/>.</param>
			virtual void									Load(bool controllerUnrelatedPlugins, bool controllerRelatedPlugins)=0;
			/// <summary>Unload all plugins.</summary>
			/// <param name="controllerUnrelatedPlugins">Unload plugins that does not use anything from a <see cref="INativeController"/>.</param>
			/// <param name="controllerRelatedPlugins">Unload plugins that it use anything from a <see cref="INativeController"/>.</param>
			virtual void									Unload(bool controllerUnrelatedPlugins, bool controllerRelatedPlugins)=0;
			/// <returns>Returns true if all controller related plugins are loaded.</returns>
			virtual bool									IsControllerRelatedPluginsLoaded()=0;
			/// <returns>Returns true if all controller unrelated plugins are loaded.</returns>
			virtual bool									IsControllerUnrelatedPluginsLoaded()=0;
		};

/***********************************************************************
Plugin Manager
***********************************************************************/

		struct GuiPluginDescriptor
		{
			GuiPluginDescriptor*							next = nullptr;

			virtual Ptr<IGuiPlugin>							CreatePlugin() = 0;
		};

		/// <summary>Get the global <see cref="IGuiPluginManager"/> object.</summary>
		/// <returns>The global <see cref="IGuiPluginManager"/> object.</returns>
		extern IGuiPluginManager*							GetPluginManager();

		/// <summary>Register a plugin descriptor. Do not call this function directly, use GUI_REGISTER_PLUGIN macro instead.</summary>
		/// <param name="pluginDescriptor">The plugin descriptor.</param>
		extern void											RegisterPluginDescriptor(GuiPluginDescriptor* pluginDescriptor);

		/// <summary>Destroy the global <see cref="IGuiPluginManager"/> object.</summary>
		extern void											DestroyPluginManager();

#define GUI_REGISTER_PLUGIN(TYPE)\
	struct GuiRegisterPluginClass_##TYPE : private vl::presentation::GuiPluginDescriptor\
	{\
	private:\
		vl::Ptr<vl::presentation::IGuiPlugin> CreatePlugin() override\
		{\
			return vl::Ptr(new TYPE);\
		}\
	public:\
		GuiRegisterPluginClass_##TYPE()\
		{\
			vl::presentation::RegisterPluginDescriptor(this);\
		}\
	} instance_GuiRegisterPluginClass_##TYPE;\

#define GUI_PLUGIN_NAME(NAME)\
	vl::WString GetName()override { return L ## #NAME; }\
	void GetDependencies(vl::collections::List<WString>& dependencies)override\

#define GUI_PLUGIN_DEPEND(NAME) dependencies.Add(L ## #NAME)
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIRESOURCE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIRESOURCE
#define VCZH_PRESENTATION_RESOURCES_GUIRESOURCE


namespace vl
{
	namespace workflow
	{
		class IWfCompilerCallback;
	}

	namespace presentation
	{
		class GuiResourceItem;
		class GuiResourceFolder;
		class GuiResource;
		class GuiResourcePathResolver;

/***********************************************************************
Helper Functions
***********************************************************************/

		/// <summary>Get the folder path from a file path. The result folder path is ended with a separator.</summary>
		/// <returns>The folder path.</returns>
		/// <param name="filePath">The file path.</param>
		extern WString								GetFolderPath(const WString& filePath);
		/// <summary>Get the file name from a file path.</summary>
		/// <returns>The file name.</returns>
		/// <param name="filePath">The file path.</param>
		extern WString								GetFileName(const WString& filePath);
		/// <summary>Load a text file.</summary>
		/// <returns>Returns true if the operation succeeded.</returns>
		/// <param name="filePath">The text file path.</param>
		/// <param name="text">The text file content, if succeeded.</param>
		extern bool									LoadTextFile(const WString& filePath, WString& text);
		/// <summary>Test is a text a resource url and extract the protocol and the path.</summary>
		/// <returns>Returns true if the text is a resource url.</returns>
		/// <param name="text">The text.</param>
		/// <param name="protocol">The extracted protocol.</param>
		/// <param name="path">The extracted path.</param>
		extern bool									IsResourceUrl(const WString& text, WString& protocol, WString& path);

		extern void									HexToBinary(stream::IStream& binaryStream, const WString& hexText);
		extern WString								BinaryToHex(stream::IStream& binaryStream);

/***********************************************************************
Global String Key
***********************************************************************/

		struct GlobalStringKey
		{
		public:
			static GlobalStringKey					Empty;
			static GlobalStringKey					_InferType;
			static GlobalStringKey					_Set;
			static GlobalStringKey					_Ref;
			static GlobalStringKey					_Bind;
			static GlobalStringKey					_Format;
			static GlobalStringKey					_Str;
			static GlobalStringKey					_Eval;
			static GlobalStringKey					_Uri;
			static GlobalStringKey					_ControlTemplate;
			static GlobalStringKey					_ItemTemplate;

		private:
			vint									key = -1;

		public:
			GUI_DEFINE_COMPARE_OPERATORS(GlobalStringKey)

			static GlobalStringKey					Get(const WString& string);
			vint									ToKey()const;
			WString									ToString()const;
		};

/***********************************************************************
Resource Image
***********************************************************************/
			
		/// <summary>
		/// Represnets an image to display.
		/// </summary>
		class GuiImageData : public Object, public Description<GuiImageData>
		{
		protected:
			Ptr<INativeImage>				image;
			vint							frameIndex;

		public:
			/// <summary>Create an empty image data.</summary>
			GuiImageData();
			/// <summary>Create an image data with a specified image and a frame index.</summary>
			/// <param name="_image">The specified image.</param>
			/// <param name="_frameIndex">The specified frame index.</param>
			GuiImageData(Ptr<INativeImage> _image, vint _frameIndex);
			~GuiImageData();

			/// <summary>Get the specified image.</summary>
			/// <returns>The specified image.</returns>
			Ptr<INativeImage>				GetImage();
			/// <summary>Get the specified frame index.</summary>
			/// <returns>The specified frame index.</returns>
			vint							GetFrameIndex();
		};

/***********************************************************************
Resource String
***********************************************************************/

		/// <summary>Represents a text resource.</summary>
		class GuiTextData : public Object, public Description<GuiTextData>
		{
		protected:
			WString							text;

		public:
			/// <summary>Create an empty text data.</summary>
			GuiTextData();
			/// <summary>Create a text data with a specified text.</summary>
			/// <param name="_text">The specified text.</param>
			GuiTextData(const WString& _text);
			
			/// <summary>Get the specified text.</summary>
			/// <returns>The specified text.</returns>
			WString							GetText();
		};

/***********************************************************************
Resource Precompile Context
***********************************************************************/

		/// <summary>
		/// CPU architecture
		/// </summary>
		enum class GuiResourceCpuArchitecture
		{
			x86,
			x64,
			Unspecified,
		};

		/// <summary>
		/// Resource usage
		/// </summary>
		enum class GuiResourceUsage
		{
			DataOnly,
			InstanceClass,
		};

		/// <summary>Provide a context for resource precompiling</summary>
		struct GuiResourcePrecompileContext
		{
			typedef collections::Dictionary<Ptr<DescriptableObject>, Ptr<DescriptableObject>>	PropertyMap;

			/// <summary>The target CPU architecture.</summary>
			GuiResourceCpuArchitecture							targetCpuArchitecture = GuiResourceCpuArchitecture::Unspecified;
			/// <summary>Progress callback.</summary>
			workflow::IWfCompilerCallback*						compilerCallback = nullptr;
			/// <summary>The folder to contain compiled objects.</summary>
			Ptr<GuiResourceFolder>								targetFolder;
			/// <summary>The root resource object.</summary>
			GuiResource*										rootResource = nullptr;
			/// <summary>Indicate the pass index of this precompiling pass.</summary>
			vint												passIndex = -1;
			/// <summary>The path resolver. This is only for delay load resource.</summary>
			Ptr<GuiResourcePathResolver>						resolver;
			/// <summary>Additional properties for resource item contents</summary>
			PropertyMap											additionalProperties;
		};

		/// <summary>Provide a context for resource initializing</summary>
		struct GuiResourceInitializeContext : GuiResourcePrecompileContext
		{
			GuiResourceUsage									usage;
		};

/***********************************************************************
Resource Structure
***********************************************************************/

		/// <summary>Resource node base.</summary>
		class GuiResourceNodeBase : public Object, public Description<GuiResourceNodeBase>
		{
			friend class GuiResourceFolder;
		protected:
			GuiResourceFolder*						parent;
			WString									name;
			WString									fileContentPath;
			WString									fileAbsolutePath;
			
		public:
			GuiResourceNodeBase();
			~GuiResourceNodeBase();

			/// <summary>Get the containing folder. Returns null means that this is the root resource node.</summary>
			/// <returns>The containing folder.</returns>
			GuiResourceFolder*						GetParent();
			/// <summary>Get the name of this resource node.</summary>
			/// <returns>The name of this resource node .</returns>
			const WString&							GetName();
			/// <summary>Get the resource path of this resource node</summary>
			/// <returns>The resource path of this resource node .</returns>
			WString									GetResourcePath();
			/// <summary>Get the file content path of this resource node. When saving the resource, if the path is not empty, the path will be serialized instead of the content.</summary>
			/// <returns>The file content path of this resource node .</returns>
			const WString&							GetFileContentPath();
			/// <summary>Get the absolute file content path of this resource node. This path points to an existing file containing the content.</summary>
			/// <returns>The file absolute path of this resource node .</returns>
			const WString&							GetFileAbsolutePath();
			/// <summary>Set the file content path of this resource node.</summary>
			/// <param name="content">The file content path of this resource node .</param>
			/// <param name="absolute">The file absolute path of this resource node .</param>
			void									SetFileContentPath(const WString& content, const WString& absolute);
		};

		struct GuiResourceLocation
		{
			WString									resourcePath;
			WString									filePath;

			GuiResourceLocation() = default;
			GuiResourceLocation(const WString& _resourcePath, const WString& _filePath);
			GuiResourceLocation(Ptr<GuiResourceNodeBase> node);

			GUI_DEFINE_COMPARE_OPERATORS(GuiResourceLocation)
		};

		struct GuiResourceTextPos
		{
			GuiResourceLocation						originalLocation;
			vint									row = glr::ParsingTextPos::UnknownValue;
			vint									column = glr::ParsingTextPos::UnknownValue;

			GuiResourceTextPos() = default;
			GuiResourceTextPos(GuiResourceLocation location, glr::ParsingTextPos position);

			GUI_DEFINE_COMPARE_OPERATORS(GuiResourceTextPos)
		};

		struct GuiResourceError
		{
		public:
			using List = collections::List<GuiResourceError>;

			GuiResourceLocation						location;
			GuiResourceTextPos						position;
			WString									message;

			GuiResourceError() = default;
			GuiResourceError(GuiResourceTextPos _position, const WString& _message);
			GuiResourceError(GuiResourceLocation _location, const WString& _message);
			GuiResourceError(GuiResourceLocation _location, GuiResourceTextPos _position, const WString& _message);

			GUI_DEFINE_COMPARE_OPERATORS(GuiResourceError)

			static void								Transform(GuiResourceLocation _location, GuiResourceError::List& errors, collections::List<glr::ParsingError>& parsingErrors);
			static void								Transform(GuiResourceLocation _location, GuiResourceError::List& errors, collections::List<glr::ParsingError>& parsingErrors, glr::ParsingTextPos offset);
			static void								Transform(GuiResourceLocation _location, GuiResourceError::List& errors, collections::List<glr::ParsingError>& parsingErrors, GuiResourceTextPos offset);
			static void								SortAndLog(List& errors, collections::List<WString>& output, const WString& workingDirectory = WString::Empty);
		};

		class DocumentModel;
		class IGuiResourcePrecompileCallback;
		
		/// <summary>Resource item.</summary>
		class GuiResourceItem : public GuiResourceNodeBase, public Description<GuiResourceItem>
		{
			friend class GuiResourceFolder;
		protected:
			Ptr<DescriptableObject>					content;
			WString									typeName;
			
		public:
			/// <summary>Create a resource item.</summary>
			GuiResourceItem();
			~GuiResourceItem();

			/// <summary>Get the type of this resource item.</summary>
			/// <returns>The type name.</returns>
			const WString&							GetTypeName();
			
			/// <summary>Get the contained object for this resource item.</summary>
			/// <returns>The contained object.</returns>
			Ptr<DescriptableObject>					GetContent();
			/// <summary>Set the containd object for this resource item.</summary>
			/// <param name="_typeName">The type name of this contained object.</param>
			/// <param name="value">The contained object.</param>
			void									SetContent(const WString& _typeName, Ptr<DescriptableObject> value);

			/// <summary>Get the contained object as an image.</summary>
			/// <returns>The contained object.</returns>
			Ptr<GuiImageData>						AsImage();
			/// <summary>Get the contained object as an xml.</summary>
			/// <returns>The contained object.</returns>
			Ptr<glr::xml::XmlDocument>				AsXml();
			/// <summary>Get the contained object as a string.</summary>
			/// <returns>The contained object.</returns>
			Ptr<GuiTextData>						AsString();
			/// <summary>Get the contained object as a document model.</summary>
			/// <returns>The contained object.</returns>
			Ptr<DocumentModel>						AsDocument();
		};
		
		/// <summary>Resource folder. A resource folder contains many sub folders and sub items.</summary>
		class GuiResourceFolder : public GuiResourceNodeBase, public Description<GuiResourceFolder>
		{
		protected:
			typedef collections::Dictionary<WString, Ptr<GuiResourceItem>>		ItemMap;
			typedef collections::Dictionary<WString, Ptr<GuiResourceFolder>>	FolderMap;
			typedef collections::List<Ptr<GuiResourceItem>>						ItemList;
			typedef collections::List<Ptr<GuiResourceFolder>>					FolderList;

			struct DelayLoading
			{
				WString								type;
				WString								workingDirectory;
				Ptr<GuiResourceItem>				preloadResource;
			};

			typedef collections::List<DelayLoading>								DelayLoadingList;

			WString									importUri;
			ItemMap									items;
			FolderMap								folders;

			void									LoadResourceFolderFromXml(DelayLoadingList& delayLoadings, const WString& containingFolder, Ptr<glr::xml::XmlElement> folderXml, GuiResourceError::List& errors);
			void									SaveResourceFolderToXml(Ptr<glr::xml::XmlElement> xmlParent);
			void									CollectTypeNames(collections::List<WString>& typeNames);
			void									LoadResourceFolderFromBinary(DelayLoadingList& delayLoadings, stream::internal::ContextFreeReader& reader, collections::List<WString>& typeNames, GuiResourceError::List& errors);
			void									SaveResourceFolderToBinary(stream::internal::ContextFreeWriter& writer, collections::List<WString>& typeNames);
			void									PrecompileResourceFolder(GuiResourcePrecompileContext& context, IGuiResourcePrecompileCallback* callback, GuiResourceError::List& errors);
			void									InitializeResourceFolder(GuiResourceInitializeContext& context, GuiResourceError::List& errors);
			void									ImportFromUri(const WString& uri, GuiResourceTextPos position, GuiResourceError::List& errors);
		public:
			/// <summary>Create a resource folder.</summary>
			GuiResourceFolder();
			~GuiResourceFolder();

			///<summary>Get the import uri for this folder.</summary>
			///<returns>The import uri for this folder. Returns an empty string for non-import folders</returns>
			const WString&							GetImportUri();
			///<summary>Set the import uri for this folder.</summary>
			///<param name="uri">The import uri for this folder. Set an empty string for non-import folders</param>
			void									SetImportUri(const WString& uri);

			/// <summary>Get all sub items.</summary>
			/// <returns>All sub items.</returns>
			const ItemList&							GetItems();
			/// <summary>Get the item of a specified name.</summary>
			/// <returns>The item of a specified name.</returns>
			/// <param name="name">The specified name.</param>
			Ptr<GuiResourceItem>					GetItem(const WString& name);
			/// <summary>Add a resource item.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="name">The name of this resource item.</param>
			/// <param name="item">The resource item.</param>
			bool									AddItem(const WString& name, Ptr<GuiResourceItem> item);
			/// <summary>Remove a resource item of a specified name.</summary>
			/// <returns>Returns the removed resource item if this operation succeeded.</returns>
			/// <param name="name">The name of this resource item.</param>
			Ptr<GuiResourceItem>					RemoveItem(const WString& name);
			/// <summary>Remove all resource item.</summary>
			void									ClearItems();
			
			/// <summary>Get all sub folders.</summary>
			/// <returns>All sub folders.</returns>
			const FolderList&						GetFolders();
			/// <summary>Get the folder of a specified name.</summary>
			/// <returns>The folder of a specified name.</returns>
			/// <param name="name">The specified name.</param>
			Ptr<GuiResourceFolder>					GetFolder(const WString& name);
			/// <summary>Add a resource folder.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="name">The name of this resource folder.</param>
			/// <param name="folder">The resource folder.</param>
			bool									AddFolder(const WString& name, Ptr<GuiResourceFolder> folder);
			/// <summary>Remove a resource folder of a specified name.</summary>
			/// <returns>Returns the removed resource folder if this operation succeeded.</returns>
			/// <param name="name">The name of this resource folder.</param>
			Ptr<GuiResourceFolder>					RemoveFolder(const WString& name);
			/// <summary>Remove all resource folders.</summary>
			void									ClearFolders();

			/// <summary>Get a contained resource object using a path like "Packages\Application\Name".</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<DescriptableObject>					GetValueByPath(const WString& path);
			/// <summary>Get a resource folder using a path like "Packages\Application\Name\".</summary>
			/// <returns>The resource folder.</returns>
			/// <param name="path">The path.</param>
			Ptr<GuiResourceFolder>					GetFolderByPath(const WString& path);
			/// <summary>Create a contained resource object using a path like "Packages\Application\Name".</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="path">The path.</param>
			/// <param name="typeName">The type name of this contained object.</param>
			/// <param name="value">The contained object.</param>
			bool									CreateValueByPath(const WString& path, const WString& typeName, Ptr<DescriptableObject> value);
		};

/***********************************************************************
Resource
***********************************************************************/

		/// <summary>Resource metadata.</summary>
		class GuiResourceMetadata : public Object
		{
		public:
			WString									name;
			WString									version;
			collections::List<WString>				dependencies;

			void									LoadFromXml(Ptr<glr::xml::XmlDocument> xml, GuiResourceLocation location, GuiResourceError::List& errors);
			Ptr<glr::xml::XmlDocument>				SaveToXml();
		};
		
		/// <summary>Resource. A resource is a root resource folder that does not have a name.</summary>
		class GuiResource : public GuiResourceFolder, public Description<GuiResource>
		{
		protected:
			WString									workingDirectory;
			Ptr<GuiResourceMetadata>				metadata;

			static void								ProcessDelayLoading(Ptr<GuiResource> resource, DelayLoadingList& delayLoadings, GuiResourceError::List& errors);
		public:
			static const wchar_t*					CurrentVersionString;

			/// <summary>Create a resource.</summary>
			GuiResource();
			~GuiResource();

			/// <summary>Get the metadata of the resource.</summary>
			/// <returns>The metadata.</returns>
			Ptr<GuiResourceMetadata>				GetMetadata();

			/// <summary>Get the directory where the resource is load.</summary>
			/// <returns>The directory.</returns>
			WString									GetWorkingDirectory();

			/// <summary>Load a resource from an xml file. If the xml file refers other files, they will be loaded as well.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="xml">The xml document.</param>
			/// <param name="filePath">The file path of the resource.</param>
			/// <param name="workingDirectory">The working directory for loading external resources.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<GuiResource>					LoadFromXml(Ptr<glr::xml::XmlDocument> xml, const WString& filePath, const WString& workingDirectory, GuiResourceError::List& errors);

			/// <summary>Load a resource from an xml file. If the xml file refers other files, they will be loaded as well.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="filePath">The file path of the xml file.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<GuiResource>					LoadFromXml(const WString& filePath, GuiResourceError::List& errors);

			/// <summary>Save the resource to xml.</summary>
			/// <returns>The xml.</returns>
			Ptr<glr::xml::XmlDocument>				SaveToXml();
			
			/// <summary>Load a precompiled resource from a stream.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="binaryStream">The stream.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<GuiResource>					LoadPrecompiledBinary(stream::IStream& binaryStream, GuiResourceError::List& errors);

			/// <summary>Load a precompiled resource from a stream. This function will hit an assert if there are errors.</summary>
			/// <returns>The loaded resource.</returns>
			/// <param name="binaryStream">The stream.</param>
			static Ptr<GuiResource>					LoadPrecompiledBinary(stream::IStream& binaryStream);
			
			/// <summary>Save the precompiled resource to a stream.</summary>
			/// <param name="binaryStream">The stream.</param>
			void									SavePrecompiledBinary(stream::IStream& binaryStream);

			/// <summary>Precompile this resource to improve performance.</summary>
			/// <returns>The resource folder contains all precompiled result. The folder will be added to the resource if there is no error.</returns>
			/// <param name="callback">A callback to receive progress.</param>
			/// <param name="errors">All collected errors during precompiling a resource.</param>
			Ptr<GuiResourceFolder>					Precompile(GuiResourceCpuArchitecture targetCpuArchitecture, IGuiResourcePrecompileCallback* callback, GuiResourceError::List& errors);

			/// <summary>Initialize a precompiled resource.</summary>
			/// <param name="usage">In which role an application is initializing this resource.</param>
			/// <param name="errors">All collected errors during initializing a resource.</param>
			void									Initialize(GuiResourceUsage usage, GuiResourceError::List& errors);
			
			/// <summary>Get a contained document model using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<DocumentModel>						GetDocumentByPath(const WString& path);
			/// <summary>Get a contained image using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<GuiImageData>						GetImageByPath(const WString& path);
			/// <summary>Get a contained xml using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			Ptr<glr::xml::XmlDocument>				GetXmlByPath(const WString& path);
			/// <summary>Get a contained string object using a path like "Packages\Application\Name". If the path does not exists or the type does not match, an exception will be thrown.</summary>
			/// <returns>The containd resource object.</returns>
			/// <param name="path">The path.</param>
			WString									GetStringByPath(const WString& path);
		};

/***********************************************************************
Resource Path Resolver
***********************************************************************/

		/// <summary>Represents a symbol resolver for loading a resource of a certain protocol.</summary>
		class IGuiResourcePathResolver : public IDescriptable, public Description<IGuiResourcePathResolver>
		{
		public:
			/// <summary>Load a resource when the descriptor is something like a protocol-prefixed uri.</summary>
			/// <returns>The loaded resource. Returns null if failed to load.</returns>
			/// <param name="path">The path.</param>
			virtual Ptr<DescriptableObject>					ResolveResource(const WString& path)=0;
		};

		/// <summary>Represents an <see cref="IGuiResourcePathResolver"/> factory.</summary>
		class IGuiResourcePathResolverFactory : public IDescriptable, public Description<IGuiResourcePathResolverFactory>
		{
		public:
			/// <summary>Get the protocol for this resolver.</summary>
			/// <returns>The protocol.</returns>
			virtual WString									GetProtocol()=0;

			/// <summary>Create an <see cref="IGuiResourcePathResolver"/> object.</summary>
			/// <returns>The created resolver.</returns>
			/// <param name="resource">The resource context.</param>
			/// <param name="workingDirectory">The working directory context.</param>
			virtual Ptr<IGuiResourcePathResolver>			CreateResolver(Ptr<GuiResource> resource, const WString& workingDirectory)=0;
		};
		
		/// <summary>Represents a symbol resolver for loading a resource.</summary>
		class GuiResourcePathResolver : public Object, public Description<GuiResourcePathResolver>
		{
			typedef collections::Dictionary<WString, Ptr<IGuiResourcePathResolver>>		ResolverMap;
		protected:
			ResolverMap										resolvers;
			Ptr<GuiResource>								resource;
			WString											workingDirectory;

		public:
			/// <summary>Create a resolver.</summary>
			/// <param name="_resource">The resource context.</param>
			/// <param name="_workingDirectory">The working directory context.</param>
			GuiResourcePathResolver(Ptr<GuiResource> _resource, const WString& _workingDirectory);
			~GuiResourcePathResolver();

			/// <summary>Load a resource when the descriptor is something like a protocol-prefixed uri.</summary>
			/// <returns>The loaded resource. Returns null if failed to load.</returns>
			/// <param name="protocol">The protocol.</param>
			/// <param name="path">The path.</param>
			Ptr<DescriptableObject>							ResolveResource(const WString& protocol, const WString& path);
		};

/***********************************************************************
Resource Type Resolver
***********************************************************************/

		class IGuiResourceTypeResolver_Precompile;
		class IGuiResourceTypeResolver_Initialize;
		class IGuiResourceTypeResolver_DirectLoadXml;
		class IGuiResourceTypeResolver_DirectLoadStream;
		class IGuiResourceTypeResolver_IndirectLoad;

		/// <summary>Represents a symbol type for loading a resource.</summary>
		class IGuiResourceTypeResolver : public virtual IDescriptable, public Description<IGuiResourceTypeResolver>
		{
		public:
			/// <summary>Get the type of the resource that load by this resolver.</summary>
			/// <returns>The type.</returns>
			virtual WString										GetType() = 0;
			/// <summary>Test is this resource able to serialize in an XML resource or not.</summary>
			/// <returns>Returns true if this resource is able to serialize in an XML resource.</returns>
			virtual bool										XmlSerializable() = 0;
			/// <summary>Test is this resource able to serialize in a precompiled binary resource or not.</summary>
			/// <returns>Returns true if this resource is able to serialize in a precompiled binary resource.</returns>
			virtual bool										StreamSerializable() = 0;
			
			/// <summary>Get the precompiler for the type resolver.</summary>
			/// <returns>Returns null if the type resolve does not support precompiling.</returns>
			virtual IGuiResourceTypeResolver_Precompile*		Precompile(){ return nullptr; }
			/// <summary>Get the initializer for the type resolver.</summary>
			/// <returns>Returns null if the type resolve does not support initializing.</returns>
			virtual IGuiResourceTypeResolver_Initialize*		Initialize(){ return nullptr; }
			/// <summary>Get the object for convert the resource between xml and object.</summary>
			/// <returns>Returns null if the type resolver does not have this ability.</returns>
			virtual IGuiResourceTypeResolver_DirectLoadXml*		DirectLoadXml(){ return nullptr; }
			/// <summary>Get the object for convert the resource between stream and object.</summary>
			/// <returns>Returns null if the type resolver does not have this ability.</returns>
			virtual IGuiResourceTypeResolver_DirectLoadStream*	DirectLoadStream(){ return nullptr; }
			/// <summary>Get the object for convert the resource between the preload type and the current type.</summary>
			/// <returns>Returns null if the type resolver does not have this ability.</returns>
			virtual IGuiResourceTypeResolver_IndirectLoad*		IndirectLoad(){ return nullptr; }
		};

		/// <summary>
		///		Represents a precompiler for resources of a specified type.
		///		Current resources that needs precompiling:
		///		Workflow:
		///			Pass  0: Collect workflow scripts / Compile localized strings / Generate ClassNameRecord
		///			Pass  1: Compile workflow scripts
		///		Instance:
		///			Pass  2: Collect instance types													/ Compile animation types
		///			Pass  3: Compile
		///			Pass  4: Generate instance types with event handler functions to TemporaryClass	/ Compile animation types
		///			Pass  5: Compile
		///			Pass  6: Generate instance types with everything to InstanceCtor				/ Compile animation types / Compile localized strings injection
		///			Pass  7: Compile
		/// </summary>
		class IGuiResourceTypeResolver_Precompile : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_Precompile>
		{
		public:
			enum PassNames
			{
				Workflow_Collect					= 0,
				Workflow_Compile					= 1,
				Workflow_Max						= Workflow_Compile,

				Instance_CollectInstanceTypes		= 2,
				Instance_CompileInstanceTypes		= 3,
				Instance_CollectEventHandlers		= 4,
				Instance_CompileEventHandlers		= 5,
				Instance_GenerateInstanceClass		= 6,
				Instance_CompileInstanceClass		= 7,
				Instance_Max						= Instance_CompileInstanceClass,

				Everything_Max						= Instance_Max,
			};

			enum PassSupport
			{
				NotSupported,
				PerResource,
				PerPass,
			};

			/// <summary>Get how this resolver supports precompiling.</summary>
			/// <param name="passIndex">The pass index.</param>
			/// <returns>Returns how this resolver supports precompiling.</returns>
			virtual PassSupport									GetPrecompilePassSupport(vint passIndex) = 0;
			/// <summary>Precompile the resource item.</summary>
			/// <param name="resource">The resource to precompile.</param>
			/// <param name="context">The context for precompiling.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual void										PerResourcePrecompile(Ptr<GuiResourceItem> resource, GuiResourcePrecompileContext& context, GuiResourceError::List& errors) = 0;
			/// <summary>Precompile for a pass.</summary>
			/// <param name="context">The context for precompiling.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual void										PerPassPrecompile(GuiResourcePrecompileContext& context, GuiResourceError::List& errors) = 0;
		};

		class IGuiResourcePrecompileCallback : public virtual IDescriptable, public Description<IGuiResourcePrecompileCallback>
		{
		public:
			virtual workflow::IWfCompilerCallback*				GetCompilerCallback() = 0;
			virtual void										OnPerPass(vint passIndex) = 0;
			virtual void										OnPerResource(vint passIndex, Ptr<GuiResourceItem> resource) = 0;
		};

		/// <summary>
		///		Represents a precompiler for resources of a specified type.
		///		Current resources that needs precompiling:
		///			Pass 0: Script		(initialize view model scripts)
		///			Pass 1: Script		(initialize shared scripts)
		///			Pass 2: Script		(initialize instance scripts)
		/// </summary>
		class IGuiResourceTypeResolver_Initialize : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_Initialize>
		{
		public:
			enum PassNames
			{
				Workflow_Initialize					= 0,
				Everything_Max						= Workflow_Initialize,
			};

			/// <summary>Get how this resolver supports precompiling.</summary>
			/// <param name="passIndex">The pass index.</param>
			/// <returns>Returns how this resolver supports precompiling.</returns>
			virtual bool										GetInitializePassSupport(vint passIndex) = 0;
			/// <summary>Initialize the resource item.</summary>
			/// <param name="resource">The resource to initializer.</param>
			/// <param name="context">The context for initializing.</param>
			/// <param name="errors">All collected errors during initializing a resource.</param>
			virtual void										Initialize(Ptr<GuiResourceItem> resource, GuiResourceInitializeContext& context, GuiResourceError::List& errors) = 0;
		};

		/// <summary>Represents a symbol type for loading a resource without a preload type.</summary>
		class IGuiResourceTypeResolver_DirectLoadXml : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_DirectLoadXml>
		{
		public:
			/// <summary>Serialize a resource to an xml element. This function is called if this type resolver does not have a preload type.</summary>
			/// <returns>The serialized xml element.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="content">The object to serialize.</param>
			virtual Ptr<glr::xml::XmlElement>					Serialize(Ptr<GuiResourceItem> resource, Ptr<DescriptableObject> content) = 0;

			/// <summary>Load a resource for a type inside an xml element.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="element">The xml element.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlElement> element, GuiResourceError::List& errors) = 0;

			/// <summary>Load a resource for a type from a file.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="path">The file path.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<GuiResourceItem> resource, const WString& path, GuiResourceError::List& errors) = 0;
		};

		/// <summary>Represents a symbol type for loading a resource without a preload type.</summary>
		class IGuiResourceTypeResolver_DirectLoadStream : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_DirectLoadStream>
		{
		public:
			/// <summary>Serialize a precompiled resource to a stream.</summary>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="content">The content to serialize.</param>
			/// <param name="binaryStream">The stream.</param>
			virtual void										SerializePrecompiled(Ptr<GuiResourceItem> resource, Ptr<DescriptableObject> content, stream::IStream& binaryStream) = 0;

			/// <summary>Load a precompiled resource from a stream.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="binaryStream">The stream.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResourcePrecompiled(Ptr<GuiResourceItem> resource, stream::IStream& binaryStream, GuiResourceError::List& errors) = 0;
		};

		/// <summary>Represents a symbol type for loading a resource with a preload type.</summary>
		class IGuiResourceTypeResolver_IndirectLoad : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_IndirectLoad>
		{
		public:
			/// <summary>Get the preload type to load the resource before loading itself.</summary>
			/// <returns>The preload type. Returns an empty string to indicate that there is no preload type for this resolver.</returns>
			virtual WString										GetPreloadType() = 0;
			/// <summary>Get the delay load feature for this resolver.</summary>
			/// <returns>Returns true if this type need to delay load.</returns>
			virtual bool										IsDelayLoad() = 0;

			/// <summary>Serialize a resource to a resource in preload type.</summary>
			/// <returns>The serialized resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="content">The object to serialize.</param>
			virtual Ptr<DescriptableObject>						Serialize(Ptr<GuiResourceItem> resource, Ptr<DescriptableObject> content) = 0;

			/// <summary>Load a resource for a type from a resource loaded by the preload type resolver.</summary>
			/// <returns>The resource.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="resolver">The path resolver. This is only for delay load resource.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<GuiResourceItem> resource, Ptr<GuiResourcePathResolver> resolver, GuiResourceError::List& errors) = 0;
		};

/***********************************************************************
Resource Resolver Manager
***********************************************************************/

		/// <summary>A resource resolver manager.</summary>
		class IGuiResourceResolverManager : public IDescriptable, public Description<IGuiResourceResolverManager>
		{
		public:
			/// <summary>Get the <see cref="IGuiResourcePathResolverFactory"/> for a protocol.</summary>
			/// <returns>The factory.</returns>
			/// <param name="protocol">The protocol.</param>
			virtual IGuiResourcePathResolverFactory*			GetPathResolverFactory(const WString& protocol) = 0;
			/// <summary>Set the <see cref="IGuiResourcePathResolverFactory"/> for a protocol.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="factory">The factory.</param>
			virtual bool										SetPathResolverFactory(Ptr<IGuiResourcePathResolverFactory> factory) = 0;
			/// <summary>Get the <see cref="IGuiResourceTypeResolver"/> for a resource type.</summary>
			/// <returns>The resolver.</returns>
			/// <param name="type">The resource type.</param>
			virtual IGuiResourceTypeResolver*					GetTypeResolver(const WString& type) = 0;
			/// <summary>Set the <see cref="IGuiResourceTypeResolver"/> for a resource type.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="resolver">The resolver.</param>
			virtual bool										SetTypeResolver(Ptr<IGuiResourceTypeResolver> resolver) = 0;
			/// <summary>Get names of all per resource resolvers for a pass.</summary>
			/// <param name="passIndex">The pass index.</param>
			/// <param name="names">Names of resolvers</param>
			virtual void										GetPerResourceResolverNames(vint passIndex, collections::List<WString>& names) = 0;
			/// <summary>Get names of all per pass resolvers for a pass.</summary>
			/// <param name="passIndex">The pass index.</param>
			/// <param name="names">Names of resolvers</param>
			virtual void										GetPerPassResolverNames(vint passIndex, collections::List<WString>& names) = 0;
		};
		
		extern IGuiResourceResolverManager*						GetResourceResolverManager();
		extern void												DecompressStream(const char** buffer, bool compress, vint rows, vint block, vint remain, stream::IStream& outputStream);
	}
}

#endif

/***********************************************************************
.\APPLICATION\CONTROLS\GUIINSTANCEROOTOBJECT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUIINSTANCEROOTOBJECT
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUIINSTANCEROOTOBJECT


namespace vl
{
	namespace presentation
	{
		namespace templates
		{
			class GuiTemplate;
		}

		namespace controls
		{
			class GuiControlHost;
			class GuiCustomControl;

/***********************************************************************
Component
***********************************************************************/

			class GuiInstanceRootObject;

			/// <summary>
			/// Represnets a component.
			/// </summary>
			class GuiComponent : public Object, public Description<GuiComponent>
			{
			public:
				GuiComponent();
				~GuiComponent();

				virtual void							Attach(GuiInstanceRootObject* rootObject);
				virtual void							Detach(GuiInstanceRootObject* rootObject);
			};

/***********************************************************************
Animation
***********************************************************************/

			/// <summary>Animation.</summary>
			class IGuiAnimation abstract : public virtual IDescriptable, public Description<IGuiAnimation>
			{
			public:
				/// <summary>Called when the animation is about to play the first frame.</summary>
				virtual void							Start() = 0;

				/// <summary>Called when the animation is about to pause.</summary>
				virtual void							Pause() = 0;

				/// <summary>Called when the animation is about to resume.</summary>
				virtual void							Resume() = 0;

				/// <summary>Play the animation. The animation should calculate the time itself to determine the content of the current state of animating objects.</summary>
				virtual void							Run() = 0;

				/// <summary>Test if the animation has ended.</summary>
				/// <returns>Returns true if the animation has ended.</returns>
				virtual bool							GetStopped() = 0;

				/// <summary>Create a finite animation.</summary>
				/// <returns>Returns the created animation.</returns>
				/// <param name="run">The animation callback for each frame.</param>
				/// <param name="milliseconds">The length of the animation.</param>
				static Ptr<IGuiAnimation>				CreateAnimation(const Func<void(vuint64_t)>& run, vuint64_t milliseconds);

				/// <summary>Create an infinite animation.</summary>
				/// <returns>Returns the created animation.</returns>
				/// <param name="run">The animation callback for each frame.</param>
				static Ptr<IGuiAnimation>				CreateAnimation(const Func<void(vuint64_t)>& run);
			};

/***********************************************************************
Root Object
***********************************************************************/

			class RootObjectTimerCallback;

			/// <summary>Represnets a root GUI object.</summary>
			class GuiInstanceRootObject abstract : public Description<GuiInstanceRootObject>
			{
				friend class RootObjectTimerCallback;
				using SubscriptionList = collections::List<Ptr<description::IValueSubscription>>;
				using ObjectMap = collections::Dictionary<WString, reflection::description::Value>;
			protected:
				Ptr<GuiResourcePathResolver>					resourceResolver;
				ObjectMap										namedObjects;
				SubscriptionList								subscriptions;
				collections::SortedList<GuiComponent*>			components;
				Ptr<RootObjectTimerCallback>					timerCallback;
				collections::SortedList<Ptr<IGuiAnimation>>		runningAnimations;
				collections::SortedList<Ptr<IGuiAnimation>>		pendingAnimations;
				bool											finalized = false;

				virtual controls::GuiControlHost*				GetControlHostForInstance() = 0;
				void											InstallTimerCallback(controls::GuiControlHost* controlHost);
				bool											UninstallTimerCallback(controls::GuiControlHost* controlHost);
				void											OnControlHostForInstanceChanged();
				void											StartPendingAnimations();
			public:
				GuiInstanceRootObject();
				~GuiInstanceRootObject();

				/// <summary>Clear all subscriptions and components.</summary>
				void											FinalizeInstance();

				/// <summary>Test has the object been finalized.</summary>
				/// <returns>Returns true if this object has been finalized.</returns>
				bool											IsFinalized();

				void											FinalizeInstanceRecursively(templates::GuiTemplate* thisObject);
				void											FinalizeInstanceRecursively(GuiCustomControl* thisObject);
				void											FinalizeInstanceRecursively(GuiControlHost* thisObject);
				void											FinalizeGeneralInstance(GuiInstanceRootObject* thisObject);

				/// <summary>Set the resource resolver to connect the current root object to the resource creating it.</summary>
				/// <param name="resolver">The resource resolver</param>
				void											SetResourceResolver(Ptr<GuiResourcePathResolver> resolver);
				/// <summary>Resolve a resource using the current resource resolver.</summary>
				/// <returns>The loaded resource. Returns null if failed to load.</returns>
				/// <param name="protocol">The protocol.</param>
				/// <param name="path">The path.</param>
				/// <param name="ensureExist">Set to true and it will throw an exception if the resource doesn't exist.</param>
				Ptr<DescriptableObject>							ResolveResource(const WString& protocol, const WString& path, bool ensureExist);

				/// <summary>Add a subscription. When this control host is disposing, all attached subscriptions will be deleted.</summary>
				/// <returns>Returns null if this operation failed.</returns>
				/// <param name="subscription">The subscription to test.</param>
				Ptr<description::IValueSubscription>			AddSubscription(Ptr<description::IValueSubscription> subscription);
				/// <summary>Clear all subscriptions.</summary>
				void											UpdateSubscriptions();

				/// <summary>Add a component. When this control host is disposing, all attached components will be deleted.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="component">The component to add.</param>
				bool											AddComponent(GuiComponent* component);

				/// <summary>Add a control host as a component. When this control host is disposing, all attached components will be deleted.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="controlHost">The controlHost to add.</param>
				bool											AddControlHostComponent(GuiControlHost* controlHost);

				/// <summary>Add an animation. The animation will be paused if the root object is removed from a window.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="animation">The animation.</param>
				bool											AddAnimation(Ptr<IGuiAnimation> animation);

				/// <summary>Kill an animation.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="animation">The animation.</param>
				bool											KillAnimation(Ptr<IGuiAnimation> animation);

				/// <summary>
				/// Get the object by name, which is set by <see cref="SetNamedObject"/>.
				/// </summary>
				/// <param name="name">The name of the object.</param>
				/// <returns>The object. Returns null if the name is not taken.</returns>
				reflection::description::Value					GetNamedObject(const WString& name);

				/// <summary>
				/// Set an object with a name. If the name has been taken, the previous object will be replaced.
				/// </summary>
				/// <param name="name">The name of the object.</param>
				/// <param name="namedObject">The object.</param>
				void											SetNamedObject(const WString& name, const reflection::description::Value& namedObject);
			};
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\CONTROLS\GUITHEMEMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITHEMEMANAGER
#define VCZH_PRESENTATION_CONTROLS_GUITHEMEMANAGER


namespace vl
{
	namespace presentation
	{
		namespace templates
		{

/***********************************************************************
Theme Builders
***********************************************************************/

#define GUI_TEMPLATE_PROPERTY_DECL(CLASS, TYPE, NAME, VALUE)\
			private:\
				TYPE NAME##_ = VALUE;\
			public:\
				TYPE Get##NAME();\
				void Set##NAME(TYPE const& value);\
				compositions::GuiNotifyEvent NAME##Changed;\

#define GUI_TEMPLATE_PROPERTY_IMPL(CLASS, TYPE, NAME, VALUE)\
			TYPE CLASS::Get##NAME()\
			{\
				return NAME##_;\
			}\
			void CLASS::Set##NAME(TYPE const& value)\
			{\
				if (NAME##_ != value)\
				{\
					NAME##_ = value;\
					NAME##Changed.Execute(compositions::GuiEventArgs(this));\
				}\
			}\

#define GUI_TEMPLATE_PROPERTY_EVENT_INIT(CLASS, TYPE, NAME, VALUE)\
			NAME##Changed.SetAssociatedComposition(this);

#define GUI_TEMPLATE_CLASS_FORWARD_DECL(CLASS, BASE)\
			class CLASS;\

#define GUI_TEMPLATE_CLASS_DECL(CLASS, BASE)\
			class CLASS : public BASE, public AggregatableDescription<CLASS>\
			{\
			public:\
				CLASS();\
				~CLASS();\
				CLASS ## _PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)\
			};\

#define GUI_TEMPLATE_CLASS_IMPL(CLASS, BASE)\
			CLASS ## _PROPERTIES(GUI_TEMPLATE_PROPERTY_IMPL)\
			CLASS::CLASS()\
			{\
				CLASS ## _PROPERTIES(GUI_TEMPLATE_PROPERTY_EVENT_INIT)\
			}\
			CLASS::~CLASS()\
			{\
				FinalizeAggregation();\
			}\

/***********************************************************************
GuiTemplate
***********************************************************************/

			/// <summary>Represents a user customizable template.</summary>
			class GuiTemplate : public compositions::GuiBoundsComposition, public controls::GuiInstanceRootObject, public Description<GuiTemplate>
			{
			protected:
				controls::GuiControlHost*		GetControlHostForInstance()override;
				void							OnParentLineChanged()override;
			public:
				/// <summary>Create a template.</summary>
				GuiTemplate();
				~GuiTemplate();
				
#define GuiTemplate_PROPERTIES(F)\
				F(GuiTemplate,	FontProperties,		Font,				{}	)\
				F(GuiTemplate,	description::Value,	Context,			{}	)\
				F(GuiTemplate,	WString,			Text,				{}	)\
				F(GuiTemplate,	bool,				VisuallyEnabled,	true)\

				GuiTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

/***********************************************************************
Core Themes
***********************************************************************/

#define GUI_CORE_CONTROL_TEMPLATE_DECL(F)\
			F(GuiControlTemplate,				GuiTemplate)				\
			F(GuiLabelTemplate,					GuiControlTemplate)			\
			F(GuiWindowTemplate,				GuiControlTemplate)			\

#define GuiControlTemplate_PROPERTIES(F)\
				F(GuiControlTemplate, compositions::GuiGraphicsComposition*, ContainerComposition, this)\
				F(GuiControlTemplate, compositions::GuiGraphicsComposition*, FocusableComposition, nullptr)\
				F(GuiControlTemplate, bool, Focused, false)\

#define GuiLabelTemplate_PROPERTIES(F)\
				F(GuiLabelTemplate, Color, DefaultTextColor, {})\
				F(GuiLabelTemplate, Color, TextColor, {})\

#define GuiWindowTemplate_PROPERTIES(F)\
				F(GuiWindowTemplate, BoolOption, MaximizedBoxOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, MinimizedBoxOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, BorderOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, SizeBoxOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, IconVisibleOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, BoolOption, TitleBarOption, BoolOption::Customizable)\
				F(GuiWindowTemplate, bool, MaximizedBox, true)\
				F(GuiWindowTemplate, bool, MinimizedBox, true)\
				F(GuiWindowTemplate, bool, Border, true)\
				F(GuiWindowTemplate, bool, SizeBox, true)\
				F(GuiWindowTemplate, bool, IconVisible, true)\
				F(GuiWindowTemplate, bool, TitleBar, true)\
				F(GuiWindowTemplate, bool, Maximized, false)\
				F(GuiWindowTemplate, bool, Activated, false)\
				F(GuiWindowTemplate, TemplateProperty<GuiWindowTemplate>, TooltipTemplate, {})\
				F(GuiWindowTemplate, TemplateProperty<GuiLabelTemplate>, ShortcutKeyTemplate, {})\
				F(GuiWindowTemplate, bool, CustomFrameEnabled, true)\
				F(GuiWindowTemplate, Margin, CustomFramePadding, {})\
				F(GuiWindowTemplate, Ptr<GuiImageData>, Icon, {})\

/***********************************************************************
Template Declarations
***********************************************************************/

			GUI_CORE_CONTROL_TEMPLATE_DECL(GUI_TEMPLATE_CLASS_DECL)
		}

/***********************************************************************
Theme Names
***********************************************************************/

		namespace theme
		{

#define GUI_CONTROL_TEMPLATE_TYPES(F) \
			F(WindowTemplate,				SystemFrameWindow)			\
			F(WindowTemplate,				CustomFrameWindow)			\
			F(ControlTemplate,				CustomControl)				\
			F(WindowTemplate,				Tooltip)					\
			F(LabelTemplate,				Label)						\
			F(LabelTemplate,				ShortcutKey)				\
			F(ScrollViewTemplate,			ScrollView)					\
			F(ControlTemplate,				GroupBox)					\
			F(TabTemplate,					Tab)						\
			F(ComboBoxTemplate,				ComboBox)					\
			F(MultilineTextBoxTemplate,		MultilineTextBox)			\
			F(SinglelineTextBoxTemplate,	SinglelineTextBox)			\
			F(DocumentViewerTemplate,		DocumentViewer)				\
			F(DocumentLabelTemplate,		DocumentLabel)				\
			F(DocumentLabelTemplate,		DocumentTextBox)			\
			F(ListViewTemplate,				ListView)					\
			F(TreeViewTemplate,				TreeView)					\
			F(TextListTemplate,				TextList)					\
			F(SelectableButtonTemplate,		ListItemBackground)			\
			F(SelectableButtonTemplate,		TreeItemExpander)			\
			F(SelectableButtonTemplate,		CheckTextListItem)			\
			F(SelectableButtonTemplate,		RadioTextListItem)			\
			F(MenuTemplate,					Menu)						\
			F(ControlTemplate,				MenuBar)					\
			F(ControlTemplate,				MenuSplitter)				\
			F(ToolstripButtonTemplate,		MenuBarButton)				\
			F(ToolstripButtonTemplate,		MenuItemButton)				\
			F(ControlTemplate,				ToolstripToolBar)			\
			F(ToolstripButtonTemplate,		ToolstripButton)			\
			F(ToolstripButtonTemplate,		ToolstripDropdownButton)	\
			F(ToolstripButtonTemplate,		ToolstripSplitButton)		\
			F(ControlTemplate,				ToolstripSplitter)			\
			F(RibbonTabTemplate,			RibbonTab)					\
			F(RibbonGroupTemplate,			RibbonGroup)				\
			F(RibbonGroupMenuTemplate,		RibbonGroupMenu)			\
			F(RibbonIconLabelTemplate,		RibbonIconLabel)			\
			F(RibbonIconLabelTemplate,		RibbonSmallIconLabel)		\
			F(RibbonButtonsTemplate,		RibbonButtons)				\
			F(RibbonToolstripsTemplate,		RibbonToolstrips)			\
			F(RibbonGalleryTemplate,		RibbonGallery)				\
			F(RibbonToolstripMenuTemplate,	RibbonToolstripMenu)		\
			F(RibbonGalleryListTemplate,	RibbonGalleryList)			\
			F(TextListTemplate,				RibbonGalleryItemList)		\
			F(ToolstripButtonTemplate,		RibbonSmallButton)			\
			F(ToolstripButtonTemplate,		RibbonSmallDropdownButton)	\
			F(ToolstripButtonTemplate,		RibbonSmallSplitButton)		\
			F(ToolstripButtonTemplate,		RibbonLargeButton)			\
			F(ToolstripButtonTemplate,		RibbonLargeDropdownButton)	\
			F(ToolstripButtonTemplate,		RibbonLargeSplitButton)		\
			F(ControlTemplate,				RibbonSplitter)				\
			F(ControlTemplate,				RibbonToolstripHeader)		\
			F(ButtonTemplate,				Button)						\
			F(SelectableButtonTemplate,		CheckBox)					\
			F(SelectableButtonTemplate,		RadioButton)				\
			F(DatePickerTemplate,			DatePicker)					\
			F(DateComboBoxTemplate,			DateComboBox)				\
			F(ScrollTemplate,				HScroll)					\
			F(ScrollTemplate,				VScroll)					\
			F(ScrollTemplate,				HTracker)					\
			F(ScrollTemplate,				VTracker)					\
			F(ScrollTemplate,				ProgressBar)				\

			enum class ThemeName
			{
				Unknown,
				Window,
#define GUI_DEFINE_THEME_NAME(TEMPLATE, CONTROL) CONTROL,
				GUI_CONTROL_TEMPLATE_TYPES(GUI_DEFINE_THEME_NAME)
#undef GUI_DEFINE_THEME_NAME
			};

			/// <summary>Theme interface. A theme creates appropriate style controllers or style providers for default controls. Call [M:vl.presentation.theme.GetCurrentTheme] to access this interface.</summary>
			class ITheme : public virtual IDescriptable, public Description<ITheme>
			{
			public:
				virtual TemplateProperty<templates::GuiControlTemplate>				CreateStyle(ThemeName themeName) = 0;
			};

			/// <summary>Get the current theme style factory object. Call <see cref="RegisterTheme"/> or <see cref="UnregisterTheme"/> to change the default theme.</summary>
			/// <returns>The current theme style factory object.</returns>
			extern ITheme*						GetCurrentTheme();
			extern void							InitializeTheme();
			extern void							FinalizeTheme();
		}
	}
}

#endif

/***********************************************************************
.\APPLICATION\CONTROLS\GUIBASICCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			enum class ThemeName;
		}

		namespace controls
		{
			template<typename T, typename=void>
			struct QueryServiceHelper;

			template<typename T>
			struct QueryServiceHelper<T, std::enable_if_t<std::is_convertible_v<decltype(T::Identifier), const wchar_t* const>>>
			{
				static WString GetIdentifier()
				{
					return WString::Unmanaged(T::Identifier);
				}
			};

			template<typename T>
			struct QueryServiceHelper<T, std::enable_if_t<std::is_convertible_v<decltype(T::GetIdentifier()), WString>>>
			{
				static WString GetIdentifier()
				{
					return MoveValue<WString>(T::GetIdentifier());
				}
			};

/***********************************************************************
Basic Construction
***********************************************************************/

			/// <summary>
			/// A helper object to test if a control has been deleted or not.
			/// </summary>
			class GuiDisposedFlag : public Object, public Description<GuiDisposedFlag>
			{
				friend class GuiControl;
			protected:
				GuiControl*								owner = nullptr;
				bool									disposed = false;

				void									SetDisposed();
			public:
				GuiDisposedFlag(GuiControl* _owner);
				~GuiDisposedFlag();

				bool									IsDisposed();
			};

			/// <summary>
			/// The base class of all controls.
			/// When the control is destroyed, it automatically destroys sub controls, and the bounds composition from the style controller.
			/// If you want to manually destroy a control, you should first remove it from its parent.
			/// The only way to remove a control from a parent control, is to remove the bounds composition from its parent composition. The same to inserting a control.
			/// </summary>
			class GuiControl
				: public Object
				, protected compositions::IGuiAltAction
				, protected compositions::IGuiTabAction
				, public Description<GuiControl>
			{
				friend class compositions::GuiGraphicsComposition;

			protected:
				using ControlList = collections::List<GuiControl*>;
				using ControlServiceMap = collections::Dictionary<WString, Ptr<IDescriptable>>;
				using ControlTemplatePropertyType = TemplateProperty<templates::GuiControlTemplate>;
				using IGuiGraphicsEventHandler = compositions::IGuiGraphicsEventHandler;

			private:
				theme::ThemeName						controlThemeName;
				ControlTemplatePropertyType				controlTemplate;
				templates::GuiControlTemplate*			controlTemplateObject = nullptr;
				Ptr<GuiDisposedFlag>					disposedFlag;

			public:
				Ptr<GuiDisposedFlag>					GetDisposedFlag();

			protected:
				compositions::GuiBoundsComposition*		boundsComposition = nullptr;
				compositions::GuiBoundsComposition*		containerComposition = nullptr;
				compositions::GuiGraphicsComposition*	focusableComposition = nullptr;
				compositions::GuiGraphicsEventReceiver*	eventReceiver = nullptr;

				bool									isFocused = false;
				Ptr<IGuiGraphicsEventHandler>			gotFocusHandler;
				Ptr<IGuiGraphicsEventHandler>			lostFocusHandler;

				bool									acceptTabInput = false;
				vint									tabPriority = -1;
				bool									isEnabled = true;
				bool									isVisuallyEnabled = true;
				bool									isVisible = true;
				WString									alt;
				WString									text;
				Nullable<FontProperties>				font;
				FontProperties							displayFont;
				description::Value						context;
				compositions::IGuiAltActionHost*		activatingAltHost = nullptr;
				ControlServiceMap						controlServices;

				GuiControl*								parent = nullptr;
				ControlList								children;
				description::Value						tag;
				GuiControl*								tooltipControl = nullptr;
				vint									tooltipWidth = 0;

				virtual void							BeforeControlTemplateUninstalled();
				virtual void							AfterControlTemplateInstalled(bool initialize);
				virtual void							CheckAndStoreControlTemplate(templates::GuiControlTemplate* value);
				virtual void							EnsureControlTemplateExists();
				virtual void							RebuildControlTemplate();
				virtual void							OnChildInserted(GuiControl* control);
				virtual void							OnChildRemoved(GuiControl* control);
				virtual void							OnParentChanged(GuiControl* oldParent, GuiControl* newParent);
				virtual void							OnParentLineChanged();
				virtual void							OnServiceAdded();
				virtual void							OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget);
				virtual void							OnBeforeReleaseGraphicsHost();
				virtual void							UpdateVisuallyEnabled();
				virtual void							UpdateDisplayFont();
				void									OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

				bool									IsControlVisibleAndEnabled();
				bool									IsAltEnabled()override;
				bool									IsAltAvailable()override;
				compositions::GuiGraphicsComposition*	GetAltComposition()override;
				compositions::IGuiAltActionHost*		GetActivatingAltHost()override;
				void									OnActiveAlt()override;
				bool									IsTabEnabled()override;
				bool									IsTabAvailable()override;

				static bool								SharedPtrDestructorProc(DescriptableObject* obj, bool forceDisposing);

			public:
				using ControlTemplateType = templates::GuiControlTemplate;

				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiControl(theme::ThemeName themeName);
				~GuiControl();

				/// <summary>Theme name changed event. This event raises when the theme name is changed.</summary>
				compositions::GuiNotifyEvent			ControlThemeNameChanged;
				/// <summary>Control template changed event. This event raises when the control template is changed.</summary>
				compositions::GuiNotifyEvent			ControlTemplateChanged;
				/// <summary>Control signal trigerred. This raises be raised because of multiple reason specified in the argument.</summary>
				compositions::GuiControlSignalEvent		ControlSignalTrigerred;
				/// <summary>Visible event. This event raises when the visibility state of the control is changed.</summary>
				compositions::GuiNotifyEvent			VisibleChanged;
				/// <summary>Enabled event. This event raises when the enabling state of the control is changed.</summary>
				compositions::GuiNotifyEvent			EnabledChanged;
				/// <summary>Focused event. This event raises when the focusing state of the control is changed.</summary>
				compositions::GuiNotifyEvent			FocusedChanged;
				/// <summary>
				/// Enabled event. This event raises when the visually enabling state of the control is changed. A visually enabling is combined by the enabling state and the parent's visually enabling state.
				/// A control is rendered as disabled, not only when the control itself is disabled, but also when the parent control is rendered as disabled.
				/// </summary>
				compositions::GuiNotifyEvent			VisuallyEnabledChanged;
				/// <summary>Alt changed event. This event raises when the associated Alt-combined shortcut key of the control is changed.</summary>
				compositions::GuiNotifyEvent			AltChanged;
				/// <summary>Text changed event. This event raises when the text of the control is changed.</summary>
				compositions::GuiNotifyEvent			TextChanged;
				/// <summary>Font changed event. This event raises when the font of the control is changed.</summary>
				compositions::GuiNotifyEvent			FontChanged;
				/// <summary>Display font changed event. This event raises when the display font of the control is changed.</summary>
				compositions::GuiNotifyEvent			DisplayFontChanged;
				/// <summary>Context changed event. This event raises when the font of the control is changed.</summary>
				compositions::GuiNotifyEvent			ContextChanged;

				void									TryDelayExecuteIfNotDeleted(Func<void()> proc);

				/// <summary>A function to create the argument for notify events that raised by itself.</summary>
				/// <returns>The created argument.</returns>
				compositions::GuiEventArgs				GetNotifyEventArguments();
				/// <summary>Get the associated theme name.</summary>
				/// <returns>The theme name.</returns>
				theme::ThemeName						GetControlThemeName();
				/// <summary>Set the associated control theme name.</summary>
				/// <param name="value">The theme name.</param>
				void									SetControlThemeName(theme::ThemeName value);
				/// <summary>Get the associated control template.</summary>
				/// <returns>The control template.</returns>
				ControlTemplatePropertyType				GetControlTemplate();
				/// <summary>Set the associated control template.</summary>
				/// <param name="value">The control template.</param>
				void									SetControlTemplate(const ControlTemplatePropertyType& value);
				/// <summary>Set the associated control theme name and template and the same time.</summary>
				/// <param name="themeNameValue">The theme name.</param>
				/// <param name="controlTemplateValue">The control template.</param>
				void									SetControlThemeNameAndTemplate(theme::ThemeName themeNameValue, const ControlTemplatePropertyType& controlTemplateValue);
				/// <summary>Get the associated style controller.</summary>
				/// <returns>The associated style controller.</returns>
				templates::GuiControlTemplate*			GetControlTemplateObject();
				/// <summary>Get the bounds composition for the control.</summary>
				/// <returns>The bounds composition.</returns>
				compositions::GuiBoundsComposition*		GetBoundsComposition();
				/// <summary>Get the container composition for the control.</summary>
				/// <returns>The container composition.</returns>
				compositions::GuiGraphicsComposition*	GetContainerComposition();
				/// <summary>Get the focusable composition for the control. A focusable composition is the composition to be focused when the control is focused.</summary>
				/// <returns>The focusable composition.</returns>
				compositions::GuiGraphicsComposition*	GetFocusableComposition();
				/// <summary>Get the parent control.</summary>
				/// <returns>The parent control.</returns>
				GuiControl*								GetParent();
				/// <summary>Get the number of child controls.</summary>
				/// <returns>The number of child controls.</returns>
				vint									GetChildrenCount();
				/// <summary>Get the child control using a specified index.</summary>
				/// <returns>The child control.</returns>
				/// <param name="index">The specified index.</param>
				GuiControl*								GetChild(vint index);
				/// <summary>Put another control in the container composition of this control.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="control">The control to put in this control.</param>
				bool									AddChild(GuiControl* control);
				/// <summary>Test if a control owned by this control.</summary>
				/// <returns>Returns true if the control is owned by this control.</returns>
				/// <param name="control">The control to test.</param>
				bool									HasChild(GuiControl* control);
				
				/// <summary>Get the <see cref="GuiControlHost"/> that contains this control.</summary>
				/// <returns>The <see cref="GuiControlHost"/> that contains this control.</returns>
				virtual GuiControlHost*					GetRelatedControlHost();
				/// <summary>Test if this control is rendered as enabled.</summary>
				/// <returns>Returns true if this control is rendered as enabled.</returns>
				virtual bool							GetVisuallyEnabled();
				/// <summary>Test if this control is focused.</summary>
				/// <returns>Returns true if this control is focused.</returns>
				virtual bool							GetFocused();
				/// <summary>Focus this control.</summary>
				virtual void							SetFocused();
				/// <summary>Test if this control accepts tab character input.</summary>
				/// <returns>Returns true if this control accepts tab character input.</returns>
				virtual bool							GetAcceptTabInput()override;
				/// <summary>Set if this control accepts tab character input.</summary>
				/// <param name="value">Set to true to make this control accept tab character input.</param>
				void									SetAcceptTabInput(bool value);
				/// <summary>Get the tab priority associated with this control.</summary>
				/// <returns>Returns he tab priority associated with this control.</returns>
				virtual vint							GetTabPriority()override;
				/// <summary>Associate a tab priority with this control.</summary>
				/// <param name="value">The tab priority to associate. TAB key will go through controls in the order of priority: 0, 1, 2, ..., -1. All negative numbers will be converted to -1. The priority of containers affects all children if it is not -1.</param>
				void									SetTabPriority(vint value);
				/// <summary>Test if this control is enabled.</summary>
				/// <returns>Returns true if this control is enabled.</returns>
				virtual bool							GetEnabled();
				/// <summary>Make the control enabled or disabled.</summary>
				/// <param name="value">Set to true to make the control enabled.</param>
				virtual void							SetEnabled(bool value);
				/// <summary>Test if this visible or invisible.</summary>
				/// <returns>Returns true if this control is visible.</returns>
				virtual bool							GetVisible();
				/// <summary>Make the control visible or invisible.</summary>
				/// <param name="value">Set to true to make the visible enabled.</param>
				virtual void							SetVisible(bool value);
				/// <summary>Get the Alt-combined shortcut key associated with this control.</summary>
				/// <returns>The Alt-combined shortcut key associated with this control.</returns>
				virtual const WString&					GetAlt()override;
				/// <summary>Associate a Alt-combined shortcut key with this control.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The Alt-combined shortcut key to associate. The key should contain only upper-case letters or digits.</param>
				virtual bool							SetAlt(const WString& value);
				/// <summary>Make the control as the parent of multiple Alt-combined shortcut key activatable controls.</summary>
				/// <param name="host">The alt action host object.</param>
				void									SetActivatingAltHost(compositions::IGuiAltActionHost* host);
				/// <summary>Get the text to display on the control.</summary>
				/// <returns>The text to display on the control.</returns>
				virtual const WString&					GetText();
				/// <summary>Set the text to display on the control.</summary>
				/// <param name="value">The text to display on the control.</param>
				virtual void							SetText(const WString& value);
				/// <summary>Get the font of this control.</summary>
				/// <returns>The font of this control.</returns>
				virtual const Nullable<FontProperties>&	GetFont();
				/// <summary>Set the font of this control.</summary>
				/// <param name="value">The font of this control.</param>
				virtual void							SetFont(const Nullable<FontProperties>& value);
				/// <summary>Get the font to render the text. If the font of this control is null, then the display font is either the parent control's display font, or the system's default font when there is no parent control.</summary>
				/// <returns>The font to render the text.</returns>
				virtual const FontProperties&			GetDisplayFont();
				/// <summary>Get the context of this control. The control template and all item templates (if it has) will see this context property.</summary>
				/// <returns>The context of this control.</returns>
				virtual description::Value				GetContext();
				/// <summary>Set the context of this control.</summary>
				/// <param name="value">The context of this control.</param>
				virtual void							SetContext(const description::Value& value);

				/// <summary>Get the tag object of the control.</summary>
				/// <returns>The tag object of the control.</returns>
				description::Value						GetTag();
				/// <summary>Set the tag object of the control.</summary>
				/// <param name="value">The tag object of the control.</param>
				void									SetTag(const description::Value& value);
				/// <summary>Get the tooltip control of the control.</summary>
				/// <returns>The tooltip control of the control.</returns>
				GuiControl*								GetTooltipControl();
				/// <summary>Set the tooltip control of the control. The tooltip control will be released when this control is released. If you set a new tooltip control to replace the old one, the old one will not be owned by this control anymore, therefore user should release the old tooltip control manually.</summary>
				/// <returns>The old tooltip control.</returns>
				/// <param name="value">The tooltip control of the control.</param>
				GuiControl*								SetTooltipControl(GuiControl* value);
				/// <summary>Get the tooltip width of the control.</summary>
				/// <returns>The tooltip width of the control.</returns>
				vint									GetTooltipWidth();
				/// <summary>Set the tooltip width of the control.</summary>
				/// <param name="value">The tooltip width of the control.</param>
				void									SetTooltipWidth(vint value);
				/// <summary>Display the tooltip.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="location">The relative location to specify the left-top position of the tooltip.</param>
				bool									DisplayTooltip(Point location);
				/// <summary>Close the tooltip that owned by this control.</summary>
				void									CloseTooltip();

				/// <summary>Query a service using an identifier. If you want to get a service of type IXXX, use IXXX::Identifier as the identifier.</summary>
				/// <returns>The requested service. If the control doesn't support this service, it will be null.</returns>
				/// <param name="identifier">The identifier.</param>
				virtual IDescriptable*					QueryService(const WString& identifier);

				template<typename T>
				T* QueryTypedService()
				{
					return dynamic_cast<T*>(QueryService(QueryServiceHelper<T>::GetIdentifier()));
				}

				templates::GuiControlTemplate* TypedControlTemplateObject(bool ensureExists)
				{
					if (ensureExists)
					{
						EnsureControlTemplateExists();
					}
					return controlTemplateObject;
				}

				/// <summary>Add a service to this control dynamically. The added service cannot override existing services.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="identifier">The identifier. You are suggested to fill this parameter using the value from the interface's GetIdentifier function, or <see cref="QueryTypedService`1"/> will not work on this service.</param>
				/// <param name="value">The service.</param>
				bool									AddService(const WString& identifier, Ptr<IDescriptable> value);
			};

			/// <summary>Represnets a user customizable control.</summary>
			class GuiCustomControl : public GuiControl, public GuiInstanceRootObject, public AggregatableDescription<GuiCustomControl>
			{
			protected:
				controls::GuiControlHost*				GetControlHostForInstance()override;
				void									OnParentLineChanged()override;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiCustomControl(theme::ThemeName themeName);
				~GuiCustomControl();

				using GuiControl::SetFocusableComposition;
			};

			template<typename T>
			class GuiObjectComponent : public GuiComponent
			{
			public:
				Ptr<T>				object;

				GuiObjectComponent()
				{
				}

				GuiObjectComponent(Ptr<T> _object)
					:object(_object)
				{
				}
			};

#define GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_3(UNIQUE) controlTemplateObject ## UNIQUE
#define GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_2(UNIQUE) GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_3(UNIQUE)
#define GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME_2(__LINE__)

#define GUI_SPECIFY_CONTROL_TEMPLATE_TYPE_2(TEMPLATE, BASE_TYPE, NAME) \
			public: \
				using ControlTemplateType = templates::Gui##TEMPLATE; \
			private: \
				templates::Gui##TEMPLATE* NAME = nullptr; \
				void BeforeControlTemplateUninstalled_(); \
				void AfterControlTemplateInstalled_(bool initialize); \
			protected: \
				void BeforeControlTemplateUninstalled()override \
				{\
					BeforeControlTemplateUninstalled_(); \
					BASE_TYPE::BeforeControlTemplateUninstalled(); \
				}\
				void AfterControlTemplateInstalled(bool initialize)override \
				{\
					BASE_TYPE::AfterControlTemplateInstalled(initialize); \
					AfterControlTemplateInstalled_(initialize); \
				}\
				void CheckAndStoreControlTemplate(templates::GuiControlTemplate* value)override \
				{ \
					auto ct = dynamic_cast<templates::Gui##TEMPLATE*>(value); \
					CHECK_ERROR(ct, L"The assigned control template is not vl::presentation::templates::Gui" L ## # TEMPLATE L"."); \
					NAME = ct; \
					BASE_TYPE::CheckAndStoreControlTemplate(value); \
				} \
			public: \
				templates::Gui##TEMPLATE* TypedControlTemplateObject(bool ensureExists) \
				{ \
					if (ensureExists) \
					{ \
						EnsureControlTemplateExists(); \
					} \
					return NAME; \
				} \
			private: \

#define GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TEMPLATE, BASE_TYPE) GUI_SPECIFY_CONTROL_TEMPLATE_TYPE_2(TEMPLATE, BASE_TYPE, GUI_GENERATE_CONTROL_TEMPLATE_OBJECT_NAME)

/***********************************************************************
Helper Functions
***********************************************************************/

			template<typename T>
			T* TryFindObjectByName(GuiInstanceRootObject* rootObject, const WString& name)
			{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::controls::TryFindObjectByName<T>(GuiInstanceRootObject*, const WString&)#"
				CHECK_ERROR(rootObject, ERROR_MESSAGE_PREFIX L"rootObject should not be null.");
				if (auto rawPtr = rootObject->GetNamedObject(name).GetRawPtr())
				{
					auto typedObject = rawPtr->SafeAggregationCast<T>();
					CHECK_ERROR(typedObject, ERROR_MESSAGE_PREFIX L"The object assigned by the name is not in the specified type.");
					return typedObject;
				}
				return nullptr;
#undef ERROR_MESSAGE_PREFIX
			}

			template<typename T>
			T* FindObjectByName(GuiInstanceRootObject* rootObject, const WString& name)
			{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::controls::FindObjectByName<T>(GuiInstanceRootObject*, const WString&)#"
				CHECK_ERROR(rootObject, ERROR_MESSAGE_PREFIX L"rootObject should not be null.");
				auto value = rootObject->GetNamedObject(name);
				CHECK_ERROR(!value.IsNull(), ERROR_MESSAGE_PREFIX L"The name has not been used.");
				CHECK_ERROR(value.GetRawPtr(), ERROR_MESSAGE_PREFIX L"The object assigned by the name is not a class.");
				auto rawPtr = value.GetRawPtr()->SafeAggregationCast<T>();
				CHECK_ERROR(rawPtr, ERROR_MESSAGE_PREFIX L"The object assigned by the name is not in the specified type.");
				return rawPtr;
#undef ERROR_MESSAGE_PREFIX
			}

			template<typename T>
				requires(std::is_base_of_v<controls::GuiControl, T>)
			T* TryFindControlByText(GuiControl* rootObject, const WString& text)
			{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::controls::TryFindControlByText<T>(GuiControl*, const WString&)#"
				CHECK_ERROR(rootObject, ERROR_MESSAGE_PREFIX L"rootObject should not be null.");
				if (rootObject->GetText() == text)
				{
					auto typedObject = dynamic_cast<T*>(rootObject);
					CHECK_ERROR(typedObject, ERROR_MESSAGE_PREFIX L"The object with the specified text is not in the specified type.");
					return typedObject;
				}

				vint count = rootObject->GetChildrenCount();
				for (vint i = 0; i < count; i++)
				{
					if (auto result = TryFindControlByText<T>(rootObject->GetChild(i), text))
					{
						return result;
					}
				}
				return nullptr;
#undef ERROR_MESSAGE_PREFIX
			}

			template<typename T>
				requires(std::is_base_of_v<controls::GuiControl, T>)
			T* FindControlByText(GuiControl* rootObject, const WString& text)
			{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::controls::FindControlByText<T>(GuiControl*, const WString&)#"
				if (auto result = TryFindControlByText<T>(rootObject, text))
				{
					return result;
				}
				CHECK_FAIL(ERROR_MESSAGE_PREFIX L"The control with the specified text does not exist.");
#undef ERROR_MESSAGE_PREFIX
			}
		}
	}
}

#endif


/***********************************************************************
.\APPLICATION\CONTROLS\GUILABELCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILABELCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILABELCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Label
***********************************************************************/

			/// <summary>A control to display a text.</summary>
			class GuiLabel : public GuiControl, public Description<GuiLabel>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(LabelTemplate, GuiControl)
			protected:
				Color									textColor;
				bool									textColorConsisted = true;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiLabel(theme::ThemeName themeName);
				~GuiLabel();

				/// <summary>Get the text color.</summary>
				/// <returns>The text color.</returns>
				Color									GetTextColor();
				/// <summary>Set the text color.</summary>
				/// <param name="value">The text color.</param>
				void									SetTextColor(Color value);
			};
		}
	}
}

#endif


/***********************************************************************
.\APPLICATION\CONTROLS\GUIWINDOWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class IGuiShortcutKeyManager;
			class GuiGraphicsTimerManager;
		}

		namespace controls
		{

/***********************************************************************
Control Host
***********************************************************************/

			/// <summary>
			/// Represents a control that host by a <see cref="INativeWindow"/>.
			/// </summary>
			class GuiControlHost : public GuiControl, public GuiInstanceRootObject, protected INativeWindowListener, public Description<GuiControlHost>
			{
				friend class compositions::GuiGraphicsHost;
			protected:
				Func<void()>									callbackAfterDeleteThis;
				compositions::GuiGraphicsHost*					host;
				INativeWindow::WindowMode						windowMode = INativeWindow::Normal;

				void											DeleteThis();
				virtual void									OnNativeWindowChanged();
				virtual void									OnVisualStatusChanged();
			protected:
				static const vint								TooltipDelayOpenTime = 500;
				static const vint								TooltipDelayCloseTime = 500;
				static const vint								TooltipDelayLifeTime = 5000;

				Ptr<INativeDelay>								tooltipOpenDelay;
				Ptr<INativeDelay>								tooltipCloseDelay;
				Point											tooltipLocation;

				bool											calledDestroyed = false;
				bool											deleteWhenDestroyed = false;

				controls::GuiControlHost*						GetControlHostForInstance()override;
				GuiControl*										GetTooltipOwner(Point location);
				void											MoveIntoTooltipControl(GuiControl* tooltipControl, Point location);
				void											MouseMoving(const NativeWindowMouseInfo& info)override;
				void											MouseLeaved()override;
				void											Moved()override;
				void											Enabled()override;
				void											Disabled()override;
				void											GotFocus()override;
				void											LostFocus()override;
				void											RenderingAsActivated()override;
				void											RenderingAsDeactivated()override;
				void											Opened()override;
				void											BeforeClosing(bool& cancel)override;
				void											AfterClosing()override;
				void											Closed()override;
				void											Destroying()override;

				void											UpdateClientSize(Size value, bool updateNativeWindowOnly);
				virtual void									UpdateClientSizeAfterRendering(Size preferredSize, Size clientSize);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="mode">The window mode.</param>
				GuiControlHost(theme::ThemeName themeName, INativeWindow::WindowMode mode);
				~GuiControlHost();
				
				/// <summary>Window got focus event.</summary>
				compositions::GuiNotifyEvent					WindowGotFocus;
				/// <summary>Window lost focus event.</summary>
				compositions::GuiNotifyEvent					WindowLostFocus;
				/// <summary>Window activated event.</summary>
				compositions::GuiNotifyEvent					WindowActivated;
				/// <summary>Window deactivated event.</summary>
				compositions::GuiNotifyEvent					WindowDeactivated;
				/// <summary>Window opened event.</summary>
				compositions::GuiNotifyEvent					WindowOpened;
				/// <summary>Window closing event, raised to offer a chance to stop closing the window.</summary>
				compositions::GuiRequestEvent					WindowClosing;
				/// <summary>Window ready to close event, raised when a window is about to close.</summary>
				compositions::GuiNotifyEvent					WindowReadyToClose;
				/// <summary>Window closed event, raised when a window is closed.</summary>
				compositions::GuiNotifyEvent					WindowClosed;
				/// <summary>Window destroying event.</summary>
				compositions::GuiNotifyEvent					WindowDestroying;

				/// <summary>Delete this control host after processing all events.</summary>
				/// <param name="callback">The callback to call after the window is deleted.</param>
				void											DeleteAfterProcessingAllEvents(const Func<void()>& callback);

				/// <summary>Get the internal <see cref="compositions::GuiGraphicsHost"/> object to host the window content.</summary>
				/// <returns>The internal <see cref="compositions::GuiGraphicsHost"/> object to host the window content.</returns>
				compositions::GuiGraphicsHost*					GetGraphicsHost();
				/// <summary>Get the main composition to host the window content.</summary>
				/// <returns>The main composition to host the window content.</returns>
				compositions::GuiGraphicsComposition*			GetMainComposition();
				/// <summary>Get the internal <see cref="INativeWindow"/> object to host the content.</summary>
				/// <returns>The the internal <see cref="INativeWindow"/> object to host the content.</returns>
				INativeWindow*									GetNativeWindow();
				/// <summary>Set the internal <see cref="INativeWindow"/> object to host the content.</summary>
				/// <param name="window">The the internal <see cref="INativeWindow"/> object to host the content.</param>
				void											SetNativeWindow(INativeWindow* window);
				/// <summary>Force to calculate layout and size immediately</summary>
				void											ForceCalculateSizeImmediately();
				
				/// <summary>Test is the window enabled.</summary>
				/// <returns>Returns true if the window is enabled.</returns>
				bool											GetEnabled()override;
				/// <summary>Enable or disable the window.</summary>
				/// <param name="value">Set to true to enable the window.</param>
				void											SetEnabled(bool value)override;
				/// <summary>Test is the window focused.</summary>
				/// <returns>Returns true if the window is focused.</returns>
				bool											GetFocused()override;
				/// <summary>Focus the window. A window with activation disabled cannot receive focus.</summary>
				void											SetFocused()override;
				/// <summary>Test is the window rendering as activated.</summary>
				/// <returns>Returns true if the window is rendering as activated.</returns>
				bool											GetRenderingAsActivated();
				/// <summary>Test is the window icon shown in the task bar.</summary>
				/// <returns>Returns true if the window is icon shown in the task bar.</returns>
				bool											GetShowInTaskBar();
				/// <summary>Show or hide the window icon in the task bar.</summary>
				/// <param name="value">Set to true to show the window icon in the task bar.</param>
				void											SetShowInTaskBar(bool value);
				/// <summary>Test is the window allowed to be activated.</summary>
				/// <returns>Returns true if the window is allowed to be activated.</returns>
				bool											GetEnabledActivate();
				/// <summary>
				/// Allow or forbid the window to be activated.
				/// Clicking a window with activation disabled doesn't bring activation and focus.
				/// Activation will be automatically enabled by calling <see cref="Show"/> or <see cref="SetActivated"/>.
				/// </summary>
				/// <param name="value">Set to true to allow the window to be activated.</param>
				void											SetEnabledActivate(bool value);
				/// <summary>
				/// Test is the window always on top of the desktop.
				/// </summary>
				/// <returns>Returns true if the window is always on top of the desktop.</returns>
				bool											GetTopMost();
				/// <summary>
				/// Make the window always or never on top of the desktop.
				/// </summary>
				/// <param name="topmost">True to make the window always  on top of the desktop.</param>
				void											SetTopMost(bool topmost);

				/// <summary>Get the <see cref="compositions::IGuiShortcutKeyManager"/> attached with this control host.</summary>
				/// <returns>The shortcut key manager.</returns>
				compositions::IGuiShortcutKeyManager*			GetShortcutKeyManager();
				/// <summary>Attach or detach the <see cref="compositions::IGuiShortcutKeyManager"/> associated with this control host. When this control host is disposing, the associated shortcut key manager will be deleted if exists.</summary>
				/// <param name="value">The shortcut key manager. Set to null to detach the previous shortcut key manager from this control host.</param>
				void											SetShortcutKeyManager(compositions::IGuiShortcutKeyManager* value);
				/// <summary>Get the timer manager.</summary>
				/// <returns>The timer manager.</returns>
				compositions::GuiGraphicsTimerManager*			GetTimerManager();

				/// <summary>Get the client size of the window.</summary>
				/// <returns>The client size of the window.</returns>
				Size											GetClientSize();
				/// <summary>Set the client size of the window.</summary>
				/// <param name="value">The client size of the window.</param>
				void											SetClientSize(Size value);
				/// <summary>Get the location of the window in screen space.</summary>
				/// <returns>The location of the window.</returns>
				NativePoint										GetLocation();
				/// <summary>Set the location of the window in screen space.</summary>
				/// <param name="value">The location of the window.</param>
				void											SetLocation(NativePoint value);
				/// <summary>Set the location in screen space and the client size of the window.</summary>
				/// <param name="location">The location of the window.</param>
				/// <param name="size">The client size of the window.</param>
				void											SetBounds(NativePoint location, Size size);

				GuiControlHost*									GetRelatedControlHost()override;
				const WString&									GetText()override;
				void											SetText(const WString& value)override;

				/// <summary>Get the screen that contains the window.</summary>
				/// <returns>The screen that contains the window.</returns>
				INativeScreen*									GetRelatedScreen();
				/// <summary>
				/// Show the window.
				/// If the window disabled activation, this function enables it again.
				/// </summary>
				void											Show();
				/// <summary>
				/// Show the window without activation.
				/// </summary>
				void											ShowDeactivated();
				/// <summary>
				/// Restore the window.
				/// </summary>
				void											ShowRestored();
				/// <summary>
				/// Maximize the window.
				/// </summary>
				void											ShowMaximized();
				/// <summary>
				/// Minimize the window.
				/// </summary>
				void											ShowMinimized();
				/// <summary>
				/// Hide the window.
				/// </summary>
				void											Hide();
				/// <summary>
				/// Close the window and destroy the internal <see cref="INativeWindow"/> object.
				/// </summary>
				void											Close();
				/// <summary>Test is the window opened.</summary>
				/// <returns>Returns true if the window is opened.</returns>
				bool											GetOpening();
			};

/***********************************************************************
Window
***********************************************************************/

			/// <summary>
			/// Represents a normal window.
			/// </summary>
			class GuiWindow : public GuiControlHost, protected compositions::GuiAltActionHostBase, public AggregatableDescription<GuiWindow>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(WindowTemplate, GuiControlHost)
				friend class GuiApplication;
			protected:
				bool									registeredInApplication = false;

			protected:
				compositions::IGuiAltActionHost*		previousAltHost = nullptr;
				const NativeWindowFrameConfig*			frameConfig = nullptr;
				bool									hasMaximizedBox = true;
				bool									hasMinimizedBox = true;
				bool									hasBorder = true;
				bool									hasSizeBox = true;
				bool									isIconVisible = true;
				bool									hasTitleBar = true;
				Ptr<GuiImageData>						icon;
				
				void									UpdateIcon(INativeWindow* window, templates::GuiWindowTemplate* ct);
				void									UpdateCustomFramePadding(INativeWindow* window, templates::GuiWindowTemplate* ct);
				bool									IsRenderedAsMaximized();
				void									SetControlTemplateProperties();
				void									SetNativeWindowFrameProperties();
				bool									ApplyFrameConfigOnVariable(BoolOption frameConfig, BoolOption templateConfig, bool& variable);
				void									ApplyFrameConfig();

				void									Moved()override;
				void									Opened()override;
				void									DpiChanged(bool preparing)override;
				void									AssignFrameConfig(const NativeWindowFrameConfig& config)override;
				void									OnNativeWindowChanged()override;
				void									OnVisualStatusChanged()override;
				
				void									OnWindowActivated(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowDeactivated(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				/// <summary>Create a control with a specified default theme and a window mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="mode">The window mode.</param>
				GuiWindow(theme::ThemeName themeName, INativeWindow::WindowMode mode);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiWindow(theme::ThemeName themeName);
				~GuiWindow();

				IDescriptable*							QueryService(const WString& identifier)override;

				/// <summary>Clipboard updated event.</summary>
				compositions::GuiNotifyEvent			ClipboardUpdated;
				/// <summary>Frame configuration changed event.</summary>
				compositions::GuiNotifyEvent			FrameConfigChanged;

				/// <summary>Move the window to the center of the screen. If multiple screens exist, the window move to the screen that contains the biggest part of the window.</summary>
				void									MoveToScreenCenter();
				/// <summary>Move the window to the center of the specified screen.</summary>
				/// <param name="screen">The screen.</param>
				void									MoveToScreenCenter(INativeScreen* screen);

				const NativeWindowFrameConfig&			GetFrameConfig();
				
				/// <summary>
				/// Test is the maximize box visible.
				/// </summary>
				/// <returns>Returns true if the maximize box is visible.</returns>
				bool									GetMaximizedBox();
				/// <summary>
				/// Make the maximize box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the maximize box visible.</param>
				void									SetMaximizedBox(bool visible);
				/// <summary>
				/// Test is the minimize box visible.
				/// </summary>
				/// <returns>Returns true if the minimize box is visible.</returns>
				bool									GetMinimizedBox();
				/// <summary>
				/// Make the minimize box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the minimize box visible.</param>
				void									SetMinimizedBox(bool visible);
				/// <summary>
				/// Test is the border visible.
				/// </summary>
				/// <returns>Returns true if the border is visible.</returns>
				bool									GetBorder();
				/// <summary>
				/// Make the border visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the border visible.</param>
				void									SetBorder(bool visible);
				/// <summary>
				/// Test is the size box visible.
				/// </summary>
				/// <returns>Returns true if the size box is visible.</returns>
				bool									GetSizeBox();
				/// <summary>
				/// Make the size box visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the size box visible.</param>
				void									SetSizeBox(bool visible);
				/// <summary>
				/// Test is the icon visible.
				/// </summary>
				/// <returns>Returns true if the icon is visible.</returns>
				bool									GetIconVisible();
				/// <summary>
				/// Make the icon visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the icon visible.</param>
				void									SetIconVisible(bool visible);
				/// <summary>
				/// Get the icon which replaces the default one.
				/// </summary>
				/// <returns>Returns the icon that replaces the default one.</returns>
				Ptr<GuiImageData>						GetIcon();
				/// <summary>
				/// Set the icon that replaces the default one.
				/// </summary>
				/// <param name="value">The icon that replaces the default one.</param>
				void									SetIcon(Ptr<GuiImageData> value);
				/// <summary>
				/// Test is the title bar visible.
				/// </summary>
				/// <returns>Returns true if the title bar is visible.</returns>
				bool									GetTitleBar();
				/// <summary>
				/// Make the title bar visible or invisible.
				/// </summary>
				/// <param name="visible">True to make the title bar visible.</param>
				void									SetTitleBar(bool visible);
				/// <summary>
				/// Show a window and keep it always in front of the owner window.
				/// </summary>
				/// <param name="owner">The window to disable as a parent window.</param>
				void									ShowWithOwner(GuiWindow* owner);
				/// <summary>
				/// Show a model window, get a callback when the window is closed.
				/// </summary>
				/// <param name="owner">The window to disable as a parent window.</param>
				/// <param name="callback">The callback to call after the window is closed.</param>
				void									ShowModal(GuiWindow* owner, const Func<void()>& callback);
				/// <summary>
				/// Show a model window, get a callback when the window is closed, and then delete itself.
				/// </summary>
				/// <param name="owner">The window to disable as a parent window.</param>
				/// <param name="callback">The callback to call after the window is closed.</param>
				void									ShowModalAndDelete(GuiWindow* owner, const Func<void()>& callback);
				/// <summary>
				/// Show a model window, get a callback when the window is closed, and then delete itself.
				/// </summary>
				/// <param name="owner">The window to disable as a parent window.</param>
				/// <param name="callbackClosed">The callback to call after the window is closed.</param>
				/// <param name="callbackDeleted">The callback to call after the window is closed.</param>
				void									ShowModalAndDelete(GuiWindow* owner, const Func<void()>& callbackClosed, const Func<void()>& callbackDeleted);
				/// <summary>
				/// Show a model window as an async operation, which ends when the window is closed.
				/// </summary>
				/// <returns>Returns true if the size box is visible.</returns>
				/// <param name="owner">The window to disable as a parent window.</param>
				Ptr<reflection::description::IAsync>	ShowModalAsync(GuiWindow* owner);
			};
			
			/// <summary>
			/// Represents a popup window. When the mouse click on other window or the desktop, the popup window will be closed automatically.
			/// </summary>
			class GuiPopup : public GuiWindow, public Description<GuiPopup>
			{
			protected:
				union PopupInfo
				{
					struct _s1 { NativePoint location; INativeScreen* screen; };
					struct _s2 { GuiControl* control; INativeWindow* controlWindow; Rect bounds; bool preferredTopBottomSide; };
					struct _s3 { GuiControl* control; INativeWindow* controlWindow; Point location; };
					struct _s4 { GuiControl* control; INativeWindow* controlWindow; bool preferredTopBottomSide; };

					_s1 _1;
					_s2 _2;
					_s3 _3;
					_s4 _4;

					PopupInfo() {}
				};
			protected:
				vint									popupType = -1;
				PopupInfo								popupInfo;

				void									UpdateClientSizeAfterRendering(Size preferredSize, Size clientSize)override;
				void									PopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									PopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);

				static bool								IsClippedByScreen(NativeSize size, NativePoint location, INativeScreen* screen);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, NativePoint location, INativeScreen* screen);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, GuiControl* control, INativeWindow* controlWindow, Rect bounds, bool preferredTopBottomSide);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, GuiControl* control, INativeWindow* controlWindow, Point location);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, GuiControl* control, INativeWindow* controlWindow, bool preferredTopBottomSide);
				static NativePoint						CalculatePopupPosition(NativeSize windowSize, vint popupType, const PopupInfo& popupInfo);

				void									ShowPopupInternal();

				/// <summary>Create a control with a specified default theme and a window mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="mode">The window mode.</param>
				GuiPopup(theme::ThemeName themeName, INativeWindow::WindowMode mode);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiPopup(theme::ThemeName themeName);
				~GuiPopup();

				/// <summary>Test will the whole popup window be in the screen if the popup's left-top position is set to a specified value.</summary>
				/// <returns>Returns true if the whole popup window will be in the screen.</returns>
				/// <param name="location">The specified left-top position.</param>
				bool									IsClippedByScreen(Point location);
				/// <summary>Show the popup window with the left-top position set to a specified value. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="location">The specified left-top position.</param>
				/// <param name="screen">The expected screen. If you don't want to specify any screen, don't set this parameter.</param>
				void									ShowPopup(NativePoint location, INativeScreen* screen = 0);
				/// <summary>Show the popup window with the bounds set to a specified control-relative value. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="control">The control that owns this popup temporary. And the location is relative to this control.</param>
				/// <param name="bounds">The specified bounds.</param>
				/// <param name="preferredTopBottomSide">Set to true if the popup window is expected to be opened at the top or bottom side of that bounds.</param>
				void									ShowPopup(GuiControl* control, Rect bounds, bool preferredTopBottomSide);
				/// <summary>Show the popup window with the left-top position set to a specified control-relative value. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="control">The control that owns this popup temporary. And the location is relative to this control.</param>
				/// <param name="location">The specified left-top position.</param>
				void									ShowPopup(GuiControl* control, Point location);
				/// <summary>Show the popup window aligned with a specified control. The position of the popup window will be adjusted to make it totally inside the screen if possible.</summary>
				/// <param name="control">The control that owns this popup temporary.</param>
				/// <param name="preferredTopBottomSide">Set to true if the popup window is expected to be opened at the top or bottom side of that control.</param>
				void									ShowPopup(GuiControl* control, bool preferredTopBottomSide);
			};

			/// <summary>Represents a tooltip window.</summary>
			class GuiTooltip : public GuiPopup, private INativeControllerListener, public Description<GuiTooltip>
			{
			protected:
				GuiControl*								temporaryContentControl = nullptr;

				void									GlobalTimer()override;
				void									TooltipOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									TooltipClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTooltip(theme::ThemeName themeName);
				~GuiTooltip();

				/// <summary>Get the preferred content width.</summary>
				/// <returns>The preferred content width.</returns>
				vint									GetPreferredContentWidth();
				/// <summary>Set the preferred content width.</summary>
				/// <param name="value">The preferred content width.</param>
				void									SetPreferredContentWidth(vint value);

				/// <summary>Get the temporary content control.</summary>
				/// <returns>The temporary content control.</returns>
				GuiControl*								GetTemporaryContentControl();
				/// <summary>Set the temporary content control.</summary>
				/// <param name="control">The temporary content control.</param>
				void									SetTemporaryContentControl(GuiControl* control);
			};
		}
	}
}

#endif


/***********************************************************************
.\APPLICATION\CONTROLS\GUIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION
#define VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Application
***********************************************************************/

			/// <summary>Represents an GacUI application, for window management and asynchronized operation supporting. Use [M:vl.presentation.controls.GetApplication] to access the instance of this class.</summary>
			class GuiApplication : public Object, private INativeControllerListener, public Description<GuiApplication>
			{
				friend void GuiApplicationInitialize();
				friend class GuiControlHost;
				friend class GuiWindow;
				friend class GuiPopup;
				friend class Ptr<GuiApplication>;
			private:

				void											InvokeClipboardNotify(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);
				void											ClipboardUpdated()override;
				void											GlobalShortcutKeyActivated(vint id)override;

			protected:
				using WindowMap = collections::Dictionary<INativeWindow*, GuiWindow*>;

				Locale											locale;
				GuiWindow*										mainWindow = nullptr;
				GuiWindow*										sharedTooltipOwnerWindow = nullptr;
				GuiControl*										sharedTooltipOwner = nullptr;
				GuiTooltip*										sharedTooltipControl = nullptr;
				bool											sharedTooltipHovering = false;
				bool											sharedTooltipClosing = false;
				collections::List<GuiWindow*>					windows;
				WindowMap										windowMap;
				collections::SortedList<GuiPopup*>				openingPopups;
				Ptr<compositions::GuiShortcutKeyManager>		globalShortcutKeyManager;

				GuiApplication();
				~GuiApplication();

				INativeWindow*									GetThreadContextNativeWindow(GuiControlHost* controlHost);
				void											RegisterWindow(GuiWindow* window);
				void											UnregisterWindow(GuiWindow* window);
				void											NotifyNativeWindowChanged(GuiControlHost* controlHost, INativeWindow* previousNativeWindow);
				void											RegisterPopupOpened(GuiPopup* popup);
				void											RegisterPopupClosed(GuiPopup* popup);
				void											TooltipMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											TooltipMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Locale changed event.</summary>
				Event<void()>									LocaleChanged;

				/// <summary>Returns the selected locale for all windows.</summary>
				/// <returns>The selected locale.</returns>
				Locale											GetLocale();
				/// <summary>Set the locale for all windows.</summary>
				/// <param name="value">The selected locale.</param>
				void											SetLocale(Locale value);

				/// <summary>Run a <see cref="GuiWindow"/> as the main window and show it. This function can only be called once in the entry point. When the main window is closed or hiden, the Run function will finished, and the application should prepare for finalization.</summary>
				/// <param name="_mainWindow">The main window.</param>
				void											Run(GuiWindow* _mainWindow);
				/// <summary>
				/// Process minimum necessary events and execute some async tasks.
				/// </summary>
				/// <returns>Return false when the main window has been closed and all finalizing are done.</returns>
				bool											RunOneCycle();
				/// <summary>Get the main window.</summary>
				/// <returns>The main window.</returns>
				GuiWindow*										GetMainWindow();
				/// <summary>Get all created <see cref="GuiWindow"/> instances. This contains normal windows, popup windows, menus, or other types of windows that inherits from <see cref="GuiWindow"/>.</summary>
				/// <returns>All created <see cref="GuiWindow"/> instances.</returns>
				const collections::List<GuiWindow*>&			GetWindows();
				/// <summary>Get the <see cref="GuiWindow"/> instance that the mouse cursor are directly in.</summary>
				/// <returns>The <see cref="GuiWindow"/> instance that the mouse cursor are directly in.</returns>
				/// <param name="location">The mouse cursor.</param>
				GuiWindow*										GetWindow(NativePoint location);
				/// <summary>Get the <see cref="GuiWindow"/> instance that associated with the specified native window.</summary>
				/// <returns>The <see cref="GuiWindow"/> instance that associated with the specified native window.</returns>
				/// <param name="nativeWindow">The native window.</param>
				GuiWindow*										GetWindowFromNative(INativeWindow* nativeWindow);
				/// <summary>Show a tooltip.</summary>
				/// <param name="owner">The control that owns this tooltip temporary.</param>
				/// <param name="tooltip">The control as the tooltip content. This control is not owned by the tooltip. User should manually release this control if no longer needed (usually when the application exit).</param>
				/// <param name="preferredContentWidth">The preferred content width for this tooltip.</param>
				/// <param name="location">The relative location to specify the left-top position of the tooltip.</param>
				void											ShowTooltip(GuiControl* owner, GuiControl* tooltip, vint preferredContentWidth, Point location);
				/// <summary>Close the tooltip</summary>
				void											CloseTooltip();
				/// <summary>Get the tooltip owner. When the tooltip closed, it returns null.</summary>
				/// <returns>The tooltip owner.</returns>
				GuiControl*										GetTooltipOwner();
				/// <summary>Get the <see cref="compositions::IGuiShortcutKeyManager"/> attached with this control host.</summary>
				/// <returns>The shortcut key manager.</returns>
				compositions::IGuiShortcutKeyManager*			GetGlobalShortcutKeyManager();
				/// <summary>Get the file path of the current executable.</summary>
				/// <returns>The file path of the current executable.</returns>
				WString											GetExecutablePath();
				/// <summary>Get the folder of the current executable.</summary>
				/// <returns>The folder of the current executable.</returns>
				WString											GetExecutableFolder();

				/// <summary>Test is the current thread the main thread for GUI.</summary>
				/// <returns>Returns true if the current thread is the main thread for GUI.</returns>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				bool											IsInMainThread(GuiControlHost* controlHost);
				/// <summary>Invoke a specified function asynchronously.</summary>
				/// <param name="proc">The specified function.</param>
				void											InvokeAsync(const Func<void()>& proc);
				/// <summary>Invoke a specified function in the main thread.</summary>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				/// <param name="proc">The specified function.</param>
				void											InvokeInMainThread(GuiControlHost* controlHost, const Func<void()>& proc);
				/// <summary>Invoke a specified function in the main thread and wait for the function to complete or timeout.</summary>
				/// <returns>Return true if the function complete. Return false if the function has not completed during a specified period of time.</returns>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				/// <param name="proc">The specified function.</param>
				/// <param name="milliseconds">The specified period of time to wait. Set to -1 (default value) to wait forever until the function completed.</param>
				bool											InvokeInMainThreadAndWait(GuiControlHost* controlHost, const Func<void()>& proc, vint milliseconds=-1);
				/// <summary>Delay execute a specified function with an specified argument asynchronisly.</summary>
				/// <returns>The Delay execution controller for this task.</returns>
				/// <param name="proc">The specified function.</param>
				/// <param name="milliseconds">Time to delay.</param>
				Ptr<INativeDelay>								DelayExecute(const Func<void()>& proc, vint milliseconds);
				/// <summary>Delay execute a specified function with an specified argument in the main thread.</summary>
				/// <returns>The Delay execution controller for this task.</returns>
				/// <param name="proc">The specified function.</param>
				/// <param name="milliseconds">Time to delay.</param>
				Ptr<INativeDelay>								DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds);
				/// <summary>Run the specified function in the main thread and wait until it finishes. If the caller is in the main thread, then run the specified function directly.</summary>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				/// <param name="proc">The specified function.</param>
				void											RunGuiTask(GuiControlHost* controlHost, const Func<void()>& proc);

				/// <summary>Run the specified function in the main thread and wait until it finishes. If the caller is in the main thread, then run the specified function directly.</summary>
				/// <typeparam name="T">The return value of the function</typeparam>
				/// <param name="controlHost">A control host to access the corressponding main thread.</param>
				/// <param name="proc">The specified function.</param>
				/// <returns>The result of the function.</returns>
				template<typename T>
				T RunGuiValue(GuiControlHost* controlHost, const Func<T()>& proc)
				{
					T result;
					RunGuiTask(controlHost, [&result, &proc]()
					{
						result=proc();
					});
					return result;
				}
			};

/***********************************************************************
Helper Functions
***********************************************************************/

			/// <summary>Get the global <see cref="GuiApplication"/> object.</summary>
			/// <returns>The global <see cref="GuiApplication"/> object.</returns>
			extern GuiApplication*								GetApplication();
		}
	}
}

extern void GuiApplicationMain();

#define GUI_VALUE(HOST, VALUE) vl::presentation::controls::GetApplication()->RunGuiValue((HOST), vl::Func([&](){return (VALUE);}))
#define GUI_RUN(HOST, VALUE) vl::presentation::controls::GetApplication()->RunGuiTask((HOST), [&](){(VALUE);})

#endif

/***********************************************************************
.\CONTROLS\GUIDIALOGS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDIALOGS
#define VCZH_PRESENTATION_CONTROLS_GUIDIALOGS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiWindow;

/***********************************************************************
Dialogs
***********************************************************************/

			/// <summary>Base class for dialogs.</summary>
			class GuiDialogBase abstract : public GuiComponent, public Description<GuiDialogBase>
			{
			protected:
				GuiInstanceRootObject*								rootObject = nullptr;

				GuiWindow*											GetHostWindow();
			public:
				GuiDialogBase();
				~GuiDialogBase();

				void												Attach(GuiInstanceRootObject* _rootObject);
				void												Detach(GuiInstanceRootObject* _rootObject);
			};
			
			/// <summary>Message dialog.</summary>
			class GuiMessageDialog : public GuiDialogBase, public Description<GuiMessageDialog>
			{
			protected:
				INativeDialogService::MessageBoxButtonsInput		input = INativeDialogService::DisplayOK;
				INativeDialogService::MessageBoxDefaultButton		defaultButton = INativeDialogService::DefaultFirst;
				INativeDialogService::MessageBoxIcons				icon = INativeDialogService::IconNone;
				INativeDialogService::MessageBoxModalOptions		modalOption = INativeDialogService::ModalWindow;
				WString												text;
				WString												title;

			public:
				/// <summary>Create a message dialog.</summary>
				GuiMessageDialog();
				~GuiMessageDialog();

				/// <summary>Get the button combination that appear on the dialog.</summary>
				/// <returns>The button combination.</returns>
				INativeDialogService::MessageBoxButtonsInput		GetInput();
				/// <summary>Set the button combination that appear on the dialog.</summary>
				/// <param name="value">The button combination.</param>
				void												SetInput(INativeDialogService::MessageBoxButtonsInput value);
				
				/// <summary>Get the default button for the selected button combination.</summary>
				/// <returns>The default button.</returns>
				INativeDialogService::MessageBoxDefaultButton		GetDefaultButton();
				/// <summary>Set the default button for the selected button combination.</summary>
				/// <param name="value">The default button.</param>
				void												SetDefaultButton(INativeDialogService::MessageBoxDefaultButton value);

				/// <summary>Get the icon that appears on the dialog.</summary>
				/// <returns>The icon.</returns>
				INativeDialogService::MessageBoxIcons				GetIcon();
				/// <summary>Set the icon that appears on the dialog.</summary>
				/// <param name="value">The icon.</param>
				void												SetIcon(INativeDialogService::MessageBoxIcons value);

				/// <summary>Get the way that how this dialog disable windows of the current process.</summary>
				/// <returns>The way that how this dialog disable windows of the current process.</returns>
				INativeDialogService::MessageBoxModalOptions		GetModalOption();
				/// <summary>Set the way that how this dialog disable windows of the current process.</summary>
				/// <param name="value">The way that how this dialog disable windows of the current process.</param>
				void												SetModalOption(INativeDialogService::MessageBoxModalOptions value);

				/// <summary>Get the text for the dialog.</summary>
				/// <returns>The text.</returns>
				const WString&										GetText();
				/// <summary>Set the text for the dialog.</summary>
				/// <param name="value">The text.</param>
				void												SetText(const WString& value);

				/// <summary>Get the title for the dialog.</summary>
				/// <returns>The title.</returns>
				const WString&										GetTitle();
				/// <summary>Set the title for the dialog. If the title is empty, the dialog will use the title of the window that host this dialog.</summary>
				/// <param name="value">The title.</param>
				void												SetTitle(const WString& value);
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns the clicked button.</returns>
				INativeDialogService::MessageBoxButtonsOutput		ShowDialog();
			};
			
			/// <summary>Color dialog.</summary>
			class GuiColorDialog : public GuiDialogBase, public Description<GuiColorDialog>
			{
			protected:
				bool												enabledCustomColor = true;
				bool												openedCustomColor = false;
				Color												selectedColor;
				bool												showSelection = true;
				collections::List<Color>							customColors;

			public:
				/// <summary>Create a color dialog.</summary>
				GuiColorDialog();
				~GuiColorDialog();

				/// <summary>Selected color changed event.</summary>
				compositions::GuiNotifyEvent						SelectedColorChanged;
				
				/// <summary>Get if the custom color panel is enabled for the dialog.</summary>
				/// <returns>Returns true if the color panel is enabled for the dialog.</returns>
				bool												GetEnabledCustomColor();
				/// <summary>Set if custom color panel is enabled for the dialog.</summary>
				/// <param name="value">Set to true to enable the custom color panel for the dialog.</param>
				void												SetEnabledCustomColor(bool value);
				
				/// <summary>Get if the custom color panel is opened by default when it is enabled.</summary>
				/// <returns>Returns true if the custom color panel is opened by default.</returns>
				bool												GetOpenedCustomColor();
				/// <summary>Set if the custom color panel is opened by default when it is enabled.</summary>
				/// <param name="value">Set to true to open custom color panel by default if it is enabled.</param>
				void												SetOpenedCustomColor(bool value);
				
				/// <summary>Get the selected color.</summary>
				/// <returns>The selected color.</returns>
				Color												GetSelectedColor();
				/// <summary>Set the selected color.</summary>
				/// <param name="value">The selected color.</param>
				void												SetSelectedColor(Color value);
				
				/// <summary>Get the list to access 16 selected custom colors on the palette. Colors in the list is guaranteed to have exactly 16 items after the dialog is closed.</summary>
				/// <returns>The list to access custom colors on the palette.</returns>
				collections::List<Color>&							GetCustomColors();
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "OK" button is clicked.</returns>
				bool												ShowDialog();
			};
			
			/// <summary>Font dialog.</summary>
			class GuiFontDialog : public GuiDialogBase, public Description<GuiFontDialog>
			{
			protected:
				FontProperties										selectedFont;
				Color												selectedColor;
				bool												showSelection = true;
				bool												showEffect = true;
				bool												forceFontExist = true;

			public:
				/// <summary>Create a font dialog.</summary>
				GuiFontDialog();
				~GuiFontDialog();

				/// <summary>Selected font changed event.</summary>
				compositions::GuiNotifyEvent						SelectedFontChanged;
				/// <summary>Selected color changed event.</summary>
				compositions::GuiNotifyEvent						SelectedColorChanged;
				
				/// <summary>Get the selected font.</summary>
				/// <returns>The selected font.</returns>
				const FontProperties&								GetSelectedFont();
				/// <summary>Set the selected font.</summary>
				/// <param name="value">The selected font.</param>
				void												SetSelectedFont(const FontProperties& value);
				
				/// <summary>Get the selected color.</summary>
				/// <returns>The selected color.</returns>
				Color												GetSelectedColor();
				/// <summary>Set the selected color.</summary>
				/// <param name="value">The selected color.</param>
				void												SetSelectedColor(Color value);
				
				/// <summary>Get if the selected font is already selected on the dialog when it is opened.</summary>
				/// <returns>Returns true if the selected font is already selected on the dialog when it is opened.</returns>
				bool												GetShowSelection();
				/// <summary>Set if the selected font is already selected on the dialog when it is opened.</summary>
				/// <param name="value">Set to true to select the selected font when the dialog is opened.</param>
				void												SetShowSelection(bool value);
				
				/// <summary>Get if the font preview is enabled.</summary>
				/// <returns>Returns true if the font preview is enabled.</returns>
				bool												GetShowEffect();
				/// <summary>Set if the font preview is enabled.</summary>
				/// <param name="value">Set to true to enable the font preview.</param>
				void												SetShowEffect(bool value);
				
				/// <summary>Get if the dialog only accepts an existing font.</summary>
				/// <returns>Returns true if the dialog only accepts an existing font.</returns>
				bool												GetForceFontExist();
				/// <summary>Set if the dialog only accepts an existing font.</summary>
				/// <param name="value">Set to true to let the dialog only accept an existing font.</param>
				void												SetForceFontExist(bool value);
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "OK" button is clicked.</returns>
				bool												ShowDialog();
			};
			
			/// <summary>Base class for file dialogs.</summary>
			class GuiFileDialogBase abstract : public GuiDialogBase, public Description<GuiFileDialogBase>
			{
			protected:
				WString												filter = L"All Files (*.*)|*.*";
				vint												filterIndex = 0;
				bool												enabledPreview = false;
				WString												title;
				WString												fileName;
				WString												directory;
				WString												defaultExtension;
				INativeDialogService::FileDialogOptions				options;

			public:
				GuiFileDialogBase();
				~GuiFileDialogBase();

				/// <summary>File name changed event.</summary>
				compositions::GuiNotifyEvent						FileNameChanged;
				/// <summary>Filter index changed event.</summary>
				compositions::GuiNotifyEvent						FilterIndexChanged;
				
				/// <summary>Get the filter.</summary>
				/// <returns>The filter.</returns>
				const WString&										GetFilter();
				/// <summary>Set the filter. The filter is formed by pairs of filter name and wildcard concatenated by "|", like "Text Files (*.txt)|*.txt|All Files (*.*)|*.*".</summary>
				/// <param name="value">The filter.</param>
				void												SetFilter(const WString& value);
				
				/// <summary>Get the filter index.</summary>
				/// <returns>The filter index.</returns>
				vint												GetFilterIndex();
				/// <summary>Set the filter index.</summary>
				/// <param name="value">The filter index.</param>
				void												SetFilterIndex(vint value);
				
				/// <summary>Get if the file preview is enabled.</summary>
				/// <returns>Returns true if the file preview is enabled.</returns>
				bool												GetEnabledPreview();
				/// <summary>Set if the file preview is enabled.</summary>
				/// <param name="value">Set to true to enable the file preview.</param>
				void												SetEnabledPreview(bool value);
				
				/// <summary>Get the title.</summary>
				/// <returns>The title.</returns>
				WString												GetTitle();
				/// <summary>Set the title.</summary>
				/// <param name="value">The title.</param>
				void												SetTitle(const WString& value);
				
				/// <summary>Get the selected file name.</summary>
				/// <returns>The selected file name.</returns>
				WString												GetFileName();
				/// <summary>Set the selected file name.</summary>
				/// <param name="value">The selected file name.</param>
				void												SetFileName(const WString& value);
				
				/// <summary>Get the default folder.</summary>
				/// <returns>The default folder.</returns>
				WString												GetDirectory();
				/// <summary>Set the default folder.</summary>
				/// <param name="value">The default folder.</param>
				void												SetDirectory(const WString& value);
				
				/// <summary>Get the default file extension.</summary>
				/// <returns>The default file extension.</returns>
				WString												GetDefaultExtension();
				/// <summary>Set the default file extension like "txt". If the user does not specify a file extension, the default file extension will be appended using "." after the file name.</summary>
				/// <param name="value">The default file extension.</param>
				void												SetDefaultExtension(const WString& value);
				
				/// <summary>Get the dialog options.</summary>
				/// <returns>The dialog options.</returns>
				INativeDialogService::FileDialogOptions				GetOptions();
				/// <summary>Set the dialog options.</summary>
				/// <param name="value">The dialog options.</param>
				void												SetOptions(INativeDialogService::FileDialogOptions value);
			};
			
			/// <summary>Open file dialog.</summary>
			class GuiOpenFileDialog : public GuiFileDialogBase, public Description<GuiOpenFileDialog>
			{
			protected:
				collections::List<WString>							fileNames;

			public:
				/// <summary>Create a open file dialog.</summary>
				GuiOpenFileDialog();
				~GuiOpenFileDialog();
				
				/// <summary>Get the list to access multiple selected file names.</summary>
				/// <returns>The list to access multiple selected file names.</returns>
				collections::List<WString>&							GetFileNames();
				
				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "Open" button is clicked.</returns>
				bool												ShowDialog();
			};
			
			/// <summary>Save file dialog.</summary>
			class GuiSaveFileDialog : public GuiFileDialogBase, public Description<GuiSaveFileDialog>
			{
			public:
				/// <summary>Create a save file dialog.</summary>
				GuiSaveFileDialog();
				~GuiSaveFileDialog();

				/// <summary>Show the dialog.</summary>
				/// <returns>Returns true if the "Save" button is clicked.</returns>
				bool												ShowDialog();
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TEMPLATES\GUIANIMATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUIANIMATION
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUIANIMATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class IGuiAnimationCoroutine : public Object, public Description<IGuiAnimationCoroutine>
			{
			public:
				class IImpl : public virtual IGuiAnimation, public Description<IImpl>
				{
				public:
					virtual void			OnPlayAndWait(Ptr<IGuiAnimation> animation) = 0;
					virtual void			OnPlayInGroup(Ptr<IGuiAnimation> animation, vint groupId) = 0;
					virtual void			OnWaitForGroup(vint groupId) = 0;
				};

				typedef Func<Ptr<description::ICoroutine>(IImpl*)>	Creator;

				static void					WaitAndPause(IImpl* impl, vuint64_t milliseconds);
				static void					PlayAndWaitAndPause(IImpl* impl, Ptr<IGuiAnimation> animation);
				static void					PlayInGroupAndPause(IImpl* impl, Ptr<IGuiAnimation> animation, vint groupId);
				static void					WaitForGroupAndPause(IImpl* impl, vint groupId);
				static void					ReturnAndExit(IImpl* impl);
				static Ptr<IGuiAnimation>	Create(const Creator& creator);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPCOMMAND.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class IGuiShortcutKeyItem;
			class IGuiShortcutKeyManager;
		}

		namespace controls
		{
			/// <summary>A command for toolstrip controls.</summary>
			class GuiToolstripCommand : public GuiComponent, public Description<GuiToolstripCommand>
			{
			public:
				class ShortcutBuilder : public Object
				{
				public:
					WString									text;
					bool									global = false;
					bool									ctrl = false;
					bool									shift = false;
					bool									alt = false;
					VKEY									key = VKEY::KEY_UNKNOWN;
				};
			protected:
				Ptr<GuiImageData>							image;
				Ptr<GuiImageData>							largeImage;
				WString										text;
				compositions::IGuiShortcutKeyItem*			shortcutKeyItem = nullptr;
				bool										enabled = true;
				bool										selected = false;
				Ptr<compositions::IGuiGraphicsEventHandler>	shortcutKeyItemExecutedHandler;
				Ptr<ShortcutBuilder>						shortcutBuilder;

				GuiInstanceRootObject*						attachedRootObject = nullptr;
				GuiControlHost*								attachedControlHost = nullptr;
				Ptr<compositions::IGuiGraphicsEventHandler>	renderTargetChangedHandler;

				void										OnShortcutKeyItemExecuted(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnRenderTargetChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										InvokeDescriptionChanged();

				compositions::IGuiShortcutKeyManager*		GetShortcutManagerFromBuilder(Ptr<ShortcutBuilder> builder);
				void										RemoveShortcut();
				void										ReplaceShortcut(compositions::IGuiShortcutKeyItem* value);
				void										BuildShortcut(const WString& builderText);
				void										UpdateShortcutOwner();
			public:
				/// <summary>Create the command.</summary>
				GuiToolstripCommand();
				~GuiToolstripCommand();

				void										Attach(GuiInstanceRootObject* rootObject)override;
				void										Detach(GuiInstanceRootObject* rootObject)override;

				/// <summary>Executed event.</summary>
				compositions::GuiNotifyEvent				Executed;

				/// <summary>Description changed event, raised when any description property is modified.</summary>
				compositions::GuiNotifyEvent				DescriptionChanged;

				/// <summary>Get the large image for this command.</summary>
				/// <returns>The large image for this command.</returns>
				Ptr<GuiImageData>							GetLargeImage();
				/// <summary>Set the large image for this command.</summary>
				/// <param name="value">The large image for this command.</param>
				void										SetLargeImage(Ptr<GuiImageData> value);
				/// <summary>Get the image for this command.</summary>
				/// <returns>The image for this command.</returns>
				Ptr<GuiImageData>							GetImage();
				/// <summary>Set the image for this command.</summary>
				/// <param name="value">The image for this command.</param>
				void										SetImage(Ptr<GuiImageData> value);
				/// <summary>Get the text for this command.</summary>
				/// <returns>The text for this command.</returns>
				const WString&								GetText();
				/// <summary>Set the text for this command.</summary>
				/// <param name="value">The text for this command.</param>
				void										SetText(const WString& value);
				/// <summary>Get the shortcut key item for this command.</summary>
				/// <returns>The shortcut key item for this command.</returns>
				compositions::IGuiShortcutKeyItem*			GetShortcut();
				/// <summary>Get the shortcut builder for this command.</summary>
				/// <returns>The shortcut builder for this command.</returns>
				WString										GetShortcutBuilder();
				/// <summary>Set the shortcut builder for this command. When the command is attached to a window as a component without a shortcut, the command will try to convert the shortcut builder to a shortcut key item.</summary>
				/// <param name="value">The shortcut builder for this command.</param>
				void										SetShortcutBuilder(const WString& value);
				/// <summary>Get the enablility for this command.</summary>
				/// <returns>The enablility for this command.</returns>
				bool										GetEnabled();
				/// <summary>Set the enablility for this command.</summary>
				/// <param name="value">The enablility for this command.</param>
				void										SetEnabled(bool value);
				/// <summary>Get the selection for this command.</summary>
				/// <returns>The selection for this command.</returns>
				bool										GetSelected();
				/// <summary>Set the selection for this command.</summary>
				/// <param name="value">The selection for this command.</param>
				void										SetSelected(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIDOCUMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIDOCUMENT
#define VCZH_PRESENTATION_RESOURCES_GUIDOCUMENT


namespace vl
{
	namespace presentation
	{
		class DocumentTextRun;
		class DocumentStylePropertiesRun;
		class DocumentStyleApplicationRun;
		class DocumentHyperlinkRun;
		class DocumentImageRun;
		class DocumentEmbeddedObjectRun;
		class DocumentParagraphRun;

/***********************************************************************
Rich Content Document (style)
***********************************************************************/

		struct DocumentFontSize
		{
			double							size = 0;
			bool							relative = false;

			DocumentFontSize()
			{
			}

			DocumentFontSize(double _size, bool _relative)
				:size(_size)
				, relative(_relative)
			{
			}

			static DocumentFontSize			Parse(const WString& value);
			WString							ToString()const;

			auto operator<=>(const DocumentFontSize&) const = default;
		};

		/// <summary>Represents a text style.</summary>
		class DocumentStyleProperties : public Object, public Description<DocumentStyleProperties>
		{
		public:
			/// <summary>Font face.</summary>
			Nullable<WString>				face;
			/// <summary>Font size.</summary>
			Nullable<DocumentFontSize>		size;
			/// <summary>Font color.</summary>
			Nullable<Color>					color;
			/// <summary>Font color.</summary>
			Nullable<Color>					backgroundColor;
			/// <summary>Bold.</summary>
			Nullable<bool>					bold;
			/// <summary>Italic.</summary>
			Nullable<bool>					italic;
			/// <summary>Underline.</summary>
			Nullable<bool>					underline;
			/// <summary>Strikeline.</summary>
			Nullable<bool>					strikeline;
			/// <summary>Antialias.</summary>
			Nullable<bool>					antialias;
			/// <summary>Vertical antialias.</summary>
			Nullable<bool>					verticalAntialias;
		};

/***********************************************************************
Rich Content Document (run)
***********************************************************************/

		/// <summary>Pepresents a logical run of a rich content document.</summary>
		class DocumentRun : public Object, public Description<DocumentRun>
		{
		public:
			/// <summary>A visitor interface for <see cref="DocumentRun"/>.</summary>
			class IVisitor : public Interface
			{
			public:
				/// <summary>Visit operation for <see cref="DocumentTextRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentTextRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentStylePropertiesRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentStylePropertiesRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentStyleApplicationRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentStyleApplicationRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentHyperlinkRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentHyperlinkRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentImageRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentImageRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentEmbeddedObjectRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentEmbeddedObjectRun* run)=0;
				/// <summary>Visit operation for <see cref="DocumentParagraphRun"/>.</summary>
				/// <param name="run">The run object.</param>
				virtual void				Visit(DocumentParagraphRun* run)=0;
			};

			DocumentRun(){}

			/// <summary>Accept a <see cref="IVisitor"/> and trigger the selected visit operation.</summary>
			/// <param name="visitor">The visitor.</param>
			virtual void					Accept(IVisitor* visitor)=0;
		};
		
		/// <summary>Pepresents a container run.</summary>
		class DocumentContainerRun : public DocumentRun, public Description<DocumentContainerRun>
		{
			typedef collections::List<Ptr<DocumentRun>>			RunList;
		public:
			/// <summary>Sub runs.</summary>
			RunList							runs;
		};
		
		/// <summary>Pepresents a content run.</summary>
		class DocumentContentRun : public DocumentRun, public Description<DocumentContentRun>
		{
		public:
			/// <summary>Get representation text.</summary>
			/// <returns>The representation text.</returns>
			virtual WString					GetRepresentationText()=0;
		};

		//-------------------------------------------------------------------------

		/// <summary>Pepresents a text run.</summary>
		class DocumentTextRun : public DocumentContentRun, public Description<DocumentTextRun>
		{
		public:
			/// <summary>Run text.</summary>
			WString							text;

			DocumentTextRun(){}

			WString							GetRepresentationText()override{return text;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents a inline object run.</summary>
		class DocumentInlineObjectRun : public DocumentContentRun, public Description<DocumentInlineObjectRun>
		{
		public:
			/// <summary>Size of the inline object.</summary>
			Size							size;
			/// <summary>Baseline of the inline object.</summary>
			vint							baseline;

			DocumentInlineObjectRun():baseline(-1){}
		};
				
		/// <summary>Pepresents a image run.</summary>
		class DocumentImageRun : public DocumentInlineObjectRun, public Description<DocumentImageRun>
		{
		public:
			static const wchar_t*			RepresentationText;

			/// <summary>The image.</summary>
			Ptr<INativeImage>				image;
			/// <summary>The frame index.</summary>
			vint							frameIndex;
			/// <summary>The image source string.</summary>
			WString							source;

			DocumentImageRun():frameIndex(0){}
			
			WString							GetRepresentationText()override{return RepresentationText;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents an embedded object run.</summary>
		class DocumentEmbeddedObjectRun : public DocumentInlineObjectRun, public Description<DocumentImageRun>
		{
		public:
			static const wchar_t*			RepresentationText;

			/// <summary>The object name.</summary>
			WString							name;
			
			WString							GetRepresentationText()override{return RepresentationText;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};

		//-------------------------------------------------------------------------
				
		/// <summary>Pepresents a style properties run.</summary>
		class DocumentStylePropertiesRun : public DocumentContainerRun, public Description<DocumentStylePropertiesRun>
		{
		public:
			/// <summary>Style properties.</summary>
			Ptr<DocumentStyleProperties>	style;

			DocumentStylePropertiesRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents a style application run.</summary>
		class DocumentStyleApplicationRun : public DocumentContainerRun, public Description<DocumentStyleApplicationRun>
		{
		public:
			/// <summary>Style name.</summary>
			WString							styleName;

			DocumentStyleApplicationRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
		
		/// <summary>Pepresents a hyperlink text run.</summary>
		class DocumentHyperlinkRun : public DocumentStyleApplicationRun, public Description<DocumentHyperlinkRun>
		{
		public:
			class Package : public Object, public Description<Package>
			{
			public:
				collections::List<Ptr<DocumentHyperlinkRun>>		hyperlinks;
				vint												row = -1;
				vint												start = -1;
				vint												end = -1;
			};

			/// <summary>Style name for normal state.</summary>
			WString							normalStyleName;
			/// <summary>Style name for active state.</summary>
			WString							activeStyleName;
			/// <summary>The reference of the hyperlink.</summary>
			WString							reference;

			DocumentHyperlinkRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		/// <summary>Pepresents a paragraph run.</summary>
		class DocumentParagraphRun : public DocumentContainerRun, public Description<DocumentParagraphRun>
		{
		public:
			/// <summary>Paragraph alignment.</summary>
			Nullable<Alignment>				alignment;

			DocumentParagraphRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}

			WString							GetText(bool skipNonTextContent);
			void							GetText(stream::TextWriter& writer, bool skipNonTextContent);
		};

/***********************************************************************
Rich Content Document (model)
***********************************************************************/

		/// <summary>Represents a text style.</summary>
		class DocumentStyle : public Object, public Description<DocumentStyle>
		{
		public:
			/// <summary>Parent style name, could be #Default, #Context, #NormalLink, #ActiveLink or style name of others</summary>
			WString							parentStyleName;

			/// <summary>Properties of this style.</summary>
			Ptr<DocumentStyleProperties>	styles;

			/// <summary>Resolved properties of this style using parent styles.</summary>
			Ptr<DocumentStyleProperties>	resolvedStyles;
		};

		/// <summary>Represents a rich content document model.</summary>
		class DocumentModel : public Object, public Description<DocumentModel>
		{
		public:
			static const wchar_t*			DefaultStyleName;
			static const wchar_t*			SelectionStyleName;
			static const wchar_t*			ContextStyleName;
			static const wchar_t*			NormalLinkStyleName;
			static const wchar_t*			ActiveLinkStyleName;
		public:
			/// <summary>Represents a resolved style.</summary>
			struct ResolvedStyle
			{
				/// <summary>The style of the text.</summary>
				FontProperties				style;
				/// <summary>The color of the text.</summary>
				Color						color;
				/// <summary>The background color of the text.</summary>
				Color						backgroundColor;

				ResolvedStyle()
				{
				}

				ResolvedStyle(const FontProperties& _style, Color _color, Color _backgroundColor)
					:style(_style)
					,color(_color)
					,backgroundColor(_backgroundColor)
				{
				}
			};

			struct RunRange
			{
				vint			start;
				vint			end;
			};

			typedef collections::Dictionary<DocumentRun*, RunRange>						RunRangeMap;
		private:
			typedef collections::List<Ptr<DocumentParagraphRun>>						ParagraphList;
			typedef collections::Dictionary<WString, Ptr<DocumentStyle>>				StyleMap;
		public:
			/// <summary>All paragraphs.</summary>
			ParagraphList							paragraphs;
			/// <summary>All available styles. These will not be persistant.</summary>
			StyleMap								styles;
			
			DocumentModel();

			static void								MergeStyle(Ptr<DocumentStyleProperties> style, Ptr<DocumentStyleProperties> parent);
			void									MergeBaselineStyle(Ptr<DocumentStyleProperties> style, const WString& styleName);
			void									MergeBaselineStyle(Ptr<DocumentModel> baselineDocument, const WString& styleName);
			void									MergeBaselineStyles(Ptr<DocumentModel> baselineDocument);
			void									MergeDefaultFont(const FontProperties& defaultFont);
			ResolvedStyle							GetStyle(Ptr<DocumentStyleProperties> sp, const ResolvedStyle& context);
			ResolvedStyle							GetStyle(const WString& styleName, const ResolvedStyle& context);

			WString									GetText(bool skipNonTextContent);
			void									GetText(stream::TextWriter& writer, bool skipNonTextContent);
			
			bool									CheckEditRange(TextPos begin, TextPos end, RunRangeMap& relatedRanges);
			Ptr<DocumentModel>						CopyDocument(TextPos begin, TextPos end, bool deepCopy);
			Ptr<DocumentModel>						CopyDocument();
			bool									CutParagraph(TextPos position);
			bool									CutEditRange(TextPos begin, TextPos end);
			bool									EditContainer(TextPos begin, TextPos end, const Func<void(DocumentParagraphRun*, RunRangeMap&, vint, vint)>& editor);
			
			vint									EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> replaceToModel, bool copy);
			vint									EditRunNoCopy(TextPos begin, TextPos end, const collections::Array<Ptr<DocumentParagraphRun>>& runs);
			vint									EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
			bool									EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
			Ptr<DocumentImageRun>					EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
			bool									EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=NormalLinkStyleName, const WString& activeStyleName=ActiveLinkStyleName);
			bool									RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
			Ptr<DocumentHyperlinkRun::Package>		GetHyperlink(vint paragraphIndex, vint begin, vint end);
			bool									EditStyleName(TextPos begin, TextPos end, const WString& styleName);
			bool									RemoveStyleName(TextPos begin, TextPos end);
			bool									RenameStyle(const WString& oldStyleName, const WString& newStyleName);
			bool									ClearStyle(TextPos begin, TextPos end);
			Ptr<DocumentStyleProperties>			SummarizeStyle(TextPos begin, TextPos end);
			Nullable<WString>						SummarizeStyleName(TextPos begin, TextPos end);
			Nullable<Alignment>						SummarizeParagraphAlignment(TextPos begin, TextPos end);

			/// <summary>Load a document model from an xml.</summary>
			/// <returns>The loaded document model.</returns>
			/// <param name="resource">The resource item containing the resource.</param>
			/// <param name="xml">The xml document.</param>
			/// <param name="resolver">A document resolver to resolve symbols in non-embedded objects like image.</param>
			/// <param name="errors">All collected errors during loading a resource.</param>
			static Ptr<DocumentModel>		LoadFromXml(Ptr<GuiResourceItem> resource, Ptr<glr::xml::XmlDocument> xml, Ptr<GuiResourcePathResolver> resolver, GuiResourceError::List& errors);

			/// <summary>Save a document model to an xml.</summary>
			/// <returns>The saved xml document.</returns>
			Ptr<glr::xml::XmlDocument>		SaveToXml();
		};
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Elements
***********************************************************************/

			/// <summary>
			/// Defines a shape for some <see cref="IGuiGraphicsElement"/>.
			/// </summary>
			enum class ElementShapeType
			{
				/// <summary>Rectangle shape.</summary>
				Rectangle,
				/// <summary>Ellipse shape.</summary>
				Ellipse,
				/// <summary>Round rectangle shape.</summary>
				RoundRect,
			};

			/// <summary>
			/// Defines a shape for some <see cref="IGuiGraphicsElement"/>.
			/// </summary>
			struct ElementShape
			{
				ElementShapeType		shapeType = ElementShapeType::Rectangle;
				vint					radiusX = 0;
				vint					radiusY = 0;

				GUI_DEFINE_COMPARE_OPERATORS(ElementShape)
			};

			/// <summary>
			/// Defines a focus rectangle with a thickness of one pixel.
			/// </summary>
			class GuiFocusRectangleElement : public GuiElementBase<GuiFocusRectangleElement>
			{
				friend class GuiElementBase<GuiFocusRectangleElement>;
				static constexpr const wchar_t* ElementTypeName = L"FocusRectangle";
			protected:

				GuiFocusRectangleElement();
			public:
			};

			/// <summary>
			/// Defines a border element with a thickness of one pixel.
			/// </summary>
			class GuiSolidBorderElement : public GuiElementBase<GuiSolidBorderElement>
			{
				friend class GuiElementBase<GuiSolidBorderElement>;
				static constexpr const wchar_t* ElementTypeName = L"SolidBorder";
			protected:
				Color					color;
				ElementShape			shape;

				GuiSolidBorderElement();
			public:
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape			GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape value);
			};
			
			/// <summary>
			/// Defines a 3D-like rectangle element with a thickness of two pixels.
			/// </summary>
			class Gui3DBorderElement : public GuiElementBase<Gui3DBorderElement>
			{
				friend class GuiElementBase<Gui3DBorderElement>;
				static constexpr const wchar_t* ElementTypeName = L"3DBorder";
			protected:
				Color					color1;
				Color					color2;

				Gui3DBorderElement();
			public:
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new left-top color.</param>
				void					SetColor1(Color value);
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new right-bottom color.</param>
				void					SetColor2(Color value);
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
			};
			
			/// <summary>
			/// Defines a 3D-like splitter element with a thickness of two pixels.
			/// </summary>
			class Gui3DSplitterElement : public GuiElementBase<Gui3DSplitterElement>
			{
				friend class GuiElementBase<Gui3DSplitterElement>;
				static constexpr const wchar_t* ElementTypeName = L"3DSplitter";
			public:
				/// <summary>
				/// Defines a direction of the <see cref="Gui3DSplitterElement"/>.
				/// </summary>
				enum Direction
				{
					/// <summary>Horizontal direction.</summary>
					Horizontal,
					/// <summary>Vertical direction.</summary>
					Vertical,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;

				Gui3DSplitterElement();
			public:
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new left-top color.</param>
				void					SetColor1(Color value);
				/// <summary>
				/// Get the right-bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new right-bottom color.</param>
				void					SetColor2(Color value);
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
			};

			/// <summary>
			/// Defines a color-filled element without border.
			/// </summary>
			class GuiSolidBackgroundElement : public GuiElementBase<GuiSolidBackgroundElement>
			{
				friend class GuiElementBase<GuiSolidBackgroundElement>;
				static constexpr const wchar_t* ElementTypeName = L"SolidBackground";
			protected:
				Color					color;
				ElementShape			shape;

				GuiSolidBackgroundElement();
			public:
				/// <summary>
				/// Get the background color.
				/// </summary>
				/// <returns>The background color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the background color.
				/// </summary>
				/// <param name="value">The new background color.</param>
				void					SetColor(Color value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape			GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape value);
			};
			
			/// <summary>
			/// Defines a color-filled gradient element without border.
			/// </summary>
			class GuiGradientBackgroundElement : public GuiElementBase<GuiGradientBackgroundElement>
			{
				friend class GuiElementBase<GuiGradientBackgroundElement>;
				static constexpr const wchar_t* ElementTypeName = L"GradientBackground";
			public:
				/// <summary>
				/// Defines a direction of the <see cref="GuiGradientBackgroundElement"/>.
				/// </summary>
				enum Direction
				{
					/// <summary>Horizontal direction.</summary>
					Horizontal,
					/// <summary>vertical direction.</summary>
					Vertical,
					/// <summary>Slash direction.</summary>
					Slash,
					/// <summary>Back slash direction.</summary>
					Backslash,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;
				ElementShape			shape;

				GuiGradientBackgroundElement();
			public:
				/// <summary>
				/// Get the left-top color.
				/// </summary>
				/// <returns>The left-top color.</returns>
				Color					GetColor1();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new left-top color.</param>
				void					SetColor1(Color value);
				/// <summary>
				/// Get the right bottom color.
				/// </summary>
				/// <returns>The right-bottom color.</returns>
				Color					GetColor2();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new right-bottom color.</param>
				void					SetColor2(Color value);
				/// <summary>
				/// Set colors of the element.
				/// </summary>
				/// <param name="value1">The new left-top color.</param>
				/// <param name="value2">The new right bottom color.</param>
				void					SetColors(Color value1, Color value2);
				
				/// <summary>
				/// Get the direction.
				/// </summary>
				/// <returns>The direction.</returns>
				Direction				GetDirection();
				/// <summary>
				/// Set the direction.
				/// </summary>
				/// <param name="value">The new direction.</param>
				void					SetDirection(Direction value);
				/// <summary>
				/// Get the shape.
				/// </summary>
				/// <returns>The shape.</returns>
				ElementShape			GetShape();
				/// <summary>
				/// Set the shape.
				/// </summary>
				/// <param name="value">The new shape.</param>
				void					SetShape(ElementShape value);
			};

			/// <summary>
			/// Defines a gradient border for shadow.
			/// </summary>
			class GuiInnerShadowElement : public GuiElementBase<GuiInnerShadowElement>
			{
				friend class GuiElementBase<GuiInnerShadowElement>;
				static constexpr const wchar_t* ElementTypeName = L"InnerShadow";
			protected:
				Color					color;
				vint					thickness = 0;

				GuiInnerShadowElement();
			public:
				/// <summary>
				/// Get the shadow color.
				/// </summary>
				/// <returns>The shadow color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the shadow color.
				/// </summary>
				/// <param name="value">The new shadow color.</param>
				void					SetColor(Color value);

				/// <summary>
				/// Get the thickness.
				/// </summary>
				/// <returns>The thickness.</returns>
				vint					GetThickness();
				/// <summary>
				/// Set the thickness.
				/// </summary>
				/// <param name="value">The new thickness.</param>
				void					SetThickness(vint value);
			};
			
			/// <summary>
			/// Defines an element of a plain text.
			/// </summary>
			class GuiSolidLabelElement : public GuiElementBase<GuiSolidLabelElement>
			{
				friend class GuiElementBase<GuiSolidLabelElement>;
				static constexpr const wchar_t* ElementTypeName = L"SolidLabel";
			protected:
				Color					color;
				FontProperties			fontProperties;
				WString					text;
				Alignment				hAlignment;
				Alignment				vAlignment;
				bool					wrapLine;
				bool					ellipse;
				bool					multiline;
				bool					wrapLineHeightCalculation;

				GuiSolidLabelElement();
			public:
				/// <summary>
				/// Get the text color.
				/// </summary>
				/// <returns>The text color.</returns>
				Color					GetColor();
				/// <summary>
				/// Set the text color.
				/// </summary>
				/// <param name="value">The new text color.</param>
				void					SetColor(Color value);
				
				/// <summary>
				/// Get the text font.
				/// </summary>
				/// <returns>The text font.</returns>
				const FontProperties&	GetFont();
				/// <summary>
				/// Set the text font.
				/// </summary>
				/// <param name="value">The new text font.</param>
				void					SetFont(const FontProperties& value);
				
				/// <summary>
				/// Get the text.
				/// </summary>
				/// <returns>The text.</returns>
				const WString&			GetText();
				/// <summary>
				/// Set the text.
				/// </summary>
				/// <param name="value">The new text.</param>
				void					SetText(const WString& value);
				
				/// <summary>
				/// Get the horizontal alignment of the text.
				/// </summary>
				/// <returns>The horizontal alignment of the text.</returns>
				Alignment				GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the text.
				/// </summary>
				/// <returns>The vertical alignment of the text.</returns>
				Alignment				GetVerticalAlignment();
				/// <summary>
				/// Set the horizontal alignment of the text.
				/// </summary>
				/// <param name="value">The new horizontal alignment of the text.</param>
				void					SetHorizontalAlignment(Alignment value);
				/// <summary>
				/// Set the vertical alignment of the text.
				/// </summary>
				/// <param name="value">The vertical alignment of the text.</param>
				void					SetVerticalAlignment(Alignment value);
				/// <summary>
				/// Set alignments in both directions of the text.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the text.</param>
				/// <param name="vertical">The vertical alignment of the text.</param>
				void					SetAlignments(Alignment horizontal, Alignment vertical);
				
				/// <summary>
				/// Get if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <returns>Return true if line auto-wrapping is enabled for this text.</returns>
				bool					GetWrapLine();
				/// <summary>
				/// Set if line auto-wrapping is enabled for this text.
				/// </summary>
				/// <param name="value">True if line auto-wrapping is enabled for this text.</param>
				void					SetWrapLine(bool value);
				
				/// <summary>
				/// Get if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <returns>Return true if ellipse is enabled for this text.</returns>
				bool					GetEllipse();
				/// <summary>
				/// Set if ellipse is enabled for this text. Ellipse will appear when the text is clipped.
				/// </summary>
				/// <param name="value">True if ellipse is enabled for this text.</param>
				void					SetEllipse(bool value);
				
				/// <summary>
				/// Get if multiple lines is enabled for this text.
				/// </summary>
				/// <returns>Return true if multiple lines is enabled for this text.</returns>
				bool					GetMultiline();
				/// <summary>
				/// Set if multiple lines is enabled for this text.
				/// </summary>
				/// <param name="value">True if multiple lines is enabled for this text.</param>
				void					SetMultiline(bool value);

				/// <summary>
				/// Get if the element calculates the min height when wrap line is enabled.
				/// </summary>
				/// <returns>Return true if the element calculates the min height when wrap line is enabled.</returns>
				bool					GetWrapLineHeightCalculation();
				/// <summary>
				/// Set if the element calculates the min height when wrap line is enabled.
				/// </summary>
				/// <param name="value">True if the element calculates the min height when wrap line is enabled.</param>
				void					SetWrapLineHeightCalculation(bool value);
			};

			/// <summary>
			/// Defines an element containing an image.
			/// </summary>
			class GuiImageFrameElement : public GuiElementBase<GuiImageFrameElement>
			{
				friend class GuiElementBase<GuiImageFrameElement>;
				static constexpr const wchar_t* ElementTypeName = L"ImageFrame";
			protected:
				Ptr<INativeImage>		image;
				vint					frameIndex;
				Alignment				hAlignment;
				Alignment				vAlignment;
				bool					stretch;
				bool					enabled;

				GuiImageFrameElement();
			public:
				/// <summary>
				/// Get the containing image.
				/// </summary>
				/// <returns>The contining picture.</returns>
				Ptr<INativeImage>		GetImage();
				/// <summary>
				/// Get the index of the frame in the containing image.
				/// </summary>
				/// <returns>The index of the frame in the containing image</returns>
				vint					GetFrameIndex();
				/// <summary>
				/// Set the containing image.
				/// </summary>
				/// <param name="value">The new containing image.</param>
				void					SetImage(Ptr<INativeImage> value);
				/// <summary>
				/// Set  the frame index.
				/// </summary>
				/// <param name="value">The new frameIndex.</param>
				void					SetFrameIndex(vint value);
				/// <summary>
				/// Set the containing image and the frame index.
				/// </summary>
				/// <param name="_image">The new containing image.</param>
				/// <param name="_frameIndex">The new frameIndex.</param>
				void					SetImage(Ptr<INativeImage> _image, vint _frameIndex);
				
				/// <summary>
				/// Get the horizontal alignment of the image.
				/// </summary>
				/// <returns>The horizontal alignment of the image.</returns>
				Alignment				GetHorizontalAlignment();
				/// <summary>
				/// Get the vertical alignment of the image.
				/// </summary>
				/// <returns>The vertical alignment of the image.</returns>
				Alignment				GetVerticalAlignment();
				/// <summary>
				/// Set the horizontal alignment of the text.
				/// </summary>
				/// <param name="value">The new horizontal alignment of the text.</param>
				void					SetHorizontalAlignment(Alignment value);
				/// <summary>
				/// Set the vertical alignment of the text.
				/// </summary>
				/// <param name="value">The vertical alignment of the text.</param>
				void					SetVerticalAlignment(Alignment value);
				/// <summary>
				/// Set alignments in both directions of the image.
				/// </summary>
				/// <param name="horizontal">The new horizontal alignment of the image.</param>
				/// <param name="vertical">The vertical alignment of the image.</param>
				void					SetAlignments(Alignment horizontal, Alignment vertical);

				/// <summary>
				/// Get if stretching is enabled for this image.
				/// </summary>
				/// <returns>Return true if stretching is enabled for this image.</returns>
				bool					GetStretch();
				/// <summary>
				/// Set if stretching is enabled for this image.
				/// </summary>
				/// <param name="value">True if stretching is enabled for this image.</param>
				void					SetStretch(bool value);

				/// <summary>
				/// Get if the image is rendered as enabled.
				/// </summary>
				/// <returns>Return true if the image is rendered as enabled.</returns>
				bool					GetEnabled();
				/// <summary>
				/// Set if the image is rendered as enabled.
				/// </summary>
				/// <param name="value">True if the image is rendered as enabled.</param>
				void					SetEnabled(bool value);
			};

			/// <summary>
			/// Defines a polygon element with a thickness of one pixel.
			/// </summary>
			class GuiPolygonElement : public GuiElementBase<GuiPolygonElement>
			{
				friend class GuiElementBase<GuiPolygonElement>;

				typedef collections::Array<Point>			PointArray;
				static constexpr const wchar_t*				ElementTypeName = L"Polygon";
			protected:
				Size							size;
				PointArray						points;
				Color							borderColor;
				Color							backgroundColor;

				GuiPolygonElement();
			public:
				/// <summary>
				/// Get a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <returns>The suggested size.</returns>
				Size					GetSize();
				/// <summary>
				/// Set a suggested size. The polygon element will be layouted to the center of the required bounds using this size.
				/// </summary>
				/// <param name="value">The new size.</param>
				void					SetSize(Size value);

				/// <summary>
				/// Get a point of the polygon element using an index.
				/// </summary>
				/// <param name="index">The index to access a point.</param>
				/// <returns>The point of the polygon element associated with the index.</returns>
				const Point&			GetPoint(vint index);
				/// <summary>
				/// Get the number of points
				/// </summary>
				/// <returns>The number of points.</returns>
				vint					GetPointCount();
				/// <summary>
				/// Set all points to the polygon element.
				/// </summary>
				/// <param name="p">A pointer to a buffer that stores all points.</param>
				/// <param name="count">The number of points.</param>
				void					SetPoints(const Point* p, vint count);


				/// <summary>
				/// Get all points.
				/// </summary>
				/// <returns>All points</returns>
				const PointArray&		GetPointsArray();
				/// <summary>
				/// Set all points.
				/// </summary>
				/// <param name="value">All points</param>
				void					SetPointsArray(const PointArray& value);
				
				/// <summary>
				/// Get the border color.
				/// </summary>
				/// <returns>The border color.</returns>
				Color					GetBorderColor();
				/// <summary>
				/// Set the border color.
				/// </summary>
				/// <param name="value">The new border color.</param>
				void					SetBorderColor(Color value);
				/// <summary>
				/// Get the background color.
				/// </summary>
				/// <returns>The background color.</returns>
				Color					GetBackgroundColor();
				/// <summary>
				/// Set the background color.
				/// </summary>
				/// <param name="value">The new background color.</param>
				void					SetBackgroundColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSDOCUMENTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

			namespace visitors
			{
				class SetPropertiesVisitor;
			}

/***********************************************************************
Rich Content Document (element)
***********************************************************************/

			/// <summary>Defines a rich text document element for rendering complex styled document.</summary>
			class GuiDocumentElement : public GuiElementBase<GuiDocumentElement>
			{
				friend class GuiElementBase<GuiDocumentElement>;
				static constexpr const wchar_t* ElementTypeName = L"RichDocument";
			public:
				/// <summary>Callback interface for this element.</summary>
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					/// <summary>Called when the rendering is started.</summary>
					virtual void							OnStartRender() = 0;

					/// <summary>Called when the rendering is finished.</summary>
					virtual void							OnFinishRender() = 0;

					/// <summary>Called when an embedded object is being rendered.</summary>
					/// <returns>Returns the new size of the rendered embedded object.</returns>
					/// <param name="name">The name of the embedded object</param>
					/// <param name="location">The location of the embedded object, relative to the left-top corner of this element.</param>
					virtual Size							OnRenderEmbeddedObject(const WString& name, const Rect& location) = 0;
				};

				class GuiDocumentElementRenderer : public GuiElementRendererBase<GuiDocumentElement, GuiDocumentElementRenderer, IGuiGraphicsRenderTarget>, private IGuiGraphicsParagraphCallback
				{
					friend class visitors::SetPropertiesVisitor;
					friend class GuiElementRendererBase<GuiDocumentElement, GuiDocumentElementRenderer, IGuiGraphicsRenderTarget>;
				protected:
					struct EmbeddedObject
					{
						WString								name;
						Size								size;
						vint								start;
						bool								resized = false;
					};

					typedef collections::Dictionary<vint, Ptr<EmbeddedObject>>		IdEmbeddedObjectMap;
					typedef collections::Dictionary<WString, vint>					NameIdMap;
					typedef collections::List<vint>									FreeIdList;

					struct ParagraphCache
					{
						WString								fullText;
						Ptr<IGuiGraphicsParagraph>			graphicsParagraph;
						IdEmbeddedObjectMap					embeddedObjects;
						vint								selectionBegin;
						vint								selectionEnd;

						ParagraphCache()
							:selectionBegin(-1)
							,selectionEnd(-1)
						{
						}
					};

					typedef collections::Array<Ptr<ParagraphCache>>		ParagraphCacheArray;
					typedef collections::Array<vint>					ParagraphHeightArray;

				private:

					Size									OnRenderInlineObject(vint callbackId, Rect location)override;
				protected:
					vint									paragraphDistance;
					vint									lastMaxWidth;
					vint									cachedTotalHeight;
					IGuiGraphicsLayoutProvider*				layoutProvider;
					ParagraphCacheArray						paragraphCaches;
					ParagraphHeightArray					paragraphHeights;

					TextPos									lastCaret;
					Color									lastCaretColor;
					bool									lastCaretFrontSide;

					NameIdMap								nameCallbackIdMap;
					FreeIdList								freeCallbackIds;
					vint									usedCallbackIds = 0;

					vint									renderingParagraph = -1;
					Point									renderingParagraphOffset;

					void									InitializeInternal();
					void									FinalizeInternal();
					void									RenderTargetChangedInternal(IGuiGraphicsRenderTarget* oldRenderTarget, IGuiGraphicsRenderTarget* newRenderTarget);
					Ptr<ParagraphCache>						EnsureAndGetCache(vint paragraphIndex, bool createParagraph);
					bool									GetParagraphIndexFromPoint(Point point, vint& top, vint& index);
				public:
					GuiDocumentElementRenderer();

					void									Render(Rect bounds)override;
					void									OnElementStateChanged()override;
					void									NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
					Ptr<DocumentHyperlinkRun::Package>		GetHyperlinkFromPoint(Point point);

					void									OpenCaret(TextPos caret, Color color, bool frontSide);
					void									CloseCaret(TextPos caret);
					void									SetSelection(TextPos begin, TextPos end);
					TextPos									CalculateCaret(TextPos comparingCaret, IGuiGraphicsParagraph::CaretRelativePosition position, bool& preferFrontSide);
					TextPos									CalculateCaretFromPoint(Point point);
					Rect									GetCaretBounds(TextPos caret, bool frontSide);
				};

			protected:
				Ptr<DocumentModel>							document;
				ICallback*									callback = nullptr;
				TextPos										caretBegin;
				TextPos										caretEnd;
				bool										caretVisible;
				bool										caretFrontSide;
				Color										caretColor;

				void										UpdateCaret();

				GuiDocumentElement();
			public:
				/// <summary>Get the callback.</summary>
				/// <returns>The callback.</returns>
				ICallback*									GetCallback();
				/// <summary>Set the callback.</summary>
				/// <param name="value">The callback.</param>
				void										SetCallback(ICallback* value);
				
				/// <summary>Get the document.</summary>
				/// <returns>The document.</returns>
				Ptr<DocumentModel>							GetDocument();
				/// <summary>Set the document. When a document is set to this element, modifying the document without invoking <see cref="NotifyParagraphUpdated"/> will lead to undefined behavior.</summary>
				/// <param name="value">The document.</param>
				void										SetDocument(Ptr<DocumentModel> value);
				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos										GetCaretBegin();
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos										GetCaretEnd();
				/// <summary>
				/// Get the prefer side for the caret.
				/// </summary>
				/// <returns>Returns true if the caret is rendered for the front side.</returns>
				bool										IsCaretEndPreferFrontSide();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="begin">The begin position of the selection area.</param>
				/// <param name="end">The end position of the selection area.</param>
				/// <param name="frontSide">Set to true to show the caret for the character before it. This argument is ignored if begin and end are the same.</param>
				void										SetCaret(TextPos begin, TextPos end, bool frontSide);
				/// <summary>
				/// Get the caret visibility.
				/// </summary>
				/// <returns>Returns true if the caret will be rendered.</returns>
				bool										GetCaretVisible();
				/// <summary>
				/// Set the caret visibility.
				/// </summary>
				/// <param name="value">True if the caret will be rendered.</param>
				void										SetCaretVisible(bool value);
				/// <summary>
				/// Get the color of the caret.
				/// </summary>
				/// <returns>The color of the caret.</returns>
				Color										GetCaretColor();
				/// <summary>
				/// Set the color of the caret.
				/// </summary>
				/// <param name="value">The color of the caret.</param>
				void										SetCaretColor(Color value);

				/// <summary>Calculate a caret using a specified comparing caret and a relative position.</summary>
				/// <returns>The calculated caret.</returns>
				/// <param name="comparingCaret">The comparing caret.</param>
				/// <param name="position">The relative position.</param>
				/// <param name="preferFrontSide">Specify the side for the comparingCaret. Retrive the suggested side for the new caret. If the return caret equals compareCaret, this output is ignored.</param>
				TextPos										CalculateCaret(TextPos comparingCaret, IGuiGraphicsParagraph::CaretRelativePosition position, bool& preferFrontSide);
				/// <summary>Calculate a caret using a specified point.</summary>
				/// <returns>The calculated caret.</returns>
				/// <param name="point">The specified point.</param>
				TextPos										CalculateCaretFromPoint(Point point);
				/// <summary>Get the bounds of a caret.</summary>
				/// <returns>The bounds.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="frontSide">Set to true to get the bounds for the character before it.</param>
				Rect										GetCaretBounds(TextPos caret, bool frontSide);

				/// <summary>Notify that some paragraphs are updated.</summary>
				/// <param name="index">The start paragraph index.</param>
				/// <param name="oldCount">The number of paragraphs to be updated.</param>
				/// <param name="newCount">The number of updated paragraphs.</param>
				/// <param name="updatedText">Set to true to notify that the text is updated.</param>
				void										NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
				/// <summary>Edit run in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="model">The new run.</param>
				/// <param name="copy">Set to true to copy the model before editing. Otherwise, objects inside the model will be used directly</param>
				void										EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> model, bool copy);
				/// <summary>Edit text in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="frontSide">Set to true to use the text style in front of the specified range.</param>
				/// <param name="text">The new text.</param>
				void										EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
				/// <summary>Edit style in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="style">The new style.</param>
				void										EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
				/// <summary>Edit image in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="image">The new image.</param>
				void										EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
				/// <summary>Set hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="reference">The reference of the hyperlink.</param>
				/// <param name="normalStyleName">The normal style name of the hyperlink.</param>
				/// <param name="activeStyleName">The active style name of the hyperlink.</param>
				void										EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=DocumentModel::NormalLinkStyleName, const WString& activeStyleName=DocumentModel::ActiveLinkStyleName);
				/// <summary>Remove hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
				/// <summary>Edit style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="styleName">The new style name.</param>
				void										EditStyleName(TextPos begin, TextPos end, const WString& styleName);
				/// <summary>Remove style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveStyleName(TextPos begin, TextPos end);
				/// <summary>Rename a style.</summary>
				/// <param name="oldStyleName">The name of the style.</param>
				/// <param name="newStyleName">The new name.</param>
				void										RenameStyle(const WString& oldStyleName, const WString& newStyleName);
				/// <summary>Clear all styles in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										ClearStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the text style in a specified range.</summary>
				/// <returns>The text style summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Ptr<DocumentStyleProperties>				SummarizeStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the style name in a specified range.</summary>
				/// <returns>The style name summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<WString>							SummarizeStyleName(TextPos begin, TextPos end);
				/// <summary>Set the alignment of paragraphs in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="alignments">The alignment for each paragraph.</param>
				void										SetParagraphAlignment(TextPos begin, TextPos end, const collections::Array<Nullable<Alignment>>& alignments);
				/// <summary>Summarize the text alignment in a specified range.</summary>
				/// <returns>The text alignment summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<Alignment>							SummarizeParagraphAlignment(TextPos begin, TextPos end);

				/// <summary>Get hyperlink from point.</summary>
				/// <returns>Corressponding hyperlink id. Returns -1 indicates that the point is not in a hyperlink.</returns>
				/// <param name="point">The point to get the hyperlink id.</param>
				Ptr<DocumentHyperlinkRun::Package>			GetHyperlinkFromPoint(Point point);
			};
		}
	}
}

#endif

/***********************************************************************
.\GRAPHICSELEMENT\GUIGRAPHICSTEXTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{
			class GuiColorizedTextElement;

/***********************************************************************
Colorized Plain Text (model)
***********************************************************************/

			namespace text
			{
				/// <summary>
				/// Represents the extra information of a character to display.
				/// </summary>
				struct CharAtt
				{
					/// <summary>
					/// The distance from the head of the line to the right side of this character in pixel.
					/// </summary>
					vuint32_t						rightOffset;
					/// <summary>
					/// The color index of the character. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
					/// </summary>
					vuint32_t						colorIndex;
				};
				
				/// <summary>
				/// Represents a line of characters.
				/// </summary>
				struct TextLine
				{
					static const vint				BlockSize=32;
					static const vint				MaxWidth=0xFFFF;
					
					/// <summary>
					/// A character buffer starts from the first character of this line.
					/// </summary>
					wchar_t*						text;
					/// <summary>
					/// A extra information buffer starts from the first character of this line.
					/// </summary>
					CharAtt*						att;
					/// <summary>
					/// The number of available <see cref="CharAtt::rightOffset"/> in the buffer.
					/// </summary>
					vint								availableOffsetCount;
					/// <summary>
					/// The number of elements in the allocated buffer memory.
					/// </summary>
					vint								bufferLength;
					/// <summary>
					/// The number of available characters in the buffer.
					/// </summary>
					vint								dataLength;
					/// <summary>
					/// The internal lexical analyzer state of a colorizer when it parses to the end of this line. -1 means that this state is not available.
					/// </summary>
					vint								lexerFinalState;
					/// <summary>
					/// The internal context sensitive state of a colorizer when it parses to the end of this line. -1 means that this state is not available.
					/// </summary>
					vint								contextFinalState;

					TextLine();
					~TextLine();

					static vint						CalculateBufferLength(vint dataLength);

					std::partial_ordering			operator<=>(const TextLine&) const { return std::partial_ordering::unordered; }
					bool							operator==(const TextLine& value) const { return false; }

					/// <summary>
					/// Initialize the <see cref="TextLine"/> instance to be an empty line.
					/// </summary>
					void							Initialize();
					/// <summary>
					/// Release all resources used in this line.
					/// </summary>
					void							Finalize();
					/// <summary>
					/// Test is the line initialized.
					/// </summary>
					/// <returns>Returns true if the line is initialized.</returns>
					bool							IsReady();
					/// <summary>
					/// Modify the characters in the line by replacing characters.
					/// </summary>
					/// <returns>Returns true if the modification succeeded.</returns>
					/// <param name="start">The position of the first character to be replaced.</param>
					/// <param name="count">The number of characters to be replaced.</param>
					/// <param name="input">The buffer to the characters to write into this line.</param>
					/// <param name="inputCount">The numbers of the characters to write into this line.</param>
					bool							Modify(vint start, vint count, const wchar_t* input, vint inputCount);
					/// <summary>
					/// Split a text line into two by the position. The current line contains characters before this position. This function returns a new text line contains characters after this position.
					/// </summary>
					/// <returns>The new text line.</returns>
					/// <param name="index">.</param>
					TextLine						Split(vint index);
					/// <summary>
					/// Append a text line after the this text line, and finalize the input text line.
					/// </summary>
					/// <param name="line">The text line that contains all characters and color indices to append and be finalized.</param>
					void							AppendAndFinalize(TextLine& line);
				};

#if defined VCZH_MSVC
				/// <summary>Test if a wchar_t is the first character of a surrogate pair.</summary>
				/// <param name="c">The character to test.</param>
				/// <returns>Returns true if it is the first character of a surrogate pair.</returns>
				inline bool UTF16SPFirst(wchar_t c)
				{
					return 0xD800 <= c && c < 0xDC00;
				}

				/// <summary>Test if a wchar_t is the second character of a surrogate pair.</summary>
				/// <param name="c">The character to test.</param>
				/// <returns>Returns true if it is the second character of a surrogate pair.</returns>
				inline bool UTF16SPSecond(wchar_t c)
				{
					return 0xDC00 <= c && c < 0xDFFF;
				}
#endif

				/// <summary>
				/// A unicode code point.
				/// In Windows, when the first character is not the leading character of a surrogate pair, the second character is ignored.
				/// In other platforms which treat wchar_t as a UTF-32 character, the second character is ignored.
				/// </summary>
				struct UnicodeCodePoint
				{
#if defined VCZH_MSVC
					wchar_t							characters[2];

					UnicodeCodePoint(wchar_t c) :characters{ c,0 } {}
					UnicodeCodePoint(wchar_t c1, wchar_t c2) :characters{ c1,c2 } {}
#elif defined VCZH_GCC
					wchar_t							character;

					UnicodeCodePoint(wchar_t c) :character(c) {}
#endif

					vuint32_t GetCodePoint()const
					{
#if defined VCZH_MSVC
						if (UTF16SPFirst(characters[0]) && UTF16SPSecond(characters[1]))
						{
							return (wchar_t)(characters[0] - 0xD800) * 0x400 + (wchar_t)(characters[1] - 0xDC00) + 0x10000;
						}
						else
						{
							return (vuint32_t)characters[0];
						}
#elif defined VCZH_GCC
						return (vuint32_t)character;
#endif
					}
				};

				/// <summary>
				/// An abstract class for character size measuring in differect rendering technology.
				/// </summary>
				class CharMeasurer : public virtual IDescriptable
				{
				protected:
					IGuiGraphicsRenderTarget*		oldRenderTarget = nullptr;
					vint							rowHeight;
					vint							widths[65536];
					
					/// <summary>
					/// Measure the width of a character.
					/// </summary>
					/// <returns>The width in pixel.</returns>
					/// <param name="codePoint">The unicode code point to measure.</param>
					/// <param name="renderTarget">The render target which the character is going to be rendered. This is a pure virtual member function to be overrided.</param>
					virtual vint					MeasureWidthInternal(UnicodeCodePoint codePoint, IGuiGraphicsRenderTarget* renderTarget)=0;
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height in pixel.</returns>
					/// <param name="renderTarget">The render target which the character is going to be rendered.</param>
					virtual vint					GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)=0;
				public:

					/// <summary>
					/// Initialize a character measurer.
					/// </summary>
					/// <param name="_rowHeight">The default character height in pixel before the character measurer is binded to a render target.</param>
					CharMeasurer(vint _rowHeight);
					~CharMeasurer();

					/// <summary>
					/// Bind a render target to this character measurer.
					/// </summary>
					/// <param name="value">The render target to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Measure the width of a character using the binded render target.
					/// </summary>
					/// <returns>The width of a character, in pixel.</returns>
					/// <param name="codePoint">The unicode code point to measure.</param>
					vint							MeasureWidth(UnicodeCodePoint codePoint);
					/// <summary>
					/// Measure the height of a character.
					/// </summary>
					/// <returns>The height of a character, in pixel.</returns>
					vint							GetRowHeight();
				};

				/// <summary>
				/// A class to maintain multiple lines of text buffer.
				/// </summary>
				class TextLines : public Object, public Description<TextLines>
				{
					typedef collections::List<TextLine>		TextLineList;
				protected:
					GuiColorizedTextElement*		ownerElement;
					TextLineList					lines;
					CharMeasurer*					charMeasurer;
					IGuiGraphicsRenderTarget*		renderTarget;
					vint							tabWidth;
					vint							tabSpaceCount;
					wchar_t							passwordChar;
				public:
					TextLines(GuiColorizedTextElement* _ownerElement);
					~TextLines();

					/// <summary>
					/// Returns the number of text lines.
					/// </summary>
					/// <returns>The number of text lines.</returns>
					vint							GetCount();
					/// <summary>
					/// Returns the text line of a specified row number.
					/// </summary>
					/// <returns>The related text line object.</returns>
					/// <param name="row">The specified row number.</param>
					TextLine&						GetLine(vint row);
					/// <summary>
					/// Returns the binded <see cref="CharMeasurer"/>.
					/// </summary>
					/// <returns>The binded <see cref="CharMeasurer"/>.</returns>
					CharMeasurer*					GetCharMeasurer();
					/// <summary>
					/// Binded a <see cref="CharMeasurer"/>.
					/// </summary>
					/// <param name="value">The <see cref="CharMeasurer"/> to bind.</param>
					void							SetCharMeasurer(CharMeasurer* value);
					/// <summary>
					/// Returns the binded <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <returns>The binded <see cref="IGuiGraphicsRenderTarget"/>.</returns>
					IGuiGraphicsRenderTarget*		GetRenderTarget();
					/// <summary>
					/// Binded a <see cref="IGuiGraphicsRenderTarget"/>.
					/// </summary>
					/// <param name="value">The <see cref="IGuiGraphicsRenderTarget"/> to bind.</param>
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					/// <summary>
					/// Returns a string from a specified range of the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					/// <param name="start">The start position.</param>
					/// <param name="end">The end position.</param>
					WString							GetText(TextPos start, TextPos end);
					/// <summary>
					/// Returns the whole string in the text lines.
					/// </summary>
					/// <returns>The string.</returns>
					WString							GetText();
					/// <summary>
					/// Set the string to the text lines. This operation will modified every <see cref="TextLine"/> objects.
					/// </summary>
					/// <param name="value">The string to set into the text lines.</param>
					void							SetText(const WString& value);
					
					/// <summary>
					/// Remove text lines in a specified range.
					/// </summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="start">The first row number.</param>
					/// <param name="count">The number of text lines to be removed.</param>
					bool							RemoveLines(vint start, vint count);
					/// <summary>
					/// Test is a text position available in the text lines.
					/// </summary>
					/// <returns>Returns true if this position is available.</returns>
					/// <param name="pos">The text position to test.</param>
					bool							IsAvailable(TextPos pos);
					/// <summary>
					/// Normalize a text position to be available.
					/// </summary>
					/// <returns>The normalized text position.</returns>
					/// <param name="pos">The text position to normalize.</param>
					TextPos							Normalize(TextPos pos);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="inputs">The buffer to the string buffers to replace into the text lines.</param>
					/// <param name="inputCounts">The numbers of characters for each string buffer.</param>
					/// <param name="rows">The number of string buffers.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t** inputs, vint* inputCounts, vint rows);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The buffer to the string to replace into the text lines.</param>
					/// <param name="inputCount">The number of characters to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input, vint inputCount);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input);
					/// <summary>
					/// Modify some text lines by replacing characters.
					/// </summary>
					/// <returns>The new end position.</returns>
					/// <param name="start">The start position of the range of characters to be replaced.</param>
					/// <param name="end">The end position of the range of characters to be replaced.</param>
					/// <param name="input">The string to replace into the text lines.</param>
					TextPos							Modify(TextPos start, TextPos end, const WString& input);
					/// <summary>
					/// Remove every text lines.
					/// </summary>
					void							Clear();
					
					/// <summary>
					/// Clear all cached <see cref="CharAtt::rightOffset"/>.
					/// </summary>
					void							ClearMeasurement();
					/// <summary>
					/// Returns the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <returns>The number of spaces to replace a tab character for rendering.</returns>
					vint							GetTabSpaceCount();
					/// <summary>
					/// Set the number of spaces to replace a tab character for rendering.
					/// </summary>
					/// <param name="value">The number of spaces to replace a tab character for rendering.</param>
					void							SetTabSpaceCount(vint value);
					/// <summary>
					/// Measure all characters in a specified row.
					/// </summary>
					/// <param name="row">The specified row number.</param>
					void							MeasureRow(vint row);
					/// <summary>
					/// Returns the width of a specified row.
					/// </summary>
					/// <returns>The width of a specified row, in pixel.</returns>
					/// <param name="row">The specified row number.</param>
					vint							GetRowWidth(vint row);
					/// <summary>
					/// Returns the height of a row.
					/// </summary>
					/// <returns>The height of a row, in pixel.</returns>
					vint							GetRowHeight();
					/// <summary>
					/// Returns the total width of the text lines.
					/// </summary>
					/// <returns>The width of the text lines, in pixel.</returns>
					vint							GetMaxWidth();
					/// <summary>
					/// Returns the total height of the text lines.
					/// </summary>
					/// <returns>The height of the text lines, in pixel.</returns>
					vint							GetMaxHeight();
					/// <summary>
					/// Get the text position near to specified point.
					/// </summary>
					/// <returns>The text position.</returns>
					/// <param name="point">The specified point, in pixel.</param>
					TextPos							GetTextPosFromPoint(Point point);
					/// <summary>
					/// Get the point of a specified text position.
					/// </summary>
					/// <returns>The point, in pixel. Returns (-1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Point							GetPointFromTextPos(TextPos pos);
					/// <summary>
					/// Get the bounds of a specified text position.
					/// </summary>
					/// <returns>The bounds, in pixel. Returns (-1, -1, -1, -1) if the text position is not available.</returns>
					/// <param name="pos">The specified text position.</param>
					Rect							GetRectFromTextPos(TextPos pos);
					/// <summary>
					/// Get the password mode displaying character.
					/// </summary>
					/// <returns>The password mode displaying character. Returns L'\0' means the password mode is not activated.</returns>
					wchar_t							GetPasswordChar();
					/// <summary>
					/// Set the password mode displaying character.
					/// </summary>
					/// <param name="value">The password mode displaying character. Set to L'\0' to deactivate the password mode.</param>
					void							SetPasswordChar(wchar_t value);
				};
				
				/// <summary>
				/// Represents colors of a character.
				/// </summary>
				struct ColorItem
				{
					/// <summary>
					/// Text color.
					/// </summary>
					Color							text;
					/// <summary>
					/// Background color.
					/// </summary>
					Color							background;

					GUI_DEFINE_COMPARE_OPERATORS(ColorItem)
				};
				
				/// <summary>
				/// Represents color entry in a color table. Use [M:vl.presentation.elements.GuiColorizedTextElement.GetColors] and [M:vl.presentation.elements.GuiColorizedTextElement.SetColors] to access the color table.
				/// </summary>
				struct ColorEntry
				{
					/// <summary>
					/// Colors in normal state.
					/// </summary>
					ColorItem						normal;
					/// <summary>
					/// Colors in focused and selected state.
					/// </summary>
					ColorItem						selectedFocused;
					/// <summary>
					/// Colors in not focused and selected state.
					/// </summary>
					ColorItem						selectedUnfocused;

					GUI_DEFINE_COMPARE_OPERATORS(ColorEntry)
				};
			}

/***********************************************************************
Colorized Plain Text (element)
***********************************************************************/
			
			/// <summary>
			/// Defines a text element with separate color configuration for each character.
			/// </summary>
			class GuiColorizedTextElement : public GuiElementBase<GuiColorizedTextElement>
			{
				friend class GuiElementBase<GuiColorizedTextElement>;
				friend class text::TextLines;

				typedef collections::Array<text::ColorEntry>			ColorArray;
				static constexpr const wchar_t*							ElementTypeName = L"ColorizedText";
			public:
				/// <summary>
				/// An callback interface. Member functions will be called when colors or fonts of a <see cref="GuiColorizedTextElement"/> changed.
				/// </summary>
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					/// <summary>
					/// Called when the color table of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					ColorChanged()=0;
					/// <summary>
					/// Called when the font configuration of a <see cref="GuiColorizedTextElement"/> changed.
					/// </summary>
					virtual void					FontChanged()=0;
				};
			protected:
				ICallback*							callback;
				ColorArray							colors;
				FontProperties						font;
				Point								viewPosition;
				bool								isVisuallyEnabled;
				bool								isFocused;

				TextPos								caretBegin;
				TextPos								caretEnd;
				bool								caretVisible;
				Color								caretColor;

				text::TextLines						lines;

				GuiColorizedTextElement();
			public:
				/// <summary>
				/// Get the internal <see cref="text::TextLines"/> object that stores all characters and colors.
				/// </summary>
				/// <returns>The internal <see cref="text::TextLines"/> object.</returns>
				text::TextLines&					GetLines();
				/// <summary>
				/// Get the binded callback object.
				/// </summary>
				/// <returns>The binded callback object.</returns>
				ICallback*							GetCallback();
				/// <summary>
				/// Bind a callback object.
				/// </summary>
				/// <param name="value">The callback object to bind.</param>
				void								SetCallback(ICallback* value);
				
				/// <summary>
				/// Get the binded color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table.
				/// </summary>
				/// <returns>The binded color table.</returns>
				const ColorArray&					GetColors();
				/// <summary>
				/// Bind a color table. Use <see cref="text::CharAtt::colorIndex"/> to use colors in this color table. <see cref="ICallback::ColorChanged"/> will be called.
				/// </summary>
				/// <param name="value">The color table to bind.</param>
				void								SetColors(const ColorArray& value);
				/// <summary>
				/// Reset color of all characters
				/// </summary>
				/// <param name="index">Color index of all characters.</param>
				void								ResetTextColorIndex(vint index);
				/// <summary>
				/// Get the font configuration for all characters.
				/// </summary>
				/// <returns>The font configuration.</returns>
				const FontProperties&				GetFont();
				/// <summary>
				/// Set the font configuration for all characters. <see cref="ICallback::FontChanged"/> will be called.
				/// </summary>
				/// <param name="value">The font configuration.</param>
				void								SetFont(const FontProperties& value);
				/// <summary>
				/// Get the password mode displaying character.
				/// </summary>
				/// <returns>The password mode displaying character. Returns L'\0' means the password mode is not activated.</returns>
				wchar_t								GetPasswordChar();
				/// <summary>
				/// Set the password mode displaying character.
				/// </summary>
				/// <param name="value">The password mode displaying character. Set to L'\0' to deactivate the password mode.</param>
				void								SetPasswordChar(wchar_t value);
				/// <summary>
				/// Get the left-top position of the visible bounds of characters.
				/// </summary>
				/// <returns>The left-top position of the visible bounds of characters.</returns>
				Point								GetViewPosition();
				/// <summary>
				/// Set the left-top position of the visible bounds of characters.
				/// </summary>
				/// <param name="value">The left-top position of the visible bounds of characters.</param>
				void								SetViewPosition(Point value);
				/// <summary>
				/// Get the enabling state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as an enabled element.</returns>
				bool								GetVisuallyEnabled();
				/// <summary>
				/// Set the enabling state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as an enabled element.</param>
				void								SetVisuallyEnabled(bool value);
				/// <summary>
				/// Get the focused state.
				/// </summary>
				/// <returns>Returns true if the element will be rendered as a focused element.</returns>
				bool								GetFocused();
				/// <summary>
				/// Set the focused state.
				/// </summary>
				/// <param name="value">True if the element will be rendered as a focused element.</param>
				void								SetFocused(bool value);
				
				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos								GetCaretBegin();
				/// <summary>
				/// Set the begin position of the selection area.
				/// </summary>
				/// <param name="value">The begin position of the selection area.</param>
				void								SetCaretBegin(TextPos value);
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos								GetCaretEnd();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="value">The end position of the selection area.</param>
				void								SetCaretEnd(TextPos value);
				/// <summary>
				/// Get the caret visibility.
				/// </summary>
				/// <returns>Returns true if the caret will be rendered.</returns>
				bool								GetCaretVisible();
				/// <summary>
				/// Set the caret visibility.
				/// </summary>
				/// <param name="value">True if the caret will be rendered.</param>
				void								SetCaretVisible(bool value);
				/// <summary>
				/// Get the color of the caret.
				/// </summary>
				/// <returns>The color of the caret.</returns>
				Color								GetCaretColor();
				/// <summary>
				/// Set the color of the caret.
				/// </summary>
				/// <param name="value">The color of the caret.</param>
				void								SetCaretColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUICONTROLTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATES
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATES


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiButton;
			class GuiSelectableButton;
			class GuiListControl;
			class GuiComboBoxListControl;
			class GuiTextList;
			class GuiTabPage;
			class GuiScroll;
		}

		namespace controls
		{
			class GuiControlHost;
			class GuiCustomControl;

			/// <summary>The visual state for button.</summary>
			enum class ButtonState
			{
				/// <summary>Normal state.</summary>
				Normal,
				/// <summary>Active state (when the cursor is hovering on a button).</summary>
				Active,
				/// <summary>Pressed state (when the buttin is being pressed).</summary>
				Pressed,
			};

			/// <summary>Represents the sorting state of list view items related to this column.</summary>
			enum class ColumnSortingState
			{
				/// <summary>Not sorted.</summary>
				NotSorted,
				/// <summary>Ascending.</summary>
				Ascending,
				/// <summary>Descending.</summary>
				Descending,
			};

			/// <summary>Represents the order of tab pages.</summary>
			enum class TabPageOrder
			{
				/// <summary>Unknown.</summary>
				Unknown,
				/// <summary>Left to right.</summary>
				LeftToRight,
				/// <summary>Right to left.</summary>
				RightToLeft,
				/// <summary>Top to bottom.</summary>
				TopToBottom,
				/// <summary>Bottom to top.</summary>
				BottomToTop,
			};

			/// <summary>A command executor for the combo box to change the control state.</summary>
			class ITextBoxCommandExecutor : public virtual IDescriptable, public Description<ITextBoxCommandExecutor>
			{
			public:
				/// <summary>Override the text content in the control.</summary>
				/// <param name="value">The new text content.</param>
				virtual void						UnsafeSetText(const WString& value) = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IScrollCommandExecutor : public virtual IDescriptable, public Description<IScrollCommandExecutor>
			{
			public:
				/// <summary>Do small decrement.</summary>
				virtual void						SmallDecrease() = 0;
				/// <summary>Do small increment.</summary>
				virtual void						SmallIncrease() = 0;
				/// <summary>Do big decrement.</summary>
				virtual void						BigDecrease() = 0;
				/// <summary>Do big increment.</summary>
				virtual void						BigIncrease() = 0;

				/// <summary>Change to total size of the scroll.</summary>
				/// <param name="value">The total size.</param>
				virtual void						SetTotalSize(vint value) = 0;
				/// <summary>Change to page size of the scroll.</summary>
				/// <param name="value">The page size.</param>
				virtual void						SetPageSize(vint value) = 0;
				/// <summary>Change to position of the scroll.</summary>
				/// <param name="value">The position.</param>
				virtual void						SetPosition(vint value) = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class ITabCommandExecutor : public virtual IDescriptable, public Description<ITabCommandExecutor>
			{
			public:
				/// <summary>Select a tab page.</summary>
				/// <param name="index">The specified position for the tab page.</param>
				/// <param name="setFocus">Set to true to set focus to the tab control.</param>
				virtual void						ShowTab(vint index, bool setFocus) = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IDatePickerCommandExecutor : public virtual IDescriptable, public Description<IDatePickerCommandExecutor>
			{
			public:
				/// <summary>Called when the date has been changed.</summary>
				virtual void						NotifyDateChanged() = 0;
				/// <summary>Called when navigated to a date.</summary>
				virtual void						NotifyDateNavigated() = 0;
				/// <summary>Called when selected a date.</summary>
				virtual void						NotifyDateSelected() = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IRibbonGroupCommandExecutor : public virtual IDescriptable, public Description<IRibbonGroupCommandExecutor>
			{
			public:
				/// <summary>Called when the expand button is clicked.</summary>
				virtual void						NotifyExpandButtonClicked() = 0;
			};

			/// <summary>A command executor for the style controller to change the control state.</summary>
			class IRibbonGalleryCommandExecutor : public virtual IDescriptable, public Description<IRibbonGalleryCommandExecutor>
			{
			public:
				/// <summary>Called when the scroll up button is clicked.</summary>
				virtual void						NotifyScrollUp() = 0;
				/// <summary>Called when the scroll down button is clicked.</summary>
				virtual void						NotifyScrollDown() = 0;
				/// <summary>Called when the dropdown button is clicked.</summary>
				virtual void						NotifyDropdown() = 0;
			};
		}

/***********************************************************************
Templates
***********************************************************************/

		namespace templates
		{

#define GUI_CONTROL_TEMPLATE_DECL(F)\
			F(GuiSinglelineTextBoxTemplate,		GuiControlTemplate)			\
			F(GuiDocumentLabelTemplate,			GuiControlTemplate)			\
			F(GuiMenuTemplate,					GuiWindowTemplate)			\
			F(GuiButtonTemplate,				GuiControlTemplate)			\
			F(GuiSelectableButtonTemplate,		GuiButtonTemplate)			\
			F(GuiToolstripButtonTemplate,		GuiSelectableButtonTemplate)\
			F(GuiListViewColumnHeaderTemplate,	GuiToolstripButtonTemplate)	\
			F(GuiComboBoxTemplate,				GuiToolstripButtonTemplate)	\
			F(GuiScrollTemplate,				GuiControlTemplate)			\
			F(GuiScrollViewTemplate,			GuiControlTemplate)			\
			F(GuiMultilineTextBoxTemplate,		GuiScrollViewTemplate)		\
			F(GuiDocumentViewerTemplate,		GuiScrollViewTemplate)		\
			F(GuiListControlTemplate,			GuiScrollViewTemplate)		\
			F(GuiTextListTemplate,				GuiListControlTemplate)		\
			F(GuiListViewTemplate,				GuiListControlTemplate)		\
			F(GuiTreeViewTemplate,				GuiListControlTemplate)		\
			F(GuiTabTemplate,					GuiControlTemplate)			\
			F(GuiDatePickerTemplate,			GuiControlTemplate)			\
			F(GuiDateComboBoxTemplate,			GuiComboBoxTemplate)		\
			F(GuiRibbonTabTemplate,				GuiTabTemplate)				\
			F(GuiRibbonGroupTemplate,			GuiControlTemplate)			\
			F(GuiRibbonGroupMenuTemplate,		GuiMenuTemplate)			\
			F(GuiRibbonIconLabelTemplate,		GuiControlTemplate)			\
			F(GuiRibbonButtonsTemplate,			GuiControlTemplate)			\
			F(GuiRibbonToolstripsTemplate,		GuiControlTemplate)			\
			F(GuiRibbonToolstripMenuTemplate,	GuiMenuTemplate)			\
			F(GuiRibbonGalleryTemplate,			GuiControlTemplate)			\
			F(GuiRibbonGalleryListTemplate,		GuiRibbonGalleryTemplate)	\

#define GUI_ITEM_TEMPLATE_DECL(F)\
			F(GuiListItemTemplate,				GuiTemplate)				\
			F(GuiTextListItemTemplate,			GuiListItemTemplate)		\
			F(GuiTreeItemTemplate,				GuiListItemTemplate)		\
			F(GuiGridCellTemplate,				GuiControlTemplate)			\
			F(GuiGridVisualizerTemplate,		GuiGridCellTemplate)		\
			F(GuiGridEditorTemplate,			GuiGridCellTemplate)		\

/***********************************************************************
Control Template
***********************************************************************/

#define GuiSinglelineTextBoxTemplate_PROPERTIES(F)\
				F(GuiSinglelineTextBoxTemplate, elements::text::ColorEntry, TextColor, {})\
				F(GuiSinglelineTextBoxTemplate, Color, CaretColor, {})\

#define GuiDocumentLabelTemplate_PROPERTIES(F)\
				F(GuiDocumentLabelTemplate, Ptr<DocumentModel>, BaselineDocument, {})\
				F(GuiDocumentLabelTemplate, Color, CaretColor, {})\

#define GuiMenuTemplate_PROPERTIES(F)

#define GuiButtonTemplate_PROPERTIES(F)\
				F(GuiButtonTemplate, controls::ButtonState, State, controls::ButtonState::Normal)\

#define GuiSelectableButtonTemplate_PROPERTIES(F)\
				F(GuiSelectableButtonTemplate, bool, Selected, false)\

#define GuiToolstripButtonTemplate_PROPERTIES(F)\
				F(GuiToolstripButtonTemplate, TemplateProperty<GuiMenuTemplate>, SubMenuTemplate, {})\
				F(GuiToolstripButtonTemplate, bool, SubMenuExisting, false)\
				F(GuiToolstripButtonTemplate, bool, SubMenuOpening, false)\
				F(GuiToolstripButtonTemplate, controls::GuiButton*, SubMenuHost, nullptr)\
				F(GuiToolstripButtonTemplate, Ptr<GuiImageData>, LargeImage, {})\
				F(GuiToolstripButtonTemplate, Ptr<GuiImageData>, Image, {})\
				F(GuiToolstripButtonTemplate, WString, ShortcutText, {})\

#define GuiListViewColumnHeaderTemplate_PROPERTIES(F)\
				F(GuiListViewColumnHeaderTemplate, controls::ColumnSortingState, SortingState, controls::ColumnSortingState::NotSorted)\

#define GuiComboBoxTemplate_PROPERTIES(F)\
				F(GuiComboBoxTemplate, bool, TextVisible, true)\

#define GuiScrollTemplate_PROPERTIES(F)\
				F(GuiScrollTemplate, controls::IScrollCommandExecutor*, Commands, nullptr)\
				F(GuiScrollTemplate, vint, TotalSize, 100)\
				F(GuiScrollTemplate, vint, PageSize, 10)\
				F(GuiScrollTemplate, vint, Position, 0)\

#define GuiScrollViewTemplate_PROPERTIES(F)\
				F(GuiScrollViewTemplate, controls::GuiScroll*, HorizontalScroll, nullptr)\
				F(GuiScrollViewTemplate, controls::GuiScroll*, VerticalScroll, nullptr)\

#define GuiMultilineTextBoxTemplate_PROPERTIES(F)\
				F(GuiMultilineTextBoxTemplate, controls::ITextBoxCommandExecutor*, Commands, nullptr)\
				F(GuiMultilineTextBoxTemplate, elements::text::ColorEntry, TextColor, {})\
				F(GuiMultilineTextBoxTemplate, Color, CaretColor, {})\

#define GuiDocumentViewerTemplate_PROPERTIES(F)\
				F(GuiDocumentViewerTemplate, Ptr<DocumentModel>, BaselineDocument, {})\
				F(GuiDocumentViewerTemplate, Color, CaretColor, {})\

#define GuiListControlTemplate_PROPERTIES(F)\
				F(GuiListControlTemplate, TemplateProperty<GuiSelectableButtonTemplate>, BackgroundTemplate, {})\

#define GuiTextListTemplate_PROPERTIES(F)\
				F(GuiTextListTemplate, Color, TextColor, {})\
				F(GuiTextListTemplate, TemplateProperty<GuiSelectableButtonTemplate>, CheckBulletTemplate, {})\
				F(GuiTextListTemplate, TemplateProperty<GuiSelectableButtonTemplate>, RadioBulletTemplate, {})\

#define GuiListViewTemplate_PROPERTIES(F)\
				F(GuiListViewTemplate, TemplateProperty<GuiListViewColumnHeaderTemplate>, ColumnHeaderTemplate, {})\
				F(GuiListViewTemplate, Color, PrimaryTextColor, {})\
				F(GuiListViewTemplate, Color, SecondaryTextColor, {})\
				F(GuiListViewTemplate, Color, ItemSeparatorColor, {})\

#define GuiTreeViewTemplate_PROPERTIES(F)\
				F(GuiTreeViewTemplate, TemplateProperty<GuiSelectableButtonTemplate>, ExpandingDecoratorTemplate, {})\
				F(GuiTreeViewTemplate, Color, TextColor, {})\

#define GuiTabTemplate_PROPERTIES(F)\
				F(GuiTabTemplate, controls::ITabCommandExecutor*, Commands, nullptr)\
				F(GuiTabTemplate, Ptr<reflection::description::IValueObservableList>, TabPages, {})\
				F(GuiTabTemplate, controls::GuiTabPage*, SelectedTabPage, nullptr)\
				F(GuiTabTemplate, controls::TabPageOrder, TabOrder, controls::TabPageOrder::Unknown)\

#define GuiDatePickerTemplate_PROPERTIES(F)\
				F(GuiDatePickerTemplate, controls::IDatePickerCommandExecutor*, Commands, nullptr)\
				F(GuiDatePickerTemplate, Locale, DateLocale, {})\
				F(GuiDatePickerTemplate, DateTime, Date, {})\

#define GuiDateComboBoxTemplate_PROPERTIES(F)\
				F(GuiDateComboBoxTemplate, TemplateProperty<GuiDatePickerTemplate>, DatePickerTemplate, {})\

#define GuiRibbonTabTemplate_PROPERTIES(F)\
				F(GuiRibbonTabTemplate, compositions::GuiGraphicsComposition*, BeforeHeadersContainer, nullptr)\
				F(GuiRibbonTabTemplate, compositions::GuiGraphicsComposition*, AfterHeadersContainer, nullptr)\

#define GuiRibbonGroupTemplate_PROPERTIES(F)\
				F(GuiRibbonGroupTemplate, controls::IRibbonGroupCommandExecutor*, Commands, nullptr)\
				F(GuiRibbonGroupTemplate, bool, Expandable, false)\
				F(GuiRibbonGroupTemplate, bool, Collapsed, false)\
				F(GuiRibbonGroupTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeDropdownButtonTemplate, {})\
				F(GuiRibbonGroupTemplate, TemplateProperty<GuiRibbonGroupMenuTemplate>, SubMenuTemplate, {})\

#define GuiRibbonGroupMenuTemplate_PROPERTIES(F)\
				F(GuiRibbonGroupMenuTemplate, controls::IRibbonGroupCommandExecutor*, Commands, nullptr)\
				F(GuiRibbonGroupMenuTemplate, bool, Expandable, false)\

#define GuiRibbonIconLabelTemplate_PROPERTIES(F)\
				F(GuiRibbonIconLabelTemplate, Ptr<GuiImageData>, Image, {})\

#define GuiRibbonButtonsTemplate_PROPERTIES(F)\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeDropdownButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, LargeSplitButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallDropdownButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallSplitButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, SmallIconLabelTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconDropdownButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconSplitButtonTemplate, {})\
				F(GuiRibbonButtonsTemplate, TemplateProperty<GuiToolstripButtonTemplate>, IconLabelTemplate, {})\

#define GuiRibbonToolstripsTemplate_PROPERTIES(F)\
				F(GuiRibbonToolstripsTemplate, TemplateProperty<GuiControlTemplate>, ToolbarTemplate, {})\

#define GuiRibbonToolstripMenuTemplate_PROPERTIES(F)\
				F(GuiRibbonToolstripMenuTemplate, compositions::GuiGraphicsComposition*, ContentComposition, nullptr)\

#define GuiRibbonGalleryTemplate_PROPERTIES(F)\
				F(GuiRibbonGalleryTemplate, controls::IRibbonGalleryCommandExecutor*, Commands, nullptr)\
				F(GuiRibbonGalleryTemplate, bool, ScrollUpEnabled, true)\
				F(GuiRibbonGalleryTemplate, bool, ScrollDownEnabled, true)\

#define GuiRibbonGalleryListTemplate_PROPERTIES(F)\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiTextListTemplate>, ItemListTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiRibbonToolstripMenuTemplate>, MenuTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiControlTemplate>, HeaderTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiSelectableButtonTemplate>, BackgroundTemplate, {})\
				F(GuiRibbonGalleryListTemplate, TemplateProperty<GuiScrollViewTemplate>, GroupContainerTemplate, {})\

/***********************************************************************
Item Template
***********************************************************************/

#define GuiListItemTemplate_PROPERTIES(F)\
				F(GuiListItemTemplate, bool, Selected, false)\
				F(GuiListItemTemplate, vint, Index, 0)\
				F(GuiListItemTemplate, controls::GuiListControl*, AssociatedListControl, nullptr)\

#define GuiTextListItemTemplate_PROPERTIES(F)\
				F(GuiTextListItemTemplate, Color, TextColor, {})\
				F(GuiTextListItemTemplate, bool, Checked, false)\
				
#define GuiTreeItemTemplate_PROPERTIES(F)\
				F(GuiTreeItemTemplate, Color, TextColor, {})\
				F(GuiTreeItemTemplate, bool, Expanding, false)\
				F(GuiTreeItemTemplate, bool, Expandable, false)\
				F(GuiTreeItemTemplate, vint, Level, 0)\
				F(GuiTreeItemTemplate, Ptr<GuiImageData>, Image, {})\

#define GuiGridCellTemplate_PROPERTIES(F)\
				F(GuiGridCellTemplate, Color, PrimaryTextColor, {})\
				F(GuiGridCellTemplate, Color, SecondaryTextColor, {})\
				F(GuiGridCellTemplate, Color, ItemSeparatorColor, {})\
				F(GuiGridCellTemplate, Ptr<GuiImageData>, LargeImage, {})\
				F(GuiGridCellTemplate, Ptr<GuiImageData>, SmallImage, {})\

#define GuiGridVisualizerTemplate_PROPERTIES(F)\
				F(GuiGridVisualizerTemplate, description::Value, RowValue, {})\
				F(GuiGridVisualizerTemplate, description::Value, CellValue, {})\
				F(GuiGridVisualizerTemplate, bool, Selected, false)\

#define GuiGridEditorTemplate_PROPERTIES(F)\
				F(GuiGridEditorTemplate, description::Value, RowValue, {})\
				F(GuiGridEditorTemplate, description::Value, CellValue, {})\
				F(GuiGridEditorTemplate, bool, CellValueSaved, true)\
				F(GuiGridEditorTemplate, controls::GuiControl*, FocusControl, nullptr)\

/***********************************************************************
Template Declarations
***********************************************************************/

			GUI_CONTROL_TEMPLATE_DECL(GUI_TEMPLATE_CLASS_FORWARD_DECL)
			GUI_ITEM_TEMPLATE_DECL(GUI_TEMPLATE_CLASS_FORWARD_DECL)

			GUI_CONTROL_TEMPLATE_DECL(GUI_TEMPLATE_CLASS_DECL)
			GUI_ITEM_TEMPLATE_DECL(GUI_TEMPLATE_CLASS_DECL)
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\GUIBUTTONCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBUTTONCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBUTTONCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Buttons
***********************************************************************/

			/// <summary>A control with 3 phases state transffering when mouse click happens.</summary>
			class GuiButton : public GuiControl, public Description<GuiButton>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ButtonTemplate, GuiControl)
			protected:
				bool									clickOnMouseUp = true;
				bool									ignoreChildControlMouseEvents = true;
				bool									autoFocus = true;
				bool									keyPressing = false;
				bool									mousePressingDirect = false;
				bool									mousePressingIndirect = false;
				bool									mouseHoving = false;
				ButtonState								controlState = ButtonState::Normal;

				void									OnParentLineChanged()override;
				void									OnActiveAlt()override;
				bool									IsTabAvailable()override;
				void									UpdateControlState();
				void									CheckAndClick(bool skipChecking, compositions::GuiEventArgs& arguments);
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void									OnKeyUp(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void									OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiButton(theme::ThemeName themeName);
				~GuiButton();

				/// <summary>Mouse click event.</summary>
				compositions::GuiNotifyEvent			Clicked;

				/// <summary>Test is the <see cref="Clicked"/> event raised when left mouse button up.</summary>
				/// <returns>Returns true if this event is raised when left mouse button up</returns>
				bool									GetClickOnMouseUp();
				/// <summary>Set is the <see cref="Clicked"/> event raised when left mouse button up or not.</summary>
				/// <param name="value">Set to true to make this event raised when left mouse button up</param>
				void									SetClickOnMouseUp(bool value);

				/// <summary>Test if the button gets focus when it is clicked.</summary>
				/// <returns>Returns true if the button gets focus when it is clicked.</returns>
				bool									GetAutoFocus();
				/// <summary>Set if the button gets focus when it is clicked.</summary>
				/// <param name="value">Set to true to make this button get focus when it is clicked.</param>
				void									SetAutoFocus(bool value);

				/// <summary>
				/// Test if the button ignores mouse events raised in child controls.
				/// When this property is false,
				/// the button reacts to mouse operations even when it happens on contained child controls.
				/// </summary>
				/// <returns>Returns true if the button ignores mouse events raised in child controls.</returns>
				bool									GetIgnoreChildControlMouseEvents();
				/// <summary>Set if the button ignores mouse events raised in child controls.</summary>
				/// <param name="value">Set to true to make this button ignore mouse events raised in child controls.</param>
				void									SetIgnoreChildControlMouseEvents(bool value);
			};

			/// <summary>A <see cref="GuiButton"/> with a selection state.</summary>
			class GuiSelectableButton : public GuiButton, public Description<GuiSelectableButton>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(SelectableButtonTemplate, GuiButton)
			public:
				/// <summary>Selection group controller. Control the selection state of all attached button.</summary>
				class GroupController : public GuiComponent, public Description<GroupController>
				{
				protected:
					collections::List<GuiSelectableButton*>	buttons;
				public:
					GroupController();
					~GroupController();

					/// <summary>Called when the group controller is attached to a <see cref="GuiSelectableButton"/>. use [M:vl.presentation.controls.GuiSelectableButton.SetGroupController] to attach or detach a group controller to or from a selectable button.</summary>
					/// <param name="button">The button to attach.</param>
					virtual void						Attach(GuiSelectableButton* button);
					/// <summary>Called when the group controller is deteched to a <see cref="GuiSelectableButton"/>. use [M:vl.presentation.controls.GuiSelectableButton.SetGroupController] to attach or detach a group controller to or from a selectable button.</summary>
					/// <param name="button">The button to detach.</param>
					virtual void						Detach(GuiSelectableButton* button);
					/// <summary>Called when the selection state of any <see cref="GuiSelectableButton"/> changed.</summary>
					/// <param name="button">The button that changed the selection state.</param>
					virtual void						OnSelectedChanged(GuiSelectableButton* button) = 0;
				};

				/// <summary>A mutex group controller, usually for radio buttons.</summary>
				class MutexGroupController : public GroupController, public Description<MutexGroupController>
				{
				protected:
					bool								suppress;
				public:
					MutexGroupController();
					~MutexGroupController();

					void								OnSelectedChanged(GuiSelectableButton* button)override;
				};

			protected:
				GroupController*						groupController = nullptr;
				bool									autoSelection = true;
				bool									isSelected = false;

				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiSelectableButton(theme::ThemeName themeName);
				~GuiSelectableButton();

				/// <summary>Group controller changed event.</summary>
				compositions::GuiNotifyEvent			GroupControllerChanged;
				/// <summary>Auto selection changed event.</summary>
				compositions::GuiNotifyEvent			AutoSelectionChanged;
				/// <summary>Selected changed event.</summary>
				compositions::GuiNotifyEvent			SelectedChanged;

				/// <summary>Get the attached group controller.</summary>
				/// <returns>The attached group controller.</returns>
				virtual GroupController*				GetGroupController();
				/// <summary>Set the attached group controller.</summary>
				/// <param name="value">The attached group controller.</param>
				virtual void							SetGroupController(GroupController* value);

				/// <summary>Get the auto selection state. True if the button is automatically selected or unselected when the button is clicked.</summary>
				/// <returns>The auto selection state.</returns>
				virtual bool							GetAutoSelection();
				/// <summary>Set the auto selection state. True if the button is automatically selected or unselected when the button is clicked.</summary>
				/// <param name="value">The auto selection state.</param>
				virtual void							SetAutoSelection(bool value);

				/// <summary>Get the selected state.</summary>
				/// <returns>The selected state.</returns>
				virtual bool							GetSelected();
				/// <summary>Set the selected state.</summary>
				/// <param name="value">The selected state.</param>
				virtual void							SetSelected(bool value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUISCROLLCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUISCROLLCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUISCROLLCONTROLS


namespace vl
{
	namespace presentation
	{

		namespace controls
		{

/***********************************************************************
Scrolls
***********************************************************************/

			/// <summary>A scroll control, which represents a one dimension sub range of a whole range.</summary>
			class GuiScroll : public GuiControl, public Description<GuiScroll>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ScrollTemplate, GuiControl)
			protected:
				class CommandExecutor : public Object, public IScrollCommandExecutor
				{
				protected:
					GuiScroll*							scroll;
				public:
					CommandExecutor(GuiScroll* _scroll);
					~CommandExecutor();

					void								SmallDecrease()override;
					void								SmallIncrease()override;
					void								BigDecrease()override;
					void								BigIncrease()override;

					void								SetTotalSize(vint value)override;
					void								SetPageSize(vint value)override;
					void								SetPosition(vint value)override;
				};

				Ptr<CommandExecutor>					commandExecutor;
				vint									totalSize = 100;
				vint									pageSize = 10;
				vint									position = 0;
				vint									smallMove = 1;
				vint									bigMove = 10;
				bool									autoFocus = true;

				void									OnActiveAlt()override;
				bool									IsTabAvailable()override;
				void									OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void									OnMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiScroll(theme::ThemeName themeName);
				~GuiScroll();
				
				/// <summary>Total size changed event.</summary>
				compositions::GuiNotifyEvent			TotalSizeChanged;
				/// <summary>Page size changed event.</summary>
				compositions::GuiNotifyEvent			PageSizeChanged;
				/// <summary>Position changed event.</summary>
				compositions::GuiNotifyEvent			PositionChanged;
				/// <summary>Small move changed event.</summary>
				compositions::GuiNotifyEvent			SmallMoveChanged;
				/// <summary>Big move changed event.</summary>
				compositions::GuiNotifyEvent			BigMoveChanged;
				
				/// <summary>Get the total size.</summary>
				/// <returns>The total size.</returns>
				virtual vint							GetTotalSize();
				/// <summary>Set the total size.</summary>
				/// <param name="value">The total size.</param>
				virtual void							SetTotalSize(vint value);
				/// <summary>Get the page size.</summary>
				/// <returns>The page size.</returns>
				virtual vint							GetPageSize();
				/// <summary>Set the page size.</summary>
				/// <param name="value">The page size.</param>
				virtual void							SetPageSize(vint value);
				/// <summary>Get the position.</summary>
				/// <returns>The position.</returns>
				virtual vint							GetPosition();
				/// <summary>Set the position.</summary>
				/// <param name="value">The position.</param>
				virtual void							SetPosition(vint value);
				/// <summary>Get the small move.</summary>
				/// <returns>The small move.</returns>
				virtual vint							GetSmallMove();
				/// <summary>Set the small move.</summary>
				/// <param name="value">The small move.</param>
				virtual void							SetSmallMove(vint value);
				/// <summary>Get the big move.</summary>
				/// <returns>The big move.</returns>
				virtual vint							GetBigMove();
				/// <summary>Set the big move.</summary>
				/// <param name="value">The big move.</param>
				virtual void							SetBigMove(vint value);
				
				/// <summary>Get the minimum possible position.</summary>
				/// <returns>The minimum possible position.</returns>
				vint									GetMinPosition();
				/// <summary>Get the maximum possible position.</summary>
				/// <returns>The maximum possible position.</returns>
				vint									GetMaxPosition();

				/// <summary>Test if the scroll gets focus when it is clicked.</summary>
				/// <returns>Returns true if the scroll gets focus when it is clicked</returns>
				bool									GetAutoFocus();
				/// <summary>Set if the scroll gets focus when it is clicked.</summary>
				/// <param name="value">Set to true to make this scroll get focus when it is clicked.</param>
				void									SetAutoFocus(bool value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\GUICONTAINERCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
Tab Control
***********************************************************************/

			class GuiTabPageList;
			class GuiTab;

			/// <summary>Represnets a tab page control.</summary>
			class GuiTabPage : public GuiCustomControl, public AggregatableDescription<GuiTabPage>
			{
				friend class GuiTabPageList;
			protected:
				GuiTab*											tab = nullptr;

				bool											IsAltAvailable()override;
			public:
				/// <summary>Create a tab page control with a specified style controller.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTabPage(theme::ThemeName themeName);
				~GuiTabPage();

				GuiTab*											GetOwnerTab();
			};

			class GuiTabPageList : public collections::ObservableList<GuiTabPage*>
			{
			protected:
				GuiTab*											tab;

				bool											QueryInsert(vint index, GuiTabPage* const& value)override;
				void											AfterInsert(vint index, GuiTabPage* const& value)override;
				void											BeforeRemove(vint index, GuiTabPage* const& value)override;
				void											AfterRemove(vint index, vint count)override;
			public:
				GuiTabPageList(GuiTab* _tab);
				~GuiTabPageList();
			};

			/// <summary>Represents a container with multiple named tabs.</summary>
			class GuiTab : public GuiControl, public Description<GuiTab>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TabTemplate, GuiControl)
				friend class GuiTabPageList;
			protected:
				class CommandExecutor : public Object, public ITabCommandExecutor
				{
				protected:
					GuiTab*										tab;

				public:
					CommandExecutor(GuiTab* _tab);
					~CommandExecutor();

					void										ShowTab(vint index, bool setFocus)override;
				};

				Ptr<CommandExecutor>							commandExecutor;
				GuiTabPageList									tabPages;
				GuiTabPage*										selectedPage = nullptr;

				void											OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTab(theme::ThemeName themeName);
				~GuiTab();

				/// <summary>Selected page changed event.</summary>
				compositions::GuiNotifyEvent					SelectedPageChanged;

				/// <summary>Get all pages.</summary>
				/// <returns>All pages.</returns>
				collections::ObservableList<GuiTabPage*>&		GetPages();

				/// <summary>Get the selected page.</summary>
				/// <returns>The selected page.</returns>
				GuiTabPage*										GetSelectedPage();
				/// <summary>Set the selected page.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The selected page.</param>
				bool											SetSelectedPage(GuiTabPage* value);
			};

/***********************************************************************
Scroll View
***********************************************************************/

			/// <summary>A control with a vertical scroll bar and a horizontal scroll bar to perform partial viewing.</summary>
			class GuiScrollView : public GuiControl, public Description<GuiScrollView>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ScrollViewTemplate, GuiControl)

				using IEventHandler = compositions::IGuiGraphicsEventHandler;
			protected:
				bool									supressScrolling = false;
				Ptr<IEventHandler>						hScrollHandler;
				Ptr<IEventHandler>						vScrollHandler;
				Ptr<IEventHandler>						hWheelHandler;
				Ptr<IEventHandler>						vWheelHandler;
				Ptr<IEventHandler>						containerCachedBoundsChangedHandler;
				bool									horizontalAlwaysVisible = true;
				bool									verticalAlwaysVisible = true;

				void									UpdateDisplayFont()override;

				void									OnContainerCachedBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalWheel(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnVerticalWheel(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									CallUpdateView();
				bool									AdjustView(Size fullSize);

				/// <summary>Calculate the full size of the content.</summary>
				/// <returns>The full size of the content.</returns>
				virtual Size							QueryFullSize()=0;
				/// <summary>Update the visible content using a view bounds. The view bounds is in the space from (0,0) to full size.</summary>
				/// <param name="viewBounds">The view bounds.</param>
				virtual void							UpdateView(Rect viewBounds)=0;
				/// <summary>Calculate the small move of the scroll bar.</summary>
				/// <returns>The small move of the scroll bar.</returns>
				virtual vint							GetSmallMove();
				/// <summary>Calculate the big move of the scroll bar.</summary>
				/// <returns>The big move of the scroll bar.</returns>
				virtual Size							GetBigMove();
				
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiScrollView(theme::ThemeName themeName);
				~GuiScrollView();

				/// <summary>Force to update contents and scroll bars.</summary>
				void									CalculateView();
				/// <summary>Get the view size.</summary>
				/// <returns>The view size.</returns>
				Size									GetViewSize();
				/// <summary>Get the view bounds.</summary>
				/// <returns>The view bounds.</returns>
				Rect									GetViewBounds();
				
				/// <summary>Get the position of the left-top corner of the view bounds.</summary>
				/// <returns>The view position.</returns>
				Point									GetViewPosition();
				/// <summary>Set the position of the left-top corner of the view bounds.</summary>
				/// <param name="value">The position.</param>
				void									SetViewPosition(Point value);
				
				/// <summary>Get the horizontal scroll control.</summary>
				/// <returns>The horizontal scroll control.</returns>
				GuiScroll*								GetHorizontalScroll();
				/// <summary>Get the vertical scroll control.</summary>
				/// <returns>The vertical scroll control.</returns>
				GuiScroll*								GetVerticalScroll();
				/// <summary>Test is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <returns>Returns true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</returns>
				bool									GetHorizontalAlwaysVisible();
				/// <summary>Set is the horizontal scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <param name="value">Set to true if the horizontal scroll bar always visible even the content doesn't exceed the view bounds</param>
				void									SetHorizontalAlwaysVisible(bool value);
				/// <summary>Test is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <returns>Returns true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</returns>
				bool									GetVerticalAlwaysVisible();
				/// <summary>Set is the vertical scroll bar always visible even the content doesn't exceed the view bounds.</summary>
				/// <param name="value">Set to true if the vertical scroll bar always visible even the content doesn't exceed the view bounds</param>
				void									SetVerticalAlwaysVisible(bool value);
			};
			
			/// <summary>A control container with a vertical scroll bar and a horizontal scroll bar to perform partial viewing. When controls are added, removed, moved or resized, the scroll bars will adjust automatically.</summary>
			class GuiScrollContainer : public GuiScrollView, public Description<GuiScrollContainer>
			{
			protected:
				bool									extendToFullWidth = false;
				bool									extendToFullHeight = false;

				Size									QueryFullSize()override;
				void									UpdateView(Rect viewBounds)override;
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiScrollContainer(theme::ThemeName themeName);
				~GuiScrollContainer();
				
				/// <summary>Test does the content container always extend its width to fill the scroll container.</summary>
				/// <returns>Return true if the content container always extend its width to fill the scroll container.</returns>
				bool									GetExtendToFullWidth();
				/// <summary>Set does the content container always extend its width to fill the scroll container.</summary>
				/// <param name="value">Set to true if the content container always extend its width to fill the scroll container.</param>
				void									SetExtendToFullWidth(bool value);

				/// <summary>Test does the content container always extend its height to fill the scroll container.</summary>
				/// <returns>Return true if the content container always extend its height to fill the scroll container.</returns>
				bool									GetExtendToFullHeight();
				/// <summary>Set does the content container always extend its height to fill the scroll container.</summary>
				/// <param name="value">Set to true if the content container always extend its height to fill the scroll container.</param>
				void									SetExtendToFullHeight(bool value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\INCLUDEFORWARD.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_INCLUDEFORWARD
#define VCZH_PRESENTATION_CONTROLS_INCLUDEFORWARD


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiCustomControl;
			class GuiLabel;
			class GuiButton;
			class GuiSelectableButton;
			class GuiScroll;
			class GuiTabPage;
			class GuiTab;
			class GuiScrollView;
			class GuiScrollContainer;
			class GuiControlHost;
			class GuiWindow;
			class GuiPopup;
			class GuiTooltip;
			class GuiListControl;
			class GuiSelectableListControl;
			class GuiVirtualTextList;
			class GuiTextList;
			class GuiListViewColumnHeader;
			class GuiListViewBase;
			class GuiVirtualListView;
			class GuiListView;
			class GuiMenu;
			class GuiMenuBar;
			class GuiMenuButton;
			class GuiVirtualTreeListControl;
			class GuiVirtualTreeView;
			class GuiTreeView;
			class GuiComboBoxBase;
			class GuiComboBoxListControl;
			class GuiToolstripMenu;
			class GuiToolstripMenuBar;
			class GuiToolstripToolBar;
			class GuiToolstripButton;
			class GuiToolstripNestedContainer;
			class GuiToolstripGroupContainer;
			class GuiToolstripGroup;
			class GuiRibbonTab;
			class GuiRibbonTabPage;
			class GuiRibbonGroup;
			class GuiRibbonIconLabel;
			class GuiRibbonButtons;
			class GuiRibbonToolstrips;
			class GuiRibbonGallery;
			class GuiRibbonToolstripMenu;
			class GuiBindableRibbonGalleryList;
			class GuiDocumentViewer;
			class GuiDocumentLabel;
			class GuiMultilineTextBox;
			class GuiSinglelineTextBox;
			class GuiVirtualDataGrid;
			class GuiDatePicker;
			class GuiDateComboBox;
			class GuiBindableTextList;
			class GuiBindableListView;
			class GuiBindableTreeView;
			class GuiBindableDataGrid;
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace templates
		{
			class GuiListItemTemplate;
		}

		namespace controls
		{

/***********************************************************************
List Control
***********************************************************************/

			/// <summary>Represents a list control. A list control automatically read data sources and creates corresponding data item control from the item template.</summary>
			class GuiListControl : public GuiScrollView, public Description<GuiListControl>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ListControlTemplate, GuiScrollView)
			public:
				using ItemStyle = templates::GuiListItemTemplate;
				using ItemStyleBounds = templates::GuiTemplate;
				using ItemStyleRecord = collections::Pair<ItemStyle*, ItemStyleBounds*>;
				using ItemStyleProperty = TemplateProperty<templates::GuiListItemTemplate>;

				//-----------------------------------------------------------
				// IItemArrangerCallback
				//-----------------------------------------------------------

				/// <summary>Item arranger callback. Item arrangers use this interface to communicate with the list control. When setting positions for item controls, functions in this callback object is suggested to call because they use the result from the [T:vl.presentation.controls.compositions.IGuiAxis].</summary>
				class IItemArrangerCallback : public virtual IDescriptable, public Description<IItemArrangerCallback>
				{
				public:
					/// <summary>Create an item control representing an item in the item provider. This function is suggested to call when an item control gets into the visible area.</summary>
					/// <returns>The item control.</returns>
					/// <param name="itemIndex">The index of the item in the item provider.</param>
					virtual ItemStyle*								CreateItem(vint itemIndex)=0;
					/// <summary>Get the most outer bounds from an item control.</summary>
					/// <returns>The most outer bounds. When <see cref="GuiListControl::GetDisplayItemBackground/> returns true, the item is wrapped in other compositions.</returns>
					/// <param name="style">The item control.</param>
					virtual ItemStyleBounds*						GetItemBounds(ItemStyle* style)=0;
					/// <summary>Get the item control from its most outer bounds.</summary>
					/// <returns>The item control.</returns>
					/// <param name="style">The most outer bounds.</param>
					virtual ItemStyle*								GetItem(ItemStyleBounds* bounds)=0;
					/// <summary>Release an item control. This function is suggested to call when an item control gets out of the visible area.</summary>
					/// <param name="style">The item control.</param>
					virtual void									ReleaseItem(ItemStyle* style)=0;
					/// <summary>Update the view location. The view location is the left-top position in the logic space of the list control.</summary>
					/// <param name="value">The new view location.</param>
					virtual void									SetViewLocation(Point value)=0;
					/// <summary>Get the <see cref="compositions::GuiGraphicsComposition"/> that directly contains item controls.</summary>
					/// <returns>The <see cref="compositions::GuiGraphicsComposition"/> that directly contains item controls.</returns>
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					/// <summary>Notify the list control that the total size of all item controls are changed.</summary>
					virtual void									OnTotalSizeChanged()=0;
					/// <summary>Notify the list control that the adopted size of the list control is changed.</summary>
					virtual void									OnAdoptedSizeChanged()=0;
				};

				//-----------------------------------------------------------
				// IItemArranger
				//-----------------------------------------------------------

				/// <summary>EnsureItemVisible result for item arranger.</summary>
				enum class EnsureItemVisibleResult
				{
					/// <summary>The requested item does not exist.</summary>
					ItemNotExists,
					/// <summary>The view location is moved.</summary>
					Moved,
					/// <summary>The view location is not moved.</summary>
					NotMoved,
				};
				
				/// <summary>Item arranger for a <see cref="GuiListControl"/>. Item arranger decides how to arrange and item controls. When implementing an item arranger, <see cref="IItemArrangerCallback"/> is suggested to use when calculating locations and sizes for item controls.</summary>
				class IItemArranger : public virtual list::IItemProviderCallback, public Description<IItemArranger>
				{
				public:
					/// <summary>Called when an item arranger in installed to a <see cref="GuiListControl"/>.</summary>
					/// <param name="value">The list control.</param>
					virtual void								AttachListControl(GuiListControl* value) = 0;
					/// <summary>Called when an item arranger in uninstalled from a <see cref="GuiListControl"/>.</summary>
					virtual void								DetachListControl() = 0;
					/// <summary>Get the binded item arranger callback object.</summary>
					/// <returns>The binded item arranger callback object.</returns>
					virtual IItemArrangerCallback*				GetCallback() = 0;
					/// <summary>Bind the item arranger callback object.</summary>
					/// <param name="value">The item arranger callback object to bind.</param>
					virtual void								SetCallback(IItemArrangerCallback* value) = 0;
					/// <summary>Get the total size of all data controls.</summary>
					/// <returns>The total size.</returns>
					virtual Size								GetTotalSize() = 0;
					/// <summary>Get the item style controller for an visible item index. If an item is not visible, it returns null.</summary>
					/// <returns>The item style controller.</returns>
					/// <param name="itemIndex">The item index.</param>
					virtual ItemStyle*							GetVisibleStyle(vint itemIndex) = 0;
					/// <summary>Get the item index for an visible item style controller. If an item is not visible, it returns -1.</summary>
					/// <returns>The item index.</returns>
					/// <param name="style">The item style controller.</param>
					virtual vint								GetVisibleIndex(ItemStyle* style) = 0;
					/// <summary>Reload all visible items.</summary>
					virtual void								ReloadVisibleStyles() = 0;
					/// <summary>Called when the visible area of item container is changed.</summary>
					/// <param name="bounds">The new visible area.</param>
					virtual void								OnViewChanged(Rect bounds) = 0;
					/// <summary>Find the item by an base item and a key direction.</summary>
					/// <returns>The item index that is found. Returns -1 if this operation failed.</returns>
					/// <param name="itemIndex">The base item index.</param>
					/// <param name="key">The key direction.</param>
					virtual vint								FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key) = 0;
					/// <summary>Adjust the view location to make an item visible.</summary>
					/// <returns>Returns the result of this operation.</returns>
					/// <param name="itemIndex">The item index of the item to be made visible.</param>
					virtual EnsureItemVisibleResult				EnsureItemVisible(vint itemIndex) = 0;
					/// <summary>Get the adopted size for the view bounds.</summary>
					/// <returns>The adopted size, making the vids bounds just enough to display several items.</returns>
					/// <param name="expectedSize">The expected size, to provide a guidance.</param>
					virtual Size								GetAdoptedSize(Size expectedSize) = 0;
				};

			protected:

				//-----------------------------------------------------------
				// ItemCallback
				//-----------------------------------------------------------

				class ItemCallback : public list::IItemProviderCallback, public IItemArrangerCallback
				{
					typedef collections::Dictionary<ItemStyle*, templates::GuiTemplate*>	InstalledStyleMap;
				protected:
					GuiListControl*								listControl = nullptr;
					list::IItemProvider*						itemProvider = nullptr;
					InstalledStyleMap							installedStyles;

					ItemStyleRecord								InstallStyle(ItemStyle* style, vint itemIndex);
					ItemStyleRecord								UninstallStyle(vint index);
				public:
					ItemCallback(GuiListControl* _listControl);
					~ItemCallback();

					void										ClearCache();

					void										OnAttached(list::IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
					ItemStyle*									CreateItem(vint itemIndex)override;
					ItemStyleBounds*							GetItemBounds(ItemStyle* style)override;
					ItemStyle*									GetItem(ItemStyleBounds* bounds)override;
					void										ReleaseItem(ItemStyle* style)override;
					void										SetViewLocation(Point value)override;
					compositions::GuiGraphicsComposition*		GetContainerComposition()override;
					void										OnTotalSizeChanged()override;
					void										OnAdoptedSizeChanged()override;
				};

				//-----------------------------------------------------------
				// State management
				//-----------------------------------------------------------

				Ptr<ItemCallback>								callback;
				Ptr<list::IItemProvider>						itemProvider;
				ItemStyleProperty								itemStyleProperty;
				Ptr<IItemArranger>								itemArranger;
				Ptr<compositions::IGuiAxis>						axis;
				Size											fullSize;
				Size											adoptedSizeDiffWithScroll = { -1,-1 };
				Size											adoptedSizeDiffWithoutScroll = { -1,-1 };
				bool											displayItemBackground = true;

				virtual void									OnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated);
				virtual void									OnStyleInstalled(vint itemIndex, ItemStyle* style, bool refreshPropertiesOnly);
				virtual void									OnStyleUninstalled(ItemStyle* style);
				
				void											OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void											OnBeforeReleaseGraphicsHost()override;
				Size											QueryFullSize()override;
				void											UpdateView(Rect viewBounds)override;
				
				void											OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											SetStyleAndArranger(ItemStyleProperty styleProperty, Ptr<IItemArranger> arranger);

				//-----------------------------------------------------------
				// Item event management
				//-----------------------------------------------------------

				class VisibleStyleHelper
				{
				public:
					Ptr<compositions::IGuiGraphicsEventHandler>		leftButtonDownHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		leftButtonUpHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		leftButtonDoubleClickHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		middleButtonDownHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		middleButtonUpHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		middleButtonDoubleClickHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		rightButtonDownHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		rightButtonUpHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		rightButtonDoubleClickHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		mouseMoveHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		mouseEnterHandler;
					Ptr<compositions::IGuiGraphicsEventHandler>		mouseLeaveHandler;
				};
				
				friend class collections::ArrayBase<Ptr<VisibleStyleHelper>>;
				collections::Dictionary<ItemStyle*, Ptr<VisibleStyleHelper>>		visibleStyles;

				void											UpdateDisplayFont()override;
				void											OnVisuallyEnabledChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnContextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnItemMouseEvent(compositions::GuiItemMouseEvent& itemEvent, ItemStyle* style, compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											OnItemNotifyEvent(compositions::GuiItemNotifyEvent& itemEvent, ItemStyle* style, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											AttachItemEvents(ItemStyle* style);
				void											DetachItemEvents(ItemStyle* style);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider as a data source.</param>
				/// <param name="acceptFocus">Set to true if the list control is allowed to have a keyboard focus.</param>
				GuiListControl(theme::ThemeName themeName, list::IItemProvider* _itemProvider, bool acceptFocus=false);
				~GuiListControl();

				/// <summary>Style provider changed event.</summary>
				compositions::GuiNotifyEvent					ItemTemplateChanged;
				/// <summary>Arranger changed event.</summary>
				compositions::GuiNotifyEvent					ArrangerChanged;
				/// <summary>Coordinate transformer changed event.</summary>
				compositions::GuiNotifyEvent					AxisChanged;
				/// <summary>Adopted size invalidated.</summary>
				compositions::GuiNotifyEvent					AdoptedSizeInvalidated;

				/// <summary>Item left mouse button down event.</summary>
				compositions::GuiItemMouseEvent					ItemLeftButtonDown;
				/// <summary>Item left mouse button up event.</summary>
				compositions::GuiItemMouseEvent					ItemLeftButtonUp;
				/// <summary>Item left mouse button double click event.</summary>
				compositions::GuiItemMouseEvent					ItemLeftButtonDoubleClick;
				/// <summary>Item middle mouse button down event.</summary>
				compositions::GuiItemMouseEvent					ItemMiddleButtonDown;
				/// <summary>Item middle mouse button up event.</summary>
				compositions::GuiItemMouseEvent					ItemMiddleButtonUp;
				/// <summary>Item middle mouse button double click event.</summary>
				compositions::GuiItemMouseEvent					ItemMiddleButtonDoubleClick;
				/// <summary>Item right mouse button down event.</summary>
				compositions::GuiItemMouseEvent					ItemRightButtonDown;
				/// <summary>Item right mouse button up event.</summary>
				compositions::GuiItemMouseEvent					ItemRightButtonUp;
				/// <summary>Item right mouse button double click event.</summary>
				compositions::GuiItemMouseEvent					ItemRightButtonDoubleClick;
				/// <summary>Item mouse move event.</summary>
				compositions::GuiItemMouseEvent					ItemMouseMove;
				/// <summary>Item mouse enter event.</summary>
				compositions::GuiItemNotifyEvent				ItemMouseEnter;
				/// <summary>Item mouse leave event.</summary>
				compositions::GuiItemNotifyEvent				ItemMouseLeave;

				/// <summary>Get the item provider.</summary>
				/// <returns>The item provider.</returns>
				virtual list::IItemProvider*					GetItemProvider();
				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				virtual ItemStyleProperty						GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				virtual void									SetItemTemplate(ItemStyleProperty value);
				/// <summary>Get the item arranger.</summary>
				/// <returns>The item arranger.</returns>
				virtual IItemArranger*							GetArranger();
				/// <summary>Set the item arranger</summary>
				/// <param name="value">The new item arranger</param>
				virtual void									SetArranger(Ptr<IItemArranger> value);
				/// <summary>Get the item coordinate transformer.</summary>
				/// <returns>The item coordinate transformer.</returns>
				virtual compositions::IGuiAxis*					GetAxis();
				/// <summary>Set the item coordinate transformer</summary>
				/// <param name="value">The new item coordinate transformer</param>
				virtual void									SetAxis(Ptr<compositions::IGuiAxis> value);
				/// <summary>Adjust the view location to make an item visible.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="itemIndex">The item index of the item to be made visible.</param>
				virtual bool									EnsureItemVisible(vint itemIndex);
				/// <summary>Get the adopted size for the list control.</summary>
				/// <returns>The adopted size, making the list control just enough to display several items.</returns>
				/// <param name="expectedSize">The expected size, to provide a guidance.</param>
				virtual Size									GetAdoptedSize(Size expectedSize);
				/// <summary>Test if the list control displays predefined item background.</summary>
				/// <returns>Returns true if the list control displays predefined item background.</returns>
				bool											GetDisplayItemBackground();
				/// <summary>Set if the list control displays predefined item background.</summary>
				/// <param name="value">Set to true to display item background.</param>
				void											SetDisplayItemBackground(bool value);
			};

/***********************************************************************
Selectable List Control
***********************************************************************/

			/// <summary>Represents a list control that each item is selectable.</summary>
			class GuiSelectableListControl : public GuiListControl, public Description<GuiSelectableListControl>
			{
			protected:

				collections::SortedList<vint>					selectedItems;
				bool											multiSelect;
				vint											selectedItemIndexStart;
				vint											selectedItemIndexEnd;

				virtual void									NotifySelectionChanged(bool triggeredByItemContentModified);
				void											OnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
				void											OnStyleInstalled(vint itemIndex, ItemStyle* style, bool refreshPropertiesOnly)override;
				virtual void									OnItemSelectionChanged(vint itemIndex, bool value);
				virtual void									OnItemSelectionCleared();
				void											OnItemLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void											OnItemRightButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);

				void											NormalizeSelectedItemIndexStartEnd();
				void											SetMultipleItemsSelectedSilently(vint start, vint end, bool selected);
				void											OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);

				virtual vint									FindItemByVirtualKeyDirection(vint index, compositions::KeyDirection keyDirection);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider as a data source.</param>
				GuiSelectableListControl(theme::ThemeName themeName, list::IItemProvider* _itemProvider);
				~GuiSelectableListControl();

				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent					SelectionChanged;

				/// <summary>Get the multiple selection mode.</summary>
				/// <returns>Returns true if multiple selection is enabled.</returns>
				bool											GetMultiSelect();
				/// <summary>Set the multiple selection mode.</summary>
				/// <param name="value">Set to true to enable multiple selection.</param>
				void											SetMultiSelect(bool value);
				
				/// <summary>Get indices of all selected items.</summary>
				/// <returns>Indices of all selected items.</returns>
				const collections::SortedList<vint>&			GetSelectedItems();
				/// <summary>Get the index of the selected item.</summary>
				/// <returns>Returns the index of the selected item. If there are multiple selected items, or there is no selected item, -1 will be returned.</returns>
				vint											GetSelectedItemIndex();
				/// <summary>Get the text of the selected item.</summary>
				/// <returns>Returns the text of the selected item. If there are multiple selected items, or there is no selected item, an empty string will be returned.</returns>
				WString											GetSelectedItemText();

				/// <summary>Get the selection status of an item.</summary>
				/// <returns>The selection status of an item.</returns>
				/// <param name="itemIndex">The index of the item.</param>
				bool											GetSelected(vint itemIndex);
				/// <summary>Set the selection status of an item.</summary>
				/// <param name="itemIndex">The index of the item.</param>
				/// <param name="value">Set to true to select the item.</param>
				void											SetSelected(vint itemIndex, bool value);
				/// <summary>Set the selection status of an item, and affect other selected item according to key status.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="itemIndex">The index of the item.</param>
				/// <param name="ctrl">Set to true if the control key is pressing.</param>
				/// <param name="shift">Set to true if the shift key is pressing.</param>
				/// <param name="leftButton">Set to true if clicked by left mouse button, otherwise right mouse button.</param>
				bool											SelectItemsByClick(vint itemIndex, bool ctrl, bool shift, bool leftButton);
				/// <summary>Set the selection status using keys.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="code">The key code that is pressing.</param>
				/// <param name="ctrl">Set to true if the control key is pressing.</param>
				/// <param name="shift">Set to true if the shift key is pressing.</param>
				bool											SelectItemsByKey(VKEY code, bool ctrl, bool shift);
				/// <summary>Unselect all items.</summary>
				void											ClearSelection();
			};

/***********************************************************************
Predefined ItemProvider
***********************************************************************/

			namespace list
			{
				template<typename TBase>
				class PredefinedListItemTemplate : public TBase
				{
				protected:
					GuiListControl*							listControl = nullptr;
					virtual void							OnInitialize() = 0;
					virtual void							OnRefresh() = 0;

					void OnAssociatedListControlChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments)
					{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::controls::list::PredefinedListItemTemplate<TBase>::OnAssociatedListControlChanged(GuiGraphicsComposition*, GuiEventArgs&)#"
						auto value = this->GetAssociatedListControl();
						CHECK_ERROR(value && (!listControl || listControl == value), ERROR_MESSAGE_PREFIX L"GuiListItemTemplate::SetAssociatedListControl cannot be invoked using a different list control instance.");
						if (!listControl)
						{
							listControl = value;
							OnInitialize();
							OnRefresh();
						}
#undef ERROR_MESSAGE_PREFIX
					}
				public:
					PredefinedListItemTemplate()
					{
						this->AssociatedListControlChanged.AttachMethod(this, &PredefinedListItemTemplate<TBase>::OnAssociatedListControlChanged);
					}

					void RefreshItem()
					{
						OnRefresh();
					}
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTCONTROLITEMARRANGERS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLITEMARRANGERS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLITEMARRANGERS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Predefined ItemArranger
***********************************************************************/

			namespace list
			{
				/// <summary>Ranged item arranger. This arranger implements most of the common functionality for those arrangers that display a continuing subset of item at a time.</summary>
				class RangedItemArrangerBase : public Object, virtual public GuiListControl::IItemArranger, public Description<RangedItemArrangerBase>
				{
				protected:
					using ItemStyleRecord = collections::Pair<GuiListControl::ItemStyle*, GuiSelectableButton*>;
					typedef collections::List<ItemStyleRecord>	StyleList;

					GuiListControl*									listControl = nullptr;
					GuiListControl::IItemArrangerCallback*			callback = nullptr;
					list::IItemProvider*							itemProvider = nullptr;
					Ptr<description::IValueObservableList>			itemSource;
					compositions::GuiVirtualRepeatCompositionBase*	repeat = nullptr;

					void											OnViewLocationChanged(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);
					void											OnTotalSizeChanged(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);
					void											OnAdoptedSizeInvalidated(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);
				public:
					/// <summary>Create the arranger.</summary>
					/// <param name="_repeat">A repeat composition to implement the item layout. It will be deleted when the item arranger is deleted.</param>
					RangedItemArrangerBase(compositions::GuiVirtualRepeatCompositionBase* _repeat);
					~RangedItemArrangerBase();

					void											OnAttached(list::IItemProvider* provider)override;
					void											OnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
					void											AttachListControl(GuiListControl* value)override;
					void											DetachListControl()override;
					GuiListControl::IItemArrangerCallback*			GetCallback()override;
					void											SetCallback(GuiListControl::IItemArrangerCallback* value)override;
					Size											GetTotalSize()override;
					GuiListControl::ItemStyle*						GetVisibleStyle(vint itemIndex)override;
					vint											GetVisibleIndex(GuiListControl::ItemStyle* style)override;
					void											ReloadVisibleStyles()override;
					void											OnViewChanged(Rect bounds)override;
					vint											FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key) override;
					GuiListControl::EnsureItemVisibleResult			EnsureItemVisible(vint itemIndex) override;
					Size											GetAdoptedSize(Size expectedSize) override;
				};

				template<typename TVirtualRepeatComposition>
				class VirtualRepeatRangedItemArrangerBase : public RangedItemArrangerBase
				{
					using TArranger = VirtualRepeatRangedItemArrangerBase<TVirtualRepeatComposition>;
				protected:
					class ArrangerRepeatComposition : public TVirtualRepeatComposition
					{
					protected:
						TArranger*								arranger = nullptr;

						void Layout_UpdateIndex(templates::GuiTemplate* style, vint index) override
						{
							auto itemStyle = arranger->callback->GetItem(style);
							itemStyle->SetIndex(index);
						}

						templates::GuiTemplate* CreateStyleInternal(vint index) override
						{
							auto itemStyle = arranger->callback->CreateItem(index);
							return arranger->callback->GetItemBounds(itemStyle);
						}

						void DeleteStyleInternal(templates::GuiTemplate* style) override
						{
							auto itemStyle = arranger->callback->GetItem(style);
							arranger->callback->ReleaseItem(itemStyle);
						}
					public:
						template<typename ...TArgs>
						ArrangerRepeatComposition(TArranger* _arranger, TArgs&& ...args)
							: TVirtualRepeatComposition(std::forward<TArgs&&>(args)...)
							, arranger(_arranger)
						{
							this->SetUseMinimumTotalSize(true);
						}
					};

					TVirtualRepeatComposition* GetRepeatComposition()
					{
						return dynamic_cast<TVirtualRepeatComposition*>(repeat);
					}

				protected:
					VirtualRepeatRangedItemArrangerBase()
						: RangedItemArrangerBase(new ArrangerRepeatComposition(this))
					{
					}

					VirtualRepeatRangedItemArrangerBase(ArrangerRepeatComposition* _repeat)
						: RangedItemArrangerBase(_repeat)
					{
					}
				};

				/// <summary>Free height item arranger. This arranger will cache heights of all items.</summary>
				class FreeHeightItemArranger : public VirtualRepeatRangedItemArrangerBase<compositions::GuiRepeatFreeHeightItemComposition>, public Description<FreeHeightItemArranger>
				{
				public:
					/// <summary>Create the arranger.</summary>
					FreeHeightItemArranger();
					~FreeHeightItemArranger();
				};
				
				/// <summary>Fixed height item arranger. This arranger lists all item with the same height value. This value is the maximum height of all minimum heights of displayed items.</summary>
				class FixedHeightItemArranger : public VirtualRepeatRangedItemArrangerBase<compositions::GuiRepeatFixedHeightItemComposition>, public Description<FixedHeightItemArranger>
				{
				public:
					/// <summary>Create the arranger.</summary>
					FixedHeightItemArranger();
					~FixedHeightItemArranger();
				};

				/// <summary>Fixed size multiple columns item arranger. This arranger adjust all items in multiple lines with the same size. The width is the maximum width of all minimum widths of displayed items. The same to height.</summary>
				class FixedSizeMultiColumnItemArranger : public VirtualRepeatRangedItemArrangerBase<compositions::GuiRepeatFixedSizeMultiColumnItemComposition>, public Description<FixedSizeMultiColumnItemArranger>
				{
				public:
					/// <summary>Create the arranger.</summary>
					FixedSizeMultiColumnItemArranger();
					~FixedSizeMultiColumnItemArranger();
				};
				
				/// <summary>Fixed size multiple columns item arranger. This arranger adjust all items in multiple columns with the same height. The height is the maximum width of all minimum height of displayed items. Each item will displayed using its minimum width.</summary>
				class FixedHeightMultiColumnItemArranger : public VirtualRepeatRangedItemArrangerBase<compositions::GuiRepeatFixedHeightMultiColumnItemComposition>, public Description<FixedHeightMultiColumnItemArranger>
				{
				public:
					/// <summary>Create the arranger.</summary>
					FixedHeightMultiColumnItemArranger();
					~FixedHeightMultiColumnItemArranger();
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUITEXTLISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualTextList;
			class GuiTextList;

			namespace list
			{

/***********************************************************************
DefaultTextListItemTemplate
***********************************************************************/

				/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for <see cref="GuiVirtualTextList"/>.</summary>
				class ITextItemView : public virtual IDescriptable, public Description<ITextItemView>
				{
				public:
					/// <summary>The identifier for this view.</summary>
					static const wchar_t* const				Identifier;

					/// <summary>Get the check state of an item.</summary>
					/// <returns>The check state of an item.</returns>
					/// <param name="itemIndex">The index of an item.</param>
					virtual bool							GetChecked(vint itemIndex) = 0;
					/// <summary>Set the check state of an item without invoving any UI action.</summary>
					/// <param name="itemIndex">The index of an item.</param>
					/// <param name="value">The new check state.</param>
					virtual void							SetChecked(vint itemIndex, bool value) = 0;
				};

				class DefaultTextListItemTemplate : public PredefinedListItemTemplate<templates::GuiTextListItemTemplate>
				{
				protected:
					using BulletStyle = templates::GuiControlTemplate;

					GuiSelectableButton*					bulletButton = nullptr;
					elements::GuiSolidLabelElement*			textElement = nullptr;
					bool									supressEdit = false;

					virtual TemplateProperty<BulletStyle>	CreateBulletStyle();
					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnCheckedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DefaultTextListItemTemplate();
					~DefaultTextListItemTemplate();
				};

				class DefaultCheckTextListItemTemplate : public DefaultTextListItemTemplate
				{
				protected:
					TemplateProperty<BulletStyle>			CreateBulletStyle()override;
				public:
				};

				class DefaultRadioTextListItemTemplate : public DefaultTextListItemTemplate
				{
				protected:
					TemplateProperty<BulletStyle>			CreateBulletStyle()override;
				public:
				};

/***********************************************************************
TextItemProvider
***********************************************************************/

				class TextItemProvider;

				/// <summary>Text item. This is the item data structure for [T:vl.presentation.controls.list.TextItemProvider].</summary>
				class TextItem : public Object, public Description<TextItem>
				{
					friend class TextItemProvider;
				protected:
					TextItemProvider*							owner;
					WString										text;
					bool										checked;

					void										NotifyUpdate(bool raiseCheckEvent);
				public:
					/// <summary>Create an empty text item.</summary>
					TextItem();
					/// <summary>Create a text item with specified text and check state.</summary>
					/// <param name="_text">The text.</param>
					/// <param name="_checked">The check state.</param>
					TextItem(const WString& _text, bool _checked=false);
					~TextItem();

					std::strong_ordering operator<=>(const TextItem& value) const { return text <=> value.text; }
					bool operator==(const TextItem& value) const { return text == value.text; }
					
					/// <summary>Get the text of this item.</summary>
					/// <returns>The text of this item.</returns>
					const WString&								GetText();
					/// <summary>Set the text of this item.</summary>
					/// <param name="value">The text of this item.</param>
					void										SetText(const WString& value);

					/// <summary>Get the check state of this item.</summary>
					/// <returns>The check state of this item.</returns>
					bool										GetChecked();
					/// <summary>Set the check state of this item.</summary>
					/// <param name="value">The check state of this item.</param>
					void										SetChecked(bool value);
				};

				/// <summary>Item provider for <see cref="GuiVirtualTextList"/> or <see cref="GuiSelectableListControl"/>.</summary>
				class TextItemProvider
					: public ListProvider<Ptr<TextItem>>
					, protected ITextItemView
					, public Description<TextItemProvider>
				{
					friend class TextItem;
					friend class vl::presentation::controls::GuiTextList;
				protected:
					GuiTextList*								listControl;

					void										AfterInsert(vint item, const Ptr<TextItem>& value)override;
					void										BeforeRemove(vint item, const Ptr<TextItem>& value)override;

					WString										GetTextValue(vint itemIndex)override;
					description::Value							GetBindingValue(vint itemIndex)override;
					bool										GetChecked(vint itemIndex)override;
					void										SetChecked(vint itemIndex, bool value)override;
				public:
					TextItemProvider();
					~TextItemProvider();

					IDescriptable*								RequestView(const WString& identifier)override;
				};
			}

/***********************************************************************
GuiVirtualTextList
***********************************************************************/

			enum class TextListView
			{
				Text,
				Check,
				Radio,
				Unknown,
			};

			/// <summary>Text list control in virtual mode.</summary>
			class GuiVirtualTextList : public GuiSelectableListControl, public Description<GuiVirtualTextList>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TextListTemplate, GuiSelectableListControl)
			protected:
				TextListView											view = TextListView::Unknown;

				void													OnStyleInstalled(vint itemIndex, ItemStyle* style, bool refreshPropertiesOnly)override;
				void													OnItemTemplateChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a Text list control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiVirtualTextList(theme::ThemeName themeName, list::IItemProvider* _itemProvider);
				~GuiVirtualTextList();

				/// <summary>Item checked changed event.</summary>
				compositions::GuiItemNotifyEvent						ItemChecked;

				/// <summary>Get the current view.</summary>
				/// <returns>The current view. After [M:vl.presentation.controls.GuiListControl.SetItemTemplate] is called, the current view is reset to Unknown.</returns>
				TextListView											GetView();
				/// <summary>Set the current view.</summary>
				/// <param name="_view">The current view.</param>
				void													SetView(TextListView _view);
			};

/***********************************************************************
GuiTextList
***********************************************************************/
			
			/// <summary>Text list control.</summary>
			class GuiTextList : public GuiVirtualTextList, public Description<GuiTextList>
			{
			protected:
				list::TextItemProvider*									items;
			public:
				/// <summary>Create a Text list control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTextList(theme::ThemeName themeName);
				~GuiTextList();

				/// <summary>Get all text items.</summary>
				/// <returns>All text items.</returns>
				list::TextItemProvider&									GetItems();

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				Ptr<list::TextItem>										GetSelectedItem();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUITREEVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			/// <summary>Tree list control in virtual node.</summary>
			class GuiVirtualTreeListControl : public GuiSelectableListControl, protected virtual tree::INodeProviderCallback, public Description<GuiVirtualTreeListControl>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(TreeViewTemplate, GuiSelectableListControl)
			protected:
				void								OnAttached(tree::INodeRootProvider* provider)override;
				void								OnBeforeItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
				void								OnAfterItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
				void								OnItemExpanded(tree::INodeProvider* node)override;
				void								OnItemCollapsed(tree::INodeProvider* node)override;

				vint								FindItemByVirtualKeyDirection(vint index, compositions::KeyDirection keyDirection)override;
			protected:
				tree::NodeItemProvider*				nodeItemProvider;
				tree::INodeItemView*				nodeItemView;

				void								OnItemMouseEvent(compositions::GuiNodeMouseEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void								OnItemNotifyEvent(compositions::GuiNodeNotifyEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void								OnNodeLeftButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiNodeMouseEventArgs& arguments);
			public:
				/// <summary>Create a tree list control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_nodeRootProvider">The node root provider for this control.</param>
				GuiVirtualTreeListControl(theme::ThemeName themeName, Ptr<tree::INodeRootProvider> _nodeRootProvider);
				~GuiVirtualTreeListControl();

				/// <summary>Node left mouse button down event.</summary>
				compositions::GuiNodeMouseEvent		NodeLeftButtonDown;
				/// <summary>Node left mouse button up event.</summary>
				compositions::GuiNodeMouseEvent		NodeLeftButtonUp;
				/// <summary>Node left mouse button double click event.</summary>
				compositions::GuiNodeMouseEvent		NodeLeftButtonDoubleClick;
				/// <summary>Node middle mouse button down event.</summary>
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDown;
				/// <summary>Node middle mouse button up event.</summary>
				compositions::GuiNodeMouseEvent		NodeMiddleButtonUp;
				/// <summary>Node middle mouse button double click event.</summary>
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDoubleClick;
				/// <summary>Node right mouse button down event.</summary>
				compositions::GuiNodeMouseEvent		NodeRightButtonDown;
				/// <summary>Node right mouse button up event.</summary>
				compositions::GuiNodeMouseEvent		NodeRightButtonUp;
				/// <summary>Node right mouse button double click event.</summary>
				compositions::GuiNodeMouseEvent		NodeRightButtonDoubleClick;
				/// <summary>Node mouse move event.</summary>
				compositions::GuiNodeMouseEvent		NodeMouseMove;
				/// <summary>Node mouse enter event.</summary>
				compositions::GuiNodeNotifyEvent	NodeMouseEnter;
				/// <summary>Node mouse leave event.</summary>
				compositions::GuiNodeNotifyEvent	NodeMouseLeave;
				/// <summary>Node expanded event.</summary>
				compositions::GuiNodeNotifyEvent	NodeExpanded;
				/// <summary>Node collapsed event.</summary>
				compositions::GuiNodeNotifyEvent	NodeCollapsed;

				/// <summary>Get the <see cref="tree::INodeItemView"/> from the item provider.</summary>
				/// <returns>The <see cref="tree::INodeItemView"/> from the item provider.</returns>
				tree::INodeItemView*				GetNodeItemView();
				/// <summary>Get the binded node root provider.</summary>
				/// <returns>The binded node root provider.</returns>
				tree::INodeRootProvider*			GetNodeRootProvider();
			};

/***********************************************************************
TreeViewItemRootProvider
***********************************************************************/

			namespace tree
			{
				/// <summary>The required <see cref="INodeRootProvider"/> view for [T:vl.presentation.controls.GuiVirtualTreeView].</summary>
				class ITreeViewItemView : public virtual IDescriptable, public Description<ITreeViewItemView>
				{
				public:
					/// <summary>The identifier of this view.</summary>
					static const wchar_t* const		Identifier;

					/// <summary>Get the image of a node.</summary>
					/// <returns>Get the image of a node.</returns>
					/// <param name="node">The node.</param>
					virtual Ptr<GuiImageData>		GetNodeImage(INodeProvider* node)=0;
				};

				/// <summary>A tree view item. This data structure is used in [T:vl.presentation.controls.tree.TreeViewItemRootProvider].</summary>
				class TreeViewItem : public Object, public Description<TreeViewItem>
				{
				public:
					/// <summary>The image of this item.</summary>
					Ptr<GuiImageData>				image;
					/// <summary>The text of this item.</summary>
					WString							text;
					/// <summary>Tag object.</summary>
					description::Value				tag;

					/// <summary>Create a tree view item.</summary>
					TreeViewItem();
					/// <summary>Create a tree view item with specified image and text.</summary>
					/// <param name="_image">The specified image.</param>
					/// <param name="_text">The specified text.</param>
					TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text);
				};

				/// <summary>The default implementation of <see cref="INodeRootProvider"/> for [T:vl.presentation.controls.GuiVirtualTreeView].</summary>
				class TreeViewItemRootProvider
					: public MemoryNodeRootProvider
					, public virtual ITreeViewItemView
					, public Description<TreeViewItemRootProvider>
				{
				protected:

					Ptr<GuiImageData>				GetNodeImage(INodeProvider* node)override;
					WString							GetTextValue(INodeProvider* node)override;
					description::Value				GetBindingValue(INodeProvider* node)override;
				public:
					/// <summary>Create a item root provider.</summary>
					TreeViewItemRootProvider();
					~TreeViewItemRootProvider();

					IDescriptable*					RequestView(const WString& identifier)override;

					/// <summary>Get the <see cref="TreeViewItem"/> object from a node.</summary>
					/// <returns>The <see cref="TreeViewItem"/> object.</returns>
					/// <param name="node">The node to get the tree view item.</param>
					Ptr<TreeViewItem>				GetTreeViewData(INodeProvider* node);
					/// <summary>Set the <see cref="TreeViewItem"/> object to a node.</summary>
					/// <param name="node">The node.</param>
					/// <param name="value">The <see cref="TreeViewItem"/> object.</param>
					void							SetTreeViewData(INodeProvider* node, Ptr<TreeViewItem> value);
					/// <summary>Notify the tree view control that the node is changed. This is required when content in a <see cref="TreeViewItem"/> is modified, but both <see cref="SetTreeViewData"/> or [M:vl.presentation.controls.tree.MemoryNodeProvider.SetData] are not called.</summary>
					/// <param name="node">The node.</param>
					void							UpdateTreeViewData(INodeProvider* node);
				};
			}

/***********************************************************************
GuiVirtualTreeView
***********************************************************************/
			
			/// <summary>Tree view control in virtual mode.</summary>
			class GuiVirtualTreeView : public GuiVirtualTreeListControl, public Description<GuiVirtualTreeView>
			{
			protected:
				tree::ITreeViewItemView*								treeViewItemView = nullptr;

				templates::GuiTreeItemTemplate*							GetStyleFromNode(tree::INodeProvider* node);
				void													SetStyleExpanding(tree::INodeProvider* node, bool expanding);
				void													SetStyleExpandable(tree::INodeProvider* node, bool expandable);
				void													OnAfterItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
				void													OnItemExpanded(tree::INodeProvider* node)override;
				void													OnItemCollapsed(tree::INodeProvider* node)override;
				void													OnStyleInstalled(vint itemIndex, ItemStyle* style, bool refreshPropertiesOnly)override;
			public:
				/// <summary>Create a tree view control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_nodeRootProvider">The node root provider for this control.</param>
				GuiVirtualTreeView(theme::ThemeName themeName, Ptr<tree::INodeRootProvider> _nodeRootProvider);
				~GuiVirtualTreeView();
			};

/***********************************************************************
GuiTreeView
***********************************************************************/
			
			/// <summary>Tree view control.</summary>
			class GuiTreeView : public GuiVirtualTreeView, public Description<GuiTreeView>
			{
			protected:
				Ptr<tree::TreeViewItemRootProvider>						nodes;
			public:
				/// <summary>Create a tree view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiTreeView(theme::ThemeName themeName);
				~GuiTreeView();

				/// <summary>Get the <see cref="tree::TreeViewItemRootProvider"/> as a node root providerl.</summary>
				/// <returns>The <see cref="tree::TreeViewItemRootProvider"/> as a node root provider.</returns>
				Ptr<tree::TreeViewItemRootProvider>						Nodes();

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				Ptr<tree::TreeViewItem>									GetSelectedItem();
			};

/***********************************************************************
DefaultTreeItemTemplate
***********************************************************************/

			namespace tree
			{
				class DefaultTreeItemTemplate : public list::PredefinedListItemTemplate<templates::GuiTreeItemTemplate>
				{
				protected:
					GuiSelectableButton*					expandingButton = nullptr;
					compositions::GuiTableComposition*		table = nullptr;
					elements::GuiImageFrameElement*			imageElement = nullptr;
					elements::GuiSolidLabelElement*			textElement = nullptr;

					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnExpandingChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnExpandableChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnLevelChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnImageChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void									OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void									OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DefaultTreeItemTemplate();
					~DefaultTreeItemTemplate();
				};
			}
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::tree::MemoryNodeProvider>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUICOMMONTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICOMMONTEMPLATES
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICOMMONTEMPLATES


namespace vl
{
	namespace presentation
	{
		namespace templates
		{

/***********************************************************************
GuiCommonDatePickerLook
***********************************************************************/

			class GuiCommonDatePickerLook : public GuiTemplate, public Description<GuiCommonDatePickerLook>
			{
			protected:
				static const vint									DaysOfWeek = 7;
				static const vint									DayRows = 6;
				static const vint									DayRowStart = 2;
				static const vint									YearFirst = 1900;
				static const vint									YearLast = 2099;

				Color												backgroundColor;
				Color												primaryTextColor;
				Color												secondaryTextColor;
				DateTime											currentDate;
				Locale												dateLocale;
				FontProperties										font;

				TemplateProperty<GuiSelectableButtonTemplate>		dateButtonTemplate;
				TemplateProperty<GuiTextListTemplate>				dateTextListTemplate;
				TemplateProperty<GuiComboBoxTemplate>				dateComboBoxTemplate;

				controls::IDatePickerCommandExecutor*				commands = nullptr;
				bool												preventComboEvent = false;
				bool												preventButtonEvent = false;

				controls::GuiComboBoxListControl*					comboYear;
				controls::GuiTextList*								listYears;
				controls::GuiComboBoxListControl*					comboMonth;
				controls::GuiTextList*								listMonths;
				collections::Array<elements::GuiSolidLabelElement*>	labelDaysOfWeek;
				collections::Array<controls::GuiSelectableButton*>	buttonDays;
				collections::Array<elements::GuiSolidLabelElement*>	labelDays;
				collections::Array<DateTime>						dateDays;

				void												SetDay(const DateTime& day, vint& index, vint monthOffset);
				void												DisplayMonth(vint year, vint month);
				void												SelectDay(vint day);

				void												comboYearMonth_SelectedIndexChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												buttonDay_SelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

			public:
				GuiCommonDatePickerLook(Color _backgroundColor, Color _primaryTextColor, Color _secondaryTextColor);
				~GuiCommonDatePickerLook();

				compositions::GuiNotifyEvent						DateChanged;

				controls::IDatePickerCommandExecutor*				GetCommands();
				void												SetCommands(controls::IDatePickerCommandExecutor* value);
				TemplateProperty<GuiSelectableButtonTemplate>		GetDateButtonTemplate();
				void												SetDateButtonTemplate(const TemplateProperty<GuiSelectableButtonTemplate>& value);
				TemplateProperty<GuiTextListTemplate>				GetDateTextListTemplate();
				void												SetDateTextListTemplate(const TemplateProperty<GuiTextListTemplate>& value);
				TemplateProperty<GuiComboBoxTemplate>				GetDateComboBoxTemplate();
				void												SetDateComboBoxTemplate(const TemplateProperty<GuiComboBoxTemplate>& value);

				const Locale&										GetDateLocale();
				void												SetDateLocale(const Locale& value);
				const DateTime&										GetDate();
				void												SetDate(const DateTime& value);
				const FontProperties&								GetFont();
				void												SetFont(const FontProperties& value);
			};

/***********************************************************************
GuiCommonScrollViewLook
***********************************************************************/

			class GuiCommonScrollViewLook : public GuiTemplate, public Description<GuiCommonScrollViewLook>
			{
			protected:
				controls::GuiScroll*								horizontalScroll = nullptr;
				controls::GuiScroll*								verticalScroll = nullptr;
				compositions::GuiTableComposition*					tableComposition = nullptr;
				compositions::GuiCellComposition*					containerCellComposition = nullptr;
				compositions::GuiBoundsComposition*					containerComposition = nullptr;

				vint												defaultScrollSize = 12;
				TemplateProperty<GuiScrollTemplate>					hScrollTemplate;
				TemplateProperty<GuiScrollTemplate>					vScrollTemplate;

				void												UpdateTable();
				void												hScroll_OnVisibleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												vScroll_OnVisibleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiCommonScrollViewLook(vint _defaultScrollSize);
				~GuiCommonScrollViewLook();

				controls::GuiScroll*								GetHScroll();
				controls::GuiScroll*								GetVScroll();
				compositions::GuiGraphicsComposition*				GetContainerComposition();

				TemplateProperty<GuiScrollTemplate>					GetHScrollTemplate();
				void												SetHScrollTemplate(const TemplateProperty<GuiScrollTemplate>& value);
				TemplateProperty<GuiScrollTemplate>					GetVScrollTemplate();
				void												SetVScrollTemplate(const TemplateProperty<GuiScrollTemplate>& value);
			};

/***********************************************************************
GuiCommonScrollBehavior
***********************************************************************/

			class GuiCommonScrollBehavior : public controls::GuiComponent, public Description<GuiCommonScrollBehavior>
			{
			protected:
				bool												dragging = false;
				Point												location = { 0,0 };
				GuiScrollTemplate*									scrollTemplate = nullptr;

				void												SetScroll(vint totalPixels, vint newOffset);
				void												AttachHandle(compositions::GuiGraphicsComposition* handle);
			public:
				GuiCommonScrollBehavior();
				~GuiCommonScrollBehavior();

				void												AttachScrollTemplate(GuiScrollTemplate* value);
				void												AttachDecreaseButton(controls::GuiButton* button);
				void												AttachIncreaseButton(controls::GuiButton* button);
				void												AttachHorizontalScrollHandle(compositions::GuiPartialViewComposition* partialView);
				void												AttachVerticalScrollHandle(compositions::GuiPartialViewComposition* partialView);
				void												AttachHorizontalTrackerHandle(compositions::GuiPartialViewComposition* partialView);
				void												AttachVerticalTrackerHandle(compositions::GuiPartialViewComposition* partialView);

				vint												GetHorizontalTrackerHandlerPosition(compositions::GuiBoundsComposition* handle, vint totalSize, vint pageSize, vint position);
				vint												GetVerticalTrackerHandlerPosition(compositions::GuiBoundsComposition* handle, vint totalSize, vint pageSize, vint position);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEMPLATES\GUITHEMESTYLEFACTORY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY
#define VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY


namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			class Theme;

			/// <summary>Partial control template collections. [F:vl.presentation.theme.GetCurrentTheme] will returns an object, which walks through multiple registered [T:vl.presentation.theme.ThemeTemplates] to create a correct template object for a control.</summary>
			class ThemeTemplates : public controls::GuiInstanceRootObject, public AggregatableDescription<ThemeTemplates>
			{
				friend class Theme;
			protected:
				ThemeTemplates*					previous = nullptr;
				ThemeTemplates*					next = nullptr;

				controls::GuiControlHost*		GetControlHostForInstance()override;
			public:
				~ThemeTemplates();

				WString							Name;
				Nullable<bool>					PreferCustomFrameWindow;

#define GUI_DEFINE_ITEM_PROPERTY(TEMPLATE, CONTROL) TemplateProperty<templates::Gui##TEMPLATE> CONTROL;
				GUI_CONTROL_TEMPLATE_TYPES(GUI_DEFINE_ITEM_PROPERTY)
#undef GUI_DEFINE_ITEM_PROPERTY
			};

			/// <summary>Register a control template collection object.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="theme">The control template collection object.</param>
			extern bool							RegisterTheme(Ptr<ThemeTemplates> theme);
			/// <summary>Unregister a control template collection object.</summary>
			/// <returns>The registered object. Returns null if it does not exist.</returns>
			/// <param name="name">The name of the theme.</param>
			extern Ptr<ThemeTemplates>			UnregisterTheme(const WString& name);
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTGENERALOPERATIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTGENERALOPERATIONS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTGENERALOPERATIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Operations
***********************************************************************/
			
			/// <summary>An text edit callback for text box controls.</summary>
			class ICommonTextEditCallback : public virtual IDescriptable, public Description<ICommonTextEditCallback>
			{
			public:
				/// <summary>Callback data for text editing preview.</summary>
				struct TextEditPreviewStruct
				{
					/// <summary>The start position of the selection before replacing. This field can be modified.</summary>
					TextPos								originalStart;
					/// <summary>The end position of the selection before replacing. This field can be modified.</summary>
					TextPos								originalEnd;
					/// <summary>The text of the selection before replacing.</summary>
					WString								originalText;
					/// <summary>The text of the selection after replacing. This field can be modified.</summary>
					WString								inputText;
					/// <summary>The base edit version.</summary>
					vuint								editVersion = 0;
					/// <summary>True if this modification is raised by the keyboard.</summary>
					bool								keyInput = false;
				};

				/// <summary>Callback data for text editing.</summary>
				struct TextEditNotifyStruct
				{
					/// <summary>The start position of the selection before replacing.</summary>
					TextPos								originalStart;
					/// <summary>The end position of the selection before replacing.</summary>
					TextPos								originalEnd;
					/// <summary>The text of the selection before replacing.</summary>
					WString								originalText;
					/// <summary>The start position of the selection after replacing.</summary>
					TextPos								inputStart;
					/// <summary>The end position of the selection after replacing.</summary>
					TextPos								inputEnd;
					/// <summary>The text of the selection after replacing.</summary>
					WString								inputText;
					/// <summary>The created edit version.</summary>
					vuint								editVersion = 0;
					/// <summary>True if this modification is raised by the keyboard.</summary>
					bool								keyInput = false;
				};
				
				/// <summary>Callback data for text caret changing.</summary>
				struct TextCaretChangedStruct
				{
					/// <summary>The start position of the selection before caret changing.</summary>
					TextPos								oldBegin;
					/// <summary>The end position of the selection before caret changing.</summary>
					TextPos								oldEnd;
					/// <summary>The start position of the selection after caret changing.</summary>
					TextPos								newBegin;
					/// <summary>The end position of the selection after caret changing.</summary>
					TextPos								newEnd;
					/// <summary>The current edit version.</summary>
					vuint								editVersion = 0;
				};

				/// <summary>Called when the callback is attached to a text box control.</summary>
				/// <param name="element">The element that used in the text box control.</param>
				/// <param name="elementModifyLock">The lock that pretect the element.</param>
				/// <param name="ownerComposition">The owner composition of this element.</param>
				/// <param name="editVersion">The current edit version.</param>
				virtual void							Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock, compositions::GuiGraphicsComposition* ownerComposition, vuint editVersion)=0;
				/// <summary>Called when the callback is detached from a text box control.</summary>
				virtual void							Detach()=0;
				/// <summary>Called before the text is edited.</summary>
				/// <param name="arguments">The data for this callback.</param>
				virtual void							TextEditPreview(TextEditPreviewStruct& arguments)=0;
				/// <summary>Called after the text is edited and before the caret is changed.</summary>
				/// <param name="arguments">The data for this callback.</param>
				virtual void							TextEditNotify(const TextEditNotifyStruct& arguments)=0;
				/// <summary>Called after the caret is changed.</summary>
				/// <param name="arguments">The data for this callback.</param>
				virtual void							TextCaretChanged(const TextCaretChangedStruct& arguments)=0;
				/// <summary>Called after the text is edited and after the caret is changed.</summary>
				/// <param name="editVersion">The current edit version.</param>
				virtual void							TextEditFinished(vuint editVersion)=0;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTAUTOCOMPLETE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTAUTOCOMPLETE
#define VCZH_PRESENTATION_CONTROLS_GUITEXTAUTOCOMPLETE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiTextBoxAutoCompleteBase
***********************************************************************/
			
			/// <summary>The base class of text box auto complete controller.</summary>
			class GuiTextBoxAutoCompleteBase : public Object, public virtual ICommonTextEditCallback
			{
			public:
				/// <summary>Represents an auto complete candidate item.</summary>
				struct AutoCompleteItem
				{
					/// <summary>Tag object for any purpose, e.g., data binding.</summary>
					description::Value								tag;
					/// <summary>Display text for the item.</summary>
					WString											text;
				};

				/// <summary>Auto complete control provider.</summary>
				class IAutoCompleteControlProvider : public virtual Interface
				{
				public:
					/// <summary>Get the auto complete control that will be installed in a popup to show candidate items.</summary>
					/// <returns>The auto complete control.</returns>
					virtual GuiControl*								GetAutoCompleteControl() = 0;

					/// <summary>Get the list control storing candidate items.</summary>
					/// <returns>The list control. It should be inside the auto complete control, or the auto complete control itself.</returns>
					virtual GuiSelectableListControl*				GetListControl() = 0;

					/// <summary>Store candidate items in the list control.</summary>
					/// <param name="items">Candidate items.</param>
					virtual void									SetSortedContent(const collections::List<AutoCompleteItem>& items) = 0;

					/// <summary>Get the numbers of all stored candidate items.</summary>
					/// <returns>The number of all stored candidate items.</returns>
					virtual vint									GetItemCount() = 0;

					/// <summary>Get the text of a specified item.</summary>
					/// <param name="index">The index of the item.</param>
					/// <returns>The text of the item.</returns>
					virtual WString									GetItemText(vint index) = 0;
				};

				class TextListControlProvider : public Object, public virtual IAutoCompleteControlProvider
				{
				protected:
					GuiTextList*									autoCompleteList;

				public:
					TextListControlProvider(TemplateProperty<templates::GuiTextListTemplate> controlTemplate = {});
					~TextListControlProvider();

					GuiControl*										GetAutoCompleteControl()override;
					GuiSelectableListControl*						GetListControl()override;
					void											SetSortedContent(const collections::List<AutoCompleteItem>& items)override;
					vint											GetItemCount()override;
					WString											GetItemText(vint index)override;
				};

			protected:
				elements::GuiColorizedTextElement*					element;
				SpinLock*											elementModifyLock;
				compositions::GuiGraphicsComposition*				ownerComposition;
				GuiPopup*											autoCompletePopup;
				Ptr<IAutoCompleteControlProvider>					autoCompleteControlProvider;
				TextPos												autoCompleteStartPosition;

				bool												IsPrefix(const WString& prefix, const WString& candidate);
			public:
				/// <summary>Create an auto complete.</summary>
				/// <param name="_autoCompleteControlProvider">A auto complete control provider. Set to null to use a default one.</param>
				GuiTextBoxAutoCompleteBase(Ptr<IAutoCompleteControlProvider> _autoCompleteControlProvider = nullptr);
				~GuiTextBoxAutoCompleteBase();

				void												Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void												Detach()override;
				void												TextEditPreview(TextEditPreviewStruct& arguments)override;
				void												TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void												TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void												TextEditFinished(vuint editVersion)override;

				/// <summary>Get the list state.</summary>
				/// <returns>Returns true if the list is visible.</returns>
				bool												IsListOpening();
				/// <summary>Notify the list to be visible.</summary>
				/// <param name="startPosition">The text position to show the list.</param>
				void												OpenList(TextPos startPosition);
				/// <summary>Notify the list to be invisible.</summary>
				void												CloseList();
				/// <summary>Set the content of the list.</summary>
				/// <param name="items">The content of the list.</param>
				void												SetListContent(const collections::List<AutoCompleteItem>& items);
				/// <summary>Get the last start position when the list is opened.</summary>
				/// <returns>The start position.</returns>
				TextPos												GetListStartPosition();
				/// <summary>Select the previous item.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												SelectPreviousListItem();
				/// <summary>Select the next item.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												SelectNextListItem();
				/// <summary>Apply the selected item into the text box.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												ApplySelectedListItem();
				/// <summary>Get the selected item.</summary>
				/// <returns>The text of the selected item. Returns empty if there is no selected item.</returns>
				WString												GetSelectedListItem();
				/// <summary>Highlight a candidate item in the list.</summary>
				/// <param name="editingText">The text to match an item.</param>
				void												HighlightList(const WString& editingText);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTCOLORIZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiTextBoxColorizerBase
***********************************************************************/
			
			/// <summary>The base class of text box colorizer.</summary>
			class GuiTextBoxColorizerBase : public Object, public virtual ICommonTextEditCallback
			{
			public:
				typedef collections::Array<elements::text::ColorEntry>			ColorArray;
			protected:
				elements::GuiColorizedTextElement*			element;
				SpinLock*									elementModifyLock;
				volatile vint								colorizedLineCount;
				volatile bool								isColorizerRunning;
				volatile bool								isFinalizing;
				SpinLock									colorizerRunningEvent;

				static void									ColorizerThreadProc(void* argument);

				void										StartColorizer();
				void										StopColorizer(bool forever);
				void										StopColorizerForever();
			public:
				/// <summary>Create a colorrizer.</summary>
				GuiTextBoxColorizerBase();
				~GuiTextBoxColorizerBase();

				void										Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void										Detach()override;
				void										TextEditPreview(TextEditPreviewStruct& arguments)override;
				void										TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void										TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void										TextEditFinished(vuint editVersion)override;
				void										RestartColorizer();

				/// <summary>Get the lexical analyzer start state for the first line.</summary>
				/// <returns>The lexical analyzer start state for the first line.</returns>
				virtual vint								GetLexerStartState()=0;
				/// <summary>Get the context sensitive start state for the first line.</summary>
				/// <returns>The context sensitive start state for the first line.</returns>
				virtual vint								GetContextStartState()=0;
				/// <summary>Colorizer one line with a start state.</summary>
				/// <param name="lineIndex">Line index.</param>
				/// <param name="text">Text buffer.</param>
				/// <param name="colors">Color index buffer. The index should be in [0 .. [M:vl.presentation.controls.GuiTextBoxColorizerBase.GetColors]()-1].</param>
				/// <param name="length">The length of the buffer.</param>
				/// <param name="lexerState">The lexical analyzer state for this line. After executing this function, the new value of this argument indicates the new state.</param>
				/// <param name="contextState">The context sensitive state for this line. After executing this function, the new value of this argument indicates the new state.</param>
				virtual void								ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, vuint32_t* colors, vint length, vint& lexerState, vint& contextState)=0;
				/// <summary>Get the supported colors ordered by their indices.</summary>
				/// <returns>The supported colors ordered by their indices.</returns>
				virtual const ColorArray&					GetColors()=0;
			};

/***********************************************************************
GuiTextBoxRegexColorizer
***********************************************************************/

			/// <summary>Regex based colorizer.</summary>
			class GuiTextBoxRegexColorizer : public GuiTextBoxColorizerBase
			{
			protected:
				Ptr<regex::RegexLexer>										lexer;
				Ptr<regex::RegexLexerColorizer>								colorizer;
				void*														colorizerArgument[1] { nullptr };
				ColorArray													colors;

				elements::text::ColorEntry									defaultColor;
				collections::List<WString>									tokenRegexes;
				collections::List<elements::text::ColorEntry>				tokenColors;
				collections::List<elements::text::ColorEntry>				extraTokenColors;

				static void													ColorizerProc(void* argument, vint start, vint length, vint token);
			public:
				/// <summary>Create the colorizer.</summary>
				GuiTextBoxRegexColorizer();
				~GuiTextBoxRegexColorizer();

				/// <summary>Get the default color.</summary>
				/// <returns>The default color.</returns>
				elements::text::ColorEntry									GetDefaultColor();
				/// <summary>Get all regular expressions for tokens.</summary>
				/// <returns>All regular expressions for tokens.</returns>
				collections::List<WString>&									GetTokenRegexes();
				/// <summary>Get all colors for tokens.</summary>
				/// <returns>All colors for tokens.</returns>
				collections::List<elements::text::ColorEntry>&				GetTokenColors();
				/// <summary>Get all colors for extra tokens.</summary>
				/// <returns>All colors for extra tokens.</returns>
				collections::List<elements::text::ColorEntry>&				GetExtraTokenColors();
				/// <summary>Get the first token index for the first extra token.</summary>
				/// <returns>The first token index for the first extra token. Returns -1 if this operation failed.</returns>
				vint														GetExtraTokenIndexStart();
				
				/// <summary>Set the default color. Call [M:vl.presentation.controls.GuiTextBoxRegexColorizer.Setup] after finishing all configuration.</summary>
				/// <returns>Returns the token index of this token. Returns -1 if this operation failed.</returns>
				/// <param name="value">The default color.</param>
				bool														SetDefaultColor(elements::text::ColorEntry value);
				/// <summary>Add a token type. Call [M:vl.presentation.controls.GuiTextBoxRegexColorizer.Setup] after finishing all configuration.</summary>
				/// <returns>Returns the token index of this token. Returns -1 if this operation failed.</returns>
				/// <param name="regex">The regular expression for this token type.</param>
				/// <param name="color">The color for this token type.</param>
				vint														AddToken(const WString& regex, elements::text::ColorEntry color);
				/// <summary>Add an extra  token type. Call [M:vl.presentation.controls.GuiTextBoxRegexColorizer.Setup] after finishing all configuration.</summary>
				/// <returns>Returns the extra token index of this token. The token index for this token is regex-token-count + extra-token-index Returns -1 if this operation failed.</returns>
				/// <param name="color">The color for this token type.</param>
				vint														AddExtraToken(elements::text::ColorEntry color);
				/// <summary>Clear all token color settings.</summary>
				void														ClearTokens();
				/// <summary>Setup the colorizer. After that, the colorizer cannot be changed.</summary>
				void														Setup();
				/// <summary>Callback function to set context sensitive state and change token accordingly.</summary>
				/// <param name="lineIndex">Line index.</param>
				/// <param name="text">Text buffer.</param>
				/// <param name="start">The start position of the token.</param>
				/// <param name="length">The length of the token.</param>
				/// <param name="token">The token type. After executing this function, the new value of this argument indicates the new token type.</param>
				/// <param name="contextState">The context sensitive state. After executing this function, the new value of this argument indicates the new state.</param>
				virtual void												ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState);

				vint														GetLexerStartState()override;
				vint														GetContextStartState()override;
				void														ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, vuint32_t* colors, vint length, vint& lexerState, vint& contextState)override;
				const ColorArray&											GetColors()override;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTUNDOREDO.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO
#define VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiTextBoxCommonInterface;

/***********************************************************************
Undo Redo
***********************************************************************/

			class GuiGeneralUndoRedoProcessor : public Object
			{
			protected:
				class IEditStep : public Interface
				{
				public:
					virtual void							Undo()=0;
					virtual void							Redo()=0;
				};
				friend class collections::ArrayBase<Ptr<IEditStep>>;

			protected:
				collections::List<Ptr<IEditStep>>			steps;
				vint										firstFutureStep;
				vint										savedStep;
				bool										performingUndoRedo;

				void										PushStep(Ptr<IEditStep> step);
			public:
				GuiGeneralUndoRedoProcessor();
				~GuiGeneralUndoRedoProcessor();

				Event<void()>								UndoRedoChanged;
				Event<void()>								ModifiedChanged;

				bool										CanUndo();
				bool										CanRedo();
				void										ClearUndoRedo();
				bool										GetModified();
				void										NotifyModificationSaved();
				bool										Undo();
				bool										Redo();
			};

/***********************************************************************
Undo Redo (Text)
***********************************************************************/

			class GuiTextBoxUndoRedoProcessor : public GuiGeneralUndoRedoProcessor, public ICommonTextEditCallback
			{
			protected:
				class EditStep : public Object, public IEditStep
				{
				public:
					GuiTextBoxUndoRedoProcessor*			processor;
					TextEditNotifyStruct					arguments;
					
					void									Undo();
					void									Redo();
				};

				compositions::GuiGraphicsComposition*		ownerComposition;
			public:
				GuiTextBoxUndoRedoProcessor();
				~GuiTextBoxUndoRedoProcessor();

				void										Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void										Detach()override;
				void										TextEditPreview(TextEditPreviewStruct& arguments)override;
				void										TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void										TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void										TextEditFinished(vuint editVersion)override;
			};

/***********************************************************************
Undo Redo (Document)
***********************************************************************/

			class GuiDocumentUndoRedoProcessor : public GuiGeneralUndoRedoProcessor
			{
			public:
				struct ReplaceModelStruct
				{
					TextPos									originalStart;
					TextPos									originalEnd;
					Ptr<DocumentModel>						originalModel;
					TextPos									inputStart;
					TextPos									inputEnd;
					Ptr<DocumentModel>						inputModel;

					ReplaceModelStruct()
					{
					}
				};

				struct RenameStyleStruct
				{
					WString									oldStyleName;
					WString									newStyleName;

					RenameStyleStruct()
					{
					}
				};

				struct SetAlignmentStruct
				{
					vint									start;
					vint									end;
					collections::Array<Nullable<Alignment>>	originalAlignments;
					collections::Array<Nullable<Alignment>>	inputAlignments;
				};

			protected:
				elements::GuiDocumentElement*				element;
				compositions::GuiGraphicsComposition*		ownerComposition;
				
				class ReplaceModelStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					ReplaceModelStruct						arguments;
					
					void									Undo();
					void									Redo();
				};

				class RenameStyleStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					RenameStyleStruct						arguments;
					
					void									Undo();
					void									Redo();
				};

				class SetAlignmentStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					Ptr<SetAlignmentStruct>					arguments;
					
					void									Undo();
					void									Redo();
				};
			public:

				GuiDocumentUndoRedoProcessor();
				~GuiDocumentUndoRedoProcessor();

				void										Setup(elements::GuiDocumentElement* _element, compositions::GuiGraphicsComposition* _ownerComposition);
				void										OnReplaceModel(const ReplaceModelStruct& arguments);
				void										OnRenameStyle(const RenameStyleStruct& arguments);
				void										OnSetAlignment(Ptr<SetAlignmentStruct> arguments);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\GUIDOCUMENTVIEWER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDOCUMENTVIEWER
#define VCZH_PRESENTATION_CONTROLS_GUIDOCUMENTVIEWER


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiShortcutKeyManager;
		}

		namespace controls
		{

/***********************************************************************
GuiDocumentCommonInterface
***********************************************************************/

			class GuiDocumentCommonInterface;

			/// <summary>Embedded object in a document.</summary>
			class GuiDocumentItem : public Object, public Description<GuiDocumentItem>
			{
				friend class GuiDocumentCommonInterface;
			protected:
				bool										visible = false;
				WString										name;
				compositions::GuiBoundsComposition*			container;
				bool										owned = false;
			public:
				GuiDocumentItem(const WString& _name);
				~GuiDocumentItem();
				
				/// <summary>Get the container for all embedded controls and compositions in this item.</summary>
				/// <returns>The container.</returns>
				compositions::GuiGraphicsComposition*		GetContainer();

				/// <summary>Get the name of the document item.</summary>
				/// <returns>The name.</returns>
				WString										GetName();
			};
			
			/// <summary>Document displayer control common interface for displaying <see cref="DocumentModel"/>.</summary>
			class GuiDocumentCommonInterface abstract
				: protected virtual elements::GuiDocumentElement::ICallback
				, public Description<GuiDocumentCommonInterface>
			{
				typedef collections::Dictionary<WString, Ptr<GuiDocumentItem>>		DocumentItemMap;
			public:
				/// <summary>Represents the edit mode.</summary>
				enum EditMode
				{
					/// <summary>View the rich text only.</summary>
					ViewOnly,
					/// <summary>The rich text is selectable.</summary>
					Selectable,
					/// <summary>The rich text is editable.</summary>
					Editable,
				};
			protected:
				Ptr<DocumentModel>							baselineDocument;
				DocumentItemMap								documentItems;
				GuiControl*									documentControl = nullptr;
				elements::GuiDocumentElement*				documentElement = nullptr;
				compositions::GuiBoundsComposition*			documentComposition = nullptr;

				compositions::GuiGraphicsComposition*		documentMouseArea = nullptr;
				Ptr<compositions::IGuiGraphicsEventHandler>	onMouseMoveHandler;
				Ptr<compositions::IGuiGraphicsEventHandler>	onMouseDownHandler;
				Ptr<compositions::IGuiGraphicsEventHandler>	onMouseUpHandler;
				Ptr<compositions::IGuiGraphicsEventHandler>	onMouseLeaveHandler;

				Ptr<DocumentHyperlinkRun::Package>			activeHyperlinks;
				bool										dragging = false;
				EditMode									editMode = EditMode::ViewOnly;

				Ptr<GuiDocumentUndoRedoProcessor>			undoRedoProcessor;
				Ptr<compositions::GuiShortcutKeyManager>	internalShortcutKeyManager;

			protected:
				void										InvokeUndoRedoChanged();
				void										InvokeModifiedChanged();
				void										UpdateCaretPoint();
				void										EnsureDocumentRectVisible(Rect bounds);
				void										Move(TextPos caret, bool shift, bool frontSide);
				bool										ProcessKey(VKEY code, bool shift, bool ctrl);
				void										InstallDocumentViewer(
																GuiControl* _sender,
																compositions::GuiGraphicsComposition* _mouseArea,
																compositions::GuiGraphicsComposition* _container,
																compositions::GuiGraphicsComposition* eventComposition,
																compositions::GuiGraphicsComposition* focusableComposition
																);
				void										ReplaceMouseArea(compositions::GuiGraphicsComposition* _mouseArea);

				void										SetActiveHyperlink(Ptr<DocumentHyperlinkRun::Package> package);
				void										ActivateActiveHyperlink(bool activate);
				void										AddShortcutCommand(VKEY key, const Func<void()>& eventHandler);
				void										EditTextInternal(TextPos begin, TextPos end, const Func<void(TextPos, TextPos, vint&, vint&)>& editor);
				void										EditStyleInternal(TextPos begin, TextPos end, const Func<void(TextPos, TextPos)>& editor);
				
				void										MergeBaselineAndDefaultFont(Ptr<DocumentModel> document);
				void										OnFontChanged();
				void										OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void										OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);

				void										UpdateCursor(INativeCursor* cursor);
				Point										GetMouseOffset();
				void										OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				virtual Point								GetDocumentViewPosition();
				virtual void								EnsureRectVisible(Rect bounds);

				//================ callback

				void										OnStartRender()override;
				void										OnFinishRender()override;
				Size										OnRenderEmbeddedObject(const WString& name, const Rect& location)override;
			public:
				GuiDocumentCommonInterface();
				~GuiDocumentCommonInterface();

				/// <summary>Active hyperlink changed event.</summary>
				compositions::GuiNotifyEvent				ActiveHyperlinkChanged;
				/// <summary>Active hyperlink executed event.</summary>
				compositions::GuiNotifyEvent				ActiveHyperlinkExecuted;

				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent				SelectionChanged;
				/// <summary>Undo redo status changed event.</summary>
				compositions::GuiNotifyEvent				UndoRedoChanged;
				/// <summary>Modified status changed event.</summary>
				compositions::GuiNotifyEvent				ModifiedChanged;
				
				/// <summary>Get the document.</summary>
				/// <returns>The document.</returns>
				Ptr<DocumentModel>							GetDocument();
				/// <summary>Set the document. When a document is set to this element, modifying the document without invoking <see cref="NotifyParagraphUpdated"/> will lead to undefined behavior.</summary>
				/// <param name="value">The document.</param>
				void										SetDocument(Ptr<DocumentModel> value);

				//================ document items

				/// <summary>Add a document item. The name of the document item will display in the position of the &lt;object&gt; element with the same name in the document.</summary>
				/// <param name="value">The document item.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										AddDocumentItem(Ptr<GuiDocumentItem> value);

				/// <summary>Remove a document item.</summary>
				/// <param name="value">The document item.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										RemoveDocumentItem(Ptr<GuiDocumentItem> value);

				/// <summary>Get all document items.</summary>
				/// <returns>All document items.</returns>
				const DocumentItemMap&						GetDocumentItems();

				//================ caret operations

				/// <summary>
				/// Get the begin position of the selection area.
				/// </summary>
				/// <returns>The begin position of the selection area.</returns>
				TextPos										GetCaretBegin();
				/// <summary>
				/// Get the end position of the selection area.
				/// </summary>
				/// <returns>The end position of the selection area.</returns>
				TextPos										GetCaretEnd();
				/// <summary>
				/// Set the end position of the selection area.
				/// </summary>
				/// <param name="begin">The begin position of the selection area.</param>
				/// <param name="end">The end position of the selection area.</param>
				void										SetCaret(TextPos begin, TextPos end);
				/// <summary>Calculate a caret using a specified point.</summary>
				/// <returns>The calculated caret.</returns>
				/// <param name="point">The specified point.</param>
				TextPos										CalculateCaretFromPoint(Point point);
				/// <summary>Get the bounds of a caret.</summary>
				/// <returns>The bounds.</returns>
				/// <param name="caret">The caret.</param>
				/// <param name="frontSide">Set to true to get the bounds for the character before it.</param>
				Rect										GetCaretBounds(TextPos caret, bool frontSide);

				//================ editing operations

				/// <summary>Notify that some paragraphs are updated.</summary>
				/// <param name="index">The start paragraph index.</param>
				/// <param name="oldCount">The number of paragraphs to be updated.</param>
				/// <param name="newCount">The number of updated paragraphs.</param>
				/// <param name="updatedText">Set to true to notify that the text is updated.</param>
				void										NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
				/// <summary>Edit run in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="model">The new run.</param>
				/// <param name="copy">Set to true to copy the model before editing. Otherwise, objects inside the model will be used directly</param>
				void										EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> model, bool copy);
				/// <summary>Edit text in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="frontSide">Set to true to use the text style in front of the specified range.</param>
				/// <param name="text">The new text.</param>
				void										EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
				/// <summary>Edit style in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="style">The new style.</param>
				void										EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
				/// <summary>Edit image in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="image">The new image.</param>
				void										EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
				/// <summary>Set hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="reference">The reference of the hyperlink.</param>
				/// <param name="normalStyleName">The normal style name of the hyperlink.</param>
				/// <param name="activeStyleName">The active style name of the hyperlink.</param>
				void										EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=DocumentModel::NormalLinkStyleName, const WString& activeStyleName=DocumentModel::ActiveLinkStyleName);
				/// <summary>Remove hyperlink in a specified range.</summary>
				/// <param name="paragraphIndex">The index of the paragraph to edit.</param>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
				/// <summary>Edit style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="styleName">The new style name.</param>
				void										EditStyleName(TextPos begin, TextPos end, const WString& styleName);
				/// <summary>Remove style name in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										RemoveStyleName(TextPos begin, TextPos end);
				/// <summary>Rename a style.</summary>
				/// <param name="oldStyleName">The name of the style.</param>
				/// <param name="newStyleName">The new name.</param>
				void										RenameStyle(const WString& oldStyleName, const WString& newStyleName);
				/// <summary>Clear all styles in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				void										ClearStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the text style in a specified range.</summary>
				/// <returns>The text style summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Ptr<DocumentStyleProperties>				SummarizeStyle(TextPos begin, TextPos end);
				/// <summary>Summarize the style name in a specified range.</summary>
				/// <returns>The style name summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<WString>							SummarizeStyleName(TextPos begin, TextPos end);
				/// <summary>Set the alignment of paragraphs in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="alignments">The alignment for each paragraph.</param>
				void										SetParagraphAlignments(TextPos begin, TextPos end, const collections::Array<Nullable<Alignment>>& alignments);
				/// <summary>Set the alignment of paragraphs in a specified range.</summary>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				/// <param name="alignment">The alignment for each paragraph.</param>
				void										SetParagraphAlignment(TextPos begin, TextPos end, Nullable<Alignment> alignment);
				/// <summary>Summarize the text alignment in a specified range.</summary>
				/// <returns>The text alignment summary.</returns>
				/// <param name="begin">The begin position of the range.</param>
				/// <param name="end">The end position of the range.</param>
				Nullable<Alignment>							SummarizeParagraphAlignment(TextPos begin, TextPos end);

				//================ editing control

				/// <summary>Get the href attribute of the active hyperlink.</summary>
				/// <returns>The href attribute of the active hyperlink.</returns>
				WString										GetActiveHyperlinkReference();
				/// <summary>Get the edit mode of this control.</summary>
				/// <returns>The edit mode.</returns>
				EditMode									GetEditMode();
				/// <summary>Set the edit mode of this control.</summary>
				/// <param name="value">The edit mode.</param>
				void										SetEditMode(EditMode value);

				//================ selection operations

				/// <summary>Select all text.</summary>
				void										SelectAll();
				/// <summary>Get the selected text.</summary>
				/// <returns>The selected text.</returns>
				WString										GetSelectionText();
				/// <summary>Set the selected text.</summary>
				/// <param name="value">The selected text.</param>
				void										SetSelectionText(const WString& value);
				/// <summary>Get the selected model.</summary>
				/// <returns>The selected model.</returns>
				Ptr<DocumentModel>							GetSelectionModel();
				/// <summary>Set the selected model.</summary>
				/// <param name="value">The selected model.</param>
				void										SetSelectionModel(Ptr<DocumentModel> value);

				//================ clipboard operations

				/// <summary>Test can the selection be cut.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool										CanCut();
				/// <summary>Test can the selection be copied.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool										CanCopy();
				/// <summary>Test can the content in the clipboard be pasted.</summary>
				/// <returns>Returns true if the content in the clipboard can be pasted.</returns>
				bool										CanPaste();
				/// <summary>Cut the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Cut();
				/// <summary>Copy the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Copy();
				/// <summary>Paste the content from the clipboard and replace the selected text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Paste();

				//================ undo redo control

				/// <summary>Test can undo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool										CanUndo();
				/// <summary>Test can redo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool										CanRedo();
				/// <summary>Clear all undo and redo information.</summary>
				void										ClearUndoRedo();
				/// <summary>Test is the text box modified.</summary>
				/// <returns>Returns true if the text box is modified.</returns>
				bool										GetModified();
				/// <summary>Notify the text box that the current status is considered saved.</summary>
				void										NotifyModificationSaved();
				/// <summary>Perform the undo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Undo();
				/// <summary>Perform the redo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool										Redo();
			};

/***********************************************************************
GuiDocumentViewer
***********************************************************************/
			
			/// <summary>Scrollable document viewer for displaying <see cref="DocumentModel"/>.</summary>
			class GuiDocumentViewer : public GuiScrollContainer, public GuiDocumentCommonInterface, public Description<GuiDocumentViewer>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DocumentViewerTemplate, GuiScrollContainer)
			protected:

				void										UpdateDisplayFont()override;
				Point										GetDocumentViewPosition()override;
				void										EnsureRectVisible(Rect bounds)override;
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiDocumentViewer(theme::ThemeName themeName);
				~GuiDocumentViewer();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};

/***********************************************************************
GuiDocumentViewer
***********************************************************************/
			
			/// <summary>Static document viewer for displaying <see cref="DocumentModel"/>.</summary>
			class GuiDocumentLabel : public GuiControl, public GuiDocumentCommonInterface, public Description<GuiDocumentLabel>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DocumentLabelTemplate, GuiControl)
			protected:

				void										UpdateDisplayFont()override;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiDocumentLabel(theme::ThemeName themeName);
				~GuiDocumentLabel();
				
				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\GUITEXTCOMMONINTERFACE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiShortcutKeyManager;
		}

		namespace controls
		{

/***********************************************************************
Common Interface
***********************************************************************/

			/// <summary>Common interface for text box controls.</summary>
			class GuiTextBoxCommonInterface abstract : public Description<GuiTextBoxCommonInterface>
			{
				typedef collections::Array<elements::text::ColorEntry>			ColorArray;
			protected:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual TextPos									GetLeftWord(TextPos pos)=0;
					virtual TextPos									GetRightWord(TextPos pos)=0;
					virtual void									GetWord(TextPos pos, TextPos& begin, TextPos& end)=0;
					virtual vint									GetPageRows()=0;
					virtual bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)=0;
					virtual void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
					virtual void									ScrollToView(Point point)=0;
					virtual vint									GetTextMargin()=0;
				};

				class DefaultCallback : public Object, public ICallback, public Description<DefaultCallback>
				{
				protected:
					elements::GuiColorizedTextElement*				textElement;
					compositions::GuiGraphicsComposition*			textComposition;
					bool											readonly;
				public:
					DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition);
					~DefaultCallback();

					TextPos											GetLeftWord(TextPos pos)override;
					TextPos											GetRightWord(TextPos pos)override;
					void											GetWord(TextPos pos, TextPos& begin, TextPos& end)override;
					vint											GetPageRows()override;
					bool											BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
				};
			private:
				elements::GuiColorizedTextElement*					textElement;
				compositions::GuiGraphicsComposition*				textComposition;
				vuint												editVersion;
				GuiControl*											textControl;
				ICallback*											callback;
				bool												dragging;
				bool												readonly;
				Ptr<GuiTextBoxColorizerBase>						colorizer;
				Ptr<GuiTextBoxAutoCompleteBase>						autoComplete;
				Ptr<GuiTextBoxUndoRedoProcessor>					undoRedoProcessor;

				bool												filledDefaultColors = false;
				ColorArray											defaultColors;

				SpinLock											elementModifyLock;
				collections::List<Ptr<ICommonTextEditCallback>>		textEditCallbacks;
				Ptr<compositions::GuiShortcutKeyManager>			internalShortcutKeyManager;
				bool												preventEnterDueToAutoComplete;

				void												InvokeUndoRedoChanged();
				void												InvokeModifiedChanged();
				void												UpdateCaretPoint();
				void												Move(TextPos pos, bool shift);
				void												Modify(TextPos start, TextPos end, const WString& input, bool asKeyInput);
				bool												ProcessKey(VKEY code, bool shift, bool ctrl);
					
				void												OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void												OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void												OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);

			protected:

				void												Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl, compositions::GuiGraphicsComposition* eventComposition, compositions::GuiGraphicsComposition* focusableComposition);
				ICallback*											GetCallback();
				void												SetCallback(ICallback* value);
				bool												AttachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				bool												DetachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				void												AddShortcutCommand(VKEY key, const Func<void()>& eventHandler);
				elements::GuiColorizedTextElement*					GetTextElement();
				void												UnsafeSetText(const WString& value);

			public:
				GuiTextBoxCommonInterface();
				~GuiTextBoxCommonInterface();

				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent						SelectionChanged;
				/// <summary>Undo redo status changed event.</summary>
				compositions::GuiNotifyEvent						UndoRedoChanged;
				/// <summary>Modified status changed event.</summary>
				compositions::GuiNotifyEvent						ModifiedChanged;

				//================ clipboard operations

				/// <summary>Test can the selection be cut.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool												CanCut();
				/// <summary>Test can the selection be copied.</summary>
				/// <returns>Returns true if the selection can be cut.</returns>
				bool												CanCopy();
				/// <summary>Test can the content in the clipboard be pasted.</summary>
				/// <returns>Returns true if the content in the clipboard can be pasted.</returns>
				bool												CanPaste();
				/// <summary>Cut the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Cut();
				/// <summary>Copy the selection text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Copy();
				/// <summary>Paste the content from the clipboard and replace the selected text.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Paste();

				//================ editing control

				/// <summary>Get the readonly mode.</summary>
				/// <returns>Returns true if the text box is readonly.</returns>
				bool												GetReadonly();
				/// <summary>Set the readonly mode.</summary>
				/// <param name="value">Set to true to make the texg box readonly.</param>
				void												SetReadonly(bool value);

				//================ text operations

				/// <summary>Select all text.</summary>
				void												SelectAll();
				/// <summary>Select (highlight) a part of text.</summary>
				/// <param name="begin">The begin position.</param>
				/// <param name="end">The end position. This is also the caret position.</param>
				void												Select(TextPos begin, TextPos end);
				/// <summary>Get the selected text.</summary>
				/// <returns>The selected text.</returns>
				WString												GetSelectionText();
				/// <summary>Set the selected text.</summary>
				/// <param name="value">The selected text.</param>
				void												SetSelectionText(const WString& value);
				/// <summary>Set the selected text and let to text box treat this changing as input by the keyboard.</summary>
				/// <param name="value">The selected text.</param>
				void												SetSelectionTextAsKeyInput(const WString& value);
				
				/// <summary>Get the text from a specified row number.</summary>
				/// <returns>The text from a specified row number.</returns>
				/// <param name="row">The specified row number.</param>
				WString												GetRowText(vint row);
				/// <summary>Get the number of rows.</summary>
				/// <returns>The number of rows.</returns>
				vint												GetRowCount();
				/// <summary>Get the text from a specified range.</summary>
				/// <returns>The text from a specified range.</returns>
				/// <param name="start">The specified start position.</param>
				/// <param name="end">The specified end position.</param>
				WString												GetFragmentText(TextPos start, TextPos end);

				/// <summary>Get the begin text position of the selection.</summary>
				/// <returns>The begin text position of the selection.</returns>
				TextPos												GetCaretBegin();
				/// <summary>Get the end text position of the selection.</summary>
				/// <returns>The end text position of the selection.</returns>
				TextPos												GetCaretEnd();
				/// <summary>Get the left-top text position of the selection.</summary>
				/// <returns>The left-top text position of the selection.</returns>
				TextPos												GetCaretSmall();
				/// <summary>Get the right-bottom text position of the selection.</summary>
				/// <returns>The right-bottom text position of the selection.</returns>
				TextPos												GetCaretLarge();

				//================ position query

				/// <summary>Get the width of a row.</summary>
				/// <returns>The width of a row in pixel.</returns>
				/// <param name="row">The specified row number</param>
				vint												GetRowWidth(vint row);
				/// <summary>Get the height of a row.</summary>
				/// <returns>The height of a row in pixel.</returns>
				vint												GetRowHeight();
				/// <summary>Get the maximum width of all rows.</summary>
				/// <returns>The maximum width of all rows.</returns>
				vint												GetMaxWidth();
				/// <summary>Get the total height of all rows.</summary>
				/// <returns>The total height of all rows.</returns>
				vint												GetMaxHeight();
				/// <summary>Get the nearest position of a character from a specified display position.</summary>
				/// <returns>Get the nearest position of a character.</returns>
				/// <param name="point">The specified display position.</param>
				TextPos												GetTextPosFromPoint(Point point);
				/// <summary>Get the display position of a character from a specified text position.</summary>
				/// <returns>Get the display position of a character.</returns>
				/// <param name="pos">The specified text position.</param>
				Point												GetPointFromTextPos(TextPos pos);
				/// <summary>Get the display bounds of a character from a specified text position.</summary>
				/// <returns>Get the display bounds of a character.</returns>
				/// <param name="pos">The specified text position.</param>
				Rect												GetRectFromTextPos(TextPos pos);
				/// <summary>Get the nearest text position from a specified display position.</summary>
				/// <returns>Get the nearest text position.</returns>
				/// <param name="point">The specified display position.</param>
				TextPos												GetNearestTextPos(Point point);

				//================ colorizing

				/// <summary>Get the current colorizer.</summary>
				/// <returns>The current colorizer.</returns>
				Ptr<GuiTextBoxColorizerBase>						GetColorizer();
				/// <summary>Set the current colorizer.</summary>
				/// <param name="value">The current colorizer.</param>
				void												SetColorizer(Ptr<GuiTextBoxColorizerBase> value);

				//================ auto complete

				/// <summary>Get the current auto complete controller.</summary>
				/// <returns>The current auto complete controller.</returns>
				Ptr<GuiTextBoxAutoCompleteBase>						GetAutoComplete();
				/// <summary>Set the current auto complete controller.</summary>
				/// <param name="value">The current auto complete controller.</param>
				void												SetAutoComplete(Ptr<GuiTextBoxAutoCompleteBase> value);

				//================ undo redo control

				/// <summary>Get the current edit version. When the control is modified, the edit version increased. Calling <see cref="NotifyModificationSaved"/> will not reset the edit version.</summary>
				/// <returns>The current edit version.</returns>
				vuint												GetEditVersion();
				/// <summary>Test can undo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool												CanUndo();
				/// <summary>Test can redo.</summary>
				/// <returns>Returns true if this action can be performed.</returns>
				bool												CanRedo();
				/// <summary>Clear all undo and redo information.</summary>
				void												ClearUndoRedo();
				/// <summary>Test is the text box modified.</summary>
				/// <returns>Returns true if the text box is modified.</returns>
				bool												GetModified();
				/// <summary>Notify the text box that the current status is considered saved.</summary>
				void												NotifyModificationSaved();
				/// <summary>Perform the undo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Undo();
				/// <summary>Perform the redo action.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												Redo();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\GUITEXTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
MultilineTextBox
***********************************************************************/

			/// <summary>Multiline text box control.</summary>
			class GuiMultilineTextBox : public GuiScrollView, public GuiTextBoxCommonInterface, public Description<GuiMultilineTextBox>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(MultilineTextBoxTemplate, GuiScrollView)
			public:
				static const vint							TextMargin=3;

				class CommandExecutor : public Object, public ITextBoxCommandExecutor
				{
				protected:
					GuiMultilineTextBox*					textBox;

				public:
					CommandExecutor(GuiMultilineTextBox* _textBox);
					~CommandExecutor();

					void									UnsafeSetText(const WString& value)override;
				};

			protected:
				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiMultilineTextBox*					textControl;
				public:
					TextElementOperatorCallback(GuiMultilineTextBox* _textControl);

					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};

			protected:
				Ptr<TextElementOperatorCallback>			callback;
				Ptr<CommandExecutor>						commandExecutor;
				elements::GuiColorizedTextElement*			textElement = nullptr;
				compositions::GuiBoundsComposition*			textComposition = nullptr;

				void										UpdateVisuallyEnabled()override;
				void										UpdateDisplayFont()override;
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				Size										QueryFullSize()override;
				void										UpdateView(Rect viewBounds)override;
				void										CalculateViewAndSetScroll();
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiMultilineTextBox(theme::ThemeName themeName);
				~GuiMultilineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};

/***********************************************************************
SinglelineTextBox
***********************************************************************/
			
			/// <summary>Single text box control.</summary>
			class GuiSinglelineTextBox : public GuiControl, public GuiTextBoxCommonInterface, public Description<GuiSinglelineTextBox>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(SinglelineTextBoxTemplate, GuiControl)
			public:
				static const vint							TextMargin=2;
				
			protected:
				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				public:
					TextElementOperatorCallback(GuiSinglelineTextBox* _textControl);

					bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};

			protected:
				Ptr<TextElementOperatorCallback>			callback;
				elements::GuiColorizedTextElement*			textElement = nullptr;
				compositions::GuiTableComposition*			textCompositionTable = nullptr;
				compositions::GuiCellComposition*			textComposition = nullptr;
				
				void										UpdateVisuallyEnabled()override;
				void										UpdateDisplayFont()override;
				void										RearrangeTextElement();
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiSinglelineTextBox(theme::ThemeName themeName);
				~GuiSinglelineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;

				/// <summary>
				/// Get the password mode displaying character.
				/// </summary>
				/// <returns>The password mode displaying character. Returns L'\0' means the password mode is not activated.</returns>
				wchar_t										GetPasswordChar();
				/// <summary>
				/// Set the password mode displaying character.
				/// </summary>
				/// <param name="value">The password mode displaying character. Set to L'\0' to deactivate the password mode.</param>
				void										SetPasswordChar(wchar_t value);
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGEOPERATIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGEOPERATIONS
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGEOPERATIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ParsingInput
***********************************************************************/

			class RepeatingParsingExecutor;

			/// <summary>A data structure storing the parsing input for text box control.</summary>
			struct RepeatingParsingInput
			{
				/// <summary>The text box edit version of the code.</summary>
				vuint													editVersion = 0;
				/// <summary>The code.</summary>
				WString													code;
			};

/***********************************************************************
ParsingOutput
***********************************************************************/

			/// <summary>A data structure storing the parsing result for text box control.</summary>
			struct RepeatingParsingOutput
			{
				/// <summary>The parsed syntax tree.</summary>
				Ptr<parsing::ParsingTreeObject>							node;
				/// <summary>The text box edit version of the code.</summary>
				vuint													editVersion = 0;
				/// <summary>The code.</summary>
				WString													code;
				/// <summary>The cache created from [T:vl.presentation.controls.RepeatingParsingExecutor.IParsingAnalyzer].</summary>
				Ptr<DescriptableObject>									cache;
			};

/***********************************************************************
PartialParsingOutput
***********************************************************************/
			
			/// <summary>A data structure storing the parsing result for partial updating when a text box control is modified.</summary>
			struct RepeatingPartialParsingOutput
			{
				/// <summary>The input data.</summary>
				RepeatingParsingOutput									input;
				/// <summary>The rule name that can parse the code of the selected context.</summary>
				WString													rule;
				/// <summary>Range of the original context in the input.</summary>
				parsing::ParsingTextRange								originalRange;
				/// <summary>The original context in the syntax tree.</summary>
				Ptr<parsing::ParsingTreeObject>							originalNode;
				/// <summary>The modified context in the syntax tree.</summary>
				Ptr<parsing::ParsingTreeObject>							modifiedNode;
				/// <summary>The modified code of the selected context.</summary>
				WString													modifiedCode;
			};

/***********************************************************************
PartialParsingOutput
***********************************************************************/

			/// <summary>A data structure storing the information for a candidate item.</summary>
			struct ParsingCandidateItem
			{
				/// <summary>Semantic id.</summary>
				vint													semanticId = -1;
				/// <summary>Display name.</summary>
				WString													name;
				/// <summary>Tag object for any purpose, e.g., data binding.</summary>
				description::Value										tag;
			};

/***********************************************************************
ParsingContext
***********************************************************************/

			/// <summary>A data structure storing the context of a token.</summary>
			struct ParsingTokenContext
			{
				/// <summary>Token syntax tree for the selected token.</summary>
				parsing::ParsingTreeToken*								foundToken = nullptr;
				/// <summary>The object syntax tree parent of the token.</summary>
				parsing::ParsingTreeObject*								tokenParent = nullptr;
				/// <summary>Type of the parent.</summary>
				WString													type;
				/// <summary>Field of the parent that contains the token.</summary>
				WString													field;
				/// <summary>All acceptable semantic ids.</summary>
				Ptr<collections::List<vint>>							acceptableSemanticIds;

				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTreeNode* foundNode, RepeatingParsingExecutor* executor);
				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTextPos pos, parsing::ParsingTreeObject* rootNode, RepeatingParsingExecutor* executor);
				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTextRange range, parsing::ParsingTreeObject* rootNode, RepeatingParsingExecutor* executor);
			};

/***********************************************************************
RepeatingParsingExecutor
***********************************************************************/

			/// <summary>Repeating parsing executor.</summary>
			class RepeatingParsingExecutor : public RepeatingTaskExecutor<RepeatingParsingInput>, public Description<RepeatingParsingExecutor>
			{
			public:
				/// <summary>Callback.</summary>
				class ICallback : public virtual Interface
				{
				public:
					/// <summary>Callback when a parsing task is finished.</summary>
					/// <param name="output">the result of the parsing.</param>
					virtual void											OnParsingFinishedAsync(const RepeatingParsingOutput& output)=0;
					/// <summary>Callback when <see cref="RepeatingParsingExecutor"/> requires enabling or disabling automatically repeating calling to the SubmitTask function.</summary>
					/// <param name="enabled">Set to true to require an automatically repeating calling to the SubmitTask function</param>
					virtual void											RequireAutoSubmitTask(bool enabled)=0;
				};

				/// <summary>Parsing analyzer.</summary>
				class IParsingAnalyzer : public virtual Interface
				{
				private:
					parsing::ParsingTreeNode*								ToParent(parsing::ParsingTreeNode* node, const RepeatingPartialParsingOutput* output);
					parsing::ParsingTreeObject*								ToChild(parsing::ParsingTreeObject* node, const RepeatingPartialParsingOutput* output);
					Ptr<parsing::ParsingTreeNode>							ToChild(Ptr<parsing::ParsingTreeNode> node, const RepeatingPartialParsingOutput* output);

				protected:
					/// <summary>Get a syntax tree node's parent when the whole tree is in a partial modified state. You should use this function instead of ParsingTreeNode::GetParent when implementing this interface.</summary>
					/// <returns>Returns the parent node.</returns>
					/// <param name="node">The node.</param>
					/// <param name="output">The partial parsing output, which describes how the whole tree is partial modified.</param>
					parsing::ParsingTreeNode*								GetParent(parsing::ParsingTreeNode* node, const RepeatingPartialParsingOutput* output);
					/// <summary>Get a syntax tree node's member when the whole tree is in a partial modified state. You should use this function instead of ParsingTreeObject::GetMember when implementing this interface.</summary>
					/// <returns>Returns the member node.</returns>
					/// <param name="node">The node.</param>
					/// <param name="name">The name of the member.</param>
					/// <param name="output">The partial parsing output, which describes how the whole tree is partial modified.</param>
					Ptr<parsing::ParsingTreeNode>							GetMember(parsing::ParsingTreeObject* node, const WString& name, const RepeatingPartialParsingOutput* output);
					/// <summary>Get a syntax tree node's item when the whole tree is in a partial modified state. You should use this function instead of ParsingTreeArray::GetItem when implementing this interface.</summary>
					/// <returns>Returns the item node.</returns>
					/// <param name="node">The node.</param>
					/// <param name="index">The index of the item.</param>
					/// <param name="output">The partial parsing output, which describes how the whole tree is partial modified.</param>
					Ptr<parsing::ParsingTreeNode>							GetItem(parsing::ParsingTreeArray* node, vint index, const RepeatingPartialParsingOutput* output);

				public:
					/// <summary>Called when a <see cref="RepeatingParsingExecutor"/> is created.</summary>
					/// <param name="executor">The releated <see cref="RepeatingParsingExecutor"/>.</param>
					virtual void											Attach(RepeatingParsingExecutor* executor) = 0;

					/// <summary>Called when a <see cref="RepeatingParsingExecutor"/> is destroyed.</summary>
					/// <param name="executor">The releated <see cref="RepeatingParsingExecutor"/>.</param>
					virtual void											Detach(RepeatingParsingExecutor* executor) = 0;

					/// <summary>Called when a new parsing result is produced. A parsing analyzer can create a cache to be attached to the output containing anything necessary. This function does not run in UI thread.</summary>
					/// <param name="output">The new parsing result.</param>
					/// <returns>The created cache object, which can be null.</returns>
					virtual Ptr<DescriptableObject>							CreateCacheAsync(const RepeatingParsingOutput& output) = 0;

					/// <summary>Called when an semantic id for a token is needed. If an semantic id is returned, a context sensitive color can be assigned to this token. This functio does not run in UI thread, but it will only be called (for several times) after the cache object is initialized.</summary>
					/// <param name="tokenContext">The token context.</param>
					/// <param name="output">The current parsing result.</param>
					/// <returns>The semantic id.</returns>
					virtual vint											GetSemanticIdForTokenAsync(const ParsingTokenContext& tokenContext, const RepeatingParsingOutput& output) = 0;

					/// <summary>Called when multiple auto complete candidate items for a token is needed. If nothing is written into the "candidateItems" parameter and the grammar also doesn't provide static candidate items, nothing will popup. This functio does not run in UI thread, but it will only be called (for several times) after the cache object is initialized.</summary>
					/// <param name="tokenContext">The token context.</param>
					/// <param name="partialOutput">The partial parsing result. It contains the current parsing result, and an incremental parsing result. If the calculation of candidate items are is very context sensitive, then you should be very careful when traversing the syntax tree, by carefully looking at the "originalNode" and the "modifiedNode" in the "partialOutput" parameter.</param>
					/// <param name="candidateItems">The candidate items.</param>
					virtual void											GetCandidateItemsAsync(const ParsingTokenContext& tokenContext, const RepeatingPartialParsingOutput& partialOutput, collections::List<ParsingCandidateItem>& candidateItems) = 0;					

					/// <summary>Create a tag object for a candidate item without a tag object. An candidate item without a tag maybe created by calling <see cref="GetCandidateItemsAsync"/> or any token marked by a @Candidate attribute in the grammar.</summary>
					/// <param name="item">The candidate item.</param>
					/// <returns>The tag object. In most of the case this object is used for data binding or any other purpose when you want to customize the auto complete control. Returns null if the specified [T.vl.presentation.controls.GuiTextBoxAutoCompleteBase.IAutoCompleteControlProvider] can handle null tag correctly.</returns>
					virtual description::Value								CreateTagForCandidateItem(ParsingCandidateItem& item) = 0;
				};

				/// <summary>A base class for implementing a callback.</summary>
				class CallbackBase : public virtual ICallback, public virtual ICommonTextEditCallback
				{
				private:
					bool													callbackAutoPushing;
					elements::GuiColorizedTextElement*						callbackElement;
					SpinLock*												callbackElementModifyLock;

				protected:
					Ptr<RepeatingParsingExecutor>							parsingExecutor;

				public:
					CallbackBase(Ptr<RepeatingParsingExecutor> _parsingExecutor);
					~CallbackBase();

					void													RequireAutoSubmitTask(bool enabled)override;
					void													Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
					void													Detach()override;
					void													TextEditPreview(TextEditPreviewStruct& arguments)override;
					void													TextEditNotify(const TextEditNotifyStruct& arguments)override;
					void													TextCaretChanged(const TextCaretChangedStruct& arguments)override;
					void													TextEditFinished(vuint editVersion)override;
				};

				struct TokenMetaData
				{
					vint													tableTokenIndex;
					vint													lexerTokenIndex;
					vint													defaultColorIndex;
					bool													hasContextColor;
					bool													hasAutoComplete;
					bool													isCandidate;
					WString													unescapedRegexText;
				};

				struct FieldMetaData
				{
					vint													colorIndex;
					Ptr<collections::List<vint>>							semantics;
				};
			private:
				Ptr<parsing::tabling::ParsingGeneralParser>					grammarParser;
				WString														grammarRule;
				Ptr<IParsingAnalyzer>										analyzer;
				collections::List<ICallback*>								callbacks;
				collections::List<ICallback*>								activatedCallbacks;
				ICallback*													autoPushingCallback;

				typedef collections::Pair<WString, WString>					FieldDesc;
				collections::Dictionary<WString, vint>						tokenIndexMap;
				collections::SortedList<WString>							semanticIndexMap;
				collections::Dictionary<vint, TokenMetaData>				tokenMetaDatas;
				collections::Dictionary<FieldDesc, FieldMetaData>			fieldMetaDatas;

			protected:

				void														Execute(const RepeatingParsingInput& input)override;
				void														PrepareMetaData();

				/// <summary>Called when semantic analyzing is needed. It is encouraged to set the "cache" fields in "context" argument. If there is an <see cref="RepeatingParsingExecutor::IParsingAnalyzer"/> binded to the <see cref="RepeatingParsingExecutor"/>, this function can be automatically done.</summary>
				/// <param name="context">The parsing result.</param>
				virtual void												OnContextFinishedAsync(RepeatingParsingOutput& context);
			public:
				/// <summary>Initialize the parsing executor.</summary>
				/// <param name="_grammarParser">Parser generated from a grammar.</param>
				/// <param name="_grammarRule">The rule name to parse a complete code.</param>
				/// <param name="_analyzer">The parsing analyzer to create semantic metadatas, it can be null.</param>
				RepeatingParsingExecutor(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule, Ptr<IParsingAnalyzer> _analyzer = 0);
				~RepeatingParsingExecutor();
				
				/// <summary>Get the internal parser that parse the text.</summary>
				/// <returns>The internal parser.</returns>
				Ptr<parsing::tabling::ParsingGeneralParser>					GetParser();
				/// <summary>Detach callback.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														AttachCallback(ICallback* value);
				/// <summary>Detach callback.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														DetachCallback(ICallback* value);
				/// <summary>Activate a callback. Activating a callback means that the callback owner has an ability to watch a text box modification, e.g., an attached <see cref="ICommonTextEditCallback"/> that is also an <see cref="ICallback"/>. The <see cref="RepeatingParsingExecutor"/> may require one of the activated callback to push code for parsing automatically via a call to <see cref="ICallback::RequireAutoSubmitTask"/>.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														ActivateCallback(ICallback* value);
				/// <summary>Deactivate a callback. See <see cref="ActivateCallback"/> for deatils.</summary>
				/// <returns>Returns true if this operation succeeded.</returns>
				/// <param name="value">The callback.</param>
				bool														DeactivateCallback(ICallback* value);
				/// <summary>Get the parsing analyzer.</summary>
				/// <returns>The parsing analyzer.</returns>
				Ptr<IParsingAnalyzer>										GetAnalyzer();

				vint														GetTokenIndex(const WString& tokenName);
				vint														GetSemanticId(const WString& name);
				WString														GetSemanticName(vint id);
				const TokenMetaData&										GetTokenMetaData(vint regexTokenIndex);
				const FieldMetaData&										GetFieldMetaData(const WString& type, const WString& field);

				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetAttribute(vint index, const WString& name, vint argumentCount);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetColorAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetContextColorAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetSemanticAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetCandidateAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetAutoCompleteAttribute(vint index);

				/*
				@Color(ColorName)
					field:	color of the token field when the token type is marked with @ContextColor
					token:	color of the token
				@ContextColor()
					token:	the color of the token may be changed if the token field is marked with @Color or @Semantic
				@Semantic(Type1, Type2, ...)
					field:	After resolved symbols for this field, only types of symbols that specified in the arguments are acceptable.
				@Candidate()
					token:	when the token can be available after the editing caret, than it will be in the auto complete list.
				@AutoComplete()
					token:	when the token is editing, an auto complete list will appear if possible
				*/
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGEAUTOCOMPLETE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGEAUTOCOMPLETE
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGEAUTOCOMPLETE

namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiGrammarAutoComplete
***********************************************************************/
			
			/// <summary>Grammar based auto complete controller.</summary>
			class GuiGrammarAutoComplete
				: public GuiTextBoxAutoCompleteBase
				, protected RepeatingParsingExecutor::CallbackBase
				, private RepeatingTaskExecutor<RepeatingParsingOutput>
			{
			public:

				/// <summary>The auto complete list data.</summary>
				struct AutoCompleteData : ParsingTokenContext
				{
					/// <summary>Available candidate tokens (in lexer token index).</summary>
					collections::List<vint>							candidates;
					/// <summary>Available candidate tokens (in lexer token index) that marked with @AutoCompleteCandidate().</summary>
					collections::List<vint>							shownCandidates;
					/// <summary>Candidate items.</summary>
					collections::List<ParsingCandidateItem>			candidateItems;
					/// <summary>The start position of the editing token in global coordination.</summary>
					TextPos											startPosition;
				};

				/// <summary>The analysed data from an input code.</summary>
				struct AutoCompleteContext : RepeatingPartialParsingOutput
				{
					/// <summary>The edit version of modified code.</summary>
					vuint											modifiedEditVersion = 0;
					/// <summary>The analysed auto complete list data.</summary>
					Ptr<AutoCompleteData>							autoComplete;
				};
			private:
				Ptr<parsing::tabling::ParsingGeneralParser>			grammarParser;
				collections::SortedList<WString>					leftRecursiveRules;
				bool												editing;

				SpinLock											editTraceLock;
				collections::List<TextEditNotifyStruct>				editTrace;

				SpinLock											contextLock;
				AutoCompleteContext									context;
				
				void												Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void												Detach()override;
				void												TextEditPreview(TextEditPreviewStruct& arguments)override;
				void												TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void												TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void												TextEditFinished(vuint editVersion)override;
				void												OnParsingFinishedAsync(const RepeatingParsingOutput& output)override;
				void												CollectLeftRecursiveRules();

				vint												UnsafeGetEditTraceIndex(vuint editVersion);
				TextPos												ChooseCorrectTextPos(TextPos pos, const regex::RegexTokens& tokens);
				void												ExecuteRefresh(AutoCompleteContext& newContext);

				bool												NormalizeTextPos(AutoCompleteContext& newContext, elements::text::TextLines& lines, TextPos& pos);
				void												ExecuteEdit(AutoCompleteContext& newContext);

				void												DeleteFutures(collections::List<parsing::tabling::ParsingState::Future*>& futures);
				regex::RegexToken*									TraverseTransitions(
																		parsing::tabling::ParsingState& state,
																		parsing::tabling::ParsingTransitionCollector& transitionCollector,
																		TextPos stopPosition,
																		collections::List<parsing::tabling::ParsingState::Future*>& nonRecoveryFutures,
																		collections::List<parsing::tabling::ParsingState::Future*>& recoveryFutures
																		);
				regex::RegexToken*									SearchValidInputToken(
																		parsing::tabling::ParsingState& state,
																		parsing::tabling::ParsingTransitionCollector& transitionCollector,
																		TextPos stopPosition,
																		AutoCompleteContext& newContext,
																		collections::SortedList<vint>& tableTokenIndices
																		);

				TextPos												GlobalTextPosToModifiedTextPos(AutoCompleteContext& newContext, TextPos pos);
				TextPos												ModifiedTextPosToGlobalTextPos(AutoCompleteContext& newContext, TextPos pos);
				void												ExecuteCalculateList(AutoCompleteContext& newContext);

				void												Execute(const RepeatingParsingOutput& input)override;
				void												PostList(const AutoCompleteContext& newContext, bool byGlobalCorrection);
				void												Initialize();
			protected:

				/// <summary>Called when the context of the code is selected. It is encouraged to set the "candidateItems" field in "context.autoComplete" during the call. If there is an <see cref="RepeatingParsingExecutor::IParsingAnalyzer"/> binded to the <see cref="RepeatingParsingExecutor"/>, this function can be automatically done.</summary>
				/// <param name="context">The selected context.</param>
				virtual void										OnContextFinishedAsync(AutoCompleteContext& context);

				/// <summary>Call this function in the derived class's destructor when it overrided <see cref="OnContextFinishedAsync"/>.</summary>
				void												EnsureAutoCompleteFinished();
			public:
				/// <summary>Create the auto complete controller with a created parsing executor.</summary>
				/// <param name="_parsingExecutor">The parsing executor.</param>
				GuiGrammarAutoComplete(Ptr<RepeatingParsingExecutor> _parsingExecutor);
				/// <summary>Create the auto complete controller with a specified grammar and start rule to create a <see cref="RepeatingParsingExecutor"/>.</summary>
				/// <param name="_grammarParser">Parser generated from a grammar.</param>
				/// <param name="_grammarRule"></param>
				GuiGrammarAutoComplete(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule);
				~GuiGrammarAutoComplete();

				/// <summary>Get the internal parsing executor.</summary>
				/// <returns>The parsing executor.</returns>
				Ptr<RepeatingParsingExecutor>						GetParsingExecutor();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGECOLORIZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGECOLORIZER
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGECOLORIZER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiGrammarColorizer
***********************************************************************/

			/// <summary>Grammar based colorizer.</summary>
			class GuiGrammarColorizer : public GuiTextBoxRegexColorizer, protected RepeatingParsingExecutor::CallbackBase
			{
				typedef collections::Pair<WString, WString>					FieldDesc;
				typedef collections::Dictionary<FieldDesc, vint>			FieldContextColors;
				typedef collections::Dictionary<FieldDesc, vint>			FieldSemanticColors;
				typedef elements::text::ColorEntry							ColorEntry;
			public:
				/// <summary>Context for doing semantic colorizing.</summary>
				struct SemanticColorizeContext : ParsingTokenContext
				{
					/// <summary>Output semantic id that comes from one the argument in the @Semantic attribute.</summary>
					vint													semanticId;
				};
			private:
				collections::Dictionary<WString, ColorEntry>				colorSettings;
				collections::Dictionary<vint, vint>							semanticColorMap;

				SpinLock													contextLock;
				RepeatingParsingOutput										context;

				void														OnParsingFinishedAsync(const RepeatingParsingOutput& output)override;
			protected:
				/// <summary>Called when the node is parsed successfully before restarting colorizing.</summary>
				/// <param name="context">The result of the parsing.</param>
				virtual void												OnContextFinishedAsync(const RepeatingParsingOutput& context);

				void														Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void														Detach()override;
				void														TextEditPreview(TextEditPreviewStruct& arguments)override;
				void														TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void														TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void														TextEditFinished(vuint editVersion)override;

				/// <summary>Called when a @SemanticColor attribute in a grammar is activated during colorizing to determine a color for the token. If there is an <see cref="RepeatingParsingExecutor::IParsingAnalyzer"/> binded to the <see cref="RepeatingParsingExecutor"/>, this function can be automatically done.</summary>
				/// <param name="context">Context for doing semantic colorizing.</param>
				/// <param name="input">The corressponding result from the <see cref="RepeatingParsingExecutor"/>.</param>
				virtual void												OnSemanticColorize(SemanticColorizeContext& context, const RepeatingParsingOutput& input);

				/// <summary>Call this function in the derived class's destructor when it overrided <see cref="OnSemanticColorize"/>.</summary>
				void														EnsureColorizerFinished();
			public:
				/// <summary>Create the colorizer with a created parsing executor.</summary>
				/// <param name="_parsingExecutor">The parsing executor.</param>
				GuiGrammarColorizer(Ptr<RepeatingParsingExecutor> _parsingExecutor);
				/// <summary>Create the colorizer with a specified grammar and start rule to create a <see cref="RepeatingParsingExecutor"/>.</summary>
				/// <param name="_grammarParser">Parser generated from a grammar.</param>
				/// <param name="_grammarRule"></param>
				GuiGrammarColorizer(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule);
				~GuiGrammarColorizer();

				/// <summary>Reset all color settings.</summary>
				void														BeginSetColors();
				/// <summary>Get all color names.</summary>
				/// <returns>All color names.</returns>
				const collections::SortedList<WString>&						GetColorNames();
				/// <summary>Get the color for a token theme name (@Color or @ContextColor("theme-name") in the grammar).</summary>
				/// <returns>The color.</returns>
				/// <param name="name">The token theme name.</param>
				ColorEntry													GetColor(const WString& name);
				/// <summary>Set a color for a token theme name (@Color or @ContextColor("theme-name") in the grammar).</summary>
				/// <param name="name">The token theme name.</param>
				/// <param name="entry">The color.</param>
				void														SetColor(const WString& name, const ColorEntry& entry);
				/// <summary>Set a color for a token theme name (@Color or @ContextColor("theme-name") in the grammar).</summary>
				/// <param name="name">The token theme name.</param>
				/// <param name="color">The color.</param>
				void														SetColor(const WString& name, const Color& color);
				/// <summary>Submit all color settings.</summary>
				void														EndSetColors();
				void														ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState)override;

				/// <summary>Get the internal parsing executor.</summary>
				/// <returns>The parsing executor.</returns>
				Ptr<RepeatingParsingExecutor>								GetParsingExecutor();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIMENUCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Menu Service
***********************************************************************/

			class GuiMenu;

			/// <summary>IGuiMenuService is a required service for menu item container.</summary>
			class IGuiMenuService : public virtual IDescriptable, public Description<IGuiMenuService>
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				/// <summary>Direction to decide the position for a menu with specified control.</summary>
				enum Direction
				{
					/// <summary>Aligned to the top or bottom side.</summary>
					Horizontal,
					/// <summary>Aligned to the left or right side.</summary>
					Vertical,
				};
			protected:
				GuiMenu*								openingMenu;
			public:
				IGuiMenuService();

				/// <summary>Get the parent service. This service represents the parent menu that host the menu item control that contains this menu.</summary>
				/// <returns>The parent service.</returns>
				virtual IGuiMenuService*				GetParentMenuService()=0;
				/// <summary>Get the preferred direction to open the sub menu.</summary>
				/// <returns>The preferred direction to open the sub menu.</returns>
				virtual Direction						GetPreferredDirection()=0;
				/// <summary>Test is this menu is active. When an menu is active, the sub menu is automatically opened when the corresponding menu item is opened.</summary>
				/// <returns>Returns true if this menu is active.</returns>
				virtual bool							IsActiveState()=0;
				/// <summary>Test all sub menu items are actived by mouse down.</summary>
				/// <returns>Returns true if all sub menu items are actived by mouse down.</returns>
				virtual bool							IsSubMenuActivatedByMouseDown()=0;

				/// <summary>Called when the menu item is executed.</summary>
				virtual void							MenuItemExecuted();
				/// <summary>Get the opening sub menu.</summary>
				/// <returns>The opening sub menu.</returns>
				virtual GuiMenu*						GetOpeningMenu();
				/// <summary>Called when the sub menu is opened.</summary>
				/// <param name="menu">The sub menu.</param>
				virtual void							MenuOpened(GuiMenu* menu);
				/// <summary>Called when the sub menu is closed.</summary>
				/// <param name="menu">The sub menu.</param>
				virtual void							MenuClosed(GuiMenu* menu);
			};

			/// <summary>IGuiMenuService is a required service to tell a ribbon group that this control has a dropdown to display.</summary>
			class IGuiMenuDropdownProvider : public virtual IDescriptable, public Description<IGuiMenuDropdownProvider>
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const				Identifier;

				/// <summary>Get the dropdown to display.</summary>
				/// <returns>The dropdown to display. Returns null to indicate the dropdown cannot be displaied temporary.</returns>
				virtual GuiMenu*						ProvideDropdownMenu() = 0;
			};

/***********************************************************************
Menu
***********************************************************************/

			/// <summary>Popup menu.</summary>
			class GuiMenu : public GuiPopup, protected IGuiMenuService, public Description<GuiMenu>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(MenuTemplate, GuiPopup)
			private:
				IGuiMenuService*						parentMenuService = nullptr;
				bool									hideOnDeactivateAltHost = true;
				Size									preferredMenuClientSizeBeforeUpdating;
				Size									preferredMenuClientSize;

				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;
				void									MenuItemExecuted()override;

				void									Moving(NativeRect& bounds, bool fixSizeOnly, bool draggingBorder)override;
				void									UpdateClientSizeAfterRendering(Size preferredSize, Size clientSize)override;
			protected:
				GuiControl*								owner;

				void									OnDeactivatedAltHost()override;
				void									OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_owner">The owner menu item of the parent menu.</param>
				GuiMenu(theme::ThemeName themeName, GuiControl* _owner);
				~GuiMenu();

				/// <summary>Update the reference to the parent <see cref="IGuiMenuService"/>. This function is not required to call outside the menu or menu item control.</summary>
				void									UpdateMenuService();
				IDescriptable*							QueryService(const WString& identifier)override;

				/// <summary>Test if this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</summary>
				/// <returns>Returns true if this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</returns>
				bool									GetHideOnDeactivateAltHost();
				/// <summary>Set if this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</summary>
				/// <param name="value">Set to true to make this menu hide after pressing ESC key to exit to the upper level of ALT shortcuts.</param>
				void									SetHideOnDeactivateAltHost(bool value);

				/// <summary>Get the preferred client size for the menu.</summary>
				/// <returns>The preferred client size for the menu.</returns>
				Size									GetPreferredMenuClientSize();
				/// <summary>Set the preferred client size for the menu.</summary>
				/// <param name="value">The preferred client size for the menu.</param>
				void									SetPreferredMenuClientSize(Size value);
			};
			
			/// <summary>Menu bar.</summary>
			class GuiMenuBar : public GuiControl, protected IGuiMenuService, public Description<GuiMenuBar>
			{
			private:
				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiMenuBar(theme::ThemeName themeName);
				~GuiMenuBar();
				
				IDescriptable*							QueryService(const WString& identifier)override;
			};

/***********************************************************************
MenuButton
***********************************************************************/

			/// <summary>Menu item.</summary>
			class GuiMenuButton : public GuiSelectableButton, private IGuiMenuDropdownProvider, public Description<GuiMenuButton>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ToolstripButtonTemplate, GuiSelectableButton)

				using IEventHandler = compositions::IGuiGraphicsEventHandler;
			protected:
				Ptr<GuiDisposedFlag>					subMenuDisposeFlag;
				Ptr<IEventHandler>						subMenuWindowOpenedHandler;
				Ptr<IEventHandler>						subMenuWindowClosedHandler;
				Ptr<IEventHandler>						hostClickedHandler;
				Ptr<IEventHandler>						hostMouseEnterHandler;
				Ptr<GuiImageData>						image;
				Ptr<GuiImageData>						largeImage;
				WString									shortcutText;
				GuiMenu*								subMenu;
				bool									ownedSubMenu;
				Size									preferredMenuClientSize;
				IGuiMenuService*						ownerMenuService;
				bool									cascadeAction;

				GuiButton*								GetSubMenuHost();
				bool									OpenSubMenuInternal();
				void									OnParentLineChanged()override;
				compositions::IGuiAltActionHost*		GetActivatingAltHost()override;

				void									OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				virtual IGuiMenuService::Direction		GetSubMenuDirection();

			private:
				void									DetachSubMenu();
				GuiMenu*								ProvideDropdownMenu()override;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiMenuButton(theme::ThemeName themeName);
				~GuiMenuButton();

				/// <summary>Before sub menu opening event.</summary>
				compositions::GuiNotifyEvent			BeforeSubMenuOpening;
				/// <summary>After sub menu opening event.</summary>
				compositions::GuiNotifyEvent			AfterSubMenuOpening;
				/// <summary>Sub menu opening changed event.</summary>
				compositions::GuiNotifyEvent			SubMenuOpeningChanged;
				/// <summary>Large image changed event.</summary>
				compositions::GuiNotifyEvent			LargeImageChanged;
				/// <summary>Image changed event.</summary>
				compositions::GuiNotifyEvent			ImageChanged;
				/// <summary>Shortcut text changed event.</summary>
				compositions::GuiNotifyEvent			ShortcutTextChanged;

				/// <summary>Get the large image for the menu button.</summary>
				/// <returns>The large image for the menu button.</returns>
				Ptr<GuiImageData>						GetLargeImage();
				/// <summary>Set the large image for the menu button.</summary>
				/// <param name="value">The large image for the menu button.</param>
				void									SetLargeImage(Ptr<GuiImageData> value);
				/// <summary>Get the image for the menu button.</summary>
				/// <returns>The image for the menu button.</returns>
				Ptr<GuiImageData>						GetImage();
				/// <summary>Set the image for the menu button.</summary>
				/// <param name="value">The image for the menu button.</param>
				void									SetImage(Ptr<GuiImageData> value);
				/// <summary>Get the shortcut key text for the menu button.</summary>
				/// <returns>The shortcut key text for the menu button.</returns>
				const WString&							GetShortcutText();
				/// <summary>Set the shortcut key text for the menu button.</summary>
				/// <param name="value">The shortcut key text for the menu button.</param>
				void									SetShortcutText(const WString& value);

				/// <summary>Test does the sub menu exist.</summary>
				/// <returns>Returns true if the sub menu exists.</returns>
				bool									IsSubMenuExists();
				/// <summary>Get the sub menu. If the sub menu is not created, it returns null.</summary>
				/// <returns>The sub menu.</returns>
				GuiMenu*								GetSubMenu();
				/// <summary>Create the sub menu if necessary. The created sub menu is owned by this menu button.</summary>
				/// <returns>The created sub menu.</returns>
				/// <param name="subMenuTemplate">The style controller for the sub menu. Set to null to use the default control template.</param>
				GuiMenu*								CreateSubMenu(TemplateProperty<templates::GuiMenuTemplate> subMenuTemplate = {});
				/// <summary>Associate a sub menu if there is no sub menu binded in this menu button. The associated sub menu is not owned by this menu button if the "owned" argument is set to false.</summary>
				/// <param name="value">The sub menu to associate.</param>
				/// <param name="owned">Set to true if the menu is expected to be owned.</param>
				void									SetSubMenu(GuiMenu* value, bool owned);
				/// <summary>Destroy the sub menu if necessary.</summary>
				void									DestroySubMenu();
				/// <summary>Test is the sub menu owned by this menu button. If the sub menu is owned, both deleting this menu button or calling <see cref="DestroySubMenu"/> will delete the sub menu.</summary>
				/// <returns>Returns true if the sub menu is owned by this menu button.</returns>
				bool									GetOwnedSubMenu();

				/// <summary>Test is the sub menu opened.</summary>
				/// <returns>Returns true if the sub menu is opened.</returns>
				bool									GetSubMenuOpening();
				/// <summary>Open or close the sub menu.</summary>
				/// <param name="value">Set to true to open the sub menu.</param>
				void									SetSubMenuOpening(bool value);

				/// <summary>Get the preferred client size for the sub menu.</summary>
				/// <returns>The preferred client size for the sub menu.</returns>
				Size									GetPreferredMenuClientSize();
				/// <summary>Set the preferred client size for the sub menu.</summary>
				/// <param name="value">The preferred client size for the sub menu.</param>
				void									SetPreferredMenuClientSize(Size value);

				/// <summary>Test is cascade action enabled. If the cascade action is enabled, when the mouse enter this menu button, the sub menu will be automatically opened if the parent menu is in an active state (see <see cref="IGuiMenuService::IsActiveState"/>), closing the sub menu will also close the parent menu.</summary>
				/// <returns>Returns true if cascade action is enabled.</returns>
				bool									GetCascadeAction();
				/// <summary>Enable or disable cascade action.</summary>
				/// <param name="value">Set to true to enable cascade action.</param>
				void									SetCascadeAction(bool value);

				IDescriptable*							QueryService(const WString& identifier)override;
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUICOMBOCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ComboBox Base
***********************************************************************/

			/// <summary>The base class of combo box control.</summary>
			class GuiComboBoxBase : public GuiMenuButton, public Description<GuiComboBoxBase>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ComboBoxTemplate, GuiMenuButton)
			protected:
				
				IGuiMenuService::Direction					GetSubMenuDirection()override;
				void										OnCachedBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiComboBoxBase(theme::ThemeName themeName);
				~GuiComboBoxBase();
			};

/***********************************************************************
ComboBox with GuiControl
***********************************************************************/

			/// <summary>Combo box control. This control is a combo box with a control in its popup.</summary>
			class GuiComboButton
				: public GuiComboBoxBase
				, public Description<GuiComboButton>
			{
			protected:
				GuiControl*									dropdownControl = nullptr;

			public:
				/// <summary>Create a control with a specified default theme and a control that will be put in the popup control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_dropdownControl">The contained control.</param>
				GuiComboButton(theme::ThemeName themeName, GuiControl* _dropdownControl);
				~GuiComboButton();
			};

/***********************************************************************
ComboBox with GuiListControl
***********************************************************************/

			/// <summary>Combo box list control. This control is a combo box with a list control in its popup.</summary>
			class GuiComboBoxListControl
				: public GuiComboBoxBase
				, private list::IItemProviderCallback
				, public Description<GuiComboBoxListControl>
			{
			public:
				using ItemStyleProperty = TemplateProperty<templates::GuiTemplate>;

			protected:
				GuiSelectableListControl*					containedListControl = nullptr;
				vint										selectedIndex = -1;
				ItemStyleProperty							itemStyleProperty;
				templates::GuiTemplate*						itemStyleController = nullptr;
				Ptr<compositions::IGuiGraphicsEventHandler>	boundsChangedHandler;

				void										UpdateDisplayFont()override;
				void										BeforeControlTemplateUninstalled()override;
				void										AfterControlTemplateInstalled(bool initialize)override;
				void										RemoveStyleController();
				void										InstallStyleController(vint itemIndex);
				virtual void								DisplaySelectedContent(vint itemIndex);
				void										AdoptSubMenuSize();
				void										OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnContextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnVisuallyEnabledChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnAfterSubMenuOpening(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnListControlAdoptedSizeInvalidated(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnListControlItemMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void										OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);

			private:
				// ===================== GuiListControl::IItemProviderCallback =====================

				void										OnAttached(list::IItemProvider* provider)override;
				void										OnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
			public:
				/// <summary>Create a control with a specified default theme and a list control that will be put in the popup control to show all items.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_containedListControl">The list control.</param>
				GuiComboBoxListControl(theme::ThemeName themeName, GuiSelectableListControl* _containedListControl);
				~GuiComboBoxListControl();
				
				/// <summary>Style provider changed event.</summary>
				compositions::GuiNotifyEvent				ItemTemplateChanged;
				/// <summary>Selected index changed event.</summary>
				compositions::GuiNotifyEvent				SelectedIndexChanged;
				
				/// <summary>Get the list control.</summary>
				/// <returns>The list control.</returns>
				GuiSelectableListControl*					GetContainedListControl();

				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				virtual ItemStyleProperty					GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				virtual void								SetItemTemplate(ItemStyleProperty value);
				
				/// <summary>Get the selected index.</summary>
				/// <returns>The selected index.</returns>
				vint										GetSelectedIndex();
				/// <summary>Set the selected index.</summary>
				/// <param name="value">The selected index.</param>
				void										SetSelectedIndex(vint value);

				/// <summary>Get the selected item.</summary>
				/// <returns>The selected item.</returns>
				description::Value							GetSelectedItem();
				/// <summary>Get the item provider in the list control.</summary>
				/// <returns>The item provider in the list control.</returns>
				list::IItemProvider*						GetItemProvider();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\GUIDATETIMECONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATETIMECONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIDATETIMECONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
DatePicker
***********************************************************************/

			/// <summary>Date picker control that display a calendar.</summary>
			class GuiDatePicker : public GuiControl, protected compositions::GuiAltActionHostBase, public Description<GuiDatePicker>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DatePickerTemplate, GuiControl)
			protected:
				class CommandExecutor : public Object, public IDatePickerCommandExecutor
				{
				protected:
					GuiDatePicker*										datePicker;
				public:
					CommandExecutor(GuiDatePicker* _datePicker);
					~CommandExecutor();

					void												NotifyDateChanged()override;
					void												NotifyDateNavigated()override;
					void												NotifyDateSelected()override;
				};

				Ptr<CommandExecutor>									commandExecutor;
				DateTime												date;
				WString													dateFormat;
				Locale													dateLocale;
				compositions::IGuiAltActionHost*						previousAltHost = nullptr;
				bool													nestedAlt = false;

				void													UpdateText();
				bool													IsAltAvailable()override;
				compositions::IGuiAltActionHost*						GetActivatingAltHost()override;

			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_nestedAlt">Set to true to make this date picker an <see cref="compositions::IGuiAltActionHost"/>.</param>
				GuiDatePicker(theme::ThemeName themeName, bool _nestedAlt = true);
				~GuiDatePicker();

				/// <summary>Date changed event.</summary>
				compositions::GuiNotifyEvent							DateChanged;
				/// <summary>Date navigated event. Called when the current month is changed.</summary>
				compositions::GuiNotifyEvent							DateNavigated;
				/// <summary>Date selected event. Called when a day button is selected.</summary>
				compositions::GuiNotifyEvent							DateSelected;
				/// <summary>Date format changed event.</summary>
				compositions::GuiNotifyEvent							DateFormatChanged;
				/// <summary>Date locale changed event.</summary>
				compositions::GuiNotifyEvent							DateLocaleChanged;
				
				/// <summary>Get the displayed date.</summary>
				/// <returns>The date.</returns>
				const DateTime&											GetDate();
				/// <summary>Display a date.</summary>
				/// <param name="value">The date.</param>
				void													SetDate(const DateTime& value);
				/// <summary>Get the format.</summary>
				/// <returns>The format.</returns>
				const WString&											GetDateFormat();
				/// <summary>Set the format for the text of this control.</summary>
				/// <param name="value">The format.</param>
				void													SetDateFormat(const WString& value);
				/// <summary>Get the locale.</summary>
				/// <returns>The locale.</returns>
				const Locale&											GetDateLocale();
				/// <summary>Set the locale to display texts.</summary>
				/// <param name="value">The locale.</param>
				void													SetDateLocale(const Locale& value);

				void													SetText(const WString& value)override;
			};

/***********************************************************************
DateComboBox
***********************************************************************/
			
			/// <summary>A combo box control with a date picker control.</summary>
			class GuiDateComboBox : public GuiComboBoxBase, public Description<GuiDateComboBox>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(DateComboBoxTemplate, GuiComboBoxBase)
			protected:
				GuiDatePicker*											datePicker;
				DateTime												selectedDate;
				
				void													UpdateText();
				void													NotifyUpdateSelectedDate();
				void													OnSubMenuOpeningChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateLocaleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateFormatChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateSelected(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified style provider.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiDateComboBox(theme::ThemeName themeName);
				~GuiDateComboBox();
				
				/// <summary>Selected data changed event.</summary>
				compositions::GuiNotifyEvent							SelectedDateChanged;
				
				void													SetFont(const Nullable<FontProperties>& value)override;
				/// <summary>Get the displayed date.</summary>
				/// <returns>The date.</returns>
				const DateTime&											GetSelectedDate();
				/// <summary>Display a date.</summary>
				/// <param name="value">The date.</param>
				void													SetSelectedDate(const DateTime& value);
				/// <summary>Get the date picker control.</summary>
				/// <returns>The date picker control.</returns>
				GuiDatePicker*											GetDatePicker();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			///<summary>List view column header control for detailed view.</summary>
			class GuiListViewColumnHeader : public GuiMenuButton, public Description<GuiListViewColumnHeader>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ListViewColumnHeaderTemplate, GuiMenuButton)
			protected:
				ColumnSortingState								columnSortingState = ColumnSortingState::NotSorted;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiListViewColumnHeader(theme::ThemeName themeName);
				~GuiListViewColumnHeader();

				bool											IsAltAvailable()override;

				/// <summary>Get the column sorting state.</summary>
				/// <returns>The column sorting state.</returns>
				ColumnSortingState								GetColumnSortingState();
				/// <summary>Set the column sorting state.</summary>
				/// <param name="value">The new column sorting state.</param>
				void											SetColumnSortingState(ColumnSortingState value);
			};

			/// <summary>List view base control. All list view controls inherit from this class.</summary>
			class GuiListViewBase : public GuiSelectableListControl, public Description<GuiListViewBase>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(ListViewTemplate, GuiSelectableListControl)
			public:
				/// <summary>Create a list view base control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiListViewBase(theme::ThemeName themeName, list::IItemProvider* _itemProvider);
				~GuiListViewBase();

				/// <summary>Column clicked event.</summary>
				compositions::GuiItemNotifyEvent				ColumnClicked;
			};

/***********************************************************************
ListView ItemStyleProvider
***********************************************************************/

			namespace list
			{
				/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for <see cref="GuiVirtualListView"/>.</summary>
				class IListViewItemView : public virtual IDescriptable, public Description<IListViewItemView>
				{
				public:
					/// <summary>The identifier for this view.</summary>
					static const wchar_t* const				Identifier;

					/// <summary>Get the small image of an item.</summary>
					/// <returns>The small image.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual Ptr<GuiImageData>				GetSmallImage(vint itemIndex) = 0;
					/// <summary>Get the large image of an item.</summary>
					/// <returns>The large image.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual Ptr<GuiImageData>				GetLargeImage(vint itemIndex) = 0;
					/// <summary>Get the text of an item.</summary>
					/// <returns>The text.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					virtual WString							GetText(vint itemIndex) = 0;
					/// <summary>Get the sub item text of an item. If the sub item index out of range, it returns an empty string.</summary>
					/// <returns>The sub item text.</returns>
					/// <param name="itemIndex">The index of the item.</param>
					/// <param name="index">The sub item index of the item.</param>
					virtual WString							GetSubItem(vint itemIndex, vint index) = 0;

					/// <summary>Get the number of data columns.</summary>
					/// <returns>The number of data columns.</returns>
					virtual vint											GetDataColumnCount() = 0;
					/// <summary>Get the column index of the index-th data column.</summary>
					/// <returns>The column index.</returns>
					/// <param name="index">The order of the data column.</param>
					virtual vint											GetDataColumn(vint index) = 0;

					/// <summary>Get the number of all columns.</summary>
					/// <returns>The number of all columns.</returns>
					virtual vint											GetColumnCount() = 0;
					/// <summary>Get the text of the column.</summary>
					/// <returns>The text of the column.</returns>
					/// <param name="index">The index of the column.</param>
					virtual WString											GetColumnText(vint index) = 0;
				};

/***********************************************************************
ListViewColumnItemArranger
***********************************************************************/

				/// <summary>List view column item arranger. This arranger contains column headers. When an column header is resized, all items will be notified via the [T:vl.presentation.controls.list.ListViewColumnItemArranger.IColumnItemView] for <see cref="GuiListControl::IItemProvider"/>.</summary>
				class ListViewColumnItemArranger : public VirtualRepeatRangedItemArrangerBase<compositions::GuiRepeatFixedHeightItemComposition>, public Description<ListViewColumnItemArranger>
				{
					using TBase = VirtualRepeatRangedItemArrangerBase<compositions::GuiRepeatFixedHeightItemComposition>;
					typedef collections::List<GuiListViewColumnHeader*>					ColumnHeaderButtonList;
					typedef collections::List<compositions::GuiBoundsComposition*>		ColumnHeaderSplitterList;
				public:
					static const vint							SplitterWidth = 8;
					
					/// <summary>Callback for [T:vl.presentation.controls.list.ListViewColumnItemArranger.IColumnItemView]. Column item view use this interface to notify column related modification.</summary>
					class IColumnItemViewCallback : public virtual IDescriptable, public Description<IColumnItemViewCallback>
					{
					public:
						/// <summary>Called when any column object is changed (inserted, removed, updated binding, etc.).</summary>
						virtual void							OnColumnRebuilt()=0;

						/// <summary>Called when any property of a column is changed (size changed, text changed, etc.).</summary>
						virtual void							OnColumnChanged(bool needToRefreshItems)=0;
					};
					
					/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for <see cref="ListViewColumnItemArranger"/>.</summary>
					class IColumnItemView : public virtual IDescriptable, public Description<IColumnItemView>
					{
					public:
						/// <summary>The identifier for this view.</summary>
						static const wchar_t* const								Identifier;
						
						/// <summary>Attach an column item view callback to this view.</summary>
						/// <returns>Returns true if this operation succeeded.</returns>
						/// <param name="value">The column item view callback.</param>
						virtual bool											AttachCallback(IColumnItemViewCallback* value)=0;
						/// <summary>Detach an column item view callback from this view.</summary>
						/// <returns>Returns true if this operation succeeded.</returns>
						/// <param name="value">The column item view callback.</param>
						virtual bool											DetachCallback(IColumnItemViewCallback* value)=0;

						/// <summary>Get the size of the column.</summary>
						/// <returns>The size of the column.</returns>
						/// <param name="index">The index of the column.</param>
						virtual vint											GetColumnSize(vint index)=0;
						/// <summary>Set the size of the column.</summary>
						/// <param name="index">The index of the column.</param>
						/// <param name="value">The new size of the column.</param>
						virtual void											SetColumnSize(vint index, vint value)=0;

						/// <summary>Get the popup binded to the column.</summary>
						/// <returns>The popup binded to the column.</returns>
						/// <param name="index">The index of the column.</param>
						virtual GuiMenu*										GetDropdownPopup(vint index)=0;
						/// <summary>Get the sorting state of the column.</summary>
						/// <returns>The sorting state of the column.</returns>
						/// <param name="index">The index of the column.</param>
						virtual ColumnSortingState								GetSortingState(vint index)=0;
					};
				protected:
					class ColumnItemViewCallback : public Object, public virtual IColumnItemViewCallback
					{
					protected:
						ListViewColumnItemArranger*				arranger = nullptr;

					public:
						ColumnItemViewCallback(ListViewColumnItemArranger* _arranger);
						~ColumnItemViewCallback();

						void									OnColumnRebuilt() override;
						void									OnColumnChanged(bool needToRefreshItems) override;
					};

					class ColumnItemArrangerRepeatComposition : public TBase::ArrangerRepeatComposition
					{
					protected:
						ListViewColumnItemArranger*				arranger = nullptr;

						void									Layout_EndLayout(bool totalSizeUpdated) override;
						void									Layout_CalculateTotalSize(Size& full, Size& minimum) override;
					public:
						ColumnItemArrangerRepeatComposition(ListViewColumnItemArranger* _arranger);
					};

					GuiListViewBase*							listView = nullptr;
					IListViewItemView*							listViewItemView = nullptr;
					IColumnItemView*							columnItemView = nullptr;
					Ptr<ColumnItemViewCallback>					columnItemViewCallback;
					compositions::GuiStackComposition*			columnHeaders = nullptr;
					ColumnHeaderButtonList						columnHeaderButtons;
					ColumnHeaderSplitterList					columnHeaderSplitters;
					bool										splitterDragging = false;
					vint										splitterLatestX = 0;

					void										OnViewLocationChanged(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);
					void										ColumnClicked(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnCachedBoundsChanged(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeadersCachedBoundsChanged(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);

					void										FixColumnsAfterViewLocationChanged();
					void										FixColumnsAfterLayout();
					vint										GetColumnsWidth();
					vint										GetColumnsYOffset();
					void										DeleteColumnButtons();
					void										RebuildColumns();
					void										UpdateRepeatConfig();
					void										RefreshColumns();
				public:
					ListViewColumnItemArranger();
					~ListViewColumnItemArranger();

					Size										GetTotalSize()override;
					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
				};
			}

/***********************************************************************
ListViewItemProvider
***********************************************************************/

			namespace list
			{
				class ListViewItem;

				class ListViewSubItems : public collections::ObservableListBase<WString>
				{
					friend class ListViewItem;
				protected:
					ListViewItem*									owner;
					
					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
				};

				class ListViewItemProvider;

				/// <summary>List view item.</summary>
				class ListViewItem : public Object, public Description<ListViewItem>
				{
					friend class ListViewSubItems;
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*							owner;
					ListViewSubItems								subItems;
					Ptr<GuiImageData>								smallImage;
					Ptr<GuiImageData>								largeImage;
					WString											text;
					description::Value								tag;
					
					void											NotifyUpdate();
				public:
					/// <summary>Create a list view item.</summary>
					ListViewItem();
					
					/// <summary>Get all sub items of this item.</summary>
					/// <returns>All sub items of this item.</returns>
					ListViewSubItems&								GetSubItems();
					/// <summary>Get the small image of this item.</summary>
					/// <returns>The small image of this item.</returns>
					Ptr<GuiImageData>								GetSmallImage();
					/// <summary>Set the small image of this item.</summary>
					/// <param name="value">The small image of this item.</param>
					void											SetSmallImage(Ptr<GuiImageData> value);
					/// <summary>Get the large image of this item.</summary>
					/// <returns>The large image of this item.</returns>
					Ptr<GuiImageData>								GetLargeImage();
					/// <summary>Set the large image of this item.</summary>
					/// <param name="value">The large image of this item.</param>
					void											SetLargeImage(Ptr<GuiImageData> value);
					/// <summary>Get the text of this item.</summary>
					/// <returns>The text of this item.</returns>
					const WString&									GetText();
					/// <summary>Set the text of this item.</summary>
					/// <param name="value">The text of this item.</param>
					void											SetText(const WString& value);
					/// <summary>Get the tag of this item.</summary>
					/// <returns>The tag of this item.</returns>
					description::Value								GetTag();
					/// <summary>Set the tag of this item.</summary>
					/// <param name="value">The tag of this item.</param>
					void											SetTag(const description::Value& value);
				};

				class ListViewColumns;
				
				/// <summary>List view column.</summary>
				class ListViewColumn : public Object, public Description<ListViewColumn>
				{
					friend class ListViewColumns;
				protected:
					ListViewColumns*								owner = nullptr;
					WString											text;
					ItemProperty<WString>							textProperty;
					vint											size;
					bool											ownPopup = true;
					GuiMenu*										dropdownPopup = nullptr;
					ColumnSortingState								sortingState = ColumnSortingState::NotSorted;
					
					void											NotifyRebuilt();
					void											NotifyChanged(bool needToRefreshItems);
				public:
					/// <summary>Create a column with the specified text and size.</summary>
					/// <param name="_text">The specified text.</param>
					/// <param name="_size">The specified size.</param>
					ListViewColumn(const WString& _text=L"", vint _size=160);
					~ListViewColumn();
					
					/// <summary>Get the text of this item.</summary>
					/// <returns>The text of this item.</returns>
					const WString&									GetText();
					/// <summary>Set the text of this item.</summary>
					/// <param name="value">The text of this item.</param>
					void											SetText(const WString& value);
					/// <summary>Get the text property of this item.</summary>
					/// <returns>The text property of this item.</returns>
					ItemProperty<WString>							GetTextProperty();
					/// <summary>Set the text property of this item.</summary>
					/// <param name="value">The text property of this item.</param>
					void											SetTextProperty(const ItemProperty<WString>& value);
					/// <summary>Get the size of this item.</summary>
					/// <returns>The size of this item.</returns>
					vint											GetSize();
					/// <summary>Set the size of this item.</summary>
					/// <param name="value">The size of this item.</param>
					void											SetSize(vint value);
					/// <summary>Test if the column owns the popup. Owned popup will be deleted in the destructor.</summary>
					/// <returns>Returns true if the column owns the popup.</returns>
					bool											GetOwnPopup();
					/// <summary>Set if the column owns the popup.</summary>
					/// <param name="value">Set to true to let the column own the popup.</param>
					void											SetOwnPopup(bool value);
					/// <summary>Get the dropdown context menu of this item.</summary>
					/// <returns>The dropdown context menu of this item.</returns>
					GuiMenu*										GetDropdownPopup();
					/// <summary>Set the dropdown context menu of this item.</summary>
					/// <param name="value">The dropdown context menu of this item.</param>
					void											SetDropdownPopup(GuiMenu* value);
					/// <summary>Get the sorting state of this item.</summary>
					/// <returns>The sorting state of this item.</returns>
					ColumnSortingState								GetSortingState();
					/// <summary>Set the sorting state of this item.</summary>
					/// <param name="value">The sorting state of this item.</param>
					void											SetSortingState(ColumnSortingState value);
				};

				class IListViewItemProvider : public virtual Interface
				{
				public:
					virtual void									RebuildAllItems() = 0;
					virtual void									RefreshAllItems() = 0;
					virtual void									NotifyColumnRebuilt() = 0;
					virtual void									NotifyColumnChanged() = 0;
				};

				/// <summary>List view data column container.</summary>
				class ListViewDataColumns : public collections::ObservableListBase<vint>
				{
				protected:
					IListViewItemProvider*							itemProvider;

					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					/// <summary>Create a container.</summary>
					/// <param name="_itemProvider">The item provider in the same control to receive notifications.</param>
					ListViewDataColumns(IListViewItemProvider* _itemProvider);
					~ListViewDataColumns();
				};
				
				/// <summary>List view column container.</summary>
				class ListViewColumns : public collections::ObservableListBase<Ptr<ListViewColumn>>
				{
					friend class ListViewColumn;
				protected:
					IListViewItemProvider*							itemProvider;
					bool											affectItemFlag = true;

					void											NotifyColumnRebuilt(vint column);
					void											NotifyColumnChanged(vint column, bool needToRefreshItems);
					void											AfterInsert(vint index, const Ptr<ListViewColumn>& value)override;
					void											BeforeRemove(vint index, const Ptr<ListViewColumn>& value)override;
					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					/// <summary>Create a container.</summary>
					/// <param name="_itemProvider">The item provider in the same control to receive notifications.</param>
					ListViewColumns(IListViewItemProvider* _itemProvider);
					~ListViewColumns();
				};
				
				/// <summary>Item provider for <see cref="GuiListViewBase"/>.</summary>
				class ListViewItemProvider
					: public ListProvider<Ptr<ListViewItem>>
					, protected virtual IListViewItemProvider
					, public virtual IListViewItemView
					, public virtual ListViewColumnItemArranger::IColumnItemView
					, public Description<ListViewItemProvider>
				{
					friend class ListViewItem;
					friend class ListViewColumns;
					friend class ListViewDataColumns;
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					ListViewDataColumns									dataColumns;
					ListViewColumns										columns;
					ColumnItemViewCallbackList							columnItemViewCallbacks;

					void												AfterInsert(vint index, const Ptr<ListViewItem>& value)override;
					void												BeforeRemove(vint index, const Ptr<ListViewItem>& value)override;

					// ===================== list::IListViewItemProvider =====================

					void												RebuildAllItems() override;
					void												RefreshAllItems() override;
					void												NotifyColumnRebuilt() override;
					void												NotifyColumnChanged() override;

				public:
					ListViewItemProvider();
					~ListViewItemProvider();

					// ===================== GuiListControl::IItemProvider =====================

					WString												GetTextValue(vint itemIndex)override;
					description::Value									GetBindingValue(vint itemIndex)override;
					IDescriptable*										RequestView(const WString& identifier)override;

					// ===================== list::ListViewItemStyleProvider::IListViewItemView =====================

					Ptr<GuiImageData>									GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(vint itemIndex)override;
					WString												GetText(vint itemIndex)override;
					WString												GetSubItem(vint itemIndex, vint index)override;
					vint												GetDataColumnCount()override;
					vint												GetDataColumn(vint index)override;
					vint												GetColumnCount()override;
					WString												GetColumnText(vint index)override;

					// ===================== list::ListViewColumnItemArranger::IColumnItemView =====================

					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint												GetColumnSize(vint index)override;
					void												SetColumnSize(vint index, vint value)override;
					GuiMenu*											GetDropdownPopup(vint index)override;
					ColumnSortingState									GetSortingState(vint index)override;

					/// <summary>Get all data columns indices in columns.</summary>
					/// <returns>All data columns indices in columns.</returns>
					ListViewDataColumns&								GetDataColumns();
					/// <summary>Get all columns.</summary>
					/// <returns>All columns.</returns>
					ListViewColumns&									GetColumns();
				};
			}

/***********************************************************************
GuiVirtualListView
***********************************************************************/

			enum class ListViewView
			{
				BigIcon,
				SmallIcon,
				List,
				Tile,
				Information,
				Detail,
				Unknown,
			};
			
			/// <summary>List view control in virtual mode.</summary>
			class GuiVirtualListView : public GuiListViewBase, public Description<GuiVirtualListView>
			{
			protected:
				ListViewView											view = ListViewView::Unknown;

				void													OnStyleInstalled(vint itemIndex, ItemStyle* style, bool refreshPropertiesOnly)override;
				void													OnItemTemplateChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a list view control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiVirtualListView(theme::ThemeName themeName, list::IItemProvider* _itemProvider);
				~GuiVirtualListView();

				/// <summary>Get the current view.</summary>
				/// <returns>The current view. After [M:vl.presentation.controls.GuiListControl.SetItemTemplate] is called, the current view is reset to Unknown.</returns>
				ListViewView											GetView();
				/// <summary>Set the current view.</summary>
				/// <param name="_view">The current view.</param>
				void													SetView(ListViewView _view);
			};

/***********************************************************************
GuiListView
***********************************************************************/
			
			/// <summary>List view control in virtual mode.</summary>
			class GuiListView : public GuiVirtualListView, public Description<GuiListView>
			{
			protected:
				list::ListViewItemProvider*								items;
			public:
				/// <summary>Create a list view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiListView(theme::ThemeName themeName);
				~GuiListView();
				
				/// <summary>Get all list view items.</summary>
				/// <returns>All list view items.</returns>
				list::ListViewItemProvider&								GetItems();
				/// <summary>Get all data columns indices in columns.</summary>
				/// <returns>All data columns indices in columns.</returns>
				list::ListViewDataColumns&								GetDataColumns();
				/// <summary>Get all columns.</summary>
				/// <returns>All columns.</returns>
				list::ListViewColumns&									GetColumns();

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				Ptr<list::ListViewItem>									GetSelectedItem();
			};
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIBINDABLELISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBINDABLELISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBINDABLELISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			template<typename T>
			struct DefaultValueOf
			{
				static T Get()
				{
					return reflection::description::TypedValueSerializerProvider<T>::GetDefaultValue();
				}
			};

			template<typename T>
			struct DefaultValueOf<Ptr<T>>
			{
				static Ptr<T> Get()
				{
					return nullptr;
				}
			};

			template<>
			struct DefaultValueOf<description::Value>
			{
				static description::Value Get()
				{
					return description::Value();
				}
			};

			template<typename T>
			T ReadProperty(const description::Value& thisObject, const ItemProperty<T>& propertyName)
			{
				if (!thisObject.IsNull() && propertyName)
				{
					return propertyName(thisObject);
				}
				else
				{
					return DefaultValueOf<T>::Get();
				}
			}

			template<typename T>
			T ReadProperty(const description::Value& thisObject, const WritableItemProperty<T>& propertyName)
			{
				auto defaultValue = DefaultValueOf<T>::Get();
				if (!thisObject.IsNull() && propertyName)
				{
					return propertyName(thisObject, defaultValue, false);
				}
				else
				{
					return defaultValue;
				}
			}

			template<typename T>
			void WriteProperty(const description::Value& thisObject, const WritableItemProperty<T>& propertyName, const T& value)
			{
				if (!thisObject.IsNull() && propertyName)
				{
					propertyName(thisObject, value, true);
				}
			}

/***********************************************************************
GuiBindableTextList
***********************************************************************/

			/// <summary>A bindable Text list control.</summary>
			class GuiBindableTextList : public GuiVirtualTextList, public Description<GuiBindableTextList>
			{
			public:
				class ItemSource
					: public list::ItemProviderBase
					, protected list::ITextItemView
					, public Description<ItemSource>
				{
				protected:
					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			itemSource;

				public:
					ItemProperty<WString>							textProperty;
					WritableItemProperty<bool>						checkedProperty;

				public:
					ItemSource();
					~ItemSource();

					Ptr<description::IValueEnumerable>				GetItemSource();
					void											SetItemSource(Ptr<description::IValueEnumerable> _itemSource);

					description::Value								Get(vint index);
					void											UpdateBindingProperties();
					bool											NotifyUpdate(vint start, vint count, bool itemReferenceUpdated);
					
					// ===================== GuiListControl::IItemProvider =====================

					WString											GetTextValue(vint itemIndex)override;
					description::Value								GetBindingValue(vint itemIndex)override;
					vint											Count()override;
					IDescriptable*									RequestView(const WString& identifier)override;
					
					// ===================== list::TextItemStyleProvider::ITextItemView =====================

					bool											GetChecked(vint itemIndex)override;
					void											SetChecked(vint itemIndex, bool value)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				/// <summary>Create a bindable Text list control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableTextList(theme::ThemeName themeName);
				~GuiBindableTextList();
				
				/// <summary>Text property name changed event.</summary>
				compositions::GuiNotifyEvent						TextPropertyChanged;
				/// <summary>Checked property name changed event.</summary>
				compositions::GuiNotifyEvent						CheckedPropertyChanged;

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<description::IValueEnumerable>					GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
				
				/// <summary>Get the text property name to get the item text from an item.</summary>
				/// <returns>The text property name.</returns>
				ItemProperty<WString>								GetTextProperty();
				/// <summary>Set the text property name to get the item text from an item.</summary>
				/// <param name="value">The text property name.</param>
				void												SetTextProperty(const ItemProperty<WString>& value);
				
				/// <summary>Get the checked property name to get the check state from an item.</summary>
				/// <returns>The checked property name.</returns>
				WritableItemProperty<bool>							GetCheckedProperty();
				/// <summary>Set the checked property name to get the check state from an item.</summary>
				/// <param name="value">The checked property name.</param>
				void												SetCheckedProperty(const WritableItemProperty<bool>& value);

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedItem();

				/// <summary>Notify the control that data in some items are modified.</summary>
				/// <param name="start">The index of the first item.</param>
				/// <param name="count">The number of items</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												NotifyItemDataModified(vint start, vint count);
			};

/***********************************************************************
GuiBindableListView
***********************************************************************/
			
			/// <summary>A bindable List view control.</summary>
			class GuiBindableListView : public GuiVirtualListView, public Description<GuiBindableListView>
			{
			public:
				class ItemSource
					: public list::ItemProviderBase
					, protected virtual list::IListViewItemProvider
					, public virtual list::IListViewItemView
					, public virtual list::ListViewColumnItemArranger::IColumnItemView
					, public Description<ItemSource>
				{
					typedef collections::List<list::ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					list::ListViewDataColumns						dataColumns;
					list::ListViewColumns							columns;
					ColumnItemViewCallbackList						columnItemViewCallbacks;
					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			itemSource;

				public:
					ItemProperty<Ptr<GuiImageData>>					largeImageProperty;
					ItemProperty<Ptr<GuiImageData>>					smallImageProperty;

				public:
					ItemSource();
					~ItemSource();

					Ptr<description::IValueEnumerable>				GetItemSource();
					void											SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
					
					description::Value								Get(vint index);
					void											UpdateBindingProperties();
					bool											NotifyUpdate(vint start, vint count, bool itemReferenceUpdated);
					list::ListViewDataColumns&						GetDataColumns();
					list::ListViewColumns&							GetColumns();
					
					// ===================== list::IListViewItemProvider =====================

					void											RebuildAllItems() override;
					void											RefreshAllItems() override;
					void											NotifyColumnRebuilt() override;
					void											NotifyColumnChanged() override;
					
					// ===================== GuiListControl::IItemProvider =====================

					WString											GetTextValue(vint itemIndex)override;
					description::Value								GetBindingValue(vint itemIndex)override;
					vint											Count()override;
					IDescriptable*									RequestView(const WString& identifier)override;

					// ===================== list::ListViewItemStyleProvider::IListViewItemView =====================

					Ptr<GuiImageData>								GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>								GetLargeImage(vint itemIndex)override;
					WString											GetText(vint itemIndex)override;
					WString											GetSubItem(vint itemIndex, vint index)override;
					vint											GetDataColumnCount()override;
					vint											GetDataColumn(vint index)override;
					vint											GetColumnCount()override;
					WString											GetColumnText(vint index)override;

					// ===================== list::ListViewColumnItemArranger::IColumnItemView =====================
						
					bool											AttachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool											DetachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint											GetColumnSize(vint index)override;
					void											SetColumnSize(vint index, vint value)override;
					GuiMenu*										GetDropdownPopup(vint index)override;
					ColumnSortingState								GetSortingState(vint index)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				/// <summary>Create a bindable List view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableListView(theme::ThemeName themeName);
				~GuiBindableListView();

				/// <summary>Get all data columns indices in columns.</summary>
				/// <returns>All data columns indices in columns.</returns>
				list::ListViewDataColumns&							GetDataColumns();
				/// <summary>Get all columns.</summary>
				/// <returns>All columns.</returns>
				list::ListViewColumns&								GetColumns();

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<description::IValueEnumerable>					GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
				
				/// <summary>Large image property name changed event.</summary>
				compositions::GuiNotifyEvent						LargeImagePropertyChanged;
				/// <summary>Small image property name changed event.</summary>
				compositions::GuiNotifyEvent						SmallImagePropertyChanged;
				
				/// <summary>Get the large image property name to get the large image from an item.</summary>
				/// <returns>The large image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetLargeImageProperty();
				/// <summary>Set the large image property name to get the large image from an item.</summary>
				/// <param name="value">The large image property name.</param>
				void												SetLargeImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);
				
				/// <summary>Get the small image property name to get the small image from an item.</summary>
				/// <returns>The small image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetSmallImageProperty();
				/// <summary>Set the small image property name to get the small image from an item.</summary>
				/// <param name="value">The small image property name.</param>
				void												SetSmallImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedItem();

				/// <summary>Notify the control that data in some items are modified.</summary>
				/// <param name="start">The index of the first item.</param>
				/// <param name="count">The number of items</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												NotifyItemDataModified(vint start, vint count);
			};

/***********************************************************************
GuiBindableTreeView
***********************************************************************/
			
			/// <summary>A bindable Tree view control.</summary>
			class GuiBindableTreeView : public GuiVirtualTreeView, public Description<GuiBindableTreeView>
			{
				using IValueEnumerable = reflection::description::IValueEnumerable;
			public:
				class ItemSource;

				class ItemSourceNode
					: public Object
					, public virtual tree::INodeProvider
				{
					friend class ItemSource;
					typedef collections::List<Ptr<ItemSourceNode>>	NodeList;
				protected:
					description::Value								itemSource;
					ItemSource*										rootProvider;
					ItemSourceNode*									parent;
					tree::INodeProviderCallback*					callback;
					bool											expanding = false;

					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			childrenVirtualList;
					NodeList										children;

					Ptr<description::IValueReadonlyList>			PrepareValueList(const description::Value& inputItemSource);
					void											PrepareChildren(Ptr<description::IValueReadonlyList> newValueList);
					void											UnprepareChildren();
					void											PrepareReverseMapping();
					void											UnprepareReverseMapping();
				public:
					ItemSourceNode(const description::Value& _itemSource, ItemSourceNode* _parent);
					ItemSourceNode(ItemSource* _rootProvider);
					~ItemSourceNode();

					description::Value								GetItemSource();
					void											SetItemSource(const description::Value& _itemSource);

					// ===================== tree::INodeProvider =====================

					bool											GetExpanding()override;
					void											SetExpanding(bool value)override;
					vint											CalculateTotalVisibleNodes()override;
					void											NotifyDataModified()override;

					vint											GetChildCount()override;
					Ptr<tree::INodeProvider>						GetParent()override;
					Ptr<tree::INodeProvider>						GetChild(vint index)override;
				};

				class ItemSource
					: public tree::NodeRootProviderBase
					, public virtual tree::ITreeViewItemView
					, public Description<ItemSource>
				{
					friend class ItemSourceNode;
				public:
					WritableItemProperty<description::Value>		reverseMappingProperty;
					ItemProperty<WString>							textProperty;
					ItemProperty<Ptr<GuiImageData>>					imageProperty;
					ItemProperty<Ptr<IValueEnumerable>>				childrenProperty;
					Ptr<ItemSourceNode>								rootNode;

				public:
					ItemSource();
					~ItemSource();

					description::Value								GetItemSource();
					void											SetItemSource(const description::Value& _itemSource);

					void											UpdateBindingProperties(bool updateChildrenProperty);

					// ===================== tree::INodeRootProvider =====================

					Ptr<tree::INodeProvider>						GetRootNode()override;
					WString											GetTextValue(tree::INodeProvider* node)override;
					description::Value								GetBindingValue(tree::INodeProvider* node)override;
					IDescriptable*									RequestView(const WString& identifier)override;

					// ===================== tree::ITreeViewItemView =====================

					Ptr<GuiImageData>								GetNodeImage(tree::INodeProvider* node)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				/// <summary>Create a bindable Tree view control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="reverseMappingProperty">(Optional): The value of <see cref="GuiBindableTreeView::GetReverseMappingProperty"/>.</param>
				GuiBindableTreeView(theme::ThemeName themeName, WritableItemProperty<description::Value> reverseMappingProperty = {});
				~GuiBindableTreeView();
				
				/// <summary>Text property name changed event.</summary>
				compositions::GuiNotifyEvent						TextPropertyChanged;
				/// <summary>Image property name changed event.</summary>
				compositions::GuiNotifyEvent						ImagePropertyChanged;
				/// <summary>Children property name changed event.</summary>
				compositions::GuiNotifyEvent						ChildrenPropertyChanged;

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				description::Value									GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(description::Value _itemSource);

				/// <summary>
				/// Get the reverse mapping property name to store the internal tree view node for an item.
				/// The value is set in the constructor.
				/// Using this property makes items in item source exclusive to a treeview control.
				/// Sharing such item in different treeview controls causes exceptions.
				/// </summary>
				/// <returns>The reverse mapping property name.</returns>
				WritableItemProperty<description::Value>			GetReverseMappingProperty();
				
				/// <summary>Get the text property name to get the item text from an item.</summary>
				/// <returns>The text property name.</returns>
				ItemProperty<WString>								GetTextProperty();
				/// <summary>Set the text property name to get the item text from an item.</summary>
				/// <param name="value">The text property name.</param>
				void												SetTextProperty(const ItemProperty<WString>& value);
				
				/// <summary>Get the image property name to get the image from an item.</summary>
				/// <returns>The image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetImageProperty();
				/// <summary>Set the image property name to get the image from an item.</summary>
				/// <param name="value">The image property name.</param>
				void												SetImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);
				
				/// <summary>Get the children property name to get the children from an item.</summary>
				/// <returns>The children property name.</returns>
				ItemProperty<Ptr<IValueEnumerable>>					GetChildrenProperty();
				/// <summary>Set the children property name to get the children from an item.</summary>
				/// <param name="value">The children property name.</param>
				void												SetChildrenProperty(const ItemProperty<Ptr<IValueEnumerable>>& value);

				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedItem();

				/// <summary>Notify the control that data in an item is modified. Child nodes are not notified.</summary>
				/// <param name="value">The item from the item source.</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				void												NotifyNodeDataModified(description::Value value);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDINTERFACES
#define VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDINTERFACES


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{

/***********************************************************************
Datagrid Interfaces
***********************************************************************/

				class IDataVisualizer;
				class IDataEditor;

				/// <summary>The data grid context.</summary>
				class IDataGridContext : public virtual IDescriptable, public Description<IDataGridContext>
				{
				public:
					virtual list::IItemProvider*						GetItemProvider() = 0;
					virtual templates::GuiListViewTemplate*				GetListViewControlTemplate() = 0;
					virtual void										RequestSaveData() = 0;
				};

				/// <summary>The visualizer factory.</summary>
				class IDataVisualizerFactory : public virtual IDescriptable, public Description<IDataVisualizerFactory>
				{
				public:
					/// <summary>Create a data visualizer.</summary>
					/// <returns>The created data visualizer.</returns>
					/// <param name="dataGridContext">Context information of the data grid.</param>
					virtual Ptr<IDataVisualizer>						CreateVisualizer(IDataGridContext* dataGridContext) = 0;
				};

				/// <summary>The visualizer for each cell in [T:vl.presentation.controls.GuiVirtualDataGrid].</summary>
				class IDataVisualizer : public virtual IDescriptable, public Description<IDataVisualizer>
				{
				public:
					/// <summary>Get the factory object that creates this visualizer.</summary>
					/// <returns>The factory object.</returns>
					virtual IDataVisualizerFactory*						GetFactory() = 0;

					/// <summary>Get the template that renders the data. The data visualizer should maintain this template, and delete it when necessary.</summary>
					/// <returns>The template.</returns>
					virtual templates::GuiGridVisualizerTemplate*		GetTemplate() = 0;
					/// <summary>Notify that the template has been deleted during the deconstruction of UI objects.</summary>
					virtual void										NotifyDeletedTemplate() = 0;

					/// <summary>Called before visualizing a cell.</summary>
					/// <param name="itemProvider">The item provider.</param>
					/// <param name="row">The row number of the cell.</param>
					/// <param name="column">The column number of the cell.</param>
					virtual void										BeforeVisualizeCell(list::IItemProvider* itemProvider, vint row, vint column) = 0;

					/// <summary>Set the selected state.</summary>
					/// <param name="value">Set to true to make this data visualizer looks selected.</param>
					virtual void										SetSelected(bool value) = 0;
				};

				/// <summary>The editor factory.</summary>
				class IDataEditorFactory : public virtual IDescriptable, public Description<IDataEditorFactory>
				{
				public:
					/// <summary>Create a data editor.</summary>
					/// <returns>The created data editor.</returns>
					/// <param name="dataGridContext">Context information of the data grid.</param>
					virtual Ptr<IDataEditor>							CreateEditor(IDataGridContext* dataGridContext) = 0;
				};

				/// <summary>The editor for each cell in [T:vl.presentation.controls.GuiVirtualDataGrid].</summary>
				class IDataEditor : public virtual IDescriptable, public Description<IDataEditor>
				{
				public:
					/// <summary>Get the factory object that creates this editor.</summary>
					/// <returns>The factory object.</returns>
					virtual IDataEditorFactory*							GetFactory() = 0;

					/// <summary>Get the template that edit the data. The data editor should maintain this template, and delete it when necessary.</summary>
					/// <returns>The template.</returns>
					virtual templates::GuiGridEditorTemplate*			GetTemplate() = 0;
					/// <summary>Notify that the template has been deleted during the deconstruction of UI objects.</summary>
					virtual void										NotifyDeletedTemplate() = 0;

					/// <summary>Called before editing a cell.</summary>
					/// <param name="itemProvider">The item provider.</param>
					/// <param name="row">The row number of the cell.</param>
					/// <param name="column">The column number of the cell.</param>
					virtual void										BeforeEditCell(list::IItemProvider* itemProvider, vint row, vint column) = 0;

					/// <summary>Test if the edit has saved the data.</summary>
					/// <returns>Returns true if the data is saved.</returns>
					virtual bool										GetCellValueSaved() = 0;
				};

				/// <summary>The required <see cref="GuiListControl::IItemProvider"/> view for [T:vl.presentation.controls.GuiVirtualDataGrid].</summary>
				class IDataGridView : public virtual IDescriptable, public Description<IDataGridView>
				{
				public:
					/// <summary>The identifier for this view.</summary>
					static const wchar_t* const							Identifier;

					/// <summary>Test is a column sortable.</summary>
					/// <returns>Returns true if this column is sortable.</returns>
					/// <param name="column">The index of the column.</param>
					virtual bool										IsColumnSortable(vint column) = 0;
					/// <summary>Set the column sorting state to update the data.</summary>
					/// <param name="column">The index of the column. Set to -1 means go back to the unsorted state.</param>
					/// <param name="ascending">Set to true if the data is sorted in ascending order.</param>
					virtual void										SortByColumn(vint column, bool ascending) = 0;
					/// <summary>Get the sorted columm. If no column is under a sorted state, it returns -1.</summary>
					/// <returns>The column number.</returns>
					virtual vint										GetSortedColumn() = 0;
					/// <summary>Test is the sort order ascending. </summary>
					/// <returns>Returns true if the sort order is ascending.</returns>
					virtual bool										IsSortOrderAscending() = 0;

					/// <summary>Get the column span for the cell.</summary>
					/// <returns>The column span for the cell.</returns>
					/// <param name="row">The row number for the cell.</param>
					/// <param name="column">The column number for the cell.</param>
					virtual vint										GetCellSpan(vint row, vint column) = 0;
					/// <summary>Get the data visualizer factory that creates data visualizers for visualizing the cell.</summary>
					/// <returns>The data visualizer factory. The data grid control to use the predefined data visualizer if this function returns null.</returns>
					/// <param name="row">The row number for the cell.</param>
					/// <param name="column">The column number for the cell.</param>
					virtual IDataVisualizerFactory*						GetCellDataVisualizerFactory(vint row, vint column) = 0;
					/// <summary>Get the data editor factory that creates data editors for editing the cell.</summary>
					/// <returns>The data editor factory. Returns null to disable editing.</returns>
					/// <param name="row">The row number for the cell.</param>
					/// <param name="column">The column number for the cell.</param>
					virtual IDataEditorFactory*							GetCellDataEditorFactory(vint row, vint column) = 0;
					/// <summary>Get the binding value of a cell.</summary>
					/// <returns>The binding value of cell.</returns>
					/// <param name="row">The row index of the cell.</param>
					/// <param name="column">The column index of the cell.</param>
					virtual description::Value							GetBindingCellValue(vint row, vint column) = 0;
					/// <summary>Set the binding value of a cell.</summary>
					/// <param name="row">The row index of the cell.</param>
					/// <param name="column">The column index of the cell.</param>
					/// <param name="value">The value to set.</param>
					virtual void										SetBindingCellValue(vint row, vint column, const description::Value& value) = 0;
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDEXTENSIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAEXTENSIONS
#define VCZH_PRESENTATION_CONTROLS_GUIDATAEXTENSIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{

/***********************************************************************
Extension Bases
***********************************************************************/

				class DataVisualizerFactory;
				class DataEditorFactory;
				
				/// <summary>Base class for all data visualizers.</summary>
				class DataVisualizerBase : public Object, public virtual IDataVisualizer
				{
					friend class DataVisualizerFactory;
					using ItemTemplate = templates::GuiGridVisualizerTemplate;
				protected:
					DataVisualizerFactory*								factory = nullptr;
					IDataGridContext*									dataGridContext = nullptr;
					templates::GuiGridVisualizerTemplate*				visualizerTemplate = nullptr;

				public:
					/// <summary>Create the data visualizer.</summary>
					DataVisualizerBase();
					~DataVisualizerBase();

					IDataVisualizerFactory*								GetFactory()override;
					templates::GuiGridVisualizerTemplate*				GetTemplate()override;
					void												NotifyDeletedTemplate()override;
					void												BeforeVisualizeCell(list::IItemProvider* itemProvider, vint row, vint column)override;
					void												SetSelected(bool value)override;
				};
				
				class DataVisualizerFactory : public Object, public virtual IDataVisualizerFactory, public Description<DataVisualizerFactory>
				{
					using ItemTemplate = templates::GuiGridVisualizerTemplate;
				protected:
					TemplateProperty<ItemTemplate>						templateFactory;
					Ptr<DataVisualizerFactory>							decoratedFactory;

					ItemTemplate*										CreateItemTemplate(controls::list::IDataGridContext* dataGridContext);
				public:
					DataVisualizerFactory(TemplateProperty<ItemTemplate> _templateFactory, Ptr<DataVisualizerFactory> _decoratedFactory = nullptr);
					~DataVisualizerFactory();

					Ptr<IDataVisualizer>								CreateVisualizer(IDataGridContext* dataGridContext)override;
				};
				
				/// <summary>Base class for all data editors.</summary>
				class DataEditorBase : public Object, public virtual IDataEditor
				{
					friend class DataEditorFactory;
					using ItemTemplate = templates::GuiGridEditorTemplate;
				protected:
					IDataEditorFactory*									factory = nullptr;
					IDataGridContext*									dataGridContext = nullptr;
					templates::GuiGridEditorTemplate*					editorTemplate = nullptr;

					void												OnCellValueChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					/// <summary>Create the data editor.</summary>
					DataEditorBase();
					~DataEditorBase();

					IDataEditorFactory*									GetFactory()override;
					templates::GuiGridEditorTemplate*					GetTemplate()override;
					void												NotifyDeletedTemplate()override;
					void												BeforeEditCell(list::IItemProvider* itemProvider, vint row, vint column)override;
					bool												GetCellValueSaved()override;
				};
				
				class DataEditorFactory : public Object, public virtual IDataEditorFactory, public Description<DataEditorFactory>
				{
					using ItemTemplate = templates::GuiGridEditorTemplate;
				protected:
					TemplateProperty<ItemTemplate>						templateFactory;

				public:
					DataEditorFactory(TemplateProperty<ItemTemplate> _templateFactory);
					~DataEditorFactory();

					Ptr<IDataEditor>									CreateEditor(IDataGridContext* dataGridContext)override;
				};

/***********************************************************************
Visualizer Extensions
***********************************************************************/

				class MainColumnVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<MainColumnVisualizerTemplate>
				{
				protected:
					elements::GuiImageFrameElement*						image = nullptr;
					elements::GuiSolidLabelElement*						text = nullptr;

					void												OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnSmallImageChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					MainColumnVisualizerTemplate();
					~MainColumnVisualizerTemplate();
				};

				class SubColumnVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<SubColumnVisualizerTemplate>
				{
				protected:
					elements::GuiSolidLabelElement*						text = nullptr;

					void												OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												OnTextColorChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												Initialize(bool fixTextColor);

					SubColumnVisualizerTemplate(bool fixTextColor);
				public:
					SubColumnVisualizerTemplate();
					~SubColumnVisualizerTemplate();
				};

				class HyperlinkVisualizerTemplate : public SubColumnVisualizerTemplate, public Description<HyperlinkVisualizerTemplate>
				{
				protected:
					void												label_MouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												label_MouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				public:
					HyperlinkVisualizerTemplate();
					~HyperlinkVisualizerTemplate();
				};

				class FocusRectangleVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<FocusRectangleVisualizerTemplate>
				{
				protected:
					compositions::GuiBoundsComposition*					focusComposition = nullptr;

					void												OnSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				public:
					FocusRectangleVisualizerTemplate();
					~FocusRectangleVisualizerTemplate();
				};

				class CellBorderVisualizerTemplate : public templates::GuiGridVisualizerTemplate, public Description<CellBorderVisualizerTemplate>
				{
				protected:
					elements::GuiSolidBorderElement*					border1 = nullptr;
					elements::GuiSolidBorderElement*					border2 = nullptr;

					void												OnItemSeparatorColorChanged(GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				public:
					CellBorderVisualizerTemplate();
					~CellBorderVisualizerTemplate();
				};
			}
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUILISTVIEWITEMTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWITEMTEMPLATES
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWITEMTEMPLATES


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{
				class DefaultListViewItemTemplate : public PredefinedListItemTemplate<templates::GuiListItemTemplate>
				{
				public:
					DefaultListViewItemTemplate();
					~DefaultListViewItemTemplate();
				};

				class BigIconListViewItemTemplate : public DefaultListViewItemTemplate
				{
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;

					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					BigIconListViewItemTemplate();
					~BigIconListViewItemTemplate();
				};

				class SmallIconListViewItemTemplate : public DefaultListViewItemTemplate
				{
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;

					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					SmallIconListViewItemTemplate();
					~SmallIconListViewItemTemplate();
				};

				class ListListViewItemTemplate : public DefaultListViewItemTemplate
				{
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;

					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					ListListViewItemTemplate();
					~ListListViewItemTemplate();
				};

				class TileListViewItemTemplate : public DefaultListViewItemTemplate
				{
					typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;
					compositions::GuiTableComposition*		textTable = nullptr;
					DataTextElementArray					dataTexts;

					elements::GuiSolidLabelElement*			CreateTextElement(vint textRow);
					void									ResetTextTable(vint dataColumnCount);
					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					TileListViewItemTemplate();
					~TileListViewItemTemplate();
				};

				class InformationListViewItemTemplate : public DefaultListViewItemTemplate
				{
					typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
				protected:
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;
					compositions::GuiTableComposition*		textTable = nullptr;
					DataTextElementArray					columnTexts;
					DataTextElementArray					dataTexts;
					elements::GuiSolidBackgroundElement*	bottomLine = nullptr;
					compositions::GuiBoundsComposition*		bottomLineComposition = nullptr;

					void									ResetTextTable(vint dataColumnCount);
					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					InformationListViewItemTemplate();
					~InformationListViewItemTemplate();
				};

				class DetailListViewItemTemplate
					: public DefaultListViewItemTemplate
				{
					typedef collections::Array<compositions::GuiCellComposition*>	SubItemCellList;
					typedef collections::Array<elements::GuiSolidLabelElement*>		SubItemTestList;
					typedef ListViewColumnItemArranger::IColumnItemView				IColumnItemView;
				protected:
					IColumnItemView*						columnItemView = nullptr;
					elements::GuiImageFrameElement*			image = nullptr;
					elements::GuiSolidLabelElement*			text = nullptr;
					compositions::GuiTableComposition*		textTable = nullptr;
					SubItemCellList							subItemCells;
					SubItemTestList							subItemTexts;

					void									UpdateSubItemSize();
					void									ResetTextTable(vint subColumnCount);
					void									OnInitialize()override;
					void									OnRefresh()override;
					void									OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DetailListViewItemTemplate();
					~DetailListViewItemTemplate();
				};
			}
		}
	}
}

#endif

/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualDataGrid;

			namespace list
			{

/***********************************************************************
DefaultDataGridItemTemplate
***********************************************************************/

				class DefaultDataGridItemTemplate
					: public DefaultListViewItemTemplate
				{
				protected:
					compositions::GuiTableComposition*						textTable = nullptr;
					collections::Array<IDataVisualizerFactory*>				dataVisualizerFactories;
					collections::Array<Ptr<IDataVisualizer>>				dataVisualizers;
					collections::Array<compositions::GuiCellComposition*>	dataCells;
					IDataEditor*											currentEditor = nullptr;

					IDataVisualizerFactory*									GetDataVisualizerFactory(vint row, vint column);
					IDataEditorFactory*										GetDataEditorFactory(vint row, vint column);
					vint													GetCellColumnIndex(compositions::GuiGraphicsComposition* composition);
					bool													IsInEditor(GuiVirtualDataGrid* dataGrid, compositions::GuiMouseEventArgs& arguments);
					void													OnCellButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void													OnCellLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void													OnCellRightButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void													DeleteAllVisualizers();
					void													DeleteVisualizer(vint column);
					void													ResetDataTable(vint columnCount);
					void													OnInitialize()override;
					void													OnRefresh()override;
					void													OnSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void													OnFontChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void													OnContextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void													OnVisuallyEnabledChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					DefaultDataGridItemTemplate();
					~DefaultDataGridItemTemplate();

					void													UpdateSubItemSize();
					bool													IsEditorOpened();
					void													NotifyOpenEditor(vint column, IDataEditor* editor);
					void													NotifyCloseEditor();
					void													NotifySelectCell(vint column);
					void													NotifyCellEdited();
				};
			}

/***********************************************************************
GuiVirtualDataGrid
***********************************************************************/

			/// <summary>Data grid control in virtual mode.</summary>
			class GuiVirtualDataGrid
				: public GuiVirtualListView
				, protected compositions::GuiAltActionHostBase
				, private list::IDataGridContext
				, public Description<GuiVirtualDataGrid>
			{
				friend class list::DefaultDataGridItemTemplate;
			protected:
				list::IListViewItemView*								listViewItemView = nullptr;
				list::ListViewColumnItemArranger::IColumnItemView*		columnItemView = nullptr;
				list::IDataGridView*									dataGridView = nullptr;
				Ptr<list::IDataVisualizerFactory>						defaultMainColumnVisualizerFactory;
				Ptr<list::IDataVisualizerFactory>						defaultSubColumnVisualizerFactory;

				bool													skipOnSelectionChanged = false;
				GridPos													selectedCell{ -1,-1 };
				Ptr<list::IDataEditor>									currentEditor;
				GridPos													currentEditorPos{ -1,-1 };
				bool													currentEditorOpeningEditor = false;

				compositions::IGuiAltActionHost*						GetActivatingAltHost()override;
				void													NotifySelectionChanged(bool triggeredByItemContentModified)override;
				void													OnItemModified(vint start, vint count, vint newCount, bool itemReferenceUpdated)override;
				void													OnStyleInstalled(vint index, ItemStyle* style, bool refreshPropertiesOnly)override;
				void													OnStyleUninstalled(ItemStyle* style)override;

				void													NotifyCloseEditor();
				void													NotifySelectCell(vint row, vint column);
				bool													StartEdit(vint row, vint column);
				void													StopEdit();
				void													OnColumnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void													OnKeyUp(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);

			public:
				templates::GuiListViewTemplate*							GetListViewControlTemplate()override;
				void													RequestSaveData()override;

			public:
				/// <summary>Create a data grid control in virtual mode.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_itemProvider">The item provider for this control.</param>
				GuiVirtualDataGrid(theme::ThemeName themeName, list::IItemProvider* _itemProvider);
				~GuiVirtualDataGrid();

				/// <summary>Selected cell changed event.</summary>
				compositions::GuiNotifyEvent							SelectedCellChanged;

				list::IItemProvider*									GetItemProvider()override;

				/// <summary>Change the view to data grid's default view.</summary>
				void													SetViewToDefault();

				/// <summary>Get the row index and column index of the selected cell.</summary>
				/// <returns>The row index and column index of the selected cell.</returns>
				GridPos													GetSelectedCell();

				/// <summary>Select a cell.</summary>
				/// <returns>Returns true if the editor is opened.</returns>
				/// <param name="value">The row index and column index of the selected cell.</param>
				/// <param name="openEditor">Set to true to open an editor.</param>
				bool													SelectCell(const GridPos& value, bool openEditor);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\LISTCONTROLPACKAGE\GUIBINDABLEDATAGRID.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATASTRUCTURED
#define VCZH_PRESENTATION_CONTROLS_GUIDATASTRUCTURED


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiBindableDataGrid;

			namespace list
			{

/***********************************************************************
Interfaces
***********************************************************************/

				class IDataProcessorCallback : public virtual IDescriptable, public Description<IDataProcessorCallback>
				{
				public:
					virtual list::IItemProvider*						GetItemProvider() = 0;
					virtual void										OnProcessorChanged() = 0;
				};

				class IDataFilter : public virtual IDescriptable, public Description<IDataFilter>
				{
				public:
					virtual void										SetCallback(IDataProcessorCallback* value) = 0;
					virtual bool										Filter(const description::Value& row) = 0;
				};

				class IDataSorter : public virtual IDescriptable, public Description<IDataSorter>
				{
				public:
					virtual void										SetCallback(IDataProcessorCallback* value) = 0;
					virtual vint										Compare(const description::Value& row1, const description::Value& row2) = 0;
				};

/***********************************************************************
Filter Extensions
***********************************************************************/

				/// <summary>Base class for <see cref="IDataFilter"/>.</summary>
				class DataFilterBase : public Object, public virtual IDataFilter, public Description<DataFilterBase>
				{
				protected:
					IDataProcessorCallback*								callback = nullptr;

					/// <summary>Called when the structure or properties for this filter is changed.</summary>
					void												InvokeOnProcessorChanged();
				public:
					DataFilterBase();

					void												SetCallback(IDataProcessorCallback* value)override;
				};
				
				/// <summary>Base class for a <see cref="IDataFilter"/> that contains multiple sub filters.</summary>
				class DataMultipleFilter : public DataFilterBase, public Description<DataMultipleFilter>
				{
				protected:
					collections::List<Ptr<IDataFilter>>		filters;

				public:
					DataMultipleFilter();

					/// <summary>Add a sub filter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub filter.</param>
					bool												AddSubFilter(Ptr<IDataFilter> value);
					/// <summary>Remove a sub filter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub filter.</param>
					bool												RemoveSubFilter(Ptr<IDataFilter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
				};

				/// <summary>A filter that keep a row if all sub filters agree.</summary>
				class DataAndFilter : public DataMultipleFilter, public Description<DataAndFilter>
				{
				public:
					/// <summary>Create the filter.</summary>
					DataAndFilter();

					bool												Filter(const description::Value& row)override;
				};
				
				/// <summary>A filter that keep a row if one of all sub filters agrees.</summary>
				class DataOrFilter : public DataMultipleFilter, public Description<DataOrFilter>
				{
				public:
					/// <summary>Create the filter.</summary>
					DataOrFilter();

					bool												Filter(const description::Value& row)override;
				};
				
				/// <summary>A filter that keep a row if the sub filter not agrees.</summary>
				class DataNotFilter : public DataFilterBase, public Description<DataNotFilter>
				{
				protected:
					Ptr<IDataFilter>							filter;
				public:
					/// <summary>Create the filter.</summary>
					DataNotFilter();
					
					/// <summary>Set a sub filter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub filter.</param>
					bool												SetSubFilter(Ptr<IDataFilter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
					bool												Filter(const description::Value& row)override;
				};

/***********************************************************************
Sorter Extensions
***********************************************************************/

				/// <summary>Base class for <see cref="IDataSorter"/>.</summary>
				class DataSorterBase : public Object, public virtual IDataSorter, public Description<DataSorterBase>
				{
				protected:
					IDataProcessorCallback*								callback = nullptr;

					/// <summary>Called when the structure or properties for this filter is changed.</summary>
					void												InvokeOnProcessorChanged();
				public:
					DataSorterBase();

					void												SetCallback(IDataProcessorCallback* value)override;
				};
				
				/// <summary>A multi-level <see cref="IDataSorter"/>.</summary>
				class DataMultipleSorter : public DataSorterBase, public Description<DataMultipleSorter>
				{
				protected:
					Ptr<IDataSorter>							leftSorter;
					Ptr<IDataSorter>							rightSorter;
				public:
					/// <summary>Create the sorter.</summary>
					DataMultipleSorter();
					
					/// <summary>Set the first sub sorter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub sorter.</param>
					bool												SetLeftSorter(Ptr<IDataSorter> value);
					/// <summary>Set the second sub sorter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub sorter.</param>
					bool												SetRightSorter(Ptr<IDataSorter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
					vint												Compare(const description::Value& row1, const description::Value& row2)override;
				};
				
				/// <summary>A reverse order <see cref="IDataSorter"/>.</summary>
				class DataReverseSorter : public DataSorterBase, public Description<DataReverseSorter>
				{
				protected:
					Ptr<IDataSorter>							sorter;
				public:
					/// <summary>Create the sorter.</summary>
					DataReverseSorter();
					
					/// <summary>Set the sub sorter.</summary>
					/// <returns>Returns true if this operation succeeded.</returns>
					/// <param name="value">The sub sorter.</param>
					bool												SetSubSorter(Ptr<IDataSorter> value);
					void												SetCallback(IDataProcessorCallback* value)override;
					vint												Compare(const description::Value& row1, const description::Value& row2)override;
				};

/***********************************************************************
DataColumn
***********************************************************************/

				class DataColumns;
				class DataProvider;

				/// <summary>Datagrid Column.</summary>
				class DataColumn : public Object, public Description<DataColumn>
				{
					friend class DataColumns;
					friend class DataProvider;
				protected:
					DataProvider*										dataProvider = nullptr;
					ItemProperty<WString>								textProperty;
					WritableItemProperty<description::Value>			valueProperty;
					WString												text;
					vint												size = 160;
					ColumnSortingState									sortingState = ColumnSortingState::NotSorted;
					bool												ownPopup = true;
					GuiMenu*											popup = nullptr;
					Ptr<IDataFilter>									associatedFilter;
					Ptr<IDataSorter>									associatedSorter;
					Ptr<IDataVisualizerFactory>							visualizerFactory;
					Ptr<IDataEditorFactory>								editorFactory;

					void												NotifyRebuilt();
					void												NotifyChanged(bool needToRefreshItems);
				public:
					DataColumn();
					~DataColumn();

					/// <summary>Value property name changed event.</summary>
					compositions::GuiNotifyEvent						ValuePropertyChanged;
					/// <summary>Text property name changed event.</summary>
					compositions::GuiNotifyEvent						TextPropertyChanged;

					/// <summary>Get the text for the column.</summary>
					/// <returns>The text for the column.</returns>
					WString												GetText();
					/// <summary>Set the text for the column.</summary>
					/// <param name="value">The text for the column.</param>
					void												SetText(const WString& value);

					/// <summary>Get the size for the column.</summary>
					/// <returns>The size for the column.</returns>
					vint												GetSize();
					/// <summary>Set the size for the column.</summary>
					/// <param name="value">The size for the column.</param>
					void												SetSize(vint value);

					/// <summary>Test if the column owns the popup. Owned popup will be deleted in the destructor.</summary>
					/// <returns>Returns true if the column owns the popup.</returns>
					bool												GetOwnPopup();
					/// <summary>Set if the column owns the popup.</summary>
					/// <param name="value">Set to true to let the column own the popup.</param>
					void												SetOwnPopup(bool value);

					/// <summary>Get the popup for the column.</summary>
					/// <returns>The popup for the column.</returns>
					GuiMenu*											GetPopup();
					/// <summary>Set the popup for the column.</summary>
					/// <param name="value">The popup for the column.</param>
					void												SetPopup(GuiMenu* value);

					/// <summary>Get the filter for the column.</summary>
					/// <returns>The filter for the column.</returns>
					Ptr<IDataFilter>									GetFilter();
					/// <summary>Set the filter for the column.</summary>
					/// <param name="value">The filter.</param>
					void												SetFilter(Ptr<IDataFilter> value);

					/// <summary>Get the sorter for the column.</summary>
					/// <returns>The sorter for the column.</returns>
					Ptr<IDataSorter>									GetSorter();
					/// <summary>Set the sorter for the column.</summary>
					/// <param name="value">The sorter.</param>
					void												SetSorter(Ptr<IDataSorter> value);

					/// <summary>Get the visualizer factory for the column.</summary>
					/// <returns>The the visualizer factory for the column.</returns>
					Ptr<IDataVisualizerFactory>							GetVisualizerFactory();
					/// <summary>Set the visualizer factory for the column.</summary>
					/// <param name="value">The visualizer factory.</param>
					void												SetVisualizerFactory(Ptr<IDataVisualizerFactory> value);

					/// <summary>Get the editor factory for the column.</summary>
					/// <returns>The the editor factory for the column.</returns>
					Ptr<IDataEditorFactory>								GetEditorFactory();
					/// <summary>Set the editor factory for the column.</summary>
					/// <param name="value">The editor factory.</param>
					void												SetEditorFactory(Ptr<IDataEditorFactory> value);

					/// <summary>Get the text value from an item.</summary>
					/// <returns>The text value.</returns>
					/// <param name="row">The row index of the item.</param>
					WString												GetCellText(vint row);
					/// <summary>Get the cell value from an item.</summary>
					/// <returns>The cell value.</returns>
					/// <param name="row">The row index of the item.</param>
					description::Value									GetCellValue(vint row);
					/// <summary>Set the cell value to an item.</summary>
					/// <param name="row">The row index of the item.</param>
					/// <param name="value">The value property name.</param>
					void												SetCellValue(vint row, description::Value value);

					/// <summary>Get the text property name to get the cell text from an item.</summary>
					/// <returns>The text property name.</returns>
					ItemProperty<WString>								GetTextProperty();
					/// <summary>Set the text property name to get the cell text from an item.</summary>
					/// <param name="value">The text property name.</param>
					void												SetTextProperty(const ItemProperty<WString>& value);

					/// <summary>Get the value property name to get the cell value from an item.</summary>
					/// <returns>The value property name.</returns>
					WritableItemProperty<description::Value>			GetValueProperty();
					/// <summary>Set the value property name to get the cell value from an item.</summary>
					/// <param name="value">The value property name.</param>
					void												SetValueProperty(const WritableItemProperty<description::Value>& value);
				};

				class DataColumns : public collections::ObservableListBase<Ptr<DataColumn>>
				{
					friend class DataColumn;
				protected:
					DataProvider*										dataProvider = nullptr;
					bool												affectItemFlag = true;

					void												NotifyColumnRebuilt(vint column);
					void												NotifyColumnChanged(vint column, bool needToRefreshItems);
					void												NotifyUpdateInternal(vint start, vint count, vint newCount)override;
					bool												QueryInsert(vint index, const Ptr<DataColumn>& value)override;
					void												AfterInsert(vint index, const Ptr<DataColumn>& value)override;
					void												BeforeRemove(vint index, const Ptr<DataColumn>& value)override;
				public:
					DataColumns(DataProvider* _dataProvider);
					~DataColumns();
				};

/***********************************************************************
DataProvider
***********************************************************************/

				class DataProvider
					: public virtual ItemProviderBase
					, public virtual IListViewItemView
					, public virtual ListViewColumnItemArranger::IColumnItemView
					, public virtual IDataGridView
					, public virtual IDataProcessorCallback
					, public virtual IListViewItemProvider
					, public Description<DataProvider>
				{
					friend class DataColumn;
					friend class DataColumns;
					friend class controls::GuiBindableDataGrid;
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					ListViewDataColumns										dataColumns;
					DataColumns												columns;
					ColumnItemViewCallbackList								columnItemViewCallbacks;
					Ptr<description::IValueReadonlyList>					itemSource;
					Ptr<EventHandler>										itemChangedEventHandler;

					Ptr<IDataFilter>										additionalFilter;
					Ptr<IDataFilter>										currentFilter;
					Ptr<IDataSorter>										currentSorter;
					collections::List<vint>									virtualRowToSourceRow;

					bool													NotifyUpdate(vint start, vint count, bool itemReferenceUpdated);
					void													RebuildAllItems() override;
					void													RefreshAllItems() override;
					void													NotifyColumnRebuilt() override;
					void													NotifyColumnChanged() override;
					list::IItemProvider*									GetItemProvider()override;

					void													OnProcessorChanged()override;
					void													OnItemSourceModified(vint start, vint count, vint newCount);

					void													RebuildFilter();
					void													ReorderRows(bool invokeCallback);

				public:
					ItemProperty<Ptr<GuiImageData>>							largeImageProperty;
					ItemProperty<Ptr<GuiImageData>>							smallImageProperty;

				public:
					/// <summary>Create a data provider.</summary>
					DataProvider();
					~DataProvider();

					ListViewDataColumns&								GetDataColumns();
					DataColumns&										GetColumns();
					Ptr<description::IValueEnumerable>					GetItemSource();
					void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);
					
					Ptr<IDataFilter>									GetAdditionalFilter();
					void												SetAdditionalFilter(Ptr<IDataFilter> value);

					// ===================== GuiListControl::IItemProvider =====================

					vint												Count()override;
					WString												GetTextValue(vint itemIndex)override;
					description::Value									GetBindingValue(vint itemIndex)override;
					IDescriptable*										RequestView(const WString& identifier)override;
					
					// ===================== list::IListViewItemProvider =====================

					Ptr<GuiImageData>									GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(vint itemIndex)override;
					WString												GetText(vint itemIndex)override;
					WString												GetSubItem(vint itemIndex, vint index)override;
					vint												GetDataColumnCount()override;
					vint												GetDataColumn(vint index)override;
					vint												GetColumnCount()override;
					WString												GetColumnText(vint index)override;
					
					// ===================== list::ListViewColumnItemArranger::IColumnItemView =====================
						
					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint												GetColumnSize(vint index)override;
					void												SetColumnSize(vint index, vint value)override;
					GuiMenu*											GetDropdownPopup(vint index)override;
					ColumnSortingState									GetSortingState(vint index)override;
					
					// ===================== list::IDataGridView =====================

					bool												IsColumnSortable(vint column)override;
					void												SortByColumn(vint column, bool ascending)override;
					vint												GetSortedColumn()override;
					bool												IsSortOrderAscending()override;
					
					vint												GetCellSpan(vint row, vint column)override;
					IDataVisualizerFactory*								GetCellDataVisualizerFactory(vint row, vint column)override;
					IDataEditorFactory*									GetCellDataEditorFactory(vint row, vint column)override;
					description::Value									GetBindingCellValue(vint row, vint column)override;
					void												SetBindingCellValue(vint row, vint column, const description::Value& value)override;
				};
			}

/***********************************************************************
GuiBindableDataGrid
***********************************************************************/

			/// <summary>A bindable Data grid control.</summary>
			class GuiBindableDataGrid : public GuiVirtualDataGrid, public Description<GuiBindableDataGrid>
			{
			protected:
				list::DataProvider*									dataProvider = nullptr;

			public:
				/// <summary>Create a bindable Data grid control.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableDataGrid(theme::ThemeName themeName);
				~GuiBindableDataGrid();

				/// <summary>Get all data columns indices in columns.</summary>
				/// <returns>All data columns indices in columns.</returns>
				list::ListViewDataColumns&							GetDataColumns();
				/// <summary>Get all columns.</summary>
				/// <returns>All columns.</returns>
				list::DataColumns&									GetColumns();

				/// <summary>Get the item source.</summary>
				/// <returns>The item source.</returns>
				Ptr<description::IValueEnumerable>					GetItemSource();
				/// <summary>Set the item source.</summary>
				/// <param name="_itemSource">The item source. Null is acceptable if you want to clear all data.</param>
				void												SetItemSource(Ptr<description::IValueEnumerable> _itemSource);

				/// <summary>Get the additional filter.</summary>
				/// <returns>The additional filter.</returns>
				Ptr<list::IDataFilter>								GetAdditionalFilter();
				/// <summary>Set the additional filter. This filter will be composed with filters of all column to be the final filter.</summary>
				/// <param name="value">The additional filter.</param>
				void												SetAdditionalFilter(Ptr<list::IDataFilter> value);

				/// <summary>Large image property name changed event.</summary>
				compositions::GuiNotifyEvent						LargeImagePropertyChanged;
				/// <summary>Small image property name changed event.</summary>
				compositions::GuiNotifyEvent						SmallImagePropertyChanged;

				/// <summary>Get the large image property name to get the large image from an item.</summary>
				/// <returns>The large image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetLargeImageProperty();
				/// <summary>Set the large image property name to get the large image from an item.</summary>
				/// <param name="value">The large image property name.</param>
				void												SetLargeImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);

				/// <summary>Get the small image property name to get the small image from an item.</summary>
				/// <returns>The small image property name.</returns>
				ItemProperty<Ptr<GuiImageData>>						GetSmallImageProperty();
				/// <summary>Set the small image property name to get the small image from an item.</summary>
				/// <param name="value">The small image property name.</param>
				void												SetSmallImageProperty(const ItemProperty<Ptr<GuiImageData>>& value);


				/// <summary>Get the selected cell.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedRowValue();

				/// <summary>Get the selected cell.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value									GetSelectedCellValue();

				/// <summary>Notify the control that data in some items are modified.</summary>
				/// <param name="start">The index of the first item.</param>
				/// <param name="count">The number of items</param>
				/// <returns>Returns true if this operation succeeded.</returns>
				bool												NotifyItemDataModified(vint start, vint count);
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIRIBBONIMPL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIRIBBONIMPL
#define VCZH_PRESENTATION_CONTROLS_GUIRIBBONIMPL


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiBindableRibbonGalleryList;

/***********************************************************************
GalleryItemArranger
***********************************************************************/

			namespace ribbon_impl
			{
				class GalleryItemArrangerRepeatComposition : public compositions::GuiVirtualRepeatCompositionBase, public Description<GalleryItemArrangerRepeatComposition>
				{
				private:
					vint													pim_itemWidth = 0;
					bool													blockScrollUpdate = true;

				protected:
					GuiBindableRibbonGalleryList*							owner;
					vint													itemWidth = 1;
					vint													firstIndex = 0;

					void													Layout_BeginPlaceItem(bool firstPhase, Rect newBounds, vint& newStartIndex)override;
					compositions::VirtualRepeatPlaceItemResult				Layout_PlaceItem(bool firstPhase, bool newCreatedStyle, vint index, ItemStyleRecord style, Rect viewBounds, Rect& bounds, Margin& alignmentToParent)override;
					compositions::VirtualRepeatEndPlaceItemResult			Layout_EndPlaceItem(bool firstPhase, Rect newBounds, vint newStartIndex)override;
					void													Layout_EndLayout(bool totalSizeUpdated) override;
					void													Layout_InvalidateItemSizeCache()override;
					void													Layout_CalculateTotalSize(Size& full, Size& minimum)override;
					Size													Layout_GetAdoptedSize(Size expectedSize)override;
				public:
					GalleryItemArrangerRepeatComposition(GuiBindableRibbonGalleryList* _owner);
					~GalleryItemArrangerRepeatComposition();

					vint													FindItemByVirtualKeyDirection(vint itemIndex, compositions::KeyDirection key)override;
					compositions::VirtualRepeatEnsureItemVisibleResult		EnsureItemVisible(vint itemIndex)override;

					void													ScrollUp();
					void													ScrollDown();
					void													UnblockScrollUpdate();
				};

				class GalleryItemArranger : public list::VirtualRepeatRangedItemArrangerBase<GalleryItemArrangerRepeatComposition>, public Description<GalleryItemArranger>
				{
					using TBase = list::VirtualRepeatRangedItemArrangerBase<GalleryItemArrangerRepeatComposition>;
				public:
					GalleryItemArranger(GuiBindableRibbonGalleryList* _owner);
					~GalleryItemArranger();

					void										ScrollUp();
					void										ScrollDown();
					void										UnblockScrollUpdate();
				};

				class GalleryResponsiveLayout : public compositions::GuiResponsiveCompositionBase, public Description<GalleryResponsiveLayout>
				{
				protected:
					vint										minCount = 0;
					vint										maxCount = 0;
					Size										sizeOffset;
					vint										itemCount = 0;
					vint										itemWidth = 1;

					void										UpdateMinSize();
				public:
					GalleryResponsiveLayout();
					~GalleryResponsiveLayout();

					vint										GetMinCount();
					vint										GetMaxCount();
					vint										GetItemWidth();
					Size										GetSizeOffset();
					vint										GetVisibleItemCount();

					void										SetMinCount(vint value);
					void										SetMaxCount(vint value);
					void										SetItemWidth(vint value);
					void										SetSizeOffset(Size value);

					vint										GetLevelCount()override;
					vint										GetCurrentLevel()override;
					bool										LevelDown()override;
					bool										LevelUp()override;
				};
			}
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPMENU.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Toolstrip Item Collection
***********************************************************************/

			/// <summary>IToolstripUpdateLayout is a required service for all menu item container.</summary>
			class IToolstripUpdateLayout : public IDescriptable
			{
			public:
				virtual void								UpdateLayout() = 0;
			};

			/// <summary>IToolstripUpdateLayout is a required service for a menu item which want to force the container to redo layout.</summary>
			class IToolstripUpdateLayoutInvoker : public IDescriptable
			{
			public:
				/// <summary>The identifier for this service.</summary>
				static const wchar_t* const					Identifier;

				virtual void								SetCallback(IToolstripUpdateLayout* callback) = 0;
			};

			/// <summary>Toolstrip item collection.</summary>
			class GuiToolstripCollectionBase : public collections::ObservableListBase<GuiControl*>
			{
			public:

			protected:
				IToolstripUpdateLayout *					contentCallback;

				void										InvokeUpdateLayout();
				bool										QueryInsert(vint index, GuiControl* const& child)override;
				void										BeforeRemove(vint index, GuiControl* const& child)override;
				void										AfterInsert(vint index, GuiControl* const& child)override;
				void										AfterRemove(vint index, vint count)override;
			public:
				GuiToolstripCollectionBase(IToolstripUpdateLayout* _contentCallback);
				~GuiToolstripCollectionBase();
			};

			/// <summary>Toolstrip item collection.</summary>
			class GuiToolstripCollection : public GuiToolstripCollectionBase
			{
				using EventHandlerList = collections::List<Ptr<compositions::IGuiGraphicsEventHandler>>;
			protected:
				compositions::GuiStackComposition*			stackComposition;
				EventHandlerList							eventHandlers;

				void										UpdateItemVisibility(vint index, GuiControl* child);
				void										OnItemVisibleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										BeforeRemove(vint index, GuiControl* const& child)override;
				void										AfterInsert(vint index, GuiControl* const& child)override;
				void										AfterRemove(vint index, vint count)override;
			public:
				GuiToolstripCollection(IToolstripUpdateLayout* _contentCallback, compositions::GuiStackComposition* _stackComposition);
				~GuiToolstripCollection();
			};

/***********************************************************************
Toolstrip Container
***********************************************************************/

			/// <summary>Toolstrip menu.</summary>
			class GuiToolstripMenu : public GuiMenu, protected IToolstripUpdateLayout,  Description<GuiToolstripMenu>
			{
			protected:
				compositions::GuiSharedSizeRootComposition*		sharedSizeRootComposition;
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

				void											UpdateLayout()override;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_owner">The owner menu item of the parent menu.</param>
				GuiToolstripMenu(theme::ThemeName themeName, GuiControl* _owner);
				~GuiToolstripMenu();
				
				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

			/// <summary>Toolstrip menu bar.</summary>
			class GuiToolstripMenuBar : public GuiMenuBar, public Description<GuiToolstripMenuBar>
			{
			protected:
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiToolstripMenuBar(theme::ThemeName themeName);
				~GuiToolstripMenuBar();
				
				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

			/// <summary>Toolstrip tool bar.</summary>
			class GuiToolstripToolBar : public GuiControl, public Description<GuiToolstripToolBar>
			{
			protected:
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiToolstripToolBar(theme::ThemeName themeName);
				~GuiToolstripToolBar();
				
				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

/***********************************************************************
Toolstrip Component
***********************************************************************/

			/// <summary>Toolstrip button that can connect with a <see cref="GuiToolstripCommand"/>.</summary>
			class GuiToolstripButton : public GuiMenuButton, protected IToolstripUpdateLayoutInvoker, public Description<GuiToolstripButton>
			{
			protected:
				GuiToolstripCommand*							command;
				IToolstripUpdateLayout*							callback = nullptr;
				Ptr<compositions::IGuiGraphicsEventHandler>		descriptionChangedHandler;

				void											SetCallback(IToolstripUpdateLayout* _callback)override;
				void											OnActiveAlt()override;
				void											UpdateCommandContent();
				void											OnLayoutAwaredPropertyChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnCommandDescriptionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiToolstripButton(theme::ThemeName themeName);
				~GuiToolstripButton();

				/// <summary>Get the attached <see cref="GuiToolstripCommand"/>.</summary>
				/// <returns>The attached toolstrip command.</returns>
				GuiToolstripCommand*							GetCommand();
				/// <summary>Detach from the previous <see cref="GuiToolstripCommand"/> and attach to a new one. If the command is null, this function only do detaching.</summary>
				/// <param name="value">The new toolstrip command.</param>
				void											SetCommand(GuiToolstripCommand* value);

				/// <summary>Get the toolstrip sub menu. If the sub menu is not created, it returns null.</summary>
				/// <returns>The toolstrip sub menu.</returns>
				GuiToolstripMenu*								GetToolstripSubMenu();

				/// <summary>Get the toolstrip sub menu. If the sub menu is not created, it returns null.</summary>
				/// <returns>The toolstrip sub menu.</returns>
				GuiToolstripMenu*								EnsureToolstripSubMenu();
				/// <summary>Create the toolstrip sub menu if necessary. The created toolstrip sub menu is owned by this menu button.</summary>
				/// <param name="subMenuTemplate">The style controller for the toolstrip sub menu. Set to null to use the default control template.</param>
				void											CreateToolstripSubMenu(TemplateProperty<templates::GuiMenuTemplate> subMenuTemplate);

				IDescriptable*									QueryService(const WString& identifier)override;
			};

/***********************************************************************
Toolstrip Group
***********************************************************************/

			class GuiToolstripNestedContainer : public GuiControl, protected IToolstripUpdateLayout, protected IToolstripUpdateLayoutInvoker
			{
			protected:
				IToolstripUpdateLayout*							callback = nullptr;

				void											UpdateLayout()override;
				void											SetCallback(IToolstripUpdateLayout* _callback)override;
			public:
				GuiToolstripNestedContainer(theme::ThemeName themeName);
				~GuiToolstripNestedContainer();

				IDescriptable*									QueryService(const WString& identifier)override;
			};

			/// <summary>A toolstrip item, which is also a toolstrip item container, automatically maintaining splitters between items.</summary>
			class GuiToolstripGroupContainer : public GuiToolstripNestedContainer, public Description<GuiToolstripGroupContainer>
			{
			protected:
				class GroupCollection : public GuiToolstripCollectionBase
				{
				protected:
					GuiToolstripGroupContainer*					container;
					ControlTemplatePropertyType					splitterTemplate;

					void										BeforeRemove(vint index, GuiControl* const& child)override;
					void										AfterInsert(vint index, GuiControl* const& child)override;
					void										AfterRemove(vint index, vint count)override;
				public:
					GroupCollection(GuiToolstripGroupContainer* _container);
					~GroupCollection();

					ControlTemplatePropertyType					GetSplitterTemplate();
					void										SetSplitterTemplate(const ControlTemplatePropertyType& value);
					void										RebuildSplitters();
				};

			protected:
				compositions::GuiStackComposition*				stackComposition;
				theme::ThemeName								splitterThemeName;
				Ptr<GroupCollection>							groupCollection;

				void											OnParentLineChanged()override;
			public:
				GuiToolstripGroupContainer(theme::ThemeName themeName);
				~GuiToolstripGroupContainer();

				ControlTemplatePropertyType						GetSplitterTemplate();
				void											SetSplitterTemplate(const ControlTemplatePropertyType& value);

				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};

			/// <summary>A toolstrip item, which is also a toolstrip item container.</summary>
			class GuiToolstripGroup : public GuiToolstripNestedContainer, public Description<GuiToolstripGroup>
			{
			protected:
				compositions::GuiStackComposition*				stackComposition;
				Ptr<GuiToolstripCollection>						toolstripItems;

				void											OnParentLineChanged()override;
			public:
				GuiToolstripGroup(theme::ThemeName themeName);
				~GuiToolstripGroup();

				/// <summary>Get all managed child controls ordered by their positions.</summary>
				/// <returns>All managed child controls.</returns>
				collections::ObservableListBase<GuiControl*>&	GetToolstripItems();
			};
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::GuiToolstripCollection>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIRIBBONCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIRIBBONCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIRIBBONCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiRibbonTabPage;
			class GuiRibbonGroup;

/***********************************************************************
Ribbon Tab
***********************************************************************/

			/// <summary>Ribbon tab control, for displaying ribbon tab pages.</summary>
			class GuiRibbonTab : public GuiTab, public Description<GuiRibbonTab>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonTabTemplate, GuiTab)
			protected:
				compositions::GuiBoundsComposition*					beforeHeaders = nullptr;
				compositions::GuiBoundsComposition*					afterHeaders = nullptr;
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonTab(theme::ThemeName themeName);
				~GuiRibbonTab();

				/// <summary>Get the composition representing the space before tabs.</summary>
				/// <returns>The composition representing the space before tabs.</returns>
				compositions::GuiGraphicsComposition*				GetBeforeHeaders();
				/// <summary>Get the composition representing the space after tabs.</summary>
				/// <returns>The composition representing the space after tabs.</returns>
				compositions::GuiGraphicsComposition*				GetAfterHeaders();
			};

			class GuiRibbonGroupCollection : public collections::ObservableListBase<GuiRibbonGroup*>
			{
			protected:
				GuiRibbonTabPage*									tabPage = nullptr;

				bool												QueryInsert(vint index, GuiRibbonGroup* const& value)override;
				void												AfterInsert(vint index, GuiRibbonGroup* const& value)override;
				void												AfterRemove(vint index, vint count)override;

			public:
				GuiRibbonGroupCollection(GuiRibbonTabPage* _tabPage);
				~GuiRibbonGroupCollection();
			};

			/// <summary>Ribbon tab page control, adding to the Pages property of a <see cref="GuiRibbonTab"/>.</summary>
			class GuiRibbonTabPage : public GuiTabPage, public AggregatableDescription<GuiRibbonTabPage>
			{
				friend class GuiRibbonGroupCollection;
			protected:
				bool												highlighted = false;
				GuiRibbonGroupCollection							groups;
				compositions::GuiResponsiveStackComposition*		responsiveStack = nullptr;
				compositions::GuiResponsiveContainerComposition*	responsiveContainer = nullptr;
				compositions::GuiStackComposition*					stack = nullptr;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonTabPage(theme::ThemeName themeName);
				~GuiRibbonTabPage();
				
				/// <summary>Highlighted changed event.</summary>
				compositions::GuiNotifyEvent						HighlightedChanged;

				/// <summary>Test if this is a highlighted tab page.</summary>
				/// <returns>Returns true if this is a highlighted tab page.</returns>
				bool												GetHighlighted();
				/// <summary>Set if this is a highlighted tab page.</summary>
				/// <param name="value">Set to true to highlight the tab page.</param>
				void												SetHighlighted(bool value);

				/// <summary>Get the collection of ribbon groups.</summary>
				/// <returns>The collection of ribbon groups.</returns>
				collections::ObservableListBase<GuiRibbonGroup*>&	GetGroups();
			};

/***********************************************************************
Ribbon Group
***********************************************************************/

			class GuiRibbonGroupItemCollection : public collections::ObservableListBase<GuiControl*>
			{
			protected:
				GuiRibbonGroup*										group = nullptr;

				bool												QueryInsert(vint index, GuiControl* const& value)override;
				void												AfterInsert(vint index, GuiControl* const& value)override;
				void												AfterRemove(vint index, vint count)override;

			public:
				GuiRibbonGroupItemCollection(GuiRibbonGroup* _group);
				~GuiRibbonGroupItemCollection();
			};

			/// <summary>Ribbon group control, adding to the Groups property of a <see cref="GuiRibbonTabPage"/>.</summary>
			class GuiRibbonGroup : public GuiControl, protected compositions::GuiAltActionHostBase, public Description<GuiRibbonGroup>
			{
				friend class GuiRibbonGroupItemCollection;
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonGroupTemplate, GuiControl)
			protected:

				class CommandExecutor : public Object, public IRibbonGroupCommandExecutor
				{
				protected:
					GuiRibbonGroup*									group;

				public:
					CommandExecutor(GuiRibbonGroup* _group);
					~CommandExecutor();

					void											NotifyExpandButtonClicked()override;
				};

				bool												expandable = false;
				Ptr<GuiImageData>									largeImage;
				GuiRibbonGroupItemCollection						items;
				compositions::GuiResponsiveStackComposition*		responsiveStack = nullptr;
				compositions::GuiStackComposition*					stack = nullptr;
				Ptr<CommandExecutor>								commandExecutor;

				compositions::GuiResponsiveViewComposition*			responsiveView = nullptr;
				compositions::GuiResponsiveFixedComposition*		responsiveFixedButton = nullptr;
				GuiToolstripButton*									dropdownButton = nullptr;
				GuiMenu*											dropdownMenu = nullptr;

				bool												IsAltAvailable()override;
				compositions::IGuiAltActionHost*					GetActivatingAltHost()override;
				void												OnCachedBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnBeforeSwitchingView(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void												OnBeforeSubMenuOpening(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonGroup(theme::ThemeName themeName);
				~GuiRibbonGroup();

				/// <summary>Expandable changed event.</summary>
				compositions::GuiNotifyEvent						ExpandableChanged;
				/// <summary>Expand button clicked event.</summary>
				compositions::GuiNotifyEvent						ExpandButtonClicked;
				/// <summary>Large image changed event.</summary>
				compositions::GuiNotifyEvent						LargeImageChanged;

				/// <summary>Test if this group is expandable. An expandable group will display an extra small button, which raises <see cref="ExpandButtonClicked"/>.</summary>
				/// <returns>Returns true if this group is expandable.</returns>
				bool												GetExpandable();
				/// <summary>Set if this group is expandable.</summary>
				/// <param name="value">Set to true to make this group is expandable.</param>
				void												SetExpandable(bool value);

				/// <summary>Get the large image for the collapsed ribbon group.</summary>
				/// <returns>The large image for the collapsed ribbon group.</returns>
				Ptr<GuiImageData>									GetLargeImage();
				/// <summary>Set the large image for the collapsed ribbon group.</summary>
				/// <param name="value">The large image for the collapsed ribbon group.</param>
				void												SetLargeImage(Ptr<GuiImageData> value);

				/// <summary>Get the collection of controls in this group.</summary>
				/// <returns>The collection of controls.</returns>
				collections::ObservableListBase<GuiControl*>&		GetItems();
			};

/***********************************************************************
Ribbon Buttons
***********************************************************************/

			/// <summary>Auto resizable ribbon icon label.</summary>
			class GuiRibbonIconLabel : public GuiControl, public Description<GuiRibbonIconLabel>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonIconLabelTemplate, GuiControl)
			protected:
				Ptr<GuiImageData>						image;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonIconLabel(theme::ThemeName themeName);
				~GuiRibbonIconLabel();

				/// <summary>Image changed event.</summary>
				compositions::GuiNotifyEvent			ImageChanged;

				/// <summary>Get the image for the menu button.</summary>
				/// <returns>The image for the menu button.</returns>
				Ptr<GuiImageData>						GetImage();
				/// <summary>Set the image for the menu button.</summary>
				/// <param name="value">The image for the menu button.</param>
				void									SetImage(Ptr<GuiImageData> value);
			};

			/// <summary>Represents the size of a ribbon button in a <see cref="GuiRibbonButtons"/> control.</summary>
			enum class RibbonButtonSize
			{
				/// <summary>Large icon with text.</summary>
				Large = 0,
				/// <summary>Small icon with text.</summary>
				Small = 1,
				/// <summary>Small icon only.</summary>
				Icon = 2,
			};

			class GuiRibbonButtons;

			class GuiRibbonButtonsItemCollection : public collections::ObservableListBase<GuiControl*>
			{
			protected:
				GuiRibbonButtons*										buttons = nullptr;

				bool													QueryInsert(vint index, GuiControl* const& value)override;
				void													AfterInsert(vint index, GuiControl* const& value)override;
				void													BeforeRemove(vint index, GuiControl* const& value)override;

			public:
				GuiRibbonButtonsItemCollection(GuiRibbonButtons* _buttons);
				~GuiRibbonButtonsItemCollection();
			};

			/// <summary>Auto resizable ribbon buttons.</summary>
			class GuiRibbonButtons : public GuiControl, public Description<GuiRibbonButtons>
			{
				friend class GuiRibbonButtonsItemCollection;
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonButtonsTemplate, GuiControl)
			protected:
				RibbonButtonSize										minSize;
				RibbonButtonSize										maxSize;
				compositions::GuiResponsiveViewComposition*				responsiveView = nullptr;
				compositions::GuiResponsiveFixedComposition*			views[3] = { nullptr,nullptr,nullptr };
				GuiRibbonButtonsItemCollection							buttons;
																		
				void													OnBeforeSwitchingView(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													SetButtonThemeName(compositions::GuiResponsiveCompositionBase* fixed, GuiControl* button);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="_maxSize">Max allowed size.</param>
				/// <param name="_minSize">Min allowed size.</param>
				GuiRibbonButtons(theme::ThemeName themeName, RibbonButtonSize _maxSize, RibbonButtonSize _minSize);
				~GuiRibbonButtons();

				/// <summary>Get the collection of buttons. <see cref="GuiToolstripButton"/> is expected.</summary>
				/// <returns>The collection of buttons.</returns>
				collections::ObservableListBase<GuiControl*>&			GetButtons();
			};

/***********************************************************************
Ribbon Toolstrips
***********************************************************************/

			class GuiRibbonToolstrips;

			class GuiRibbonToolstripsGroupCollection : public collections::ObservableListBase<GuiToolstripGroup*>
			{
			protected:
				GuiRibbonToolstrips*									toolstrips = nullptr;

				bool													QueryInsert(vint index, GuiToolstripGroup* const& value)override;
				void													AfterInsert(vint index, GuiToolstripGroup* const& value)override;
				void													AfterRemove(vint index, vint count)override;

			public:
				GuiRibbonToolstripsGroupCollection(GuiRibbonToolstrips* _toolstrips);
				~GuiRibbonToolstripsGroupCollection();
			};

			/// <summary>Auto resizable ribbon toolstrips.</summary>
			class GuiRibbonToolstrips : public GuiControl, public Description<GuiRibbonToolstrips>
			{
				friend class GuiRibbonToolstripsGroupCollection;
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonToolstripsTemplate, GuiControl)
			protected:
				compositions::GuiResponsiveViewComposition*				responsiveView = nullptr;
				GuiToolstripToolBar*									toolbars[5] = { nullptr,nullptr,nullptr,nullptr,nullptr };
				GuiToolstripGroupContainer*								longContainers[2] = { nullptr,nullptr };
				GuiToolstripGroupContainer*								shortContainers[3] = { nullptr,nullptr,nullptr };
				compositions::GuiResponsiveFixedComposition*			views[2] = { nullptr,nullptr };
				GuiRibbonToolstripsGroupCollection						groups;

				void													OnBeforeSwitchingView(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													RearrangeToolstripGroups(vint viewIndex = -1);
			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonToolstrips(theme::ThemeName themeName);
				~GuiRibbonToolstrips();

				/// <summary>Get the collection of toolstrip groups. <see cref="GuiRibbonToolstrips"/> will decide the order of these toolstrip groups.</summary>
				/// <returns>The collection of toolstrip groups.</returns>
				collections::ObservableListBase<GuiToolstripGroup*>&	GetGroups();
			};

/***********************************************************************
Ribbon Gallery
***********************************************************************/

			/// <summary>Ribbon gallery, with scroll up, scroll down, dropdown buttons.</summary>
			class GuiRibbonGallery : public GuiControl, public Description<GuiRibbonGallery>
			{
				using ItemStyle = templates::GuiListItemTemplate;
				using ItemStyleProperty = TemplateProperty<templates::GuiListItemTemplate>;

				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonGalleryTemplate, GuiControl)
			protected:
				class CommandExecutor : public Object, public IRibbonGalleryCommandExecutor
				{
				protected:
					GuiRibbonGallery*									gallery;

				public:
					CommandExecutor(GuiRibbonGallery* _gallery);
					~CommandExecutor();

					void												NotifyScrollUp()override;
					void												NotifyScrollDown()override;
					void												NotifyDropdown()override;
				};

				bool													scrollUpEnabled = true;
				bool													scrollDownEnabled = true;
				Ptr<CommandExecutor>									commandExecutor;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiRibbonGallery(theme::ThemeName themeName);
				~GuiRibbonGallery();

				/// <summary>Scroll up enabled changed event.</summary>
				compositions::GuiNotifyEvent							ScrollUpEnabledChanged;
				/// <summary>Scroll down enabled changed event.</summary>
				compositions::GuiNotifyEvent							ScrollDownEnabledChanged;
				/// <summary>Scroll up button clicked event.</summary>
				compositions::GuiNotifyEvent							RequestedScrollUp;
				/// <summary>Scroll down button clicked event.</summary>
				compositions::GuiNotifyEvent							RequestedScrollDown;
				/// <summary>Dropdown button clicked event.</summary>
				compositions::GuiNotifyEvent							RequestedDropdown;

				/// <summary>Test if the scroll up button is enabled.</summary>
				/// <returns>Returns true if the scroll up button is enabled.</returns>
				bool													GetScrollUpEnabled();
				/// <summary>Set if the scroll up button is enabled.</summary>
				/// <param name="value">Set to true to enable the scroll up button.</param>
				void													SetScrollUpEnabled(bool value);

				/// <summary>Test if the scroll down button is enabled.</summary>
				/// <returns>Returns true if the scroll down button is enabled.</returns>
				bool													GetScrollDownEnabled();
				/// <summary>Set if the scroll down button is enabled.</summary>
				/// <param name="value">Set to true to enable the scroll down button.</param>
				void													SetScrollDownEnabled(bool value);
			};

			/// <summary>Resizable ribbon toolstrip menu with a space above of all menu items to display extra content.</summary>
			class GuiRibbonToolstripMenu : public GuiToolstripMenu, public Description<GuiRibbonToolstripMenu>
			{
				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonToolstripMenuTemplate, GuiToolstripMenu)
			protected:
				compositions::GuiBoundsComposition*						contentComposition;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				/// <param name="owner">The owner menu item of the parent menu.</param>
				GuiRibbonToolstripMenu(theme::ThemeName themeName, GuiControl* owner);
				~GuiRibbonToolstripMenu();

				/// <summary>Get the composition representing the space above of menu items.</summary>
				/// <returns>The composition representing the space above of menu items.</returns>
				compositions::GuiGraphicsComposition*					GetContentComposition();
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\TOOLSTRIPPACKAGE\GUIRIBBONGALLERYLIST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIRIBBONGALLERYLIST
#define VCZH_PRESENTATION_CONTROLS_GUIRIBBONGALLERYLIST


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Ribbon Gallery List
***********************************************************************/

			/// <summary>Represents the position of an item in the gallery list.</summary>
			struct GalleryPos
			{
				/// <summary>Group index.</summary>
				vint			group;
				/// <summary>Item index.</summary>
				vint			item;

				GalleryPos()
					:group(-1), item(-1)
				{
				}

				GalleryPos(vint _group, vint _item)
					:group(_group), item(_item)
				{
				}

				GUI_DEFINE_COMPARE_OPERATORS(GalleryPos)
			};

			namespace list
			{
				class GroupedDataSource;

				/// <summary>A gallery group.</summary>
				class GalleryGroup : public Description<GalleryGroup>
				{
					friend class GroupedDataSource;
					using IValueList = reflection::description::IValueList;
				protected:
					Ptr<EventHandler>									eventHandler;
					WString												name;
					Ptr<IValueList>										itemValues;

				public:
					GalleryGroup();
					~GalleryGroup();

					/// <summary>Get the title of this group.</summary>
					/// <returns>The title of this group.</returns>
					WString												GetName();
					/// <summary>Get the all items of this group, could be null.</summary>
					/// <returns>All items of this group.</returns>
					Ptr<IValueList>										GetItemValues();
				};

				class GroupedDataSource : public Description<GroupedDataSource>
				{
					using IValueEnumerable = reflection::description::IValueEnumerable;
					using IValueList = reflection::description::IValueList;
					using IValueObservableList = reflection::description::IValueObservableList;
					using GalleryItemList = collections::ObservableList<reflection::description::Value>;
					using GalleryGroupList = collections::ObservableList<Ptr<GalleryGroup>>;

				protected:
					compositions::GuiGraphicsComposition*				associatedComposition;
					Ptr<IValueEnumerable>								itemSource;
					ItemProperty<WString>								titleProperty;
					ItemProperty<Ptr<IValueEnumerable>>					childrenProperty;

					GalleryItemList										joinedItemSource;
					GalleryGroupList									groupedItemSource;
					collections::List<vint>								cachedGroupItemCounts;
					Ptr<EventHandler>									groupChangedHandler;
					bool												ignoreGroupChanged = false;

					void												RebuildItemSource();
					Ptr<IValueList>										GetChildren(Ptr<IValueEnumerable> children);
					void												AttachGroupChanged(Ptr<GalleryGroup> group, vint index);
					void												OnGroupChanged(vint start, vint oldCount, vint newCount);
					void												OnGroupItemChanged(vint index, vint start, vint oldCount, vint newCount);
					vint												GetCountBeforeGroup(vint index);
					void												InsertGroupToJoined(vint index);
					void												RemoveGroupFromJoined(vint index);

				public:
					GroupedDataSource(compositions::GuiGraphicsComposition* _associatedComposition);
					~GroupedDataSource();

					/// <summary>Group enabled event.</summary>
					compositions::GuiNotifyEvent						GroupEnabledChanged;
					/// <summary>Group title property changed event.</summary>
					compositions::GuiNotifyEvent						GroupTitlePropertyChanged;
					/// <summary>Group children property changed event.</summary>
					compositions::GuiNotifyEvent						GroupChildrenPropertyChanged;

					/// <summary>Get the item source.</summary>
					/// <returns>The item source.</returns>
					Ptr<IValueEnumerable>								GetItemSource();
					/// <summary>Set the item source.</summary>
					/// <param name="value">The item source. Null is acceptable if you want to clear all data.</param>
					void												SetItemSource(Ptr<IValueEnumerable> value);

					/// <summary>Test if grouping is enabled. Enabled means there is really both GroupTitleProperty and GroupChildrenProperty is not empty.</summary>
					/// <returns>Returns true if grouping is enabled.</returns>
					bool												GetGroupEnabled();

					/// <summary>Get the group title property.</summary>
					/// <returns>The group title property.</returns>
					ItemProperty<WString>								GetGroupTitleProperty();
					/// <summary>Get the group title property.</summary>
					/// <param name="value">The group title property.</param>
					void												SetGroupTitleProperty(const ItemProperty<WString>& value);

					/// <summary>Get the group children property.</summary>
					/// <returns>The group children property.</returns>
					ItemProperty<Ptr<IValueEnumerable>>					GetGroupChildrenProperty();
					/// <summary>Get the group children property.</summary>
					/// <param name="value">The children title property.</param>
					void												SetGroupChildrenProperty(const ItemProperty<Ptr<IValueEnumerable>>& value);

					/// <summary>Get all groups.</summary>
					/// <returns>All groups.</returns>
					const GalleryGroupList&								GetGroups();
				};
			}

			namespace ribbon_impl
			{
				class GalleryItemArrangerRepeatComposition;
				class GalleryItemArranger;
				class GalleryResponsiveLayout;
			}

			/// <summary>Auto resizable ribbon gallyer list.</summary>
			class GuiBindableRibbonGalleryList : public GuiRibbonGallery, public list::GroupedDataSource, private IGuiMenuDropdownProvider, public Description<GuiBindableRibbonGalleryList>
			{
				friend class ribbon_impl::GalleryItemArrangerRepeatComposition;

				using IValueEnumerable = reflection::description::IValueEnumerable;
				using IValueObservableList = reflection::description::IValueObservableList;
				using ItemStyleProperty = TemplateProperty<templates::GuiListItemTemplate>;

				GUI_SPECIFY_CONTROL_TEMPLATE_TYPE(RibbonGalleryListTemplate, GuiRibbonGallery)
			protected:
				ItemStyleProperty										itemStyle;
				GuiBindableTextList*									itemList;
				GuiRibbonToolstripMenu*									subMenu;
				vint													visibleItemCount = 1;
				bool													skipItemAppliedEvent = false;

				ribbon_impl::GalleryItemArranger*						itemListArranger;
				ribbon_impl::GalleryResponsiveLayout*					layout;
				GuiScrollContainer*										groupContainer;
				compositions::GuiRepeatStackComposition*				groupStack;

				void													UpdateLayoutSizeOffset();
				void													OnItemListSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnItemListItemMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													OnItemListItemMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													OnCachedBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnRequestedDropdown(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnRequestedScrollUp(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													OnRequestedScrollDown(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void													MenuResetGroupTemplate();
				GuiControl*												MenuGetGroupHeader(vint groupIndex);
				compositions::GuiRepeatFlowComposition*					MenuGetGroupFlow(vint groupIndex);
				GuiSelectableButton*									MenuGetGroupItemBackground(vint groupIndex, vint itemIndex);

				void													StartPreview(vint index);
				void													StopPreview(vint index);

			private:
				GuiMenu*												ProvideDropdownMenu()override;

			public:
				/// <summary>Create a control with a specified default theme.</summary>
				/// <param name="themeName">The theme name for retriving a default control template.</param>
				GuiBindableRibbonGalleryList(theme::ThemeName themeName);
				~GuiBindableRibbonGalleryList();

				/// <summary>Item template changed event.</summary>
				compositions::GuiNotifyEvent							ItemTemplateChanged;
				/// <summary>Selection changed event.</summary>
				compositions::GuiNotifyEvent							SelectionChanged;
				/// <summary>Preview started event.</summary>
				compositions::GuiItemNotifyEvent						PreviewStarted;
				/// <summary>Preview stopped event.</summary>
				compositions::GuiItemNotifyEvent						PreviewStopped;
				/// <summary>Item applied event.</summary>
				compositions::GuiItemNotifyEvent						ItemApplied;

				/// <summary>Get the item style provider.</summary>
				/// <returns>The item style provider.</returns>
				ItemStyleProperty										GetItemTemplate();
				/// <summary>Set the item style provider</summary>
				/// <param name="value">The new item style provider</param>
				void													SetItemTemplate(ItemStyleProperty value);

				/// <summary>Convert an item index to a gallery item position.</summary>
				/// <returns>The gallery item position.</returns>
				/// <param name="index">The item index.</param>
				GalleryPos												IndexToGalleryPos(vint index);
				/// <summary>Convert a gallery item position to an item index.</summary>
				/// <returns>The item index.</returns>
				/// <param name="pos">The gallery item position.</param>
				vint													GalleryPosToIndex(GalleryPos pos);

				/// <summary>Get the minimum number of items should be displayed.</summary>
				/// <returns>The minimum number of items should be displayed.</returns>
				vint													GetMinCount();
				/// <summary>Set the minimum number of items should be displayed.</summary>
				/// <param name="value">The minimum number of items should be displayed.</param>
				void													SetMinCount(vint value);

				/// <summary>Get the maximum number of items should be displayed.</summary>
				/// <returns>The maximum number of items should be displayed.</returns>
				vint													GetMaxCount();
				/// <summary>Set the maximum number of items should be displayed.</summary>
				/// <param name="value">The maximum number of items should be displayed.</param>
				void													SetMaxCount(vint value);

				/// <summary>Get the selected item index.</summary>
				/// <returns>The index of the selected item. If there are multiple selected items, or there is no selected item, -1 will be returned.</returns>
				vint													GetSelectedIndex();
				/// <summary>Get the selected item.</summary>
				/// <returns>Returns the selected item. If there are multiple selected items, or there is no selected item, null will be returned.</returns>
				description::Value										GetSelectedItem();
				/// <summary>Select an item with <see cref="ItemApplied"/> event raised.</summary>
				/// <param name="index">The index of the item to select. Set to -1 to clear the selection.</param>
				void													ApplyItem(vint index);
				/// <summary>Select an item without <see cref="ItemApplied"/> event raised.</summary>
				/// <param name="index">The index of the item to select. Set to -1 to clear the selection.</param>
				void													SelectItem(vint index);

				/// <summary>Get the minimum items visible in the drop down menu.</summary>
				/// <returns>The minimum items visible in the drop down menu.</returns>
				vint													GetVisibleItemCount();
				/// <summary>Set minimum items visible in the drop down menu.</summary>
				/// <param name="value">The minimum items visible in the drop down menu.</param>
				void													SetVisibleItemCount(vint value);

				/// <summary>Get the dropdown menu.</summary>
				/// <returns>The dropdown menu.</returns>
				GuiToolstripMenu*										GetSubMenu();

				IDescriptable*											QueryService(const WString& identifier)override;
			};
		}
	}
}

#endif


/***********************************************************************
.\CONTROLS\INCLUDEALL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_INCLUDEALL
#define VCZH_PRESENTATION_CONTROLS_INCLUDEALL





#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEPROTOCOLSCHEMASHARED.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  IGuiRemoteProtocol

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_REMOTEPROTOCOLSCHEMASHARED
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_REMOTEPROTOCOLSCHEMASHARED


namespace vl::presentation::remoteprotocol
{
	template<typename T>
	struct JsonNameHelper;

	template<typename TKey, typename TValue, TKey TValue::* Field>
	struct ArrayMap
	{
		using KK = typename KeyType<TKey>::Type;
		collections::Dictionary<TKey, TValue>			map;

		auto&& Keys() const								{ return map.Keys(); }
		auto&& Values() const							{ return map.Values(); }
		vint Count() const								{ return map.Count(); }
		const TValue& Get(const KK& key) const			{ return map.Get(key); }
		const TValue& operator[](const KK& key) const	{ return map[key]; }

		bool Add(const TValue& value)					{ return map.Add(value.*Field, value); }
		bool Remove(const KK& key)						{ return map.Remove(key); }
		bool Clear()									{ return map.Clear(); }
	};

	template<typename T>
	struct JsonHelper
	{
		static Ptr<glr::json::JsonNode> ToJson(const T& value);
		static void ConvertJsonToCustomType(Ptr<glr::json::JsonNode> node, T& value);
	};

	template<typename T>
	Ptr<glr::json::JsonNode> ConvertCustomTypeToJson(const T& value)
	{
		return JsonHelper<T>::ToJson(value);
	}

	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<bool>(const bool& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<vint>(const vint& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<float>(const float& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<double>(const double& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<WString>(const WString& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<wchar_t>(const wchar_t& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<VKEY>(const VKEY& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<Color>(const Color& value);
	template<> Ptr<glr::json::JsonNode> ConvertCustomTypeToJson<Ptr<stream::MemoryStream>>(const Ptr<stream::MemoryStream>& value);

	template<typename T>
	void ConvertJsonToCustomType(Ptr<glr::json::JsonNode> node, T& value)
	{
		return JsonHelper<T>::FromJson(node, value);
	}

	template<> void ConvertJsonToCustomType<bool>(Ptr<glr::json::JsonNode> node, bool& value);
	template<> void ConvertJsonToCustomType<vint>(Ptr<glr::json::JsonNode> node, vint& value);
	template<> void ConvertJsonToCustomType<float>(Ptr<glr::json::JsonNode> node, float& value);
	template<> void ConvertJsonToCustomType<double>(Ptr<glr::json::JsonNode> node, double& value);
	template<> void ConvertJsonToCustomType<WString>(Ptr<glr::json::JsonNode> node, WString& value);
	template<> void ConvertJsonToCustomType<wchar_t>(Ptr<glr::json::JsonNode> node, wchar_t& value);
	template<> void ConvertJsonToCustomType<VKEY>(Ptr<glr::json::JsonNode> node, VKEY& value);
	template<> void ConvertJsonToCustomType<Color>(Ptr<glr::json::JsonNode> node, Color& value);
	template<> void ConvertJsonToCustomType<Ptr<stream::MemoryStream>>(Ptr<glr::json::JsonNode> node, Ptr<stream::MemoryStream>& value);

	template<typename T>
	void ConvertCustomTypeToJsonField(Ptr<glr::json::JsonObject> node, const wchar_t* name, const T& value)
	{
		auto field = Ptr(new glr::json::JsonObjectField);
		field->name.value = WString::Unmanaged(name);
		field->value = ConvertCustomTypeToJson(value);
		node->fields.Add(field);
	}

	template<typename T, typename F>
	Ptr<glr::json::JsonNode> NullableToJson(const T& value, F&& get)
	{
		if (!value)
		{
			auto node = Ptr(new glr::json::JsonLiteral);
			node->value = glr::json::JsonLiteralValue::Null;
			return node;
		}
		else
		{
			return ConvertCustomTypeToJson(get(value));
		}
	}

	template<typename T, typename F>
	bool JsonToNullable(Ptr<glr::json::JsonNode> node, T& value, F&& set)
	{
		if (auto jsonLiteral = node.Cast<glr::json::JsonLiteral>())
		{
			if (jsonLiteral->value == glr::json::JsonLiteralValue::Null)
			{
				value = T{};
				return true;
			}
		}
		else
		{
			set([&](auto&& item) { ConvertJsonToCustomType(node, item); });
			return true;
		}
		return false;
	}

	template<typename T>
	struct JsonHelper<Nullable<T>>
	{
		static Ptr<glr::json::JsonNode> ToJson(const Nullable<T>& value)
		{
			return NullableToJson(
				value,
				[](auto&& v)->decltype(auto) { return v.Value(); }
				);
		}

		static void FromJson(Ptr<glr::json::JsonNode> node, Nullable<T>& value)
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<T>(Ptr<JsonNode>, Ptr<List<T>>&)#"
			if (!JsonToNullable(
				node,
				value,
				[&](auto&& f)
				{
					T item;
					f(item);
					value = std::move(item);
				}))
			{
				CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
			}
#undef ERROR_MESSAGE_PREFIX
		}
	};

	template<typename T>
	struct JsonHelper<Ptr<T>>
	{
		static Ptr<glr::json::JsonNode> ToJson(const Ptr<T>& value)
		{
			return NullableToJson(
				value,
				[](auto&& v)->decltype(auto) { return *v.Obj(); }
				);
		}

		static void FromJson(Ptr<glr::json::JsonNode> node, Ptr<T>& value)
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<T>(Ptr<JsonNode>, Ptr<T>&)#"
			if (!JsonToNullable(
				node,
				value,
				[&](auto&& f)
				{
					value = Ptr(new T);
					f(*value.Obj());
				}))
			{
				CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
			}
#undef ERROR_MESSAGE_PREFIX
		}
	};

	template<typename T>
	struct JsonHelper<collections::List<T>>
	{
		static Ptr<glr::json::JsonNode> ToJson(const collections::List<T>& value)
		{
			auto node = Ptr(new glr::json::JsonArray);
			for (auto&& item : value)
			{
				node->items.Add(ConvertCustomTypeToJson(item));
			}
			return node;
		}

		static void FromJson(Ptr<glr::json::JsonNode> node, collections::List<T>& value)
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<T>(Ptr<JsonNode>, List<T>&)#"
			value.Clear();
			if (auto jsonArray = node.Cast<glr::json::JsonArray>())
			{
				for (auto jsonItem : jsonArray->items)
				{
					T item;
					ConvertJsonToCustomType(jsonItem, item);
					value.Add(std::move(item));
				}
				return;
			}
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
#undef ERROR_MESSAGE_PREFIX
		}
	};

	template<typename TKey, typename TValue, TKey TValue::* Field>
	struct JsonHelper<ArrayMap<TKey, TValue, Field>>
	{
		static Ptr<glr::json::JsonNode> ToJson(const ArrayMap<TKey, TValue, Field>& value)
		{
			auto&& values = const_cast<collections::List<TValue>&>(value.map.Values());
			return ConvertCustomTypeToJson(values);
		}

		static void FromJson(Ptr<glr::json::JsonNode> node, ArrayMap<TKey, TValue, Field>& value)
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<T>(Ptr<JsonNode>, ArrayMap<TKey, TValue, Field>&)#"
			value.Clear();
			collections::List<TValue> values;
			ConvertJsonToCustomType(node, values);
			for (auto&& item : values)
			{
				value.Add(item);
			}
#undef ERROR_MESSAGE_PREFIX
		}
	};

	template<typename TKey, typename TValue>
	struct JsonHelper<collections::Dictionary<TKey, TValue>>
	{
		static Ptr<glr::json::JsonNode> ToJson(const collections::Dictionary<TKey, TValue>& value)
		{
			auto node = Ptr(new glr::json::JsonArray);
			for (auto [key, value] : value)
			{
				auto pairNode = Ptr(new glr::json::JsonArray);
				pairNode->items.Add(ConvertCustomTypeToJson(key));
				pairNode->items.Add(ConvertCustomTypeToJson(value));
				node->items.Add(pairNode);
			}
			return node;
		}

		static void FromJson(Ptr<glr::json::JsonNode> node, collections::Dictionary<TKey, TValue>& value)
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<T>(Ptr<JsonNode>, Dictionary<TKey, TValue>&)#"
			value.Clear();
			auto jsonArray = node.Cast<glr::json::JsonArray>();
			if (!jsonArray) goto FAILED;
			for (auto jsonPair : jsonArray->items)
			{
				auto jsonPairArray = jsonPair.Cast<glr::json::JsonArray>();
				if (!jsonPairArray) goto FAILED;
				if (jsonPairArray->items.Count() != 2) goto FAILED;
				TKey itemKey;
				ConvertJsonToCustomType(jsonPairArray->items[0], itemKey);
				TValue itemValue;
				ConvertJsonToCustomType(jsonPairArray->items[1], itemValue);
				value.Add(itemKey, itemValue);
			}
			return;
		FAILED:
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
#undef ERROR_MESSAGE_PREFIX
		}
	};

	template<typename ...Ts>
	struct JsonHelper<Variant<Ts...>>
	{
		static Ptr<glr::json::JsonNode> ToJson(const Variant<Ts...>& value)
		{
			auto node = Ptr(new glr::json::JsonArray);
			value.Apply([&node]<typename T>(const T& element)
			{
				node->items.Add(ConvertCustomTypeToJson(WString::Unmanaged(JsonNameHelper<T>::Name)));
				node->items.Add(ConvertCustomTypeToJson(element));
			});
			return node;
		}

		template<typename T>
		static bool TryFromJson(Ptr<glr::json::JsonNode> node, const WString& itemKey, Variant<Ts...>& value)
		{
			if (JsonNameHelper<T>::Name != itemKey) return false;
			T itemValue;
			ConvertJsonToCustomType(node, itemValue);
			value = std::move(itemValue);
			return true;
		}

		static void FromJson(Ptr<glr::json::JsonNode> node, Variant<Ts...>& value)
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<T>(Ptr<JsonNode>, Variant<Ts...>&)#"
			auto jsonPairArray = node.Cast<glr::json::JsonArray>();
			if (!jsonPairArray) goto FAILED;
			if (jsonPairArray->items.Count() != 2) goto FAILED;
			{
				WString itemKey;
				ConvertJsonToCustomType(jsonPairArray->items[0], itemKey);
				if ((TryFromJson<Ts>(jsonPairArray->items[1], itemKey, value) || ...))
				{
					return;
				}
			}
		FAILED:
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
#undef ERROR_MESSAGE_PREFIX
		}
	};
}

#endif


/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\PROTOCOL\GENERATED\GUIREMOTEPROTOCOLSCHEMA.H
***********************************************************************/
/***********************************************************************
This file is generated by : Vczh GacUI Remote Protocol Generator
Licensed under https ://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_REMOTEPROTOCOLSCHEMA
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_REMOTEPROTOCOLSCHEMA


namespace vl::presentation::remoteprotocol
{
	struct FontConfig;
	struct ScreenConfig;
	struct WindowSizingConfig;
	struct WindowShowing;
	struct IOMouseInfoWithButton;
	struct GlobalShortcutKey;
	struct ElementDesc_SolidBorder;
	struct ElementDesc_SinkBorder;
	struct ElementDesc_SinkSplitter;
	struct ElementDesc_SolidBackground;
	struct ElementDesc_GradientBackground;
	struct ElementDesc_InnerShadow;
	struct ElementDesc_Polygon;
	struct ElementDesc_SolidLabel;
	struct ImageCreation;
	struct ImageFrameMetadata;
	struct ImageMetadata;
	struct ElementDesc_ImageFrame;
	struct RendererCreation;
	struct ElementBeginRendering;
	struct ElementRendering;
	struct ElementBoundary;
	struct ElementMeasuring_FontHeight;
	struct ElementMeasuring_ElementMinSize;
	struct ElementMeasurings;
	struct RenderingDom;
	struct RenderingCommand_BeginBoundary;
	struct RenderingCommand_EndBoundary;
	struct RenderingCommand_Element;
	struct RenderingFrame;
	struct RenderingTrace;
}
namespace vl::presentation::remoteprotocol
{
	template<> struct JsonNameHelper<::vl::presentation::NativeCoordinate> { static constexpr const wchar_t* Name = L"NativeCoordinate"; };
	template<> struct JsonNameHelper<::vl::presentation::NativePoint> { static constexpr const wchar_t* Name = L"NativePoint"; };
	template<> struct JsonNameHelper<::vl::presentation::NativeSize> { static constexpr const wchar_t* Name = L"NativeSize"; };
	template<> struct JsonNameHelper<::vl::presentation::NativeRect> { static constexpr const wchar_t* Name = L"NativeRect"; };
	template<> struct JsonNameHelper<::vl::presentation::NativeMargin> { static constexpr const wchar_t* Name = L"NativeMargin"; };
	template<> struct JsonNameHelper<::vl::presentation::Point> { static constexpr const wchar_t* Name = L"Point"; };
	template<> struct JsonNameHelper<::vl::presentation::Size> { static constexpr const wchar_t* Name = L"Size"; };
	template<> struct JsonNameHelper<::vl::presentation::Rect> { static constexpr const wchar_t* Name = L"Rect"; };
	template<> struct JsonNameHelper<::vl::presentation::FontProperties> { static constexpr const wchar_t* Name = L"FontProperties"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::FontConfig> { static constexpr const wchar_t* Name = L"FontConfig"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ScreenConfig> { static constexpr const wchar_t* Name = L"ScreenConfig"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::WindowSizingConfig> { static constexpr const wchar_t* Name = L"WindowSizingConfig"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::WindowShowing> { static constexpr const wchar_t* Name = L"WindowShowing"; };
	template<> struct JsonNameHelper<::vl::presentation::NativeWindowMouseInfo> { static constexpr const wchar_t* Name = L"IOMouseInfo"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::IOMouseInfoWithButton> { static constexpr const wchar_t* Name = L"IOMouseInfoWithButton"; };
	template<> struct JsonNameHelper<::vl::presentation::NativeWindowKeyInfo> { static constexpr const wchar_t* Name = L"IOKeyInfo"; };
	template<> struct JsonNameHelper<::vl::presentation::NativeWindowCharInfo> { static constexpr const wchar_t* Name = L"IOCharInfo"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::GlobalShortcutKey> { static constexpr const wchar_t* Name = L"GlobalShortcutKey"; };
	template<> struct JsonNameHelper<::vl::presentation::elements::ElementShape> { static constexpr const wchar_t* Name = L"ElementShape"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_SolidBorder> { static constexpr const wchar_t* Name = L"ElementDesc_SolidBorder"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_SinkBorder> { static constexpr const wchar_t* Name = L"ElementDesc_SinkBorder"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter> { static constexpr const wchar_t* Name = L"ElementDesc_SinkSplitter"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_SolidBackground> { static constexpr const wchar_t* Name = L"ElementDesc_SolidBackground"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_GradientBackground> { static constexpr const wchar_t* Name = L"ElementDesc_GradientBackground"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_InnerShadow> { static constexpr const wchar_t* Name = L"ElementDesc_InnerShadow"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_Polygon> { static constexpr const wchar_t* Name = L"ElementDesc_Polygon"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_SolidLabel> { static constexpr const wchar_t* Name = L"ElementDesc_SolidLabel"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ImageCreation> { static constexpr const wchar_t* Name = L"ImageCreation"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ImageFrameMetadata> { static constexpr const wchar_t* Name = L"ImageFrameMetadata"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ImageMetadata> { static constexpr const wchar_t* Name = L"ImageMetadata"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementDesc_ImageFrame> { static constexpr const wchar_t* Name = L"ElementDesc_ImageFrame"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::RendererCreation> { static constexpr const wchar_t* Name = L"RendererCreation"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementBeginRendering> { static constexpr const wchar_t* Name = L"ElementBeginRendering"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementRendering> { static constexpr const wchar_t* Name = L"ElementRendering"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementBoundary> { static constexpr const wchar_t* Name = L"ElementBoundary"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight> { static constexpr const wchar_t* Name = L"ElementMeasuring_FontHeight"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize> { static constexpr const wchar_t* Name = L"ElementMeasuring_ElementMinSize"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::ElementMeasurings> { static constexpr const wchar_t* Name = L"ElementMeasurings"; };
	template<> struct JsonNameHelper<::vl::Ptr<::vl::presentation::remoteprotocol::RenderingDom>> { static constexpr const wchar_t* Name = L"RenderingDom"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary> { static constexpr const wchar_t* Name = L"RenderingCommand_BeginBoundary"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary> { static constexpr const wchar_t* Name = L"RenderingCommand_EndBoundary"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::RenderingCommand_Element> { static constexpr const wchar_t* Name = L"RenderingCommand_Element"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::RenderingFrame> { static constexpr const wchar_t* Name = L"RenderingFrame"; };
	template<> struct JsonNameHelper<::vl::presentation::remoteprotocol::RenderingTrace> { static constexpr const wchar_t* Name = L"RenderingTrace"; };
}
namespace vl::presentation::remoteprotocol
{
	enum class IOMouseButton
	{
		Left,
		Middle,
		Right,
	};

	enum class ElementHorizontalAlignment
	{
		Left,
		Right,
		Center,
	};

	enum class ElementVerticalAlignment
	{
		Top,
		Bottom,
		Center,
	};

	enum class ElementSolidLabelMeasuringRequest
	{
		FontHeight,
		TotalSize,
	};

	enum class RendererType
	{
		FocusRectangle,
		SolidBorder,
		SinkBorder,
		SinkSplitter,
		SolidBackground,
		GradientBackground,
		InnerShadow,
		SolidLabel,
		Polygon,
		ImageFrame,
		UnsupportedColorizedText,
		UnsupportedDocument,
	};

	using ElementDescVariant = ::vl::Variant<
		::vl::presentation::remoteprotocol::ElementDesc_SolidBorder,
		::vl::presentation::remoteprotocol::ElementDesc_SinkBorder,
		::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter,
		::vl::presentation::remoteprotocol::ElementDesc_SolidBackground,
		::vl::presentation::remoteprotocol::ElementDesc_GradientBackground,
		::vl::presentation::remoteprotocol::ElementDesc_InnerShadow,
		::vl::presentation::remoteprotocol::ElementDesc_Polygon,
		::vl::presentation::remoteprotocol::ElementDesc_SolidLabel,
		::vl::presentation::remoteprotocol::ElementDesc_ImageFrame
	>;

	using RenderingCommand = ::vl::Variant<
		::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary,
		::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary,
		::vl::presentation::remoteprotocol::RenderingCommand_Element
	>;

	struct FontConfig
	{
		::vl::presentation::FontProperties defaultFont;
		::vl::Ptr<::vl::collections::List<::vl::WString>> supportedFonts;
	};

	struct ScreenConfig
	{
		::vl::presentation::NativeRect bounds;
		::vl::presentation::NativeRect clientBounds;
		double scalingX;
		double scalingY;
	};

	struct WindowSizingConfig
	{
		::vl::presentation::NativeRect bounds;
		::vl::presentation::NativeRect clientBounds;
		::vl::presentation::INativeWindow::WindowSizeState sizeState;
		::vl::presentation::NativeMargin customFramePadding;
	};

	struct WindowShowing
	{
		bool activate;
		::vl::presentation::INativeWindow::WindowSizeState sizeState;
	};

	struct IOMouseInfoWithButton
	{
		::vl::presentation::remoteprotocol::IOMouseButton button;
		::vl::presentation::NativeWindowMouseInfo info;
	};

	struct GlobalShortcutKey
	{
		::vl::vint id;
		bool ctrl;
		bool shift;
		bool alt;
		::vl::presentation::VKEY code;
	};

	struct ElementDesc_SolidBorder
	{
		::vl::vint id;
		::vl::presentation::Color borderColor;
		::vl::presentation::elements::ElementShape shape;
	};

	struct ElementDesc_SinkBorder
	{
		::vl::vint id;
		::vl::presentation::Color leftTopColor;
		::vl::presentation::Color rightBottomColor;
	};

	struct ElementDesc_SinkSplitter
	{
		::vl::vint id;
		::vl::presentation::Color leftTopColor;
		::vl::presentation::Color rightBottomColor;
		::vl::presentation::elements::Gui3DSplitterElement::Direction direction;
	};

	struct ElementDesc_SolidBackground
	{
		::vl::vint id;
		::vl::presentation::Color backgroundColor;
		::vl::presentation::elements::ElementShape shape;
	};

	struct ElementDesc_GradientBackground
	{
		::vl::vint id;
		::vl::presentation::Color leftTopColor;
		::vl::presentation::Color rightBottomColor;
		::vl::presentation::elements::GuiGradientBackgroundElement::Direction direction;
		::vl::presentation::elements::ElementShape shape;
	};

	struct ElementDesc_InnerShadow
	{
		::vl::vint id;
		::vl::presentation::Color shadowColor;
		::vl::vint thickness;
	};

	struct ElementDesc_Polygon
	{
		::vl::vint id;
		::vl::presentation::Size size;
		::vl::presentation::Color borderColor;
		::vl::presentation::Color backgroundColor;
		::vl::Ptr<::vl::collections::List<::vl::presentation::Point>> points;
	};

	struct ElementDesc_SolidLabel
	{
		::vl::vint id;
		::vl::presentation::Color textColor;
		::vl::presentation::remoteprotocol::ElementHorizontalAlignment horizontalAlignment;
		::vl::presentation::remoteprotocol::ElementVerticalAlignment verticalAlignment;
		bool wrapLine;
		bool wrapLineHeightCalculation;
		bool ellipse;
		bool multiline;
		::vl::Nullable<::vl::presentation::FontProperties> font;
		::vl::Nullable<::vl::WString> text;
		::vl::Nullable<::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest> measuringRequest;
	};

	struct ImageCreation
	{
		::vl::vint id;
		::vl::Ptr<::vl::stream::MemoryStream> imageData;
		bool imageDataOmitted;
	};

	struct ImageFrameMetadata
	{
		::vl::presentation::Size size;
	};

	struct ImageMetadata
	{
		::vl::vint id;
		::vl::presentation::INativeImage::FormatType format;
		::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::ImageFrameMetadata>> frames;
	};

	struct ElementDesc_ImageFrame
	{
		::vl::vint id;
		::vl::Nullable<::vl::vint> imageId;
		::vl::vint imageFrame;
		::vl::presentation::remoteprotocol::ElementHorizontalAlignment horizontalAlignment;
		::vl::presentation::remoteprotocol::ElementVerticalAlignment verticalAlignment;
		bool stretch;
		bool enabled;
		::vl::Nullable<::vl::presentation::remoteprotocol::ImageCreation> imageCreation;
	};

	struct RendererCreation
	{
		::vl::vint id;
		::vl::presentation::remoteprotocol::RendererType type;
	};

	struct ElementBeginRendering
	{
		::vl::vint frameId;
	};

	struct ElementRendering
	{
		::vl::vint id;
		::vl::presentation::Rect bounds;
		::vl::presentation::Rect areaClippedByParent;
	};

	struct ElementBoundary
	{
		::vl::Nullable<::vl::presentation::INativeWindowListener::HitTestResult> hitTestResult;
		::vl::Nullable<::vl::presentation::INativeCursor::SystemCursorType> cursor;
		::vl::presentation::Rect bounds;
		::vl::presentation::Rect areaClippedBySelf;
	};

	struct ElementMeasuring_FontHeight
	{
		::vl::WString fontFamily;
		::vl::vint fontSize;
		::vl::vint height;
	};

	struct ElementMeasuring_ElementMinSize
	{
		::vl::vint id;
		::vl::presentation::Size minSize;
	};

	struct ElementMeasurings
	{
		::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight>> fontHeights;
		::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize>> minSizes;
		::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::ImageMetadata>> createdImages;
	};

	struct RenderingDom
	{
		::vl::Nullable<::vl::presentation::INativeWindowListener::HitTestResult> hitTestResult;
		::vl::Nullable<::vl::presentation::INativeCursor::SystemCursorType> cursor;
		::vl::Nullable<::vl::vint> element;
		::vl::presentation::Rect bounds;
		::vl::presentation::Rect validArea;
		::vl::Ptr<::vl::collections::List<::vl::Ptr<::vl::presentation::remoteprotocol::RenderingDom>>> children;
	};

	struct RenderingCommand_BeginBoundary
	{
		::vl::presentation::remoteprotocol::ElementBoundary boundary;
	};

	struct RenderingCommand_EndBoundary
	{
	};

	struct RenderingCommand_Element
	{
		::vl::presentation::remoteprotocol::ElementRendering rendering;
		::vl::Nullable<::vl::vint> element;
	};

	struct RenderingFrame
	{
		::vl::vint frameId;
		::vl::Nullable<::vl::WString> frameName;
		::vl::presentation::remoteprotocol::WindowSizingConfig windowSize;
		::vl::Ptr<::vl::collections::Dictionary<::vl::vint, ::vl::presentation::remoteprotocol::ElementDescVariant>> elements;
		::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::RenderingCommand>> commands;
		::vl::Ptr<::vl::presentation::remoteprotocol::RenderingDom> root;
	};

	struct RenderingTrace
	{
		::vl::Ptr<::vl::collections::Dictionary<::vl::vint, ::vl::presentation::remoteprotocol::RendererType>> createdElements;
		::vl::Ptr<::vl::presentation::remoteprotocol::ArrayMap<::vl::vint, ::vl::presentation::remoteprotocol::ImageCreation, &::vl::presentation::remoteprotocol::ImageCreation::id>> imageCreations;
		::vl::Ptr<::vl::presentation::remoteprotocol::ArrayMap<::vl::vint, ::vl::presentation::remoteprotocol::ImageMetadata, &::vl::presentation::remoteprotocol::ImageMetadata::id>> imageMetadatas;
		::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::RenderingFrame>> frames;
	};

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeWindowListener::HitTestResult>(const ::vl::presentation::INativeWindowListener::HitTestResult & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeCursor::SystemCursorType>(const ::vl::presentation::INativeCursor::SystemCursorType & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeWindow::WindowSizeState>(const ::vl::presentation::INativeWindow::WindowSizeState & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::IOMouseButton>(const ::vl::presentation::remoteprotocol::IOMouseButton & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::ElementShapeType>(const ::vl::presentation::elements::ElementShapeType & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::GuiGradientBackgroundElement::Direction>(const ::vl::presentation::elements::GuiGradientBackgroundElement::Direction & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::Gui3DSplitterElement::Direction>(const ::vl::presentation::elements::Gui3DSplitterElement::Direction & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementHorizontalAlignment>(const ::vl::presentation::remoteprotocol::ElementHorizontalAlignment & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementVerticalAlignment>(const ::vl::presentation::remoteprotocol::ElementVerticalAlignment & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest>(const ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeImage::FormatType>(const ::vl::presentation::INativeImage::FormatType & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RendererType>(const ::vl::presentation::remoteprotocol::RendererType & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeCoordinate>(const ::vl::presentation::NativeCoordinate & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativePoint>(const ::vl::presentation::NativePoint & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeSize>(const ::vl::presentation::NativeSize & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeRect>(const ::vl::presentation::NativeRect & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeMargin>(const ::vl::presentation::NativeMargin & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::Point>(const ::vl::presentation::Point & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::Size>(const ::vl::presentation::Size & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::Rect>(const ::vl::presentation::Rect & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::FontProperties>(const ::vl::presentation::FontProperties & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::FontConfig>(const ::vl::presentation::remoteprotocol::FontConfig & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ScreenConfig>(const ::vl::presentation::remoteprotocol::ScreenConfig & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::WindowSizingConfig>(const ::vl::presentation::remoteprotocol::WindowSizingConfig & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::WindowShowing>(const ::vl::presentation::remoteprotocol::WindowShowing & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeWindowMouseInfo>(const ::vl::presentation::NativeWindowMouseInfo & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::IOMouseInfoWithButton>(const ::vl::presentation::remoteprotocol::IOMouseInfoWithButton & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeWindowKeyInfo>(const ::vl::presentation::NativeWindowKeyInfo & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeWindowCharInfo>(const ::vl::presentation::NativeWindowCharInfo & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::GlobalShortcutKey>(const ::vl::presentation::remoteprotocol::GlobalShortcutKey & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::ElementShape>(const ::vl::presentation::elements::ElementShape & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SolidBorder>(const ::vl::presentation::remoteprotocol::ElementDesc_SolidBorder & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SinkBorder>(const ::vl::presentation::remoteprotocol::ElementDesc_SinkBorder & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter>(const ::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SolidBackground>(const ::vl::presentation::remoteprotocol::ElementDesc_SolidBackground & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_GradientBackground>(const ::vl::presentation::remoteprotocol::ElementDesc_GradientBackground & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_InnerShadow>(const ::vl::presentation::remoteprotocol::ElementDesc_InnerShadow & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_Polygon>(const ::vl::presentation::remoteprotocol::ElementDesc_Polygon & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SolidLabel>(const ::vl::presentation::remoteprotocol::ElementDesc_SolidLabel & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ImageCreation>(const ::vl::presentation::remoteprotocol::ImageCreation & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ImageFrameMetadata>(const ::vl::presentation::remoteprotocol::ImageFrameMetadata & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ImageMetadata>(const ::vl::presentation::remoteprotocol::ImageMetadata & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_ImageFrame>(const ::vl::presentation::remoteprotocol::ElementDesc_ImageFrame & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RendererCreation>(const ::vl::presentation::remoteprotocol::RendererCreation & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementBeginRendering>(const ::vl::presentation::remoteprotocol::ElementBeginRendering & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementRendering>(const ::vl::presentation::remoteprotocol::ElementRendering & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementBoundary>(const ::vl::presentation::remoteprotocol::ElementBoundary & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight>(const ::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize>(const ::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementMeasurings>(const ::vl::presentation::remoteprotocol::ElementMeasurings & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingDom>(const ::vl::presentation::remoteprotocol::RenderingDom & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary>(const ::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary>(const ::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingCommand_Element>(const ::vl::presentation::remoteprotocol::RenderingCommand_Element & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingFrame>(const ::vl::presentation::remoteprotocol::RenderingFrame & value);
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingTrace>(const ::vl::presentation::remoteprotocol::RenderingTrace & value);

	template<> void ConvertJsonToCustomType<::vl::presentation::INativeWindowListener::HitTestResult>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeWindowListener::HitTestResult& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::INativeCursor::SystemCursorType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeCursor::SystemCursorType& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::INativeWindow::WindowSizeState>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeWindow::WindowSizeState& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::IOMouseButton>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::IOMouseButton& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::elements::ElementShapeType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::ElementShapeType& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::elements::GuiGradientBackgroundElement::Direction>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::GuiGradientBackgroundElement::Direction& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::elements::Gui3DSplitterElement::Direction>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::Gui3DSplitterElement::Direction& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementHorizontalAlignment>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementHorizontalAlignment& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementVerticalAlignment>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementVerticalAlignment& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::INativeImage::FormatType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeImage::FormatType& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RendererType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RendererType& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativeCoordinate>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeCoordinate& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativePoint>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativePoint& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativeSize>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeSize& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativeRect>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeRect& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativeMargin>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeMargin& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::Point>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::Point& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::Size>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::Size& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::Rect>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::Rect& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::FontProperties>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::FontProperties& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::FontConfig>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::FontConfig& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ScreenConfig>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ScreenConfig& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::WindowSizingConfig>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::WindowSizingConfig& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::WindowShowing>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::WindowShowing& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativeWindowMouseInfo>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeWindowMouseInfo& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::IOMouseInfoWithButton>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::IOMouseInfoWithButton& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativeWindowKeyInfo>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeWindowKeyInfo& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::NativeWindowCharInfo>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeWindowCharInfo& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::GlobalShortcutKey>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::GlobalShortcutKey& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::elements::ElementShape>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::ElementShape& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidBorder>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SolidBorder& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SinkBorder>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SinkBorder& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidBackground>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SolidBackground& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_GradientBackground>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_GradientBackground& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_InnerShadow>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_InnerShadow& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_Polygon>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_Polygon& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidLabel>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SolidLabel& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageCreation>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ImageCreation& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageFrameMetadata>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ImageFrameMetadata& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageMetadata>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ImageMetadata& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_ImageFrame>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_ImageFrame& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RendererCreation>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RendererCreation& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementBeginRendering>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementBeginRendering& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementRendering>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementRendering& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementBoundary>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementBoundary& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasurings>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementMeasurings& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingDom>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingDom& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_Element>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingCommand_Element& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingFrame>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingFrame& value);
	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingTrace>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingTrace& value);

#define GACUI_REMOTEPROTOCOL_MESSAGES(HANDLER)\
	HANDLER(ControllerGetFontConfig, void, ::vl::presentation::remoteprotocol::FontConfig, NOREQ, RES, NODROP)\
	HANDLER(ControllerGetScreenConfig, void, ::vl::presentation::remoteprotocol::ScreenConfig, NOREQ, RES, NODROP)\
	HANDLER(ControllerConnectionEstablished, void, void, NOREQ, NORES, NODROP)\
	HANDLER(ControllerConnectionStopped, void, void, NOREQ, NORES, NODROP)\
	HANDLER(WindowGetBounds, void, ::vl::presentation::remoteprotocol::WindowSizingConfig, NOREQ, RES, NODROP)\
	HANDLER(WindowNotifySetTitle, ::vl::WString, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetEnabled, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetTopMost, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetShowInTaskBar, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetCustomFrameMode, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetMaximizedBox, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetMinimizedBox, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetBorder, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetSizeBox, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetIconVisible, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetTitleBar, bool, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetBounds, ::vl::presentation::NativeRect, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifySetClientSize, ::vl::presentation::NativeSize, void, REQ, NORES, DROPREP)\
	HANDLER(WindowNotifyActivate, void, void, NOREQ, NORES, DROPREP)\
	HANDLER(WindowNotifyShow, ::vl::presentation::remoteprotocol::WindowShowing, void, REQ, NORES, DROPREP)\
	HANDLER(IOUpdateGlobalShortcutKey, ::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::GlobalShortcutKey>>, void, REQ, NORES, NODROP)\
	HANDLER(IORequireCapture, void, void, NOREQ, NORES, NODROP)\
	HANDLER(IOReleaseCapture, void, void, NOREQ, NORES, NODROP)\
	HANDLER(IOIsKeyPressing, ::vl::presentation::VKEY, bool, REQ, RES, NODROP)\
	HANDLER(IOIsKeyToggled, ::vl::presentation::VKEY, bool, REQ, RES, NODROP)\
	HANDLER(RendererUpdateElement_SolidBorder, ::vl::presentation::remoteprotocol::ElementDesc_SolidBorder, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_SinkBorder, ::vl::presentation::remoteprotocol::ElementDesc_SinkBorder, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_SinkSplitter, ::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_SolidBackground, ::vl::presentation::remoteprotocol::ElementDesc_SolidBackground, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_GradientBackground, ::vl::presentation::remoteprotocol::ElementDesc_GradientBackground, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_InnerShadow, ::vl::presentation::remoteprotocol::ElementDesc_InnerShadow, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_Polygon, ::vl::presentation::remoteprotocol::ElementDesc_Polygon, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_SolidLabel, ::vl::presentation::remoteprotocol::ElementDesc_SolidLabel, void, REQ, NORES, NODROP)\
	HANDLER(ImageCreated, ::vl::presentation::remoteprotocol::ImageCreation, ::vl::presentation::remoteprotocol::ImageMetadata, REQ, RES, NODROP)\
	HANDLER(ImageDestroyed, ::vl::vint, void, REQ, NORES, NODROP)\
	HANDLER(RendererUpdateElement_ImageFrame, ::vl::presentation::remoteprotocol::ElementDesc_ImageFrame, void, REQ, NORES, NODROP)\
	HANDLER(RendererCreated, ::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::RendererCreation>>, void, REQ, NORES, NODROP)\
	HANDLER(RendererDestroyed, ::vl::Ptr<::vl::collections::List<::vl::vint>>, void, REQ, NORES, NODROP)\
	HANDLER(RendererBeginRendering, ::vl::presentation::remoteprotocol::ElementBeginRendering, void, REQ, NORES, NODROP)\
	HANDLER(RendererBeginBoundary, ::vl::presentation::remoteprotocol::ElementBoundary, void, REQ, NORES, NODROP)\
	HANDLER(RendererRenderElement, ::vl::presentation::remoteprotocol::ElementRendering, void, REQ, NORES, NODROP)\
	HANDLER(RendererEndBoundary, void, void, NOREQ, NORES, NODROP)\
	HANDLER(RendererEndRendering, void, ::vl::presentation::remoteprotocol::ElementMeasurings, NOREQ, RES, NODROP)\

#define GACUI_REMOTEPROTOCOL_EVENTS(HANDLER)\
	HANDLER(ControllerConnect, void, NOREQ, NODROP)\
	HANDLER(ControllerDisconnect, void, NOREQ, NODROP)\
	HANDLER(ControllerRequestExit, void, NOREQ, NODROP)\
	HANDLER(ControllerForceExit, void, NOREQ, NODROP)\
	HANDLER(ControllerScreenUpdated, ::vl::presentation::remoteprotocol::ScreenConfig, REQ, DROPREP)\
	HANDLER(WindowBoundsUpdated, ::vl::presentation::remoteprotocol::WindowSizingConfig, REQ, DROPREP)\
	HANDLER(WindowActivatedUpdated, bool, REQ, DROPREP)\
	HANDLER(IOGlobalShortcutKey, ::vl::vint, REQ, NODROP)\
	HANDLER(IOButtonDown, ::vl::presentation::remoteprotocol::IOMouseInfoWithButton, REQ, NODROP)\
	HANDLER(IOButtonDoubleClick, ::vl::presentation::remoteprotocol::IOMouseInfoWithButton, REQ, NODROP)\
	HANDLER(IOButtonUp, ::vl::presentation::remoteprotocol::IOMouseInfoWithButton, REQ, NODROP)\
	HANDLER(IOHWheel, ::vl::presentation::NativeWindowMouseInfo, REQ, NODROP)\
	HANDLER(IOVWheel, ::vl::presentation::NativeWindowMouseInfo, REQ, NODROP)\
	HANDLER(IOMouseMoving, ::vl::presentation::NativeWindowMouseInfo, REQ, DROPCON)\
	HANDLER(IOMouseEntered, void, NOREQ, NODROP)\
	HANDLER(IOMouseLeaved, void, NOREQ, NODROP)\
	HANDLER(IOKeyDown, ::vl::presentation::NativeWindowKeyInfo, REQ, NODROP)\
	HANDLER(IOKeyUp, ::vl::presentation::NativeWindowKeyInfo, REQ, NODROP)\
	HANDLER(IOChar, ::vl::presentation::NativeWindowCharInfo, REQ, NODROP)\

#define GACUI_REMOTEPROTOCOL_MESSAGE_REQUEST_TYPES(HANDLER)\
	HANDLER(::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::GlobalShortcutKey>>)\
	HANDLER(::vl::Ptr<::vl::collections::List<::vl::presentation::remoteprotocol::RendererCreation>>)\
	HANDLER(::vl::Ptr<::vl::collections::List<::vl::vint>>)\
	HANDLER(::vl::WString)\
	HANDLER(::vl::presentation::NativeRect)\
	HANDLER(::vl::presentation::NativeSize)\
	HANDLER(::vl::presentation::VKEY)\
	HANDLER(::vl::presentation::remoteprotocol::ElementBeginRendering)\
	HANDLER(::vl::presentation::remoteprotocol::ElementBoundary)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_GradientBackground)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_ImageFrame)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_InnerShadow)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_Polygon)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_SinkBorder)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_SolidBackground)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_SolidBorder)\
	HANDLER(::vl::presentation::remoteprotocol::ElementDesc_SolidLabel)\
	HANDLER(::vl::presentation::remoteprotocol::ElementRendering)\
	HANDLER(::vl::presentation::remoteprotocol::ImageCreation)\
	HANDLER(::vl::presentation::remoteprotocol::WindowShowing)\
	HANDLER(::vl::vint)\
	HANDLER(bool)\

#define GACUI_REMOTEPROTOCOL_MESSAGE_RESPONSE_TYPES(HANDLER)\
	HANDLER(::vl::presentation::remoteprotocol::ElementMeasurings)\
	HANDLER(::vl::presentation::remoteprotocol::FontConfig)\
	HANDLER(::vl::presentation::remoteprotocol::ImageMetadata)\
	HANDLER(::vl::presentation::remoteprotocol::ScreenConfig)\
	HANDLER(::vl::presentation::remoteprotocol::WindowSizingConfig)\
	HANDLER(bool)\

#define GACUI_REMOTEPROTOCOL_EVENT_REQUEST_TYPES(HANDLER)\
	HANDLER(::vl::presentation::NativeWindowCharInfo)\
	HANDLER(::vl::presentation::NativeWindowKeyInfo)\
	HANDLER(::vl::presentation::NativeWindowMouseInfo)\
	HANDLER(::vl::presentation::remoteprotocol::IOMouseInfoWithButton)\
	HANDLER(::vl::presentation::remoteprotocol::ScreenConfig)\
	HANDLER(::vl::presentation::remoteprotocol::WindowSizingConfig)\
	HANDLER(::vl::vint)\
	HANDLER(bool)\

}

#endif


/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEGRAPHICS_IMAGESERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  GuiRemoteController

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTEGRAPHICS_IMAGESERVICE
#define VCZH_PRESENTATION_GUIREMOTEGRAPHICS_IMAGESERVICE


namespace vl::presentation
{
	class GuiRemoteController;

	namespace elements
	{
		class GuiRemoteGraphicsRenderTarget;
	}

	namespace elements_remoteprotocol
	{
		class GuiImageFrameElementRenderer;
	}

/***********************************************************************
GuiRemoteGraphicsImage
***********************************************************************/

	class GuiRemoteGraphicsImage;
	class GuiRemoteGraphicsImageService;

	class GuiRemoteGraphicsImageFrame : public NativeImageFrameBase
	{
		friend class GuiRemoteGraphicsImage;
	protected:
		GuiRemoteGraphicsImage*				image;
		Size								size;

	public:
		GuiRemoteGraphicsImageFrame(GuiRemoteGraphicsImage* _image);
		~GuiRemoteGraphicsImageFrame();

		INativeImage*						GetImage() override;
		Size								GetSize() override;
	};

	class GuiRemoteGraphicsImage : public Object, public virtual INativeImage
	{
		friend class GuiRemoteGraphicsImageService;
		friend class elements::GuiRemoteGraphicsRenderTarget;
		friend class elements_remoteprotocol::GuiImageFrameElementRenderer;
		using ImageFrameList = collections::List<Ptr<GuiRemoteGraphicsImageFrame>>;
	protected:
		enum class MetadataStatus
		{
			Uninitialized,
			Requested,
			Retrived,
		};

		GuiRemoteController*				remote;
		vint								id = -1;
		Ptr<stream::MemoryStream>			binary;
		INativeImage::FormatType			format = INativeImage::Unknown;
		ImageFrameList						frames;
		MetadataStatus						status = MetadataStatus::Uninitialized;

		void								EnsureMetadata();
	public:
		GuiRemoteGraphicsImage(GuiRemoteController* _remote, vint _id, Ptr<stream::MemoryStream> _binary);
		~GuiRemoteGraphicsImage();

		stream::IStream&					GetBinaryData();
		remoteprotocol::ImageCreation		GenerateImageCreation();
		void								UpdateFromImageMetadata(const remoteprotocol::ImageMetadata& imageMetadata);

		INativeImageService*				GetImageService() override;
		FormatType							GetFormat() override;
		vint								GetFrameCount() override;
		INativeImageFrame*					GetFrame(vint index) override;
		void								SaveToStream(stream::IStream& imageStream, FormatType formatType) override;
	};

/***********************************************************************
GuiRemoteGraphicsImageService
***********************************************************************/

	class GuiRemoteGraphicsImageService : public Object, public virtual INativeImageService
	{
		friend class GuiRemoteGraphicsImage;
		using ImageMap = collections::Dictionary<vint, GuiRemoteGraphicsImage*>;
	protected:
		GuiRemoteController*				remote;
		vint								usedImageIds = 0;
		ImageMap							images;

		Ptr<GuiRemoteGraphicsImage>			CreateImage(Ptr<stream::MemoryStream> binary);
	public:
		GuiRemoteGraphicsImageService(GuiRemoteController* _remote);
		~GuiRemoteGraphicsImageService();

		void								OnControllerConnect();
		void								OnControllerDisconnect();
		void								Initialize();
		void								Finalize();
		GuiRemoteGraphicsImage*				GetImage(vint id);

		Ptr<INativeImage>					CreateImageFromFile(const WString& path) override;
		Ptr<INativeImage>					CreateImageFromMemory(void* buffer, vint length) override;
		Ptr<INativeImage>					CreateImageFromStream(stream::IStream& imageStream) override;
	};
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEGRAPHICS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  GuiRemoteController

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTEGRAPHICS
#define VCZH_PRESENTATION_GUIREMOTEGRAPHICS


namespace vl::presentation
{
	class GuiHostedController;
	class GuiRemoteMessages;

	namespace elements_remoteprotocol
	{
		class IGuiRemoteProtocolElementRender;
	}

	namespace elements
	{

/***********************************************************************
GuiRemoteGraphicsRenderTarget
***********************************************************************/

		class GuiRemoteGraphicsRenderTarget : public GuiGraphicsRenderTarget
		{
			using RendererMap = collections::Dictionary<vint, elements_remoteprotocol::IGuiRemoteProtocolElementRender*>;
			using RendererSet = collections::SortedList<elements_remoteprotocol::IGuiRemoteProtocolElementRender*>;
			using FontHeightMap = collections::Dictionary<Tuple<WString, vint>, vint>;
			using HitTestResult = INativeWindowListener::HitTestResult;
			using SystemCursorType = INativeCursor::SystemCursorType;
		protected:
			GuiRemoteController*				remote;
			GuiHostedController*				hostedController;
			NativeSize							canvasSize;
			vint								usedFrameIds = 0;
			vint								usedElementIds = 0;
			RendererMap							renderers;
			collections::SortedList<vint>		createdRenderers;
			collections::SortedList<vint>		destroyedRenderers;
			RendererSet							renderersAskingForCache;
			Nullable<Rect>						clipperValidArea;
			collections::List<HitTestResult>	hitTestResults;
			collections::List<SystemCursorType>	cursors;

			HitTestResult						GetHitTestResultFromGenerator(reflection::DescriptableObject* generator);
			Nullable<SystemCursorType>			GetCursorFromGenerator(reflection::DescriptableObject* generator);

			void								StartRenderingOnNativeWindow() override;
			RenderTargetFailure					StopRenderingOnNativeWindow() override;

			Size								GetCanvasSize() override;
			void								AfterPushedClipper(Rect clipper, Rect validArea, reflection::DescriptableObject* generator) override;
			void								AfterPushedClipperAndBecameInvalid(Rect clipper, reflection::DescriptableObject* generator) override;
			void								AfterPoppedClipperAndBecameValid(Rect validArea, bool clipperExists, reflection::DescriptableObject* generator) override;
			void								AfterPoppedClipper(Rect validArea, bool clipperExists, reflection::DescriptableObject* generator) override;

		public:
			FontHeightMap						fontHeights;
			vuint64_t							renderingBatchId = 0;

			GuiRemoteGraphicsRenderTarget(GuiRemoteController* _remote, GuiHostedController* _hostedController);
			~GuiRemoteGraphicsRenderTarget();

			void								OnControllerConnect();
			void								OnControllerDisconnect();

			GuiRemoteMessages&					GetRemoteMessages();
			vint								AllocateNewElementId();
			void								RegisterRenderer(elements_remoteprotocol::IGuiRemoteProtocolElementRender* renderer);
			void								UnregisterRenderer(elements_remoteprotocol::IGuiRemoteProtocolElementRender* renderer);
			Rect								GetClipperValidArea();
		};

/***********************************************************************
GuiRemoteGraphicsResourceManager
***********************************************************************/

		class GuiRemoteGraphicsResourceManager : public GuiGraphicsResourceManager
		{
		protected:
			GuiRemoteController*				remote;
			GuiRemoteGraphicsRenderTarget		renderTarget;
			GuiHostedController*				hostedController;

		public:
			GuiRemoteGraphicsResourceManager(GuiRemoteController* _remote, GuiHostedController* _hostedController);
			~GuiRemoteGraphicsResourceManager();

			void								Initialize();
			void								Finalize();

			void								OnControllerConnect();
			void								OnControllerDisconnect();

			// =============================================================
			// IGuiGraphicsResourceManager
			// =============================================================

			IGuiGraphicsRenderTarget*			GetRenderTarget(INativeWindow* window) override;
			void								RecreateRenderTarget(INativeWindow* window) override;
			void								ResizeRenderTarget(INativeWindow* window) override;
			IGuiGraphicsLayoutProvider*			GetLayoutProvider() override;
		};
	}
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEGRAPHICS_BASICELEMENTS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTEGRAPHICS_BASICELEMENTS
#define VCZH_PRESENTATION_GUIREMOTEGRAPHICS_BASICELEMENTS


namespace vl::presentation::elements_remoteprotocol
{
	using namespace elements;

	class IGuiRemoteProtocolElementRender : public virtual Interface
	{
	public:
		virtual IGuiGraphicsRenderer*			GetRenderer() = 0;
		virtual vint							GetID() = 0;
		virtual remoteprotocol::RendererType	GetRendererType() = 0;
		virtual bool							IsUpdated() = 0;
		virtual void							ResetUpdated() = 0;
		virtual void							SendUpdateElementMessages(bool fullContent) = 0;
		virtual bool							IsRenderedInLastBatch() = 0;

		virtual bool							NeedUpdateMinSizeFromCache() = 0;
		virtual void							TryFetchMinSizeFromCache() = 0;
		virtual void							UpdateMinSize(Size size) = 0;
		virtual void							NotifyMinSizeCacheInvalidated() = 0;
	};

	template<typename TElement, typename TRenderer, remoteprotocol::RendererType _RendererType>
	class GuiRemoteProtocolElementRenderer
		: public GuiElementRendererBase<TElement, TRenderer, GuiRemoteGraphicsRenderTarget>
		, public virtual IGuiRemoteProtocolElementRender
	{
	protected:
		vint							id = -1;
		vuint64_t						renderingBatchId = 0;
		bool							updated = true;

		void							InitializeInternal();
		void							FinalizeInternal();
		void							RenderTargetChangedInternal(GuiRemoteGraphicsRenderTarget* oldRenderTarget, GuiRemoteGraphicsRenderTarget* newRenderTarget);
	public:
		// IGuiRemoteProtocolElementRender
		IGuiGraphicsRenderer*			GetRenderer() override;
		vint							GetID() override;
		remoteprotocol::RendererType	GetRendererType() override;
		bool							IsUpdated() override;
		void							ResetUpdated() override;
		bool							IsRenderedInLastBatch() override;

		bool							NeedUpdateMinSizeFromCache() override;
		void							TryFetchMinSizeFromCache() override;
		void							UpdateMinSize(Size size) override;
		void							NotifyMinSizeCacheInvalidated() override;

		// IGuiGraphicsRenderer
		void							Render(Rect bounds) override;
		void							OnElementStateChanged() override;
	};

	class GuiFocusRectangleElementRenderer : public GuiRemoteProtocolElementRenderer<GuiFocusRectangleElement, GuiFocusRectangleElementRenderer, remoteprotocol::RendererType::FocusRectangle>
	{
		friend class GuiElementRendererBase<GuiFocusRectangleElement, GuiFocusRectangleElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		GuiFocusRectangleElementRenderer();

		bool							IsUpdated() override;
		void							ResetUpdated() override;
		void							SendUpdateElementMessages(bool fullContent) override;
		void							OnElementStateChanged() override;
	};

	class GuiSolidBorderElementRenderer : public GuiRemoteProtocolElementRenderer<GuiSolidBorderElement, GuiSolidBorderElementRenderer, remoteprotocol::RendererType::SolidBorder>
	{
		friend class GuiElementRendererBase<GuiSolidBorderElement, GuiSolidBorderElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		GuiSolidBorderElementRenderer();

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class Gui3DBorderElementRenderer : public GuiRemoteProtocolElementRenderer<Gui3DBorderElement, Gui3DBorderElementRenderer, remoteprotocol::RendererType::SinkBorder>
	{
		friend class GuiElementRendererBase<Gui3DBorderElement, Gui3DBorderElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		Gui3DBorderElementRenderer();

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class Gui3DSplitterElementRenderer : public GuiRemoteProtocolElementRenderer<Gui3DSplitterElement, Gui3DSplitterElementRenderer, remoteprotocol::RendererType::SinkSplitter>
	{
		friend class GuiElementRendererBase<Gui3DSplitterElement, Gui3DSplitterElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		Gui3DSplitterElementRenderer();

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class GuiSolidBackgroundElementRenderer : public GuiRemoteProtocolElementRenderer<GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, remoteprotocol::RendererType::SolidBackground>
	{
		friend class GuiElementRendererBase<GuiSolidBackgroundElement, GuiSolidBackgroundElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		GuiSolidBackgroundElementRenderer();

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class GuiGradientBackgroundElementRenderer : public GuiRemoteProtocolElementRenderer<GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, remoteprotocol::RendererType::GradientBackground>
	{
		friend class GuiElementRendererBase<GuiGradientBackgroundElement, GuiGradientBackgroundElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		GuiGradientBackgroundElementRenderer();

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class GuiInnerShadowElementRenderer : public GuiRemoteProtocolElementRenderer<GuiInnerShadowElement, GuiInnerShadowElementRenderer, remoteprotocol::RendererType::InnerShadow>
	{
		friend class GuiElementRendererBase<GuiInnerShadowElement, GuiInnerShadowElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		GuiInnerShadowElementRenderer();

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class GuiSolidLabelElementRenderer : public GuiRemoteProtocolElementRenderer<GuiSolidLabelElement, GuiSolidLabelElementRenderer, remoteprotocol::RendererType::SolidLabel>
	{
		friend class GuiElementRendererBase<GuiSolidLabelElement, GuiSolidLabelElementRenderer, GuiRemoteGraphicsRenderTarget>;
		using MeasuringRequest = Nullable<remoteprotocol::ElementSolidLabelMeasuringRequest>;
	protected:
		FontProperties					lastFont;
		WString							lastText;
		bool							needFontHeight = false;

		MeasuringRequest				GetMeasuringRequest();
		bool							IsNeedFontHeight(MeasuringRequest request);
	public:
		GuiSolidLabelElementRenderer();

		bool							NeedUpdateMinSizeFromCache() override;
		void							TryFetchMinSizeFromCache() override;
		void							UpdateMinSize(Size size) override;
		void							NotifyMinSizeCacheInvalidated() override;

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class GuiImageFrameElementRenderer : public GuiRemoteProtocolElementRenderer<GuiImageFrameElement, GuiImageFrameElementRenderer, remoteprotocol::RendererType::ImageFrame>
	{
		friend class GuiElementRendererBase<GuiImageFrameElement, GuiImageFrameElementRenderer, GuiRemoteGraphicsRenderTarget>;
	protected:
		bool							needUpdateSize = false;

		GuiRemoteGraphicsImage*			GetRemoteImage();
		void							UpdateMinSizeFromImage(GuiRemoteGraphicsImage* image);
	public:
		GuiImageFrameElementRenderer();

		bool							NeedUpdateMinSizeFromCache() override;
		void							TryFetchMinSizeFromCache() override;
		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class GuiPolygonElementRenderer : public GuiRemoteProtocolElementRenderer<GuiPolygonElement, GuiPolygonElementRenderer, remoteprotocol::RendererType::Polygon>
	{
		friend class GuiElementRendererBase<GuiPolygonElement, GuiPolygonElementRenderer, GuiRemoteGraphicsRenderTarget>;
	public:
		GuiPolygonElementRenderer();

		void							SendUpdateElementMessages(bool fullContent) override;
	};

	class GuiColorizedTextElementRenderer : public GuiRemoteProtocolElementRenderer<GuiColorizedTextElement, GuiColorizedTextElementRenderer, remoteprotocol::RendererType::UnsupportedColorizedText>, protected GuiColorizedTextElement::ICallback
	{
		friend class GuiElementRendererBase<GuiColorizedTextElement, GuiColorizedTextElementRenderer, GuiRemoteGraphicsRenderTarget>;
		using TBase = GuiRemoteProtocolElementRenderer<GuiColorizedTextElement, GuiColorizedTextElementRenderer, remoteprotocol::RendererType::UnsupportedColorizedText>;
	protected:
		void							ColorChanged() override;
		void							FontChanged() override;
		void							InitializeInternal();
		void							FinalizeInternal();
	public:
		GuiColorizedTextElementRenderer();

		void							OnElementStateChanged() override;
		void							SendUpdateElementMessages(bool fullContent) override;
	};
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEPROTOCOL_SHARED.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  IGuiRemoteProtocol

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL_SHARED
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL_SHARED


namespace vl::presentation
{
/***********************************************************************
IGuiRemoteProtocolEvents
***********************************************************************/

	class IGuiRemoteProtocolEvents : public virtual Interface
	{
	public:
#define EVENT_NOREQ(NAME, REQUEST)					virtual void On ## NAME() = 0;
#define EVENT_REQ(NAME, REQUEST)					virtual void On ## NAME(const REQUEST& arguments) = 0;
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, ...)	EVENT_ ## REQTAG(NAME, REQUEST)
		GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_REQ
#undef EVENT_NOREQ

#define MESSAGE_NORES(NAME, RESPONSE)
#define MESSAGE_RES(NAME, RESPONSE)										virtual void Respond ## NAME(vint id, const RESPONSE& arguments) = 0;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## RESTAG(NAME, RESPONSE)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_RES
#undef MESSAGE_NORES
	};

/***********************************************************************
IGuiRemoteProtocolMessages
***********************************************************************/

	class IGuiRemoteProtocolMessages : public virtual Interface
	{
	public:
#define MESSAGE_NOREQ_NORES(NAME, REQUEST, RESPONSE)					virtual void Request ## NAME() = 0;
#define MESSAGE_NOREQ_RES(NAME, REQUEST, RESPONSE)						virtual void Request ## NAME(vint id) = 0;
#define MESSAGE_REQ_NORES(NAME, REQUEST, RESPONSE)						virtual void Request ## NAME(const REQUEST& arguments) = 0;
#define MESSAGE_REQ_RES(NAME, REQUEST, RESPONSE)						virtual void Request ## NAME(vint id, const REQUEST& arguments) = 0;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## REQTAG ## _ ## RESTAG(NAME, REQUEST, RESPONSE)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_REQ_RES
#undef MESSAGE_REQ_NORES
#undef MESSAGE_NOREQ_RES
#undef MESSAGE_NOREQ_NORES
	};

/***********************************************************************
IGuiRemoteProtocolConfig
***********************************************************************/

	class IGuiRemoteProtocolConfig : public virtual Interface
	{
	public:
		virtual WString			GetExecutablePath() = 0;
	};

/***********************************************************************
IGuiRemoteProtocol
***********************************************************************/

	class IGuiRemoteProtocol
		: public virtual IGuiRemoteProtocolConfig
		, public virtual IGuiRemoteProtocolMessages
	{
	public:
		virtual void			Initialize(IGuiRemoteProtocolEvents* events) = 0;
		virtual void			Submit() = 0;
		virtual void			ProcessRemoteEvents() = 0;
	};

	class GuiRemoteEventCombinator : public Object, public virtual IGuiRemoteProtocolEvents
	{
	public:
		IGuiRemoteProtocolEvents*		targetEvents = nullptr;
	};

	template<typename TEvents>
		requires(std::is_base_of_v<GuiRemoteEventCombinator, TEvents>)
	class GuiRemoteProtocolCombinator : public Object, public virtual IGuiRemoteProtocol
	{
	protected:
		IGuiRemoteProtocol*				targetProtocol = nullptr;
		TEvents							eventCombinator;

	public:
		GuiRemoteProtocolCombinator(IGuiRemoteProtocol* _protocol)
			: targetProtocol(_protocol)
		{
		}

		// protocol

		WString GetExecutablePath() override
		{
			return targetProtocol->GetExecutablePath();
		}

		void Initialize(IGuiRemoteProtocolEvents* _events) override
		{
			eventCombinator.targetEvents = _events;
			targetProtocol->Initialize(&eventCombinator);
		}

		void Submit() override
		{
			targetProtocol->Submit();
		}

		void ProcessRemoteEvents() override
		{
			targetProtocol->ProcessRemoteEvents();
		}
	};
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEPROTOCOL_FILTERVERIFIER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  IGuiRemoteProtocol

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL_FILTERVERIFIER
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL_FILTERVERIFIER


namespace vl::presentation::remoteprotocol::repeatfiltering
{
/***********************************************************************
GuiRemoteEventFilterVerifier
***********************************************************************/

	class GuiRemoteEventFilterVerifier : public GuiRemoteEventCombinator
	{
	protected:
#define EVENT_NODROP(NAME)
#define EVENT_DROPREP(NAME)										bool lastDropRepeatEvent ## NAME = false;
#define EVENT_DROPCON(NAME)										bool lastDropConsecutiveEvent ## NAME = false;
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, DROPTAG, ...)		EVENT_ ## DROPTAG(NAME)
			GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_DROPCON
#undef EVENT_DROPREP
#undef EVENT_NODROP

	public:
		bool													submitting = false;

		void ClearDropRepeatMasks()
		{
#define EVENT_NODROP(NAME)
#define EVENT_DROPREP(NAME)									lastDropRepeatEvent ## NAME = false;
#define EVENT_DROPCON(NAME)
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, DROPTAG, ...)	EVENT_ ## DROPTAG(NAME)
			GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_DROPCON
#undef EVENT_DROPREP
#undef EVENT_NODROP
		}

		void ClearDropConsecutiveMasks()
		{
#define EVENT_NODROP(NAME)
#define EVENT_DROPREP(NAME)
#define EVENT_DROPCON(NAME)									lastDropConsecutiveEvent ## NAME = false;
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, DROPTAG, ...)	EVENT_ ## DROPTAG(NAME)
			GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_DROPCON
#undef EVENT_DROPREP
#undef EVENT_NODROP
		}

		// responses

#define MESSAGE_NORES(NAME, RESPONSE)
#define MESSAGE_RES(NAME, RESPONSE)\
		void Respond ## NAME(vint id, const RESPONSE& arguments) override\
		{\
			targetEvents->Respond ## NAME(id, arguments);\
		}\
	
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## RESTAG(NAME, RESPONSE)
			GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_RES
#undef MESSAGE_NORES

		// events
	
#define EVENT_NODROP(NAME)
	
#define EVENT_DROPREP(NAME)\
			CHECK_ERROR(!lastDropRepeatEvent ## NAME, L"vl::presentation::remoteprotocol::GuiRemoteEventFilterVerifier::On" L ## #NAME L"(...)#[@DropRepeat] event repeated.");\
			lastDropRepeatEvent ## NAME = true;\
	
#define EVENT_DROPCON(NAME)\
			CHECK_ERROR(!lastDropConsecutiveEvent ## NAME, L"vl::presentation::remoteprotocol::GuiRemoteEventFilterVerifier::On" L ## #NAME L"(...)#[@DropConsecutive] event repeated.");\
			ClearDropConsecutiveMasks();\
			lastDropConsecutiveEvent ## NAME = true;\
	
#define EVENT_NOREQ(NAME, REQUEST, DROPTAG)\
		void On ## NAME() override\
		{\
			if (submitting)\
			{\
				EVENT_ ## DROPTAG(NAME);\
				targetEvents->On ## NAME();\
			}\
			else\
			{\
				targetEvents->On ## NAME();\
			}\
		}\
	
#define EVENT_REQ(NAME, REQUEST, DROPTAG)\
		void On ## NAME(const REQUEST& arguments) override\
		{\
			if (submitting)\
			{\
				EVENT_ ## DROPTAG(NAME);\
				targetEvents->On ## NAME(arguments);\
			}\
			else\
			{\
				targetEvents->On ## NAME(arguments);\
			}\
		}\
	
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, DROPTAG, ...)	EVENT_ ## REQTAG(NAME, REQUEST, DROPTAG)
		GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_REQ
#undef EVENT_NOREQ
#undef EVENT_DROPCON
#undef EVENT_DROPREP
#undef EVENT_NOREP
	};

/***********************************************************************
GuiRemoteProtocolFilterVerifier
***********************************************************************/

	class GuiRemoteProtocolFilter;
	
	class GuiRemoteProtocolFilterVerifier : public GuiRemoteProtocolCombinator<GuiRemoteEventFilterVerifier>
	{
		friend class GuiRemoteProtocolFilter;
	protected:
		vint													lastRequestId = -1;
	
#define MESSAGE_NODROP(NAME)
#define MESSAGE_DROPREP(NAME)												bool lastDropRepeatRequest ## NAME = false;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, DROPTAG)	MESSAGE_ ## DROPTAG(NAME)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_DROPREP
#undef MESSAGE_NODROP
	
		void ClearDropRepeatMasks()
		{
#define MESSAGE_NODROP(NAME)
#define MESSAGE_DROPREP(NAME)												lastDropRepeatRequest ## NAME = false;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, DROPTAG)	MESSAGE_ ## DROPTAG(NAME)
			GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_DROPREP
#undef MESSAGE_NODROP
		}
	public:
		GuiRemoteProtocolFilterVerifier(IGuiRemoteProtocol* _protocol)
			: GuiRemoteProtocolCombinator<GuiRemoteEventFilterVerifier>(_protocol)
		{
		}
	
	protected:
	
	public:
	
		// messages
	
#define MESSAGE_NODROP(NAME)
	
#define MESSAGE_DROPREP(NAME)\
			CHECK_ERROR(!lastDropRepeatRequest ## NAME, L"vl::presentation::remoteprotocol::GuiRemoteProtocolFilterVerifier::Request" L ## #NAME L"(...)#[@DropRepeat] message repeated.");\
			lastDropRepeatRequest ## NAME = true;\
	
#define MESSAGE_NOREQ_NORES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME() override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			targetProtocol->Request ## NAME();\
		}\
	
#define MESSAGE_NOREQ_RES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME(vint id) override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			targetProtocol->Request ## NAME(id);\
		}\
	
#define MESSAGE_REQ_NORES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME(const REQUEST& arguments) override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			targetProtocol->Request ## NAME(arguments);\
		}\
	
#define MESSAGE_REQ_RES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME(vint id, const REQUEST& arguments) override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			targetProtocol->Request ## NAME(id, arguments);\
		}\
	
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, DROPTAG, ...)	MESSAGE_ ## REQTAG ## _ ## RESTAG(NAME, REQUEST, RESPONSE, DROPTAG)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_REQ_RES
#undef MESSAGE_REQ_NORES
#undef MESSAGE_NOREQ_RES
#undef MESSAGE_NOREQ_NORES
#undef MESSAGE_DROPREP
#undef MESSAGE_NODROP
	
		// protocol
	
		void Submit() override
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::repeatfiltering::GuiRemoteProtocolFilterVerifier::Submit()#"
			CHECK_ERROR(!eventCombinator.submitting, ERROR_MESSAGE_PREFIX L"This function is not allowed to be called recursively.");
			eventCombinator.submitting = true;
			GuiRemoteProtocolCombinator<GuiRemoteEventFilterVerifier>::Submit();
			ClearDropRepeatMasks();
			eventCombinator.ClearDropRepeatMasks();
			eventCombinator.ClearDropConsecutiveMasks();
			eventCombinator.submitting = false;
#undef ERROR_MESSAGE_PREFIX
		}
	};
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEPROTOCOL_FILTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  IGuiRemoteProtocol

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL_FILTER
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL_FILTER


namespace vl::presentation::remoteprotocol::repeatfiltering
{
	using FilteredRequestTypes = Variant<std::nullptr_t
#define FILTERED_VARIANT_ELEMENT(TYPE) ,TYPE
		GACUI_REMOTEPROTOCOL_MESSAGE_REQUEST_TYPES(FILTERED_VARIANT_ELEMENT)
#undef FILTERED_VARIANT_ELEMENT
		>;
	
	using FilteredResponseTypes = Variant<std::nullptr_t
#define FILTERED_VARIANT_ELEMENT(TYPE) ,TYPE
		GACUI_REMOTEPROTOCOL_MESSAGE_RESPONSE_TYPES(FILTERED_VARIANT_ELEMENT)
#undef FILTERED_VARIANT_ELEMENT
		>;
	
	using FilteredEventTypes = Variant<std::nullptr_t
#define FILTERED_VARIANT_ELEMENT(TYPE) ,TYPE
		GACUI_REMOTEPROTOCOL_EVENT_REQUEST_TYPES(FILTERED_VARIANT_ELEMENT)
#undef FILTERED_VARIANT_ELEMENT
		>;

	enum class FilteredRequestNames
	{
		Unknown,
#define FILTERED_ENUM_ITEM(NAME, ...) NAME,
		GACUI_REMOTEPROTOCOL_MESSAGES(FILTERED_ENUM_ITEM)
#undef FILTERED_ENUM_ITEM
	};

	enum class FilteredResponseNames
	{
		Unknown,
#define FILTERED_ENUM_ITEM_NORES(NAME)
#define FILTERED_ENUM_ITEM_RES(NAME) NAME,
#define FILTERED_ENUN_ITEM(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...) FILTERED_ENUM_ITEM_ ## RESTAG(NAME)
		GACUI_REMOTEPROTOCOL_MESSAGES(FILTERED_ENUN_ITEM)
#undef FILTERED_ENUM_ITEM
#undef FILTERED_ENUM_ITEM_RES
#undef FILTERED_ENUM_ITEM_NORES
	};

	enum class FilteredEventNames
	{
		Unknown,
#define FILTERED_ENUM_ITEM(NAME, ...) NAME,
		GACUI_REMOTEPROTOCOL_EVENTS(FILTERED_ENUM_ITEM)
#undef FILTERED_ENUM_ITEM
	};

	struct FilteredRequest
	{
		bool					dropped = false;
		vint					id = -1;
		FilteredRequestNames	name = FilteredRequestNames::Unknown;
		FilteredRequestTypes	arguments;
	};

	struct FilteredResponse
	{
		vint					id = -1;
		FilteredResponseNames	name = FilteredResponseNames::Unknown;
		FilteredResponseTypes	arguments;
	};

	struct FilteredEvent
	{
		bool					dropped = false;
		vint					id = -1;
		FilteredEventNames		name = FilteredEventNames::Unknown;
		FilteredEventTypes		arguments;
	};

/***********************************************************************
GuiRemoteEventFilter
***********************************************************************/

	class GuiRemoteEventFilter : public GuiRemoteEventCombinator
	{
	protected:
		collections::List<FilteredResponse>						filteredResponses;
		collections::List<FilteredEvent>						filteredEvents;

#define EVENT_NODROP(NAME)
#define EVENT_DROPREP(NAME)										vint lastDropRepeatEvent ## NAME = -1;
#define EVENT_DROPCON(NAME)										vint lastDropConsecutiveEvent ## NAME = -1;
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, DROPTAG, ...)		EVENT_ ## DROPTAG(NAME)
			GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_DROPCON
#undef EVENT_DROPREP
#undef EVENT_NODROP

	public:
		bool													submitting = false;
		collections::Dictionary<vint, FilteredResponseNames>	responseIds;
	
		void ProcessResponses()
		{
			for (auto&& response : filteredResponses)
			{
#define MESSAGE_NORES(NAME, RESPONSE)
#define MESSAGE_RES(NAME, RESPONSE)\
				case FilteredResponseNames::NAME:\
					targetEvents->Respond ## NAME(response.id, response.arguments.Get<RESPONSE>());\
					break;\
	
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## RESTAG(NAME, RESPONSE)
				switch (response.name)
				{
				GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
				default:
					CHECK_FAIL(L"vl::presentation::remoteprotocol::GuiRemoteEventFilter::ProcessResponses()#Unrecognized response.");
				}
#undef MESSAGE_HANDLER
#undef MESSAGE_RES
#undef MESSAGE_NORES
			}
	
			filteredResponses.Clear();
		}
	
		void ProcessEvents()
		{
#define EVENT_NODROP(NAME)
#define EVENT_DROPREP(NAME)									lastDropRepeatEvent ## NAME = -1;
#define EVENT_DROPCON(NAME)									lastDropConsecutiveEvent ## NAME = -1;
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, DROPTAG, ...)	EVENT_ ## DROPTAG(NAME)
			GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_DROPCON
#undef EVENT_DROPREP
#undef EVENT_NODROP
	
			collections::List<FilteredEvent> events(std::move(filteredEvents));
	
			for (auto&& event : events)
			{
				if (event.dropped)
				{
					continue;
				}
	
#define EVENT_NOREQ(NAME, REQUEST)\
				case FilteredEventNames::NAME:\
					targetEvents->On ## NAME();\
					break;\
	
#define EVENT_REQ(NAME, REQUEST)\
				case FilteredEventNames::NAME:\
					targetEvents->On ## NAME(event.arguments.Get<REQUEST>());\
					break;\
	
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, ...)	EVENT_ ## REQTAG(NAME, REQUEST)
				switch (event.name)
				{
				GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
				default:
					CHECK_FAIL(L"vl::presentation::remoteprotocol::GuiRemoteEventFilter::ProcessEvents()#Unrecognized event.");
				}
#undef EVENT_HANDLER
#undef EVENT_REQ
#undef EVENT_NOREQ
			}
		}

		// responses

#define MESSAGE_NORES(NAME, RESPONSE)
#define MESSAGE_RES(NAME, RESPONSE)\
		void Respond ## NAME(vint id, const RESPONSE& arguments) override\
		{\
			CHECK_ERROR(\
				responseIds[id] == FilteredResponseNames::NAME,\
				L"vl::presentation::remoteprotocol::GuiRemoteEventFilter::"\
				L"Respond" L ## #NAME L"()#"\
				L"Messages sending to IGuiRemoteProtocol should be responded by calling the correct function.");\
			responseIds.Remove(id);\
			FilteredResponse response;\
			response.id = id;\
			response.name = FilteredResponseNames::NAME;\
			response.arguments = arguments;\
			filteredResponses.Add(response);\
		}\
	
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## RESTAG(NAME, RESPONSE)
			GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_RES
#undef MESSAGE_NORES

		// events
	
#define EVENT_NODROP(NAME)
	
#define EVENT_DROPREP(NAME)\
			if (lastDropRepeatEvent ## NAME != -1)\
			{\
				filteredEvents[lastDropRepeatEvent ## NAME].dropped = true;\
			}\
			lastDropRepeatEvent ## NAME = filteredEvents.Count() - 1\
	
#define EVENT_DROPCON(NAME)\
			if (lastDropConsecutiveEvent ## NAME != -1 && lastDropConsecutiveEvent ## NAME == filteredEvents.Count() - 1)\
			{\
				filteredEvents[lastDropConsecutiveEvent ## NAME].dropped = true;\
			}\
			lastDropConsecutiveEvent ## NAME = filteredEvents.Count() - 1\
	
#define EVENT_NOREQ(NAME, REQUEST, DROPTAG)\
		void On ## NAME() override\
		{\
			if (submitting)\
			{\
				EVENT_ ## DROPTAG(NAME);\
				FilteredEvent event;\
				event.name = FilteredEventNames::NAME;\
				filteredEvents.Add(event);\
			}\
			else\
			{\
				targetEvents->On ## NAME();\
			}\
		}\
	
#define EVENT_REQ(NAME, REQUEST, DROPTAG)\
		void On ## NAME(const REQUEST& arguments) override\
		{\
			if (submitting)\
			{\
				EVENT_ ## DROPTAG(NAME);\
				FilteredEvent event;\
				event.name = FilteredEventNames::NAME;\
				event.arguments = arguments;\
				filteredEvents.Add(event);\
			}\
			else\
			{\
				targetEvents->On ## NAME(arguments);\
			}\
		}\
	
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, DROPTAG, ...)	EVENT_ ## REQTAG(NAME, REQUEST, DROPTAG)
		GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_REQ
#undef EVENT_NOREQ
#undef EVENT_DROPCON
#undef EVENT_DROPREP
#undef EVENT_NOREP
	};

/***********************************************************************
GuiRemoteProtocolFilter
***********************************************************************/
	
	class GuiRemoteProtocolFilter : public GuiRemoteProtocolCombinator<GuiRemoteEventFilter>
	{
	protected:
		vint													lastRequestId = -1;
		collections::List<FilteredRequest>						filteredRequests;
	
#define MESSAGE_NODROP(NAME)
#define MESSAGE_DROPREP(NAME)												vint lastDropRepeatRequest ## NAME = -1;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, DROPTAG)	MESSAGE_ ## DROPTAG(NAME)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_DROPREP
#undef MESSAGE_NODROP
	
		void ProcessRequests()
		{
#define MESSAGE_NODROP(NAME)
#define MESSAGE_DROPREP(NAME)												lastDropRepeatRequest ## NAME = -1;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, DROPTAG)	MESSAGE_ ## DROPTAG(NAME)
			GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_DROPREP
#undef MESSAGE_NODROP
	
			for (auto&& request : filteredRequests)
			{
				CHECK_ERROR(\
					!request.dropped || request.id == -1,\
					L"vl::presentation::remoteprotocol::GuiRemoteProtocolFilter::ProcessRequests()#"\
					L"Messages with id cannot be dropped.");\
				if (request.dropped)
				{
					continue;
				}
	
#define MESSAGE_NOREQ_NORES(NAME, REQUEST, RESPONSE)\
				case FilteredRequestNames::NAME:\
					targetProtocol->Request ## NAME();\
					break;\
	
#define MESSAGE_NOREQ_RES(NAME, REQUEST, RESPONSE)\
				case FilteredRequestNames::NAME:\
					targetProtocol->Request ## NAME(request.id);\
					break;\
	
#define MESSAGE_REQ_NORES(NAME, REQUEST, RESPONSE)\
				case FilteredRequestNames::NAME:\
					targetProtocol->Request ## NAME(request.arguments.Get<REQUEST>());\
					break;\
	
#define MESSAGE_REQ_RES(NAME, REQUEST, RESPONSE)\
				case FilteredRequestNames::NAME:\
					targetProtocol->Request ## NAME(request.id, request.arguments.Get<REQUEST>());\
					break;\
	
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## REQTAG ## _ ## RESTAG(NAME, REQUEST, RESPONSE)
				switch (request.name)
				{
				GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
				default:
					CHECK_FAIL(L"vl::presentation::remoteprotocol::GuiRemoteProtocolFilter::ProcessRequests()#Unrecognized request.");
				}
#undef MESSAGE_HANDLER
#undef MESSAGE_REQ_RES
#undef MESSAGE_REQ_NORES
#undef MESSAGE_NOREQ_RES
#undef MESSAGE_NOREQ_NORES
			}
	
			CHECK_ERROR(eventCombinator.responseIds.Count() == 0, L"Messages sending to IGuiRemoteProtocol should be all responded.");
			filteredRequests.Clear();
		}
	public:
		GuiRemoteProtocolFilter(IGuiRemoteProtocol* _protocol)
			: GuiRemoteProtocolCombinator<GuiRemoteEventFilter>(_protocol)
		{
		}
	
	protected:
	
	public:
	
		// messages
	
#define MESSAGE_NODROP(NAME)
	
#define MESSAGE_DROPREP(NAME)\
			if (lastDropRepeatRequest ## NAME != -1)\
			{\
				filteredRequests[lastDropRepeatRequest ## NAME].dropped = true;\
			}\
			lastDropRepeatRequest ## NAME = filteredRequests.Count()\
	
#define MESSAGE_NOREQ_NORES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME() override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			FilteredRequest request;\
			request.name = FilteredRequestNames::NAME;\
			filteredRequests.Add(request);\
		}\
	
#define MESSAGE_NOREQ_RES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME(vint id) override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			CHECK_ERROR(\
				lastRequestId < id,\
				L"vl::presentation::remoteprotocol::GuiRemoteProtocolFilter::"\
				L"Request" L ## #NAME L"()#"\
				L"Id of a message sending to IGuiRemoteProtocol should be increasing.");\
			lastRequestId = id;\
			FilteredRequest request;\
			request.id = id;\
			request.name = FilteredRequestNames::NAME;\
			filteredRequests.Add(request);\
			eventCombinator.responseIds.Add(id, FilteredResponseNames::NAME);\
		}\
	
#define MESSAGE_REQ_NORES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME(const REQUEST& arguments) override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			FilteredRequest request;\
			request.name = FilteredRequestNames::NAME;\
			request.arguments = arguments;\
			filteredRequests.Add(request);\
		}\
	
#define MESSAGE_REQ_RES(NAME, REQUEST, RESPONSE, DROPTAG)\
		void Request ## NAME(vint id, const REQUEST& arguments) override\
		{\
			MESSAGE_ ## DROPTAG(NAME);\
			CHECK_ERROR(\
				lastRequestId < id,\
				L"vl::presentation::remoteprotocol::GuiRemoteProtocolFilter::"\
				L"Request" L ## #NAME L"()#"\
				L"Id of a message sending to IGuiRemoteProtocol should be increasing.");\
			lastRequestId = id;\
			FilteredRequest request;\
			request.id = id;\
			request.name = FilteredRequestNames::NAME;\
			request.arguments = arguments;\
			filteredRequests.Add(request);\
			eventCombinator.responseIds.Add(id, FilteredResponseNames::NAME);\
		}\
	
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, DROPTAG, ...)	MESSAGE_ ## REQTAG ## _ ## RESTAG(NAME, REQUEST, RESPONSE, DROPTAG)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_REQ_RES
#undef MESSAGE_REQ_NORES
#undef MESSAGE_NOREQ_RES
#undef MESSAGE_NOREQ_NORES
#undef MESSAGE_DROPREP
#undef MESSAGE_NODROP
	
		// protocol
	
		void Initialize(IGuiRemoteProtocolEvents* _events) override
		{
			if (auto verifierProtocol = dynamic_cast<GuiRemoteProtocolFilterVerifier*>(targetProtocol))
			{
				verifierProtocol->targetProtocol->Initialize(&eventCombinator);
				eventCombinator.targetEvents = &verifierProtocol->eventCombinator;
				verifierProtocol->eventCombinator.targetEvents = _events;
			}
			else
			{
				GuiRemoteProtocolCombinator<GuiRemoteEventFilter>::Initialize(_events);
			}
		}
	
		void Submit() override
		{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::repeatfiltering::GuiRemoteProtocolFilter::Submit()#"
			CHECK_ERROR(!eventCombinator.submitting, ERROR_MESSAGE_PREFIX L"This function is not allowed to be called recursively.");
			eventCombinator.submitting = true;
			ProcessRequests();
			eventCombinator.ProcessResponses();
			GuiRemoteProtocolCombinator<GuiRemoteEventFilter>::Submit();
			eventCombinator.submitting = false;
			eventCombinator.ProcessEvents();
#undef ERROR_MESSAGE_PREFIX
		}
	};
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEPROTOCOL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  IGuiRemoteProtocol

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEPROTOCOL


#endif

/***********************************************************************
.\RESOURCES\GUIDOCUMENTCLIPBOARD.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTCLIPBOARD
#define VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTCLIPBOARD


namespace vl
{
	namespace presentation
	{
		extern void					ModifyDocumentForClipboard(Ptr<DocumentModel> model);
		extern Ptr<DocumentModel>	LoadDocumentFromClipboardStream(stream::IStream& clipboardStream);
		extern void					SaveDocumentToClipboardStream(Ptr<DocumentModel> model, stream::IStream& clipboardStream);

		extern void					SaveDocumentToRtf(Ptr<DocumentModel> model, AString& rtf);
		extern void					SaveDocumentToRtfStream(Ptr<DocumentModel> model, stream::IStream& rtfStream);

		extern void					SaveDocumentToHtmlUtf8(Ptr<DocumentModel> model, AString& header, AString& content, AString& footer);
		extern void					SaveDocumentToHtmlClipboardStream(Ptr<DocumentModel> model, stream::IStream& clipboardStream);
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIDOCUMENTEDITOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTEDITOR
#define VCZH_PRESENTATION_RESOURCES_GUIDOCUMENTEDITOR


namespace vl
{
	namespace presentation
	{
		typedef DocumentModel::RunRange			RunRange;
		typedef DocumentModel::RunRangeMap		RunRangeMap;

		namespace document_editor
		{
			extern void									GetRunRange(DocumentParagraphRun* run, RunRangeMap& runRanges);
			extern void									LocateStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, vint position, bool frontSide, collections::List<DocumentContainerRun*>& locatedRuns);
			extern Ptr<DocumentHyperlinkRun::Package>	LocateHyperlink(DocumentParagraphRun* run, RunRangeMap& runRanges, vint row, vint start, vint end);
			extern Ptr<DocumentStyleProperties>			CopyStyle(Ptr<DocumentStyleProperties> style);
			extern Ptr<DocumentRun>						CopyRun(DocumentRun* run);
			extern Ptr<DocumentRun>						CopyStyledText(collections::List<DocumentContainerRun*>& styleRuns, const WString& text);
			extern Ptr<DocumentRun>						CopyRunRecursively(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, bool deepCopy);
			extern void									CollectStyleName(DocumentParagraphRun* run, collections::List<WString>& styleNames);
			extern void									ReplaceStyleName(DocumentParagraphRun* run, const WString& oldStyleName, const WString& newStyleName);
			extern void									RemoveRun(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern void									CutRun(DocumentParagraphRun* run, RunRangeMap& runRanges, vint position, Ptr<DocumentRun>& leftRun, Ptr<DocumentRun>& rightRun);
			extern void									ClearUnnecessaryRun(DocumentParagraphRun* run, DocumentModel* model);
			extern void									AddStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, Ptr<DocumentStyleProperties> style);
			extern void									AddHyperlink(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, const WString& reference, const WString& normalStyleName, const WString& activeStyleName);
			extern void									AddStyleName(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end, const WString& styleName);
			extern void									RemoveHyperlink(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern void									RemoveStyleName(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern void									ClearStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, vint start, vint end);
			extern Ptr<DocumentStyleProperties>			SummarizeStyle(DocumentParagraphRun* run, RunRangeMap& runRanges, DocumentModel* model, vint start, vint end);
			extern Nullable<WString>					SummarizeStyleName(DocumentParagraphRun* run, RunRangeMap& runRanges, DocumentModel* model, vint start, vint end);
			extern void									AggregateStyle(Ptr<DocumentStyleProperties>& dst, Ptr<DocumentStyleProperties> src);
		}
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIPARSERMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIPARSERMANAGER
#define VCZH_PRESENTATION_RESOURCES_GUIPARSERMANAGER


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Parser
***********************************************************************/

		/// <summary>Represents a parser.</summary>
		class IGuiGeneralParser : public IDescriptable, public Description<IGuiGeneralParser>
		{
		public:
		};

		template<typename T>
		class IGuiParser : public IGuiGeneralParser
		{
			using ErrorList = collections::List<glr::ParsingError>;
		public:
			virtual Ptr<T>							ParseInternal(const WString& text, ErrorList& errors) = 0;

			Ptr<T> Parse(GuiResourceLocation location, const WString& text, collections::List<GuiResourceError>& errors)
			{
				ErrorList parsingErrors;
				auto result = ParseInternal(text, parsingErrors);
				GuiResourceError::Transform(location, errors, parsingErrors);
				return result;
			}

			Ptr<T> Parse(GuiResourceLocation location, const WString& text, glr::ParsingTextPos position, collections::List<GuiResourceError>& errors)
			{
				ErrorList parsingErrors;
				auto result = ParseInternal(text, parsingErrors);
				GuiResourceError::Transform(location, errors, parsingErrors, position);
				return result;
			}

			Ptr<T> Parse(GuiResourceLocation location, const WString& text, GuiResourceTextPos position, collections::List<GuiResourceError>& errors)
			{
				ErrorList parsingErrors;
				auto result = ParseInternal(text, parsingErrors);
				GuiResourceError::Transform(location, errors, parsingErrors, position);
				return result;
			}
		};

/***********************************************************************
Parser Manager
***********************************************************************/

		/// <summary>Parser manager for caching parsing table globally.</summary>
		class IGuiParserManager : public IDescriptable, public Description<IGuiParserManager>
		{
		public:
			/// <summary>Get a parser.</summary>
			/// <returns>The parser.</returns>
			/// <param name="name">The name.</param>
			virtual Ptr<IGuiGeneralParser>			GetParser(const WString& name)=0;
			/// <summary>Set a parser by name.</summary>
			/// <returns>Returns true if this operation succeeded.</returns>
			/// <param name="name">The name.</param>
			/// <param name="parser">The parser.</param>
			virtual bool							SetParser(const WString& name, Ptr<IGuiGeneralParser> parser)=0;

			template<typename T>
			Ptr<IGuiParser<T>>						GetParser(const WString& name);
		};

		/// <summary>Get the global <see cref="IGuiParserManager"/> object.</summary>
		/// <returns>The parser manager.</returns>
		extern IGuiParserManager*					GetParserManager();

/***********************************************************************
Parser Manager
***********************************************************************/

		template<typename T>
		Ptr<IGuiParser<T>> IGuiParserManager::GetParser(const WString& name)
		{
			return GetParser(name).Cast<IGuiParser<T>>();
		}
	}
}

#endif

/***********************************************************************
.\RESOURCES\GUIRESOURCEMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection: Instance Loader

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_REFLECTION_GUIRESOURCEMANAGER
#define VCZH_PRESENTATION_REFLECTION_GUIRESOURCEMANAGER


namespace vl
{
	namespace presentation
	{

/***********************************************************************
IGuiResourceManager
***********************************************************************/

		class GuiResourceClassNameRecord : public Object, public Description<GuiResourceClassNameRecord>
		{
		public:
			collections::List<WString>								classNames;
			collections::Dictionary<WString, Ptr<GuiResourceItem>>	classResources;
		};

		class IGuiResourceManager : public IDescriptable, public Description<IGuiResourceManager>
		{
			using ResourceLazyList = collections::LazyList<Ptr<GuiResource>>;
		public:
			virtual void								SetResource(Ptr<GuiResource> resource, GuiResourceError::List& errors, GuiResourceUsage usage = GuiResourceUsage::DataOnly) = 0;
			virtual Ptr<GuiResource>					GetResource(const WString& name) = 0;
			virtual Ptr<GuiResource>					GetResourceFromClassName(const WString& classFullName) = 0;
			virtual ResourceLazyList					GetLoadedResources() = 0;
			virtual bool								UnloadResource(const WString& name) = 0;
			virtual bool								UnloadResource(Ptr<GuiResource> resource) = 0;
			virtual void								LoadResourceOrPending(stream::IStream& resourceStream, GuiResourceError::List& errors, GuiResourceUsage usage = GuiResourceUsage::DataOnly) = 0;
			virtual void								LoadResourceOrPending(stream::IStream& resourceStream, GuiResourceUsage usage = GuiResourceUsage::DataOnly) = 0;
			virtual void								GetPendingResourceNames(collections::List<WString>& names) = 0;
		};

		extern IGuiResourceManager*						GetResourceManager();
	}
}

#endif

/***********************************************************************
.\UTILITIES\FAKESERVICES\GUIFAKECLIPBOARDSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Default Service Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_UTILITIES_FAKESERVICES_FAKECLIPBOARDSERVICE
#define VCZH_PRESENTATION_UTILITIES_FAKESERVICES_FAKECLIPBOARDSERVICE


namespace vl
{
	namespace presentation
	{
		class FakeClipboardReader;
		class FakeClipboardWriter;

		/// <summary>
		/// An <see cref="INativeClipboardService"/> implementation that interchange objects only in the current process.
		/// </summary>
		class FakeClipboardService
			: public Object
			, public INativeClipboardService
		{
			friend class FakeClipboardReader;
			friend class FakeClipboardWriter;
		protected:
			Ptr<INativeClipboardReader>		reader;

		public:
			FakeClipboardService();
			~FakeClipboardService();

			Ptr<INativeClipboardReader>		ReadClipboard() override;
			Ptr<INativeClipboardWriter>		WriteClipboard() override;
		};
	}
}

#endif

/***********************************************************************
.\UTILITIES\FAKESERVICES\GUIFAKEDIALOGSERVICEBASE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Default Service Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_UTILITIES_FAKESERVICES_FAKEDIALOGSERVICEBASE
#define VCZH_PRESENTATION_UTILITIES_FAKESERVICES_FAKEDIALOGSERVICEBASE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiWindow;
		}

/***********************************************************************
View Models (MessageBox)
***********************************************************************/

		/// <summary>
		/// The view model for message box button. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IMessageBoxDialogAction : public virtual IDescriptable
		{
		public:
			using ButtonItem = INativeDialogService::MessageBoxButtonsOutput;

			/// <summary>
			/// Get the button that it stands for.
			/// </summary>
			/// <returns>The button.</returns>
			virtual ButtonItem				GetButton() = 0;
			/// <summary>
			/// Select this button.
			/// </summary>
			virtual void					PerformAction() = 0;
		};

		/// <summary>
		/// The view model for message box. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IMessageBoxDialogViewModel : public virtual IDescriptable
		{
		public:
			using Icon = INativeDialogService::MessageBoxIcons;
			using ButtonItem = Ptr<IMessageBoxDialogAction>;
			using ButtonItemList = collections::List<ButtonItem>;

			/// <summary>
			/// Get the text to display on the message box.
			/// </summary>
			/// <returns>The text.</returns>
			virtual WString					GetText() = 0;
			/// <summary>
			/// Get the title to display on the message box.
			/// </summary>
			/// <returns>The title.</returns>
			virtual WString					GetTitle() = 0;
			/// <summary>
			/// Get the icon to display on the message box.
			/// </summary>
			/// <returns>The icon.</returns>
			virtual Icon					GetIcon() = 0;
			/// <summary>
			/// Get all buttons to display on the message box.
			/// </summary>
			/// <returns>All buttons.</returns>
			virtual const ButtonItemList&	GetButtons() = 0;
			/// <summary>
			/// Get the button that should have the focus by default.
			/// </summary>
			/// <returns>The button to be focused.</returns>
			virtual ButtonItem				GetDefaultButton() = 0;
			/// <summary>
			/// Get the selected button. It is set by <see cref="IMessageBoxDialogAction::PerformAction"/>.
			/// </summary>
			/// <returns>The selected button.</returns>
			virtual ButtonItem				GetResult() = 0;
		};

/***********************************************************************
View Models (Confirmation)
***********************************************************************/

		/// <summary>
		/// The view model for all dialogs with "OK" and "Cancel" button.  It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IDialogConfirmation : public virtual IDescriptable
		{
		public:
			/// <summary>
			/// Test is the OK button is selected.
			/// </summary>
			/// <returns>Returns true if the OK button is selected.</returns>
			virtual bool					GetConfirmed() = 0;
			/// <summary>
			/// Set the selected button.
			/// </summary>
			/// <param name="value">True for OK, false for Cancel.</param>
			virtual void					SetConfirmed(bool value) = 0;
		};

/***********************************************************************
View Models (ColorDialog)
***********************************************************************/

		/// <summary>
		/// The view model for color dialog. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IColorDialogViewModel : public virtual IDialogConfirmation
		{
		public:
			/// <summary>
			/// Get the selected color. When the dialog is opened, it returns the pre-selected color.
			/// </summary>
			/// <returns>The selected color.</returns>
			virtual Color					GetColor() = 0;
			/// <summary>
			/// Set the selected color.
			/// </summary>
			/// <param name="value">The selected color.</param>
			virtual void					SetColor(Color value) = 0;
		};

/***********************************************************************
View Models (FontDialog)
***********************************************************************/

		/// <summary>
		/// The view model for all font dialogs. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class ICommonFontDialogViewModel : public virtual IDescriptable
		{
		public:
			using FontList = collections::List<WString>;

			/// <summary>
			/// Test if the selected font should be one in <see cref="GetFontList"/>. If it is true and the selected font does not exist, the OK button should be disabled.
			/// </summary>
			/// <returns>Returns true if the selected font should be one in <see cref="GetFontList"/>.</returns>
			virtual bool					GetFontMustExist() = 0;
			/// <summary>
			/// All registered fonts in the system.
			/// </summary>
			/// <returns>All registered fonts.</returns>
			virtual const FontList&			GetFontList() = 0;
		};

		/// <summary>
		/// The view model for simple font dialog. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class ISimpleFontDialogViewModel : public virtual ICommonFontDialogViewModel, public virtual IDialogConfirmation
		{
		public:
			/// <summary>
			/// Get the selected font. When the dialog is opened, it returns the pre-selected font.
			/// </summary>
			/// <returns>The selected font.</returns>
			virtual WString					GetFontFamily() = 0;
			/// <summary>
			/// Set the selected font.
			/// </summary>
			/// <param name="fontface">The selected font.</param>
			virtual void					SetFontFamily(const WString& fontface) = 0;
			/// <summary>
			/// Get the selected size. When the dialog is opened, it returns the pre-selected size.
			/// </summary>
			/// <returns>The selected size.</returns>
			virtual vint					GetFontSize() = 0;
			/// <summary>
			/// Set the selected size.
			/// </summary>
			/// <param name="value">The selected size.</param>
			virtual void					SetFontSize(vint value) = 0;
		};

		/// <summary>
		/// The view model for full font dialog. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IFullFontDialogViewModel : public virtual ICommonFontDialogViewModel, public virtual IColorDialogViewModel
		{
		public:
			/// <summary>
			/// Get the selected font. When the dialog is opened, it returns the pre-selected font.
			/// </summary>
			/// <returns>The selected font.</returns>
			virtual FontProperties			GetFont() = 0;
			/// <summary>
			/// Set the selected font.
			/// </summary>
			/// <param name="value">The selected font.</param>
			virtual void					SetFont(const FontProperties& value) = 0;
			/// <summary>
			/// Display a color dialog and change the Color property in <see cref="IColorDialogViewModel"/>.
			/// </summary>
			/// <returns>Returns true when a color is selected.</returns>
			/// <param name="owner">A owner window for displaying color dialogs.</param>
			virtual bool					SelectColor(controls::GuiWindow* owner) = 0;
		};

/***********************************************************************
View Models (FileDialog)
***********************************************************************/

		/// <summary>
		/// Type of a folder in a file dialog.
		/// </summary>
		enum class FileDialogFolderType
		{
			/// <summary>
			/// The root folder, it does not render in the dialog.
			/// </summary>
			Root,
			/// <summary>
			/// A placeolder item, it means folders are being loaded.
			/// </summary>
			Placeholder,
			/// <summary>
			/// A folder.
			/// </summary>
			Folder,
		};

		/// <summary>
		/// The view model for a folder in a file dialog. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IFileDialogFolder : public virtual IDescriptable
		{
		public:
			using Folders = collections::ObservableList<Ptr<IFileDialogFolder>>;

			/// <summary>
			/// Get the parent folder of this folder.
			/// </summary>
			/// <returns>The parent folder. It returns null for the root folder.</returns>
			virtual Ptr<IFileDialogFolder>	GetParent() = 0;
			/// <summary>
			/// Get the type of this folder.
			/// </summary>
			/// <returns>The type.</returns>
			virtual FileDialogFolderType	GetType() = 0;
			/// <summary>
			/// Get the full path of this folder.
			/// </summary>
			/// <returns>The full path. It returns an empty string for root or placeholder.</returns>
			virtual WString					GetFullPath() = 0;
			/// <summary>
			/// Get the name of this folder.
			/// </summary>
			/// <returns>The name. It returns an empty string for root.</returns>
			virtual WString					GetName() = 0;
			/// <summary>
			/// Get the rendering position of this folder in its parent folder.
			/// </summary>
			/// <returns>The rendering position.</returns>
			virtual vint					GetIndex() = 0;
			/// <summary>
			/// Get all sub folders of this folder.
			/// </summary>
			/// <returns>All sub folders.</returns>
			virtual Folders&				GetFolders() = 0;
			/// <summary>
			/// Get a sub folder by its name.
			/// </summary>
			/// <param name="name">The name of the sub folder.</param>
			/// <returns>The sub folder. It returns null if the object has not been created yet, this doesn't mean the folder doesn't exist.</returns>
			virtual Ptr<IFileDialogFolder>	TryGetFolder(const WString& name) = 0;
		};

		/// <summary>
		/// Type of a file in a file dialog.
		/// </summary>
		enum class FileDialogFileType
		{
			/// <summary>
			/// A placeholder item, it means files and folders are being loaded.
			/// </summary>
			Placeholder,
			/// <summary>
			/// A folder.
			/// </summary>
			Folder,
			/// <summary>
			/// A file.
			/// </summary>
			File,
		};

		/// <summary>
		/// The view model for a file in a file dialog. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IFileDialogFile : public virtual IDescriptable
		{
		public:
			using Files = collections::ObservableList<Ptr<IFileDialogFile>>;

			/// <summary>
			/// Get the type of this file.
			/// </summary>
			/// <returns></returns>
			virtual FileDialogFileType		GetType() = 0;
			/// <summary>
			/// Get the associated folder of this file.
			/// </summary>
			/// <returns>The associated folder. It returns null for placeholder or file.</returns>
			virtual Ptr<IFileDialogFolder>	GetAssociatedFolder() = 0;
			/// <summary>
			/// Get the name of this file.
			/// </summary>
			/// <returns>The name.</returns>
			virtual WString					GetName() = 0;
		};

		/// <summary>
		/// The view model for a filter in a file dialog. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IFileDialogFilter : public virtual IDescriptable
		{
		public:
			using Filters = collections::List<Ptr<IFileDialogFilter>>;

			/// <summary>
			/// Get the name of this filter.
			/// </summary>
			/// <returns>The name.</returns>
			virtual WString					GetName() = 0;
			/// <summary>
			/// Get the wildcard of this filter.
			/// </summary>
			/// <returns>The wildcard.</returns>
			virtual WString					GetFilter() = 0;
			/// <summary>
			/// Get the default extension for this filter.
			/// </summary>
			/// <returns>The default extension. It returns null if it is not defined.</returns>
			virtual Nullable<WString>		GetDefaultExtension() = 0;
			/// <summary>
			/// Filter a file.
			/// </summary>
			/// <param name="file">The file to filter.</param>
			/// <returns>Returns true if the file satisfies the filter.</returns>
			virtual bool					FilterFile(Ptr<IFileDialogFile> file) = 0;
		};

		/// <summary>
		/// The view model for file dialog. It is implemented by <see cref="FakeDialogServiceBase"/>.
		/// </summary>
		class IFileDialogViewModel : public virtual IDescriptable
		{
		public:
			using Filters = IFileDialogFilter::Filters;
			using Folders = IFileDialogFolder::Folders;
			using Files = IFileDialogFile::Files;
			using Selection = collections::LazyList<WString>;

			/// <summary>
			/// Raised when the <see cref="GetSelectedFilter"/> is changed.
			/// </summary>
			Event<void()>					SelectedFilterChanged;
			/// <summary>
			/// Raised when the <see cref="GetSelectedFolder"/> is changed.
			/// </summary>
			Event<void()>					SelectedFolderChanged;
			/// <summary>
			/// Raised when the <see cref="GetIsLoadingFiles"/> property is changed.
			/// </summary>
			Event<void()>					IsLoadingFilesChanged;

			/// <summary>
			/// Get the title of this dialog.
			/// </summary>
			/// <returns></returns>
			virtual WString					GetTitle() = 0;
			/// <summary>
			/// Test if multiple selection is allowed.
			/// </summary>
			/// <returns>Returns true if multiple selection is allowed.</returns>
			virtual bool					GetEnabledMultipleSelection() = 0;

			/// <summary>
			/// Get the default extension.
			/// </summary>
			/// <returns>The default extension.</returns>
			virtual WString					GetDefaultExtension() = 0;
			/// <summary>
			/// Get all filters of this dialog.
			/// </summary>
			/// <returns>All filters.</returns>
			virtual const Filters&			GetFilters() = 0;
			/// <summary>
			/// Get the selected filter of this dialog.
			/// </summary>
			/// <returns>The selected filter of this dialog.</returns>
			virtual Ptr<IFileDialogFilter>	GetSelectedFilter() = 0;
			/// <summary>
			/// Set the selected filter of this dialog. It could cause folders and files to be refreshed.
			/// </summary>
			/// <param name="value">The selected filter of this dialog.</param>
			virtual void					SetSelectedFilter(Ptr<IFileDialogFilter> value) = 0;

			/// <summary>
			/// Get the root folder.
			/// </summary>
			/// <returns>The root folder.</returns>
			virtual Ptr<IFileDialogFolder>	GetRootFolder() = 0;
			/// <summary>
			/// Get the selected folder.
			/// </summary>
			/// <returns>The selected folder.</returns>
			virtual Ptr<IFileDialogFolder>	GetSelectedFolder() = 0;
			/// <summary>
			/// Set the selected folder.
			/// </summary>
			/// <param name="value">The selected folder.</param>
			virtual void					SetSelectedFolder(Ptr<IFileDialogFolder> value) = 0;

			/// <summary>
			/// Test if folders and files are being loaded.
			/// </summary>
			/// <returns>Returns true if folders and files are being loaded.</returns>
			virtual bool					GetIsLoadingFiles() = 0;
			/// <summary>
			/// Get all folders and files in the selected folder.
			/// </summary>
			/// <returns>All folders and files to display.</returns>
			virtual Files&					GetFiles() = 0;
			/// <summary>
			/// Refresh the folders and files list.
			/// </summary>
			virtual void					RefreshFiles() = 0;

			/// <summary>
			/// Convert files to a display string.
			/// </summary>
			/// <param name="files">The files.</param>
			/// <returns>The display string, items are separated by ";".</returns>
			virtual WString					GetDisplayString(collections::LazyList<Ptr<IFileDialogFile>> files) = 0;

			/// <summary>
			/// Split the display string to items.
			/// </summary>
			/// <param name="displayString">The display string.</param>
			/// <returns>The items, each item is either a relative path or an absolute path.</returns>
			virtual Selection				ParseDisplayString(const WString& displayString) = 0;
			/// <summary>
			/// Test if the selection is valid. Dialogs could be displayed and ask for input accordingly.
			/// </summary>
			/// <param name="owner">A owner window for displaying message boxes.</param>
			/// <param name="selectedPaths">All selected items in string format. Each of them could be either full path, relative path or file name.</param>
			/// <returns>Returns true if the selection is valid.</returns>
			virtual bool					TryConfirm(controls::GuiWindow* owner, Selection selection) = 0;

			/// <summary>
			/// Initialize the view model with localized texts.
			/// </summary>
			/// <param name="textLoadingFolders">The name for placeholder folder.</param>
			/// <param name="textLoadingFiles">The name for placeholder file.</param>
			/// <param name="dialogErrorEmptySelection">The message saying selection is empty.</param>
			/// <param name="dialogErrorFileNotExist">The message saying selected files do not exist.</param>
			/// <param name="dialogErrorFileExpected">The message saying selected files are expected but they are folders.</param>
			/// <param name="dialogErrorFolderNotExist">The message saying the selected folder do not exist.</param>
			/// <param name="dialogErrorMultipleSelectionNotEnabled">The message saying multiple selection is not allowed.</param>
			/// <param name="dialogAskCreateFile">The message asking if user wants to create a file.</param>
			/// <param name="dialogAskOverrideFile">The message asking if user wants to override a file.</param>
			virtual void					InitLocalizedText(
												const WString& textLoadingFolders,
												const WString& textLoadingFiles,
												const WString& dialogErrorEmptySelection,
												const WString& dialogErrorFileNotExist,
												const WString& dialogErrorFileExpected,
												const WString& dialogErrorFolderNotExist,
												const WString& dialogErrorMultipleSelectionNotEnabled,
												const WString& dialogAskCreateFile,
												const WString& dialogAskOverrideFile
											) = 0;
		};

/***********************************************************************
FakeDialogServiceBase
***********************************************************************/

		/// <summary>
		/// View model implementations for <see cref="INativeDialogService"/>.
		/// </summary>
		class FakeDialogServiceBase
			: public Object
			, public INativeDialogService
		{
		protected:

			/// <summary>
			/// A callback to create a message box from the given view model.
			/// </summary>
			/// <param name="viewModel">The given view model.</param>
			/// <returns>The created window to be displayed.</returns>
			virtual controls::GuiWindow*	CreateMessageBoxDialog(Ptr<IMessageBoxDialogViewModel> viewModel) = 0;

			/// <summary>
			/// A callback to create a color dialog from the given view model.
			/// </summary>
			/// <param name="viewModel">The given view model.</param>
			/// <returns>The created window to be displayed.</returns>
			virtual controls::GuiWindow*	CreateColorDialog(Ptr<IColorDialogViewModel> viewModel) = 0;

			/// <summary>
			/// A callback to create a simple font dialog from the given view model.
			/// </summary>
			/// <param name="viewModel">The given view model.</param>
			/// <returns>The created window to be displayed.</returns>
			virtual controls::GuiWindow*	CreateSimpleFontDialog(Ptr<ISimpleFontDialogViewModel> viewModel) = 0;

			/// <summary>
			/// A callback to create a full font dialog from the given view model.
			/// </summary>
			/// <param name="viewModel">The given view model.</param>
			/// <returns>The created window to be displayed.</returns>
			virtual controls::GuiWindow*	CreateFullFontDialog(Ptr<IFullFontDialogViewModel> viewModel) = 0;

			/// <summary>
			/// A callback to create a open file dialog from the given view model.
			/// </summary>
			/// <param name="viewModel">The given view model.</param>
			/// <returns>The created window to be displayed.</returns>
			virtual controls::GuiWindow*	CreateOpenFileDialog(Ptr<IFileDialogViewModel> viewModel) = 0;

			/// <summary>
			/// A callback to create a save file dialog from the given view model.
			/// </summary>
			/// <param name="viewModel">The given view model.</param>
			/// <returns>The created window to be displayed.</returns>
			virtual controls::GuiWindow*	CreateSaveFileDialog(Ptr<IFileDialogViewModel> viewModel) = 0;

			void							ShowModalDialogAndDelete(Ptr<IDescriptable> viewModel, controls::GuiWindow* owner, controls::GuiWindow* dialog);

		public:
			FakeDialogServiceBase();
			~FakeDialogServiceBase();

			MessageBoxButtonsOutput	ShowMessageBox(
										INativeWindow* window,
										const WString& text,
										const WString& title,
										MessageBoxButtonsInput buttons,
										MessageBoxDefaultButton defaultButton,
										MessageBoxIcons icon,
										MessageBoxModalOptions modal
										) override;

			bool					ShowColorDialog(
										INativeWindow* window,
										Color& selection,
										bool selected,
										ColorDialogCustomColorOptions customColorOptions,
										Color* customColors
										) override;

			bool					ShowFontDialog(
										INativeWindow* window,
										FontProperties& selectionFont,
										Color& selectionColor,
										bool selected,
										bool showEffect,
										bool forceFontExist
										) override;

			bool					ShowFileDialog(
										INativeWindow* window,
										collections::List<WString>& selectionFileNames,
										vint& selectionFilterIndex,
										FileDialogTypes dialogType,
										const WString& title,
										const WString& initialFileName,
										const WString& initialDirectory,
										const WString& defaultExtension,
										const WString& filter,
										FileDialogOptions options
										) override;
		};
	}
}

#endif

/***********************************************************************
.\GACUIREFLECTIONHELPER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Reflection Helper

***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUIREFLECTIONHELPER
#define VCZH_PRESENTATION_GACUIREFLECTIONHELPER


namespace vl
{
	namespace presentation
	{
		namespace helper_types
		{
			struct SiteValue
			{
				vint					row = 0;
				vint					column = 0;
				vint					rowSpan = 1;
				vint					columnSpan = 1;

				auto operator<=>(const SiteValue&) const = default;
			};

			class LocalizedStrings
			{
			public:
				static WString			FirstOrEmpty(const collections::LazyList<WString>& formats);
			};
		}
	}

	namespace reflection
	{
		namespace description
		{

/***********************************************************************
Serialization
***********************************************************************/

			template<>
			struct TypedValueSerializerProvider<presentation::Color>
			{
				static presentation::Color GetDefaultValue();
				static bool Serialize(const presentation::Color& input, WString& output);
				static bool Deserialize(const WString& input, presentation::Color& output);
			};

			template<>
			struct TypedValueSerializerProvider<presentation::DocumentFontSize>
			{
				static presentation::DocumentFontSize GetDefaultValue();
				static bool Serialize(const presentation::DocumentFontSize& input, WString& output);
				static bool Deserialize(const WString& input, presentation::DocumentFontSize& output);
			};

			template<>
			struct TypedValueSerializerProvider<presentation::GlobalStringKey>
			{
				static presentation::GlobalStringKey GetDefaultValue();
				static bool Serialize(const presentation::GlobalStringKey& input, WString& output);
				static bool Deserialize(const WString& input, presentation::GlobalStringKey& output);
			};

/***********************************************************************
External Functions
***********************************************************************/

			extern Ptr<presentation::INativeImage>							INativeImage_Constructor(const WString& path);
			extern presentation::INativeCursor*								INativeCursor_Constructor1();
			extern presentation::INativeCursor*								INativeCursor_Constructor2(presentation::INativeCursor::SystemCursorType type);

			template<typename T>
			Ptr<T> Element_Constructor()
			{
				return Ptr(T::Create());
			}
			extern presentation::elements::text::TextLines*					GuiColorizedTextElement_GetLines(presentation::elements::GuiColorizedTextElement* thisObject);

			extern void														GuiTableComposition_SetRows(presentation::compositions::GuiTableComposition* thisObject, vint value);
			extern void														GuiTableComposition_SetColumns(presentation::compositions::GuiTableComposition* thisObject, vint value);
			extern void														IGuiAltActionHost_CollectAltActions(presentation::compositions::IGuiAltActionHost* host, collections::List<presentation::compositions::IGuiAltAction*>& actions);
		}
	}
}

#endif

/***********************************************************************
.\GACUI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Header Files and Common Namespaces

Global Objects:
	vl::reflection::description::					GetGlobalTypeManager
	vl::presentation::								GetParserManager
	vl::presentation::								GetResourceResolverManager
	vl::presentation::								GetCurrentController
	vl::presentation::								GetInstanceLoaderManager
	vl::presentation::elements::					GetGuiGraphicsResourceManager
	vl::presentation::controls::					GetApplication
	vl::presentation::controls::					GetPluginManager
	vl::presentation::theme::						GetCurrentTheme

	vl::presentation::windows::						GetDirect2DFactory
	vl::presentation::windows::						GetDirectWriteFactory
	vl::presentation::elements_windows_gdi::		GetWindowsGDIResourceManager
	vl::presentation::elements_windows_gdi::		GetWindowsGDIObjectProvider
	vl::presentation::elements_windows_d2d::		GetWindowsDirect2DResourceManager
	vl::presentation::elements_windows_d2d::		GetWindowsDirect2DObjectProvider
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUI
#define VCZH_PRESENTATION_GACUI


#ifdef GAC_HEADER_USE_NAMESPACE

using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::theme;
using namespace vl::presentation::templates;

#endif

// GacUI Compiler
extern int SetupGacGenNativeController();

// Remote
namespace vl::presentation
{
	class IGuiRemoteProtocol;
}
extern int SetupRemoteNativeController(vl::presentation::IGuiRemoteProtocol* protocol);

// Windows
extern int SetupWindowsGDIRenderer();
extern int SetupWindowsDirect2DRenderer();
extern int SetupHostedWindowsGDIRenderer();
extern int SetupHostedWindowsDirect2DRenderer();

// Gtk
extern int SetupGtkRenderer();

// macOS
extern int SetupOSXCoreGraphicsRenderer();

#endif

/***********************************************************************
.\UTILITIES\FAKESERVICES\DIALOGS\GUIFAKEDIALOGSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Default Service Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_UTILITIES_FAKESERVICES_FAKEDIALOGSERVICE
#define VCZH_PRESENTATION_UTILITIES_FAKESERVICES_FAKEDIALOGSERVICE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiWindow;
		}

		/// <summary>
		/// UI implementations for <see cref="INativeDialogService"/>.
		/// </summary>
		class FakeDialogService : public FakeDialogServiceBase
		{
		protected:

			controls::GuiWindow*	CreateMessageBoxDialog(Ptr< IMessageBoxDialogViewModel> viewModel) override;
			controls::GuiWindow*	CreateColorDialog(Ptr<IColorDialogViewModel> viewModel) override;
			controls::GuiWindow*	CreateSimpleFontDialog(Ptr<ISimpleFontDialogViewModel> viewModel) override;
			controls::GuiWindow*	CreateFullFontDialog(Ptr<IFullFontDialogViewModel> viewModel) override;
			controls::GuiWindow*	CreateOpenFileDialog(Ptr<IFileDialogViewModel> viewModel) override;
			controls::GuiWindow*	CreateSaveFileDialog(Ptr<IFileDialogViewModel> viewModel) override;

		public:
			FakeDialogService();
			~FakeDialogService();
		};
	}
}

#endif

/***********************************************************************
.\UTILITIES\FAKESERVICES\DIALOGS\SOURCE\GUIFAKEDIALOGSERVICEUI.H
***********************************************************************/
/***********************************************************************
!!!!!! DO NOT MODIFY !!!!!!

Source: GacUI FakeDialogServiceUI

This file is generated by Workflow compiler
https://github.com/vczh-libraries
***********************************************************************/

#ifndef VCZH_WORKFLOW_COMPILER_GENERATED_GUIFAKEDIALOGSERVICEUI
#define VCZH_WORKFLOW_COMPILER_GENERATED_GUIFAKEDIALOGSERVICEUI


#if defined( _MSC_VER)
#pragma warning(push)
#pragma warning(disable:4250)
#elif defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wparentheses-equality"
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#endif

namespace vl_workflow_global
{
	struct __vwsnf10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
	struct __vwsnf11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
	struct __vwsnf12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
	struct __vwsnf13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
	struct __vwsnf14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
	struct __vwsnf15_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
	struct __vwsnf16_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
	struct __vwsnf17_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
	struct __vwsnf18_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
	struct __vwsnf19_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__;
	struct __vwsnf1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
	struct __vwsnf20_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
	struct __vwsnf21_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
	struct __vwsnf22_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
	struct __vwsnf23_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
	struct __vwsnf24_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
	struct __vwsnf25_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindow___vwsn_instance_ctor__;
	struct __vwsnf26_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf27_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf28_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf29_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
	struct __vwsnf30_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf32_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf33_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf35_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf36_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf37_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__;
	struct __vwsnf38_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf39_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
	struct __vwsnf40_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf41_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf42_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf43_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsnf44_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles_;
	struct __vwsnf46_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
	struct __vwsnf47_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
	struct __vwsnf48_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
	struct __vwsnf49_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
	struct __vwsnf4_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
	struct __vwsnf50_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
	struct __vwsnf51_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
	struct __vwsnf53_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
	struct __vwsnf54_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
	struct __vwsnf55_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
	struct __vwsnf56_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
	struct __vwsnf57_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
	struct __vwsnf58_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
	struct __vwsnf59_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
	struct __vwsnf60_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf61_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf62_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf63_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf64_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf65_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf66_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf67_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf68_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf69_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
	struct __vwsnf70_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf71_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf72_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf73_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf74_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf75_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf76_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
	struct __vwsnf77_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf78_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf79_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
	struct __vwsnf80_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf81_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf82_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf83_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf84_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf85_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
	struct __vwsnf86_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
	struct __vwsnf87_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
	struct __vwsnf88_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
	struct __vwsnf89_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxWindowConstructor___vwsn_gaclib_controls_MessageBoxWindow_Initialize_;
	struct __vwsnf8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
	struct __vwsnf9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
	struct __vwsno31_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsno34_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
	struct __vwsno45_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
	struct __vwsno52_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
	class __vwsnc10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc15_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc16_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc17_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc18_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc19_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc20_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc21_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc22_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc23_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc24_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles___vl_reflection_description_ICoroutine;
	class __vwsnc25_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_CreateFileFilter__vl_presentation_controls_list_IDataFilter;
	class __vwsnc26_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc27_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc28_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc29_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc30_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc31_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc32_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc33_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc34_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc35_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc36_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc37_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc38_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc39_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc40_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc41_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc42_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc43_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc44_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc45_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc46_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc47_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc48_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc49_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc4_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc50_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc51_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc52_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc53_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc54_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc55_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc56_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc57_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc58_GuiFakeDialogServiceUI_gaclib_controls_DialogStrings___vwsn_ls_en_US_BuildStrings__gaclib_controls_IDialogStringsStrings;
	class __vwsnc5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
	class __vwsnc9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
}

namespace gaclib_controls
{
	class ColorComponentControlConstructor;
	class ColorComponentControl;
	class ColorDialogControlConstructor;
	class ColorDialogControl;
	class ColorDialogWindowConstructor;
	class ColorDialogWindow;
	class DialogStrings;
	class FileDialogWindowConstructor;
	class FileDialogWindow;
	class FilePickerControlConstructor;
	class FilePickerControl;
	class FontNameControlConstructor;
	class FontNameControl;
	class FontSizeControlConstructor;
	class FontSizeControl;
	class FullFontDialogWindowConstructor;
	class FullFontDialogWindow;
	class IDialogStringsStrings;
	class MessageBoxButtonTemplateConstructor;
	class MessageBoxButtonTemplate;
	class MessageBoxWindowConstructor;
	class MessageBoxWindow;
	class SimpleFontDialogWindowConstructor;
	class SimpleFontDialogWindow;

	class ColorComponentControlConstructor : public ::vl::Object, public ::vl::reflection::Description<ColorComponentControlConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf4_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<ColorComponentControlConstructor>;
#endif
	protected:
		::gaclib_controls::ColorComponentControl* self;
		::vl::presentation::controls::GuiSinglelineTextBox* textBox;
		::vl::presentation::controls::GuiScroll* tracker;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_3;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_4;
		void __vwsn_gaclib_controls_ColorComponentControl_Initialize(::gaclib_controls::ColorComponentControl* __vwsn_this_);
	public:
		ColorComponentControlConstructor();
	};

	class ColorComponentControl : public ::vl::presentation::controls::GuiCustomControl, public ::gaclib_controls::ColorComponentControlConstructor, public ::vl::reflection::Description<ColorComponentControl>
	{
		friend class ::gaclib_controls::ColorComponentControlConstructor;
		friend class ::vl_workflow_global::__vwsnc1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf4_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<ColorComponentControl>;
#endif
	public:
		::vl::vint __vwsn_prop_Value;
		::vl::vint GetValue();
		void SetValue(::vl::vint __vwsn_value_);
		::vl::Event<void()> ValueChanged;
		::vl::WString __vwsn_prop_TextBoxAlt;
		::vl::WString GetTextBoxAlt();
		void SetTextBoxAlt(const ::vl::WString& __vwsn_value_);
		::vl::Event<void()> TextBoxAltChanged;
		ColorComponentControl();
		~ColorComponentControl();
	};

	class ColorDialogControlConstructor : public ::vl::Object, public ::vl::reflection::Description<ColorDialogControlConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc4_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<ColorDialogControlConstructor>;
#endif
	protected:
		::gaclib_controls::ColorDialogControl* self;
		::vl::Ptr<::vl::presentation::IColorDialogViewModel> ViewModel;
		::gaclib_controls::ColorComponentControl* colorRed;
		::gaclib_controls::ColorComponentControl* colorGreen;
		::gaclib_controls::ColorComponentControl* colorBlue;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_3;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_5;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_6;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_7;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_8;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_9;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_10;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_11;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_12;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_13;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_14;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_15;
		::vl::Ptr<::vl::presentation::elements::GuiSolidBackgroundElement> __vwsn_precompile_16;
		void __vwsn_gaclib_controls_ColorDialogControl_Initialize(::gaclib_controls::ColorDialogControl* __vwsn_this_);
	public:
		ColorDialogControlConstructor();
	};

	class ColorDialogControl : public ::vl::presentation::controls::GuiCustomControl, public ::gaclib_controls::ColorDialogControlConstructor, public ::vl::reflection::Description<ColorDialogControl>
	{
		friend class ::gaclib_controls::ColorDialogControlConstructor;
		friend class ::vl_workflow_global::__vwsnc10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc4_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<ColorDialogControl>;
#endif
	public:
		::vl::presentation::Color __vwsn_prop_Value;
		::vl::presentation::Color GetValue();
		void SetValue(::vl::presentation::Color __vwsn_value_);
		::vl::Event<void()> ValueChanged;
		::vl::presentation::Color ReadColor();
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::IColorDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::IColorDialogViewModel> GetViewModel();
		ColorDialogControl(::vl::Ptr<::vl::presentation::IColorDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		~ColorDialogControl();
	};

	class ColorDialogWindowConstructor : public ::vl::Object, public ::vl::reflection::Description<ColorDialogWindowConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf15_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf16_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf17_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<ColorDialogWindowConstructor>;
#endif
	protected:
		::gaclib_controls::ColorDialogWindow* self;
		::vl::Ptr<::vl::presentation::IColorDialogViewModel> ViewModel;
		::gaclib_controls::ColorDialogControl* colorControl;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_3;
		::vl::presentation::controls::GuiButton* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_5;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_6;
		::vl::presentation::controls::GuiButton* __vwsn_precompile_7;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_8;
		void __vwsn_gaclib_controls_ColorDialogWindow_Initialize(::gaclib_controls::ColorDialogWindow* __vwsn_this_);
	public:
		ColorDialogWindowConstructor();
	};

	class ColorDialogWindow : public ::vl::presentation::controls::GuiWindow, public ::gaclib_controls::ColorDialogWindowConstructor, public ::vl::reflection::Description<ColorDialogWindow>
	{
		friend class ::gaclib_controls::ColorDialogWindowConstructor;
		friend class ::vl_workflow_global::__vwsnc11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf15_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf16_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf17_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<ColorDialogWindow>;
#endif
	public:
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::IColorDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::IColorDialogViewModel> GetViewModel();
		ColorDialogWindow(::vl::Ptr<::vl::presentation::IColorDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		~ColorDialogWindow();
	};

	class DialogStrings : public ::vl::Object, public ::vl::reflection::Description<DialogStrings>
	{
		friend class ::vl_workflow_global::__vwsnc58_GuiFakeDialogServiceUI_gaclib_controls_DialogStrings___vwsn_ls_en_US_BuildStrings__gaclib_controls_IDialogStringsStrings;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<DialogStrings>;
#endif
	public:
		static ::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_ls_en_US_BuildStrings(::vl::Locale __vwsn_ls_locale);
		static void Install(::vl::Locale __vwsn_ls_locale, ::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_ls_impl);
		static ::vl::Ptr<::gaclib_controls::IDialogStringsStrings> Get(::vl::Locale __vwsn_ls_locale);
		DialogStrings();
	};

	class FileDialogWindowConstructor : public ::vl::Object, public ::vl::reflection::Description<FileDialogWindowConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc15_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc16_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc17_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf18_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf19_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__;
		friend struct ::vl_workflow_global::__vwsnf20_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf21_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf22_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf23_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf24_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FileDialogWindowConstructor>;
#endif
	protected:
		::gaclib_controls::FileDialogWindow* self;
		::vl::Ptr<::vl::presentation::IFileDialogViewModel> ViewModel;
		::gaclib_controls::FilePickerControl* filePickerControl;
		::vl::presentation::controls::GuiButton* buttonOK;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_3;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_5;
		::vl::presentation::controls::GuiButton* __vwsn_precompile_6;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_7;
		void __vwsn_gaclib_controls_FileDialogWindow_Initialize(::gaclib_controls::FileDialogWindow* __vwsn_this_);
	public:
		FileDialogWindowConstructor();
	};

	class FileDialogWindow : public ::vl::presentation::controls::GuiWindow, public ::gaclib_controls::FileDialogWindowConstructor, public ::vl::reflection::Description<FileDialogWindow>
	{
		friend struct ::vl_workflow_global::__vwsnf25_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindow___vwsn_instance_ctor__;
		friend class ::gaclib_controls::FileDialogWindowConstructor;
		friend class ::vl_workflow_global::__vwsnc15_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc16_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc17_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf18_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf19_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__;
		friend struct ::vl_workflow_global::__vwsnf20_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf21_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf22_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf23_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf24_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FileDialogWindow>;
#endif
	public:
		void MakeOpenFileDialog();
		void MakeSaveFileDialog();
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::IFileDialogViewModel> GetViewModel();
		FileDialogWindow(::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		void __vwsn_instance_ctor_();
		~FileDialogWindow();
	};

	class FilePickerControlConstructor : public ::vl::Object, public ::vl::reflection::Description<FilePickerControlConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc18_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc19_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc20_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc21_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc22_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc23_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf26_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf27_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf28_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf29_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf30_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf32_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf33_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf35_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf36_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf37_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__;
		friend struct ::vl_workflow_global::__vwsnf38_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf39_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf40_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf41_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf42_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf43_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno31_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno34_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FilePickerControlConstructor>;
#endif
	protected:
		::gaclib_controls::FilePickerControl* self;
		::vl::Ptr<::vl::presentation::IFileDialogViewModel> ViewModel;
		::vl::presentation::controls::GuiSinglelineTextBox* textBox;
		::vl::presentation::controls::GuiBindableTreeView* treeView;
		::vl::presentation::controls::GuiBindableDataGrid* dataGrid;
		::vl::presentation::controls::GuiComboBoxListControl* comboBox;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_3;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_5;
		::vl::presentation::compositions::GuiColumnSplitterComposition* __vwsn_precompile_6;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_7;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_8;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_9;
		::vl::Ptr<::vl::presentation::controls::list::DataColumn> __vwsn_precompile_10;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_11;
		::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_precompile_12;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_13;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_14;
		::vl::presentation::compositions::GuiColumnSplitterComposition* __vwsn_precompile_15;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_16;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_17;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_18;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_19;
		::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_precompile_20;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_21;
		::vl::presentation::controls::GuiBindableTextList* __vwsn_precompile_22;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_23;
		::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_precompile_24;
		void __vwsn_gaclib_controls_FilePickerControl_Initialize(::gaclib_controls::FilePickerControl* __vwsn_this_);
	public:
		FilePickerControlConstructor();
	};

	class FilePickerControl : public ::vl::presentation::controls::GuiCustomControl, public ::gaclib_controls::FilePickerControlConstructor, public ::vl::reflection::Description<FilePickerControl>
	{
		friend class ::vl_workflow_global::__vwsnc24_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles___vl_reflection_description_ICoroutine;
		friend class ::vl_workflow_global::__vwsnc25_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_CreateFileFilter__vl_presentation_controls_list_IDataFilter;
		friend struct ::vl_workflow_global::__vwsnf44_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles_;
		friend class ::gaclib_controls::FilePickerControlConstructor;
		friend class ::vl_workflow_global::__vwsnc18_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc19_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc20_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc21_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc22_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc23_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf26_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf27_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf28_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf29_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf30_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf32_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf33_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf35_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf36_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf37_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__;
		friend struct ::vl_workflow_global::__vwsnf38_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf39_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf40_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf41_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf42_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf43_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno31_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno34_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FilePickerControl>;
#endif
	public:
		::vl::Ptr<::vl::presentation::GuiImageData> imageFolder;
		::vl::Ptr<::vl::presentation::GuiImageData> imageFile;
		::vl::Event<void()> RequestClose;
		::vl::collections::LazyList<::vl::Ptr<::vl::presentation::IFileDialogFile>> GetSelectedFiles();
		::vl::collections::LazyList<::vl::WString> GetSelection();
		void LocateSelectedFolderInTreeView();
		::vl::Ptr<::vl::presentation::controls::list::IDataFilter> CreateFileFilter(::vl::Ptr<::vl::presentation::IFileDialogFilter> filter);
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::IFileDialogViewModel> GetViewModel();
		FilePickerControl(::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		void __vwsn_instance_ctor_();
		~FilePickerControl();
	};

	class FontNameControlConstructor : public ::vl::Object, public ::vl::reflection::Description<FontNameControlConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc26_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc27_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc28_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc29_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf46_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf47_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf48_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf49_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf50_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf51_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno45_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FontNameControlConstructor>;
#endif
	protected:
		::gaclib_controls::FontNameControl* self;
		::vl::Ptr<::vl::presentation::ICommonFontDialogViewModel> ViewModel;
		::vl::presentation::controls::GuiSinglelineTextBox* textBox;
		::vl::presentation::controls::GuiBindableTextList* textList;
		::vl::presentation::controls::GuiControl* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_3;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_5;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_6;
		void __vwsn_gaclib_controls_FontNameControl_Initialize(::gaclib_controls::FontNameControl* __vwsn_this_);
	public:
		FontNameControlConstructor();
	};

	class FontNameControl : public ::vl::presentation::controls::GuiCustomControl, public ::gaclib_controls::FontNameControlConstructor, public ::vl::reflection::Description<FontNameControl>
	{
		friend class ::gaclib_controls::FontNameControlConstructor;
		friend class ::vl_workflow_global::__vwsnc26_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc27_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc28_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc29_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf46_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf47_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf48_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf49_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf50_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf51_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno45_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FontNameControl>;
#endif
	public:
		::vl::WString __vwsn_prop_Value;
		::vl::WString GetValue();
		void SetValue(const ::vl::WString& __vwsn_value_);
		::vl::Event<void()> ValueChanged;
		bool __vwsn_prop_Legal;
		bool GetLegal();
		void SetLegal(bool __vwsn_value_);
		::vl::Event<void()> LegalChanged;
		void UpdateSelectedIndex();
		void InitValue(const ::vl::WString& value);
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::ICommonFontDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::ICommonFontDialogViewModel> GetViewModel();
		FontNameControl(::vl::Ptr<::vl::presentation::ICommonFontDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		~FontNameControl();
	};

	class FontSizeControlConstructor : public ::vl::Object, public ::vl::reflection::Description<FontSizeControlConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc30_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc31_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc32_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc33_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf53_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf54_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf55_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf56_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf57_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf58_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno52_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FontSizeControlConstructor>;
#endif
	protected:
		::gaclib_controls::FontSizeControl* self;
		::vl::presentation::controls::GuiSinglelineTextBox* textBox;
		::vl::presentation::controls::GuiBindableTextList* textList;
		::vl::presentation::controls::GuiControl* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_3;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_5;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_6;
		void __vwsn_gaclib_controls_FontSizeControl_Initialize(::gaclib_controls::FontSizeControl* __vwsn_this_);
	public:
		FontSizeControlConstructor();
	};

	class FontSizeControl : public ::vl::presentation::controls::GuiCustomControl, public ::gaclib_controls::FontSizeControlConstructor, public ::vl::reflection::Description<FontSizeControl>
	{
		friend class ::gaclib_controls::FontSizeControlConstructor;
		friend class ::vl_workflow_global::__vwsnc30_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc31_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc32_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc33_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf53_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf54_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf55_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf56_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf57_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf58_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
		friend struct ::vl_workflow_global::__vwsno52_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FontSizeControl>;
#endif
	public:
		::vl::Ptr<::vl::reflection::description::IValueList> __vwsn_prop_SizeList;
		::vl::Ptr<::vl::reflection::description::IValueList> GetSizeList();
		void SetSizeList(::vl::Ptr<::vl::reflection::description::IValueList> __vwsn_value_);
		::vl::vint __vwsn_prop_Value;
		::vl::vint GetValue();
		void SetValue(::vl::vint __vwsn_value_);
		::vl::Event<void()> ValueChanged;
		bool __vwsn_prop_Legal;
		bool GetLegal();
		void SetLegal(bool __vwsn_value_);
		::vl::Event<void()> LegalChanged;
		void UpdateSelectedIndex();
		void InitValue(::vl::vint value);
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
		FontSizeControl();
		~FontSizeControl();
	};

	class FullFontDialogWindowConstructor : public ::vl::Object, public ::vl::reflection::Description<FullFontDialogWindowConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc34_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc35_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc36_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc37_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc38_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc39_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc40_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc41_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc42_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc43_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc44_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc45_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc46_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc47_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc48_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf59_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf60_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf61_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf62_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf63_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf64_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf65_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf66_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf67_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf68_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf69_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf70_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf71_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf72_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf73_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf74_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf75_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf76_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FullFontDialogWindowConstructor>;
#endif
	protected:
		::gaclib_controls::FullFontDialogWindow* self;
		::vl::Ptr<::vl::presentation::IFullFontDialogViewModel> ViewModel;
		::gaclib_controls::FontNameControl* nameControl;
		::gaclib_controls::FontSizeControl* sizeControl;
		::vl::presentation::controls::GuiSelectableButton* checkBold;
		::vl::presentation::controls::GuiSelectableButton* checkItalic;
		::vl::presentation::controls::GuiSelectableButton* checkUnderline;
		::vl::presentation::controls::GuiSelectableButton* checkStrikeline;
		::vl::presentation::controls::GuiSelectableButton* checkHAA;
		::vl::presentation::controls::GuiSelectableButton* checkVAA;
		::vl::presentation::compositions::GuiBoundsComposition* colorBounds;
		::vl::Ptr<::vl::presentation::elements::GuiSolidBackgroundElement> colorBackground;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_3;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_5;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_6;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_7;
		::vl::presentation::controls::GuiControl* __vwsn_precompile_8;
		::vl::presentation::compositions::GuiStackComposition* __vwsn_precompile_9;
		::vl::presentation::compositions::GuiStackItemComposition* __vwsn_precompile_10;
		::vl::presentation::compositions::GuiStackItemComposition* __vwsn_precompile_11;
		::vl::presentation::compositions::GuiStackItemComposition* __vwsn_precompile_12;
		::vl::presentation::compositions::GuiStackItemComposition* __vwsn_precompile_13;
		::vl::presentation::compositions::GuiStackItemComposition* __vwsn_precompile_14;
		::vl::presentation::compositions::GuiStackItemComposition* __vwsn_precompile_15;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_16;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_17;
		::vl::presentation::controls::GuiControl* __vwsn_precompile_18;
		::vl::Ptr<::vl::presentation::elements::Gui3DBorderElement> __vwsn_precompile_19;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_20;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_21;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_22;
		::vl::presentation::controls::GuiControl* __vwsn_precompile_23;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_24;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_25;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_26;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_27;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_28;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_29;
		::vl::presentation::controls::GuiButton* __vwsn_precompile_30;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_31;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_32;
		::vl::presentation::controls::GuiButton* __vwsn_precompile_33;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_34;
		void __vwsn_gaclib_controls_FullFontDialogWindow_Initialize(::gaclib_controls::FullFontDialogWindow* __vwsn_this_);
	public:
		FullFontDialogWindowConstructor();
	};

	class FullFontDialogWindow : public ::vl::presentation::controls::GuiWindow, public ::gaclib_controls::FullFontDialogWindowConstructor, public ::vl::reflection::Description<FullFontDialogWindow>
	{
		friend class ::gaclib_controls::FullFontDialogWindowConstructor;
		friend class ::vl_workflow_global::__vwsnc34_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc35_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc36_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc37_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc38_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc39_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc40_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc41_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc42_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc43_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc44_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc45_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc46_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc47_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc48_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf59_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf60_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf61_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf62_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf63_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf64_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf65_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf66_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf67_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf68_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf69_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf70_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf71_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf72_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf73_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf74_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf75_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf76_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<FullFontDialogWindow>;
#endif
	public:
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::IFullFontDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::IFullFontDialogViewModel> GetViewModel();
		FullFontDialogWindow(::vl::Ptr<::vl::presentation::IFullFontDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		void __vwsn_instance_ctor_();
		~FullFontDialogWindow();
	};

	class IDialogStringsStrings : public virtual ::vl::reflection::IDescriptable, public ::vl::reflection::Description<IDialogStringsStrings>
	{
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<IDialogStringsStrings>;
#endif
	public:
		virtual ::vl::WString Abort() = 0;
		virtual ::vl::WString Blue() = 0;
		virtual ::vl::WString Bold() = 0;
		virtual ::vl::WString Cancel() = 0;
		virtual ::vl::WString Color() = 0;
		virtual ::vl::WString ColorDialogTitle() = 0;
		virtual ::vl::WString Continue() = 0;
		virtual ::vl::WString FileDialogAskCreateFile() = 0;
		virtual ::vl::WString FileDialogAskOverrideFile() = 0;
		virtual ::vl::WString FileDialogErrorEmptySelection() = 0;
		virtual ::vl::WString FileDialogErrorFileExpected() = 0;
		virtual ::vl::WString FileDialogErrorFileNotExist() = 0;
		virtual ::vl::WString FileDialogErrorFolderNotExist() = 0;
		virtual ::vl::WString FileDialogErrorMultipleSelectionNotEnabled() = 0;
		virtual ::vl::WString FileDialogFileName() = 0;
		virtual ::vl::WString FileDialogOpen() = 0;
		virtual ::vl::WString FileDialogSave() = 0;
		virtual ::vl::WString FileDialogTextLoadingFiles() = 0;
		virtual ::vl::WString FileDialogTextLoadingFolders() = 0;
		virtual ::vl::WString FontColorGroup() = 0;
		virtual ::vl::WString FontColorGroup2() = 0;
		virtual ::vl::WString FontDialogTitle() = 0;
		virtual ::vl::WString FontEffectGroup() = 0;
		virtual ::vl::WString FontNameGroup() = 0;
		virtual ::vl::WString FontPreviewGroup() = 0;
		virtual ::vl::WString FontSizeGroup() = 0;
		virtual ::vl::WString Green() = 0;
		virtual ::vl::WString HAA() = 0;
		virtual ::vl::WString Ignore() = 0;
		virtual ::vl::WString Italic() = 0;
		virtual ::vl::WString No() = 0;
		virtual ::vl::WString OK() = 0;
		virtual ::vl::WString Red() = 0;
		virtual ::vl::WString Retry() = 0;
		virtual ::vl::WString Strikeline() = 0;
		virtual ::vl::WString TryAgain() = 0;
		virtual ::vl::WString Underline() = 0;
		virtual ::vl::WString VAA() = 0;
		virtual ::vl::WString Yes() = 0;
	};

	class MessageBoxButtonTemplateConstructor : public ::vl::Object, public ::vl::reflection::Description<MessageBoxButtonTemplateConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc56_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc57_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf86_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf87_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf88_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<MessageBoxButtonTemplateConstructor>;
#endif
	protected:
		::vl::Ptr<::vl::presentation::IMessageBoxDialogAction> Action;
		::gaclib_controls::MessageBoxButtonTemplate* self;
		::vl::presentation::controls::GuiButton* buttonControl;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_0;
		void __vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize(::gaclib_controls::MessageBoxButtonTemplate* __vwsn_this_);
	public:
		MessageBoxButtonTemplateConstructor();
	};

	class MessageBoxButtonTemplate : public ::vl::presentation::templates::GuiControlTemplate, public ::gaclib_controls::MessageBoxButtonTemplateConstructor, public ::vl::reflection::Description<MessageBoxButtonTemplate>
	{
		friend class ::gaclib_controls::MessageBoxButtonTemplateConstructor;
		friend class ::vl_workflow_global::__vwsnc56_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc57_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf86_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf87_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf88_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<MessageBoxButtonTemplate>;
#endif
	public:
		::vl::presentation::controls::GuiButton* __vwsn_prop_ButtonControl;
		::vl::presentation::controls::GuiButton* GetButtonControl();
		void SetButtonControl(::vl::presentation::controls::GuiButton* __vwsn_value_);
		::vl::Event<void()> ButtonControlChanged;
		::vl::WString GetButtonText(::vl::presentation::INativeDialogService::MessageBoxButtonsOutput button, ::vl::Ptr<::gaclib_controls::IDialogStringsStrings> strings);
		::vl::WString GetButtonAlt(::vl::presentation::INativeDialogService::MessageBoxButtonsOutput button);
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::IMessageBoxDialogAction> __vwsn_parameter_Action;
	public:
		::vl::Ptr<::vl::presentation::IMessageBoxDialogAction> GetAction();
		MessageBoxButtonTemplate(::vl::Ptr<::vl::presentation::IMessageBoxDialogAction> __vwsn_ctor_parameter_Action);
		void __vwsn_instance_ctor_();
		~MessageBoxButtonTemplate();
	};

	class MessageBoxWindowConstructor : public ::vl::Object, public ::vl::reflection::Description<MessageBoxWindowConstructor>
	{
		friend struct ::vl_workflow_global::__vwsnf89_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxWindowConstructor___vwsn_gaclib_controls_MessageBoxWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<MessageBoxWindowConstructor>;
#endif
	protected:
		::gaclib_controls::MessageBoxWindow* self;
		::vl::Ptr<::vl::presentation::IMessageBoxDialogViewModel> ViewModel;
		::vl::presentation::compositions::GuiRepeatStackComposition* buttonStack;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_3;
		::vl::Ptr<::vl::presentation::elements::GuiSolidBackgroundElement> __vwsn_precompile_4;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_5;
		::vl::Ptr<::vl::presentation::elements::GuiImageFrameElement> __vwsn_precompile_6;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_7;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_8;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_9;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_10;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_11;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_12;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_13;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_14;
		void __vwsn_gaclib_controls_MessageBoxWindow_Initialize(::gaclib_controls::MessageBoxWindow* __vwsn_this_);
	public:
		MessageBoxWindowConstructor();
	};

	class MessageBoxWindow : public ::vl::presentation::controls::GuiWindow, public ::gaclib_controls::MessageBoxWindowConstructor, public ::vl::reflection::Description<MessageBoxWindow>
	{
		friend class ::gaclib_controls::MessageBoxWindowConstructor;
		friend struct ::vl_workflow_global::__vwsnf89_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxWindowConstructor___vwsn_gaclib_controls_MessageBoxWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<MessageBoxWindow>;
#endif
	public:
		::vl::Ptr<::vl::presentation::INativeImage> GetIcon(::vl::presentation::INativeDialogService::MessageBoxIcons icon);
	private:
		::vl::Ptr<::vl::presentation::IMessageBoxDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::IMessageBoxDialogViewModel> GetViewModel();
		MessageBoxWindow(::vl::Ptr<::vl::presentation::IMessageBoxDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		void __vwsn_instance_ctor_();
		~MessageBoxWindow();
	};

	class SimpleFontDialogWindowConstructor : public ::vl::Object, public ::vl::reflection::Description<SimpleFontDialogWindowConstructor>
	{
		friend class ::vl_workflow_global::__vwsnc49_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc50_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc51_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc52_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc53_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc54_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc55_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf77_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf78_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf79_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf80_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf81_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf82_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf83_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf84_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf85_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<SimpleFontDialogWindowConstructor>;
#endif
	protected:
		::gaclib_controls::SimpleFontDialogWindow* self;
		::vl::Ptr<::vl::presentation::ISimpleFontDialogViewModel> ViewModel;
		::gaclib_controls::FontNameControl* nameControl;
		::gaclib_controls::FontSizeControl* sizeControl;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_0;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_1;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_2;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_3;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_4;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_5;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_6;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_7;
		::vl::presentation::controls::GuiControl* __vwsn_precompile_8;
		::vl::presentation::compositions::GuiTableComposition* __vwsn_precompile_9;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_10;
		::vl::presentation::controls::GuiLabel* __vwsn_precompile_11;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_12;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_13;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_14;
		::vl::presentation::controls::GuiButton* __vwsn_precompile_15;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_16;
		::vl::presentation::compositions::GuiCellComposition* __vwsn_precompile_17;
		::vl::presentation::controls::GuiButton* __vwsn_precompile_18;
		::vl::presentation::compositions::GuiBoundsComposition* __vwsn_precompile_19;
		void __vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize(::gaclib_controls::SimpleFontDialogWindow* __vwsn_this_);
	public:
		SimpleFontDialogWindowConstructor();
	};

	class SimpleFontDialogWindow : public ::vl::presentation::controls::GuiWindow, public ::gaclib_controls::SimpleFontDialogWindowConstructor, public ::vl::reflection::Description<SimpleFontDialogWindow>
	{
		friend class ::gaclib_controls::SimpleFontDialogWindowConstructor;
		friend class ::vl_workflow_global::__vwsnc49_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc50_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc51_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc52_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc53_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc54_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend class ::vl_workflow_global::__vwsnc55_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription;
		friend struct ::vl_workflow_global::__vwsnf77_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf78_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf79_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf80_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf81_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf82_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf83_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf84_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
		friend struct ::vl_workflow_global::__vwsnf85_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_;
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		friend struct ::vl::reflection::description::CustomTypeDescriptorSelector<SimpleFontDialogWindow>;
#endif
	public:
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_prop_Strings;
		::vl::Ptr<::gaclib_controls::IDialogStringsStrings> GetStrings();
		void SetStrings(::vl::Ptr<::gaclib_controls::IDialogStringsStrings> __vwsn_value_);
		::vl::Event<void()> StringsChanged;
	private:
		::vl::Ptr<::vl::presentation::ISimpleFontDialogViewModel> __vwsn_parameter_ViewModel;
	public:
		::vl::Ptr<::vl::presentation::ISimpleFontDialogViewModel> GetViewModel();
		SimpleFontDialogWindow(::vl::Ptr<::vl::presentation::ISimpleFontDialogViewModel> __vwsn_ctor_parameter_ViewModel);
		void __vwsn_instance_ctor_();
		~SimpleFontDialogWindow();
	};

}
/***********************************************************************
Global Variables and Functions
***********************************************************************/

namespace vl_workflow_global
{
	class GuiFakeDialogServiceUI
	{
	public:

		::vl::Ptr<::vl::reflection::description::IValueDictionary> __vwsn_ls_DialogStrings;

		static GuiFakeDialogServiceUI& Instance();
	};

/***********************************************************************
Closures
***********************************************************************/

	struct __vwsnf10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_
	{
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnf10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_
	{
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnf11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_
	{
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnf12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_(::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_
	{
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnf13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_(::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_
	{
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnf14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_(::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf15_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_
	{
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnf15_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_(::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf16_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_
	{
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnf16_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_(::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf17_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_
	{
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnf17_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize_(::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf18_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_
	{
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnf18_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		void operator()() const;
	};

	struct __vwsnf19_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__
	{
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnf19_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		void operator()() const;
	};

	struct __vwsnf1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_
	{
		::gaclib_controls::ColorComponentControlConstructor* __vwsnthis_0;

		__vwsnf1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_(::gaclib_controls::ColorComponentControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf20_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_
	{
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnf20_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf21_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_
	{
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnf21_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf22_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_
	{
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnf22_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf23_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_
	{
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnf23_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf24_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_
	{
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnf24_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize_(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf25_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindow___vwsn_instance_ctor__
	{
		::gaclib_controls::FileDialogWindow* __vwsnthis_0;

		__vwsnf25_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindow___vwsn_instance_ctor__(::gaclib_controls::FileDialogWindow* __vwsnctorthis_0);

		void operator()() const;
	};

	struct __vwsnf26_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf26_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::Ptr<::vl::reflection::description::IValueEnumerable> operator()(const ::vl::reflection::description::Value& __vwsn_item_) const;
	};

	struct __vwsnf27_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf27_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::WString operator()(const ::vl::reflection::description::Value& __vwsn_item_) const;
	};

	struct __vwsnf28_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf28_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::WString operator()(const ::vl::reflection::description::Value& __vwsn_item_) const;
	};

	struct __vwsnf29_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf29_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::WString operator()(const ::vl::reflection::description::Value& __vwsn_item_) const;
	};

	struct __vwsnf2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_
	{
		::gaclib_controls::ColorComponentControlConstructor* __vwsnthis_0;

		__vwsnf2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_(::gaclib_controls::ColorComponentControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf30_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf30_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf32_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf32_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf33_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf33_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiKeyEventArgs* arguments) const;
	};

	struct __vwsnf35_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf35_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf36_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf36_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiItemMouseEventArgs* arguments) const;
	};

	struct __vwsnf37_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__
	{
		::vl::collections::LazyList<::vl::WString> selection;
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf37_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__(::vl::collections::LazyList<::vl::WString> __vwsnctor_selection, ::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()() const;
	};

	struct __vwsnf38_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf38_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf39_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf39_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiKeyEventArgs* arguments) const;
	};

	struct __vwsnf3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_
	{
		::gaclib_controls::ColorComponentControlConstructor* __vwsnthis_0;

		__vwsnf3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_(::gaclib_controls::ColorComponentControlConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf40_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf40_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf41_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf41_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf42_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf42_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()() const;
	};

	struct __vwsnf43_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnf43_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf44_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles_
	{
		::gaclib_controls::FilePickerControl* __vwsnthis_0;

		__vwsnf44_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles_(::gaclib_controls::FilePickerControl* __vwsnctorthis_0);

		::vl::Ptr<::vl::reflection::description::ICoroutine> operator()(::vl::reflection::description::EnumerableCoroutine::IImpl* __vwsn_co_impl_) const;
	};

	struct __vwsnf46_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_
	{
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnf46_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf47_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_
	{
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnf47_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf48_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_
	{
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnf48_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf49_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_
	{
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnf49_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf4_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_
	{
		::gaclib_controls::ColorComponentControlConstructor* __vwsnthis_0;

		__vwsnf4_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize_(::gaclib_controls::ColorComponentControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf50_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_
	{
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnf50_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		void operator()() const;
	};

	struct __vwsnf51_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_
	{
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnf51_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf53_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_
	{
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnf53_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf54_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_
	{
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnf54_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf55_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_
	{
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnf55_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf56_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_
	{
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnf56_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf57_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_
	{
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnf57_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		void operator()() const;
	};

	struct __vwsnf58_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_
	{
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnf58_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf59_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf59_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_
	{
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnf5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf60_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf60_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf61_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf61_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf62_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf62_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf63_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf63_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf64_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf64_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf65_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf65_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf66_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf66_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiMouseEventArgs* arguments) const;
	};

	struct __vwsnf67_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf67_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf68_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf68_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf69_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf69_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_
	{
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnf6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf70_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf70_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf71_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf71_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf72_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf72_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf73_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf73_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf74_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf74_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf75_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf75_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf76_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_
	{
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf76_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize_(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf77_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf77_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf78_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf78_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf79_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf79_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_
	{
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnf7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf80_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf80_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf81_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf81_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf82_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf82_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf83_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf83_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf84_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf84_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf85_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_
	{
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnf85_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize_(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf86_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_
	{
		::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnthis_0;

		__vwsnf86_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_(::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf87_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_
	{
		::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnthis_0;

		__vwsnf87_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_(::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnctorthis_0);

		void operator()(::vl::presentation::compositions::GuiGraphicsComposition* sender, ::vl::presentation::compositions::GuiEventArgs* arguments) const;
	};

	struct __vwsnf88_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_
	{
		::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnthis_0;

		__vwsnf88_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize_(::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf89_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxWindowConstructor___vwsn_gaclib_controls_MessageBoxWindow_Initialize_
	{
		::gaclib_controls::MessageBoxWindowConstructor* __vwsnthis_0;

		__vwsnf89_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxWindowConstructor___vwsn_gaclib_controls_MessageBoxWindow_Initialize_(::gaclib_controls::MessageBoxWindowConstructor* __vwsnctorthis_0);

		::vl::presentation::templates::GuiTemplate* operator()(const ::vl::reflection::description::Value& __vwsn_viewModel_) const;
	};

	struct __vwsnf8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_
	{
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnf8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsnf9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_
	{
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnf9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize_(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		void operator()(const ::vl::reflection::description::Value& __vwsn_value_) const;
	};

	struct __vwsno31_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsno31_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::Ptr<::vl::presentation::GuiImageData> operator()(const ::vl::reflection::description::Value& __vwsno_1) const;
	};

	struct __vwsno34_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_
	{
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsno34_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize_(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::Ptr<::vl::presentation::GuiImageData> operator()(const ::vl::reflection::description::Value& __vwsno_1) const;
	};

	struct __vwsno45_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_
	{
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsno45_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize_(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		::vl::WString operator()(const ::vl::reflection::description::Value& __vwsno_1) const;
	};

	struct __vwsno52_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_
	{
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsno52_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize_(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		::vl::WString operator()(const ::vl::reflection::description::Value& __vwsno_1) const;
	};

	class __vwsnc10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnc10_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogWindow* __vwsn_this_;
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnc11_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogWindow* __vwsn_this_;
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnc12_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogWindow* __vwsn_this_;
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnc13_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogWindowConstructor* __vwsnthis_0;

		__vwsnc14_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogWindowConstructor___vwsn_gaclib_controls_ColorDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogWindowConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc15_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnc15_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_bind_cache_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc16_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FileDialogWindow* __vwsn_this_;
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnc16_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FileDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FileDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc17_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FileDialogWindowConstructor* __vwsnthis_0;

		__vwsnc17_GuiFakeDialogServiceUI_gaclib_controls_FileDialogWindowConstructor___vwsn_gaclib_controls_FileDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FileDialogWindowConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc18_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnc18_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_bind_cache_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc19_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnc19_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::Ptr<::vl::presentation::IFileDialogViewModel> __vwsn_bind_cache_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorComponentControlConstructor* __vwsnthis_0;

		__vwsnc1_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorComponentControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorComponentControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc20_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FilePickerControl* __vwsn_this_;
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnc20_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FilePickerControl* __vwsnctor___vwsn_this_, ::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::FilePickerControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc21_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnc21_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiComboBoxListControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc22_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnc22_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiBindableTreeView* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc23_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FilePickerControlConstructor* __vwsnthis_0;

		__vwsnc23_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControlConstructor___vwsn_gaclib_controls_FilePickerControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FilePickerControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc24_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles___vl_reflection_description_ICoroutine : public ::vl::Object, public virtual ::vl::reflection::description::ICoroutine
	{
	public:
		::vl::reflection::description::EnumerableCoroutine::IImpl* __vwsn_co_impl_;
		::gaclib_controls::FilePickerControl* __vwsnthis_0;

		__vwsnc24_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_GetSelectedFiles___vl_reflection_description_ICoroutine(::vl::reflection::description::EnumerableCoroutine::IImpl* __vwsnctor___vwsn_co_impl_, ::gaclib_controls::FilePickerControl* __vwsnctorthis_0);

		::vl::Ptr<::vl::presentation::IFileDialogFile> __vwsn_co0_file;
		::vl::vint __vwsn_co1_item = 0;
		::vl::Ptr<::vl::reflection::description::IValueEnumerable> __vwsn_co2_for_enumerable_item;
		::vl::Ptr<::vl::reflection::description::IValueEnumerator> __vwsn_co3_for_enumerator_item;
		::vl::vint __vwsn_co_state_ = 0;
		::vl::vint __vwsn_co_state_before_pause_ = 0;
		::vl::Ptr<::vl::reflection::description::IValueException> __vwsn_prop_Failure;
		::vl::Ptr<::vl::reflection::description::IValueException> GetFailure() override;
		void SetFailure(::vl::Ptr<::vl::reflection::description::IValueException> __vwsn_value_);
		::vl::reflection::description::CoroutineStatus __vwsn_prop_Status = static_cast<::vl::reflection::description::CoroutineStatus>(0);
		::vl::reflection::description::CoroutineStatus GetStatus() override;
		void SetStatus(::vl::reflection::description::CoroutineStatus __vwsn_value_);
		void Resume(bool __vwsn_raise_exception_, ::vl::Ptr<::vl::reflection::description::CoroutineResult> __vwsn_co_result_) override;
	};

	class __vwsnc25_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_CreateFileFilter__vl_presentation_controls_list_IDataFilter : public ::vl::Object, public virtual ::vl::presentation::controls::list::IDataFilter
	{
	public:
		::vl::Ptr<::vl::presentation::IFileDialogFilter> filter;
		::gaclib_controls::FilePickerControl* __vwsnthis_0;

		__vwsnc25_GuiFakeDialogServiceUI_gaclib_controls_FilePickerControl_CreateFileFilter__vl_presentation_controls_list_IDataFilter(::vl::Ptr<::vl::presentation::IFileDialogFilter> __vwsnctor_filter, ::gaclib_controls::FilePickerControl* __vwsnctorthis_0);

		void SetCallback(::vl::presentation::controls::list::IDataProcessorCallback* value) override;
		bool Filter(const ::vl::reflection::description::Value& row) override;
	};

	class __vwsnc26_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontNameControl* __vwsn_this_;
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnc26_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontNameControl* __vwsnctor___vwsn_this_, ::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::FontNameControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc27_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnc27_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiSinglelineTextBox* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc28_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnc28_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiSinglelineTextBox* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc29_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontNameControlConstructor* __vwsnthis_0;

		__vwsnc29_GuiFakeDialogServiceUI_gaclib_controls_FontNameControlConstructor___vwsn_gaclib_controls_FontNameControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontNameControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorComponentControlConstructor* __vwsnthis_0;

		__vwsnc2_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorComponentControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorComponentControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc30_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontSizeControl* __vwsn_this_;
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnc30_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontSizeControl* __vwsnctor___vwsn_this_, ::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc31_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnc31_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiSinglelineTextBox* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc32_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnc32_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc33_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FontSizeControlConstructor* __vwsnthis_0;

		__vwsnc33_GuiFakeDialogServiceUI_gaclib_controls_FontSizeControlConstructor___vwsn_gaclib_controls_FontSizeControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FontSizeControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc34_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc34_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc35_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc35_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc36_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc36_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc37_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc37_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc38_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc38_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc39_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc39_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorComponentControlConstructor* __vwsnthis_0;

		__vwsnc3_GuiFakeDialogServiceUI_gaclib_controls_ColorComponentControlConstructor___vwsn_gaclib_controls_ColorComponentControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorComponentControlConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiScroll* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc40_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc40_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc41_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc41_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc42_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc42_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FontNameControl* __vwsn_bind_cache_0 = nullptr;
		::gaclib_controls::FontNameControl* __vwsn_bind_cache_1 = nullptr;
		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_2 = nullptr;
		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_3 = nullptr;
		::vl::presentation::controls::GuiSelectableButton* __vwsn_bind_cache_4 = nullptr;
		::vl::presentation::controls::GuiSelectableButton* __vwsn_bind_cache_5 = nullptr;
		::vl::presentation::controls::GuiSelectableButton* __vwsn_bind_cache_6 = nullptr;
		::vl::presentation::controls::GuiSelectableButton* __vwsn_bind_cache_7 = nullptr;
		::vl::presentation::controls::GuiSelectableButton* __vwsn_bind_cache_8 = nullptr;
		::vl::presentation::controls::GuiSelectableButton* __vwsn_bind_cache_9 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_1_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_2_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_3_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_4_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_5_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_6_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_7_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_8_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_9_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		void __vwsn_bind_callback_1_0();
		void __vwsn_bind_callback_2_0();
		void __vwsn_bind_callback_3_0();
		void __vwsn_bind_callback_4_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		void __vwsn_bind_callback_5_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		void __vwsn_bind_callback_6_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		void __vwsn_bind_callback_7_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		void __vwsn_bind_callback_8_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		void __vwsn_bind_callback_9_0(::vl::presentation::compositions::GuiGraphicsComposition* __vwsn_bind_callback_argument_0, ::vl::presentation::compositions::GuiEventArgs* __vwsn_bind_callback_argument_1);
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc43_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc43_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc44_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc44_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc45_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc45_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FontNameControl* __vwsn_bind_cache_0 = nullptr;
		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_1 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_1_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		void __vwsn_bind_callback_1_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc46_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc46_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc47_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindow* __vwsn_this_;
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc47_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FullFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc48_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::FullFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc48_GuiFakeDialogServiceUI_gaclib_controls_FullFontDialogWindowConstructor___vwsn_gaclib_controls_FullFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::FullFontDialogWindowConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc49_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc49_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FontNameControl* __vwsn_bind_cache_0 = nullptr;
		::gaclib_controls::FontNameControl* __vwsn_bind_cache_1 = nullptr;
		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_2 = nullptr;
		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_3 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_1_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_2_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_3_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		void __vwsn_bind_callback_1_0();
		void __vwsn_bind_callback_2_0();
		void __vwsn_bind_callback_3_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc4_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogControl* __vwsn_this_;
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnc4_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogControl* __vwsnctor___vwsn_this_, ::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc50_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::SimpleFontDialogWindow* __vwsn_this_;
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc50_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::SimpleFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::SimpleFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc51_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::SimpleFontDialogWindow* __vwsn_this_;
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc51_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::SimpleFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::SimpleFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc52_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc52_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::FontNameControl* __vwsn_bind_cache_0 = nullptr;
		::gaclib_controls::FontSizeControl* __vwsn_bind_cache_1 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_1_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		void __vwsn_bind_callback_1_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc53_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::SimpleFontDialogWindow* __vwsn_this_;
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc53_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::SimpleFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::SimpleFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc54_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::SimpleFontDialogWindow* __vwsn_this_;
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc54_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::SimpleFontDialogWindow* __vwsnctor___vwsn_this_, ::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		::gaclib_controls::SimpleFontDialogWindow* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc55_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnthis_0;

		__vwsnc55_GuiFakeDialogServiceUI_gaclib_controls_SimpleFontDialogWindowConstructor___vwsn_gaclib_controls_SimpleFontDialogWindow_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::SimpleFontDialogWindowConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc56_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnthis_0;

		__vwsnc56_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnctorthis_0);

		::gaclib_controls::MessageBoxButtonTemplate* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc57_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnthis_0;

		__vwsnc57_GuiFakeDialogServiceUI_gaclib_controls_MessageBoxButtonTemplateConstructor___vwsn_gaclib_controls_MessageBoxButtonTemplate_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::MessageBoxButtonTemplateConstructor* __vwsnctorthis_0);

		::vl::presentation::controls::GuiApplication* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc58_GuiFakeDialogServiceUI_gaclib_controls_DialogStrings___vwsn_ls_en_US_BuildStrings__gaclib_controls_IDialogStringsStrings : public ::vl::Object, public virtual ::gaclib_controls::IDialogStringsStrings
	{
	public:
		__vwsnc58_GuiFakeDialogServiceUI_gaclib_controls_DialogStrings___vwsn_ls_en_US_BuildStrings__gaclib_controls_IDialogStringsStrings();

		::vl::WString Abort() override;
		::vl::WString Blue() override;
		::vl::WString Bold() override;
		::vl::WString Cancel() override;
		::vl::WString Color() override;
		::vl::WString ColorDialogTitle() override;
		::vl::WString Continue() override;
		::vl::WString FileDialogAskCreateFile() override;
		::vl::WString FileDialogAskOverrideFile() override;
		::vl::WString FileDialogErrorEmptySelection() override;
		::vl::WString FileDialogErrorFileExpected() override;
		::vl::WString FileDialogErrorFileNotExist() override;
		::vl::WString FileDialogErrorFolderNotExist() override;
		::vl::WString FileDialogErrorMultipleSelectionNotEnabled() override;
		::vl::WString FileDialogFileName() override;
		::vl::WString FileDialogOpen() override;
		::vl::WString FileDialogSave() override;
		::vl::WString FileDialogTextLoadingFiles() override;
		::vl::WString FileDialogTextLoadingFolders() override;
		::vl::WString FontColorGroup() override;
		::vl::WString FontColorGroup2() override;
		::vl::WString FontDialogTitle() override;
		::vl::WString FontEffectGroup() override;
		::vl::WString FontNameGroup() override;
		::vl::WString FontPreviewGroup() override;
		::vl::WString FontSizeGroup() override;
		::vl::WString Green() override;
		::vl::WString HAA() override;
		::vl::WString Ignore() override;
		::vl::WString Italic() override;
		::vl::WString No() override;
		::vl::WString OK() override;
		::vl::WString Red() override;
		::vl::WString Retry() override;
		::vl::WString Strikeline() override;
		::vl::WString TryAgain() override;
		::vl::WString Underline() override;
		::vl::WString VAA() override;
		::vl::WString Yes() override;
	};

	class __vwsnc5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogControl* __vwsn_this_;
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnc5_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogControl* __vwsnctor___vwsn_this_, ::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogControl* __vwsn_this_;
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnc6_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogControl* __vwsnctor___vwsn_this_, ::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogControl* __vwsn_this_;
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnc7_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogControl* __vwsnctor___vwsn_this_, ::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnc8_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};

	class __vwsnc9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription : public ::vl::Object, public virtual ::vl::reflection::description::IValueSubscription
	{
	public:
		::gaclib_controls::ColorDialogControlConstructor* __vwsnthis_0;

		__vwsnc9_GuiFakeDialogServiceUI_gaclib_controls_ColorDialogControlConstructor___vwsn_gaclib_controls_ColorDialogControl_Initialize__vl_reflection_description_IValueSubscription(::gaclib_controls::ColorDialogControlConstructor* __vwsnctorthis_0);

		::gaclib_controls::ColorDialogControl* __vwsn_bind_cache_0 = nullptr;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_0;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_1;
		::vl::Ptr<::vl::reflection::description::IEventHandler> __vwsn_bind_handler_0_2;
		bool __vwsn_bind_opened_ = false;
		bool __vwsn_bind_closed_ = false;
		void __vwsn_bind_activator_();
		void __vwsn_bind_callback_0_0();
		void __vwsn_bind_callback_0_1();
		void __vwsn_bind_callback_0_2();
		bool Open() override;
		bool Update() override;
		bool Close() override;
	};
}

#if defined( _MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#endif


/***********************************************************************
.\UTILITIES\FAKESERVICES\DIALOGS\SOURCE\GUIFAKEDIALOGSERVICEUIINCLUDES.H
***********************************************************************/
/***********************************************************************
!!!!!! DO NOT MODIFY !!!!!!

Source: GacUI FakeDialogServiceUI

This file is generated by Workflow compiler
https://github.com/vczh-libraries
***********************************************************************/

#ifndef VCZH_WORKFLOW_COMPILER_GENERATED_GUIFAKEDIALOGSERVICEUIINCLUDES
#define VCZH_WORKFLOW_COMPILER_GENERATED_GUIFAKEDIALOGSERVICEUIINCLUDES


#endif


/***********************************************************************
.\UTILITIES\SHAREDSERVICES\GUISHAREDASYNCSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Default Service Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_UTILITIES_SHAREDSERVICES_SHAREDASYNCSERVICE
#define VCZH_PRESENTATION_UTILITIES_SHAREDSERVICES_SHAREDASYNCSERVICE


namespace vl
{
	namespace presentation
	{
		/// <summary>
		/// A general <see cref="INativeAsyncService/> implementation.
		/// </summary>
		class SharedAsyncService : public INativeAsyncService
		{
		protected:
			struct TaskItem
			{
				Semaphore*							semaphore;
				Func<void()>						proc;

				TaskItem();
				TaskItem(Semaphore* _semaphore, const Func<void()>& _proc);
				~TaskItem();
			};

			class DelayItem : public Object, public INativeDelay
			{
			public:
				DelayItem(SharedAsyncService* _service, const Func<void()>& _proc, bool _executeInMainThread, vint milliseconds);
				~DelayItem();

				SharedAsyncService*					service;
				Func<void()>						proc;
				ExecuteStatus						status;
				DateTime							executeUtcTime;
				bool								executeInMainThread;

				ExecuteStatus						GetStatus()override;
				bool								Delay(vint milliseconds)override;
				bool								Cancel()override;
			};
		protected:
			vint									mainThreadId;
			SpinLock								taskListLock;
			collections::List<TaskItem>				taskItems;
			collections::List<Ptr<DelayItem>>		delayItems;
		public:
			SharedAsyncService();
			~SharedAsyncService();

			void									ExecuteAsyncTasks();
			bool									IsInMainThread(INativeWindow* window)override;
			void									InvokeAsync(const Func<void()>& proc)override;
			void									InvokeInMainThread(INativeWindow* window, const Func<void()>& proc)override;
			bool									InvokeInMainThreadAndWait(INativeWindow* window, const Func<void()>& proc, vint milliseconds)override;
			Ptr<INativeDelay>						DelayExecute(const Func<void()>& proc, vint milliseconds)override;
			Ptr<INativeDelay>						DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds)override;
		};
	}
}

#endif

/***********************************************************************
.\UTILITIES\SHAREDSERVICES\GUISHAREDCALLBACKSERVICE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window::Default Service Implementation

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_UTILITIES_SHAREDSERVICES_SHAREDCALLBACKSERVICE
#define VCZH_PRESENTATION_UTILITIES_SHAREDSERVICES_SHAREDCALLBACKSERVICE


namespace vl
{
	namespace presentation
	{
		/// <summary>
		/// A general <see cref="INativeCallbackService/> implementation.
		/// </summary>
		class SharedCallbackService
			: public Object
			, public INativeCallbackService
			, public INativeCallbackInvoker
		{
		protected:
			collections::List<INativeControllerListener*>	listeners;

		public:
			SharedCallbackService();
			~SharedCallbackService();

			bool											InstallListener(INativeControllerListener* listener) override;
			bool											UninstallListener(INativeControllerListener* listener) override;
			INativeCallbackInvoker*							Invoker() override;

			void											InvokeGlobalTimer() override;
			void											InvokeClipboardUpdated() override;
			void											InvokeGlobalShortcutKeyActivated(vint id) override;
			void											InvokeNativeWindowCreated(INativeWindow* window) override;
			void											InvokeNativeWindowDestroying(INativeWindow* window) override;
		};
	}
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\HOSTED\GUIHOSTEDCONTROLLER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Hosted Window

Interfaces:
  GuiHostedController

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIHOSTEDCONTROLLER
#define VCZH_PRESENTATION_GUIHOSTEDCONTROLLER


namespace vl
{
	namespace presentation
	{

/***********************************************************************
GuiHostedController
***********************************************************************/

		class GuiHostedController
			: public Object
			, protected hosted_window_manager::WindowManager<GuiHostedWindow*>
			, protected INativeWindowListener
			, protected INativeControllerListener
			, public INativeController
			, protected INativeAsyncService
			, protected INativeScreenService
			, protected INativeScreen
			, protected INativeWindowService
			, protected IGuiHostedApplication
		{
			friend class GuiHostedWindow;
			friend class elements::GuiHostedGraphicsResourceManager;
		protected:
			SharedCallbackService										callbackService;
			hosted_window_manager::WindowManager<GuiHostedWindow*>*		wmManager = nullptr;
			bool														windowsUpdatedInLastFrame = false;
			INativeController*											nativeController = nullptr;
			elements::GuiHostedGraphicsResourceManager*					hostedResourceManager = nullptr;
			collections::SortedList<Ptr<GuiHostedWindow>>				createdWindows;

			INativeWindow*												nativeWindow = nullptr;
			bool														nativeWindowDestroyed = false;

			GuiHostedWindow*											mainWindow = nullptr;
			GuiHostedWindow*											capturingWindow = nullptr;
			GuiHostedWindow*											enteringWindow = nullptr;

			NativePoint													hoveringLocation{ -1,-1 };
			GuiHostedWindow*											hoveringWindow = nullptr;
			GuiHostedWindow*											lastFocusedWindow = nullptr;

			enum class WindowManagerOperation
			{
				None,
				Title,
				BorderLeft,
				BorderRight,
				BorderTop,
				BorderBottom,
				BorderLeftTop,
				BorderRightTop,
				BorderLeftBottom,
				BorderRightBottom,
			};
			WindowManagerOperation										wmOperation = WindowManagerOperation::None;
			GuiHostedWindow*											wmWindow = nullptr;
			NativePoint													wmRelative;

			NativePoint						GetPointInClientSpace(NativePoint location);
			GuiHostedWindow*				HitTestInClientSpace(NativePoint location);
			void							UpdateHoveringWindow(Nullable<NativePoint> location);
			void							UpdateEnteringWindow(GuiHostedWindow* window);

			// =============================================================
			// WindowManager<GuiHostedWindow*>
			// =============================================================

			void							OnOpened(hosted_window_manager::Window<GuiHostedWindow*>* window) override;
			void							OnClosed(hosted_window_manager::Window<GuiHostedWindow*>* window) override;
			void							OnEnabled(hosted_window_manager::Window<GuiHostedWindow*>* window) override;
			void							OnDisabled(hosted_window_manager::Window<GuiHostedWindow*>* window) override;
			void							OnGotFocus(hosted_window_manager::Window<GuiHostedWindow*>* window) override;
			void							OnLostFocus(hosted_window_manager::Window<GuiHostedWindow*>* window) override;
			void							OnActivated(hosted_window_manager::Window<GuiHostedWindow*>* window) override;
			void							OnDeactivated(hosted_window_manager::Window<GuiHostedWindow*>* window) override;

			// =============================================================
			// INativeWindowListener
			// =============================================================

			HitTestResult					HitTest(NativePoint location) override;
			void							Moving(NativeRect& bounds, bool fixSizeOnly, bool draggingBorder) override;
			void							Moved() override;
			void							DpiChanged(bool preparing) override;
			void							GotFocus() override;
			void							LostFocus() override;
			void							Opened() override;
			void							BeforeClosing(bool& cancel) override;
			void							AfterClosing() override;
			void							Paint() override;
			
			GuiHostedWindow*				GetSelectedWindow_MouseDown(const NativeWindowMouseInfo& info);
			GuiHostedWindow*				GetSelectedWindow_MouseMoving(const NativeWindowMouseInfo& info);
			GuiHostedWindow*				GetSelectedWindow_Other(const NativeWindowMouseInfo& info);

			void							PreAction_LeftButtonDown(const NativeWindowMouseInfo& info);
			void							PreAction_MouseDown(const NativeWindowMouseInfo& info);
			void							PreAction_MouseMoving(const NativeWindowMouseInfo& info);
			void							PreAction_Other(const NativeWindowMouseInfo& info);

			void							PostAction_LeftButtonUp(GuiHostedWindow* selectedWindow, const NativeWindowMouseInfo& info);
			void							PostAction_Other(GuiHostedWindow* selectedWindow, const NativeWindowMouseInfo& info);

			template<
				void (GuiHostedController::* PreAction)(const NativeWindowMouseInfo&),
				GuiHostedWindow* (GuiHostedController::* GetSelectedWindow)(const NativeWindowMouseInfo&),
				void (GuiHostedController::* PostAction)(GuiHostedWindow*, const NativeWindowMouseInfo&),
				void (INativeWindowListener::* Callback)(const NativeWindowMouseInfo&)
				>
			void							HandleMouseCallback(const NativeWindowMouseInfo& info);

			template<
				typename TInfo,
				void (INativeWindowListener::* Callback)(const TInfo&)
			>
			void							HandleKeyboardCallback(const TInfo& info);

			void							LeftButtonDown(const NativeWindowMouseInfo& info) override;
			void							LeftButtonUp(const NativeWindowMouseInfo& info) override;
			void							LeftButtonDoubleClick(const NativeWindowMouseInfo& info) override;
			void							RightButtonDown(const NativeWindowMouseInfo& info) override;
			void							RightButtonUp(const NativeWindowMouseInfo& info) override;
			void							RightButtonDoubleClick(const NativeWindowMouseInfo& info) override;
			void							MiddleButtonDown(const NativeWindowMouseInfo& info) override;
			void							MiddleButtonUp(const NativeWindowMouseInfo& info) override;
			void							MiddleButtonDoubleClick(const NativeWindowMouseInfo& info) override;
			void							HorizontalWheel(const NativeWindowMouseInfo& info) override;
			void							VerticalWheel(const NativeWindowMouseInfo& info) override;
			void							MouseMoving(const NativeWindowMouseInfo& info) override;
			void							MouseEntered() override;
			void							MouseLeaved() override;

			void							KeyDown(const NativeWindowKeyInfo& info) override;
			void							KeyUp(const NativeWindowKeyInfo& info) override;
			void							Char(const NativeWindowCharInfo& info) override;

			// =============================================================
			// INativeControllerListener
			// =============================================================

			void							GlobalTimer() override;
			void							ClipboardUpdated() override;
			void							GlobalShortcutKeyActivated(vint id) override;
			void							NativeWindowDestroying(INativeWindow* window) override;

			// =============================================================
			// INativeAsyncService
			// =============================================================

			bool							IsInMainThread(INativeWindow* window) override;
			void							InvokeAsync(const Func<void()>& proc) override;
			void							InvokeInMainThread(INativeWindow* window, const Func<void()>& proc) override;
			bool							InvokeInMainThreadAndWait(INativeWindow* window, const Func<void()>& proc, vint milliseconds) override;
			Ptr<INativeDelay>				DelayExecute(const Func<void()>& proc, vint milliseconds) override;
			Ptr<INativeDelay>				DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds) override;

			// =============================================================
			// INativeScreenService
			// =============================================================

			vint							GetScreenCount() override;
			INativeScreen*					GetScreen(vint index) override;
			INativeScreen*					GetScreen(INativeWindow* window) override;

			// =============================================================
			// INativeScreen
			// =============================================================

			NativeRect						GetBounds() override;
			NativeRect						GetClientBounds() override;
			WString							GetName() override;
			bool							IsPrimary() override;
			double							GetScalingX() override;
			double							GetScalingY() override;

			// =============================================================
			// INativeWindowService
			// =============================================================
			
			const NativeWindowFrameConfig&	GetMainWindowFrameConfig() override;
			const NativeWindowFrameConfig&	GetNonMainWindowFrameConfig() override;
			INativeWindow*					CreateNativeWindow(INativeWindow::WindowMode windowMode) override;
			void							DestroyNativeWindow(INativeWindow* window) override;
			INativeWindow*					GetMainWindow() override;
			INativeWindow*					GetWindow(NativePoint location) override;

			void							SettingHostedWindowsBeforeRunning();
			void							DestroyHostedWindowsAfterRunning();
			void							Run(INativeWindow* window) override;
			bool							RunOneCycle() override;

			// =============================================================
			// IGuiHostedApplication
			// =============================================================

			INativeWindow*					GetNativeWindowHost() override;
		public:
			GuiHostedController(INativeController* _nativeController);
			~GuiHostedController();

			IGuiHostedApplication*			GetHostedApplication();
			void							Initialize();
			void							Finalize();
			void							RequestRefresh();

			// =============================================================
			// INativeController
			// =============================================================

			INativeCallbackService*			CallbackService() override;
			INativeResourceService*			ResourceService() override;
			INativeAsyncService*			AsyncService() override;
			INativeClipboardService*		ClipboardService() override;
			INativeImageService*			ImageService() override;
			INativeInputService*			InputService() override;
			INativeDialogService*			DialogService() override;
			WString							GetExecutablePath() override;
			
			INativeScreenService*			ScreenService() override;
			INativeWindowService*			WindowService() override;
		};
	}
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEEVENTS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  GuiRemoteEvent

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEEVENT
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEEVENT


namespace vl::presentation
{
	class GuiRemoteController;

/***********************************************************************
GuiRemoteMessages
***********************************************************************/

	class GuiRemoteMessages : public Object
	{
	protected:
		GuiRemoteController*						remote;
		vint										id = 0;

#define MESSAGE_NORES(NAME, RESPONSE)
#define MESSAGE_RES(NAME, RESPONSE)										collections::Dictionary<vint, RESPONSE> response ## NAME;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## RESTAG(NAME, RESPONSE)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_RES
#undef MESSAGE_NORES

	public:
		GuiRemoteMessages(GuiRemoteController* _remote);
		~GuiRemoteMessages();

		void	Submit();

		// messages

#define MESSAGE_NOREQ_NORES(NAME, REQUEST, RESPONSE)					void Request ## NAME();
#define MESSAGE_NOREQ_RES(NAME, REQUEST, RESPONSE)						vint Request ## NAME();
#define MESSAGE_REQ_NORES(NAME, REQUEST, RESPONSE)						void Request ## NAME(const REQUEST& arguments);
#define MESSAGE_REQ_RES(NAME, REQUEST, RESPONSE)						vint Request ## NAME(const REQUEST& arguments);
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## REQTAG ## _ ## RESTAG(NAME, REQUEST, RESPONSE)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_REQ_RES
#undef MESSAGE_REQ_NORES
#undef MESSAGE_NOREQ_RES
#undef MESSAGE_NOREQ_NORES

#define MESSAGE_NORES(NAME, RESPONSE)
#define MESSAGE_RES(NAME, RESPONSE)\
		void Respond ## NAME(vint id, const RESPONSE& arguments);\
		RESPONSE Retrieve ## NAME(vint id);\

#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## RESTAG(NAME, RESPONSE)
			GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_RES
#undef MESSAGE_NORES
	};

/***********************************************************************
GuiRemoteEvents
***********************************************************************/

	class GuiRemoteEvents : public Object, public virtual IGuiRemoteProtocolEvents
	{
	protected:
		GuiRemoteController*						remote;

	public:
		GuiRemoteEvents(GuiRemoteController* _remote);
		~GuiRemoteEvents();

		// =============================================================
		// IGuiRemoteProtocolEvents
		// =============================================================

		// messages

#define MESSAGE_NORES(NAME, RESPONSE)
#define MESSAGE_RES(NAME, RESPONSE)										void Respond ## NAME(vint id, const RESPONSE& arguments) override;
#define MESSAGE_HANDLER(NAME, REQUEST, RESPONSE, REQTAG, RESTAG, ...)	MESSAGE_ ## RESTAG(NAME, RESPONSE)
		GACUI_REMOTEPROTOCOL_MESSAGES(MESSAGE_HANDLER)
#undef MESSAGE_HANDLER
#undef MESSAGE_RES
#undef MESSAGE_NORES

		void	ClearResponses();

		// events

#define EVENT_NOREQ(NAME, REQUEST)					void On ## NAME() override;
#define EVENT_REQ(NAME, REQUEST)					void On ## NAME(const REQUEST& arguments) override;
#define EVENT_HANDLER(NAME, REQUEST, REQTAG, ...)	EVENT_ ## REQTAG(NAME, REQUEST)
		GACUI_REMOTEPROTOCOL_EVENTS(EVENT_HANDLER)
#undef EVENT_HANDLER
#undef EVENT_REQ
#undef EVENT_NOREQ
	};
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  GuiRemoteController

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEWINDOW
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER_GUIREMOTEWINDOW


namespace vl::presentation
{
	class GuiRemoteController;

/***********************************************************************
GuiRemoteWindow
***********************************************************************/

	class GuiRemoteWindow : public Object, public virtual INativeWindow
	{
		friend class GuiRemoteEvents;
		friend class GuiRemoteController;
	protected:
		GuiRemoteController*								remote;
		GuiRemoteMessages&									remoteMessages;
		GuiRemoteEvents&									remoteEvents;
		collections::List<INativeWindowListener*>			listeners;
		INativeWindow::WindowMode							windowMode = INativeWindow::Normal;

		bool												disconnected = false;
		remoteprotocol::WindowSizingConfig					remoteWindowSizingConfig;
		bool												sizingConfigInvalidated = false;
		double												scalingX = 1;
		double												scalingY = 1;

		WString							styleTitle;
		INativeCursor*					styleCursor = nullptr;
		NativePoint						styleCaret;
		Ptr<GuiImageData>				styleIcon;
		bool							styleEnabled = true;
		bool							styleTopMost = false;

		bool							styleMaximizedBox = true;
		bool							styleMinimizedBox = true;
		bool							styleBorder = true;
		bool							styleSizeBox = true;
		bool							styleIconVisible = true;
		bool							styleTitleBar = true;
		bool							styleShowInTaskBar = true;
		bool							styleCustomFrameMode = false;
		
		bool							statusVisible = false;
		bool							statusActivated = false;
		bool							statusCapturing = false;

		void							RequestGetBounds();
		void							Opened();
		void							SetActivated(bool activated);
		void							ShowWithSizeState(bool activate, INativeWindow::WindowSizeState sizeState);

		// =============================================================
		// Events
		// =============================================================

		void							OnControllerConnect();
		void							OnControllerDisconnect();
		void							OnControllerScreenUpdated(const remoteprotocol::ScreenConfig& arguments);
		void							OnWindowBoundsUpdated(const remoteprotocol::WindowSizingConfig& arguments);
		void							OnWindowActivatedUpdated(bool activated);

	public:
		GuiRemoteWindow(GuiRemoteController* _remote);
		~GuiRemoteWindow();

		// =============================================================
		// INativeWindow
		// =============================================================

		bool							IsActivelyRefreshing() override;
		NativeSize						GetRenderingOffset() override;
		Point							Convert(NativePoint value) override;
		NativePoint						Convert(Point value) override;
		Size							Convert(NativeSize value) override;
		NativeSize						Convert(Size value) override;
		Margin							Convert(NativeMargin value) override;
		NativeMargin					Convert(Margin value) override;
		NativeRect						GetBounds() override;
		void							SetBounds(const NativeRect& bounds) override;
		NativeSize						GetClientSize() override;
		void							SetClientSize(NativeSize size) override;
		NativeRect						GetClientBoundsInScreen() override;
		WString							GetTitle() override;
		void							SetTitle(const WString& title) override;
		INativeCursor*					GetWindowCursor() override;
		void							SetWindowCursor(INativeCursor* cursor) override;
		NativePoint						GetCaretPoint() override;
		void							SetCaretPoint(NativePoint point) override;
		INativeWindow*					GetParent() override;
		void							SetParent(INativeWindow* parent) override;
		WindowMode						GetWindowMode() override;
		void							EnableCustomFrameMode() override;
		void							DisableCustomFrameMode() override;
		bool							IsCustomFrameModeEnabled() override;
		NativeMargin					GetCustomFramePadding() override;
		Ptr<GuiImageData>				GetIcon() override;
		void							SetIcon(Ptr<GuiImageData> icon) override;
		WindowSizeState					GetSizeState() override;
		void							Show() override;
		void							ShowDeactivated() override;
		void							ShowRestored() override;
		void							ShowMaximized() override;
		void							ShowMinimized() override;
		void							Hide(bool closeWindow) override;
		bool							IsVisible() override;
		void							Enable() override;
		void							Disable() override;
		bool							IsEnabled() override;
		void							SetActivate() override;
		bool							IsActivated() override;
		bool							IsRenderingAsActivated() override;
		void							ShowInTaskBar() override;
		void							HideInTaskBar() override;
		bool							IsAppearedInTaskBar() override;
		void							EnableActivate() override;
		void							DisableActivate() override;
		bool							IsEnabledActivate() override;
		bool							RequireCapture() override;
		bool							ReleaseCapture() override;
		bool							IsCapturing() override;
		bool							GetMaximizedBox() override;
		void							SetMaximizedBox(bool visible) override;
		bool							GetMinimizedBox() override;
		void							SetMinimizedBox(bool visible) override;
		bool							GetBorder() override;
		void							SetBorder(bool visible) override;
		bool							GetSizeBox() override;
		void							SetSizeBox(bool visible) override;
		bool							GetIconVisible() override;
		void							SetIconVisible(bool visible) override;
		bool							GetTitleBar() override;
		void							SetTitleBar(bool visible) override;
		bool							GetTopMost() override;
		void							SetTopMost(bool topmost) override;
		void							SupressAlt() override;
		bool							InstallListener(INativeWindowListener* listener) override;
		bool							UninstallListener(INativeWindowListener* listener) override;
		void							RedrawContent() override;
	};
}

#endif

/***********************************************************************
.\PLATFORMPROVIDERS\REMOTE\GUIREMOTECONTROLLER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Remote Window

Interfaces:
  GuiRemoteController

***********************************************************************/

#ifndef VCZH_PRESENTATION_GUIREMOTECONTROLLER
#define VCZH_PRESENTATION_GUIREMOTECONTROLLER


namespace vl::presentation
{
/***********************************************************************
GuiRemoteController
***********************************************************************/

	class GuiRemoteController
		: public Object
		, public INativeController
		, protected INativeResourceService
		, protected INativeInputService
		, protected INativeScreenService
		, protected INativeScreen
		, protected INativeWindowService
	{
		friend class GuiRemoteMessages;
		friend class GuiRemoteEvents;
		friend class GuiRemoteWindow;
		friend class GuiRemoteGraphicsImage;
		friend class elements::GuiRemoteGraphicsRenderTarget;
		friend class elements::GuiRemoteGraphicsResourceManager;
		using CursorMap = collections::Dictionary<INativeCursor::SystemCursorType, Ptr<INativeCursor>>;
		using HotKeyEntry = Tuple<bool, bool, bool, VKEY>;
		using HotKeySet = collections::SortedList<HotKeyEntry>;
		using HotKeyIds = collections::Dictionary<vint, HotKeyEntry>;
	protected:
		IGuiRemoteProtocol*								remoteProtocol = nullptr;
		GuiRemoteMessages								remoteMessages;
		GuiRemoteEvents									remoteEvents;
		GuiRemoteWindow									remoteWindow;
		elements::GuiRemoteGraphicsResourceManager*		resourceManager = nullptr;
		SharedCallbackService							callbackService;
		SharedAsyncService								asyncService;
		GuiRemoteGraphicsImageService					imageService;
		bool											applicationRunning = false;
		bool											connectionForcedToStop = false;
		bool											connectionStopped = false;

		remoteprotocol::FontConfig						remoteFontConfig;
		remoteprotocol::ScreenConfig					remoteScreenConfig;

		vint											usedHotKeys = (vint)NativeGlobalShortcutKeyResult::ValidIdBegins;
		HotKeySet										hotKeySet;
		HotKeyIds										hotKeyIds;

		CursorMap										cursors;
		bool											timerEnabled = false;
		bool											windowCreated = false;
		bool											windowDestroyed = false;

		collections::Dictionary<VKEY, WString>			keyNames;
		collections::Dictionary<WString, VKEY>			keyCodes;
		bool											keyInitialized = false;

		// =============================================================
		// INativeResourceService
		// =============================================================

		INativeCursor*					GetSystemCursor(INativeCursor::SystemCursorType type) override;
		INativeCursor*					GetDefaultSystemCursor() override;
		FontProperties					GetDefaultFont() override;
		void							SetDefaultFont(const FontProperties& value) override;
		void							EnumerateFonts(collections::List<WString>& fonts) override;

		// =============================================================
		// INativeInputService
		// =============================================================

		void							StartTimer() override;
		void							StopTimer() override;
		bool							IsTimerEnabled() override;
		bool							IsKeyPressing(VKEY code) override;
		bool							IsKeyToggled(VKEY code) override;
		void							EnsureKeyInitialized();
		WString							GetKeyName(VKEY code) override;
		VKEY							GetKey(const WString& name) override;
		void							UpdateGlobalShortcutKey();
		vint							RegisterGlobalShortcutKey(bool ctrl, bool shift, bool alt, VKEY key) override;
		bool							UnregisterGlobalShortcutKey(vint id) override;

		// =============================================================
		// INativeScreenService
		// =============================================================

		vint							GetScreenCount() override;
		INativeScreen*					GetScreen(vint index) override;
		INativeScreen*					GetScreen(INativeWindow* window) override;

		// =============================================================
		// INativeScreen
		// =============================================================

		NativeRect						GetBounds() override;
		NativeRect						GetClientBounds() override;
		WString							GetName() override;
		bool							IsPrimary() override;
		double							GetScalingX() override;
		double							GetScalingY() override;

		// =============================================================
		// INativeWindowService
		// =============================================================
			
		const NativeWindowFrameConfig&	GetMainWindowFrameConfig() override;
		const NativeWindowFrameConfig&	GetNonMainWindowFrameConfig() override;
		INativeWindow*					CreateNativeWindow(INativeWindow::WindowMode windowMode) override;
		void							DestroyNativeWindow(INativeWindow* window) override;
		INativeWindow*					GetMainWindow() override;
		INativeWindow*					GetWindow(NativePoint location) override;
		void							Run(INativeWindow* window) override;
		bool							RunOneCycle() override;

		// =============================================================
		// Events
		// =============================================================

		void							OnControllerConnect();
		void							OnControllerDisconnect();
		void							OnControllerRequestExit();
		void							OnControllerForceExit();
		void							OnControllerScreenUpdated(const remoteprotocol::ScreenConfig& arguments);

	public:
		GuiRemoteController(IGuiRemoteProtocol* _remoteProtocol);
		~GuiRemoteController();

		void							Initialize();
		void							Finalize();

		// =============================================================
		// INativeController
		// =============================================================

		INativeCallbackService*			CallbackService() override;
		INativeResourceService*			ResourceService() override;
		INativeAsyncService*			AsyncService() override;
		INativeClipboardService*		ClipboardService() override;
		INativeImageService*			ImageService() override;
		INativeInputService*			InputService() override;
		INativeDialogService*			DialogService() override;
		WString							GetExecutablePath() override;
			
		INativeScreenService*			ScreenService() override;
		INativeWindowService*			WindowService() override;
	};
}

#endif
