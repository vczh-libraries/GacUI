/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "Vlpp.h"
#include "VlppWorkflow.h"

/***********************************************************************
GACVLPPREFERENCES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Vczh Library++ 3.0 References

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACVLPPREFERENCES
#define VCZH_PRESENTATION_GACVLPPREFERENCES


#endif

/***********************************************************************
GUITYPES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Common Types

Classes:
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUITYPES
#define VCZH_PRESENTATION_GUITYPES


namespace vl
{
	namespace presentation
	{

/***********************************************************************
Enumerations
***********************************************************************/
		
		enum class Alignment
		{
			Left=0,
			Top=0,
			Center=1,
			Right=2,
			Bottom=2,
		};

/***********************************************************************
TextPos
***********************************************************************/
		
		struct TextPos
		{
			vint			row;
			vint			column;

			TextPos()
				:row(0) ,column(0)
			{
			}

			TextPos(vint _row, vint _column)
				:row(_row) ,column(_column)
			{
			}

			vint Compare(const TextPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const TextPos& value)const {return Compare(value)==0;}
			bool operator!=(const TextPos& value)const {return Compare(value)!=0;}
			bool operator<(const TextPos& value)const {return Compare(value)<0;}
			bool operator<=(const TextPos& value)const {return Compare(value)<=0;}
			bool operator>(const TextPos& value)const {return Compare(value)>0;}
			bool operator>=(const TextPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
GridPos
***********************************************************************/
		
		struct GridPos
		{
			vint			row;
			vint			column;

			GridPos()
				:row(0) ,column(0)
			{
			}

			GridPos(vint _row, vint _column)
				:row(_row) ,column(_column)
			{
			}

			vint Compare(const GridPos& value)const
			{
				if(row<value.row) return -1;
				if(row>value.row) return 1;
				if(column<value.column) return -1;
				if(column>value.column) return 1;
				return 0;
			}

			bool operator==(const GridPos& value)const {return Compare(value)==0;}
			bool operator!=(const GridPos& value)const {return Compare(value)!=0;}
			bool operator<(const GridPos& value)const {return Compare(value)<0;}
			bool operator<=(const GridPos& value)const {return Compare(value)<=0;}
			bool operator>(const GridPos& value)const {return Compare(value)>0;}
			bool operator>=(const GridPos& value)const {return Compare(value)>=0;}
		};

/***********************************************************************
Point
***********************************************************************/
		
		struct Point
		{
			vint			x;
			vint			y;

			Point()
				:x(0) ,y(0)
			{
			}

			Point(vint _x, vint _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Point point)const
			{
				return x==point.x && y==point.y;
			}

			bool operator!=(Point point)const
			{
				return x!=point.x || y!=point.y;
			}
		};

/***********************************************************************
Size
***********************************************************************/
		
		struct Size
		{
			vint			x;
			vint			y;

			Size()
				:x(0) ,y(0)
			{
			}

			Size(vint _x, vint _y)
				:x(_x) ,y(_y)
			{
			}

			bool operator==(Size size)const
			{
				return x==size.x && y==size.y;
			}

			bool operator!=(Size size)const
			{
				return x!=size.x || y!=size.y;
			}
		};

/***********************************************************************
Rectangle
***********************************************************************/
		
		struct Rect
		{
			vint		x1;
			vint		y1;
			vint		x2;
			vint		y2;

			Rect()
				:x1(0), y1(0), x2(0), y2(0)
			{
			}

			Rect(vint _x1, vint _y1, vint _x2, vint _y2)
				:x1(_x1), y1(_y1), x2(_x2), y2(_y2)
			{
			}

			Rect(Point p, Size s)
				:x1(p.x), y1(p.y), x2(p.x+s.x), y2(p.y+s.y)
			{
			}

			bool operator==(Rect rect)const
			{
				return x1==rect.x1 && y1==rect.y1 && x2==rect.x2 && y2==rect.y2;
			}

			bool operator!=(Rect rect)const
			{
				return x1!=rect.x1 || y1!=rect.y1 || x2!=rect.x2 || y2!=rect.y2;
			}

			Point LeftTop()const
			{
				return Point(x1, y1);
			}

			Point RightBottom()const
			{
				return Point(x2, y2);
			}

			Size GetSize()const
			{
				return Size(x2-x1, y2-y1);
			}

			vint Left()const
			{
				return x1;
			}

			vint Right()const
			{
				return x2;
			}

			vint Width()const
			{
				return x2-x1;
			}

			vint Top()const
			{
				return y1;
			}

			vint Bottom()const
			{
				return y2;
			}

			vint Height()const
			{
				return y2-y1;
			}

			void Expand(vint x, vint y)
			{
				x1-=x;
				y1-=y;
				x2+=x;
				y2+=y;
			}

			void Expand(Size s)
			{
				x1-=s.x;
				y1-=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			void Move(vint x, vint y)
			{
				x1+=x;
				y1+=y;
				x2+=x;
				y2+=y;
			}

			void Move(Size s)
			{
				x1+=s.x;
				y1+=s.y;
				x2+=s.x;
				y2+=s.y;
			}

			bool Contains(Point p)
			{
				return x1<=p.x && p.x<x2 && y1<=p.y && p.y<y2;
			}
		};

/***********************************************************************
2D operations
***********************************************************************/

		inline Point operator+(Point p, Size s)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator+(Size s, Point p)
		{
			return Point(p.x+s.x, p.y+s.y);
		}

		inline Point operator-(Point p, Size s)
		{
			return Point(p.x-s.x, p.y-s.y);
		}

		inline Size operator-(Point p1, Point p2)
		{
			return Size(p1.x-p2.x, p1.y-p2.y);
		}

		inline Size operator+(Size s1, Size s2)
		{
			return Size(s1.x+s2.x, s1.y+s2.y);
		}

		inline Size operator-(Size s1, Size s2)
		{
			return Size(s1.x-s2.x, s1.y-s2.y);
		}

		inline Size operator*(Size s, vint i)
		{
			return Size(s.x*i, s.y*i);
		}

		inline Size operator/(Size s, vint i)
		{
			return Size(s.x/i, s.y/i);
		}

		inline Point operator+=(Point& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Point operator-=(Point& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

		inline Size operator+=(Size& s1, Size s2)
		{
			s1.x+=s2.x;
			s1.y+=s2.y;
			return s1;
		}

		inline Size operator-=(Size& s1, Size s2)
		{
			s1.x-=s2.x;
			s1.y-=s2.y;
			return s1;
		}

/***********************************************************************
Color
***********************************************************************/
		
		struct Color
		{
			union
			{
				struct
				{
					unsigned char r;
					unsigned char g;
					unsigned char b;
					unsigned char a;
				};
				vuint32_t value;
			};

			Color()
				:r(0), g(0), b(0), a(255)
			{
			}

			Color(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a=255)
				:r(_r), g(_g), b(_b), a(_a)
			{
			}

			vint Compare(Color color)const
			{
				return value-color.value;
			}

			static Color Parse(const WString& value)
			{
				const wchar_t* code=L"0123456789ABCDEF";
				if((value.Length()==7 || value.Length()==9) && value[0]==L'#')
				{
					vint index[8]={15, 15, 15, 15, 15, 15, 15, 15};
					for(vint i=0;i<value.Length()-1;i++)
					{
						index[i]=wcschr(code, value[i+1])-code;
						if(index[i]<0 || index[i]>15)
						{
							return Color();
						}
					}

					Color c;
					c.r=(unsigned char)(index[0]*16+index[1]);
					c.g=(unsigned char)(index[2]*16+index[3]);
					c.b=(unsigned char)(index[4]*16+index[5]);
					c.a=(unsigned char)(index[6]*16+index[7]);
					return c;
				}
				return Color();
			}

			WString ToString()const
			{
				const wchar_t* code=L"0123456789ABCDEF";
				wchar_t result[10]=L"#00000000";
				result[1]=code[r/16];
				result[2]=code[r%16];
				result[3]=code[g/16];
				result[4]=code[g%16];
				result[5]=code[b/16];
				result[6]=code[b%16];
				if(a==255)
				{
					result[7]=L'\0';
				}
				else
				{
					result[7]=code[a/16];
					result[8]=code[a%16];
				}
				return result;
			}

			bool operator==(Color color)const {return Compare(color)==0;}
			bool operator!=(Color color)const {return Compare(color)!=0;}
			bool operator<(Color color)const {return Compare(color)<0;}
			bool operator<=(Color color)const {return Compare(color)<=0;}
			bool operator>(Color color)const {return Compare(color)>0;}
			bool operator>=(Color color)const {return Compare(color)>=0;}
		};

/***********************************************************************
Margin
***********************************************************************/
		
		struct Margin
		{
			vint		left;
			vint		top;
			vint		right;
			vint		bottom;

			Margin()
				:left(0), top(0), right(0), bottom(0)
			{
			}

			Margin(vint _left, vint _top, vint _right, vint _bottom)
				:left(_left), top(_top), right(_right), bottom(_bottom)
			{
			}

			bool operator==(Margin margin)const
			{
				return left==margin.left && top==margin.top && right==margin.right && bottom==margin.bottom;
			}

			bool operator!=(Margin margin)const
			{
				return left!=margin.left || top!=margin.top || right!=margin.right || bottom!=margin.bottom;
			}
		};

/***********************************************************************
Resources
***********************************************************************/
		
		struct FontProperties
		{
			WString				fontFamily;
			vint				size;
			bool				bold;
			bool				italic;
			bool				underline;
			bool				strikeline;
			bool				antialias;
			bool				verticalAntialias;

			FontProperties()
				:size(0)
				,bold(false)
				,italic(false)
				,underline(false)
				,strikeline(false)
				,antialias(true)
				,verticalAntialias(false)
			{
			}
			
			vint Compare(const FontProperties& value)const
			{
				vint result=0;
				
				result=WString::Compare(fontFamily, value.fontFamily);
				if(result!=0) return result;

				result=size-value.size;
				if(result!=0) return result;

				result=(vint)bold-(vint)value.bold;
				if(result!=0) return result;

				result=(vint)italic-(vint)value.italic;
				if(result!=0) return result;

				result=(vint)underline-(vint)value.underline;
				if(result!=0) return result;

				result=(vint)strikeline-(vint)value.strikeline;
				if(result!=0) return result;

				result=(vint)antialias-(vint)value.antialias;
				if(result!=0) return result;

				return 0;
			}

			bool operator==(const FontProperties& value)const {return Compare(value)==0;}
			bool operator!=(const FontProperties& value)const {return Compare(value)!=0;}
			bool operator<(const FontProperties& value)const {return Compare(value)<0;}
			bool operator<=(const FontProperties& value)const {return Compare(value)<=0;}
			bool operator>(const FontProperties& value)const {return Compare(value)>0;}
			bool operator>=(const FontProperties& value)const {return Compare(value)>=0;}
		};
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSELEMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		namespace elements
		{
			class IGuiGraphicsElement;
			class IGuiGraphicsElementFactory;
			class IGuiGraphicsRenderer;
			class IGuiGraphicsRendererFactory;
			class IGuiGraphicsRenderTarget;

/***********************************************************************
Basic Construction
***********************************************************************/

			class IGuiGraphicsElement : public virtual IDescriptable, public Description<IGuiGraphicsElement>
			{
			public:
				virtual IGuiGraphicsElementFactory*		GetFactory()=0;
				virtual IGuiGraphicsRenderer*			GetRenderer()=0;
			};

			class IGuiGraphicsElementFactory : public Interface
			{
			public:
				virtual WString							GetElementTypeName()=0;
				virtual IGuiGraphicsElement*			Create()=0;
			};

			class IGuiGraphicsRenderer : public Interface
			{
			public:
				virtual IGuiGraphicsRendererFactory*	GetFactory()=0;

				virtual void							Initialize(IGuiGraphicsElement* element)=0;
				virtual void							Finalize()=0;
				virtual void							SetRenderTarget(IGuiGraphicsRenderTarget* renderTarget)=0;
				virtual void							Render(Rect bounds)=0;
				virtual void							OnElementStateChanged()=0;
				virtual Size							GetMinSize()=0;
			};

			class IGuiGraphicsRendererFactory : public Interface
			{
			public:
				virtual IGuiGraphicsRenderer*			Create()=0;
			};

			class IGuiGraphicsRenderTarget : public Interface
			{
			public:
				virtual void							StartRendering()=0;
				virtual bool							StopRendering()=0;
				virtual void							PushClipper(Rect clipper)=0;
				virtual void							PopClipper()=0;
				virtual Rect							GetClipper()=0;
				virtual bool							IsClipperCoverWholeTarget()=0;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSDOCUMENTINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTINTERFACES


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		namespace elements
		{

/***********************************************************************
Layout Engine
***********************************************************************/

			class IGuiGraphicsParagraph;
			class IGuiGraphicsLayoutProvider;

			class IGuiGraphicsParagraph : public IDescriptable, public Description<IGuiGraphicsParagraph>
			{
			public:
				static const vint		NullInteractionId = -1;

				enum TextStyle
				{
					Bold=1,
					Italic=2,
					Underline=4,
					Strikeline=8,
				};

				enum BreakCondition
				{
					StickToPreviousRun,
					StickToNextRun,
					Alone,
				};

				enum CaretRelativePosition
				{
					CaretFirst,
					CaretLast,
					CaretLineFirst,
					CaretLineLast,
					CaretMoveLeft,
					CaretMoveRight,
					CaretMoveUp,
					CaretMoveDown,
				};

				struct InlineObjectProperties
				{
					Size					size;
					vint					baseline;
					BreakCondition			breakCondition;

					InlineObjectProperties()
						:baseline(-1)
					{
					}
				};

				virtual IGuiGraphicsLayoutProvider*			GetProvider()=0;
				virtual IGuiGraphicsRenderTarget*			GetRenderTarget()=0;
				virtual bool								GetWrapLine()=0;
				virtual void								SetWrapLine(bool value)=0;
				virtual vint								GetMaxWidth()=0;
				virtual void								SetMaxWidth(vint value)=0;
				virtual Alignment							GetParagraphAlignment()=0;
				virtual void								SetParagraphAlignment(Alignment value)=0;

				virtual bool								SetFont(vint start, vint length, const WString& value)=0;
				virtual bool								SetSize(vint start, vint length, vint value)=0;
				virtual bool								SetStyle(vint start, vint length, TextStyle value)=0;
				virtual bool								SetColor(vint start, vint length, Color value)=0;
				virtual bool								SetBackgroundColor(vint start, vint length, Color value)=0;
				virtual bool								SetInlineObject(vint start, vint length, const InlineObjectProperties& properties, Ptr<IGuiGraphicsElement> value)=0;
				virtual bool								ResetInlineObject(vint start, vint length)=0;

				virtual vint								GetHeight()=0;
				virtual bool								OpenCaret(vint caret, Color color, bool frontSide)=0;
				virtual bool								CloseCaret()=0;
				virtual void								Render(Rect bounds)=0;

				virtual vint								GetCaret(vint comparingCaret, CaretRelativePosition position, bool& preferFrontSide)=0;
				virtual Rect								GetCaretBounds(vint caret, bool frontSide)=0;
				virtual vint								GetCaretFromPoint(Point point)=0;
				virtual Ptr<IGuiGraphicsElement>			GetInlineObjectFromPoint(Point point, vint& start, vint& length)=0;
				virtual vint								GetNearestCaretFromTextPos(vint textPos, bool frontSide)=0;
				virtual bool								IsValidCaret(vint caret)=0;
				virtual bool								IsValidTextPos(vint textPos)=0;
			};

			class IGuiGraphicsLayoutProvider : public IDescriptable, public Description<IGuiGraphicsLayoutProvider>
			{
			public:
				virtual Ptr<IGuiGraphicsParagraph>			CreateParagraph(const WString& text, IGuiGraphicsRenderTarget* renderTarget)=0;
			};
		}
	}
}

#endif

/***********************************************************************
NATIVEWINDOW\GUINATIVEWINDOW.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Native Window

Interfaces:
  INativeWindow							：窗口适配器
  INativeWindowListener					：窗口事件监听器
  INativeController						：全局控制器
  INativeControllerListener				：全局事件监听器

Renderers:
  GUI_GRAPHICS_RENDERER_GDI
  GUI_GRAPHICS_RENDERER_DIRECT2D
***********************************************************************/

#ifndef VCZH_PRESENTATION_GUINATIVEWINDOW
#define VCZH_PRESENTATION_GUINATIVEWINDOW


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		class INativeWindow;
		class INativeWindowListener;
		class INativeController;
		class INativeControllerListener;

/***********************************************************************
System Object
***********************************************************************/

		class INativeScreen : public virtual IDescriptable, Description<INativeScreen>
		{
		public:
			virtual Rect				GetBounds()=0;
			virtual Rect				GetClientBounds()=0;
			virtual WString				GetName()=0;
			virtual bool				IsPrimary()=0;
		};
		
		class INativeCursor : public virtual IDescriptable, Description<INativeCursor>
		{
		public:
			enum SystemCursorType
			{
				SmallWaiting,
				LargeWaiting,
				Arrow,
				Cross,
				Hand,
				Help,
				IBeam,
				SizeAll,
				SizeNESW,
				SizeNS,
				SizeNWSE,
				SizeWE,
				LastSystemCursor=SizeWE,
			};

			static const vint			SystemCursorCount=LastSystemCursor+1;
		public:
			virtual bool				IsSystemCursor()=0;
			virtual SystemCursorType	GetSystemCursorType()=0;
		};

/***********************************************************************
Image Object
***********************************************************************/

		class INativeImageService;
		class INativeImage;
		class INativeImageFrame;
		
		class INativeImageFrameCache : public Interface
		{
		public:
			virtual void						OnAttach(INativeImageFrame* frame)=0;
			virtual void						OnDetach(INativeImageFrame* frame)=0;
		};

		class INativeImageFrame : public virtual IDescriptable, public Description<INativeImageFrame>
		{
		public:
			virtual INativeImage*				GetImage()=0;
			virtual Size						GetSize()=0;

			virtual bool						SetCache(void* key, Ptr<INativeImageFrameCache> cache)=0;
			virtual Ptr<INativeImageFrameCache>	GetCache(void* key)=0;
			virtual Ptr<INativeImageFrameCache>	RemoveCache(void* key)=0;
		};
		
		class INativeImage : public virtual IDescriptable, public Description<INativeImage>
		{
		public:
			enum FormatType
			{
				Bmp,
				Gif,
				Icon,
				Jpeg,
				Png,
				Tiff,
				Wmp,
				Unknown,
			};
			
			virtual INativeImageService*		GetImageService()=0;
			virtual FormatType					GetFormat()=0;
			virtual vint						GetFrameCount()=0;
			virtual INativeImageFrame*			GetFrame(vint index)=0;
		};
		
		class INativeImageService : public virtual IDescriptable, public Description<INativeImageService>
		{
		public:
			virtual Ptr<INativeImage>			CreateImageFromFile(const WString& path)=0;

			virtual Ptr<INativeImage>			CreateImageFromMemory(void* buffer, vint length)=0;

			virtual Ptr<INativeImage>			CreateImageFromStream(stream::IStream& stream)=0;
		};

/***********************************************************************
Native Window
***********************************************************************/
		
		class INativeWindow : public Interface, public Description<INativeWindow>
		{
		public:
			virtual Rect				GetBounds()=0;
			virtual void				SetBounds(const Rect& bounds)=0;
			virtual Size				GetClientSize()=0;
			virtual void				SetClientSize(Size size)=0;
			virtual Rect				GetClientBoundsInScreen()=0;
			
			virtual WString				GetTitle()=0;
			virtual void				SetTitle(WString title)=0;
			virtual INativeCursor*		GetWindowCursor()=0;
			virtual void				SetWindowCursor(INativeCursor* cursor)=0;
			virtual Point				GetCaretPoint()=0;
			virtual void				SetCaretPoint(Point point)=0;
			
			virtual INativeWindow*		GetParent()=0;
			virtual void				SetParent(INativeWindow* parent)=0;
			virtual bool				GetAlwaysPassFocusToParent()=0;
			virtual void				SetAlwaysPassFocusToParent(bool value)=0;

			virtual void				EnableCustomFrameMode()=0;
			virtual void				DisableCustomFrameMode()=0;
			virtual bool				IsCustomFrameModeEnabled()=0;

			enum WindowSizeState
			{
				Minimized,
				Restored,
				Maximized,
			};

			virtual WindowSizeState		GetSizeState()=0;
			virtual void				Show()=0;
			virtual void				ShowDeactivated()=0;
			virtual void				ShowRestored()=0;
			virtual void				ShowMaximized()=0;
			virtual void				ShowMinimized()=0;
			virtual void				Hide()=0;
			virtual bool				IsVisible()=0;

			virtual void				Enable()=0;
			virtual void				Disable()=0;
			virtual bool				IsEnabled()=0;
			
			virtual void				SetFocus()=0;
			virtual bool				IsFocused()=0;
			virtual void				SetActivate()=0;
			virtual bool				IsActivated()=0;
			
			virtual void				ShowInTaskBar()=0;
			virtual void				HideInTaskBar()=0;
			virtual bool				IsAppearedInTaskBar()=0;
			
			virtual void				EnableActivate()=0;
			virtual void				DisableActivate()=0;
			virtual bool				IsEnabledActivate()=0;
			
			virtual bool				RequireCapture()=0;
			virtual bool				ReleaseCapture()=0;
			virtual bool				IsCapturing()=0;

			virtual bool				GetMaximizedBox()=0;
			virtual void				SetMaximizedBox(bool visible)=0;
			virtual bool				GetMinimizedBox()=0;
			virtual void				SetMinimizedBox(bool visible)=0;
			virtual bool				GetBorder()=0;
			virtual void				SetBorder(bool visible)=0;
			virtual bool				GetSizeBox()=0;
			virtual void				SetSizeBox(bool visible)=0;
			virtual bool				GetIconVisible()=0;
			virtual void				SetIconVisible(bool visible)=0;
			virtual bool				GetTitleBar()=0;
			virtual void				SetTitleBar(bool visible)=0;
			virtual bool				GetTopMost()=0;
			virtual void				SetTopMost(bool topmost)=0;

			virtual void				SupressAlt() = 0;
			
			virtual bool				InstallListener(INativeWindowListener* listener)=0;
			virtual bool				UninstallListener(INativeWindowListener* listener)=0;
			virtual void				RedrawContent()=0;
		};

		struct NativeWindowMouseInfo
		{
			bool						ctrl;
			bool						shift;
			bool						left;
			bool						middle;
			bool						right;
			vint						x;
			vint						y;
			vint						wheel;
			bool						nonClient;
		};
		
		struct NativeWindowKeyInfo
		{
			vint						code;
			bool						ctrl;
			bool						shift;
			bool						alt;
			bool						capslock;
		};
		
		struct NativeWindowCharInfo
		{
			wchar_t						code;
			bool						ctrl;
			bool						shift;
			bool						alt;
			bool						capslock;
		};
		
		class INativeWindowListener : public Interface
		{
		public:
			enum HitTestResult
			{
				BorderNoSizing,
				BorderLeft,
				BorderRight,
				BorderTop,
				BorderBottom,
				BorderLeftTop,
				BorderRightTop,
				BorderLeftBottom,
				BorderRightBottom,
				Title,
				ButtonMinimum,
				ButtonMaximum,
				ButtonClose,
				Client,
				Icon,
				NoDecision,
			};

			virtual HitTestResult		HitTest(Point location);
			virtual void				Moving(Rect& bounds, bool fixSizeOnly);
			virtual void				Moved();
			virtual void				Enabled();
			virtual void				Disabled();
			virtual void				GotFocus();
			virtual void				LostFocus();
			virtual void				Activated();
			virtual void				Deactivated();
			virtual void				Opened();
			virtual void				Closing(bool& cancel);
			virtual void				Closed();
			virtual void				Paint();
			virtual void				Destroying();
			virtual void				Destroyed();
			
			virtual void				LeftButtonDown(const NativeWindowMouseInfo& info);
			virtual void				LeftButtonUp(const NativeWindowMouseInfo& info);
			virtual void				LeftButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				RightButtonDown(const NativeWindowMouseInfo& info);
			virtual void				RightButtonUp(const NativeWindowMouseInfo& info);
			virtual void				RightButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonDown(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonUp(const NativeWindowMouseInfo& info);
			virtual void				MiddleButtonDoubleClick(const NativeWindowMouseInfo& info);
			virtual void				HorizontalWheel(const NativeWindowMouseInfo& info);
			virtual void				VerticalWheel(const NativeWindowMouseInfo& info);
			virtual void				MouseMoving(const NativeWindowMouseInfo& info);
			virtual void				MouseEntered();
			virtual void				MouseLeaved();
			
			virtual void				KeyDown(const NativeWindowKeyInfo& info);
			virtual void				KeyUp(const NativeWindowKeyInfo& info);
			virtual void				SysKeyDown(const NativeWindowKeyInfo& info);
			virtual void				SysKeyUp(const NativeWindowKeyInfo& info);
			virtual void				Char(const NativeWindowCharInfo& info);
		};

/***********************************************************************
Native Window Services
***********************************************************************/

		class INativeResourceService : public virtual IDescriptable, public Description<INativeResourceService>
		{
		public:
			virtual INativeCursor*			GetSystemCursor(INativeCursor::SystemCursorType type)=0;
			virtual INativeCursor*			GetDefaultSystemCursor()=0;

			virtual FontProperties			GetDefaultFont()=0;
			virtual void					SetDefaultFont(const FontProperties& value)=0;
		};

		class INativeDelay : public virtual IDescriptable, public Description<INativeDelay>
		{
		public:
			enum ExecuteStatus
			{
				Pending,
				Executing,
				Executed,
				Canceled,
			};

			virtual ExecuteStatus			GetStatus()=0;
			virtual bool					Delay(vint milliseconds)=0;
			virtual bool					Cancel()=0;
		};
		
		class INativeAsyncService : public virtual IDescriptable, public Description<INativeAsyncService>
		{
		public:

			virtual bool					IsInMainThread()=0;
			virtual void					InvokeAsync(const Func<void()>& proc)=0;
			virtual void					InvokeInMainThread(const Func<void()>& proc)=0;
			virtual bool					InvokeInMainThreadAndWait(const Func<void()>& proc, vint milliseconds=-1)=0;
			virtual Ptr<INativeDelay>		DelayExecute(const Func<void()>& proc, vint milliseconds)=0;
			virtual Ptr<INativeDelay>		DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds)=0;
		};
		
		class INativeClipboardService : public virtual IDescriptable, public Description<INativeClipboardService>
		{
		public:
			virtual bool					ContainsText()=0;
			virtual WString					GetText()=0;
			virtual bool					SetText(const WString& value)=0;
		};
		
		class INativeScreenService : public virtual IDescriptable, public Description<INativeScreenService>
		{
		public:
			virtual vint					GetScreenCount()=0;
			virtual INativeScreen*			GetScreen(vint index)=0;
			virtual INativeScreen*			GetScreen(INativeWindow* window)=0;
		};
		
		class INativeWindowService : public virtual Interface
		{
		public:
			virtual INativeWindow*			CreateNativeWindow()=0;
			virtual void					DestroyNativeWindow(INativeWindow* window)=0;
			virtual INativeWindow*			GetMainWindow()=0;
			virtual INativeWindow*			GetWindow(Point location)=0;
			virtual void					Run(INativeWindow* window)=0;
		};
		
		class INativeInputService : public virtual IDescriptable, public Description<INativeInputService>
		{
		public:
			virtual void					StartHookMouse()=0;
			virtual void					StopHookMouse()=0;
			virtual bool					IsHookingMouse()=0;
			
			virtual void					StartTimer()=0;
			virtual void					StopTimer()=0;
			virtual bool					IsTimerEnabled()=0;
			
			virtual bool					IsKeyPressing(vint code)=0;
			virtual bool					IsKeyToggled(vint code)=0;

			virtual WString					GetKeyName(vint code)=0;
			virtual vint					GetKey(const WString& name)=0;
		};
		
		class INativeCallbackService : public virtual Interface
		{
		public:
			virtual bool					InstallListener(INativeControllerListener* listener)=0;
			virtual bool					UninstallListener(INativeControllerListener* listener)=0;
		};


		class INativeDialogService : public virtual Interface
		{
		public:
			enum MessageBoxButtonsInput
			{
				DisplayOK,
				DisplayOKCancel,
				DisplayYesNo,
				DisplayYesNoCancel,
				DisplayRetryCancel,
				DisplayAbortRetryIgnore,
				DisplayCancelTryAgainContinue,
			};

			enum MessageBoxButtonsOutput
			{
				SelectOK,
				SelectCancel,
				SelectYes,
				SelectNo,
				SelectRetry,
				SelectAbort,
				SelectIgnore,
				SelectTryAgain,
				SelectContinue,
			};

			enum MessageBoxDefaultButton
			{
				DefaultFirst,
				DefaultSecond,
				DefaultThird,
			};

			enum MessageBoxIcons
			{
				IconNone,
				IconError,
				IconQuestion,
				IconWarning,
				IconInformation,
			};

			enum MessageBoxModalOptions
			{
				ModalWindow,
				ModalTask,
				ModalSystem,
			};

			virtual MessageBoxButtonsOutput			ShowMessageBox(INativeWindow* window, const WString& text, const WString& title=L"", MessageBoxButtonsInput buttons=DisplayOK, MessageBoxDefaultButton defaultButton=DefaultFirst, MessageBoxIcons icon=IconNone, MessageBoxModalOptions modal=ModalWindow)=0;

			enum ColorDialogCustomColorOptions
			{
				CustomColorDisabled,
				CustomColorEnabled,
				CustomColorOpened,
			};

			virtual bool							ShowColorDialog(INativeWindow* window, Color& selection, bool selected=false, ColorDialogCustomColorOptions customColorOptions=CustomColorEnabled, Color* customColors=0)=0;

			virtual bool							ShowFontDialog(INativeWindow* window, FontProperties& selectionFont, Color& selectionColor, bool selected=false, bool showEffect=true, bool forceFontExist=true)=0;
			
			enum FileDialogTypes
			{
				FileDialogOpen,
				FileDialogOpenPreview,
				FileDialogSave,
				FileDialogSavePreview,
			};

			enum FileDialogOptions
			{
				FileDialogAllowMultipleSelection = 1,
				FileDialogFileMustExist = 2,
				FileDialogShowReadOnlyCheckBox = 4,
				FileDialogDereferenceLinks = 8,
				FileDialogShowNetworkButton = 16,
				FileDialogPromptCreateFile = 32,
				FileDialogPromptOverwriteFile = 64,
				FileDialogDirectoryMustExist = 128,
				FileDialogAddToRecent = 256,
			};

			virtual bool							ShowFileDialog(INativeWindow* window, collections::List<WString>& selectionFileNames, vint& selectionFilterIndex, FileDialogTypes dialogType, const WString& title, const WString& initialFileName, const WString& initialDirectory, const WString& defaultExtension, const WString& filter, FileDialogOptions options)=0;
		};

/***********************************************************************
Native Window Controller
***********************************************************************/

		class INativeController : public virtual IDescriptable, public Description<INativeController>
		{
		public:
			virtual INativeCallbackService*			CallbackService()=0;
			virtual INativeResourceService*			ResourceService()=0;
			virtual INativeAsyncService*			AsyncService()=0;
			virtual INativeClipboardService*		ClipboardService()=0;
			virtual INativeImageService*			ImageService()=0;
			virtual INativeScreenService*			ScreenService()=0;
			virtual INativeWindowService*			WindowService()=0;
			virtual INativeInputService*			InputService()=0;
			virtual INativeDialogService*			DialogService()=0;
			virtual WString							GetOSVersion()=0;
			virtual WString							GetExecutablePath()=0;
		};
		
		class INativeControllerListener : public Interface
		{
		public:
			virtual void					LeftButtonDown(Point position);
			virtual void					LeftButtonUp(Point position);
			virtual void					RightButtonDown(Point position);
			virtual void					RightButtonUp(Point position);
			virtual void					MouseMoving(Point position);
			virtual void					GlobalTimer();
			virtual void					ClipboardUpdated();
			virtual void					NativeWindowCreated(INativeWindow* window);
			virtual void					NativeWindowDestroying(INativeWindow* window);
		};

		extern								INativeController* GetCurrentController();
		extern void							SetCurrentController(INativeController* controller);
	}
}

/***********************************************************************
Native Window Provider
***********************************************************************/

/*
 * Virtual Keys, Standard Set
 */
#define VKEY_LBUTTON        0x01
#define VKEY_RBUTTON        0x02
#define VKEY_CANCEL         0x03
#define VKEY_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VKEY_XBUTTON1       0x05    /* NOT contiguous with L & RBUTTON */
#define VKEY_XBUTTON2       0x06    /* NOT contiguous with L & RBUTTON */

/*
 * 0x07 : unassigned
 */

#define VKEY_BACK           0x08
#define VKEY_TAB            0x09

/*
 * 0x0A - 0x0B : reserved
 */

#define VKEY_CLEAR          0x0C
#define VKEY_RETURN         0x0D

#define VKEY_SHIFT          0x10
#define VKEY_CONTROL        0x11
#define VKEY_MENU           0x12
#define VKEY_PAUSE          0x13
#define VKEY_CAPITAL        0x14

#define VKEY_KANA           0x15
#define VKEY_HANGEUL        0x15  /* old name - should be here for compatibility */
#define VKEY_HANGUL         0x15
#define VKEY_JUNJA          0x17
#define VKEY_FINAL          0x18
#define VKEY_HANJA          0x19
#define VKEY_KANJI          0x19

#define VKEY_ESCAPE         0x1B

#define VKEY_CONVERT        0x1C
#define VKEY_NONCONVERT     0x1D
#define VKEY_ACCEPT         0x1E
#define VKEY_MODECHANGE     0x1F

#define VKEY_SPACE          0x20
#define VKEY_PRIOR          0x21
#define VKEY_NEXT           0x22
#define VKEY_END            0x23
#define VKEY_HOME           0x24
#define VKEY_LEFT           0x25
#define VKEY_UP             0x26
#define VKEY_RIGHT          0x27
#define VKEY_DOWN           0x28
#define VKEY_SELECT         0x29
#define VKEY_PRINT          0x2A
#define VKEY_EXECUTE        0x2B
#define VKEY_SNAPSHOT       0x2C
#define VKEY_INSERT         0x2D
#define VKEY_DELETE         0x2E
#define VKEY_HELP           0x2F

/*
 * VKEY_0 - VKEY_9 are the same as ASCII '0' - '9' (0x30 - 0x39)
 * 0x40 : unassigned
 * VKEY_A - VKEY_Z are the same as ASCII 'A' - 'Z' (0x41 - 0x5A)
 */

#define VKEY_0              0x30
#define VKEY_1              0x31
#define VKEY_2              0x32
#define VKEY_3              0x33
#define VKEY_4              0x34
#define VKEY_5              0x35
#define VKEY_6              0x36
#define VKEY_7              0x37
#define VKEY_8              0x38
#define VKEY_9              0x39

#define VKEY_A              0x41
#define VKEY_B              0x42
#define VKEY_C              0x43
#define VKEY_D              0x44
#define VKEY_E              0x45
#define VKEY_F              0x46
#define VKEY_G              0x47
#define VKEY_H              0x48
#define VKEY_I              0x49
#define VKEY_J              0x4A
#define VKEY_K              0x4B
#define VKEY_L              0x4C
#define VKEY_M              0x4D
#define VKEY_N              0x4E
#define VKEY_O              0x4F
#define VKEY_P              0x50
#define VKEY_Q              0x51
#define VKEY_R              0x52
#define VKEY_S              0x53
#define VKEY_T              0x54
#define VKEY_U              0x55
#define VKEY_V              0x56
#define VKEY_W              0x57
#define VKEY_X              0x58
#define VKEY_Y              0x59
#define VKEY_Z              0x5A

#define VKEY_LWIN           0x5B
#define VKEY_RWIN           0x5C
#define VKEY_APPS           0x5D

/*
 * 0x5E : reserved
 */

#define VKEY_SLEEP          0x5F

#define VKEY_NUMPAD0        0x60
#define VKEY_NUMPAD1        0x61
#define VKEY_NUMPAD2        0x62
#define VKEY_NUMPAD3        0x63
#define VKEY_NUMPAD4        0x64
#define VKEY_NUMPAD5        0x65
#define VKEY_NUMPAD6        0x66
#define VKEY_NUMPAD7        0x67
#define VKEY_NUMPAD8        0x68
#define VKEY_NUMPAD9        0x69
#define VKEY_MULTIPLY       0x6A
#define VKEY_ADD            0x6B
#define VKEY_SEPARATOR      0x6C
#define VKEY_SUBTRACT       0x6D
#define VKEY_DECIMAL        0x6E
#define VKEY_DIVIDE         0x6F
#define VKEY_F1             0x70
#define VKEY_F2             0x71
#define VKEY_F3             0x72
#define VKEY_F4             0x73
#define VKEY_F5             0x74
#define VKEY_F6             0x75
#define VKEY_F7             0x76
#define VKEY_F8             0x77
#define VKEY_F9             0x78
#define VKEY_F10            0x79
#define VKEY_F11            0x7A
#define VKEY_F12            0x7B
#define VKEY_F13            0x7C
#define VKEY_F14            0x7D
#define VKEY_F15            0x7E
#define VKEY_F16            0x7F
#define VKEY_F17            0x80
#define VKEY_F18            0x81
#define VKEY_F19            0x82
#define VKEY_F20            0x83
#define VKEY_F21            0x84
#define VKEY_F22            0x85
#define VKEY_F23            0x86
#define VKEY_F24            0x87

/*
 * 0x88 - 0x8F : unassigned
 */

#define VKEY_NUMLOCK        0x90
#define VKEY_SCROLL         0x91

/*
 * NEC PC-9800 kbd definitions
 */
#define VKEY_OEM_NEC_EQUAL  0x92   // '=' key on numpad

/*
 * Fujitsu/OASYS kbd definitions
 */
#define VKEY_OEM_FJ_JISHO   0x92   // 'Dictionary' key
#define VKEY_OEM_FJ_MASSHOU 0x93   // 'Unregister word' key
#define VKEY_OEM_FJ_TOUROKU 0x94   // 'Register word' key
#define VKEY_OEM_FJ_LOYA    0x95   // 'Left OYAYUBI' key
#define VKEY_OEM_FJ_ROYA    0x96   // 'Right OYAYUBI' key

/*
 * 0x97 - 0x9F : unassigned
 */

/*
 * VKEY_L* & VKEY_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VKEY_LSHIFT         0xA0
#define VKEY_RSHIFT         0xA1
#define VKEY_LCONTROL       0xA2
#define VKEY_RCONTROL       0xA3
#define VKEY_LMENU          0xA4
#define VKEY_RMENU          0xA5

#define VKEY_BROWSER_BACK        0xA6
#define VKEY_BROWSER_FORWARD     0xA7
#define VKEY_BROWSER_REFRESH     0xA8
#define VKEY_BROWSER_STOP        0xA9
#define VKEY_BROWSER_SEARCH      0xAA
#define VKEY_BROWSER_FAVORITES   0xAB
#define VKEY_BROWSER_HOME        0xAC

#define VKEY_VOLUME_MUTE         0xAD
#define VKEY_VOLUME_DOWN         0xAE
#define VKEY_VOLUME_UP           0xAF
#define VKEY_MEDIA_NEXT_TRACK    0xB0
#define VKEY_MEDIA_PREV_TRACK    0xB1
#define VKEY_MEDIA_STOP          0xB2
#define VKEY_MEDIA_PLAY_PAUSE    0xB3
#define VKEY_LAUNCH_MAIL         0xB4
#define VKEY_LAUNCH_MEDIA_SELECT 0xB5
#define VKEY_LAUNCH_APP1         0xB6
#define VKEY_LAUNCH_APP2         0xB7

/*
 * 0xB8 - 0xB9 : reserved
 */

#define VKEY_OEM_1          0xBA   // ';:' for US
#define VKEY_OEM_PLUS       0xBB   // '+' any country
#define VKEY_OEM_COMMA      0xBC   // ',' any country
#define VKEY_OEM_MINUS      0xBD   // '-' any country
#define VKEY_OEM_PERIOD     0xBE   // '.' any country
#define VKEY_OEM_2          0xBF   // '/?' for US
#define VKEY_OEM_3          0xC0   // '`~' for US

/*
 * 0xC1 - 0xD7 : reserved
 */

/*
 * 0xD8 - 0xDA : unassigned
 */

#define VKEY_OEM_4          0xDB  //  '[{' for US
#define VKEY_OEM_5          0xDC  //  '\|' for US
#define VKEY_OEM_6          0xDD  //  ']}' for US
#define VKEY_OEM_7          0xDE  //  ''"' for US
#define VKEY_OEM_8          0xDF

/*
 * 0xE0 : reserved
 */

/*
 * Various extended or enhanced keyboards
 */

#define VKEY_OEM_AX         0xE1  //  'AX' key on Japanese AX kbd
#define VKEY_OEM_102        0xE2  //  "<>" or "\|" on RT 102-key kbd.
#define VKEY_ICO_HELP       0xE3  //  Help key on ICO
#define VKEY_ICO_00         0xE4  //  00 key on ICO

#define VKEY_PROCESSKEY     0xE5
#define VKEY_ICO_CLEAR      0xE6
#define VKEY_PACKET         0xE7

/*
 * 0xE8 : unassigned
 */

/*
 * Nokia/Ericsson definitions
 */
#define VKEY_OEM_RESET      0xE9
#define VKEY_OEM_JUMP       0xEA
#define VKEY_OEM_PA1        0xEB
#define VKEY_OEM_PA2        0xEC
#define VKEY_OEM_PA3        0xED
#define VKEY_OEM_WSCTRL     0xEE
#define VKEY_OEM_CUSEL      0xEF
#define VKEY_OEM_ATTN       0xF0
#define VKEY_OEM_FINISH     0xF1
#define VKEY_OEM_COPY       0xF2
#define VKEY_OEM_AUTO       0xF3
#define VKEY_OEM_ENLW       0xF4
#define VKEY_OEM_BACKTAB    0xF5

#define VKEY_ATTN           0xF6
#define VKEY_CRSEL          0xF7
#define VKEY_EXSEL          0xF8
#define VKEY_EREOF          0xF9
#define VKEY_PLAY           0xFA
#define VKEY_ZOOM           0xFB
#define VKEY_NONAME         0xFC
#define VKEY_PA1            0xFD
#define VKEY_OEM_CLEAR      0xFE

/*
 * Friendly names for common keys (US)
 */
#define VKEY_SEMICOLON		VKEY_OEM_1
#define VKEY_SLASH			VKEY_OEM_2
#define VKEY_GRAVE_ACCENT	VKEY_OEM_3
#define VKEY_RIGHT_BRACKET	VKEY_OEM_4
#define VKEY_BACKSLASH		VKEY_OEM_5
#define VKEY_LEFT_BRACKET	VKEY_OEM_6
#define VKEY_APOSTROPHE		VKEY_OEM_7


#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSRESOURCEMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSRESOURCEMANAGER


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Resource Manager
***********************************************************************/

			class GuiGraphicsResourceManager : public Object
			{
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsElementFactory>>		elementFactoryMap;
				typedef collections::Dictionary<WString, Ptr<IGuiGraphicsRendererFactory>>		rendererFactoryMap;
			protected:
				elementFactoryMap						elementFactories;
				rendererFactoryMap						rendererFactories;
			public:
				GuiGraphicsResourceManager();
				~GuiGraphicsResourceManager();

				virtual bool							RegisterElementFactory(IGuiGraphicsElementFactory* factory);
				virtual bool							RegisterRendererFactory(const WString& elementTypeName, IGuiGraphicsRendererFactory* factory);
				virtual IGuiGraphicsElementFactory*		GetElementFactory(const WString& elementTypeName);
				virtual IGuiGraphicsRendererFactory*	GetRendererFactory(const WString& elementTypeName);
				virtual IGuiGraphicsRenderTarget*		GetRenderTarget(INativeWindow* window)=0;
				virtual void							RecreateRenderTarget(INativeWindow* window) = 0;
				virtual IGuiGraphicsLayoutProvider*		GetLayoutProvider()=0;
			};

			extern GuiGraphicsResourceManager*			GetGuiGraphicsResourceManager();
			extern void									SetGuiGraphicsResourceManager(GuiGraphicsResourceManager* resourceManager);
			extern bool									RegisterFactories(IGuiGraphicsElementFactory* elementFactory, IGuiGraphicsRendererFactory* rendererFactory);

/***********************************************************************
Helpers
***********************************************************************/

#define DEFINE_GUI_GRAPHICS_ELEMENT(TELEMENT, ELEMENT_TYPE_NAME)\
			public:\
				class Factory : public Object, public IGuiGraphicsElementFactory\
				{\
				public:\
					WString GetElementTypeName()\
					{\
						return TELEMENT::GetElementTypeName();\
					}\
					IGuiGraphicsElement* Create()\
					{\
						TELEMENT* element=new TELEMENT;\
						element->factory=this;\
						IGuiGraphicsRendererFactory* rendererFactory=GetGuiGraphicsResourceManager()->GetRendererFactory(GetElementTypeName());\
						if(rendererFactory)\
						{\
							element->renderer=rendererFactory->Create();\
							element->renderer->Initialize(element);\
						}\
						return element;\
					}\
				};\
			protected:\
				IGuiGraphicsElementFactory*		factory;\
				Ptr<IGuiGraphicsRenderer>		renderer;\
			public:\
				static WString GetElementTypeName()\
				{\
					return ELEMENT_TYPE_NAME;\
				}\
				static TELEMENT* Create()\
				{\
					return dynamic_cast<TELEMENT*>(GetGuiGraphicsResourceManager()->GetElementFactory(TELEMENT::GetElementTypeName())->Create());\
				}\
				IGuiGraphicsElementFactory* GetFactory()override\
				{\
					return factory;\
				}\
				IGuiGraphicsRenderer* GetRenderer()override\
				{\
					return renderer.Obj();\
				}\

#define DEFINE_GUI_GRAPHICS_RENDERER(TELEMENT, TRENDERER, TTARGET)\
			public:\
				class Factory : public Object, public IGuiGraphicsRendererFactory\
				{\
				public:\
					IGuiGraphicsRenderer* Create()\
					{\
						TRENDERER* renderer=new TRENDERER;\
						renderer->factory=this;\
						renderer->element=0;\
						renderer->renderTarget=0;\
						return renderer;\
					}\
				};\
			protected:\
				IGuiGraphicsRendererFactory*	factory;\
				TELEMENT*						element;\
				TTARGET*						renderTarget;\
				Size							minSize;\
			public:\
				static void Register()\
				{\
					RegisterFactories(new TELEMENT::Factory, new TRENDERER::Factory);\
				}\
				IGuiGraphicsRendererFactory* GetFactory()override\
				{\
					return factory;\
				}\
				void Initialize(IGuiGraphicsElement* _element)override\
				{\
					element=dynamic_cast<TELEMENT*>(_element);\
					InitializeInternal();\
				}\
				void Finalize()override\
				{\
					FinalizeInternal();\
				}\
				void SetRenderTarget(IGuiGraphicsRenderTarget* _renderTarget)override\
				{\
					TTARGET* oldRenderTarget=renderTarget;\
					renderTarget=dynamic_cast<TTARGET*>(_renderTarget);\
					RenderTargetChangedInternal(oldRenderTarget, renderTarget);\
				}\
				Size GetMinSize()override\
				{\
					return minSize;\
				}\

#define DEFINE_CACHED_RESOURCE_ALLOCATOR(TKEY, TVALUE)\
			public:\
				static const vint DeadPackageMax=32;\
				struct Package\
				{\
					TVALUE							resource;\
					vint								counter;\
					bool operator==(const Package& package)const{return false;}\
					bool operator!=(const Package& package)const{return true;}\
				};\
				struct DeadPackage\
				{\
					TKEY							key;\
					TVALUE							value;\
					bool operator==(const DeadPackage& package)const{return false;}\
					bool operator!=(const DeadPackage& package)const{return true;}\
				};\
				Dictionary<TKEY, Package>			aliveResources;\
				List<DeadPackage>					deadResources;\
			public:\
				TVALUE Create(const TKEY& key)\
				{\
					vint index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values().Get(index);\
						package.counter++;\
						aliveResources.Set(key, package);\
						return package.resource;\
					}\
					TVALUE resource;\
					for(vint i=0;i<deadResources.Count();i++)\
					{\
						if(deadResources[i].key==key)\
						{\
							DeadPackage deadPackage=deadResources[i];\
							deadResources.RemoveAt(i);\
							resource=deadPackage.value;\
							break;\
						}\
					}\
					if(!resource)\
					{\
						resource=CreateInternal(key);\
					}\
					Package package;\
					package.resource=resource;\
					package.counter=1;\
					aliveResources.Add(key, package);\
					return package.resource;\
				}\
				void Destroy(const TKEY& key)\
				{\
					vint index=aliveResources.Keys().IndexOf(key);\
					if(index!=-1)\
					{\
						Package package=aliveResources.Values().Get(index);\
						package.counter--;\
						if(package.counter==0)\
						{\
							aliveResources.Remove(key);\
							if(deadResources.Count()==DeadPackageMax)\
							{\
								deadResources.RemoveAt(DeadPackageMax-1);\
							}\
							DeadPackage deadPackage;\
							deadPackage.key=key;\
							deadPackage.value=package.resource;\
							deadResources.Insert(0, deadPackage);\
						}\
						else\
						{\
							aliveResources.Set(key, package);\
						}\
					}\
				}
		}
	}
}

#endif

/***********************************************************************
RESOURCES\GUIRESOURCE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIRESOURCE
#define VCZH_PRESENTATION_RESOURCES_GUIRESOURCE


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		class GuiResourceItem;
		class GuiResourceFolder;
		class GuiResource;

/***********************************************************************
Helper Functions
***********************************************************************/

		extern WString								GetFolderPath(const WString& filePath);
		extern WString								GetFileName(const WString& filePath);
		extern bool									LoadTextFile(const WString& filePath, WString& text);
		extern bool									LoadTextFromStream(stream::IStream& stream, WString& text);
		extern bool									IsResourceUrl(const WString& text, WString& protocol, WString& path);

		extern void									HexToBinary(stream::IStream& stream, const WString& hexText);
		extern WString								BinaryToHex(stream::IStream& stream);

/***********************************************************************
Global String Key
***********************************************************************/

		struct GlobalStringKey
		{
		public:
			static GlobalStringKey					Empty;
			static GlobalStringKey					_Set;
			static GlobalStringKey					_Ref;
			static GlobalStringKey					_Bind;
			static GlobalStringKey					_Format;
			static GlobalStringKey					_Eval;
			static GlobalStringKey					_Uri;
			static GlobalStringKey					_Workflow_Assembly_Cache;
			static GlobalStringKey					_Workflow_Global_Context;
			static GlobalStringKey					_ControlTemplate;
			static GlobalStringKey					_ItemTemplate;

		private:
			vint									key = -1;

		public:
			static vint Compare(GlobalStringKey a, GlobalStringKey b){ return a.key - b.key; }
			bool operator==(GlobalStringKey g)const{ return key == g.key; }
			bool operator!=(GlobalStringKey g)const{ return key != g.key; }
			bool operator<(GlobalStringKey g)const{ return key < g.key; }
			bool operator<=(GlobalStringKey g)const{ return key <= g.key; }
			bool operator>(GlobalStringKey g)const{ return key > g.key; }
			bool operator>=(GlobalStringKey g)const{ return key >= g.key; }

			static GlobalStringKey					Get(const WString& string);
			vint									ToKey()const;
			WString									ToString()const;
		};

/***********************************************************************
Resource Image
***********************************************************************/
			
		class GuiImageData : public Object, public Description<GuiImageData>
		{
		protected:
			Ptr<INativeImage>				image;
			vint							frameIndex;
			WString							filePath;

		public:
			GuiImageData();
			GuiImageData(Ptr<INativeImage> _image, vint _frameIndex, const WString& _filePath = L"");
			~GuiImageData();

			Ptr<INativeImage>				GetImage();
			vint							GetFrameIndex();
			const WString&					GetFilePath();
		};

/***********************************************************************
Resource String
***********************************************************************/

		class GuiTextData : public Object, public Description<GuiTextData>
		{
		protected:
			WString							text;

		public:
			GuiTextData();
			GuiTextData(const WString& _text);
			
			WString							GetText();
		};

/***********************************************************************
Resource Structure
***********************************************************************/

		class GuiResourceNodeBase : public Object, public Description<GuiResourceNodeBase>
		{
			friend class GuiResourceFolder;
		protected:
			GuiResourceFolder*						parent;
			WString									name;
			WString									path;
			
		public:
			GuiResourceNodeBase();
			~GuiResourceNodeBase();

			GuiResourceFolder*						GetParent();
			const WString&							GetName();
			const WString&							GetPath();
			void									SetPath(const WString& value);
		};

		class DocumentModel;
		class GuiResourcePathResolver;
		
		class GuiResourceItem : public GuiResourceNodeBase, public Description<GuiResourceItem>
		{
			friend class GuiResourceFolder;
		protected:
			Ptr<DescriptableObject>					content;
			WString									typeName;
			
		public:
			GuiResourceItem();
			~GuiResourceItem();

			const WString&							GetTypeName();
			
			Ptr<DescriptableObject>					GetContent();
			void									SetContent(const WString& _typeName, Ptr<DescriptableObject> value);

			Ptr<GuiImageData>						AsImage();
			Ptr<parsing::xml::XmlDocument>			AsXml();
			Ptr<GuiTextData>						AsString();
			Ptr<DocumentModel>						AsDocument();
		};
		
		class GuiResourceFolder : public GuiResourceNodeBase, public Description<GuiResourceFolder>
		{
		protected:
			typedef collections::Dictionary<WString, Ptr<GuiResourceItem>>		ItemMap;
			typedef collections::Dictionary<WString, Ptr<GuiResourceFolder>>	FolderMap;
			typedef collections::List<Ptr<GuiResourceItem>>						ItemList;
			typedef collections::List<Ptr<GuiResourceFolder>>					FolderList;

			struct DelayLoading
			{
				WString								type;
				WString								workingDirectory;
				Ptr<GuiResourceItem>				preloadResource;
			};

			typedef collections::List<DelayLoading>								DelayLoadingList;

			ItemMap									items;
			FolderMap								folders;

			void									LoadResourceFolderFromXml(DelayLoadingList& delayLoadings, const WString& containingFolder, Ptr<parsing::xml::XmlElement> folderXml, collections::List<WString>& errors);
			void									SaveResourceFolderToXml(Ptr<parsing::xml::XmlElement> xmlParent, bool serializePrecompiledResource);
			void									CollectTypeNames(collections::List<WString>& typeNames);
			void									LoadResourceFolderFromBinary(DelayLoadingList& delayLoadings, stream::internal::Reader& reader, collections::List<WString>& typeNames, collections::List<WString>& errors);
			void									SaveResourceFolderToBinary(stream::internal::Writer& writer, collections::List<WString>& typeNames);
			void									PrecompileResourceFolder(Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors);
		public:
			GuiResourceFolder();
			~GuiResourceFolder();

			const ItemList&							GetItems();
			Ptr<GuiResourceItem>					GetItem(const WString& name);
			bool									AddItem(const WString& name, Ptr<GuiResourceItem> item);
			Ptr<GuiResourceItem>					RemoveItem(const WString& name);
			void									ClearItems();
			
			const FolderList&						GetFolders();
			Ptr<GuiResourceFolder>					GetFolder(const WString& name);
			bool									AddFolder(const WString& name, Ptr<GuiResourceFolder> folder);
			Ptr<GuiResourceFolder>					RemoveFolder(const WString& name);
			void									ClearFolders();

			Ptr<DescriptableObject>					GetValueByPath(const WString& path);
			Ptr<GuiResourceFolder>					GetFolderByPath(const WString& path);
		};

/***********************************************************************
Resource
***********************************************************************/
		
		class GuiResource : public GuiResourceFolder, public Description<GuiResource>
		{
		protected:
			WString									workingDirectory;

			static void								ProcessDelayLoading(Ptr<GuiResource> resource, DelayLoadingList& delayLoadings, collections::List<WString>& errors);
		public:
			GuiResource();
			~GuiResource();

			WString									GetWorkingDirectory();

			static Ptr<GuiResource>					LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, const WString& workingDirectory, collections::List<WString>& errors);

			static Ptr<GuiResource>					LoadFromXml(const WString& filePath, collections::List<WString>& errors);

			Ptr<parsing::xml::XmlDocument>			SaveToXml(bool serializePrecompiledResource);
			
			static Ptr<GuiResource>					LoadPrecompiledBinary(stream::IStream& stream, collections::List<WString>& errors);
			
			void									SavePrecompiledBinary(stream::IStream& stream);

			void									Precompile(collections::List<WString>& errors);
			
			Ptr<DocumentModel>						GetDocumentByPath(const WString& path);
			Ptr<GuiImageData>						GetImageByPath(const WString& path);
			Ptr<parsing::xml::XmlDocument>			GetXmlByPath(const WString& path);
			WString									GetStringByPath(const WString& path);
		};

/***********************************************************************
Resource Path Resolver
***********************************************************************/

		class IGuiResourcePathResolver : public IDescriptable, public Description<IGuiResourcePathResolver>
		{
		public:
			virtual Ptr<DescriptableObject>					ResolveResource(const WString& path)=0;
		};

		class IGuiResourcePathResolverFactory : public IDescriptable, public Description<IGuiResourcePathResolverFactory>
		{
		public:
			virtual WString									GetProtocol()=0;

			virtual Ptr<IGuiResourcePathResolver>			CreateResolver(Ptr<GuiResource> resource, const WString& workingDirectory)=0;
		};
		
		class GuiResourcePathResolver : public Object, public Description<GuiResourcePathResolver>
		{
			typedef collections::Dictionary<WString, Ptr<IGuiResourcePathResolver>>		ResolverMap;
		protected:
			ResolverMap										resolvers;
			Ptr<GuiResource>								resource;
			WString											workingDirectory;

		public:
			GuiResourcePathResolver(Ptr<GuiResource> _resource, const WString& _workingDirectory);
			~GuiResourcePathResolver();

			Ptr<DescriptableObject>							ResolveResource(const WString& protocol, const WString& path);
		};

/***********************************************************************
Resource Type Resolver
***********************************************************************/

		class IGuiResourceTypeResolver_DirectLoadXml;
		class IGuiResourceTypeResolver_DirectLoadStream;
		class IGuiResourceTypeResolver_IndirectLoad;

		class IGuiResourceTypeResolver : public virtual IDescriptable, public Description<IGuiResourceTypeResolver>
		{
		public:
			virtual WString										GetType() = 0;
			
			virtual void										Precompile(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors) = 0;
			
			virtual IGuiResourceTypeResolver_DirectLoadXml*		DirectLoadXml(){ return 0; }
			virtual IGuiResourceTypeResolver_DirectLoadStream*	DirectLoadStream(){ return 0; }
			virtual IGuiResourceTypeResolver_IndirectLoad*		IndirectLoad(){ return 0; }
		};

		class IGuiResourceTypeResolver_DirectLoadXml : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_DirectLoadXml>
		{
		public:
			virtual Ptr<parsing::xml::XmlElement>				Serialize(Ptr<DescriptableObject> resource, bool serializePrecompiledResource) = 0;

			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<parsing::xml::XmlElement> element, collections::List<WString>& errors) = 0;

			virtual Ptr<DescriptableObject>						ResolveResource(const WString& path, collections::List<WString>& errors) = 0;
		};

		class IGuiResourceTypeResolver_DirectLoadStream : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_DirectLoadStream>
		{
		public:
			virtual void										SerializePrecompiled(Ptr<DescriptableObject> resource, stream::IStream& stream) = 0;

			virtual Ptr<DescriptableObject>						ResolveResourcePrecompiled(stream::IStream& stream, collections::List<WString>& errors) = 0;
		};

		class IGuiResourceTypeResolver_IndirectLoad : public virtual IDescriptable, public Description<IGuiResourceTypeResolver_IndirectLoad>
		{
		public:
			virtual WString										GetPreloadType() = 0;
			virtual bool										IsDelayLoad() = 0;

			virtual Ptr<DescriptableObject>						Serialize(Ptr<DescriptableObject> resource, bool serializePrecompiledResource) = 0;

			virtual Ptr<DescriptableObject>						ResolveResource(Ptr<DescriptableObject> resource, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors) = 0;
		};

/***********************************************************************
Resource Resolver Manager
***********************************************************************/

		class IGuiResourceResolverManager : public IDescriptable, public Description<IGuiResourceResolverManager>
		{
		public:
			virtual IGuiResourcePathResolverFactory*			GetPathResolverFactory(const WString& protocol)=0;
			virtual bool										SetPathResolverFactory(Ptr<IGuiResourcePathResolverFactory> factory)=0;
			virtual IGuiResourceTypeResolver*					GetTypeResolver(const WString& type)=0;
			virtual bool										SetTypeResolver(Ptr<IGuiResourceTypeResolver> resolver)=0;
		};
		
		extern IGuiResourceResolverManager*						GetResourceResolverManager();
	}
}

#endif

/***********************************************************************
RESOURCES\GUIDOCUMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIDOCUMENT
#define VCZH_PRESENTATION_RESOURCES_GUIDOCUMENT


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		class DocumentTextRun;
		class DocumentStylePropertiesRun;
		class DocumentStyleApplicationRun;
		class DocumentHyperlinkRun;
		class DocumentImageRun;
		class DocumentParagraphRun;

/***********************************************************************
Rich Content Document (style)
***********************************************************************/

		class DocumentStyleProperties : public Object, public Description<DocumentStyleProperties>
		{
		public:
			Nullable<WString>				face;
			Nullable<vint>					size;
			Nullable<Color>					color;
			Nullable<Color>					backgroundColor;
			Nullable<bool>					bold;
			Nullable<bool>					italic;
			Nullable<bool>					underline;
			Nullable<bool>					strikeline;
			Nullable<bool>					antialias;
			Nullable<bool>					verticalAntialias;
		};

/***********************************************************************
Rich Content Document (run)
***********************************************************************/

		class DocumentRun : public Object, public Description<DocumentRun>
		{
		public:
			class IVisitor : public Interface
			{
			public:
				virtual void				Visit(DocumentTextRun* run)=0;
				virtual void				Visit(DocumentStylePropertiesRun* run)=0;
				virtual void				Visit(DocumentStyleApplicationRun* run)=0;
				virtual void				Visit(DocumentHyperlinkRun* run)=0;
				virtual void				Visit(DocumentImageRun* run)=0;
				virtual void				Visit(DocumentParagraphRun* run)=0;
			};

			DocumentRun(){}

			virtual void					Accept(IVisitor* visitor)=0;
		};
		
		class DocumentContainerRun : public DocumentRun, public Description<DocumentContainerRun>
		{
			typedef collections::List<Ptr<DocumentRun>>			RunList;
		public:
			RunList							runs;
		};
		
		class DocumentContentRun : public DocumentRun, public Description<DocumentContentRun>
		{
		public:
			virtual WString					GetRepresentationText()=0;
		};

		//-------------------------------------------------------------------------

		class DocumentTextRun : public DocumentContentRun, public Description<DocumentTextRun>
		{
		public:
			WString							text;

			DocumentTextRun(){}

			WString							GetRepresentationText()override{return text;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		class DocumentInlineObjectRun : public DocumentContentRun, public Description<DocumentInlineObjectRun>
		{
		public:
			Size							size;
			vint							baseline;

			DocumentInlineObjectRun():baseline(-1){}
		};
				
		class DocumentImageRun : public DocumentInlineObjectRun, public Description<DocumentImageRun>
		{
		public:
			static const wchar_t*			RepresentationText;

			Ptr<INativeImage>				image;
			vint							frameIndex;
			WString							source;

			DocumentImageRun():frameIndex(0){}
			
			WString							GetRepresentationText()override{return RepresentationText;}
			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};

		//-------------------------------------------------------------------------
				
		class DocumentStylePropertiesRun : public DocumentContainerRun, public Description<DocumentStylePropertiesRun>
		{
		public:
			Ptr<DocumentStyleProperties>	style;

			DocumentStylePropertiesRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		class DocumentStyleApplicationRun : public DocumentContainerRun, public Description<DocumentStyleApplicationRun>
		{
		public:
			WString							styleName;

			DocumentStyleApplicationRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
		
		class DocumentHyperlinkRun : public DocumentStyleApplicationRun, public Description<DocumentHyperlinkRun>
		{
		public:
			WString							normalStyleName;
			WString							activeStyleName;
			WString							reference;

			DocumentHyperlinkRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}
		};
				
		class DocumentParagraphRun : public DocumentContainerRun, public Description<DocumentParagraphRun>
		{
		public:
			Nullable<Alignment>				alignment;

			DocumentParagraphRun(){}

			void							Accept(IVisitor* visitor)override{visitor->Visit(this);}

			WString							GetText(bool skipNonTextContent);
			void							GetText(stream::TextWriter& writer, bool skipNonTextContent);
		};

/***********************************************************************
Rich Content Document (model)
***********************************************************************/

		class DocumentStyle : public Object, public Description<DocumentStyle>
		{
		public:
			WString							parentStyleName;

			Ptr<DocumentStyleProperties>	styles;

			Ptr<DocumentStyleProperties>	resolvedStyles;
		};

		class DocumentModel : public Object, public Description<DocumentModel>
		{
		public:
			static const wchar_t*			DefaultStyleName;
			static const wchar_t*			SelectionStyleName;
			static const wchar_t*			ContextStyleName;
			static const wchar_t*			NormalLinkStyleName;
			static const wchar_t*			ActiveLinkStyleName;
		public:
			struct ResolvedStyle
			{
				FontProperties				style;
				Color						color;
				Color						backgroundColor;

				ResolvedStyle()
				{
				}

				ResolvedStyle(const FontProperties& _style, Color _color, Color _backgroundColor)
					:style(_style)
					,color(_color)
					,backgroundColor(_backgroundColor)
				{
				}
			};

			struct RunRange
			{
				vint			start;
				vint			end;
			};

			typedef collections::Dictionary<DocumentRun*, RunRange>						RunRangeMap;
		private:
			typedef collections::List<Ptr<DocumentParagraphRun>>						ParagraphList;
			typedef collections::Dictionary<WString, Ptr<DocumentStyle>>				StyleMap;
		public:
			ParagraphList					paragraphs;
			StyleMap						styles;
			
			DocumentModel();

			static void						MergeStyle(Ptr<DocumentStyleProperties> style, Ptr<DocumentStyleProperties> parent);
			void							MergeBaselineStyle(Ptr<DocumentModel> baselineDocument, const WString& styleName);
			void							MergeBaselineStyles(Ptr<DocumentModel> baselineDocument);
			ResolvedStyle					GetStyle(Ptr<DocumentStyleProperties> sp, const ResolvedStyle& context);
			ResolvedStyle					GetStyle(const WString& styleName, const ResolvedStyle& context);

			WString							GetText(bool skipNonTextContent);
			void							GetText(stream::TextWriter& writer, bool skipNonTextContent);
			
			bool							CheckEditRange(TextPos begin, TextPos end, RunRangeMap& relatedRanges);
			Ptr<DocumentModel>				CopyDocument(TextPos begin, TextPos end, bool deepCopy);
			bool							CutParagraph(TextPos position);
			bool							CutEditRange(TextPos begin, TextPos end);
			bool							EditContainer(TextPos begin, TextPos end, const Func<void(DocumentParagraphRun*, RunRangeMap&, vint, vint)>& editor);
			
			vint							EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> model);
			vint							EditRun(TextPos begin, TextPos end, const collections::Array<Ptr<DocumentParagraphRun>>& runs);
			vint							EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
			bool							EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
			Ptr<DocumentImageRun>			EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
			bool							EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=NormalLinkStyleName, const WString& activeStyleName=ActiveLinkStyleName);
			bool							RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
			Ptr<DocumentHyperlinkRun>		GetHyperlink(vint paragraphIndex, vint begin, vint end);
			bool							EditStyleName(TextPos begin, TextPos end, const WString& styleName);
			bool							RemoveStyleName(TextPos begin, TextPos end);
			bool							RenameStyle(const WString& oldStyleName, const WString& newStyleName);
			bool							ClearStyle(TextPos begin, TextPos end);
			Ptr<DocumentStyleProperties>	SummarizeStyle(TextPos begin, TextPos end);

			static Ptr<DocumentModel>		LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, Ptr<GuiResourcePathResolver> resolver, collections::List<WString>& errors);

			static Ptr<DocumentModel>		LoadFromXml(Ptr<parsing::xml::XmlDocument> xml, const WString& workingDirectory, collections::List<WString>& errors);

			static Ptr<DocumentModel>		LoadFromXml(const WString& filePath, collections::List<WString>& errors);

			Ptr<parsing::xml::XmlDocument>	SaveToXml();
			
			bool							SaveToXml(const WString& filePath);
		};
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System and Infrastructure Interfaces

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Elements
***********************************************************************/
			
			enum class ElementShape
			{
				Rectangle,
				Ellipse,
			};

			class GuiSolidBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBorderElement, L"SolidBorder")
			protected:
				Color					color;
				ElementShape			shape;

				GuiSolidBorderElement();
			public:
				~GuiSolidBorderElement();

				Color					GetColor();
				void					SetColor(Color value);
				ElementShape			GetShape();
				void					SetShape(ElementShape value);
			};
			
			class GuiRoundBorderElement : public Object, public IGuiGraphicsElement, public Description<GuiRoundBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiRoundBorderElement, L"RoundBorder")
			protected:
				Color					color;
				vint					radius;

				GuiRoundBorderElement();
			public:
				~GuiRoundBorderElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				
				vint					GetRadius();
				void					SetRadius(vint value);
			};
			
			class Gui3DBorderElement : public Object, public IGuiGraphicsElement, public Description<Gui3DBorderElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DBorderElement, L"3DBorder")
			protected:
				Color					color1;
				Color					color2;

				Gui3DBorderElement();
			public:
				~Gui3DBorderElement();
				
				Color					GetColor1();
				void					SetColor1(Color value);
				Color					GetColor2();
				void					SetColor2(Color value);
				void					SetColors(Color value1, Color value2);
			};
			
			class Gui3DSplitterElement : public Object, public IGuiGraphicsElement, public Description<Gui3DSplitterElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(Gui3DSplitterElement, L"3DSplitter")
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Color					color1;
				Color					color2;
				Direction				direction;

				Gui3DSplitterElement();
			public:
				~Gui3DSplitterElement();
				
				Color					GetColor1();
				void					SetColor1(Color value);
				Color					GetColor2();
				void					SetColor2(Color value);
				void					SetColors(Color value1, Color value2);
				
				Direction				GetDirection();
				void					SetDirection(Direction value);
			};

			class GuiSolidBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidBackgroundElement, L"SolidBackground")
			protected:
				Color					color;
				ElementShape			shape;

				GuiSolidBackgroundElement();
			public:
				~GuiSolidBackgroundElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				ElementShape			GetShape();
				void					SetShape(ElementShape value);
			};
			
			class GuiGradientBackgroundElement : public Object, public IGuiGraphicsElement, public Description<GuiGradientBackgroundElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiGradientBackgroundElement, L"GradientBackground")
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
					Slash,
					Backslash,
				};
			protected:
				Color					color1, color2;
				Direction				direction;
				ElementShape			shape;

				GuiGradientBackgroundElement();
			public:
				~GuiGradientBackgroundElement();
				
				Color					GetColor1();
				void					SetColor1(Color value);
				Color					GetColor2();
				void					SetColor2(Color value);
				void					SetColors(Color value1, Color value2);
				
				Direction				GetDirection();
				void					SetDirection(Direction value);
				ElementShape			GetShape();
				void					SetShape(ElementShape value);
			};
			
			class GuiSolidLabelElement : public Object, public IGuiGraphicsElement, public Description<GuiSolidLabelElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiSolidLabelElement, L"SolidLabel");
			protected:
				Color					color;
				FontProperties			fontProperties;
				WString					text;
				Alignment				hAlignment;
				Alignment				vAlignment;
				bool					wrapLine;
				bool					ellipse;
				bool					multiline;
				bool					wrapLineHeightCalculation;

				GuiSolidLabelElement();
			public:
				~GuiSolidLabelElement();
				
				Color					GetColor();
				void					SetColor(Color value);
				
				const FontProperties&	GetFont();
				void					SetFont(const FontProperties& value);
				
				const WString&			GetText();
				void					SetText(const WString& value);
				
				Alignment				GetHorizontalAlignment();
				Alignment				GetVerticalAlignment();
				void					SetHorizontalAlignment(Alignment value);
				void					SetVerticalAlignment(Alignment value);
				void					SetAlignments(Alignment horizontal, Alignment vertical);
				
				bool					GetWrapLine();
				void					SetWrapLine(bool value);
				
				bool					GetEllipse();
				void					SetEllipse(bool value);
				
				bool					GetMultiline();
				void					SetMultiline(bool value);

				bool					GetWrapLineHeightCalculation();
				void					SetWrapLineHeightCalculation(bool value);
			};

			class GuiImageFrameElement : public Object, public IGuiGraphicsElement, public Description<GuiImageFrameElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiImageFrameElement, L"ImageFrame");
			protected:
				Ptr<INativeImage>		image;
				vint					frameIndex;
				Alignment				hAlignment;
				Alignment				vAlignment;
				bool					stretch;
				bool					enabled;

				GuiImageFrameElement();
			public:
				~GuiImageFrameElement();

				Ptr<INativeImage>		GetImage();
				vint					GetFrameIndex();
				void					SetImage(Ptr<INativeImage> value);
				void					SetFrameIndex(vint value);
				void					SetImage(Ptr<INativeImage> _image, vint _frameIndex);
				
				Alignment				GetHorizontalAlignment();
				Alignment				GetVerticalAlignment();
				void					SetHorizontalAlignment(Alignment value);
				void					SetVerticalAlignment(Alignment value);
				void					SetAlignments(Alignment horizontal, Alignment vertical);

				bool					GetStretch();
				void					SetStretch(bool value);

				bool					GetEnabled();
				void					SetEnabled(bool value);
			};

			class GuiPolygonElement : public Object, public IGuiGraphicsElement, public Description<GuiPolygonElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiPolygonElement, L"Polygon");

				typedef collections::Array<Point>			PointArray;
			protected:
				Size							size;
				PointArray						points;
				Color							borderColor;
				Color							backgroundColor;

				GuiPolygonElement();
			public:
				~GuiPolygonElement();

				Size					GetSize();
				void					SetSize(Size value);

				const Point&			GetPoint(vint index);
				vint					GetPointCount();
				void					SetPoints(const Point* p, vint count);


				const PointArray&		GetPointsArray();
				void					SetPointsArray(const PointArray& value);
				
				Color					GetBorderColor();
				void					SetBorderColor(Color value);
				Color					GetBackgroundColor();
				void					SetBackgroundColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSTEXTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTEXTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Colorized Plain Text (model)
***********************************************************************/

			namespace text
			{
				struct CharAtt
				{
					vuint32_t						rightOffset;
					vuint32_t						colorIndex;
				};
				
				struct TextLine
				{
					static const vint				BlockSize=32;
					static const vint				MaxWidth=0xFFFF;
					
					wchar_t*						text;
					CharAtt*						att;
					vint								availableOffsetCount;
					vint								bufferLength;
					vint								dataLength;
					vint								lexerFinalState;
					vint								contextFinalState;

					TextLine();
					~TextLine();

					static vint						CalculateBufferLength(vint dataLength);
					bool							operator==(const TextLine& value)const{return false;}
					bool							operator!=(const TextLine& value)const{return true;}

					void							Initialize();
					void							Finalize();
					bool							IsReady();
					bool							Modify(vint start, vint count, const wchar_t* input, vint inputCount);
					TextLine						Split(vint index);
					void							AppendAndFinalize(TextLine& line);
				};

				class CharMeasurer : public virtual IDescriptable
				{
				protected:
					IGuiGraphicsRenderTarget*		oldRenderTarget;
					vint								rowHeight;
					vint								widths[65536];
					
					virtual vint						MeasureWidthInternal(wchar_t character, IGuiGraphicsRenderTarget* renderTarget)=0;
					virtual vint						GetRowHeightInternal(IGuiGraphicsRenderTarget* renderTarget)=0;
				public:

					CharMeasurer(vint _rowHeight);
					~CharMeasurer();

					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					vint								MeasureWidth(wchar_t character);
					vint								GetRowHeight();
				};

				class TextLines : public Object, public Description<TextLines>
				{
					typedef collections::List<TextLine>		TextLineList;
				protected:
					TextLineList					lines;
					CharMeasurer*					charMeasurer;
					IGuiGraphicsRenderTarget*		renderTarget;
					vint							tabWidth;
					vint							tabSpaceCount;
					wchar_t							passwordChar;
				public:
					TextLines();
					~TextLines();

					vint							GetCount();
					TextLine&						GetLine(vint row);
					CharMeasurer*					GetCharMeasurer();
					void							SetCharMeasurer(CharMeasurer* value);
					IGuiGraphicsRenderTarget*		GetRenderTarget();
					void							SetRenderTarget(IGuiGraphicsRenderTarget* value);
					WString							GetText(TextPos start, TextPos end);
					WString							GetText();
					void							SetText(const WString& value);
					
					bool							RemoveLines(vint start, vint count);
					bool							IsAvailable(TextPos pos);
					TextPos							Normalize(TextPos pos);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t** inputs, vint* inputCounts, vint rows);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input, vint inputCount);
					TextPos							Modify(TextPos start, TextPos end, const wchar_t* input);
					TextPos							Modify(TextPos start, TextPos end, const WString& input);
					void							Clear();
					
					void							ClearMeasurement();
					vint							GetTabSpaceCount();
					void							SetTabSpaceCount(vint value);
					void							MeasureRow(vint row);
					vint							GetRowWidth(vint row);
					vint							GetRowHeight();
					vint							GetMaxWidth();
					vint							GetMaxHeight();
					TextPos							GetTextPosFromPoint(Point point);
					Point							GetPointFromTextPos(TextPos pos);
					Rect							GetRectFromTextPos(TextPos pos);
					wchar_t							GetPasswordChar();
					void							SetPasswordChar(wchar_t value);
				};
				
				struct ColorItem
				{
					Color							text;
					Color							background;
				};
				
				struct ColorEntry
				{
					ColorItem						normal;
					ColorItem						selectedFocused;
					ColorItem						selectedUnfocused;

					bool							operator==(const ColorEntry& value){return false;}
					bool							operator!=(const ColorEntry& value){return true;}
				};
			}

/***********************************************************************
Colorized Plain Text (element)
***********************************************************************/
			
			class GuiColorizedTextElement : public Object, public IGuiGraphicsElement, public Description<GuiColorizedTextElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiColorizedTextElement, L"ColorizedText");

				typedef collections::Array<text::ColorEntry>			ColorArray;
			public:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual void					ColorChanged()=0;
					virtual void					FontChanged()=0;
				};
			protected:
				ICallback*							callback;
				ColorArray							colors;
				FontProperties						font;
				Point								viewPosition;
				bool								isVisuallyEnabled;
				bool								isFocused;

				TextPos								caretBegin;
				TextPos								caretEnd;
				bool								caretVisible;
				Color								caretColor;

				text::TextLines						lines;

				GuiColorizedTextElement();
			public:
				~GuiColorizedTextElement();

				text::TextLines&					GetLines();
				ICallback*							GetCallback();
				void								SetCallback(ICallback* value);
				
				const ColorArray&					GetColors();
				void								SetColors(const ColorArray& value);
				const FontProperties&				GetFont();
				void								SetFont(const FontProperties& value);
				wchar_t								GetPasswordChar();
				void								SetPasswordChar(wchar_t value);
				Point								GetViewPosition();
				void								SetViewPosition(Point value);
				bool								GetVisuallyEnabled();
				void								SetVisuallyEnabled(bool value);
				bool								GetFocused();
				void								SetFocused(bool value);
				
				TextPos								GetCaretBegin();
				void								SetCaretBegin(TextPos value);
				TextPos								GetCaretEnd();
				void								SetCaretEnd(TextPos value);
				bool								GetCaretVisible();
				void								SetCaretVisible(bool value);
				Color								GetCaretColor();
				void								SetCaretColor(Color value);
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSDOCUMENTELEMENT.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Element System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTELEMENT
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSDOCUMENTELEMENT


namespace vl
{
	namespace presentation
	{
		namespace elements
		{

/***********************************************************************
Rich Content Document (element)
***********************************************************************/

			class GuiDocumentElement : public Object, public IGuiGraphicsElement, public Description<GuiDocumentElement>
			{
				DEFINE_GUI_GRAPHICS_ELEMENT(GuiDocumentElement, L"RichDocument");
			public:
				class GuiDocumentElementRenderer : public Object, public IGuiGraphicsRenderer
				{
					DEFINE_GUI_GRAPHICS_RENDERER(GuiDocumentElement, GuiDocumentElementRenderer, IGuiGraphicsRenderTarget)
				protected:
					struct ParagraphCache
					{
						WString								fullText;
						Ptr<IGuiGraphicsParagraph>			graphicsParagraph;
						vint								selectionBegin;
						vint								selectionEnd;

						ParagraphCache()
							:selectionBegin(-1)
							,selectionEnd(-1)
						{
						}
					};

					typedef collections::Array<Ptr<ParagraphCache>>		ParagraphCacheArray;
					typedef collections::Array<vint>					ParagraphHeightArray;
				protected:
					vint									paragraphDistance;
					vint									lastMaxWidth;
					vint									cachedTotalHeight;
					IGuiGraphicsLayoutProvider*				layoutProvider;
					ParagraphCacheArray						paragraphCaches;
					ParagraphHeightArray					paragraphHeights;

					TextPos									lastCaret;
					Color									lastCaretColor;
					bool									lastCaretFrontSide;

					void									InitializeInternal();
					void									FinalizeInternal();
					void									RenderTargetChangedInternal(IGuiGraphicsRenderTarget* oldRenderTarget, IGuiGraphicsRenderTarget* newRenderTarget);
					Ptr<ParagraphCache>						EnsureAndGetCache(vint paragraphIndex, bool createParagraph);
					bool									GetParagraphIndexFromPoint(Point point, vint& top, vint& index);
				public:
					GuiDocumentElementRenderer();

					void									Render(Rect bounds)override;
					void									OnElementStateChanged()override;
					void									NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
					Ptr<DocumentHyperlinkRun>				GetHyperlinkFromPoint(Point point);

					void									OpenCaret(TextPos caret, Color color, bool frontSide);
					void									CloseCaret(TextPos caret);
					void									SetSelection(TextPos begin, TextPos end);
					TextPos									CalculateCaret(TextPos comparingCaret, IGuiGraphicsParagraph::CaretRelativePosition position, bool& preferFrontSide);
					TextPos									CalculateCaretFromPoint(Point point);
					Rect									GetCaretBounds(TextPos caret, bool frontSide);
				};

			protected:
				Ptr<DocumentModel>							document;
				TextPos										caretBegin;
				TextPos										caretEnd;
				bool										caretVisible;
				bool										caretFrontSide;
				Color										caretColor;

				void										UpdateCaret();

				GuiDocumentElement();
			public:
				~GuiDocumentElement();
				
				Ptr<DocumentModel>							GetDocument();
				void										SetDocument(Ptr<DocumentModel> value);
				TextPos										GetCaretBegin();
				TextPos										GetCaretEnd();
				bool										IsCaretEndPreferFrontSide();
				void										SetCaret(TextPos begin, TextPos end, bool frontSide);
				bool										GetCaretVisible();
				void										SetCaretVisible(bool value);
				Color										GetCaretColor();
				void										SetCaretColor(Color value);

				TextPos										CalculateCaret(TextPos comparingCaret, IGuiGraphicsParagraph::CaretRelativePosition position, bool& preferFrontSide);
				TextPos										CalculateCaretFromPoint(Point point);
				Rect										GetCaretBounds(TextPos caret, bool frontSide);

				void										NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
				void										EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> model);
				void										EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
				void										EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
				void										EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
				void										EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=DocumentModel::NormalLinkStyleName, const WString& activeStyleName=DocumentModel::ActiveLinkStyleName);
				void										RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
				void										EditStyleName(TextPos begin, TextPos end, const WString& styleName);
				void										RemoveStyleName(TextPos begin, TextPos end);
				void										RenameStyle(const WString& oldStyleName, const WString& newStyleName);
				void										ClearStyle(TextPos begin, TextPos end);
				Ptr<DocumentStyleProperties>				SummarizeStyle(TextPos begin, TextPos end);
				void										SetParagraphAlignment(TextPos begin, TextPos end, const collections::Array<Nullable<Alignment>>& alignments);

				Ptr<DocumentHyperlinkRun>					GetHyperlinkFromPoint(Point point);
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSCOMPOSITION\GUIGRAPHICSEVENTRECEIVER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Event Model

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSEVENTRECEIVER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace tree
			{
				class INodeProvider;
			}
		}
	}
}

namespace vl
{
	namespace presentation
	{
		using namespace reflection;

		namespace compositions
		{
			class GuiGraphicsComposition;

/***********************************************************************
Event
***********************************************************************/

			template<typename T>
			class GuiGraphicsEvent : public Object, public Description<GuiGraphicsEvent<T>>
			{
			public:
				typedef void(RawFunctionType)(GuiGraphicsComposition*, T&);
				typedef Func<RawFunctionType>						FunctionType;
				typedef T											ArgumentType;

				class IHandler : public virtual IDescriptable, public Description<IHandler>
				{
				public:
					virtual void			Execute(GuiGraphicsComposition* sender, T& argument)=0;
				};

				class HandlerContainer
				{
				public:
					Ptr<IHandler>			handler;
				};
				
				class FunctionHandler : public Object, public IHandler
				{
				protected:
					FunctionType			handler;
				public:
					FunctionHandler(const FunctionType& _handler)
						:handler(_handler)
					{
					}

					void Execute(GuiGraphicsComposition* sender, T& argument)override
					{
						handler(sender, argument);
					}
				};
			protected:
				struct HandlerNode
				{
					Ptr<IHandler>										handler;
					Ptr<HandlerNode>									next;
				};

				GuiGraphicsComposition*									sender;
				Ptr<HandlerNode>										handlers;
			public:
				GuiGraphicsEvent(GuiGraphicsComposition* _sender=0)
					:sender(_sender)
				{
				}

				~GuiGraphicsEvent()
				{
				}

				GuiGraphicsComposition* GetAssociatedComposition()
				{
					return sender;
				}

				void SetAssociatedComposition(GuiGraphicsComposition* _sender)
				{
					sender=_sender;
				}

				bool Attach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							return false;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					(*currentHandler)=new HandlerNode;
					(*currentHandler)->handler=handler;
					return true;
				}

				template<typename TClass, typename TMethod>
				Ptr<IHandler> AttachMethod(TClass* receiver, TMethod TClass::* method)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(receiver, method));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(RawFunctionType* function)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(function));
					Attach(handler);
					return handler;
				}

				Ptr<IHandler> AttachFunction(const FunctionType& function)
				{
					Ptr<IHandler> handler=new FunctionHandler(function);
					Attach(handler);
					return handler;
				}

				template<typename TLambda>
				Ptr<IHandler> AttachLambda(const TLambda& lambda)
				{
					Ptr<IHandler> handler=new FunctionHandler(FunctionType(lambda));
					Attach(handler);
					return handler;
				}

				bool Detach(Ptr<IHandler> handler)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						if((*currentHandler)->handler==handler)
						{
							Ptr<HandlerNode> next=(*currentHandler)->next;
							(*currentHandler)=next;
							return true;
						}
						else
						{
							currentHandler=&(*currentHandler)->next;
						}
					}
					return false;
				}

				void ExecuteWithNewSender(T& argument, GuiGraphicsComposition* newSender)
				{
					Ptr<HandlerNode>* currentHandler=&handlers;
					while(*currentHandler)
					{
						(*currentHandler)->handler->Execute(newSender?newSender:sender, argument);
						currentHandler=&(*currentHandler)->next;
					}
				}

				void Execute(T& argument)
				{
					ExecuteWithNewSender(argument, 0);
				}

				void Execute(const T& argument)
				{
					auto t = argument;
					ExecuteWithNewSender(t, 0);
				}
			};

			template<typename T>
			Ptr<typename GuiGraphicsEvent<T>::HandlerContainer> CreateEventHandlerContainer()
			{
				return new typename GuiGraphicsEvent<T>::HandlerContainer;
			}

/***********************************************************************
Predefined Events
***********************************************************************/

			struct GuiEventArgs : public Object, public Description<GuiEventArgs>
			{
				GuiGraphicsComposition*		compositionSource;
				GuiGraphicsComposition*		eventSource;
				bool						handled;

				GuiEventArgs()
					:compositionSource(0)
					,eventSource(0)
					,handled(false)
				{
				}

				GuiEventArgs(GuiGraphicsComposition* composition)
					:compositionSource(composition)
					,eventSource(composition)
					,handled(false)
				{
				}
			};
			
			struct GuiRequestEventArgs : public GuiEventArgs, public Description<GuiRequestEventArgs>
			{
				bool		cancel;
				
				GuiRequestEventArgs()
					:cancel(false)
				{
				}
				
				GuiRequestEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,cancel(false)
				{
				}
			};
			
			struct GuiKeyEventArgs : public GuiEventArgs, public NativeWindowKeyInfo, public Description<GuiKeyEventArgs>
			{
				GuiKeyEventArgs()
				{
				}
				
				GuiKeyEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			struct GuiCharEventArgs : public GuiEventArgs, public NativeWindowCharInfo, public Description<GuiCharEventArgs>
			{
				GuiCharEventArgs()
				{
				}
				
				GuiCharEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};
			
			struct GuiMouseEventArgs : public GuiEventArgs, public NativeWindowMouseInfo, public Description<GuiMouseEventArgs>
			{
				GuiMouseEventArgs()
				{
				}
				
				GuiMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiEventArgs>				GuiNotifyEvent;
			typedef GuiGraphicsEvent<GuiRequestEventArgs>		GuiRequestEvent;
			typedef GuiGraphicsEvent<GuiKeyEventArgs>			GuiKeyEvent;
			typedef GuiGraphicsEvent<GuiCharEventArgs>			GuiCharEvent;
			typedef GuiGraphicsEvent<GuiMouseEventArgs>			GuiMouseEvent;

/***********************************************************************
Predefined Item Events
***********************************************************************/
			
			struct GuiItemEventArgs : public GuiEventArgs, public Description<GuiItemEventArgs>
			{
				vint			itemIndex;

				GuiItemEventArgs()
					:itemIndex(-1)
				{
				}
				
				GuiItemEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};
			
			struct GuiItemMouseEventArgs : public GuiMouseEventArgs, public Description<GuiItemMouseEventArgs>
			{
				vint			itemIndex;

				GuiItemMouseEventArgs()
					:itemIndex(-1)
				{
				}
				
				GuiItemMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,itemIndex(-1)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiItemEventArgs>			GuiItemNotifyEvent;
			typedef GuiGraphicsEvent<GuiItemMouseEventArgs>		GuiItemMouseEvent;

/***********************************************************************
Predefined Node Events
***********************************************************************/
			
			struct GuiNodeEventArgs : public GuiEventArgs, public Description<GuiNodeEventArgs>
			{
				controls::tree::INodeProvider*		node;

				GuiNodeEventArgs()
					:node(0)
				{
				}
				
				GuiNodeEventArgs(GuiGraphicsComposition* composition)
					:GuiEventArgs(composition)
					,node(0)
				{
				}
			};
			
			struct GuiNodeMouseEventArgs : public GuiMouseEventArgs, public Description<GuiNodeMouseEventArgs>
			{
				controls::tree::INodeProvider*		node;

				GuiNodeMouseEventArgs()
					:node(0)
				{
				}
				
				GuiNodeMouseEventArgs(GuiGraphicsComposition* composition)
					:GuiMouseEventArgs(composition)
					,node(0)
				{
				}
			};

			typedef GuiGraphicsEvent<GuiNodeEventArgs>			GuiNodeNotifyEvent;
			typedef GuiGraphicsEvent<GuiNodeMouseEventArgs>		GuiNodeMouseEvent;

/***********************************************************************
Event Receiver
***********************************************************************/

			class GuiGraphicsEventReceiver : public Object
			{
			protected:
				GuiGraphicsComposition*			sender;
			public:
				GuiGraphicsEventReceiver(GuiGraphicsComposition* _sender);
				~GuiGraphicsEventReceiver();

				GuiGraphicsComposition*			GetAssociatedComposition();

				GuiMouseEvent					leftButtonDown;
				GuiMouseEvent					leftButtonUp;
				GuiMouseEvent					leftButtonDoubleClick;
				GuiMouseEvent					middleButtonDown;
				GuiMouseEvent					middleButtonUp;
				GuiMouseEvent					middleButtonDoubleClick;
				GuiMouseEvent					rightButtonDown;
				GuiMouseEvent					rightButtonUp;
				GuiMouseEvent					rightButtonDoubleClick;
				GuiMouseEvent					horizontalWheel;
				GuiMouseEvent					verticalWheel;
				GuiMouseEvent					mouseMove;
				GuiNotifyEvent					mouseEnter;
				GuiNotifyEvent					mouseLeave;
				
				GuiKeyEvent						previewKey;
				GuiKeyEvent						keyDown;
				GuiKeyEvent						keyUp;
				GuiKeyEvent						systemKeyDown;
				GuiKeyEvent						systemKeyUp;
				GuiCharEvent					previewCharInput;
				GuiCharEvent					charInput;
				GuiNotifyEvent					gotFocus;
				GuiNotifyEvent					lostFocus;
				GuiNotifyEvent					caretNotify;
				GuiNotifyEvent					clipboardNotify;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSCOMPOSITION\GUIGRAPHICSCOMPOSITIONBASE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITIONBASE
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITIONBASE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiControl;
			class GuiControlHost;
		}

		namespace compositions
		{
			class GuiGraphicsHost;

/***********************************************************************
Basic Construction
***********************************************************************/

			class GuiGraphicsComposition : public Object, public Description<GuiGraphicsComposition>
			{
				typedef collections::List<GuiGraphicsComposition*> CompositionList;

				friend class controls::GuiControl;
				friend class GuiGraphicsHost;
			public:
				enum MinSizeLimitation
				{
					NoLimit,
					LimitToElement,
					LimitToElementAndChildren,
				};
			protected:
				CompositionList								children;
				GuiGraphicsComposition*						parent;
				Ptr<elements::IGuiGraphicsElement>			ownedElement;
				bool										visible;
				elements::IGuiGraphicsRenderTarget*			renderTarget;
				MinSizeLimitation							minSizeLimitation;

				Ptr<compositions::GuiGraphicsEventReceiver>	eventReceiver;
				controls::GuiControl*						associatedControl;
				GuiGraphicsHost*							associatedHost;
				INativeCursor*								associatedCursor;
				INativeWindowListener::HitTestResult		associatedHitTestResult;

				Margin										margin;
				Margin										internalMargin;
				Size										preferredMinSize;

				virtual void								OnControlParentChanged(controls::GuiControl* control);
				virtual void								OnChildInserted(GuiGraphicsComposition* child);
				virtual void								OnChildRemoved(GuiGraphicsComposition* child);
				virtual void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent);
				virtual void								OnParentLineChanged();
				virtual void								OnRenderTargetChanged();
				
				virtual void								SetAssociatedControl(controls::GuiControl* control);
				virtual void								SetAssociatedHost(GuiGraphicsHost* host);

				static bool									SharedPtrDestructorProc(DescriptableObject* obj, bool forceDisposing);
			public:
				GuiGraphicsComposition();
				~GuiGraphicsComposition();

				GuiGraphicsComposition*						GetParent();
				const CompositionList&						Children();
				bool										AddChild(GuiGraphicsComposition* child);
				bool										InsertChild(vint index, GuiGraphicsComposition* child);
				bool										RemoveChild(GuiGraphicsComposition* child);
				bool										MoveChild(GuiGraphicsComposition* child, vint newIndex);

				Ptr<elements::IGuiGraphicsElement>			GetOwnedElement();
				void										SetOwnedElement(Ptr<elements::IGuiGraphicsElement> element);
				bool										GetVisible();
				void										SetVisible(bool value);
				MinSizeLimitation							GetMinSizeLimitation();
				void										SetMinSizeLimitation(MinSizeLimitation value);
				elements::IGuiGraphicsRenderTarget*			GetRenderTarget();
				void										SetRenderTarget(elements::IGuiGraphicsRenderTarget* value);

				void										Render(Size offset);
				compositions::GuiGraphicsEventReceiver*		GetEventReceiver();
				bool										HasEventReceiver();
				GuiGraphicsComposition*						FindComposition(Point location);
				Rect										GetGlobalBounds();

				controls::GuiControl*						GetAssociatedControl();
				GuiGraphicsHost*							GetAssociatedHost();
				INativeCursor*								GetAssociatedCursor();
				void										SetAssociatedCursor(INativeCursor* cursor);
				INativeWindowListener::HitTestResult		GetAssociatedHitTestResult();
				void										SetAssociatedHitTestResult(INativeWindowListener::HitTestResult value);
				
				controls::GuiControl*						GetRelatedControl();
				GuiGraphicsHost*							GetRelatedGraphicsHost();
				controls::GuiControlHost*					GetRelatedControlHost();
				INativeCursor*								GetRelatedCursor();
				
				virtual Margin								GetMargin();
				virtual void								SetMargin(Margin value);
				virtual Margin								GetInternalMargin();
				virtual void								SetInternalMargin(Margin value);
				virtual Size								GetPreferredMinSize();
				virtual void								SetPreferredMinSize(Size value);
				virtual Rect								GetClientArea();
				virtual void								ForceCalculateSizeImmediately();
				
				virtual bool								IsSizeAffectParent()=0;
				virtual Size								GetMinPreferredClientSize()=0;
				virtual Rect								GetPreferredBounds()=0;
				virtual Rect								GetBounds()=0;
			};

			class GuiGraphicsSite : public GuiGraphicsComposition, public Description<GuiGraphicsSite>
			{
			protected:
				Rect								previousBounds;

				virtual Rect						GetBoundsInternal(Rect expectedBounds);

				void								UpdatePreviousBounds(Rect bounds);
			public:
				GuiGraphicsSite();
				~GuiGraphicsSite();

				compositions::GuiNotifyEvent		BoundsChanged;
				
				bool								IsSizeAffectParent()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetPreferredBounds()override;
			};

/***********************************************************************
Helper Functions
***********************************************************************/

			extern void								SafeDeleteControl(controls::GuiControl* value);

			extern void								SafeDeleteComposition(GuiGraphicsComposition* value);
		}
	}
}

#endif

/***********************************************************************
GRAPHICSCOMPOSITION\GUIGRAPHICSBASICCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSBASICCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSBASICCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Basic Compositions
***********************************************************************/
			
			class GuiWindowComposition : public GuiGraphicsSite, public Description<GuiWindowComposition>
			{
			protected:
				INativeWindow*						attachedWindow;
			public:
				GuiWindowComposition();
				~GuiWindowComposition();
				
				INativeWindow*						GetAttachedWindow();
				void								SetAttachedWindow(INativeWindow* window);

				Rect								GetBounds()override;
				void								SetMargin(Margin value)override;
			};

			class GuiBoundsComposition : public GuiGraphicsSite, public Description<GuiBoundsComposition>
			{
			protected:
				Rect								compositionBounds;
				Margin								alignmentToParent;
				
			public:
				GuiBoundsComposition();
				~GuiBoundsComposition();
				
				Rect								GetPreferredBounds()override;
				Rect								GetBounds()override;
				void								SetBounds(Rect value);

				void								ClearAlignmentToParent();
				Margin								GetAlignmentToParent();
				void								SetAlignmentToParent(Margin value);
				bool								IsAlignedToParent();
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSCOMPOSITION\GUIGRAPHICSTABLECOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTABLECOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSTABLECOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Table Compositions
***********************************************************************/

			class GuiTableComposition;
			class GuiCellComposition;

			struct GuiCellOption
			{
				enum ComposeType
				{
					Absolute,
					Percentage,
					MinSize,
				};

				ComposeType		composeType;
				vint			absolute;
				double			percentage;

				GuiCellOption()
					:composeType(Absolute)
					,absolute(20)
					,percentage(0)
				{
				}

				bool operator==(const GuiCellOption& value){return false;}
				bool operator!=(const GuiCellOption& value){return true;}

				static GuiCellOption AbsoluteOption(vint value)
				{
					GuiCellOption option;
					option.composeType=Absolute;
					option.absolute=value;
					return option;
				}
				
				static GuiCellOption PercentageOption(double value)
				{
					GuiCellOption option;
					option.composeType=Percentage;
					option.percentage=value;
					return option;
				}
				
				static GuiCellOption MinSizeOption()
				{
					GuiCellOption option;
					option.composeType=MinSize;
					return option;
				}
			};

			class GuiTableComposition : public GuiBoundsComposition, public Description<GuiTableComposition>
			{
				friend class GuiCellComposition;
			protected:
				vint										rows;
				vint										columns;
				vint										cellPadding;
				vint										rowExtending;
				vint										columnExtending;
				collections::Array<GuiCellOption>			rowOptions;
				collections::Array<GuiCellOption>			columnOptions;
				collections::Array<GuiCellComposition*>		cellCompositions;
				collections::Array<Rect>					cellBounds;
				Rect										previousBounds;
				Size										previousContentMinSize;
				Size										tableContentMinSize;

				vint								GetSiteIndex(vint _rows, vint _columns, vint _row, vint _column);
				void								SetSitedCell(vint _row, vint _column, GuiCellComposition* cell);

				void								UpdateCellBoundsInternal(
														collections::Array<vint>& dimSizes,
														vint& dimSize, 
														vint& dimSizeWithPercentage,
														collections::Array<GuiCellOption>& dimOptions,
														vint GuiTableComposition::* dim1,
														vint GuiTableComposition::* dim2,
														vint (*getSize)(Size),
														vint (*getLocation)(GuiCellComposition*),
														vint (*getSpan)(GuiCellComposition*),
														vint (*getRow)(vint, vint),
														vint (*getCol)(vint, vint),
														vint maxPass
														);
				void								UpdateCellBoundsPercentages(
														collections::Array<vint>& dimSizes,
														vint dimSize,
														vint maxDimSize,
														collections::Array<GuiCellOption>& dimOptions
														);
				vint									UpdateCellBoundsOffsets(
														collections::Array<vint>& offsets,
														collections::Array<vint>& sizes,
														vint start,
														vint max
														);
				
				void								UpdateCellBoundsInternal();
				void								UpdateTableContentMinSize();
				void								OnRenderTargetChanged()override;
			public:
				GuiTableComposition();
				~GuiTableComposition();

				vint								GetRows();
				vint								GetColumns();
				bool								SetRowsAndColumns(vint _rows, vint _columns);
				GuiCellComposition*					GetSitedCell(vint _row, vint _column);

				GuiCellOption						GetRowOption(vint _row);
				void								SetRowOption(vint _row, GuiCellOption option);
				GuiCellOption						GetColumnOption(vint _column);
				void								SetColumnOption(vint _column, GuiCellOption option);

				vint								GetCellPadding();
				void								SetCellPadding(vint value);
				Rect								GetCellArea();
				void								UpdateCellBounds();
				
				void								ForceCalculateSizeImmediately()override;
				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
			};

			class GuiCellComposition : public GuiGraphicsSite, public Description<GuiCellComposition>
			{
				friend class GuiTableComposition;
			protected:
				vint								row;
				vint								rowSpan;
				vint								column;
				vint								columnSpan;
				GuiTableComposition*				tableParent;
				Size								lastPreferredSize;
				
				void								ClearSitedCells(GuiTableComposition* table);
				void								SetSitedCells(GuiTableComposition* table);
				void								ResetSiteInternal();
				bool								SetSiteInternal(vint _row, vint _column, vint _rowSpan, vint _columnSpan);
				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				void								OnTableRowsAndColumnsChanged();
			public:
				GuiCellComposition();
				~GuiCellComposition();

				GuiTableComposition*				GetTableParent();

				vint								GetRow();
				vint								GetRowSpan();
				vint								GetColumn();
				vint								GetColumnSpan();
				bool								SetSite(vint _row, vint _column, vint _rowSpan, vint _columnSpan);

				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSCOMPOSITION\GUIGRAPHICSSTACKCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSTACKCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSTACKCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Stack Compositions
***********************************************************************/

			class GuiStackComposition;
			class GuiStackItemComposition;

			class GuiStackComposition : public GuiBoundsComposition, public Description<GuiStackComposition>
			{
				friend class GuiStackItemComposition;

				typedef collections::List<GuiStackItemComposition*>				ItemCompositionList;
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction							direction;
				ItemCompositionList					stackItems;
				collections::Array<Rect>			stackItemBounds;
				Size								stackItemTotalSize;
				vint								padding;
				Rect								previousBounds;
				Margin								extraMargin;
				GuiStackItemComposition*			ensuringVisibleStackItem;

				void								UpdateStackItemBounds();
				void								FixStackItemSizes();
				void								OnBoundsChanged(GuiGraphicsComposition* sender, GuiEventArgs& arguments);
				void								OnChildInserted(GuiGraphicsComposition* child)override;
				void								OnChildRemoved(GuiGraphicsComposition* child)override;
			public:
				GuiStackComposition();
				~GuiStackComposition();

				const ItemCompositionList&			GetStackItems();
				bool								InsertStackItem(vint index, GuiStackItemComposition* item);
				
				Direction							GetDirection();
				void								SetDirection(Direction value);
				vint								GetPadding();
				void								SetPadding(vint value);

				Size								GetMinPreferredClientSize()override;
				Rect								GetBounds()override;
				
				Margin								GetExtraMargin();
				void								SetExtraMargin(Margin value);
				bool								IsStackItemClipped();
				bool								EnsureVisible(vint index);
			};
			
			class GuiStackItemComposition : public GuiGraphicsSite, public Description<GuiStackItemComposition>
			{
				friend class GuiStackComposition;
			protected:
				GuiStackComposition*				stackParent;
				Rect								bounds;
				Margin								extraMargin;

				void								OnParentChanged(GuiGraphicsComposition* oldParent, GuiGraphicsComposition* newParent)override;
				Size								GetMinSize();
			public:
				GuiStackItemComposition();
				~GuiStackItemComposition();
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
				void								SetBounds(Rect value);
				
				Margin								GetExtraMargin();
				void								SetExtraMargin(Margin value);
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSCOMPOSITION\GUIGRAPHICSSPECIALIZEDCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSPECIALIZEDCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSSPECIALIZEDCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{

/***********************************************************************
Specialized Compositions
***********************************************************************/

			class GuiSideAlignedComposition : public GuiGraphicsSite, public Description<GuiSideAlignedComposition>
			{
			public:
				enum Direction
				{
					Left,
					Top,
					Right,
					Bottom,
				};
			protected:
				Direction							direction;
				vint								maxLength;
				double								maxRatio;
			public:
				GuiSideAlignedComposition();
				~GuiSideAlignedComposition();
				
				Direction							GetDirection();
				void								SetDirection(Direction value);
				vint								GetMaxLength();
				void								SetMaxLength(vint value);
				double								GetMaxRatio();
				void								SetMaxRatio(double value);
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};

			class GuiPartialViewComposition : public GuiGraphicsSite, public Description<GuiPartialViewComposition>
			{
			protected:
				double								wRatio;
				double								wPageSize;
				double								hRatio;
				double								hPageSize;

			public:
				GuiPartialViewComposition();
				~GuiPartialViewComposition();
				
				double								GetWidthRatio();
				double								GetWidthPageSize();
				double								GetHeightRatio();
				double								GetHeightPageSize();
				void								SetWidthRatio(double value);
				void								SetWidthPageSize(double value);
				void								SetHeightRatio(double value);
				void								SetHeightPageSize(double value);
				
				bool								IsSizeAffectParent()override;
				Rect								GetBounds()override;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSCOMPOSITION\GUIGRAPHICSCOMPOSITION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Composition System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSCOMPOSITION


namespace vl
{
	namespace presentation
	{
		namespace compositions
		{
			class GuiSharedSizeItemComposition;
			class GuiSharedSizeRootComposition;

			class GuiSharedSizeItemComposition : public GuiBoundsComposition, public Description<GuiSharedSizeItemComposition>
			{
			protected:
				GuiSharedSizeRootComposition*						parentRoot;
				WString												group;
				bool												sharedWidth;
				bool												sharedHeight;

				void												Update();
				void												OnParentLineChanged()override;
			public:
				GuiSharedSizeItemComposition();
				~GuiSharedSizeItemComposition();
				
				const WString&										GetGroup();
				void												SetGroup(const WString& value);
				bool												GetSharedWidth();
				void												SetSharedWidth(bool value);
				bool												GetSharedHeight();
				void												SetSharedHeight(bool value);
			};

			class GuiSharedSizeRootComposition :public GuiBoundsComposition, public Description<GuiSharedSizeRootComposition>
			{
				friend class GuiSharedSizeItemComposition;
			protected:
				collections::List<GuiSharedSizeItemComposition*>	childItems;

			public:
				GuiSharedSizeRootComposition();
				~GuiSharedSizeRootComposition();

				void												ForceCalculateSizeImmediately()override;
			};
		}
	}
}

#endif

/***********************************************************************
GRAPHICSELEMENT\GUIGRAPHICSHOST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Graphics Composition Host

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST
#define VCZH_PRESENTATION_ELEMENTS_GUIGRAPHICSHOST


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiWindow;
		}

		namespace compositions
		{

/***********************************************************************
Animation
***********************************************************************/

			class IGuiGraphicsAnimation : public virtual IDescriptable, public Description<IGuiGraphicsAnimation>
			{
			public:
				virtual vint					GetTotalLength()=0;
				virtual vint					GetCurrentPosition()=0;
				virtual void					Play(vint currentPosition, vint totalLength)=0;
				virtual void					Stop()=0;
			};

			class GuiGraphicsAnimationManager : public Object, public Description<GuiGraphicsAnimationManager>
			{
				typedef collections::List<Ptr<IGuiGraphicsAnimation>>		AnimationList;
			protected:
				AnimationList					playingAnimations;
			public:
				GuiGraphicsAnimationManager();
				~GuiGraphicsAnimationManager();

				void							AddAnimation(Ptr<IGuiGraphicsAnimation> animation);
				bool							HasAnimation();
				void							Play();
			};

/***********************************************************************
Shortcut Key Manager
***********************************************************************/

			class IGuiShortcutKeyManager;

			class IGuiShortcutKeyItem : public virtual IDescriptable, public Description<IGuiShortcutKeyItem>
			{
			public:
				GuiNotifyEvent							Executed;

				virtual IGuiShortcutKeyManager*			GetManager()=0;
				virtual WString							GetName()=0;
			};
			
			class IGuiShortcutKeyManager : public virtual IDescriptable, public Description<IGuiShortcutKeyManager>
			{
			public:
				virtual vint							GetItemCount()=0;
				virtual IGuiShortcutKeyItem*			GetItem(vint index)=0;
				virtual bool							Execute(const NativeWindowKeyInfo& info)=0;
			};

/***********************************************************************
Alt-Combined Shortcut Key Interfaces
***********************************************************************/

			class IGuiAltActionHost;
			
			class IGuiAltAction : public virtual IDescriptable
			{
			public:
				static const wchar_t* const				Identifier;

				static bool								IsLegalAlt(const WString& alt);

				virtual const WString&					GetAlt() = 0;
				virtual bool							IsAltEnabled() = 0;
				virtual bool							IsAltAvailable() = 0;
				virtual GuiGraphicsComposition*			GetAltComposition() = 0;
				virtual IGuiAltActionHost*				GetActivatingAltHost() = 0;
				virtual void							OnActiveAlt() = 0;
			};
			
			class IGuiAltActionContainer : public virtual IDescriptable
			{
			public:
				static const wchar_t* const				Identifier;

				virtual vint							GetAltActionCount() = 0;
				virtual IGuiAltAction*					GetAltAction(vint index) = 0;
			};
			
			class IGuiAltActionHost : public virtual IDescriptable
			{
			public:
				static const wchar_t* const				Identifier;

				static void								CollectAltActionsFromControl(controls::GuiControl* control, collections::Group<WString, IGuiAltAction*>& actions);
				
				virtual GuiGraphicsComposition*			GetAltComposition() = 0;
				virtual IGuiAltActionHost*				GetPreviousAltHost() = 0;
				virtual void							OnActivatedAltHost(IGuiAltActionHost* previousHost) = 0;
				virtual void							OnDeactivatedAltHost() = 0;
				virtual void							CollectAltActions(collections::Group<WString, IGuiAltAction*>& actions) = 0;
			};

/***********************************************************************
Host
***********************************************************************/

			class GuiGraphicsHost : public Object, private INativeWindowListener, private INativeControllerListener, public Description<GuiGraphicsHost>
			{
				typedef collections::List<GuiGraphicsComposition*>							CompositionList;
				typedef collections::Dictionary<WString, IGuiAltAction*>					AltActionMap;
				typedef collections::Dictionary<WString, controls::GuiControl*>				AltControlMap;
			public:
				static const vuint64_t					CaretInterval=500;
			protected:
				INativeWindow*							nativeWindow;
				IGuiShortcutKeyManager*					shortcutKeyManager;
				GuiWindowComposition*					windowComposition;
				GuiGraphicsComposition*					focusedComposition;
				Size									previousClientSize;
				Size									minSize;
				Point									caretPoint;
				vuint64_t								lastCaretTime;

				GuiGraphicsAnimationManager				animationManager;
				GuiGraphicsComposition*					mouseCaptureComposition;
				CompositionList							mouseEnterCompositions;

				IGuiAltActionHost*						currentAltHost;
				AltActionMap							currentActiveAltActions;
				AltControlMap							currentActiveAltTitles;
				WString									currentAltPrefix;
				vint									supressAltKey;

				void									EnterAltHost(IGuiAltActionHost* host);
				void									LeaveAltHost();
				bool									EnterAltKey(wchar_t key);
				void									LeaveAltKey();
				void									CreateAltTitles(const collections::Group<WString, IGuiAltAction*>& actions);
				vint									FilterTitles();
				void									ClearAltHost();
				void									CloseAltHost();

				void									DisconnectCompositionInternal(GuiGraphicsComposition* composition);
				void									MouseCapture(const NativeWindowMouseInfo& info);
				void									MouseUncapture(const NativeWindowMouseInfo& info);
				void									OnCharInput(const NativeWindowCharInfo& info, GuiGraphicsComposition* composition, GuiCharEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnKeyInput(const NativeWindowKeyInfo& info, GuiGraphicsComposition* composition, GuiKeyEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									RaiseMouseEvent(GuiMouseEventArgs& arguments, GuiGraphicsComposition* composition, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				void									OnMouseInput(const NativeWindowMouseInfo& info, GuiMouseEvent GuiGraphicsEventReceiver::* eventReceiverEvent);
				
			private:
				INativeWindowListener::HitTestResult	HitTest(Point location)override;
				void									Moving(Rect& bounds, bool fixSizeOnly)override;
				void									Moved()override;

				void									LeftButtonDown(const NativeWindowMouseInfo& info)override;
				void									LeftButtonUp(const NativeWindowMouseInfo& info)override;
				void									LeftButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									RightButtonDown(const NativeWindowMouseInfo& info)override;
				void									RightButtonUp(const NativeWindowMouseInfo& info)override;
				void									RightButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDown(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonUp(const NativeWindowMouseInfo& info)override;
				void									MiddleButtonDoubleClick(const NativeWindowMouseInfo& info)override;
				void									HorizontalWheel(const NativeWindowMouseInfo& info)override;
				void									VerticalWheel(const NativeWindowMouseInfo& info)override;
				void									MouseMoving(const NativeWindowMouseInfo& info)override;
				void									MouseEntered()override;
				void									MouseLeaved()override;

				void									KeyDown(const NativeWindowKeyInfo& info)override;
				void									KeyUp(const NativeWindowKeyInfo& info)override;
				void									SysKeyDown(const NativeWindowKeyInfo& info)override;
				void									SysKeyUp(const NativeWindowKeyInfo& info)override;
				void									Char(const NativeWindowCharInfo& info)override;

				void									GlobalTimer()override;
			public:
				GuiGraphicsHost();
				~GuiGraphicsHost();

				INativeWindow*							GetNativeWindow();
				void									SetNativeWindow(INativeWindow* _nativeWindow);
				GuiGraphicsComposition*					GetMainComposition();
				void									Render();

				IGuiShortcutKeyManager*					GetShortcutKeyManager();
				void									SetShortcutKeyManager(IGuiShortcutKeyManager* value);

				bool									SetFocus(GuiGraphicsComposition* composition);
				GuiGraphicsComposition*					GetFocusedComposition();
				Point									GetCaretPoint();
				void									SetCaretPoint(Point value, GuiGraphicsComposition* referenceComposition=0);

				GuiGraphicsAnimationManager*			GetAnimationManager();
				void									DisconnectComposition(GuiGraphicsComposition* composition);
			};

/***********************************************************************
Animation Helpers
***********************************************************************/
			
			class GuiTimeBasedAnimation : public IGuiGraphicsAnimation, public Description<GuiTimeBasedAnimation>
			{
			protected:
				vuint64_t						startTime;
				vint							length;
			public:
				GuiTimeBasedAnimation(vint totalMilliseconds);
				~GuiTimeBasedAnimation();

				void							Restart(vint totalMilliseconds=-1);
				vint							GetTotalLength()override;
				vint							GetCurrentPosition()override;
			};

/***********************************************************************
Shortcut Key Manager Helpers
***********************************************************************/

			class GuiShortcutKeyManager;

			class GuiShortcutKeyItem : public Object, public IGuiShortcutKeyItem
			{
			protected:
				GuiShortcutKeyManager*			shortcutKeyManager;
				bool							ctrl;
				bool							shift;
				bool							alt;
				vint							key;

				void							AttachManager(GuiShortcutKeyManager* manager);
				void							DetachManager(GuiShortcutKeyManager* manager);
			public:
				GuiShortcutKeyItem(GuiShortcutKeyManager* _shortcutKeyManager, bool _ctrl, bool _shift, bool _alt, vint _key);
				~GuiShortcutKeyItem();

				IGuiShortcutKeyManager*			GetManager()override;
				WString							GetName()override;
				bool							CanActivate(const NativeWindowKeyInfo& info);
				bool							CanActivate(bool _ctrl, bool _shift, bool _alt, vint _key);
			};

			class GuiShortcutKeyManager : public Object, public IGuiShortcutKeyManager, public Description<GuiShortcutKeyManager>
			{
				typedef collections::List<Ptr<GuiShortcutKeyItem>>		ShortcutKeyItemList;
			protected:
				ShortcutKeyItemList				shortcutKeyItems;

			public:
				GuiShortcutKeyManager();
				~GuiShortcutKeyManager();

				vint							GetItemCount()override;
				IGuiShortcutKeyItem*			GetItem(vint index)override;
				bool							Execute(const NativeWindowKeyInfo& info)override;

				IGuiShortcutKeyItem*			CreateShortcut(bool ctrl, bool shift, bool alt, vint key);
				bool							DestroyShortcut(bool ctrl, bool shift, bool alt, vint key);
				IGuiShortcutKeyItem*			TryGetShortcut(bool ctrl, bool shift, bool alt, vint key);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUIBASICCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBASICCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Basic Construction
***********************************************************************/

			class GuiControl : public Object, protected compositions::IGuiAltAction, public Description<GuiControl>
			{
				friend class compositions::GuiGraphicsComposition;
				typedef collections::List<GuiControl*>		ControlList;
			public:
				class IStyleController : public virtual IDescriptable, public Description<IStyleController>
				{
				public:
					virtual compositions::GuiBoundsComposition*		GetBoundsComposition()=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void									SetText(const WString& value)=0;
					virtual void									SetFont(const FontProperties& value)=0;
					virtual void									SetVisuallyEnabled(bool value)=0;
				};

				class EmptyStyleController : public Object, public virtual IStyleController, public Description<EmptyStyleController>
				{
				protected:
					compositions::GuiBoundsComposition*				boundsComposition;
				public:
					EmptyStyleController();
					~EmptyStyleController();

					compositions::GuiBoundsComposition*				GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*			GetContainerComposition()override;
					void											SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void											SetText(const WString& value)override;
					void											SetFont(const FontProperties& value)override;
					void											SetVisuallyEnabled(bool value)override;
				};

				class IStyleProvider : public virtual IDescriptable, public Description<IStyleProvider>
				{
				public:
					virtual void								AssociateStyleController(IStyleController* controller)=0;
					virtual void								SetFocusableComposition(compositions::GuiGraphicsComposition* value)=0;
					virtual void								SetText(const WString& value)=0;
					virtual void								SetFont(const FontProperties& value)=0;
					virtual void								SetVisuallyEnabled(bool value)=0;
				};
			protected:
				Ptr<IStyleController>							styleController;
				compositions::GuiBoundsComposition*				boundsComposition;
				compositions::GuiGraphicsComposition*			focusableComposition;
				compositions::GuiGraphicsEventReceiver*			eventReceiver;

				bool									isEnabled;
				bool									isVisuallyEnabled;
				bool									isVisible;
				WString									alt;
				WString									text;
				FontProperties							font;
				compositions::IGuiAltActionHost*		activatingAltHost;

				GuiControl*								parent;
				ControlList								children;
				description::Value						tag;
				GuiControl*								tooltipControl;
				vint									tooltipWidth;

				virtual void							OnChildInserted(GuiControl* control);
				virtual void							OnChildRemoved(GuiControl* control);
				virtual void							OnParentChanged(GuiControl* oldParent, GuiControl* newParent);
				virtual void							OnParentLineChanged();
				virtual void							OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget);
				virtual void							OnBeforeReleaseGraphicsHost();
				virtual void							UpdateVisuallyEnabled();
				void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

				bool									IsAltEnabled()override;
				bool									IsAltAvailable()override;
				compositions::GuiGraphicsComposition*	GetAltComposition()override;
				compositions::IGuiAltActionHost*		GetActivatingAltHost()override;
				void									OnActiveAlt()override;

				static bool								SharedPtrDestructorProc(DescriptableObject* obj, bool forceDisposing);

			public:
				GuiControl(IStyleController* _styleController);
				~GuiControl();

				compositions::GuiNotifyEvent			VisibleChanged;
				compositions::GuiNotifyEvent			EnabledChanged;
				compositions::GuiNotifyEvent			VisuallyEnabledChanged;
				compositions::GuiNotifyEvent			AltChanged;
				compositions::GuiNotifyEvent			TextChanged;
				compositions::GuiNotifyEvent			FontChanged;

				compositions::GuiEventArgs				GetNotifyEventArguments();
				IStyleController*						GetStyleController();
				compositions::GuiBoundsComposition*		GetBoundsComposition();
				compositions::GuiGraphicsComposition*	GetContainerComposition();
				compositions::GuiGraphicsComposition*	GetFocusableComposition();
				compositions::GuiGraphicsEventReceiver*	GetEventReceiver();
				GuiControl*								GetParent();
				vint									GetChildrenCount();
				GuiControl*								GetChild(vint index);
				bool									AddChild(GuiControl* control);
				bool									HasChild(GuiControl* control);
				
				virtual GuiControlHost*					GetRelatedControlHost();
				virtual bool							GetVisuallyEnabled();
				virtual bool							GetEnabled();
				virtual void							SetEnabled(bool value);
				virtual bool							GetVisible();
				virtual void							SetVisible(bool value);
				virtual const WString&					GetAlt();
				virtual bool							SetAlt(const WString& value);
				void									SetActivatingAltHost(compositions::IGuiAltActionHost* host);
				virtual const WString&					GetText();
				virtual void							SetText(const WString& value);
				virtual const FontProperties&			GetFont();
				virtual void							SetFont(const FontProperties& value);
				virtual void							SetFocus();

				description::Value						GetTag();
				void									SetTag(const description::Value& value);
				GuiControl*								GetTooltipControl();
				GuiControl*								SetTooltipControl(GuiControl* value);
				vint									GetTooltipWidth();
				void									SetTooltipWidth(vint value);
				bool									DisplayTooltip(Point location);
				void									CloseTooltip();

				virtual IDescriptable*					QueryService(const WString& identifier);

				template<typename T>
				T* QueryTypedService()
				{
					return dynamic_cast<T*>(QueryService(T::Identifier));
				}
			};

			class GuiInstanceRootObject;

			class GuiComponent : public Object, public Description<GuiComponent>
			{
			public:
				GuiComponent();
				~GuiComponent();

				virtual void							Attach(GuiInstanceRootObject* rootObject);
				virtual void							Detach(GuiInstanceRootObject* rootObject);
			};
			
			class GuiInstanceRootObject abstract : public Description<GuiInstanceRootObject>
			{
				typedef collections::List<Ptr<description::IValueSubscription>>		SubscriptionList;
			protected:
				collections::SortedList<GuiComponent*>			components;
				SubscriptionList								subscriptions;

				void											ClearSubscriptions();
				void											ClearComponents();
				void											FinalizeInstance();
			public:
				GuiInstanceRootObject();
				~GuiInstanceRootObject();

				Ptr<description::IValueSubscription>			AddSubscription(Ptr<description::IValueSubscription> subscription);
				bool											RemoveSubscription(Ptr<description::IValueSubscription> subscription);
				bool											ContainsSubscription(Ptr<description::IValueSubscription> subscription);

				bool											AddComponent(GuiComponent* component);
				bool											RemoveComponent(GuiComponent* component);
				bool											ContainsComponent(GuiComponent* component);
			};

			class GuiCustomControl : public GuiControl, public GuiInstanceRootObject, public Description<GuiCustomControl>
			{
			public:
				GuiCustomControl(IStyleController* _styleController);
				~GuiCustomControl();
			};

			template<typename T>
			class GuiObjectComponent : public GuiComponent
			{
			public:
				Ptr<T>				object;

				GuiObjectComponent()
				{
				}

				GuiObjectComponent(Ptr<T> _object)
					:object(_object)
				{
				}
			};

/***********************************************************************
Label
***********************************************************************/

			class GuiLabel : public GuiControl, public Description<GuiLabel>
			{
			public:
				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual Color						GetDefaultTextColor()=0;
					virtual void						SetTextColor(Color value)=0;
				};
			protected:
				Color									textColor;
				IStyleController*						styleController;
			public:
				GuiLabel(IStyleController* _styleController);
				~GuiLabel();
				
				Color									GetTextColor();
				void									SetTextColor(Color value);
			};

/***********************************************************************
Buttons
***********************************************************************/

			class GuiButton : public GuiControl, public Description<GuiButton>
			{
			public:
				enum ControlState
				{
					Normal,
					Active,
					Pressed,
				};

				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						Transfer(ControlState value)=0;
				};
			protected:
				IStyleController*						styleController;
				bool									clickOnMouseUp;
				bool									mousePressing;
				bool									mouseHoving;
				ControlState							controlState;
				
				void									OnParentLineChanged()override;
				void									OnActiveAlt()override;
				void									UpdateControlState();
				void									OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiButton(IStyleController* _styleController);
				~GuiButton();

				compositions::GuiNotifyEvent			Clicked;

				bool									GetClickOnMouseUp();
				void									SetClickOnMouseUp(bool value);
			};

			class GuiSelectableButton : public GuiButton, public Description<GuiSelectableButton>
			{
			public:
				class IStyleController : public virtual GuiButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetSelected(bool value)=0;
				};

				class GroupController : public GuiComponent, public Description<GroupController>
				{
				protected:
					collections::List<GuiSelectableButton*>	buttons;
				public:
					GroupController();
					~GroupController();

					virtual void						Attach(GuiSelectableButton* button);
					virtual void						Detach(GuiSelectableButton* button);
					virtual void						OnSelectedChanged(GuiSelectableButton* button)=0;
				};

				class MutexGroupController : public GroupController, public Description<MutexGroupController>
				{
				protected:
					bool								suppress;
				public:
					MutexGroupController();
					~MutexGroupController();

					void								OnSelectedChanged(GuiSelectableButton* button)override;
				};

			protected:
				IStyleController*						styleController;
				GroupController*						groupController;
				bool									autoSelection;
				bool									isSelected;

				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiSelectableButton(IStyleController* _styleController);
				~GuiSelectableButton();

				compositions::GuiNotifyEvent			GroupControllerChanged;
				compositions::GuiNotifyEvent			AutoSelectionChanged;
				compositions::GuiNotifyEvent			SelectedChanged;

				virtual GroupController*				GetGroupController();
				virtual void							SetGroupController(GroupController* value);
				
				virtual bool							GetAutoSelection();
				virtual void							SetAutoSelection(bool value);
				
				virtual bool							GetSelected();
				virtual void							SetSelected(bool value);
			};

/***********************************************************************
Scrolls
***********************************************************************/

			class GuiScroll : public GuiControl, public Description<GuiScroll>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void						SmallDecrease()=0;
					virtual void						SmallIncrease()=0;
					virtual void						BigDecrease()=0;
					virtual void						BigIncrease()=0;

					virtual void						SetTotalSize(vint value)=0;
					virtual void						SetPageSize(vint value)=0;
					virtual void						SetPosition(vint value)=0;
				};
				
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void						SetTotalSize(vint value)=0;
					virtual void						SetPageSize(vint value)=0;
					virtual void						SetPosition(vint value)=0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiScroll*							scroll;
				public:
					CommandExecutor(GuiScroll* _scroll);
					~CommandExecutor();

					void								SmallDecrease()override;
					void								SmallIncrease()override;
					void								BigDecrease()override;
					void								BigIncrease()override;

					void								SetTotalSize(vint value)override;
					void								SetPageSize(vint value)override;
					void								SetPosition(vint value)override;
				};

				IStyleController*						styleController;
				Ptr<CommandExecutor>					commandExecutor;
				vint									totalSize;
				vint									pageSize;
				vint									position;
				vint									smallMove;
				vint									bigMove;
			public:
				GuiScroll(IStyleController* _styleController);
				~GuiScroll();
				
				compositions::GuiNotifyEvent			TotalSizeChanged;
				compositions::GuiNotifyEvent			PageSizeChanged;
				compositions::GuiNotifyEvent			PositionChanged;
				compositions::GuiNotifyEvent			SmallMoveChanged;
				compositions::GuiNotifyEvent			BigMoveChanged;
				
				virtual vint							GetTotalSize();
				virtual void							SetTotalSize(vint value);
				virtual vint							GetPageSize();
				virtual void							SetPageSize(vint value);
				virtual vint							GetPosition();
				virtual void							SetPosition(vint value);
				virtual vint							GetSmallMove();
				virtual void							SetSmallMove(vint value);
				virtual vint							GetBigMove();
				virtual void							SetBigMove(vint value);
				
				vint									GetMinPosition();
				vint									GetMaxPosition();
			};

/***********************************************************************
Dialogs
***********************************************************************/

			class GuiDialogBase abstract : public GuiComponent, public Description<GuiDialogBase>
			{
			protected:
				GuiInstanceRootObject*								rootObject = nullptr;

				GuiWindow*											GetHostWindow();
			public:
				GuiDialogBase();
				~GuiDialogBase();

				void												Attach(GuiInstanceRootObject* _rootObject);
				void												Detach(GuiInstanceRootObject* _rootObject);
			};
			
			class GuiMessageDialog : public GuiDialogBase, public Description<GuiMessageDialog>
			{
			protected:
				INativeDialogService::MessageBoxButtonsInput		input = INativeDialogService::DisplayOK;
				INativeDialogService::MessageBoxDefaultButton		defaultButton = INativeDialogService::DefaultFirst;
				INativeDialogService::MessageBoxIcons				icon = INativeDialogService::IconNone;
				INativeDialogService::MessageBoxModalOptions		modalOption = INativeDialogService::ModalWindow;
				WString												text;
				WString												title;

			public:
				GuiMessageDialog();
				~GuiMessageDialog();

				INativeDialogService::MessageBoxButtonsInput		GetInput();
				void												SetInput(INativeDialogService::MessageBoxButtonsInput value);
				
				INativeDialogService::MessageBoxDefaultButton		GetDefaultButton();
				void												SetDefaultButton(INativeDialogService::MessageBoxDefaultButton value);

				INativeDialogService::MessageBoxIcons				GetIcon();
				void												SetIcon(INativeDialogService::MessageBoxIcons value);

				INativeDialogService::MessageBoxModalOptions		GetModalOption();
				void												SetModalOption(INativeDialogService::MessageBoxModalOptions value);

				const WString&										GetText();
				void												SetText(const WString& value);

				const WString&										GetTitle();
				void												SetTitle(const WString& value);
				
				INativeDialogService::MessageBoxButtonsOutput		ShowDialog();
			};
			
			class GuiColorDialog : public GuiDialogBase, public Description<GuiColorDialog>
			{
			protected:
				bool												enabledCustomColor = true;
				bool												openedCustomColor = false;
				Color												selectedColor;
				bool												showSelection = true;
				collections::List<Color>							customColors;

			public:
				GuiColorDialog();
				~GuiColorDialog();

				compositions::GuiNotifyEvent						SelectedColorChanged;
				
				bool												GetEnabledCustomColor();
				void												SetEnabledCustomColor(bool value);
				
				bool												GetOpenedCustomColor();
				void												SetOpenedCustomColor(bool value);
				
				Color												GetSelectedColor();
				void												SetSelectedColor(Color value);
				
				collections::List<Color>&							GetCustomColors();
				
				bool												ShowDialog();
			};
			
			class GuiFontDialog : public GuiDialogBase, public Description<GuiFontDialog>
			{
			protected:
				FontProperties										selectedFont;
				Color												selectedColor;
				bool												showSelection = true;
				bool												showEffect = true;
				bool												forceFontExist = true;

			public:
				GuiFontDialog();
				~GuiFontDialog();

				compositions::GuiNotifyEvent						SelectedFontChanged;
				compositions::GuiNotifyEvent						SelectedColorChanged;
				
				const FontProperties&								GetSelectedFont();
				void												SetSelectedFont(const FontProperties& value);
				
				Color												GetSelectedColor();
				void												SetSelectedColor(Color value);
				
				bool												GetShowSelection();
				void												SetShowSelection(bool value);
				
				bool												GetShowEffect();
				void												SetShowEffect(bool value);
				
				bool												GetForceFontExist();
				void												SetForceFontExist(bool value);
				
				bool												ShowDialog();
			};
			
			class GuiFileDialogBase abstract : public GuiDialogBase, public Description<GuiFileDialogBase>
			{
			protected:
				WString												filter = L"All Files (*.*)|*.*";
				vint												filterIndex = 0;
				bool												enabledPreview = false;
				WString												title;
				WString												fileName;
				WString												directory;
				WString												defaultExtension;
				INativeDialogService::FileDialogOptions				options;

			public:
				GuiFileDialogBase();
				~GuiFileDialogBase();

				compositions::GuiNotifyEvent						FileNameChanged;
				compositions::GuiNotifyEvent						FilterIndexChanged;
				
				const WString&										GetFilter();
				void												SetFilter(const WString& value);
				
				vint												GetFilterIndex();
				void												SetFilterIndex(vint value);
				
				bool												GetEnabledPreview();
				void												SetEnabledPreview(bool value);
				
				WString												GetTitle();
				void												SetTitle(const WString& value);
				
				WString												GetFileName();
				void												SetFileName(const WString& value);
				
				WString												GetDirectory();
				void												SetDirectory(const WString& value);
				
				WString												GetDefaultExtension();
				void												SetDefaultExtension(const WString& value);
				
				INativeDialogService::FileDialogOptions				GetOptions();
				void												SetOptions(INativeDialogService::FileDialogOptions value);
			};
			
			class GuiOpenFileDialog : public GuiFileDialogBase, public Description<GuiOpenFileDialog>
			{
			protected:
				collections::List<WString>							fileNames;

			public:
				GuiOpenFileDialog();
				~GuiOpenFileDialog();
				
				collections::List<WString>&							GetFileNames();
				
				bool												ShowDialog();
			};
			
			class GuiSaveFileDialog : public GuiFileDialogBase, public Description<GuiSaveFileDialog>
			{
			public:
				GuiSaveFileDialog();
				~GuiSaveFileDialog();

				bool												ShowDialog();
			};
			
			namespace list
			{
/***********************************************************************
List interface common implementation
***********************************************************************/

				template<typename T, typename K=typename KeyType<T>::Type>
				class ItemsBase : public Object, public virtual collections::IEnumerable<T>
				{
				protected:
					collections::List<T, K>					items;

					virtual void NotifyUpdateInternal(vint start, vint count, vint newCount)
					{
					}

					virtual bool QueryInsert(vint index, const T& value)
					{
						return true;
					}

					virtual void BeforeInsert(vint index, const T& value)
					{
					}

					virtual void AfterInsert(vint index, const T& value)
					{
					}

					virtual bool QueryRemove(vint index, const T& value)
					{
						return true;
					}

					virtual void BeforeRemove(vint index, const T& value)
					{
					}

					virtual void AfterRemove(vint index, vint count)
					{
					}
					
				public:
					ItemsBase()
					{
					}

					~ItemsBase()
					{
					}

					collections::IEnumerator<T>* CreateEnumerator()const
					{
						return items.CreateEnumerator();
					}

					bool NotifyUpdate(vint start, vint count=1)
					{
						if(start<0 || start>=items.Count() || count<=0 || start+count>items.Count())
						{
							return false;
						}
						else
						{
							NotifyUpdateInternal(start, count, count);
							return true;
						}
					}

					bool Contains(const K& item)const
					{
						return items.Contains(item);
					}

					vint Count()const
					{
						return items.Count();
					}

					vint Count()
					{
						return items.Count();
					}

					const T& Get(vint index)const
					{
						return items.Get(index);
					}

					const T& operator[](vint index)const
					{
						return items.Get(index);
					}

					vint IndexOf(const K& item)const
					{
						return items.IndexOf(item);
					}

					vint Add(const T& item)
					{
						return Insert(items.Count(), item);
					}

					bool Remove(const K& item)
					{
						vint index=items.IndexOf(item);
						if(index==-1) return false;
						return RemoveAt(index);
					}

					bool RemoveAt(vint index)
					{
						if (0 <= index && index < items.Count() && QueryRemove(index, items[index]))
						{
							BeforeRemove(index, items[index]);
							T item = items[index];
							items.RemoveAt(index);
							AfterRemove(index, 1);
							NotifyUpdateInternal(index, 1, 0);
							return true;
						}
						return false;
					}

					bool RemoveRange(vint index, vint count)
					{
						if(count<=0) return false;
						if (0 <= index && index<items.Count() && index + count <= items.Count())
						{
							for (vint i = 0; i < count; i++)
							{
								if (!QueryRemove(index + 1, items[index + i])) return false;
							}
							for (vint i = 0; i < count; i++)
							{
								BeforeRemove(index + i, items[index + i]);
							}
							items.RemoveRange(index, count);
							AfterRemove(index, count);
							NotifyUpdateInternal(index, count, 0);
							return true;
						}
						return false;
					}

					bool Clear()
					{
						vint count = items.Count();
						for (vint i = 0; i < count; i++)
						{
							if (!QueryRemove(i, items[i])) return false;
						}
						for (vint i = 0; i < count; i++)
						{
							BeforeRemove(i, items[i]);
						}
						items.Clear();
						AfterRemove(0, count);
						NotifyUpdateInternal(0, count, 0);
						return true;
					}

					vint Insert(vint index, const T& item)
					{
						if (0 <= index && index <= items.Count() && QueryInsert(index, item))
						{
							BeforeInsert(index, item);
							items.Insert(index, item);
							AfterInsert(index, item);
							NotifyUpdateInternal(index, 0, 1);
							return index;
						}
						else
						{
							return -1;
						}
					}

					bool Set(vint index, const T& item)
					{
						if (0 <= index && index < items.Count())
						{
							if (QueryRemove(index, items[index]) && QueryInsert(index, item))
							{
								BeforeRemove(index, items[index]);
								items.RemoveAt(index);
								AfterRemove(index, 1);

								BeforeInsert(index, item);
								items.Insert(index, item);
								AfterInsert(index, item);

								NotifyUpdateInternal(index, 1, 1);
								return true;
							}
						}
						return false;
					}
				};

				template<typename T>
				class ObservableList : public ItemsBase<T>
				{
				protected:
					Ptr<description::IValueObservableList>		observableList;

					void NotifyUpdateInternal(vint start, vint count, vint newCount)override
					{
						if (observableList)
						{
							observableList->ItemChanged(start, count, newCount);
						}
					}
				public:

					Ptr<description::IValueObservableList> GetWrapper()
					{
						if (!observableList)
						{
							observableList = new description::ValueObservableListWrapper<ObservableList<T>*>(this);
						}
						return observableList;
					}
				};
			}
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<typename T>
			struct RandomAccessable<presentation::controls::list::ItemsBase<T>>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUIWINDOWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIWINDOWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Control Host
***********************************************************************/

			class GuiControlHost : public GuiControl, public GuiInstanceRootObject, protected INativeWindowListener, public Description<GuiControlHost>
			{
			protected:
				compositions::GuiGraphicsHost*					host;

				virtual void									OnNativeWindowChanged();
				virtual void									OnVisualStatusChanged();
			protected:
				static const vint								TooltipDelayOpenTime=500;
				static const vint								TooltipDelayCloseTime=500;
				static const vint								TooltipDelayLifeTime=5000;

				Ptr<INativeDelay>								tooltipOpenDelay;
				Ptr<INativeDelay>								tooltipCloseDelay;
				Point											tooltipLocation;
				
				GuiControl*										GetTooltipOwner(Point location);
				void											MoveIntoTooltipControl(GuiControl* tooltipControl, Point location);
				void											MouseMoving(const NativeWindowMouseInfo& info)override;
				void											MouseLeaved()override;
				void											Moved()override;
				void											Enabled()override;
				void											Disabled()override;
				void											GotFocus()override;
				void											LostFocus()override;
				void											Activated()override;
				void											Deactivated()override;
				void											Opened()override;
				void											Closing(bool& cancel)override;
				void											Closed()override;
				void											Destroying()override;
			public:
				GuiControlHost(GuiControl::IStyleController* _styleController);
				~GuiControlHost();
				
				compositions::GuiNotifyEvent					WindowGotFocus;
				compositions::GuiNotifyEvent					WindowLostFocus;
				compositions::GuiNotifyEvent					WindowActivated;
				compositions::GuiNotifyEvent					WindowDeactivated;
				compositions::GuiNotifyEvent					WindowOpened;
				compositions::GuiRequestEvent					WindowClosing;
				compositions::GuiNotifyEvent					WindowClosed;
				compositions::GuiNotifyEvent					WindowDestroying;

				compositions::GuiGraphicsHost*					GetGraphicsHost();
				compositions::GuiGraphicsComposition*			GetMainComposition();
				INativeWindow*									GetNativeWindow();
				void											SetNativeWindow(INativeWindow* window);
				void											ForceCalculateSizeImmediately();
				
				bool											GetEnabled()override;
				void											SetEnabled(bool value)override;
				bool											GetFocused();
				void											SetFocused();
				bool											GetActivated();
				void											SetActivated();
				bool											GetShowInTaskBar();
				void											SetShowInTaskBar(bool value);
				bool											GetEnabledActivate();
				void											SetEnabledActivate(bool value);
				bool											GetTopMost();
				void											SetTopMost(bool topmost);

				compositions::IGuiShortcutKeyManager*			GetShortcutKeyManager();
				void											SetShortcutKeyManager(compositions::IGuiShortcutKeyManager* value);
				compositions::GuiGraphicsAnimationManager*		GetAnimationManager();

				Size											GetClientSize();
				void											SetClientSize(Size value);
				Rect											GetBounds();
				void											SetBounds(Rect value);
				GuiControlHost*									GetRelatedControlHost()override;
				const WString&									GetText()override;
				void											SetText(const WString& value)override;

				INativeScreen*									GetRelatedScreen();
				void											Show();
				void											ShowDeactivated();
				void											ShowRestored();
				void											ShowMaximized();
				void											ShowMinimized();
				void											Hide();
				void											Close();
				bool											GetOpening();
			};

/***********************************************************************
Window
***********************************************************************/

			class GuiWindow : public GuiControlHost, protected compositions::IGuiAltActionHost, public Description<GuiWindow>
			{
				friend class GuiApplication;
			public:
				class IStyleController : virtual public GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void						AttachWindow(GuiWindow* _window)=0;
					virtual void						InitializeNativeWindowProperties()=0;
					virtual void						SetSizeState(INativeWindow::WindowSizeState value)=0;
					virtual bool						GetMaximizedBox()=0;
					virtual void						SetMaximizedBox(bool visible)=0;
					virtual bool						GetMinimizedBox()=0;
					virtual void						SetMinimizedBox(bool visible)=0;
					virtual bool						GetBorder()=0;
					virtual void						SetBorder(bool visible)=0;
					virtual bool						GetSizeBox()=0;
					virtual void						SetSizeBox(bool visible)=0;
					virtual bool						GetIconVisible()=0;
					virtual void						SetIconVisible(bool visible)=0;
					virtual bool						GetTitleBar()=0;
					virtual void						SetTitleBar(bool visible)=0;
					virtual IStyleController*			CreateTooltipStyle() = 0;
					virtual GuiLabel::IStyleController*	CreateShortcutKeyStyle() = 0;
				};
				
				class DefaultBehaviorStyleController : virtual public IStyleController
				{
				protected:
					GuiWindow*							window;
				public:
					DefaultBehaviorStyleController();
					~DefaultBehaviorStyleController();

					void								AttachWindow(GuiWindow* _window)override;
					void								InitializeNativeWindowProperties()override;
					void								SetSizeState(INativeWindow::WindowSizeState value)override;
					bool								GetMaximizedBox()override;
					void								SetMaximizedBox(bool visible)override;
					bool								GetMinimizedBox()override;
					void								SetMinimizedBox(bool visible)override;
					bool								GetBorder()override;
					void								SetBorder(bool visible)override;
					bool								GetSizeBox()override;
					void								SetSizeBox(bool visible)override;
					bool								GetIconVisible()override;
					void								SetIconVisible(bool visible)override;
					bool								GetTitleBar()override;
					void								SetTitleBar(bool visible)override;
					IStyleController*					CreateTooltipStyle()override;
					GuiLabel::IStyleController*			CreateShortcutKeyStyle()override;
				};
			protected:
				IStyleController*						styleController;
				compositions::IGuiAltActionHost*		previousAltHost;
				
				void									Moved()override;
				void									OnNativeWindowChanged()override;
				void									OnVisualStatusChanged()override;
				virtual void							MouseClickedOnOtherWindow(GuiWindow* window);

				compositions::GuiGraphicsComposition*	GetAltComposition()override;
				compositions::IGuiAltActionHost*		GetPreviousAltHost()override;
				void									OnActivatedAltHost(IGuiAltActionHost* previousHost)override;
				void									OnDeactivatedAltHost()override;
				void									CollectAltActions(collections::Group<WString, IGuiAltAction*>& actions)override;
			public:
				GuiWindow(IStyleController* _styleController);
				~GuiWindow();

				IDescriptable*							QueryService(const WString& identifier)override;

				compositions::GuiNotifyEvent			ClipboardUpdated;

				void									MoveToScreenCenter();
				
				bool									GetMaximizedBox();
				void									SetMaximizedBox(bool visible);
				bool									GetMinimizedBox();
				void									SetMinimizedBox(bool visible);
				bool									GetBorder();
				void									SetBorder(bool visible);
				bool									GetSizeBox();
				void									SetSizeBox(bool visible);
				bool									GetIconVisible();
				void									SetIconVisible(bool visible);
				bool									GetTitleBar();
				void									SetTitleBar(bool visible);
				void									ShowModal(GuiWindow* owner, const Func<void()>& callback);
				void									ShowModalAndDelete(GuiWindow* owner, const Func<void()>& callback);
			};
			
			class GuiPopup : public GuiWindow, public Description<GuiPopup>
			{
			protected:
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;

				void									PopupOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									PopupClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiPopup(IStyleController* _styleController);
				~GuiPopup();

				bool									IsClippedByScreen(Point location);
				void									ShowPopup(Point location, INativeScreen* screen = 0);
				void									ShowPopup(GuiControl* control, Rect bounds, bool preferredTopBottomSide);
				void									ShowPopup(GuiControl* control, Point location);
				void									ShowPopup(GuiControl* control, bool preferredTopBottomSide);
			};

			class GuiTooltip : public GuiPopup, private INativeControllerListener, public Description<GuiTooltip>
			{
			protected:
				GuiControl*								temporaryContentControl;

				void									GlobalTimer()override;
				void									TooltipOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									TooltipClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiTooltip(IStyleController* _styleController);
				~GuiTooltip();

				vint									GetPreferredContentWidth();
				void									SetPreferredContentWidth(vint value);

				GuiControl*								GetTemporaryContentControl();
				void									SetTemporaryContentControl(GuiControl* control);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUIAPPLICATION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Application Framework

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION
#define VCZH_PRESENTATION_CONTROLS_GUIAPPLICATION


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Application
***********************************************************************/

			class GuiApplication : public Object, private INativeControllerListener, public Description<GuiApplication>
			{
				friend void GuiApplicationInitialize();
				friend class GuiWindow;
				friend class GuiPopup;
				friend class Ptr<GuiApplication>;
			private:
				void											InvokeClipboardNotify(compositions::GuiGraphicsComposition* composition, compositions::GuiEventArgs& arguments);
				void											LeftButtonDown(Point position)override;
				void											LeftButtonUp(Point position)override;
				void											RightButtonDown(Point position)override;
				void											RightButtonUp(Point position)override;
				void											ClipboardUpdated()override;
			protected:
				GuiWindow*										mainWindow;
				GuiWindow*										sharedTooltipOwnerWindow;
				GuiControl*										sharedTooltipOwner;
				GuiTooltip*										sharedTooltipControl;
				bool											sharedTooltipHovering;
				bool											sharedTooltipClosing;
				collections::List<GuiWindow*>					windows;
				collections::SortedList<GuiPopup*>				openingPopups;

				GuiApplication();
				~GuiApplication();

				void											RegisterWindow(GuiWindow* window);
				void											UnregisterWindow(GuiWindow* window);
				void											RegisterPopupOpened(GuiPopup* popup);
				void											RegisterPopupClosed(GuiPopup* popup);
				void											OnMouseDown(Point location);
				void											TooltipMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											TooltipMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				void											Run(GuiWindow* _mainWindow);
				GuiWindow*										GetMainWindow();
				const collections::List<GuiWindow*>&			GetWindows();
				GuiWindow*										GetWindow(Point location);
				void											ShowTooltip(GuiControl* owner, GuiControl* tooltip, vint preferredContentWidth, Point location);
				void											CloseTooltip();
				GuiControl*										GetTooltipOwner();
				WString											GetExecutablePath();
				WString											GetExecutableFolder();

				bool											IsInMainThread();
				void											InvokeAsync(const Func<void()>& proc);
				void											InvokeInMainThread(const Func<void()>& proc);
				bool											InvokeInMainThreadAndWait(const Func<void()>& proc, vint milliseconds=-1);
				Ptr<INativeDelay>								DelayExecute(const Func<void()>& proc, vint milliseconds);
				Ptr<INativeDelay>								DelayExecuteInMainThread(const Func<void()>& proc, vint milliseconds);
				void											RunGuiTask(const Func<void()>& proc);

				template<typename T>
				T RunGuiValue(const Func<T()>& proc)
				{
					T result;
					RunGuiTask([&result, &proc]()
					{
						result=proc();
					});
					return result;
				}

				template<typename T>
				void InvokeLambdaInMainThread(const T& proc)
				{
					InvokeInMainThread(Func<void()>(proc));
				}
				
				template<typename T>
				bool InvokeLambdaInMainThreadAndWait(const T& proc, vint milliseconds=-1)
				{
					return InvokeInMainThreadAndWait(Func<void()>(proc), milliseconds);
				}
			};

/***********************************************************************
Plugin
***********************************************************************/

			class IGuiPlugin : public IDescriptable, public Description<IGuiPlugin>
			{
			public:
				virtual void									Load()=0;
				virtual void									AfterLoad()=0;
				virtual void									Unload()=0;
			};

			class IGuiPluginManager : public IDescriptable, public Description<IGuiPluginManager>
			{
			public:
				virtual void									AddPlugin(Ptr<IGuiPlugin> plugin)=0;
				virtual void									Load()=0;
				virtual void									Unload()=0;
				virtual bool									IsLoaded()=0;
			};

/***********************************************************************
Helper Functions
***********************************************************************/

			extern GuiApplication*								GetApplication();

			extern IGuiPluginManager*							GetPluginManager();

			extern void											DestroyPluginManager();
		}
	}
}

extern void GuiApplicationMain();

#define GUI_VALUE(x) vl::presentation::controls::GetApplication()->RunGuiValue(LAMBDA([&](){return (x);}))
#define GUI_RUN(x) vl::presentation::controls::GetApplication()->RunGuiTask([=](){x})

#define GUI_REGISTER_PLUGIN(TYPE)\
	class GuiRegisterPluginClass_##TYPE\
	{\
	public:\
		GuiRegisterPluginClass_##TYPE()\
		{\
			vl::presentation::controls::GetPluginManager()->AddPlugin(new TYPE);\
		}\
	} instance_GuiRegisterPluginClass_##TYPE;\

#endif

/***********************************************************************
CONTROLS\GUICONTAINERCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICONTAINERCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
/***********************************************************************
Tab Control
***********************************************************************/

			class GuiTab;

			class GuiTabPage : public Object, protected compositions::IGuiAltActionHost, public Description<GuiTabPage>
			{
				friend class GuiTab;
				friend class Ptr<GuiTabPage>;
			protected:
				GuiControl*										containerControl;
				GuiTab*											owner;
				WString											alt;
				WString											text;
				compositions::IGuiAltActionHost*				previousAltHost;

				bool											AssociateTab(GuiTab* _owner);
				bool											DeassociateTab(GuiTab* _owner);
				compositions::GuiGraphicsComposition*			GetAltComposition()override;
				compositions::IGuiAltActionHost*				GetPreviousAltHost()override;
				void											OnActivatedAltHost(compositions::IGuiAltActionHost* previousHost)override;
				void											OnDeactivatedAltHost()override;
				void											CollectAltActions(collections::Group<WString, compositions::IGuiAltAction*>& actions)override;
			public:
				GuiTabPage();
				~GuiTabPage();
				
				compositions::GuiNotifyEvent					AltChanged;
				compositions::GuiNotifyEvent					TextChanged;
				compositions::GuiNotifyEvent					PageInstalled;
				compositions::GuiNotifyEvent					PageUninstalled;

				compositions::GuiGraphicsComposition*			GetContainerComposition();
				GuiTab*											GetOwnerTab();
				const WString&									GetAlt();
				bool											SetAlt(const WString& value);
				const WString&									GetText();
				void											SetText(const WString& param);
				bool											GetSelected();
			};

			class GuiTab : public GuiControl, protected compositions::IGuiAltActionContainer, public Description<GuiTab>
			{
				friend class GuiTabPage;
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void								ShowTab(vint index)=0;
				};
				
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void								InsertTab(vint index)=0;
					virtual void								SetTabText(vint index, const WString& value)=0;
					virtual void								RemoveTab(vint index)=0;
					virtual void								MoveTab(vint oldIndex, vint newIndex)=0;
					virtual void								SetSelectedTab(vint index)=0;
					virtual void								SetTabAlt(vint index, const WString& value, compositions::IGuiAltActionHost* host)=0;
					virtual compositions::IGuiAltAction*		GetTabAltAction(vint index) = 0;
				};
			protected:
				class CommandExecutor : public Object, public ICommandExecutor
				{
				protected:
					GuiTab*										tab;
				public:
					CommandExecutor(GuiTab* _tab);
					~CommandExecutor();

					void										ShowTab(vint index)override;
				};

				Ptr<CommandExecutor>							commandExecutor;
				IStyleController*								styleController;
				collections::List<GuiTabPage*>					tabPages;
				GuiTabPage*										selectedPage;

				vint											GetAltActionCount()override;
				compositions::IGuiAltAction*					GetAltAction(vint index)override;
			public:
				GuiTab(IStyleController* _styleController);
				~GuiTab();

				IDescriptable*									QueryService(const WString& identifier)override;

				compositions::GuiNotifyEvent					SelectedPageChanged;

				GuiTabPage*										CreatePage(vint index=-1);
				bool											CreatePage(GuiTabPage* page, vint index=-1);
				bool											RemovePage(GuiTabPage* value);
				bool											MovePage(GuiTabPage* page, vint newIndex);
				const collections::List<GuiTabPage*>&			GetPages();

				GuiTabPage*										GetSelectedPage();
				bool											SetSelectedPage(GuiTabPage* value);
			};

/***********************************************************************
Scroll View
***********************************************************************/

			class GuiScrollView : public GuiControl, public Description<GuiScrollView>
			{
			public:
				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiScroll::IStyleController*			CreateHorizontalScrollStyle()=0;
					virtual GuiScroll::IStyleController*			CreateVerticalScrollStyle()=0;
					virtual vint									GetDefaultScrollSize()=0;
					virtual compositions::GuiGraphicsComposition*	InstallBackground(compositions::GuiBoundsComposition* boundsComposition)=0;
				};
				
				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>						styleProvider;
					GuiScrollView*							scrollView;
					GuiScroll*								horizontalScroll;
					GuiScroll*								verticalScroll;
					compositions::GuiBoundsComposition*		boundsComposition;
					compositions::GuiTableComposition*		tableComposition;
					compositions::GuiCellComposition*		containerCellComposition;
					compositions::GuiBoundsComposition*		containerComposition;
					bool									horizontalAlwaysVisible;
					bool									verticalAlwaysVisible;

					void									UpdateTable();
				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetScrollView(GuiScrollView* _scrollView);
					void									AdjustView(Size fullSize);
					IStyleProvider*							GetStyleProvider();

					GuiScroll*								GetHorizontalScroll();
					GuiScroll*								GetVerticalScroll();

					compositions::GuiTableComposition*		GetInternalTableComposition();
					compositions::GuiBoundsComposition*		GetInternalContainerComposition();

					bool									GetHorizontalAlwaysVisible();
					void									SetHorizontalAlwaysVisible(bool value);
					bool									GetVerticalAlwaysVisible();
					void									SetVerticalAlwaysVisible(bool value);

					compositions::GuiBoundsComposition*		GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};
			protected:

				StyleController*						styleController;
				bool									supressScrolling;

				void									OnContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnVerticalScroll(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnHorizontalWheel(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									OnVerticalWheel(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void									CallUpdateView();
				void									Initialize();

				virtual Size							QueryFullSize()=0;
				virtual void							UpdateView(Rect viewBounds)=0;
				virtual vint							GetSmallMove();
				virtual Size							GetBigMove();
				
				GuiScrollView(StyleController* _styleController);
			public:
				GuiScrollView(IStyleProvider* styleProvider);
				~GuiScrollView();

				virtual void							SetFont(const FontProperties& value);

				void									CalculateView();
				Size									GetViewSize();
				Rect									GetViewBounds();
				
				GuiScroll*								GetHorizontalScroll();
				GuiScroll*								GetVerticalScroll();
				bool									GetHorizontalAlwaysVisible();
				void									SetHorizontalAlwaysVisible(bool value);
				bool									GetVerticalAlwaysVisible();
				void									SetVerticalAlwaysVisible(bool value);
			};
			
			class GuiScrollContainer : public GuiScrollView, public Description<GuiScrollContainer>
			{
			public:
				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					compositions::GuiBoundsComposition*		controlContainerComposition;
					bool									extendToFullWidth;
				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					compositions::GuiGraphicsComposition*	GetContainerComposition()override;
					void									MoveContainer(Point leftTop);

					bool									GetExtendToFullWidth();
					void									SetExtendToFullWidth(bool value);
				};

			protected:
				StyleController*						styleController;

				void									OnControlContainerBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				Size									QueryFullSize()override;
				void									UpdateView(Rect viewBounds)override;
			public:
				GuiScrollContainer(GuiScrollContainer::IStyleProvider* styleProvider);
				~GuiScrollContainer();
				
				bool									GetExtendToFullWidth();
				void									SetExtendToFullWidth(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUILISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
List Control
***********************************************************************/

			class GuiListControl : public GuiScrollView, public Description<GuiListControl>
			{
			public:
				class IItemProvider;
				class IItemStyleController;
				class IItemStyleProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class IItemProviderCallback : public virtual IDescriptable, public Description<IItemProviderCallback>
				{
				public:
					virtual void								OnAttached(IItemProvider* provider)=0;
					virtual void								OnItemModified(vint start, vint count, vint newCount)=0;
				};

				class IItemArrangerCallback : public virtual IDescriptable, public Description<IItemArrangerCallback>
				{
				public:
					virtual IItemStyleController*					RequestItem(vint itemIndex)=0;
					virtual void									ReleaseItem(IItemStyleController* style)=0;
					virtual void									SetViewLocation(Point value)=0;
					virtual Size									GetStylePreferredSize(IItemStyleController* style)=0;
					virtual void									SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)=0;
					virtual Rect									GetStyleBounds(IItemStyleController* style)=0;
					virtual void									SetStyleBounds(IItemStyleController* style, Rect bounds)=0;
					virtual compositions::GuiGraphicsComposition*	GetContainerComposition()=0;
					virtual void									OnTotalSizeChanged()=0;
				};

				//-----------------------------------------------------------
				// Common Views
				//-----------------------------------------------------------

				class IItemPrimaryTextView : public virtual IDescriptable, public Description<IItemPrimaryTextView>
				{
				public:
					static const wchar_t* const					Identifier;

					virtual WString								GetPrimaryTextViewText(vint itemIndex)=0;
					virtual bool								ContainsPrimaryText(vint itemIndex)=0;
				};

				class IItemBindingView : public virtual IDescriptable, public Description<IItemPrimaryTextView>
				{
				public:
					static const wchar_t* const					Identifier;

					virtual description::Value					GetBindingValue(vint itemIndex)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				enum KeyDirection
				{
					Up,
					Down,
					Left,
					Right,
					Home,
					End,
					PageUp,
					PageDown,
					PageLeft,
					PageRight,
				};

				class IItemProvider : public virtual IDescriptable, public Description<IItemProvider>
				{
				public:
					virtual bool								AttachCallback(IItemProviderCallback* value)=0;
					virtual bool								DetachCallback(IItemProviderCallback* value)=0;
					virtual vint								Count()=0;
					virtual IDescriptable*						RequestView(const WString& identifier)=0;
					virtual void								ReleaseView(IDescriptable* view)=0;
				};
				
				class IItemStyleController : public virtual IDescriptable, public Description<IItemStyleController>
				{
				public:
					virtual IItemStyleProvider*					GetStyleProvider()=0;
					virtual vint								GetItemStyleId()=0;
					virtual compositions::GuiBoundsComposition*	GetBoundsComposition()=0;
					virtual bool								IsCacheable()=0;
					virtual bool								IsInstalled()=0;
					virtual void								OnInstalled()=0;
					virtual void								OnUninstalled()=0;
				};
				
				class IItemStyleProvider : public virtual IDescriptable, public Description<IItemStyleProvider>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual vint								GetItemStyleId(vint itemIndex)=0;
					virtual IItemStyleController*				CreateItemStyle(vint styleId)=0;
					virtual void								DestroyItemStyle(IItemStyleController* style)=0;
					virtual void								Install(IItemStyleController* style, vint itemIndex)=0;
					virtual void								SetStyleIndex(IItemStyleController* style, vint value)=0;
				};
				
				class IItemArranger : public virtual IItemProviderCallback, public Description<IItemArranger>
				{
				public:
					virtual void								AttachListControl(GuiListControl* value)=0;
					virtual void								DetachListControl()=0;
					virtual IItemArrangerCallback*				GetCallback()=0;
					virtual void								SetCallback(IItemArrangerCallback* value)=0;
					virtual Size								GetTotalSize()=0;
					virtual IItemStyleController*				GetVisibleStyle(vint itemIndex)=0;
					virtual vint								GetVisibleIndex(IItemStyleController* style)=0;
					virtual void								OnViewChanged(Rect bounds)=0;
					virtual vint								FindItem(vint itemIndex, KeyDirection key)=0;
					virtual bool								EnsureItemVisible(vint itemIndex)=0;
				};
				
				class IItemCoordinateTransformer : public virtual IDescriptable, public Description<IItemCoordinateTransformer>
				{
				public:
					virtual Size								RealSizeToVirtualSize(Size size)=0;
					virtual Size								VirtualSizeToRealSize(Size size)=0;
					virtual Point								RealPointToVirtualPoint(Size realFullSize, Point point)=0;
					virtual Point								VirtualPointToRealPoint(Size realFullSize, Point point)=0;
					virtual Rect								RealRectToVirtualRect(Size realFullSize, Rect rect)=0;
					virtual Rect								VirtualRectToRealRect(Size realFullSize, Rect rect)=0;
					virtual Margin								RealMarginToVirtualMargin(Margin margin)=0;
					virtual Margin								VirtualMarginToRealMargin(Margin margin)=0;
					virtual KeyDirection						RealKeyDirectionToVirtualKeyDirection(KeyDirection key)=0;
				};

			protected:

				//-----------------------------------------------------------
				// ItemCallback
				//-----------------------------------------------------------

				class ItemCallback : public IItemProviderCallback, public IItemArrangerCallback
				{
					typedef collections::List<IItemStyleController*>			StyleList;
				protected:
					GuiListControl*								listControl;
					IItemProvider*								itemProvider;
					StyleList									cachedStyles;
					StyleList									installedStyles;

				public:
					ItemCallback(GuiListControl* _listControl);
					~ItemCallback();

					void										ClearCache();

					void										OnAttached(IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount)override;
					IItemStyleController*						RequestItem(vint itemIndex)override;
					void										ReleaseItem(IItemStyleController* style)override;
					void										SetViewLocation(Point value)override;
					Size										GetStylePreferredSize(IItemStyleController* style)override;
					void										SetStyleAlignmentToParent(IItemStyleController* style, Margin margin)override;
					Rect										GetStyleBounds(IItemStyleController* style)override;
					void										SetStyleBounds(IItemStyleController* style, Rect bounds)override;
					compositions::GuiGraphicsComposition*		GetContainerComposition()override;
					void										OnTotalSizeChanged()override;
				};

				//-----------------------------------------------------------
				// State management
				//-----------------------------------------------------------

				Ptr<ItemCallback>								callback;
				Ptr<IItemProvider>								itemProvider;
				Ptr<IItemStyleProvider>							itemStyleProvider;
				Ptr<IItemArranger>								itemArranger;
				Ptr<IItemCoordinateTransformer>					itemCoordinateTransformer;
				Size											fullSize;

				virtual void									OnItemModified(vint start, vint count, vint newCount);
				virtual void									OnStyleInstalled(vint itemIndex, IItemStyleController* style);
				virtual void									OnStyleUninstalled(IItemStyleController* style);
				
				void											OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void											OnBeforeReleaseGraphicsHost()override;
				Size											QueryFullSize()override;
				void											UpdateView(Rect viewBounds)override;
				
				void											OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											SetStyleProviderAndArranger(Ptr<IItemStyleProvider> styleProvider, Ptr<IItemArranger> arranger);

				//-----------------------------------------------------------
				// Item event management
				//-----------------------------------------------------------

				class VisibleStyleHelper
				{
				public:
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		leftButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		middleButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonDownHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonUpHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		rightButtonDoubleClickHandler;
					Ptr<compositions::GuiMouseEvent::IHandler>		mouseMoveHandler;
					Ptr<compositions::GuiNotifyEvent::IHandler>		mouseEnterHandler;
					Ptr<compositions::GuiNotifyEvent::IHandler>		mouseLeaveHandler;
				};
				
				friend class collections::ArrayBase<Ptr<VisibleStyleHelper>>;
				collections::Dictionary<IItemStyleController*, Ptr<VisibleStyleHelper>>		visibleStyles;

				void											OnItemMouseEvent(compositions::GuiItemMouseEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void											OnItemNotifyEvent(compositions::GuiItemNotifyEvent& itemEvent, IItemStyleController* style, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											AttachItemEvents(IItemStyleController* style);
				void											DetachItemEvents(IItemStyleController* style);
			public:
				GuiListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider, bool acceptFocus=false);
				~GuiListControl();

				compositions::GuiNotifyEvent					StyleProviderChanged;
				compositions::GuiNotifyEvent					ArrangerChanged;
				compositions::GuiNotifyEvent					CoordinateTransformerChanged;

				compositions::GuiItemMouseEvent					ItemLeftButtonDown;
				compositions::GuiItemMouseEvent					ItemLeftButtonUp;
				compositions::GuiItemMouseEvent					ItemLeftButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemMiddleButtonDown;
				compositions::GuiItemMouseEvent					ItemMiddleButtonUp;
				compositions::GuiItemMouseEvent					ItemMiddleButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemRightButtonDown;
				compositions::GuiItemMouseEvent					ItemRightButtonUp;
				compositions::GuiItemMouseEvent					ItemRightButtonDoubleClick;
				compositions::GuiItemMouseEvent					ItemMouseMove;
				compositions::GuiItemNotifyEvent				ItemMouseEnter;
				compositions::GuiItemNotifyEvent				ItemMouseLeave;

				virtual IItemProvider*							GetItemProvider();
				virtual IItemStyleProvider*						GetStyleProvider();
				virtual Ptr<IItemStyleProvider>					SetStyleProvider(Ptr<IItemStyleProvider> value);
				virtual IItemArranger*							GetArranger();
				virtual Ptr<IItemArranger>						SetArranger(Ptr<IItemArranger> value);
				virtual IItemCoordinateTransformer*				GetCoordinateTransformer();
				virtual Ptr<IItemCoordinateTransformer>			SetCoordinateTransformer(Ptr<IItemCoordinateTransformer> value);
				virtual bool									EnsureItemVisible(vint itemIndex);
			};

/***********************************************************************
Selectable List Control
***********************************************************************/

			class GuiSelectableListControl : public GuiListControl, public Description<GuiSelectableListControl>
			{
			public:
				class IItemStyleProvider : public virtual GuiListControl::IItemStyleProvider, public Description<IItemStyleProvider>
				{
				public:
					virtual void								SetStyleSelected(IItemStyleController* style, bool value)=0;
				};
			protected:

				Ptr<IItemStyleProvider>							selectableStyleProvider;
				collections::SortedList<vint>					selectedItems;
				bool											multiSelect;
				vint											selectedItemIndexStart;
				vint											selectedItemIndexEnd;

				void											OnItemModified(vint start, vint count, vint newCount)override;
				void											OnStyleInstalled(vint itemIndex, IItemStyleController* style)override;
				void											OnStyleUninstalled(IItemStyleController* style)override;
				virtual void									OnItemSelectionChanged(vint itemIndex, bool value);
				virtual void									OnItemSelectionCleared();
				void											OnItemLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void											OnItemRightButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);

				void											NormalizeSelectedItemIndexStartEnd();
				void											SetMultipleItemsSelectedSilently(vint start, vint end, bool selected);
				void											OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
			public:
				GuiSelectableListControl(IStyleProvider* _styleProvider, IItemProvider* _itemProvider);
				~GuiSelectableListControl();

				compositions::GuiNotifyEvent					SelectionChanged;

				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;

				bool											GetMultiSelect();
				void											SetMultiSelect(bool value);
				
				const collections::SortedList<vint>&			GetSelectedItems();
				vint											GetSelectedItemIndex();
				WString											GetSelectedItemText();

				bool											GetSelected(vint itemIndex);
				void											SetSelected(vint itemIndex, bool value);
				bool											SelectItemsByClick(vint itemIndex, bool ctrl, bool shift, bool leftButton);
				bool											SelectItemsByKey(vint code, bool ctrl, bool shift);
				void											ClearSelection();
			};

/***********************************************************************
Predefined ItemCoordinateTransformer
***********************************************************************/

			namespace list
			{
				class DefaultItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<DefaultItemCoordinateTransformer>
				{
				public:
					DefaultItemCoordinateTransformer();
					~DefaultItemCoordinateTransformer();

					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
					GuiListControl::KeyDirection				RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)override;
				};
				
				class AxisAlignedItemCoordinateTransformer : public Object, virtual public GuiListControl::IItemCoordinateTransformer, public Description<AxisAlignedItemCoordinateTransformer>
				{
				public:
					enum Alignment
					{
						LeftDown,
						RightDown,
						LeftUp,
						RightUp,
						DownLeft,
						DownRight,
						UpLeft,
						UpRight,
					};
				protected:
					Alignment									alignment;

				public:
					AxisAlignedItemCoordinateTransformer(Alignment _alignment);
					~AxisAlignedItemCoordinateTransformer();

					Alignment									GetAlignment();
					Size										RealSizeToVirtualSize(Size size)override;
					Size										VirtualSizeToRealSize(Size size)override;
					Point										RealPointToVirtualPoint(Size realFullSize, Point point)override;
					Point										VirtualPointToRealPoint(Size realFullSize, Point point)override;
					Rect										RealRectToVirtualRect(Size realFullSize, Rect rect)override;
					Rect										VirtualRectToRealRect(Size realFullSize, Rect rect)override;
					Margin										RealMarginToVirtualMargin(Margin margin)override;
					Margin										VirtualMarginToRealMargin(Margin margin)override;
					GuiListControl::KeyDirection				RealKeyDirectionToVirtualKeyDirection(GuiListControl::KeyDirection key)override;
				};
			};

/***********************************************************************
Predefined ItemArranger
***********************************************************************/

			namespace list
			{
				class RangedItemArrangerBase : public Object, virtual public GuiListControl::IItemArranger, public Description<RangedItemArrangerBase>
				{
					typedef collections::List<GuiListControl::IItemStyleController*>		StyleList;
				protected:
					GuiListControl*								listControl;
					GuiListControl::IItemArrangerCallback*		callback;
					GuiListControl::IItemProvider*				itemProvider;
					Rect										viewBounds;
					vint										startIndex;
					StyleList									visibleStyles;

					virtual void								ClearStyles();
					virtual void								OnStylesCleared()=0;
					virtual Size								OnCalculateTotalSize()=0;
					virtual void								OnViewChangedInternal(Rect oldBounds, Rect newBounds)=0;
				public:
					RangedItemArrangerBase();
					~RangedItemArrangerBase();

					void										OnAttached(GuiListControl::IItemProvider* provider)override;
					void										OnItemModified(vint start, vint count, vint newCount)override;
					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemArrangerCallback*		GetCallback()override;
					void										SetCallback(GuiListControl::IItemArrangerCallback* value)override;
					Size										GetTotalSize()override;
					GuiListControl::IItemStyleController*		GetVisibleStyle(vint itemIndex)override;
					vint										GetVisibleIndex(GuiListControl::IItemStyleController* style)override;
					void										OnViewChanged(Rect bounds)override;
				};
				
				class FixedHeightItemArranger : public RangedItemArrangerBase, public Description<FixedHeightItemArranger>
				{
				protected:
					vint										rowHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					virtual vint								GetWidth();
					virtual vint								GetYOffset();
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightItemArranger();
					~FixedHeightItemArranger();

					vint										FindItem(vint itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(vint itemIndex)override;
				};

				class FixedSizeMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedSizeMultiColumnItemArranger>
				{
				protected:
					Size										itemSize;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(Size itemSize, Rect bounds, vint count, vint& start, vint& end);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedSizeMultiColumnItemArranger();
					~FixedSizeMultiColumnItemArranger();

					vint										FindItem(vint itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(vint itemIndex)override;
				};
				
				class FixedHeightMultiColumnItemArranger : public RangedItemArrangerBase, public Description<FixedHeightMultiColumnItemArranger>
				{
				protected:
					vint										itemHeight;
					bool										suppressOnViewChanged;

					virtual void								RearrangeItemBounds();
					void										CalculateRange(vint itemHeight, Rect bounds, vint& rows, vint& startColumn);
					void										OnStylesCleared()override;
					Size										OnCalculateTotalSize()override;
					void										OnViewChangedInternal(Rect oldBounds, Rect newBounds)override;
				public:
					FixedHeightMultiColumnItemArranger();
					~FixedHeightMultiColumnItemArranger();

					vint										FindItem(vint itemIndex, GuiListControl::KeyDirection key)override;
					bool										EnsureItemVisible(vint itemIndex)override;
				};
			}

/***********************************************************************
Predefined ItemStyleController
***********************************************************************/

			namespace list
			{
				class ItemStyleControllerBase : public Object, public virtual GuiListControl::IItemStyleController, public Description<ItemStyleControllerBase>
				{
				protected:
					GuiListControl::IItemStyleProvider*			provider;
					vint										styleId;
					compositions::GuiBoundsComposition*			boundsComposition;
					GuiControl*									associatedControl;
					bool										isInstalled;

					void										Initialize(compositions::GuiBoundsComposition* _boundsComposition, GuiControl* _associatedControl);
					void										Finalize();

					ItemStyleControllerBase(GuiListControl::IItemStyleProvider* _provider, vint _styleId);
				public:
					~ItemStyleControllerBase();
					
					GuiListControl::IItemStyleProvider*			GetStyleProvider()override;
					vint										GetItemStyleId()override;
					compositions::GuiBoundsComposition*			GetBoundsComposition()override;
					bool										IsCacheable()override;
					bool										IsInstalled()override;
					void										OnInstalled()override;
					void										OnUninstalled()override;
				};
			}

/***********************************************************************
Predefined ItemProvider
***********************************************************************/

			namespace list
			{
				class ItemProviderBase : public Object, public virtual GuiListControl::IItemProvider, public Description<ItemProviderBase>
				{
				protected:
					collections::List<GuiListControl::IItemProviderCallback*>	callbacks;

					virtual void								InvokeOnItemModified(vint start, vint count, vint newCount);
				public:
					ItemProviderBase();
					~ItemProviderBase();

					bool										AttachCallback(GuiListControl::IItemProviderCallback* value);
					bool										DetachCallback(GuiListControl::IItemProviderCallback* value);
				};

				template<typename T>
				class ListProvider : public ItemProviderBase, public ItemsBase<T>
				{
				protected:
					void NotifyUpdateInternal(vint start, vint count, vint newCount)
					{
						InvokeOnItemModified(start, count, newCount);
					}
				public:
					vint Count()override
					{
						return this->items.Count();
					}
				};
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUITEXTLISTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTLISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualTextList;
			class GuiTextList;

			namespace list
			{

/***********************************************************************
TextList Style Provider
***********************************************************************/

				class TextItemStyleProvider : public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<TextItemStyleProvider>
				{
				public:
					class ITextItemStyleProvider : public virtual IDescriptable, public Description<ITextItemStyleProvider>
					{
					public:
						virtual GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()=0;
						virtual GuiSelectableButton::IStyleController*		CreateBulletStyleController()=0;
						virtual Color										GetTextColor()=0;
					};

					class ITextItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<ITextItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual WString							GetText(vint itemIndex)=0;
						virtual bool							GetChecked(vint itemIndex)=0;
						virtual void							SetCheckedSilently(vint itemIndex, bool value)=0;
					};

					class TextItemStyleController : public ItemStyleControllerBase, public Description<TextItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						GuiSelectableButton*					bulletButton;
						elements::GuiSolidLabelElement*			textElement;
						TextItemStyleProvider*					textItemStyleProvider;

						void									OnBulletSelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						TextItemStyleController(TextItemStyleProvider* provider);
						~TextItemStyleController();
						
						bool									GetSelected();
						void									SetSelected(bool value);
						bool									GetChecked();
						void									SetChecked(bool value);
						const WString&							GetText();
						void									SetText(const WString& value);
					};

				protected:
					Ptr<ITextItemStyleProvider>					textItemStyleProvider;
					ITextItemView*								textItemView;
					GuiVirtualTextList*							listControl;

					void										OnStyleCheckedChanged(TextItemStyleController* style);
				public:
					TextItemStyleProvider(ITextItemStyleProvider* _textItemStyleProvider);
					~TextItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					vint										GetItemStyleId(vint itemIndex)override;
					GuiListControl::IItemStyleController*		CreateItemStyle(vint styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, vint itemIndex)override;
					void										SetStyleIndex(GuiListControl::IItemStyleController* style, vint value)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};

/***********************************************************************
TextList Data Source
***********************************************************************/

				class TextItemProvider;

				class TextItem : public Object, public Description<TextItem>
				{
					friend class TextItemProvider;
				protected:
					TextItemProvider*							owner;
					WString										text;
					bool										checked;

				public:
					TextItem();
					TextItem(const WString& _text, bool _checked=false);
					~TextItem();

					bool										operator==(const TextItem& value)const;
					bool										operator!=(const TextItem& value)const;
					
					const WString&								GetText();
					void										SetText(const WString& value);

					bool										GetChecked();
					void										SetChecked(bool value);
				};

				class TextItemProvider
					: public ListProvider<Ptr<TextItem>>
					, protected TextItemStyleProvider::ITextItemView
					, protected GuiListControl::IItemBindingView
					, public Description<TextItemProvider>
				{
					friend class TextItem;
					friend class vl::presentation::controls::GuiTextList;
				protected:
					GuiTextList*								listControl;

					void										AfterInsert(vint item, const Ptr<TextItem>& value)override;
					void										BeforeRemove(vint item, const Ptr<TextItem>& value)override;

					bool										ContainsPrimaryText(vint itemIndex)override;
					WString										GetPrimaryTextViewText(vint itemIndex)override;
					WString										GetText(vint itemIndex)override;
					bool										GetChecked(vint itemIndex)override;
					void										SetCheckedSilently(vint itemIndex, bool value)override;
					description::Value							GetBindingValue(vint itemIndex)override;
				public:
					TextItemProvider();
					~TextItemProvider();

					IDescriptable*								RequestView(const WString& identifier)override;
					void										ReleaseView(IDescriptable* view)override;
				};
			}

/***********************************************************************
TextList Control
***********************************************************************/

			class GuiVirtualTextList : public GuiSelectableListControl, public Description<GuiVirtualTextList>
			{
			public:
				GuiVirtualTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualTextList();

				compositions::GuiItemNotifyEvent				ItemChecked;
				
				Ptr<GuiListControl::IItemStyleProvider>			ChangeItemStyle(list::TextItemStyleProvider::ITextItemStyleProvider* itemStyleProvider);
			};
			
			class GuiTextList : public GuiVirtualTextList, public Description<GuiTextList>
			{
			protected:
				list::TextItemProvider*							items;
			public:
				GuiTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider);
				~GuiTextList();

				list::TextItemProvider&							GetItems();

				Ptr<list::TextItem>								GetSelectedItem();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TOOLSTRIPPACKAGE\GUIMENUCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIMENUCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Menu Service
***********************************************************************/

			class GuiMenu;

			class IGuiMenuService : public virtual IDescriptable, public Description<IGuiMenuService>
			{
			public:
				static const wchar_t* const				Identifier;

				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				GuiMenu*								openingMenu;
			public:
				IGuiMenuService();

				virtual IGuiMenuService*				GetParentMenuService()=0;
				virtual Direction						GetPreferredDirection()=0;
				virtual bool							IsActiveState()=0;
				virtual bool							IsSubMenuActivatedByMouseDown()=0;

				virtual void							MenuItemExecuted();
				virtual GuiMenu*						GetOpeningMenu();
				virtual void							MenuOpened(GuiMenu* menu);
				virtual void							MenuClosed(GuiMenu* menu);
			};

/***********************************************************************
Menu
***********************************************************************/

			class GuiMenu : public GuiPopup, private IGuiMenuService, public Description<GuiMenu>
			{
			private:
				IGuiMenuService*						parentMenuService;

				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;
				void									MenuItemExecuted()override;
			protected:
				GuiControl*								owner;

				void									OnDeactivatedAltHost()override;
				void									MouseClickedOnOtherWindow(GuiWindow* window)override;
				void									OnWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiMenu(IStyleController* _styleController, GuiControl* _owner);
				~GuiMenu();

				void									UpdateMenuService();
				IDescriptable*							QueryService(const WString& identifier)override;
			};
			
			class GuiMenuBar : public GuiControl, private IGuiMenuService, public Description<GuiMenuBar>
			{
			private:
				IGuiMenuService*						GetParentMenuService()override;
				Direction								GetPreferredDirection()override;
				bool									IsActiveState()override;
				bool									IsSubMenuActivatedByMouseDown()override;
			public:
				GuiMenuBar(GuiControl::IStyleController* _styleController);
				~GuiMenuBar();
				
				IDescriptable*							QueryService(const WString& identifier)override;
			};

/***********************************************************************
MenuButton
***********************************************************************/

			class GuiMenuButton : public GuiSelectableButton, public Description<GuiMenuButton>
			{
			public:
				class IStyleController : public virtual GuiSelectableButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual GuiMenu::IStyleController*	CreateSubMenuStyleController()=0;
					virtual void						SetSubMenuExisting(bool value)=0;
					virtual void						SetSubMenuOpening(bool value)=0;
					virtual GuiButton*					GetSubMenuHost()=0;
					virtual void						SetImage(Ptr<GuiImageData> value)=0;
					virtual void						SetShortcutText(const WString& value)=0;
				};
			protected:
				IStyleController*						styleController;
				Ptr<GuiImageData>						image;
				WString									shortcutText;
				GuiMenu*								subMenu;
				bool									ownedSubMenu;
				Size									preferredMenuClientSize;
				IGuiMenuService*						ownerMenuService;
				bool									cascadeAction;

				GuiButton*								GetSubMenuHost();
				void									OpenSubMenuInternal();
				void									OnParentLineChanged()override;
				bool									IsAltAvailable()override;
				compositions::IGuiAltActionHost*		GetActivatingAltHost()override;

				void									OnSubMenuWindowOpened(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnSubMenuWindowClosed(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void									OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				virtual IGuiMenuService::Direction		GetSubMenuDirection();
			public:
				GuiMenuButton(IStyleController* _styleController);
				~GuiMenuButton();

				compositions::GuiNotifyEvent			SubMenuOpeningChanged;
				compositions::GuiNotifyEvent			ImageChanged;
				compositions::GuiNotifyEvent			ShortcutTextChanged;

				Ptr<GuiImageData>						GetImage();
				void									SetImage(Ptr<GuiImageData> value);
				const WString&							GetShortcutText();
				void									SetShortcutText(const WString& value);

				bool									IsSubMenuExists();
				GuiMenu*								GetSubMenu();
				void									CreateSubMenu(GuiMenu::IStyleController* subMenuStyleController=0);
				void									SetSubMenu(GuiMenu* value, bool owned);
				void									DestroySubMenu();
				bool									GetOwnedSubMenu();

				bool									GetSubMenuOpening();
				void									SetSubMenuOpening(bool value);

				Size									GetPreferredMenuClientSize();
				void									SetPreferredMenuClientSize(Size value);

				bool									GetCascadeAction();
				void									SetCascadeAction(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUILISTVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUILISTVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiListViewBase;

			namespace list
			{

/***********************************************************************
ListView Base
***********************************************************************/

				class ListViewItemStyleProviderBase: public Object, public GuiSelectableListControl::IItemStyleProvider, public Description<ListViewItemStyleProviderBase>
				{
				public:
					class ListViewItemStyleController : public ItemStyleControllerBase, public Description<ListViewItemStyleController>
					{
					protected:
						GuiSelectableButton*					backgroundButton;
						ListViewItemStyleProviderBase*			listViewItemStyleProvider;

					public:
						ListViewItemStyleController(ListViewItemStyleProviderBase* provider);
						~ListViewItemStyleController();

						bool									GetSelected();
						void									SetSelected(bool value);
					};

				protected:
					GuiListViewBase*							listControl;

				public:
					ListViewItemStyleProviderBase();
					~ListViewItemStyleProviderBase();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					vint										GetItemStyleId(vint itemIndex)override;
					void										SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

			class GuiListViewColumnHeader : public GuiMenuButton, public Description<GuiListViewColumnHeader>
			{
			public:
				enum ColumnSortingState
				{
					NotSorted,
					Ascending,
					Descending,
				};
				
				class IStyleController : public virtual GuiMenuButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void								SetColumnSortingState(ColumnSortingState value)=0;
				};

			protected:
				IStyleController*								styleController;
				ColumnSortingState								columnSortingState;

			public:
				GuiListViewColumnHeader(IStyleController* _styleController);
				~GuiListViewColumnHeader();

				bool											IsAltAvailable()override;

				ColumnSortingState								GetColumnSortingState();
				void											SetColumnSortingState(ColumnSortingState value);
			};

			class GuiListViewBase : public GuiSelectableListControl, public Description<GuiListViewBase>
			{
			public:
				class IStyleProvider : public virtual GuiSelectableListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiListViewColumnHeader::IStyleController*	CreateColumnStyle()=0;
					virtual Color										GetPrimaryTextColor()=0;
					virtual Color										GetSecondaryTextColor()=0;
					virtual Color										GetItemSeparatorColor()=0;
				};

			protected:
				IStyleProvider*									styleProvider;

			public:
				GuiListViewBase(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiListViewBase();

				compositions::GuiItemNotifyEvent				ColumnClicked;
				
				IStyleProvider*									GetListViewStyleProvider();
				Ptr<GuiListControl::IItemStyleProvider>			SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;
			};

/***********************************************************************
ListView ItemStyleProvider
***********************************************************************/

			namespace list
			{
				class ListViewItemStyleProvider : public ListViewItemStyleProviderBase, public Description<ListViewItemStyleProvider>
				{
				public:
					class IListViewItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<IListViewItemView>
					{
					public:
						static const wchar_t* const				Identifier;

						virtual Ptr<GuiImageData>				GetSmallImage(vint itemIndex)=0;
						virtual Ptr<GuiImageData>				GetLargeImage(vint itemIndex)=0;
						virtual WString							GetText(vint itemIndex)=0;
						virtual WString							GetSubItem(vint itemIndex, vint index)=0;

						virtual vint							GetDataColumnCount()=0;
						virtual vint							GetDataColumn(vint index)=0;

						virtual vint							GetColumnCount()=0;
						virtual WString							GetColumnText(vint index)=0;
					};

					class IListViewItemContent : public virtual IDescriptable, public Description<IListViewItemContent>
					{
					public:
						virtual compositions::GuiBoundsComposition*				GetContentComposition()=0;
						virtual compositions::GuiBoundsComposition*				GetBackgroundDecorator()=0;
						virtual void											Install(GuiListViewBase::IStyleProvider* styleProvider, IListViewItemView* view, vint itemIndex)=0;
						virtual void											Uninstall()=0;
					};

					class IListViewItemContentProvider : public virtual IDescriptable, public Description<IListViewItemContentProvider>
					{
					public:
						virtual GuiListControl::IItemCoordinateTransformer*		CreatePreferredCoordinateTransformer()=0;
						virtual GuiListControl::IItemArranger*					CreatePreferredArranger()=0;
						virtual IListViewItemContent*							CreateItemContent(const FontProperties& font)=0;
						virtual void											AttachListControl(GuiListControl* value)=0;
						virtual void											DetachListControl()=0;
					};

					class ListViewContentItemStyleController : public ListViewItemStyleController, public Description<ListViewContentItemStyleController>
					{
					protected:
						ListViewItemStyleProvider*				listViewItemStyleProvider;
						Ptr<IListViewItemContent>				content;
					public:
						ListViewContentItemStyleController(ListViewItemStyleProvider* provider);
						~ListViewContentItemStyleController();

						void									OnUninstalled()override;

						IListViewItemContent*					GetItemContent();
						void									Install(IListViewItemView* view, vint itemIndex);
					};

				protected:

					typedef collections::List<GuiListControl::IItemStyleController*>				ItemStyleList;

					IListViewItemView*							listViewItemView;
					Ptr<IListViewItemContentProvider>			listViewItemContentProvider;
					ItemStyleList								itemStyles;
				public:
					ListViewItemStyleProvider(Ptr<IListViewItemContentProvider> itemContentProvider);
					~ListViewItemStyleProvider();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
					GuiListControl::IItemStyleController*		CreateItemStyle(vint styleId)override;
					void										DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void										Install(GuiListControl::IItemStyleController* style, vint itemIndex)override;
					void										SetStyleIndex(GuiListControl::IItemStyleController* style, vint value)override;

					IListViewItemContentProvider*				GetItemContentProvider();

					const ItemStyleList&						GetCreatedItemStyles();
					bool										IsItemStyleAttachedToListView(GuiListControl::IItemStyleController* itemStyle);

					IListViewItemContent*						GetItemContentFromItemStyleController(GuiListControl::IItemStyleController* itemStyleController);
					GuiListControl::IItemStyleController*		GetItemStyleControllerFromItemContent(IListViewItemContent* itemContent);

					template<typename T>
					T* GetItemContent(GuiListControl::IItemStyleController* itemStyleController)
					{
						return dynamic_cast<T*>(GetItemContentFromItemStyleController(itemStyleController));
					}
				};
			}

/***********************************************************************
ListView ItemContentProvider
***********************************************************************/

			namespace list
			{
				class ListViewBigIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewBigIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size minIconSize, bool fitImage, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
						void											Uninstall()override;
					};

					Size												minIconSize;
					bool												fitImage;
				public:
					ListViewBigIconContentProvider(Size _minIconSize=Size(32, 32), bool _fitImage=true);
					~ListViewBigIconContentProvider();

					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewSmallIconContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewSmallIconContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size minIconSize, bool fitImage, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
						void											Uninstall()override;
					};

					Size												minIconSize;
					bool												fitImage;
				public:
					ListViewSmallIconContentProvider(Size _minIconSize=Size(16, 16), bool _fitImage=true);
					~ListViewSmallIconContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewListContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewListContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;

					public:
						ItemContent(Size minIconSize, bool fitImage, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
						void											Uninstall()override;
					};

					Size												minIconSize;
					bool												fitImage;
				public:
					ListViewListContentProvider(Size _minIconSize=Size(16, 16), bool _fitImage=true);
					~ListViewListContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewTileContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewTileContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						void											RemoveTextElement(vint textRow);
						elements::GuiSolidLabelElement*					CreateTextElement(vint textRow, const FontProperties& font);
						void											ResetTextTable(vint textRows);
					public:
						ItemContent(Size minIconSize, bool fitImage, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
						void											Uninstall()override;
					};

					Size												minIconSize;
					bool												fitImage;
				public:
					ListViewTileContentProvider(Size _minIconSize=Size(32, 32), bool _fitImage=true);
					~ListViewTileContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
				
				class ListViewInformationContentProvider : public Object, public virtual ListViewItemStyleProvider::IListViewItemContentProvider, public Description<ListViewInformationContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::Array<elements::GuiSolidLabelElement*>		DataTextElementArray;
					protected:
						FontProperties									baselineFont;
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						DataTextElementArray							dataTexts;

						elements::GuiSolidBackgroundElement*			bottomLine;
						compositions::GuiBoundsComposition*				bottomLineComposition;

					public:
						ItemContent(Size minIconSize, bool fitImage, const FontProperties& font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
						void											Uninstall()override;
					};

					Size												minIconSize;
					bool												fitImage;
				public:
					ListViewInformationContentProvider(Size _minIconSize=Size(32, 32), bool _fitImage=true);
					~ListViewInformationContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};

/***********************************************************************
ListView ItemContentProvider(Detailed)
***********************************************************************/

				class ListViewColumnItemArranger : public FixedHeightItemArranger, public Description<ListViewColumnItemArranger>
				{
					typedef collections::List<GuiListViewColumnHeader*>					ColumnHeaderButtonList;
					typedef collections::List<compositions::GuiBoundsComposition*>		ColumnHeaderSplitterList;
				public:
					static const vint							SplitterWidth=8;
					
					class IColumnItemViewCallback : public virtual IDescriptable, public Description<IColumnItemViewCallback>
					{
					public:
						virtual void							OnColumnChanged()=0;
					};
					
					class IColumnItemView : public virtual IDescriptable, public Description<IColumnItemView>
					{
					public:
						static const wchar_t* const								Identifier;
						
						virtual bool											AttachCallback(IColumnItemViewCallback* value)=0;
						virtual bool											DetachCallback(IColumnItemViewCallback* value)=0;
						virtual vint											GetColumnCount()=0;
						virtual WString											GetColumnText(vint index)=0;
						virtual vint											GetColumnSize(vint index)=0;
						virtual void											SetColumnSize(vint index, vint value)=0;
						virtual GuiMenu*										GetDropdownPopup(vint index)=0;
						virtual GuiListViewColumnHeader::ColumnSortingState		GetSortingState(vint index)=0;
					};
				protected:
					class ColumnItemViewCallback : public Object, public virtual IColumnItemViewCallback
					{
					protected:
						ListViewColumnItemArranger*				arranger;
					public:
						ColumnItemViewCallback(ListViewColumnItemArranger* _arranger);
						~ColumnItemViewCallback();

						void									OnColumnChanged();
					};

					GuiListViewBase*							listView;
					GuiListViewBase::IStyleProvider*			styleProvider;
					IColumnItemView*							columnItemView;
					Ptr<ColumnItemViewCallback>					columnItemViewCallback;
					compositions::GuiStackComposition*			columnHeaders;
					ColumnHeaderButtonList						columnHeaderButtons;
					ColumnHeaderSplitterList					columnHeaderSplitters;
					bool										splitterDragging;
					vint										splitterLatestX;

					void										ColumnClicked(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnBoundsChanged(vint index, compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					void										ColumnHeaderSplitterMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);

					void										RearrangeItemBounds()override;
					vint										GetWidth()override;
					vint										GetYOffset()override;
					Size										OnCalculateTotalSize()override;
					void										DeleteColumnButtons();
					void										RebuildColumns();
				public:
					ListViewColumnItemArranger();
					~ListViewColumnItemArranger();

					void										AttachListControl(GuiListControl* value)override;
					void										DetachListControl()override;
				};
				
				class ListViewDetailContentProvider
					: public Object
					, public virtual ListViewItemStyleProvider::IListViewItemContentProvider
					, protected virtual ListViewColumnItemArranger::IColumnItemViewCallback
					, public Description<ListViewDetailContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
						typedef collections::List<elements::GuiSolidLabelElement*>		SubItemList;
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						elements::GuiImageFrameElement*					image;
						elements::GuiSolidLabelElement*					text;
						compositions::GuiTableComposition*				textTable;
						SubItemList										subItems;

						GuiListControl::IItemProvider*					itemProvider;
						ListViewColumnItemArranger::IColumnItemView*	columnItemView;

					public:
						ItemContent(Size minIconSize, bool fitImage, const FontProperties& font, GuiListControl::IItemProvider* _itemProvider);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											UpdateSubItemSize();
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
						void											Uninstall()override;
					};

					Size												minIconSize;
					bool												fitImage;
					GuiListControl::IItemProvider*						itemProvider;
					ListViewColumnItemArranger::IColumnItemView*		columnItemView;
					ListViewItemStyleProvider*							listViewItemStyleProvider;

					void												OnColumnChanged()override;
				public:
					ListViewDetailContentProvider(Size _minIconSize=Size(16, 16), bool _fitImage=true);
					~ListViewDetailContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;
				};
			}

/***********************************************************************
ListView
***********************************************************************/

			namespace list
			{
				class ListViewItem;

				class ListViewSubItems : public ItemsBase<WString>
				{
					friend class ListViewItem;
				protected:
					ListViewItem*									owner;
					
					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
				};

				class ListViewItemProvider;

				class ListViewItem : public Object, public Description<ListViewItem>
				{
					friend class ListViewSubItems;
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*							owner;
					ListViewSubItems								subItems;
					Ptr<GuiImageData>								smallImage;
					Ptr<GuiImageData>								largeImage;
					WString											text;
					description::Value								tag;
					
					void											NotifyUpdate();
				public:
					ListViewItem();
					
					ListViewSubItems&								GetSubItems();
					Ptr<GuiImageData>								GetSmallImage();
					void											SetSmallImage(Ptr<GuiImageData> value);
					Ptr<GuiImageData>								GetLargeImage();
					void											SetLargeImage(Ptr<GuiImageData> value);
					const WString&									GetText();
					void											SetText(const WString& value);
					description::Value								GetTag();
					void											SetTag(const description::Value& value);
				};

				class ListViewColumns;
				
				class ListViewColumn : public Object, public Description<ListViewColumn>
				{
					friend class ListViewColumns;
				protected:
					ListViewColumns*								owner;
					WString											text;
					WString											textProperty;
					vint											size;
					GuiMenu*										dropdownPopup;
					GuiListViewColumnHeader::ColumnSortingState		sortingState;
					
					void											NotifyUpdate();
				public:
					ListViewColumn(const WString& _text=L"", vint _size=160);
					
					const WString&									GetText();
					void											SetText(const WString& value);
					const WString&									GetTextProperty();
					void											SetTextProperty(const WString& value);
					vint											GetSize();
					void											SetSize(vint value);
					GuiMenu*										GetDropdownPopup();
					void											SetDropdownPopup(GuiMenu* value);
					GuiListViewColumnHeader::ColumnSortingState		GetSortingState();
					void											SetSortingState(GuiListViewColumnHeader::ColumnSortingState value);
				};

				class ListViewItemProvider;

				class ListViewDataColumns : public ItemsBase<vint>
				{
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*							itemProvider;

					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					ListViewDataColumns();
					~ListViewDataColumns();
				};
				
				class ListViewColumns : public ItemsBase<Ptr<ListViewColumn>>
				{
					friend class ListViewColumn;
					friend class ListViewItemProvider;
				protected:
					ListViewItemProvider*							itemProvider;

					void											AfterInsert(vint index, const Ptr<ListViewColumn>& value)override;
					void											BeforeRemove(vint index, const Ptr<ListViewColumn>& value)override;
					void											NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					ListViewColumns();
					~ListViewColumns();
				};
				
				class ListViewItemProvider
					: public ListProvider<Ptr<ListViewItem>>
					, protected virtual ListViewItemStyleProvider::IListViewItemView
					, protected virtual ListViewColumnItemArranger::IColumnItemView
					, protected GuiListControl::IItemBindingView
					, public Description<ListViewItemProvider>
				{
					friend class ListViewItem;
					friend class ListViewColumns;
					friend class ListViewDataColumns;
					typedef collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					ListViewDataColumns									dataColumns;
					ListViewColumns										columns;
					ColumnItemViewCallbackList							columnItemViewCallbacks;

					void												AfterInsert(vint index, const Ptr<ListViewItem>& value)override;
					void												BeforeRemove(vint index, const Ptr<ListViewItem>& value)override;

					bool												ContainsPrimaryText(vint itemIndex)override;
					WString												GetPrimaryTextViewText(vint itemIndex)override;
					Ptr<GuiImageData>									GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(vint itemIndex)override;
					WString												GetText(vint itemIndex)override;
					WString												GetSubItem(vint itemIndex, vint index)override;
					vint												GetDataColumnCount()override;
					vint												GetDataColumn(vint index)override;

					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint												GetColumnCount()override;
					WString												GetColumnText(vint index)override;
					vint												GetColumnSize(vint index)override;
					void												SetColumnSize(vint index, vint value)override;
					GuiMenu*											GetDropdownPopup(vint index)override;
					GuiListViewColumnHeader::ColumnSortingState			GetSortingState(vint index)override;

					description::Value									GetBindingValue(vint itemIndex)override;
				public:
					ListViewItemProvider();
					~ListViewItemProvider();

					IDescriptable*										RequestView(const WString& identifier)override;
					void												ReleaseView(IDescriptable* view)override;

					ListViewDataColumns&								GetDataColumns();
					ListViewColumns&									GetColumns();
				};
			}
			
			class GuiVirtualListView : public GuiListViewBase, public Description<GuiVirtualListView>
			{
			public:
				GuiVirtualListView(IStyleProvider* _styleProvider, GuiListControl::IItemProvider* _itemProvider);
				~GuiVirtualListView();
				
				virtual bool											ChangeItemStyle(Ptr<list::ListViewItemStyleProvider::IListViewItemContentProvider> contentProvider);
			};
			
			class GuiListView : public GuiVirtualListView, public Description<GuiListView>
			{
			protected:
				list::ListViewItemProvider*								items;
			public:
				GuiListView(IStyleProvider* _styleProvider);
				~GuiListView();
				
				list::ListViewItemProvider&								GetItems();
				list::ListViewDataColumns&								GetDataColumns();
				list::ListViewColumns&									GetColumns();

				Ptr<list::ListViewItem>									GetSelectedItem();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUITREEVIEWCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITREEVIEWCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiVirtualTreeListControl NodeProvider
***********************************************************************/

			namespace tree
			{
				class INodeProvider;
				class INodeRootProvider;

				//-----------------------------------------------------------
				// Callback Interfaces
				//-----------------------------------------------------------

				class INodeProviderCallback : public virtual IDescriptable, public Description<INodeProviderCallback>
				{
				public:
					virtual void					OnAttached(INodeRootProvider* provider)=0;
					virtual void					OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)=0;
					virtual void					OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)=0;
					virtual void					OnItemExpanded(INodeProvider* node)=0;
					virtual void					OnItemCollapsed(INodeProvider* node)=0;
				};

				//-----------------------------------------------------------
				// Provider Interfaces
				//-----------------------------------------------------------

				class INodeProvider : public virtual IDescriptable, public Description<INodeProvider>
				{
				public:
					virtual bool					GetExpanding()=0;
					virtual void					SetExpanding(bool value)=0;
					virtual vint					CalculateTotalVisibleNodes()=0;

					virtual vint					GetChildCount()=0;
					virtual INodeProvider*			GetParent()=0;
					virtual INodeProvider*			GetChild(vint index)=0;
					virtual void					Increase()=0;
					virtual void					Release()=0;
				};
				
				class INodeRootProvider : public virtual IDescriptable, public Description<INodeRootProvider>
				{
				public:
					virtual INodeProvider*			GetRootNode()=0;
					virtual bool					CanGetNodeByVisibleIndex()=0;
					virtual INodeProvider*			GetNodeByVisibleIndex(vint index)=0;
					virtual bool					AttachCallback(INodeProviderCallback* value)=0;
					virtual bool					DetachCallback(INodeProviderCallback* value)=0;
					virtual IDescriptable*			RequestView(const WString& identifier)=0;
					virtual void					ReleaseView(IDescriptable* view)=0;
				};
			}

			namespace tree
			{
				//-----------------------------------------------------------
				// Tree to ListControl (IItemProvider)
				//-----------------------------------------------------------

				class INodeItemView : public virtual GuiListControl::IItemPrimaryTextView, public Description<INodeItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual INodeProvider*			RequestNode(vint index)=0;
					virtual void					ReleaseNode(INodeProvider* node)=0;
					virtual vint					CalculateNodeVisibilityIndex(INodeProvider* node)=0;
				};

				class INodeItemPrimaryTextView : public virtual IDescriptable, public Description<INodeItemPrimaryTextView>
				{
				public:
					static const wchar_t* const		Identifier;
					
					virtual WString					GetPrimaryTextViewText(INodeProvider* node)=0;
				};

				class INodeItemBindingView : public virtual IDescriptable, public Description<INodeItemPrimaryTextView>
				{
				public:
					static const wchar_t* const		Identifier;
					
					virtual description::Value		GetBindingValue(INodeProvider* node)=0;
				};

				class NodeItemProvider
					: public list::ItemProviderBase
					, protected virtual INodeProviderCallback
					, protected virtual INodeItemView
					, public Description<NodeItemProvider>
				{
				protected:
					Ptr<INodeRootProvider>			root;
					INodeItemPrimaryTextView*		nodeItemPrimaryTextView;
					vint							offsetBeforeChildModified;

					INodeProvider*					GetNodeByOffset(INodeProvider* provider, vint offset);
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
					vint							CalculateNodeVisibilityIndexInternal(INodeProvider* node);
					vint							CalculateNodeVisibilityIndex(INodeProvider* node)override;
					
					bool							ContainsPrimaryText(vint itemIndex)override;
					WString							GetPrimaryTextViewText(vint itemIndex)override;
					INodeProvider*					RequestNode(vint index)override;
					void							ReleaseNode(INodeProvider* node)override;
				public:
					NodeItemProvider(Ptr<INodeRootProvider> _root);
					~NodeItemProvider();
					
					Ptr<INodeRootProvider>			GetRoot();
					vint							Count()override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};

				//-----------------------------------------------------------
				// Tree to ListControl (IItemStyleProvider)
				//-----------------------------------------------------------

				class INodeItemStyleProvider;

				class INodeItemStyleController : public virtual GuiListControl::IItemStyleController, public Description<INodeItemStyleController>
				{
				public:
					virtual INodeItemStyleProvider*					GetNodeStyleProvider()=0;
				};
				
				class INodeItemStyleProvider : public virtual IDescriptable, public Description<INodeItemStyleProvider>
				{
				public:
					virtual void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)=0;
					virtual GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()=0;
					virtual void									AttachListControl(GuiListControl* value)=0;
					virtual void									DetachListControl()=0;
					virtual vint									GetItemStyleId(INodeProvider* node)=0;
					virtual INodeItemStyleController*				CreateItemStyle(vint styleId)=0;
					virtual void									DestroyItemStyle(INodeItemStyleController* style)=0;
					virtual void									Install(INodeItemStyleController* style, INodeProvider* node, vint itemIndex)=0;
					virtual void									SetStyleIndex(INodeItemStyleController* style, vint value)=0;
					virtual void									SetStyleSelected(INodeItemStyleController* style, bool value)=0;
				};
				
				class NodeItemStyleProvider : public Object, public virtual GuiSelectableListControl::IItemStyleProvider, public Description<NodeItemStyleProvider>
				{
				protected:
					Ptr<INodeItemStyleProvider>						nodeItemStyleProvider;
					GuiListControl*									listControl;
					INodeItemView*									nodeItemView;
				public:
					NodeItemStyleProvider(Ptr<INodeItemStyleProvider> provider);
					~NodeItemStyleProvider();

					void											AttachListControl(GuiListControl* value)override;
					void											DetachListControl()override;
					vint											GetItemStyleId(vint itemIndex)override;
					GuiListControl::IItemStyleController*			CreateItemStyle(vint styleId)override;
					void											DestroyItemStyle(GuiListControl::IItemStyleController* style)override;
					void											Install(GuiListControl::IItemStyleController* style, vint itemIndex)override;
					void											SetStyleIndex(GuiListControl::IItemStyleController* style, vint value)override;
					void											SetStyleSelected(GuiListControl::IItemStyleController* style, bool value)override;
				};
			}

/***********************************************************************
GuiVirtualTreeListControl Predefined NodeProvider
***********************************************************************/

			namespace tree
			{
				class IMemoryNodeData : public virtual IDescriptable, public Description<IMemoryNodeData>
				{
				};

				class MemoryNodeProvider
					: public Object
					, public virtual INodeProvider
					, public Description<MemoryNodeProvider>
				{
					typedef collections::List<Ptr<MemoryNodeProvider>> ChildList;
					typedef collections::IEnumerator<Ptr<MemoryNodeProvider>> ChildListEnumerator;

				public:
					class NodeCollection : public list::ItemsBase<Ptr<MemoryNodeProvider>>
					{
						friend class MemoryNodeProvider;
					protected:
						MemoryNodeProvider*			ownerProvider;

						void						OnBeforeChildModified(vint start, vint count, vint newCount);
						void						OnAfterChildModified(vint start, vint count, vint newCount);
						bool						QueryInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
						bool						QueryRemove(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						BeforeInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						BeforeRemove(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						AfterInsert(vint index, Ptr<MemoryNodeProvider> const& child)override;
						void						AfterRemove(vint index, vint count)override;

						NodeCollection();
					public:
					};

				protected:
					MemoryNodeProvider*				parent;
					bool							expanding;
					vint							childCount;
					vint							totalVisibleNodeCount;
					vint							offsetBeforeChildModified;
					Ptr<IMemoryNodeData>			data;
					NodeCollection					children;

					virtual INodeProviderCallback*	GetCallbackProxyInternal();
					void							OnChildTotalVisibleNodesChanged(vint offset);
				public:
					MemoryNodeProvider();
					MemoryNodeProvider(const Ptr<IMemoryNodeData>& _data);
					~MemoryNodeProvider();

					Ptr<IMemoryNodeData>			GetData();
					void							SetData(const Ptr<IMemoryNodeData>& value);
					void							NotifyDataModified();
					NodeCollection&					Children();

					bool							GetExpanding()override;
					void							SetExpanding(bool value)override;
					vint							CalculateTotalVisibleNodes()override;

					vint							GetChildCount()override;
					INodeProvider*					GetParent()override;
					INodeProvider*					GetChild(vint index)override;
					void							Increase()override;
					void							Release()override;
				};

				class NodeRootProviderBase : public virtual INodeRootProvider, protected virtual INodeProviderCallback, public Description<NodeRootProviderBase>
				{
					collections::List<INodeProviderCallback*>			callbacks;
				protected:
					void							OnAttached(INodeRootProvider* provider)override;
					void							OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void							OnItemExpanded(INodeProvider* node)override;
					void							OnItemCollapsed(INodeProvider* node)override;
				public:
					NodeRootProviderBase();
					~NodeRootProviderBase();
					
					bool							CanGetNodeByVisibleIndex()override;
					INodeProvider*					GetNodeByVisibleIndex(vint index)override;
					bool							AttachCallback(INodeProviderCallback* value)override;
					bool							DetachCallback(INodeProviderCallback* value)override;
					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;
				};
				
				class MemoryNodeRootProvider
					: public MemoryNodeProvider
					, public NodeRootProviderBase
					, public Description<MemoryNodeRootProvider>
				{
				protected:
					INodeProviderCallback*			GetCallbackProxyInternal()override;
				public:
					MemoryNodeRootProvider();
					~MemoryNodeRootProvider();

					INodeProvider*					GetRootNode()override;
					MemoryNodeProvider*				GetMemoryNode(INodeProvider* node);
				};
			}

/***********************************************************************
GuiVirtualTreeListControl
***********************************************************************/

			class GuiVirtualTreeListControl : public GuiSelectableListControl, protected virtual tree::INodeProviderCallback, public Description<GuiVirtualTreeListControl>
			{
			private:
				void								OnAttached(tree::INodeRootProvider* provider)override;
				void								OnBeforeItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void								OnAfterItemModified(tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void								OnItemExpanded(tree::INodeProvider* node)override;
				void								OnItemCollapsed(tree::INodeProvider* node)override;
			protected:
				tree::NodeItemProvider*				nodeItemProvider;
				tree::INodeItemView*				nodeItemView;
				Ptr<tree::INodeItemStyleProvider>	nodeStyleProvider;

				void								OnItemMouseEvent(compositions::GuiNodeMouseEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemMouseEventArgs& arguments);
				void								OnItemNotifyEvent(compositions::GuiNodeNotifyEvent& nodeEvent, compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
			public:
				GuiVirtualTreeListControl(IStyleProvider* _styleProvider, Ptr<tree::INodeRootProvider> _nodeRootProvider);
				~GuiVirtualTreeListControl();

				compositions::GuiNodeMouseEvent		NodeLeftButtonDown;
				compositions::GuiNodeMouseEvent		NodeLeftButtonUp;
				compositions::GuiNodeMouseEvent		NodeLeftButtonDoubleClick;
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDown;
				compositions::GuiNodeMouseEvent		NodeMiddleButtonUp;
				compositions::GuiNodeMouseEvent		NodeMiddleButtonDoubleClick;
				compositions::GuiNodeMouseEvent		NodeRightButtonDown;
				compositions::GuiNodeMouseEvent		NodeRightButtonUp;
				compositions::GuiNodeMouseEvent		NodeRightButtonDoubleClick;
				compositions::GuiNodeMouseEvent		NodeMouseMove;
				compositions::GuiNodeNotifyEvent	NodeMouseEnter;
				compositions::GuiNodeNotifyEvent	NodeMouseLeave;
				compositions::GuiNodeNotifyEvent	NodeExpanded;
				compositions::GuiNodeNotifyEvent	NodeCollapsed;

				tree::INodeItemView*				GetNodeItemView();
				tree::INodeRootProvider*			GetNodeRootProvider();
				tree::INodeItemStyleProvider*		GetNodeStyleProvider();
				Ptr<tree::INodeItemStyleProvider>	SetNodeStyleProvider(Ptr<tree::INodeItemStyleProvider> styleProvider);
			};

/***********************************************************************
TreeView
***********************************************************************/

			namespace tree
			{
				class ITreeViewItemView : public virtual INodeItemPrimaryTextView, public Description<ITreeViewItemView>
				{
				public:
					static const wchar_t* const		Identifier;

					virtual Ptr<GuiImageData>		GetNodeImage(INodeProvider* node)=0;
					virtual WString					GetNodeText(INodeProvider* node)=0;
				};

				class TreeViewItem : public Object, public virtual IMemoryNodeData, public Description<TreeViewItem>
				{
				public:
					Ptr<GuiImageData>				image;
					WString							text;
					description::Value				tag;

					TreeViewItem();
					TreeViewItem(const Ptr<GuiImageData>& _image, const WString& _text);
				};

				class TreeViewItemRootProvider
					: public MemoryNodeRootProvider
					, protected virtual ITreeViewItemView
					, protected virtual INodeItemBindingView
					, public Description<TreeViewItemRootProvider>
				{
				protected:

					WString							GetPrimaryTextViewText(INodeProvider* node)override;
					Ptr<GuiImageData>				GetNodeImage(INodeProvider* node)override;
					WString							GetNodeText(INodeProvider* node)override;
					description::Value				GetBindingValue(INodeProvider* node)override;
				public:
					TreeViewItemRootProvider();
					~TreeViewItemRootProvider();

					IDescriptable*					RequestView(const WString& identifier)override;
					void							ReleaseView(IDescriptable* view)override;

					Ptr<TreeViewItem>				GetTreeViewData(INodeProvider* node);
					void							SetTreeViewData(INodeProvider* node, Ptr<TreeViewItem> value);
					void							UpdateTreeViewData(INodeProvider* node);
				};
			}
			
			class GuiVirtualTreeView : public GuiVirtualTreeListControl, public Description<GuiVirtualTreeView>
			{
			public:
				class IStyleProvider : public virtual GuiVirtualTreeListControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateItemBackground()=0;
					virtual GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()=0;
					virtual Color										GetTextColor()=0;
				};
			protected:
				IStyleProvider*											styleProvider;
			public:
				GuiVirtualTreeView(IStyleProvider* _styleProvider, Ptr<tree::INodeRootProvider> _nodeRootProvider);
				~GuiVirtualTreeView();

				IStyleProvider*											GetTreeViewStyleProvider();
			};
			
			class GuiTreeView : public GuiVirtualTreeView, public Description<GuiTreeView>
			{
			protected:
				Ptr<tree::TreeViewItemRootProvider>						nodes;
			public:
				GuiTreeView(IStyleProvider* _styleProvider);
				~GuiTreeView();

				Ptr<tree::TreeViewItemRootProvider>						Nodes();

				Ptr<tree::TreeViewItem>									GetSelectedItem();
			};

			namespace tree
			{
				class TreeViewNodeItemStyleProvider
					: public Object
					, public virtual INodeItemStyleProvider
					, protected virtual INodeProviderCallback
					, public Description<TreeViewNodeItemStyleProvider>
				{
				protected:
#pragma warning(push)
#pragma warning(disable:4250)
					class ItemController : public list::ItemStyleControllerBase, public virtual INodeItemStyleController
					{
					protected:
						TreeViewNodeItemStyleProvider*		styleProvider;
						GuiSelectableButton*				backgroundButton;
						GuiSelectableButton*				expandingButton;
						compositions::GuiTableComposition*	table;
						elements::GuiImageFrameElement*		image;
						elements::GuiSolidLabelElement*		text;

						void								SwitchNodeExpanding();
						void								OnBackgroundButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonDoubleClick(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void								OnExpandingButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					public:
						ItemController(TreeViewNodeItemStyleProvider* _styleProvider, Size minIconSize, bool fitImage);

						INodeItemStyleProvider*				GetNodeStyleProvider()override;
						void								Install(INodeProvider* node);

						bool								GetSelected();
						void								SetSelected(bool value);
						void								UpdateExpandingButton(INodeProvider* associatedNode);
					};
#pragma warning(pop)

					GuiVirtualTreeView*						treeControl;
					GuiListControl::IItemStyleProvider*		bindedItemStyleProvider;
					ITreeViewItemView*						treeViewItemView;
					Size									minIconSize;
					bool									fitImage;

				protected:
					ItemController*							GetRelatedController(INodeProvider* node);
					void									UpdateExpandingButton(INodeProvider* node);
					void									OnAttached(INodeRootProvider* provider)override;
					void									OnBeforeItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void									OnAfterItemModified(INodeProvider* parentNode, vint start, vint count, vint newCount)override;
					void									OnItemExpanded(INodeProvider* node)override;
					void									OnItemCollapsed(INodeProvider* node)override;
				public:
					TreeViewNodeItemStyleProvider(Size _minIconSize = Size(16, 16), bool _fitImage = true);
					~TreeViewNodeItemStyleProvider();

					void									BindItemStyleProvider(GuiListControl::IItemStyleProvider* styleProvider)override;
					GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()override;
					void									AttachListControl(GuiListControl* value)override;
					void									DetachListControl()override;
					vint									GetItemStyleId(INodeProvider* node)override;
					INodeItemStyleController*				CreateItemStyle(vint styleId)override;
					void									DestroyItemStyle(INodeItemStyleController* style)override;
					void									Install(INodeItemStyleController* style, INodeProvider* node, vint itemIndex)override;
					void									SetStyleIndex(INodeItemStyleController* style, vint value)override;
					void									SetStyleSelected(INodeItemStyleController* style, bool value)override;
				};
			}
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::tree::MemoryNodeProvider>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUICOMBOCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUICOMBOCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ComboBox Base
***********************************************************************/

			class GuiComboBoxBase : public GuiMenuButton, public Description<GuiComboBoxBase>
			{
			public:
				class ICommandExecutor : public virtual IDescriptable, public Description<ICommandExecutor>
				{
				public:
					virtual void							SelectItem()=0;
				};
				
				class IStyleController : public virtual GuiMenuButton::IStyleController, public Description<IStyleController>
				{
				public:
					virtual void							SetCommandExecutor(ICommandExecutor* value)=0;
					virtual void							OnItemSelected()=0;
				};
			protected:

				class CommandExecutor : public Object, public virtual ICommandExecutor
				{
				protected:
					GuiComboBoxBase*						combo;

				public:
					CommandExecutor(GuiComboBoxBase* _combo);
					~CommandExecutor();

					void									SelectItem()override;
				};

				Ptr<CommandExecutor>						commandExecutor;
				IStyleController*							styleController;

				IGuiMenuService::Direction					GetSubMenuDirection()override;
				virtual void								SelectItem();
				void										OnBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxBase(IStyleController* _styleController);
				~GuiComboBoxBase();

				compositions::GuiNotifyEvent				ItemSelected;
			};

/***********************************************************************
ComboBox with GuiListControl
***********************************************************************/

			class GuiComboBoxListControl : public GuiComboBoxBase, public Description<GuiComboBoxListControl>
			{
			protected:
				GuiSelectableListControl*					containedListControl;
				GuiListControl::IItemPrimaryTextView*		primaryTextView;

				virtual void								DisplaySelectedContent(vint itemIndex);
				void										OnListControlSelectionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiComboBoxListControl(IStyleController* _styleController, GuiSelectableListControl* _containedListControl);
				~GuiComboBoxListControl();

				compositions::GuiNotifyEvent				SelectedIndexChanged;
				
				void										SetFont(const FontProperties& value)override;
				GuiSelectableListControl*					GetContainedListControl();
				
				vint										GetSelectedIndex();
				void										SetSelectedIndex(vint value);
				GuiListControl::IItemProvider*				GetItemProvider();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\GUIDATETIMECONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATETIMECONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIDATETIMECONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
DatePicker
***********************************************************************/

			class GuiDatePicker : public GuiControl, public Description<GuiDatePicker>
			{
			public:
				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual GuiSelectableButton::IStyleController*		CreateDateButtonStyle()=0;
					virtual GuiTextList*								CreateTextList()=0;
					virtual GuiComboBoxListControl::IStyleController*	CreateComboBoxStyle()=0;

					virtual Color										GetBackgroundColor()=0;
					virtual Color										GetPrimaryTextColor()=0;
					virtual Color										GetSecondaryTextColor()=0;
				};

				class StyleController : public Object, public virtual GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					static const vint									DaysOfWeek=7;
					static const vint									DayRows=6;
					static const vint									DayRowStart=2;
					static const vint									YearFirst=1900;
					static const vint									YearLast=2099;

					IStyleProvider*										styleProvider;
					GuiDatePicker*										datePicker;
					DateTime											currentDate;
					Locale												dateLocale;
					compositions::GuiTableComposition*					boundsComposition;
					bool												preventComboEvent;
					bool												preventButtonEvent;

					GuiComboBoxListControl*								comboYear;
					GuiTextList*										listYears;
					GuiComboBoxListControl*								comboMonth;
					GuiTextList*										listMonths;
					collections::Array<elements::GuiSolidLabelElement*>	labelDaysOfWeek;
					collections::Array<GuiSelectableButton*>			buttonDays;
					collections::Array<elements::GuiSolidLabelElement*>	labelDays;
					collections::Array<DateTime>						dateDays;
					Ptr<GuiSelectableButton::GroupController>			dayMutexController;

					void												SetDay(const DateTime& day, vint& index, bool currentMonth);
					void												DisplayMonth(vint year, vint month);
					void												SelectDay(vint day);
					void												comboYearMonth_SelectedIndexChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												buttonDay_SelectedChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					compositions::GuiBoundsComposition*					GetBoundsComposition()override;
					compositions::GuiGraphicsComposition*				GetContainerComposition()override;
					void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
					void												SetText(const WString& value)override;
					void												SetFont(const FontProperties& value)override;
					void												SetVisuallyEnabled(bool value)override;
					
					void												SetDatePicker(GuiDatePicker* _datePicker);
					void												SetDateLocale(const Locale& _dateLocale);
					const DateTime&										GetDate();
					void												SetDate(const DateTime& value, bool forceUpdate=false);
				};

			protected:
				StyleController*										styleController;
				WString													dateFormat;
				Locale													dateLocale;

				void													UpdateText();
				void													NotifyDateChanged();
			public:
				GuiDatePicker(IStyleProvider* _styleProvider);
				~GuiDatePicker();

				compositions::GuiNotifyEvent							DateChanged;
				compositions::GuiNotifyEvent							DateNavigated;
				compositions::GuiNotifyEvent							DateSelected;
				compositions::GuiNotifyEvent							DateFormatChanged;
				compositions::GuiNotifyEvent							DateLocaleChanged;
				
				const DateTime&											GetDate();
				void													SetDate(const DateTime& value);
				const WString&											GetDateFormat();
				void													SetDateFormat(const WString& value);
				const Locale&											GetDateLocale();
				void													SetDateLocale(const Locale& value);

				void													SetText(const WString& value)override;
			};

/***********************************************************************
DateComboBox
***********************************************************************/
			
			class GuiDateComboBox : public GuiComboBoxBase, public Description<GuiDateComboBox>
			{
			protected:
				GuiDatePicker*											datePicker;
				DateTime												selectedDate;
				
				void													UpdateText();
				void													NotifyUpdateSelectedDate();
				void													OnSubMenuOpeningChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateLocaleChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateFormatChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void													datePicker_DateSelected(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiDateComboBox(IStyleController* _styleController, GuiDatePicker* _datePicker);
				~GuiDateComboBox();
				
				compositions::GuiNotifyEvent							SelectedDateChanged;
				
				void													SetFont(const FontProperties& value)override;
				const DateTime&											GetSelectedDate();
				void													SetSelectedDate(const DateTime& value);
				GuiDatePicker*											GetDatePicker();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTGENERALOPERATIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTGENERALOPERATIONS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTGENERALOPERATIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Operations
***********************************************************************/
			
			class ICommonTextEditCallback : public virtual IDescriptable, public Description<ICommonTextEditCallback>
			{
			public:
				struct TextEditPreviewStruct
				{
					TextPos								originalStart;
					TextPos								originalEnd;
					WString								originalText;
					WString								inputText;
					vuint								editVersion;
					bool								keyInput;

					TextEditPreviewStruct()
						:editVersion(0)
						,keyInput(false)
					{
					}
				};

				struct TextEditNotifyStruct
				{
					TextPos								originalStart;
					TextPos								originalEnd;
					WString								originalText;
					TextPos								inputStart;
					TextPos								inputEnd;
					WString								inputText;
					vuint								editVersion;
					bool								keyInput;

					TextEditNotifyStruct()
						:editVersion(0)
						,keyInput(false)
					{
					}
				};
				
				struct TextCaretChangedStruct
				{
					TextPos								oldBegin;
					TextPos								oldEnd;
					TextPos								newBegin;
					TextPos								newEnd;
					vuint								editVersion;

					TextCaretChangedStruct()
						:editVersion(0)
					{
					}
				};

				virtual void							Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock, compositions::GuiGraphicsComposition* ownerComposition, vuint editVersion)=0;
				virtual void							Detach()=0;
				virtual void							TextEditPreview(TextEditPreviewStruct& arguments)=0;
				virtual void							TextEditNotify(const TextEditNotifyStruct& arguments)=0;
				virtual void							TextCaretChanged(const TextCaretChangedStruct& arguments)=0;
				virtual void							TextEditFinished(vuint editVersion)=0;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTCOLORIZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOLORIZER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiTextBoxColorizerBase
***********************************************************************/
			
			class GuiTextBoxColorizerBase : public Object, public virtual ICommonTextEditCallback
			{
			public:
				typedef collections::Array<elements::text::ColorEntry>			ColorArray;
			protected:
				elements::GuiColorizedTextElement*			element;
				SpinLock*									elementModifyLock;
				volatile vint								colorizedLineCount;
				volatile bool								isColorizerRunning;
				volatile bool								isFinalizing;
				SpinLock									colorizerRunningEvent;

				static void									ColorizerThreadProc(void* argument);

				void										StartColorizer();
				void										StopColorizer(bool forever);
				void										StopColorizerForever();
			public:
				GuiTextBoxColorizerBase();
				~GuiTextBoxColorizerBase();

				void										Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void										Detach()override;
				void										TextEditPreview(TextEditPreviewStruct& arguments)override;
				void										TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void										TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void										TextEditFinished(vuint editVersion)override;
				void										RestartColorizer();

				virtual vint								GetLexerStartState()=0;
				virtual vint								GetContextStartState()=0;
				virtual void								ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, vuint32_t* colors, vint length, vint& lexerState, vint& contextState)=0;
				virtual const ColorArray&					GetColors()=0;
			};

/***********************************************************************
GuiTextBoxRegexColorizer
***********************************************************************/

			class GuiTextBoxRegexColorizer : public GuiTextBoxColorizerBase
			{
			protected:
				Ptr<regex::RegexLexer>										lexer;
				Ptr<regex::RegexLexerColorizer>								colorizer;
				ColorArray													colors;

				elements::text::ColorEntry									defaultColor;
				collections::List<WString>									tokenRegexes;
				collections::List<elements::text::ColorEntry>				tokenColors;
				collections::List<elements::text::ColorEntry>				extraTokenColors;

				static void													ColorizerProc(void* argument, vint start, vint length, vint token);
			public:
				GuiTextBoxRegexColorizer();
				~GuiTextBoxRegexColorizer();

				elements::text::ColorEntry									GetDefaultColor();
				collections::List<WString>&									GetTokenRegexes();
				collections::List<elements::text::ColorEntry>&				GetTokenColors();
				collections::List<elements::text::ColorEntry>&				GetExtraTokenColors();
				vint														GetExtraTokenIndexStart();
				
				bool														SetDefaultColor(elements::text::ColorEntry value);
				vint														AddToken(const WString& regex, elements::text::ColorEntry color);
				vint														AddExtraToken(elements::text::ColorEntry color);
				void														ClearTokens();
				void														Setup();
				virtual void												ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState);

				vint														GetLexerStartState()override;
				vint														GetContextStartState()override;
				void														ColorizeLineWithCRLF(vint lineIndex, const wchar_t* text, vuint32_t* colors, vint length, vint& lexerState, vint& contextState)override;
				const ColorArray&											GetColors()override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTAUTOCOMPLETE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTAUTOCOMPLETE
#define VCZH_PRESENTATION_CONTROLS_GUITEXTAUTOCOMPLETE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiTextBoxAutoCompleteBase
***********************************************************************/
			
			class GuiTextBoxAutoCompleteBase : public Object, public virtual ICommonTextEditCallback
			{
			public:
				struct AutoCompleteItem
				{
					description::Value								tag;
					WString											text;
				};

				class IAutoCompleteControlProvider : public virtual Interface
				{
				public:
					virtual GuiControl*								GetAutoCompleteControl() = 0;

					virtual GuiSelectableListControl*				GetListControl() = 0;

					virtual void									SetSortedContent(const collections::List<AutoCompleteItem>& items) = 0;

					virtual vint									GetItemCount() = 0;

					virtual WString									GetItemText(vint index) = 0;
				};

				class TextListControlProvider : public Object, public virtual IAutoCompleteControlProvider
				{
				protected:
					GuiTextList*									autoCompleteList;

				public:
					TextListControlProvider(GuiTextList::IStyleProvider* styleProvider = nullptr);
					~TextListControlProvider();

					GuiControl*										GetAutoCompleteControl()override;
					GuiSelectableListControl*						GetListControl()override;
					void											SetSortedContent(const collections::List<AutoCompleteItem>& items)override;
					vint											GetItemCount()override;
					WString											GetItemText(vint index)override;
				};

			protected:
				elements::GuiColorizedTextElement*					element;
				SpinLock*											elementModifyLock;
				compositions::GuiGraphicsComposition*				ownerComposition;
				GuiPopup*											autoCompletePopup;
				Ptr<IAutoCompleteControlProvider>					autoCompleteControlProvider;
				TextPos												autoCompleteStartPosition;

				bool												IsPrefix(const WString& prefix, const WString& candidate);
			public:
				GuiTextBoxAutoCompleteBase(Ptr<IAutoCompleteControlProvider> _autoCompleteControlProvider = nullptr);
				~GuiTextBoxAutoCompleteBase();

				void												Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void												Detach()override;
				void												TextEditPreview(TextEditPreviewStruct& arguments)override;
				void												TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void												TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void												TextEditFinished(vuint editVersion)override;

				bool												IsListOpening();
				void												OpenList(TextPos startPosition);
				void												CloseList();
				void												SetListContent(const collections::List<AutoCompleteItem>& items);
				TextPos												GetListStartPosition();
				bool												SelectPreviousListItem();
				bool												SelectNextListItem();
				bool												ApplySelectedListItem();
				WString												GetSelectedListItem();
				void												HighlightList(const WString& editingText);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\EDITORCALLBACK\GUITEXTUNDOREDO.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO
#define VCZH_PRESENTATION_CONTROLS_GUITEXTUNDOREDO


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

			class GuiTextBoxCommonInterface;

/***********************************************************************
Undo Redo
***********************************************************************/

			class GuiGeneralUndoRedoProcessor : public Object
			{
			protected:
				class IEditStep : public Interface
				{
				public:
					virtual void							Undo()=0;
					virtual void							Redo()=0;
				};
				friend class collections::ArrayBase<Ptr<IEditStep>>;

			protected:
				collections::List<Ptr<IEditStep>>			steps;
				vint										firstFutureStep;
				vint										savedStep;
				bool										performingUndoRedo;

				void										PushStep(Ptr<IEditStep> step);
			public:
				GuiGeneralUndoRedoProcessor();
				~GuiGeneralUndoRedoProcessor();

				bool										CanUndo();
				bool										CanRedo();
				void										ClearUndoRedo();
				bool										GetModified();
				void										NotifyModificationSaved();
				bool										Undo();
				bool										Redo();
			};

/***********************************************************************
Undo Redo (Text)
***********************************************************************/

			class GuiTextBoxUndoRedoProcessor : public GuiGeneralUndoRedoProcessor, public ICommonTextEditCallback
			{
			protected:
				class EditStep : public Object, public IEditStep
				{
				public:
					GuiTextBoxUndoRedoProcessor*			processor;
					TextEditNotifyStruct					arguments;
					
					void									Undo();
					void									Redo();
				};

				compositions::GuiGraphicsComposition*		ownerComposition;
			public:
				GuiTextBoxUndoRedoProcessor();
				~GuiTextBoxUndoRedoProcessor();

				void										Attach(elements::GuiColorizedTextElement* element, SpinLock& elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void										Detach()override;
				void										TextEditPreview(TextEditPreviewStruct& arguments)override;
				void										TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void										TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void										TextEditFinished(vuint editVersion)override;
			};

/***********************************************************************
Undo Redo (Document)
***********************************************************************/

			class GuiDocumentUndoRedoProcessor : public GuiGeneralUndoRedoProcessor
			{
			public:
				struct ReplaceModelStruct
				{
					TextPos									originalStart;
					TextPos									originalEnd;
					Ptr<DocumentModel>						originalModel;
					TextPos									inputStart;
					TextPos									inputEnd;
					Ptr<DocumentModel>						inputModel;

					ReplaceModelStruct()
					{
					}
				};

				struct RenameStyleStruct
				{
					WString									oldStyleName;
					WString									newStyleName;

					RenameStyleStruct()
					{
					}
				};

				struct SetAlignmentStruct
				{
					vint									start;
					vint									end;
					collections::Array<Nullable<Alignment>>	originalAlignments;
					collections::Array<Nullable<Alignment>>	inputAlignments;
				};

			protected:
				elements::GuiDocumentElement*				element;
				compositions::GuiGraphicsComposition*		ownerComposition;
				
				class ReplaceModelStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					ReplaceModelStruct						arguments;
					
					void									Undo();
					void									Redo();
				};

				class RenameStyleStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					RenameStyleStruct						arguments;
					
					void									Undo();
					void									Redo();
				};

				class SetAlignmentStep : public Object, public IEditStep
				{
				public:
					GuiDocumentUndoRedoProcessor*			processor;
					Ptr<SetAlignmentStruct>					arguments;
					
					void									Undo();
					void									Redo();
				};
			public:

				GuiDocumentUndoRedoProcessor();
				~GuiDocumentUndoRedoProcessor();

				void										Setup(elements::GuiDocumentElement* _element, compositions::GuiGraphicsComposition* _ownerComposition);
				void										OnReplaceModel(const ReplaceModelStruct& arguments);
				void										OnRenameStyle(const RenameStyleStruct& arguments);
				void										OnSetAlignment(Ptr<SetAlignmentStruct> arguments);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\GUITEXTCOMMONINTERFACE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCOMMONINTERFACE


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
Common Interface
***********************************************************************/

			class GuiTextBoxCommonInterface abstract : public Description<GuiTextBoxCommonInterface>
			{
			protected:
				class ICallback : public virtual IDescriptable, public Description<ICallback>
				{
				public:
					virtual TextPos									GetLeftWord(TextPos pos)=0;
					virtual TextPos									GetRightWord(TextPos pos)=0;
					virtual void									GetWord(TextPos pos, TextPos& begin, TextPos& end)=0;
					virtual vint									GetPageRows()=0;
					virtual bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)=0;
					virtual void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)=0;
					virtual void									ScrollToView(Point point)=0;
					virtual vint									GetTextMargin()=0;
				};

				class DefaultCallback : public Object, public ICallback, public Description<DefaultCallback>
				{
				protected:
					elements::GuiColorizedTextElement*				textElement;
					compositions::GuiGraphicsComposition*			textComposition;
					bool											readonly;
				public:
					DefaultCallback(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition);
					~DefaultCallback();

					TextPos											GetLeftWord(TextPos pos)override;
					TextPos											GetRightWord(TextPos pos)override;
					void											GetWord(TextPos pos, TextPos& begin, TextPos& end)override;
					vint											GetPageRows()override;
					bool											BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
				};
			private:
				elements::GuiColorizedTextElement*					textElement;
				compositions::GuiGraphicsComposition*				textComposition;
				vuint												editVersion;
				GuiControl*											textControl;
				ICallback*											callback;
				bool												dragging;
				bool												readonly;
				Ptr<GuiTextBoxColorizerBase>						colorizer;
				Ptr<GuiTextBoxAutoCompleteBase>						autoComplete;
				Ptr<GuiTextBoxUndoRedoProcessor>					undoRedoProcessor;

				SpinLock											elementModifyLock;
				collections::List<Ptr<ICommonTextEditCallback>>		textEditCallbacks;
				Ptr<compositions::GuiShortcutKeyManager>			internalShortcutKeyManager;
				bool												preventEnterDueToAutoComplete;

				void												UpdateCaretPoint();
				void												Move(TextPos pos, bool shift);
				void												Modify(TextPos start, TextPos end, const WString& input, bool asKeyInput);
				bool												ProcessKey(vint code, bool shift, bool ctrl);
					
				void												OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void												OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void												OnLeftButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void												OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void												OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);

			protected:

				void												Install(elements::GuiColorizedTextElement* _textElement, compositions::GuiGraphicsComposition* _textComposition, GuiControl* _textControl);
				ICallback*											GetCallback();
				void												SetCallback(ICallback* value);
				bool												AttachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				bool												DetachTextEditCallback(Ptr<ICommonTextEditCallback> value);
				void												AddShortcutCommand(vint key, const Func<void()>& eventHandler);
				elements::GuiColorizedTextElement*					GetTextElement();
				void												UnsafeSetText(const WString& value);

			public:
				GuiTextBoxCommonInterface();
				~GuiTextBoxCommonInterface();

				compositions::GuiNotifyEvent						SelectionChanged;

				//================ clipboard operations

				bool												CanCut();
				bool												CanCopy();
				bool												CanPaste();
				bool												Cut();
				bool												Copy();
				bool												Paste();

				//================ editing control

				bool												GetReadonly();
				void												SetReadonly(bool value);

				//================ text operations

				void												SelectAll();
				void												Select(TextPos begin, TextPos end);
				WString												GetSelectionText();
				void												SetSelectionText(const WString& value);
				void												SetSelectionTextAsKeyInput(const WString& value);
				
				WString												GetRowText(vint row);
				WString												GetFragmentText(TextPos start, TextPos end);

				TextPos												GetCaretBegin();
				TextPos												GetCaretEnd();
				TextPos												GetCaretSmall();
				TextPos												GetCaretLarge();

				//================ position query

				vint												GetRowWidth(vint row);
				vint												GetRowHeight();
				vint												GetMaxWidth();
				vint												GetMaxHeight();
				TextPos												GetTextPosFromPoint(Point point);
				Point												GetPointFromTextPos(TextPos pos);
				Rect												GetRectFromTextPos(TextPos pos);
				TextPos												GetNearestTextPos(Point point);

				//================ colorizing

				Ptr<GuiTextBoxColorizerBase>						GetColorizer();
				void												SetColorizer(Ptr<GuiTextBoxColorizerBase> value);

				//================ auto complete

				Ptr<GuiTextBoxAutoCompleteBase>						GetAutoComplete();
				void												SetAutoComplete(Ptr<GuiTextBoxAutoCompleteBase> value);

				//================ undo redo control

				vuint												GetEditVersion();
				bool												CanUndo();
				bool												CanRedo();
				void												ClearUndoRedo();
				bool												GetModified();
				void												NotifyModificationSaved();
				bool												Undo();
				bool												Redo();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\GUITEXTCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUITEXTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
MultilineTextBox
***********************************************************************/

			class GuiMultilineTextBox : public GuiScrollView, public GuiTextBoxCommonInterface, public Description<GuiMultilineTextBox>
			{
			public:
				static const vint							TextMargin=3;

				class StyleController : public GuiScrollView::StyleController, public Description<StyleController>
				{
				protected:
					elements::GuiColorizedTextElement*			textElement;
					compositions::GuiBoundsComposition*			textComposition;
					GuiMultilineTextBox*						textBox;
					Ptr<GuiTextBoxCommonInterface::ICallback>	defaultCallback;

				public:
					StyleController(GuiScrollView::IStyleProvider* styleProvider);
					~StyleController();

					void									Initialize(GuiMultilineTextBox* control);
					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					void									SetViewPosition(Point value);
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;

					WString									GetText();
					void									SetText(const WString& value)override;
					void									SetFont(const FontProperties& value)override;
					void									SetVisuallyEnabled(bool value)override;
				};

			protected:
				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiMultilineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiMultilineTextBox* _textControl);

					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};

			protected:
				StyleController*							styleController;

				void										CalculateViewAndSetScroll();
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				Size										QueryFullSize()override;
				void										UpdateView(Rect viewBounds)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiMultilineTextBox(GuiMultilineTextBox::IStyleProvider* styleProvider);
				~GuiMultilineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
			};

/***********************************************************************
SinglelineTextBox
***********************************************************************/
			
			class GuiSinglelineTextBox : public GuiControl, public GuiTextBoxCommonInterface, public Description<GuiSinglelineTextBox>
			{
			public:
				static const vint							TextMargin=3;
				
				class IStyleProvider : public virtual GuiControl::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* background)=0;
				};

				class StyleController : public Object, public GuiControl::IStyleController, public Description<StyleController>
				{
				protected:
					Ptr<IStyleProvider>							styleProvider;
					compositions::GuiBoundsComposition*			boundsComposition;
					compositions::GuiGraphicsComposition*		containerComposition;

					GuiSinglelineTextBox*						textBox;
					elements::GuiColorizedTextElement*			textElement;
					compositions::GuiTableComposition*			textCompositionTable;
					compositions::GuiCellComposition*			textComposition;
					Ptr<GuiTextBoxCommonInterface::ICallback>	defaultCallback;

				public:
					StyleController(IStyleProvider* _styleProvider);
					~StyleController();

					void									SetTextBox(GuiSinglelineTextBox* control);
					void									RearrangeTextElement();
					compositions::GuiBoundsComposition*		GetBoundsComposition();
					compositions::GuiGraphicsComposition*	GetContainerComposition();
					void									SetFocusableComposition(compositions::GuiGraphicsComposition* value);

					WString									GetText();
					void									SetText(const WString& value);
					void									SetFont(const FontProperties& value);
					void									SetVisuallyEnabled(bool value);

					elements::GuiColorizedTextElement*		GetTextElement();
					compositions::GuiGraphicsComposition*	GetTextComposition();
					void									SetViewPosition(Point value);
				};
				
			protected:
				class TextElementOperatorCallback : public GuiTextBoxCommonInterface::DefaultCallback, public Description<TextElementOperatorCallback>
				{
				protected:
					GuiSinglelineTextBox*					textControl;
					StyleController*						textController;
				public:
					TextElementOperatorCallback(GuiSinglelineTextBox* _textControl);

					bool									BeforeModify(TextPos start, TextPos end, const WString& originalText, WString& inputText)override;
					void									AfterModify(TextPos originalStart, TextPos originalEnd, const WString& originalText, TextPos inputStart, TextPos inputEnd, const WString& inputText)override;
					void									ScrollToView(Point point)override;
					vint									GetTextMargin()override;
				};
			protected:
				StyleController*							styleController;
				
				void										OnRenderTargetChanged(elements::IGuiGraphicsRenderTarget* renderTarget)override;
				void										OnBoundsMouseButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
			public:
				GuiSinglelineTextBox(GuiSinglelineTextBox::IStyleProvider* styleProvider);
				~GuiSinglelineTextBox();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				wchar_t										GetPasswordChar();
				void										SetPasswordChar(wchar_t value);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\GUIDOCUMENTVIEWER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDOCUMENTVIEWER
#define VCZH_PRESENTATION_CONTROLS_GUIDOCUMENTVIEWER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiDocumentCommonInterface
***********************************************************************/
			
			class GuiDocumentCommonInterface abstract : public Description<GuiDocumentCommonInterface>
			{
			public:
				enum EditMode
				{
					ViewOnly,
					Selectable,
					Editable,
				};
			protected:
				Ptr<DocumentModel>							baselineDocument;
				GuiControl*									documentControl;
				elements::GuiDocumentElement*				documentElement;
				compositions::GuiBoundsComposition*			documentComposition;
				Ptr<DocumentHyperlinkRun>					activeHyperlink;
				vint										activeHyperlinkParagraph;
				bool										dragging;
				EditMode									editMode;

				Ptr<GuiDocumentUndoRedoProcessor>			undoRedoProcessor;
				Ptr<compositions::GuiShortcutKeyManager>	internalShortcutKeyManager;

				void										UpdateCaretPoint();
				void										Move(TextPos caret, bool shift, bool frontSide);
				bool										ProcessKey(vint code, bool shift, bool ctrl);
				void										InstallDocumentViewer(GuiControl* _sender, compositions::GuiGraphicsComposition* _container);
				void										SetActiveHyperlink(Ptr<DocumentHyperlinkRun> hyperlink, vint paragraphIndex=-1);
				void										ActivateActiveHyperlink(bool activate);
				void										AddShortcutCommand(vint key, const Func<void()>& eventHandler);
				void										EditTextInternal(TextPos begin, TextPos end, const Func<void(TextPos, TextPos, vint&, vint&)>& editor);
				void										EditStyleInternal(TextPos begin, TextPos end, const Func<void(TextPos, TextPos)>& editor);

				void										OnCaretNotify(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnKeyDown(compositions::GuiGraphicsComposition* sender, compositions::GuiKeyEventArgs& arguments);
				void										OnCharInput(compositions::GuiGraphicsComposition* sender, compositions::GuiCharEventArgs& arguments);
				void										OnMouseMove(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
				void										OnMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				virtual Point								GetDocumentViewPosition();
				virtual void								EnsureRectVisible(Rect bounds);
			public:
				GuiDocumentCommonInterface(Ptr<DocumentModel> _baselineDocument);
				~GuiDocumentCommonInterface();

				compositions::GuiNotifyEvent				ActiveHyperlinkChanged;
				compositions::GuiNotifyEvent				ActiveHyperlinkExecuted;

				compositions::GuiNotifyEvent				SelectionChanged;
				
				Ptr<DocumentModel>							GetDocument();
				void										SetDocument(Ptr<DocumentModel> value);

				//================ caret operations

				TextPos										GetCaretBegin();
				TextPos										GetCaretEnd();
				void										SetCaret(TextPos begin, TextPos end);
				TextPos										CalculateCaretFromPoint(Point point);
				Rect										GetCaretBounds(TextPos caret, bool frontSide);

				//================ editing operations

				void										NotifyParagraphUpdated(vint index, vint oldCount, vint newCount, bool updatedText);
				void										EditRun(TextPos begin, TextPos end, Ptr<DocumentModel> model);
				void										EditText(TextPos begin, TextPos end, bool frontSide, const collections::Array<WString>& text);
				void										EditStyle(TextPos begin, TextPos end, Ptr<DocumentStyleProperties> style);
				void										EditImage(TextPos begin, TextPos end, Ptr<GuiImageData> image);
				void										EditHyperlink(vint paragraphIndex, vint begin, vint end, const WString& reference, const WString& normalStyleName=DocumentModel::NormalLinkStyleName, const WString& activeStyleName=DocumentModel::ActiveLinkStyleName);
				void										RemoveHyperlink(vint paragraphIndex, vint begin, vint end);
				void										EditStyleName(TextPos begin, TextPos end, const WString& styleName);
				void										RemoveStyleName(TextPos begin, TextPos end);
				void										RenameStyle(const WString& oldStyleName, const WString& newStyleName);
				void										ClearStyle(TextPos begin, TextPos end);
				Ptr<DocumentStyleProperties>				SummarizeStyle(TextPos begin, TextPos end);
				void										SetParagraphAlignment(TextPos begin, TextPos end, const collections::Array<Nullable<Alignment>>& alignments);

				//================ editing control

				WString										GetActiveHyperlinkReference();
				EditMode									GetEditMode();
				void										SetEditMode(EditMode value);

				//================ selection operations

				void										SelectAll();
				WString										GetSelectionText();
				void										SetSelectionText(const WString& value);
				Ptr<DocumentModel>							GetSelectionModel();
				void										SetSelectionModel(Ptr<DocumentModel> value);

				//================ clipboard operations

				bool										CanCut();
				bool										CanCopy();
				bool										CanPaste();
				bool										Cut();
				bool										Copy();
				bool										Paste();

				//================ undo redo control

				bool										CanUndo();
				bool										CanRedo();
				void										ClearUndoRedo();
				bool										GetModified();
				void										NotifyModificationSaved();
				bool										Undo();
				bool										Redo();
			};

/***********************************************************************
GuiDocumentViewer
***********************************************************************/
			
			class GuiDocumentViewer : public GuiScrollContainer, public GuiDocumentCommonInterface, public Description<GuiDocumentViewer>
			{
			public:
				class IStyleProvider : public virtual GuiScrollContainer::IStyleProvider, public Description<IStyleProvider>
				{
				public:
					virtual Ptr<DocumentModel>				GetBaselineDocument() = 0;
				};
			protected:

				Point										GetDocumentViewPosition()override;
				void										EnsureRectVisible(Rect bounds)override;
			public:
				GuiDocumentViewer(GuiDocumentViewer::IStyleProvider* styleProvider);
				~GuiDocumentViewer();

				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};

/***********************************************************************
GuiDocumentViewer
***********************************************************************/
			
			class GuiDocumentLabel : public GuiControl, public GuiDocumentCommonInterface, public Description<GuiDocumentLabel>
			{
			public:
				class IStyleController : public virtual GuiControl::IStyleController, public Description<IStyleController>
				{
				public:
					virtual Ptr<DocumentModel>				GetBaselineDocument() = 0;
				};
			public:
				GuiDocumentLabel(GuiDocumentLabel::IStyleController* styleController);
				~GuiDocumentLabel();
				
				const WString&								GetText()override;
				void										SetText(const WString& value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDINTERFACES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDINTERFACES
#define VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDINTERFACES


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{

/***********************************************************************
Datagrid Interfaces
***********************************************************************/

				class IDataVisualizerFactory;
				class IDataVisualizer;
				class IDataEditorCallback;
				class IDataEditorFactory;
				class IDataEditor;
				class IDataProviderCommandExecutor;
				class IDataProvider;

				class IDataVisualizerFactory : public virtual IDescriptable, public Description<IDataVisualizerFactory>
				{
				public:
					virtual Ptr<IDataVisualizer>						CreateVisualizer(const FontProperties& font, GuiListViewBase::IStyleProvider* styleProvider)=0;
				};

				class IDataVisualizer : public virtual IDescriptable, public Description<IDataVisualizer>
				{
				public:
					virtual IDataVisualizerFactory*						GetFactory()=0;

					virtual compositions::GuiBoundsComposition*			GetBoundsComposition()=0;

					virtual void										BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)=0;

					virtual IDataVisualizer*							GetDecoratedDataVisualizer()=0;

					virtual void										SetSelected(bool value)=0;

					template<typename T>
					T* GetVisualizer()
					{
						IDataVisualizer* visualizer=this;
						while(visualizer)
						{
							T* result=dynamic_cast<T*>(visualizer);
							if(result) return result;
							visualizer=visualizer->GetDecoratedDataVisualizer();
						}
						return 0;
					};
				};

				class IDataEditorCallback : public virtual IDescriptable, public Description<IDataEditorCallback>
				{
				public:
					virtual void										RequestSaveData()=0;
				};

				class IDataEditorFactory : public virtual IDescriptable, public Description<IDataEditorFactory>
				{
				public:
					virtual Ptr<IDataEditor>							CreateEditor(IDataEditorCallback* callback)=0;
				};

				class IDataEditor : public virtual IDescriptable, public Description<IDataEditor>
				{
				public:
					virtual IDataEditorFactory*							GetFactory()=0;

					virtual compositions::GuiBoundsComposition*			GetBoundsComposition()=0;

					virtual void										BeforeEditCell(IDataProvider* dataProvider, vint row, vint column)=0;

					virtual void										ReinstallEditor()=0;
				};

				class IDataProviderCommandExecutor : public virtual IDescriptable, public Description<IDataProviderCommandExecutor>
				{
				public:
					virtual void										OnDataProviderColumnChanged()=0;

					virtual void										OnDataProviderItemModified(vint start, vint count, vint newCount)=0;
				};

				class IDataProvider : public virtual IDescriptable, public Description<IDataProvider>
				{
				public:
					static const wchar_t* const							Identifier;
					
					virtual void										SetCommandExecutor(IDataProviderCommandExecutor* value)=0;
					virtual vint										GetColumnCount()=0;
					virtual WString										GetColumnText(vint column)=0;
					virtual vint										GetColumnSize(vint column)=0;
					virtual void										SetColumnSize(vint column, vint value)=0;
					virtual GuiMenu*									GetColumnPopup(vint column)=0;
					virtual bool										IsColumnSortable(vint column)=0;
					virtual void										SortByColumn(vint column, bool ascending)=0;
					virtual vint										GetSortedColumn()=0;
					virtual bool										IsSortOrderAscending()=0;
					
					virtual vint										GetRowCount()=0;
					virtual Ptr<GuiImageData>							GetRowLargeImage(vint row)=0;
					virtual Ptr<GuiImageData>							GetRowSmallImage(vint row)=0;
					virtual vint										GetCellSpan(vint row, vint column)=0;
					virtual WString										GetCellText(vint row, vint column)=0;
					virtual IDataVisualizerFactory*						GetCellDataVisualizerFactory(vint row, vint column)=0;
					virtual void										VisualizeCell(vint row, vint column, IDataVisualizer* dataVisualizer)=0;
					virtual IDataEditorFactory*							GetCellDataEditorFactory(vint row, vint column)=0;
					virtual void										BeforeEditCell(vint row, vint column, IDataEditor* dataEditor)=0;
					virtual void										SaveCellData(vint row, vint column, IDataEditor* dataEditor)=0;
				};

/***********************************************************************
DataSource Extensions
***********************************************************************/

				class IStructuredDataFilterCommandExecutor : public virtual IDescriptable, public Description<IStructuredDataFilterCommandExecutor>
				{
				public:
					virtual void										OnFilterChanged()=0;
				};

				class IStructuredDataFilter : public virtual IDescriptable, public Description<IStructuredDataFilter>
				{
				public:
					virtual void										SetCommandExecutor(IStructuredDataFilterCommandExecutor* value)=0;
					virtual bool										Filter(vint row)=0;
				};

				class IStructuredDataSorter : public virtual IDescriptable, public Description<IStructuredDataSorter>
				{
				public:
					virtual vint										Compare(vint row1, vint row2)=0;
				};

				class IStructuredColumnProvider : public virtual IDescriptable, public Description<IStructuredColumnProvider>
				{
				public:
					virtual WString										GetText()=0;
					virtual vint										GetSize()=0;
					virtual void										SetSize(vint value)=0;
					virtual GuiListViewColumnHeader::ColumnSortingState	GetSortingState()=0;
					virtual void										SetSortingState(GuiListViewColumnHeader::ColumnSortingState value)=0;
					virtual GuiMenu*									GetPopup()=0;
					virtual Ptr<IStructuredDataFilter>					GetInherentFilter()=0;
					virtual Ptr<IStructuredDataSorter>					GetInherentSorter()=0;
					
					virtual WString										GetCellText(vint row)=0;
					virtual IDataVisualizerFactory*						GetCellDataVisualizerFactory(vint row)=0;
					virtual void										VisualizeCell(vint row, IDataVisualizer* dataVisualizer)=0;
					virtual IDataEditorFactory*							GetCellDataEditorFactory(vint row)=0;
					virtual void										BeforeEditCell(vint row, IDataEditor* dataEditor)=0;
					virtual void										SaveCellData(vint row, IDataEditor* dataEditor)=0;
				};

				class IStructuredDataProvider : public virtual IDescriptable, public Description<IStructuredDataProvider>
				{
				public:
					virtual void										SetCommandExecutor(IDataProviderCommandExecutor* value)=0;
					virtual vint										GetColumnCount()=0;
					virtual vint										GetRowCount()=0;
					virtual IStructuredColumnProvider*					GetColumn(vint column)=0;
					virtual Ptr<GuiImageData>							GetRowLargeImage(vint row)=0;
					virtual Ptr<GuiImageData>							GetRowSmallImage(vint row)=0;
				};
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDSTRUCTURED.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATASTRUCTURED
#define VCZH_PRESENTATION_CONTROLS_GUIDATASTRUCTURED


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{

/***********************************************************************
Filter Extensions
***********************************************************************/

				class StructuredDataFilterBase : public Object, public virtual IStructuredDataFilter, public Description<StructuredDataFilterBase>
				{
				protected:
					IStructuredDataFilterCommandExecutor*				commandExecutor;

					void												InvokeOnFilterChanged();
				public:
					StructuredDataFilterBase();

					void												SetCommandExecutor(IStructuredDataFilterCommandExecutor* value)override;
				};
				
				class StructuredDataMultipleFilter : public StructuredDataFilterBase, public Description<StructuredDataMultipleFilter>
				{
				protected:
					collections::List<Ptr<IStructuredDataFilter>>		filters;

				public:
					StructuredDataMultipleFilter();

					bool												AddSubFilter(Ptr<IStructuredDataFilter> value);
					bool												RemoveSubFilter(Ptr<IStructuredDataFilter> value);
					void												SetCommandExecutor(IStructuredDataFilterCommandExecutor* value)override;
				};

				class StructuredDataAndFilter : public StructuredDataMultipleFilter, public Description<StructuredDataAndFilter>
				{
				public:
					StructuredDataAndFilter();

					bool												Filter(vint row)override;
				};
				
				class StructuredDataOrFilter : public StructuredDataMultipleFilter, public Description<StructuredDataOrFilter>
				{
				public:
					StructuredDataOrFilter();

					bool												Filter(vint row)override;
				};
				
				class StructuredDataNotFilter : public StructuredDataFilterBase, public Description<StructuredDataNotFilter>
				{
				protected:
					Ptr<IStructuredDataFilter>							filter;
				public:
					StructuredDataNotFilter();
					
					bool												SetSubFilter(Ptr<IStructuredDataFilter> value);
					void												SetCommandExecutor(IStructuredDataFilterCommandExecutor* value)override;
					bool												Filter(vint row)override;
				};

/***********************************************************************
Sorter Extensions
***********************************************************************/
				
				class StructuredDataMultipleSorter : public Object, public virtual IStructuredDataSorter, public Description<StructuredDataMultipleSorter>
				{
				protected:
					Ptr<IStructuredDataSorter>							leftSorter;
					Ptr<IStructuredDataSorter>							rightSorter;
				public:
					StructuredDataMultipleSorter();
					
					bool												SetLeftSorter(Ptr<IStructuredDataSorter> value);
					bool												SetRightSorter(Ptr<IStructuredDataSorter> value);
					vint												Compare(vint row1, vint row2)override;
				};
				
				class StructuredDataReverseSorter : public Object, public virtual IStructuredDataSorter, public Description<StructuredDataReverseSorter>
				{
				protected:
					Ptr<IStructuredDataSorter>							sorter;
				public:
					StructuredDataReverseSorter();
					
					bool												SetSubSorter(Ptr<IStructuredDataSorter> value);
					vint												Compare(vint row1, vint row2)override;
				};

/***********************************************************************
Structured DataSource Extensions
***********************************************************************/

				class StructuredDataProvider
					: public Object
					, public virtual IDataProvider
					, protected virtual IDataProviderCommandExecutor
					, protected virtual IStructuredDataFilterCommandExecutor
					, public Description<StructuredDataProvider>
				{
				protected:
					Ptr<IStructuredDataProvider>						structuredDataProvider;
					IDataProviderCommandExecutor*						commandExecutor;
					Ptr<IStructuredDataFilter>							additionalFilter;
					Ptr<IStructuredDataFilter>							currentFilter;
					Ptr<IStructuredDataSorter>							currentSorter;
					collections::List<vint>								reorderedRows;
					
					void												OnDataProviderColumnChanged()override;
					void												OnDataProviderItemModified(vint start, vint count, vint newCount)override;
					void												OnFilterChanged()override;
					void												RebuildFilter(bool invokeCallback);
					void												ReorderRows(bool invokeCallback);
					vint												TranslateRowNumber(vint row);
				public:
					StructuredDataProvider(Ptr<IStructuredDataProvider> provider);
					~StructuredDataProvider();
					
					Ptr<IStructuredDataProvider>						GetStructuredDataProvider();
					Ptr<IStructuredDataFilter>							GetAdditionalFilter();
					void												SetAdditionalFilter(Ptr<IStructuredDataFilter> value);

					void												SetCommandExecutor(IDataProviderCommandExecutor* value)override;
					vint												GetColumnCount()override;
					WString												GetColumnText(vint column)override;
					vint												GetColumnSize(vint column)override;
					void												SetColumnSize(vint column, vint value)override;
					GuiMenu*											GetColumnPopup(vint column)override;
					bool												IsColumnSortable(vint column)override;
					void												SortByColumn(vint column, bool ascending)override;
					vint												GetSortedColumn()override;
					bool												IsSortOrderAscending()override;
					
					vint												GetRowCount()override;
					Ptr<GuiImageData>									GetRowLargeImage(vint row)override;
					Ptr<GuiImageData>									GetRowSmallImage(vint row)override;
					vint												GetCellSpan(vint row, vint column)override;
					WString												GetCellText(vint row, vint column)override;
					IDataVisualizerFactory*								GetCellDataVisualizerFactory(vint row, vint column)override;
					void												VisualizeCell(vint row, vint column, IDataVisualizer* dataVisualizer)override;
					IDataEditorFactory*									GetCellDataEditorFactory(vint row, vint column)override;
					void												BeforeEditCell(vint row, vint column, IDataEditor* dataEditor)override;
					void												SaveCellData(vint row, vint column, IDataEditor* dataEditor)override;
				};

				class StructuredColummProviderBase : public Object, public virtual IStructuredColumnProvider, public Description<StructuredColummProviderBase>
				{
				protected:
					IDataProviderCommandExecutor*						commandExecutor;
					WString												text;
					vint												size;
					GuiListViewColumnHeader::ColumnSortingState			sortingState;
					GuiMenu*											popup;
					Ptr<IStructuredDataFilter>							inherentFilter;
					Ptr<IStructuredDataSorter>							inherentSorter;
					Ptr<IDataVisualizerFactory>							visualizerFactory;
					Ptr<IDataEditorFactory>								editorFactory;

				public:
					StructuredColummProviderBase();
					~StructuredColummProviderBase();
					
					void												SetCommandExecutor(IDataProviderCommandExecutor* value);
					StructuredColummProviderBase*						SetText(const WString& value);
					StructuredColummProviderBase*						SetPopup(GuiMenu* value);
					StructuredColummProviderBase*						SetInherentFilter(Ptr<IStructuredDataFilter> value);
					StructuredColummProviderBase*						SetInherentSorter(Ptr<IStructuredDataSorter> value);
					Ptr<IDataVisualizerFactory>							GetVisualizerFactory();
					StructuredColummProviderBase*						SetVisualizerFactory(Ptr<IDataVisualizerFactory> value);
					Ptr<IDataEditorFactory>								GetEditorFactory();
					StructuredColummProviderBase*						SetEditorFactory(Ptr<IDataEditorFactory> value);

					WString												GetText()override;
					vint												GetSize()override;
					void												SetSize(vint value)override;
					GuiListViewColumnHeader::ColumnSortingState			GetSortingState()override;
					void												SetSortingState(GuiListViewColumnHeader::ColumnSortingState value)override;
					GuiMenu*											GetPopup()override;
					Ptr<IStructuredDataFilter>							GetInherentFilter()override;
					Ptr<IStructuredDataSorter>							GetInherentSorter()override;
					
					IDataVisualizerFactory*								GetCellDataVisualizerFactory(vint row)override;
					void												VisualizeCell(vint row, IDataVisualizer* dataVisualizer)override;
					IDataEditorFactory*									GetCellDataEditorFactory(vint row)override;
					void												BeforeEditCell(vint row, IDataEditor* dataEditor)override;
					void												SaveCellData(vint row, IDataEditor* dataEditor)override;
				};

				class StructuredDataProviderBase : public Object, public virtual IStructuredDataProvider, public Description<StructuredDataProviderBase>
				{
					typedef collections::List<Ptr<StructuredColummProviderBase>>		ColumnList;
				protected:
					IDataProviderCommandExecutor*						commandExecutor;
					ColumnList											columns;

					bool												InsertColumnInternal(vint column, Ptr<StructuredColummProviderBase> value, bool callback);
					bool												AddColumnInternal(Ptr<StructuredColummProviderBase> value, bool callback);
					bool												RemoveColumnInternal(Ptr<StructuredColummProviderBase> value, bool callback);
					bool												ClearColumnsInternal(bool callback);
				public:
					StructuredDataProviderBase();
					~StructuredDataProviderBase();

					void												SetCommandExecutor(IDataProviderCommandExecutor* value)override;
					vint												GetColumnCount()override;
					IStructuredColumnProvider*							GetColumn(vint column)override;
					Ptr<GuiImageData>									GetRowLargeImage(vint row)override;
					Ptr<GuiImageData>									GetRowSmallImage(vint row)override;
				};

/***********************************************************************
Strong Typed DataSource Extensions
***********************************************************************/

				template<typename TRow>
				class StrongTypedDataProvider;

				template<typename TRow, typename TColumn>
				class StrongTypedColumnProviderBase : public StructuredColummProviderBase
				{
				public:
					class FilterBase : public StructuredDataFilterBase
					{
					protected:
						StrongTypedColumnProviderBase<TRow, TColumn>*		ownerColumn;
						StrongTypedDataProvider<TRow>*						dataProvider;

						virtual bool										FilterData(const TRow& rowData, const TColumn& cellData)=0;
					public:
						FilterBase(StrongTypedColumnProviderBase<TRow, TColumn>* _ownerColumn)
							:ownerColumn(_ownerColumn)
							,dataProvider(_ownerColumn->dataProvider)
						{
						}

						bool Filter(vint row)override
						{
							TRow rowData;
							TColumn cellData;
							dataProvider->GetRowData(row, rowData);
							ownerColumn->GetCellData(rowData, cellData);
							return FilterData(rowData, cellData);
						}
					};

					class SorterBase : public Object, public virtual IStructuredDataSorter
					{
					protected:
						StrongTypedColumnProviderBase<TRow, TColumn>*		ownerColumn;
						StrongTypedDataProvider<TRow>*						dataProvider;

						virtual vint										CompareData(const TRow& rowData1, const TColumn& cellData1, const TRow& rowData2, const TColumn& cellData2)=0;
					public:
						SorterBase(StrongTypedColumnProviderBase<TRow, TColumn>* _ownerColumn)
							:ownerColumn(_ownerColumn)
							,dataProvider(_ownerColumn->dataProvider)
						{
						}

						vint Compare(vint row1, vint row2)
						{
							TRow rowData1, rowData2;
							TColumn cellData1, cellData2;
							dataProvider->GetRowData(row1, rowData1);
							dataProvider->GetRowData(row2, rowData2);
							ownerColumn->GetCellData(rowData1, cellData1);
							ownerColumn->GetCellData(rowData2, cellData2);
							return CompareData(rowData1, cellData1, rowData2, cellData2);
						}
					};

					class Sorter : public SorterBase
					{
					protected:

						vint CompareData(const TRow& rowData1, const TColumn& cellData1, const TRow& rowData2, const TColumn& cellData2)override
						{
							if(cellData1<cellData2) return -1;
							if(cellData1>cellData2) return 1;
							return 0;
						}
					public:
						Sorter(StrongTypedColumnProviderBase<TRow, TColumn>* _ownerColumn)
							:SorterBase(_ownerColumn)
						{
						}
					};

				protected:
					StrongTypedDataProvider<TRow>*						dataProvider;

				public:
					StrongTypedColumnProviderBase(StrongTypedDataProvider<TRow>* _dataProvider)
						:dataProvider(_dataProvider)
					{
					}

					virtual void										GetCellData(const TRow& rowData, TColumn& cellData)=0;
					virtual WString										GetCellDataText(const TColumn& cellData)=0;

					WString GetCellText(vint row)override
					{
						TRow rowData;
						TColumn cellData;
						dataProvider->GetRowData(row, rowData);
						GetCellData(rowData, cellData);
						return GetCellDataText(cellData);
					}
				};

				template<typename TRow, typename TColumn>
				class StrongTypedColumnProvider : public StrongTypedColumnProviderBase<TRow, TColumn>
				{
				public:
					StrongTypedColumnProvider(StrongTypedDataProvider<TRow>* _dataProvider)
						:StrongTypedColumnProviderBase<TRow, TColumn>(_dataProvider)
					{
					}

					WString GetCellDataText(const TColumn& cellData)override
					{
						return description::BoxValue<TColumn>(cellData).GetText();
					}
				};

				template<typename TRow, typename TColumn>
				class StrongTypedFieldColumnProvider : public StrongTypedColumnProvider<TRow, TColumn>
				{
				protected:
					TColumn TRow::*										field;

				public:
					StrongTypedFieldColumnProvider(StrongTypedDataProvider<TRow>* _dataProvider, TColumn TRow::* _field)
						:StrongTypedColumnProvider<TRow, TColumn>(_dataProvider)
						,field(_field)
					{
					}

					void GetCellData(const TRow& rowData, TColumn& cellData)override
					{
						cellData=rowData.*field;
					}
				};

				template<typename TRow>
				class StrongTypedDataProvider : public StructuredDataProviderBase
				{
				protected:

					template<typename TColumn>
					Ptr<StrongTypedColumnProvider<TRow, TColumn>> AddStrongTypedColumn(const WString& text, Ptr<StrongTypedColumnProvider<TRow, TColumn>> column)
					{
						column->SetText(text);
						return AddColumnInternal(column, true)?column:nullptr;
					}

					template<typename TColumn>
					Ptr<StrongTypedColumnProvider<TRow, TColumn>> AddSortableStrongTypedColumn(const WString& text, Ptr<StrongTypedColumnProvider<TRow, TColumn>> column)
					{
						if(AddStrongTypedColumn(text, column))
						{
							typedef typename StrongTypedColumnProvider<TRow, TColumn>::Sorter ColumnSorter;
							column->SetInherentSorter(new ColumnSorter(column.Obj()));
						}
						return column;
					}

					template<typename TColumn>
					Ptr<StrongTypedColumnProvider<TRow, TColumn>> AddFieldColumn(const WString& text, TColumn TRow::* field)
					{
						Ptr<StrongTypedFieldColumnProvider<TRow, TColumn>> column=new StrongTypedFieldColumnProvider<TRow, TColumn>(this, field);
						return AddStrongTypedColumn<TColumn>(text, column);
					}

					template<typename TColumn>
					Ptr<StrongTypedColumnProvider<TRow, TColumn>> AddSortableFieldColumn(const WString& text, TColumn TRow::* field)
					{
						Ptr<StrongTypedFieldColumnProvider<TRow, TColumn>> column=new StrongTypedFieldColumnProvider<TRow, TColumn>(this, field);
						return AddSortableStrongTypedColumn<TColumn>(text, column);
					}
				public:
					StrongTypedDataProvider()
					{
					}

					virtual void										GetRowData(vint row, TRow& rowData)=0;
				};
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDEXTENSIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAEXTENSIONS
#define VCZH_PRESENTATION_CONTROLS_GUIDATAEXTENSIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			namespace list
			{

/***********************************************************************
Extension Bases
***********************************************************************/
				
				class DataVisualizerBase : public Object, public virtual IDataVisualizer
				{
					template<typename T>
					friend class DataVisualizerFactory;
					template<typename T>
					friend class DataDecoratableVisualizerFactory;
				protected:
					IDataVisualizerFactory*								factory;
					FontProperties										font;
					GuiListViewBase::IStyleProvider*					styleProvider;
					compositions::GuiBoundsComposition*					boundsComposition;
					Ptr<IDataVisualizer>								decoratedDataVisualizer;

					virtual compositions::GuiBoundsComposition*			CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)=0;
				public:
					DataVisualizerBase(Ptr<IDataVisualizer> _decoratedDataVisualizer=0);
					~DataVisualizerBase();

					IDataVisualizerFactory*								GetFactory()override;
					compositions::GuiBoundsComposition*					GetBoundsComposition()override;
					void												BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)override;
					IDataVisualizer*									GetDecoratedDataVisualizer()override;
					void												SetSelected(bool value)override;
				};
				
				template<typename TVisualizer>
				class DataVisualizerFactory : public Object, public virtual IDataVisualizerFactory, public Description<DataVisualizerFactory<TVisualizer>>
				{
				public:
					Ptr<IDataVisualizer> CreateVisualizer(const FontProperties& font, GuiListViewBase::IStyleProvider* styleProvider)override
					{
						DataVisualizerBase* dataVisualizer=new TVisualizer;
						dataVisualizer->factory=this;
						dataVisualizer->font=font;
						dataVisualizer->styleProvider=styleProvider;
						return dataVisualizer;
					}
				};
				
				template<typename TVisualizer>
				class DataDecoratableVisualizerFactory : public Object, public virtual IDataVisualizerFactory, public Description<DataDecoratableVisualizerFactory<TVisualizer>>
				{
				protected:
					Ptr<IDataVisualizerFactory>							decoratedFactory;
				public:
					DataDecoratableVisualizerFactory(Ptr<IDataVisualizerFactory> _decoratedFactory)
						:decoratedFactory(_decoratedFactory)
					{
					}

					Ptr<IDataVisualizer> CreateVisualizer(const FontProperties& font, GuiListViewBase::IStyleProvider* styleProvider)override
					{
						Ptr<IDataVisualizer> decoratedDataVisualizer=decoratedFactory->CreateVisualizer(font, styleProvider);
						DataVisualizerBase* dataVisualizer=new TVisualizer(decoratedDataVisualizer);
						dataVisualizer->factory=this;
						dataVisualizer->font=font;
						dataVisualizer->styleProvider=styleProvider;
						return dataVisualizer;
					}
				};
				
				class DataEditorBase : public Object, public virtual IDataEditor
				{
					template<typename T>
					friend class DataEditorFactory;
				protected:
					IDataEditorFactory*									factory;
					IDataEditorCallback*								callback;
					compositions::GuiBoundsComposition*					boundsComposition;

					virtual compositions::GuiBoundsComposition*			CreateBoundsCompositionInternal()=0;
				public:
					DataEditorBase();
					~DataEditorBase();

					IDataEditorFactory*									GetFactory()override;
					compositions::GuiBoundsComposition*					GetBoundsComposition()override;
					void												BeforeEditCell(IDataProvider* dataProvider, vint row, vint column)override;
					void												ReinstallEditor()override;
				};
				
				template<typename TEditor>
				class DataEditorFactory : public Object, public virtual IDataEditorFactory, public Description<DataEditorFactory<TEditor>>
				{
				public:
					Ptr<IDataEditor> CreateEditor(IDataEditorCallback* callback)override
					{
						DataEditorBase* dataEditor=new TEditor;
						dataEditor->factory=this;
						dataEditor->callback=callback;
						return dataEditor;
					}
				};

/***********************************************************************
Visualizer Extensions
***********************************************************************/

				class ListViewMainColumnDataVisualizer : public DataVisualizerBase
				{
				public:
					typedef DataVisualizerFactory<ListViewMainColumnDataVisualizer>			Factory;
				protected:
					elements::GuiImageFrameElement*						image;
					elements::GuiSolidLabelElement*						text;

					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)override;
				public:
					ListViewMainColumnDataVisualizer();

					void												BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)override;

					elements::GuiSolidLabelElement*						GetTextElement();
				};
				
				class ListViewSubColumnDataVisualizer : public DataVisualizerBase
				{
				public:
					typedef DataVisualizerFactory<ListViewSubColumnDataVisualizer>			Factory;
				protected:
					elements::GuiSolidLabelElement*						text;

					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)override;
				public:
					ListViewSubColumnDataVisualizer();

					void												BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)override;

					elements::GuiSolidLabelElement*						GetTextElement();
				};

				class HyperlinkDataVisualizer : public ListViewSubColumnDataVisualizer
				{
				public:
					typedef DataVisualizerFactory<HyperlinkDataVisualizer>					Factory;
				protected:

					void												label_MouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					void												label_MouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)override;
				public:
					HyperlinkDataVisualizer();

					void												BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)override;
				};

				class ImageDataVisualizer : public DataVisualizerBase
				{
				public:
					typedef DataVisualizerFactory<ImageDataVisualizer>						Factory;
				protected:
					elements::GuiImageFrameElement*						image;

					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)override;
				public:
					ImageDataVisualizer();

					void												BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)override;

					elements::GuiImageFrameElement*						GetImageElement();
				};
				
				class CellBorderDataVisualizer : public DataVisualizerBase
				{
				public:
					typedef DataDecoratableVisualizerFactory<CellBorderDataVisualizer>		Factory;
				protected:

					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)override;
				public:
					CellBorderDataVisualizer(Ptr<IDataVisualizer> decoratedDataVisualizer);
				};

				class NotifyIconDataVisualizer : public DataVisualizerBase
				{
				public:
					typedef DataDecoratableVisualizerFactory<NotifyIconDataVisualizer>		Factory;
				protected:
					elements::GuiImageFrameElement*						leftImage;
					elements::GuiImageFrameElement*						rightImage;

					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)override;
				public:
					NotifyIconDataVisualizer(Ptr<IDataVisualizer> decoratedDataVisualizer);

					void												BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)override;

					elements::GuiImageFrameElement*						GetLeftImageElement();
					elements::GuiImageFrameElement*						GetRightImageElement();
				};

/***********************************************************************
Editor Extensions
***********************************************************************/
				
				class TextBoxDataEditor : public DataEditorBase
				{
				public:
					typedef DataEditorFactory<TextBoxDataEditor>							Factory;
				protected:
					GuiSinglelineTextBox*								textBox;

					void												OnTextChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal()override;
				public:
					TextBoxDataEditor();

					void												BeforeEditCell(IDataProvider* dataProvider, vint row, vint column)override;

					GuiSinglelineTextBox*								GetTextBox();
				};
				
				class TextComboBoxDataEditor : public DataEditorBase
				{
				public:
					typedef DataEditorFactory<TextComboBoxDataEditor>						Factory;
				protected:
					GuiComboBoxListControl*								comboBox;
					GuiTextList*										textList;
					
					void												OnSelectedIndexChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal()override;
				public:
					TextComboBoxDataEditor();

					void												BeforeEditCell(IDataProvider* dataProvider, vint row, vint column)override;

					GuiComboBoxListControl*								GetComboBoxControl();

					GuiTextList*										GetTextListControl();
				};
				
				class DateComboBoxDataEditor : public DataEditorBase
				{
				public:
					typedef DataEditorFactory<DateComboBoxDataEditor>						Factory;
				protected:
					GuiDateComboBox*									comboBox;
					
					void												OnSelectedDateChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
					compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal()override;
				public:
					DateComboBoxDataEditor();

					void												BeforeEditCell(IDataProvider* dataProvider, vint row, vint column)override;

					GuiDateComboBox*									GetComboBoxControl();

					GuiDatePicker*										GetDatePickerControl();
				};
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUIDATAGRIDCONTROLS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIDATAGRIDCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiVirtualDataGrid;

			namespace list
			{

/***********************************************************************
Datagrid ItemProvider
***********************************************************************/
				
				class DataGridItemProvider
					: public Object
					, public virtual GuiListControl::IItemProvider
					, public virtual GuiListControl::IItemPrimaryTextView
					, public virtual ListViewItemStyleProvider::IListViewItemView
					, public virtual ListViewColumnItemArranger::IColumnItemView
					, protected virtual IDataProviderCommandExecutor
					, public Description<DataGridItemProvider>
				{
				protected:
					IDataProvider*																dataProvider;
					collections::List<GuiListControl::IItemProviderCallback*>					itemProviderCallbacks;
					collections::List<ListViewColumnItemArranger::IColumnItemViewCallback*>		columnItemViewCallbacks;

					void												InvokeOnItemModified(vint start, vint count, vint newCount);
					void												InvokeOnColumnChanged();
					void												OnDataProviderColumnChanged()override;
					void												OnDataProviderItemModified(vint start, vint count, vint newCount)override;
				public:
					DataGridItemProvider(IDataProvider* _dataProvider);
					~DataGridItemProvider();

					IDataProvider*										GetDataProvider();
					void												SortByColumn(vint column, bool ascending=true);

					// ===================== GuiListControl::IItemProvider =====================

					bool												AttachCallback(GuiListControl::IItemProviderCallback* value)override;
					bool												DetachCallback(GuiListControl::IItemProviderCallback* value)override;
					vint												Count()override;
					IDescriptable*										RequestView(const WString& identifier)override;
					void												ReleaseView(IDescriptable* view)override;

					// ===================== GuiListControl::IItemPrimaryTextView =====================

					WString												GetPrimaryTextViewText(vint itemIndex)override;
					bool												ContainsPrimaryText(vint itemIndex)override;

					// ===================== list::ListViewItemStyleProvider::IListViewItemView =====================

					Ptr<GuiImageData>									GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>									GetLargeImage(vint itemIndex)override;
					WString												GetText(vint itemIndex)override;
					WString												GetSubItem(vint itemIndex, vint index)override;
					vint												GetDataColumnCount()override;
					vint												GetDataColumn(vint index)override;

					// ===================== list::ListViewColumnItemArranger::IColumnItemView =====================
						
					bool												AttachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool												DetachCallback(ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint												GetColumnCount()override;
					WString												GetColumnText(vint index)override;
					vint												GetColumnSize(vint index)override;
					void												SetColumnSize(vint index, vint value)override;
					GuiMenu*											GetDropdownPopup(vint index)override;
					GuiListViewColumnHeader::ColumnSortingState			GetSortingState(vint index)override;
				};

/***********************************************************************
Datagrid ContentProvider
***********************************************************************/
				
				class DataGridContentProvider
					: public Object
					, public virtual ListViewItemStyleProvider::IListViewItemContentProvider
					, protected virtual ListViewColumnItemArranger::IColumnItemViewCallback
					, protected virtual GuiListControl::IItemProviderCallback
					, protected virtual IDataEditorCallback
					, public Description<ListViewDetailContentProvider>
				{
				protected:
					class ItemContent : public Object, public virtual ListViewItemStyleProvider::IListViewItemContent
					{
					protected:
						compositions::GuiBoundsComposition*				contentComposition;
						compositions::GuiTableComposition*				textTable;

						DataGridContentProvider*						contentProvider;
						FontProperties									font;

						collections::Array<Ptr<IDataVisualizer>>		dataVisualizers;
						IDataEditor*									currentEditor;

						void											RemoveCellsAndDataVisualizers();
						IDataVisualizerFactory*							GetDataVisualizerFactory(vint row, vint column);
						vint											GetCellColumnIndex(compositions::GuiGraphicsComposition* composition);
						void											OnCellButtonUp(compositions::GuiGraphicsComposition* sender, bool openEditor);
						bool											IsInEditor(compositions::GuiMouseEventArgs& arguments);
						void											OnCellButtonDown(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void											OnCellLeftButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
						void											OnCellRightButtonUp(compositions::GuiGraphicsComposition* sender, compositions::GuiMouseEventArgs& arguments);
					public:
						ItemContent(DataGridContentProvider* _contentProvider, const FontProperties& _font);
						~ItemContent();

						compositions::GuiBoundsComposition*				GetContentComposition()override;
						compositions::GuiBoundsComposition*				GetBackgroundDecorator()override;
						void											UpdateSubItemSize();
						void											ForceSetEditor(vint column, IDataEditor* editor);
						void											NotifyCloseEditor();
						void											NotifySelectCell(vint column);
						void											Install(GuiListViewBase::IStyleProvider* styleProvider, ListViewItemStyleProvider::IListViewItemView* view, vint itemIndex)override;
						void											Uninstall()override;
					};

					GuiVirtualDataGrid*									dataGrid;
					GuiListControl::IItemProvider*						itemProvider;
					list::IDataProvider*								dataProvider;
					ListViewColumnItemArranger::IColumnItemView*		columnItemView;
					ListViewItemStyleProvider*							listViewItemStyleProvider;

					ListViewMainColumnDataVisualizer::Factory			mainColumnDataVisualizerFactory;
					ListViewSubColumnDataVisualizer::Factory			subColumnDataVisualizerFactory;

					GridPos												currentCell;
					Ptr<IDataEditor>									currentEditor;
					bool												currentEditorRequestingSaveData;
					bool												currentEditorOpening;

					void												OnColumnChanged()override;
					void												OnAttached(GuiListControl::IItemProvider* provider)override;
					void												OnItemModified(vint start, vint count, vint newCount)override;

					void												NotifyCloseEditor();
					void												NotifySelectCell(vint row, vint column);
					void												RequestSaveData();
					IDataEditor*										OpenEditor(vint row, vint column, IDataEditorFactory* editorFactory);
					void												CloseEditor(bool forOpenNewEditor);
				public:
					DataGridContentProvider();
					~DataGridContentProvider();
					
					GuiListControl::IItemCoordinateTransformer*			CreatePreferredCoordinateTransformer()override;
					GuiListControl::IItemArranger*						CreatePreferredArranger()override;
					ListViewItemStyleProvider::IListViewItemContent*	CreateItemContent(const FontProperties& font)override;
					void												AttachListControl(GuiListControl* value)override;
					void												DetachListControl()override;

					GridPos												GetSelectedCell();
					bool												SetSelectedCell(const GridPos& value, bool openEditor);
				};
			}

/***********************************************************************
Virtual DataGrid Control
***********************************************************************/

			class GuiVirtualDataGrid : public GuiVirtualListView, public Description<GuiVirtualDataGrid>
			{
				friend class list::DataGridContentProvider;
			protected:
				list::DataGridItemProvider*								itemProvider;
				list::DataGridContentProvider*							contentProvider;
				Ptr<list::IDataProvider>								dataProvider;
				Ptr<list::StructuredDataProvider>						structuredDataProvider;

				void													OnColumnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiItemEventArgs& arguments);
				void													Initialize();
				void													NotifySelectedCellChanged();
			public:
				GuiVirtualDataGrid(IStyleProvider* _styleProvider, list::IDataProvider* _dataProvider);
				GuiVirtualDataGrid(IStyleProvider* _styleProvider, list::IStructuredDataProvider* _dataProvider);
				~GuiVirtualDataGrid();

				compositions::GuiNotifyEvent							SelectedCellChanged;

				list::IDataProvider*									GetDataProvider();
				list::StructuredDataProvider*							GetStructuredDataProvider();

				GridPos													GetSelectedCell();
				void													SetSelectedCell(const GridPos& value);

				Ptr<GuiListControl::IItemStyleProvider>					SetStyleProvider(Ptr<GuiListControl::IItemStyleProvider> value)override;
				bool													ChangeItemStyle(Ptr<list::ListViewItemStyleProvider::IListViewItemContentProvider> contentProvider)override;
			};

/***********************************************************************
StringGrid Control
***********************************************************************/

			class GuiStringGrid;

			namespace list
			{
				class StringGridProvider;

				class StringGridItem
				{
				public:
					collections::List<WString>							strings;
				};
				
				class StringGridDataVisualizer : public ListViewSubColumnDataVisualizer
				{
				public:
					typedef DataVisualizerFactory<StringGridDataVisualizer>				Factory;
				public:
					StringGridDataVisualizer();

					void												BeforeVisualizeCell(IDataProvider* dataProvider, vint row, vint column)override;
					void												SetSelected(bool value)override;
				};

				class StringGridColumn : public StrongTypedColumnProviderBase<Ptr<StringGridItem>, WString>
				{
				protected:
					StringGridProvider*									provider;

				public:
					StringGridColumn(StringGridProvider* _provider);
					~StringGridColumn();

					void												GetCellData(const Ptr<StringGridItem>& rowData, WString& cellData)override;
					void												SetCellData(const Ptr<StringGridItem>& rowData, const WString& cellData);
					WString												GetCellDataText(const WString& cellData)override;

					void												BeforeEditCell(vint row, IDataEditor* dataEditor)override;
					void												SaveCellData(vint row, IDataEditor* dataEditor)override;
				};

				class StringGridProvider : private StrongTypedDataProvider<Ptr<StringGridItem>>, public Description<StringGridProvider>
				{
					friend class StringGridColumn;
					friend class vl::presentation::controls::GuiStringGrid;
				protected:
					bool												readonly;
					collections::List<Ptr<StringGridItem>>				items;
					Ptr<IDataVisualizerFactory>							visualizerFactory;
					Ptr<IDataEditorFactory>								editorFactory;

					void												GetRowData(vint row, Ptr<StringGridItem>& rowData)override;
					bool												GetReadonly();
					void												SetReadonly(bool value);
				public:
					StringGridProvider();
					~StringGridProvider();

					vint												GetRowCount()override;
					vint												GetColumnCount()override;

					bool												InsertRow(vint row);
					vint												AppendRow();
					bool												MoveRow(vint source, vint target);
					bool												RemoveRow(vint row);
					bool												ClearRows();
					WString												GetGridString(vint row, vint column);
					bool												SetGridString(vint row, vint column, const WString& value);

					bool												InsertColumn(vint column, const WString& text, vint size=0);
					vint												AppendColumn(const WString& text, vint size=0);
					bool												MoveColumn(vint source, vint target);
					bool												RemoveColumn(vint column);
					bool												ClearColumns();
					WString												GetColumnText(vint column);
					bool												SetColumnText(vint column, const WString& value);
				};
			}

			class GuiStringGrid : public GuiVirtualDataGrid, public Description<GuiStringGrid>
			{
			protected:
				list::StringGridProvider*								grids;
			public:
				GuiStringGrid(IStyleProvider* _styleProvider);
				~GuiStringGrid();

				list::StringGridProvider&								Grids();

				bool													GetReadonly();
				void													SetReadonly(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\LISTCONTROLPACKAGE\GUIBINDABLELISTCONTROL.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIBINDABLELISTCONTROLS
#define VCZH_PRESENTATION_CONTROLS_GUIBINDABLELISTCONTROLS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiBindableTextList
***********************************************************************/

			class GuiBindableTextList : public GuiVirtualTextList, public Description<GuiBindableTextList>
			{
			protected:
				class ItemSource
					: public list::ItemProviderBase
					, protected GuiListControl::IItemBindingView
					, protected list::TextItemStyleProvider::ITextItemView
				{
				protected:
					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			itemSource;

				public:
					WString											textProperty;
					WString											checkedProperty;

				public:
					ItemSource(Ptr<description::IValueEnumerable> _itemSource);
					~ItemSource();

					description::Value								Get(vint index);
					void											UpdateBindingProperties();
					
					// ===================== GuiListControl::IItemProvider =====================

					vint											Count()override;
					IDescriptable*									RequestView(const WString& identifier)override;
					void											ReleaseView(IDescriptable* view)override;
					
					// ===================== GuiListControl::IItemBindingView =====================

					description::Value								GetBindingValue(vint itemIndex)override;
					
					// ===================== GuiListControl::IItemPrimaryTextView =====================

					WString											GetPrimaryTextViewText(vint itemIndex)override;
					bool											ContainsPrimaryText(vint itemIndex)override;
					
					// ===================== list::TextItemStyleProvider::ITextItemView =====================

					WString											GetText(vint itemIndex)override;
					bool											GetChecked(vint itemIndex)override;
					void											SetCheckedSilently(vint itemIndex, bool value)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				GuiBindableTextList(IStyleProvider* _styleProvider, list::TextItemStyleProvider::ITextItemStyleProvider* _itemStyleProvider, Ptr<description::IValueEnumerable> _itemSource);
				~GuiBindableTextList();
				
				compositions::GuiNotifyEvent						TextPropertyChanged;
				compositions::GuiNotifyEvent						CheckedPropertyChanged;
				
				const WString&										GetTextProperty();
				void												SetTextProperty(const WString& value);
				
				const WString&										GetCheckedProperty();
				void												SetCheckedProperty(const WString& value);

				description::Value									GetSelectedItem();
			};

/***********************************************************************
GuiBindableListView
***********************************************************************/
			
			class GuiBindableListView : public GuiVirtualListView, public Description<GuiBindableListView>
			{
			protected:
				class ItemSource;
			public:
				class ListViewDataColumns : public list::ItemsBase<vint>
				{
					friend class ItemSource;
				protected:
					ItemSource*										itemProvider;

					void NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					ListViewDataColumns();
					~ListViewDataColumns();
				};
				
				class ListViewColumns : public list::ItemsBase<Ptr<list::ListViewColumn>>
				{
					friend class ItemSource;
				protected:
					ItemSource*										itemProvider;

					void NotifyUpdateInternal(vint start, vint count, vint newCount)override;
				public:
					ListViewColumns();
					~ListViewColumns();
				};

			protected:
				class ItemSource
					: public list::ItemProviderBase
					, protected GuiListControl::IItemBindingView
					, protected virtual list::ListViewItemStyleProvider::IListViewItemView
					, protected virtual list::ListViewColumnItemArranger::IColumnItemView
				{
					friend class ListViewDataColumns;
					friend class ListViewColumns;
					typedef collections::List<list::ListViewColumnItemArranger::IColumnItemViewCallback*>		ColumnItemViewCallbackList;
				protected:
					ListViewDataColumns								dataColumns;
					ListViewColumns									columns;
					ColumnItemViewCallbackList						columnItemViewCallbacks;
					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			itemSource;

				public:
					WString											largeImageProperty;
					WString											smallImageProperty;

				public:
					ItemSource(Ptr<description::IValueEnumerable> _itemSource);
					~ItemSource();
					
					description::Value								Get(vint index);
					void											UpdateBindingProperties();
					bool											NotifyUpdate(vint start, vint count);
					ListViewDataColumns&							GetDataColumns();
					ListViewColumns&								GetColumns();
					
					// ===================== GuiListControl::IItemProvider =====================

					vint											Count()override;
					IDescriptable*									RequestView(const WString& identifier)override;
					void											ReleaseView(IDescriptable* view)override;
					
					// ===================== GuiListControl::IItemBindingView =====================

					description::Value								GetBindingValue(vint itemIndex)override;

					// ===================== GuiListControl::IItemPrimaryTextView =====================

					WString											GetPrimaryTextViewText(vint itemIndex)override;
					bool											ContainsPrimaryText(vint itemIndex)override;

					// ===================== list::ListViewItemStyleProvider::IListViewItemView =====================

					Ptr<GuiImageData>								GetSmallImage(vint itemIndex)override;
					Ptr<GuiImageData>								GetLargeImage(vint itemIndex)override;
					WString											GetText(vint itemIndex)override;
					WString											GetSubItem(vint itemIndex, vint index)override;
					vint											GetDataColumnCount()override;
					vint											GetDataColumn(vint index)override;

					// ===================== list::ListViewColumnItemArranger::IColumnItemView =====================
						
					bool											AttachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					bool											DetachCallback(list::ListViewColumnItemArranger::IColumnItemViewCallback* value)override;
					vint											GetColumnCount()override;
					WString											GetColumnText(vint index)override;
					vint											GetColumnSize(vint index)override;
					void											SetColumnSize(vint index, vint value)override;
					GuiMenu*										GetDropdownPopup(vint index)override;
					GuiListViewColumnHeader::ColumnSortingState		GetSortingState(vint index)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				GuiBindableListView(IStyleProvider* _styleProvider, Ptr<description::IValueEnumerable> _itemSource);
				~GuiBindableListView();

				ListViewDataColumns&								GetDataColumns();
				ListViewColumns&									GetColumns();
				
				compositions::GuiNotifyEvent						LargeImagePropertyChanged;
				compositions::GuiNotifyEvent						SmallImagePropertyChanged;
				
				const WString&										GetLargeImageProperty();
				void												SetLargeImageProperty(const WString& value);
				
				const WString&										GetSmallImageProperty();
				void												SetSmallImageProperty(const WString& value);

				description::Value									GetSelectedItem();
			};

/***********************************************************************
GuiBindableTreeView
***********************************************************************/
			
			class GuiBindableTreeView : public GuiVirtualTreeView, public Description<GuiBindableTreeView>
			{
			protected:
				class ItemSource;

				class ItemSourceNode
					: public Object
					, public virtual tree::INodeProvider
				{
					friend class ItemSource;
					typedef collections::List<Ptr<ItemSourceNode>>	NodeList;
				protected:
					description::Value								itemSource;
					ItemSource*										rootProvider;
					ItemSourceNode*									parent;
					tree::INodeProviderCallback*					callback;
					bool											expanding = false;

					Ptr<EventHandler>								itemChangedEventHandler;
					Ptr<description::IValueReadonlyList>			childrenVirtualList;
					NodeList										children;

					void											PrepareChildren();
					void											UnprepareChildren();
				public:
					ItemSourceNode(const description::Value& _itemSource, ItemSourceNode* _parent);
					ItemSourceNode(const description::Value& _itemSource, ItemSource* _rootProvider);
					~ItemSourceNode();

					description::Value								GetItemSource();

					// ===================== tree::INodeProvider =====================

					bool											GetExpanding()override;
					void											SetExpanding(bool value)override;
					vint											CalculateTotalVisibleNodes()override;

					vint											GetChildCount()override;
					tree::INodeProvider*							GetParent()override;
					tree::INodeProvider*							GetChild(vint index)override;
					void											Increase()override;
					void											Release()override;
				};

				class ItemSource
					: public tree::NodeRootProviderBase
					, protected virtual tree::INodeItemBindingView
					, protected virtual tree::ITreeViewItemView
				{
					friend class ItemSourceNode;
				public:
					WString											textProperty;
					WString											imageProperty;
					WString											childrenProperty;
					Ptr<ItemSourceNode>								rootNode;

				public:
					ItemSource(const description::Value& _itemSource);
					~ItemSource();

					void											UpdateBindingProperties(bool updateChildrenProperty);

					// ===================== tree::INodeRootProvider =====================

					tree::INodeProvider*							GetRootNode()override;
					IDescriptable*									RequestView(const WString& identifier)override;
					void											ReleaseView(IDescriptable* view)override;

					// ===================== tree::INodeItemBindingView =====================

					description::Value								GetBindingValue(tree::INodeProvider* node)override;

					// ===================== tree::INodeItemPrimaryTextView =====================

					WString											GetPrimaryTextViewText(tree::INodeProvider* node)override;

					// ===================== tree::ITreeViewItemView =====================

					Ptr<GuiImageData>								GetNodeImage(tree::INodeProvider* node)override;
					WString											GetNodeText(tree::INodeProvider* node)override;
				};

			protected:
				ItemSource*											itemSource;

			public:
				GuiBindableTreeView(IStyleProvider* _styleProvider, const description::Value& _itemSource);
				~GuiBindableTreeView();
				
				compositions::GuiNotifyEvent						TextPropertyChanged;
				compositions::GuiNotifyEvent						ImagePropertyChanged;
				compositions::GuiNotifyEvent						ChildrenPropertyChanged;
				
				const WString&										GetTextProperty();
				void												SetTextProperty(const WString& value);
				
				const WString&										GetImageProperty();
				void												SetImageProperty(const WString& value);
				
				const WString&										GetChildrenProperty();
				void												SetChildrenProperty(const WString& value);

				description::Value									GetSelectedItem();
			};

/***********************************************************************
GuiBindableDataGrid
***********************************************************************/
			
			namespace list
			{
				class BindableDataColumn : public StructuredColummProviderBase, public Description<BindableDataColumn>
				{
					friend class BindableDataProvider;
				protected:
					description::Value								viewModelContext;
					Ptr<description::IValueReadonlyList>			itemSource;
					WString											valueProperty;

					void											SetItemSource(Ptr<description::IValueReadonlyList> _itemSource);
				public:
					BindableDataColumn();
					~BindableDataColumn();
				
					compositions::GuiNotifyEvent					ValuePropertyChanged;

					void											SaveCellData(vint row, IDataEditor* dataEditor)override;
					WString											GetCellText(vint row)override;
					
					description::Value								GetCellValue(vint row);
					void											SetCellValue(vint row, description::Value value);
				
					const WString&									GetValueProperty();
					void											SetValueProperty(const WString& value);
					
					const description::Value&						GetViewModelContext();
				};
			
				class BindableDataProvider : public StructuredDataProviderBase, public Description<BindableDataProvider>
				{
				protected:
					description::Value								viewModelContext;
					Ptr<description::IValueReadonlyList>			itemSource;
					Ptr<EventHandler>								itemChangedEventHandler;

				public:
					BindableDataProvider(Ptr<description::IValueEnumerable> _itemSource, const description::Value& _viewModelContext);
					~BindableDataProvider();

					vint											GetRowCount()override;
					description::Value								GetRowValue(vint row);

					const description::Value&						GetViewModelContext();
					bool											InsertBindableColumn(vint index, Ptr<BindableDataColumn> column);
					bool											AddBindableColumn(Ptr<BindableDataColumn> column);
					bool											RemoveBindableColumn(Ptr<BindableDataColumn> column);
					bool											ClearBindableColumns();
					Ptr<BindableDataColumn>							GetBindableColumn(vint index);
				};
			}
			
			class GuiBindableDataGrid : public GuiVirtualDataGrid, public Description<GuiBindableDataGrid>
			{
			protected:
				Ptr<list::BindableDataProvider>						bindableDataProvider;

			public:
				GuiBindableDataGrid(IStyleProvider* _styleProvider, Ptr<description::IValueEnumerable> _itemSource, const description::Value& _viewModelContext = description::Value());
				~GuiBindableDataGrid();
				
				bool												InsertBindableColumn(vint index, Ptr<list::BindableDataColumn> column);
				bool												AddBindableColumn(Ptr<list::BindableDataColumn> column);
				bool												RemoveBindableColumn(Ptr<list::BindableDataColumn> column);
				bool												ClearBindableColumns();
				Ptr<list::BindableDataColumn>						GetBindableColumn(vint index);

				description::Value									GetSelectedRowValue();

				description::Value									GetSelectedCellValue();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPCOMMAND.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPCOMMAND


namespace vl
{
	namespace presentation
	{
		namespace controls
		{
			class GuiToolstripCommand : public GuiComponent, public Description<GuiToolstripCommand>
			{
			public:
				class ShortcutBuilder : public Object
				{
				public:
					WString									text;
					bool									ctrl;
					bool									shift;
					bool									alt;
					vint									key;
				};
			protected:
				Ptr<GuiImageData>							image;
				WString										text;
				compositions::IGuiShortcutKeyItem*			shortcutKeyItem;
				bool										enabled;
				bool										selected;
				Ptr<compositions::GuiNotifyEvent::IHandler>	shortcutKeyItemExecutedHandler;
				Ptr<ShortcutBuilder>						shortcutBuilder;
				GuiControlHost*								shortcutOwner;

				void										OnShortcutKeyItemExecuted(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										InvokeDescriptionChanged();
				void										ReplaceShortcut(compositions::IGuiShortcutKeyItem* value, Ptr<ShortcutBuilder> builder);
				void										BuildShortcut(const WString& builderText);
			public:
				GuiToolstripCommand();
				~GuiToolstripCommand();

				void										Attach(GuiInstanceRootObject* rootObject)override;
				void										Detach(GuiInstanceRootObject* rootObject)override;

				compositions::GuiNotifyEvent				Executed;

				compositions::GuiNotifyEvent				DescriptionChanged;

				Ptr<GuiImageData>							GetImage();
				void										SetImage(Ptr<GuiImageData> value);
				const WString&								GetText();
				void										SetText(const WString& value);
				compositions::IGuiShortcutKeyItem*			GetShortcut();
				void										SetShortcut(compositions::IGuiShortcutKeyItem* value);
				WString										GetShortcutBuilder();
				void										SetShortcutBuilder(const WString& value);
				bool										GetEnabled();
				void										SetEnabled(bool value);
				bool										GetSelected();
				void										SetSelected(bool value);
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TOOLSTRIPPACKAGE\GUITOOLSTRIPMENU.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU
#define VCZH_PRESENTATION_CONTROLS_GUITOOLSTRIPMENU


namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			class ITheme;
		}

		namespace controls
		{

/***********************************************************************
Toolstrip Item Collection
***********************************************************************/

			class GuiToolstripCollection : public list::ItemsBase<GuiControl*>
			{
			public:
				class IContentCallback : public Interface
				{
				public:
					virtual void							UpdateLayout()=0;
				};
			protected:
				IContentCallback*							contentCallback;
				compositions::GuiStackComposition*			stackComposition;

				void										InvokeUpdateLayout();
				void										OnInterestingMenuButtonPropertyChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				bool										QueryInsert(vint index, GuiControl* const& child)override;
				bool										QueryRemove(vint index, GuiControl* const& child)override;
				void										BeforeInsert(vint index, GuiControl* const& child)override;
				void										BeforeRemove(vint index, GuiControl* const& child)override;
				void										AfterInsert(vint index, GuiControl* const& child)override;
				void										AfterRemove(vint index, vint count)override;
			public:
				GuiToolstripCollection(IContentCallback* _contentCallback, compositions::GuiStackComposition* _stackComposition);
				~GuiToolstripCollection();
			};

/***********************************************************************
Toolstrip Builder Facade
***********************************************************************/

			class GuiToolstripButton;

			class GuiToolstripBuilder : public Object
			{
				friend class GuiToolstripMenu;
				friend class GuiToolstripMenuBar;
				friend class GuiToolstripToolBar;
			protected:
				enum Environment
				{
					Menu,
					MenuBar,
					ToolBar,
				};

				Environment									environment;
				GuiToolstripCollection*						toolstripItems;
				GuiToolstripBuilder*						previousBuilder;
				theme::ITheme*								theme;
				GuiToolstripButton*							lastCreatedButton;
				
				GuiToolstripBuilder(Environment _environment, GuiToolstripCollection* _toolstripItems);
			public:
				~GuiToolstripBuilder();

				GuiToolstripBuilder*						Button(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						Button(GuiToolstripCommand* command, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						DropdownButton(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						DropdownButton(GuiToolstripCommand* command, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						SplitButton(Ptr<GuiImageData> image, const WString& text, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						SplitButton(GuiToolstripCommand* command, GuiToolstripButton** result=0);
				GuiToolstripBuilder*						Splitter();
				GuiToolstripBuilder*						Control(GuiControl* control);
				GuiToolstripBuilder*						BeginSubMenu();
				GuiToolstripBuilder*						EndSubMenu();
			};

/***********************************************************************
Toolstrip Container
***********************************************************************/

			class GuiToolstripMenu : public GuiMenu, protected GuiToolstripCollection::IContentCallback,  Description<GuiToolstripMenu>
			{
			protected:
				compositions::GuiSharedSizeRootComposition*	sharedSizeRootComposition;
				compositions::GuiStackComposition*			stackComposition;
				Ptr<GuiToolstripCollection>					toolstripItems;
				Ptr<GuiToolstripBuilder>					builder;

				void										UpdateLayout()override;
			public:
				GuiToolstripMenu(IStyleController* _styleController, GuiControl* _owner);
				~GuiToolstripMenu();
				
				GuiToolstripCollection&						GetToolstripItems();
				GuiToolstripBuilder*						GetBuilder(theme::ITheme* themeObject=0);
			};

			class GuiToolstripMenuBar : public GuiMenuBar, public Description<GuiToolstripMenuBar>
			{
			protected:
				compositions::GuiStackComposition*			stackComposition;
				Ptr<GuiToolstripCollection>					toolstripItems;
				Ptr<GuiToolstripBuilder>					builder;

			public:
				GuiToolstripMenuBar(IStyleController* _styleController);
				~GuiToolstripMenuBar();
				
				GuiToolstripCollection&						GetToolstripItems();
				GuiToolstripBuilder*						GetBuilder(theme::ITheme* themeObject=0);
			};

			class GuiToolstripToolBar : public GuiControl, public Description<GuiToolstripToolBar>
			{
			protected:
				compositions::GuiStackComposition*			stackComposition;
				Ptr<GuiToolstripCollection>					toolstripItems;
				Ptr<GuiToolstripBuilder>					builder;

			public:
				GuiToolstripToolBar(IStyleController* _styleController);
				~GuiToolstripToolBar();
				
				GuiToolstripCollection&						GetToolstripItems();
				GuiToolstripBuilder*						GetBuilder(theme::ITheme* themeObject=0);
			};

/***********************************************************************
Toolstrip Component
***********************************************************************/

			class GuiToolstripButton : public GuiMenuButton, public Description<GuiToolstripButton>
			{
			protected:
				GuiToolstripCommand*							command;
				Ptr<compositions::GuiNotifyEvent::IHandler>		descriptionChangedHandler;

				void											UpdateCommandContent();
				void											OnClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void											OnCommandDescriptionChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiToolstripButton(IStyleController* _styleController);
				~GuiToolstripButton();

				GuiToolstripCommand*							GetCommand();
				void											SetCommand(GuiToolstripCommand* value);

				GuiToolstripMenu*								GetToolstripSubMenu();
				void											CreateToolstripSubMenu(GuiToolstripMenu::IStyleController* subMenuStyleController=0);
			};
		}
	}

	namespace collections
	{
		namespace randomaccess_internal
		{
			template<>
			struct RandomAccessable<presentation::controls::GuiToolstripCollection>
			{
				static const bool							CanRead = true;
				static const bool							CanResize = false;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\GUITHEMESTYLEFACTORY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY
#define VCZH_PRESENTATION_CONTROLS_GUITHEMESTYLEFACTORY





namespace vl
{
	namespace presentation
	{
		namespace theme
		{
			class ITheme : public virtual IDescriptable, public Description<ITheme>
			{
			public:
				virtual controls::GuiWindow::IStyleController*								CreateWindowStyle()=0;
				virtual controls::GuiCustomControl::IStyleController*						CreateCustomControlStyle() = 0;
				virtual controls::GuiTooltip::IStyleController*								CreateTooltipStyle()=0;
				virtual controls::GuiLabel::IStyleController*								CreateLabelStyle()=0;
				virtual controls::GuiLabel::IStyleController*								CreateShortcutKeyStyle()=0;
				virtual controls::GuiScrollContainer::IStyleProvider*						CreateScrollContainerStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateGroupBoxStyle()=0;
				virtual controls::GuiTab::IStyleController*									CreateTabStyle()=0;
				virtual controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()=0;
				virtual controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()=0;
				virtual controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()=0;
				virtual elements::text::ColorEntry											GetDefaultTextBoxColorEntry()=0;
				virtual controls::GuiDocumentViewer::IStyleProvider*						CreateDocumentViewerStyle()=0;
				virtual controls::GuiDocumentLabel::IStyleController*						CreateDocumentLabelStyle()=0;
				virtual controls::GuiListView::IStyleProvider*								CreateListViewStyle()=0;
				virtual controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateListItemBackgroundStyle()=0;
				
				virtual controls::GuiToolstripMenu::IStyleController*						CreateMenuStyle()=0;
				virtual controls::GuiToolstripMenuBar::IStyleController*					CreateMenuBarStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateMenuBarButtonStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateMenuItemButtonStyle()=0;
				virtual controls::GuiToolstripToolBar::IStyleController*					CreateToolBarStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateToolBarButtonStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateToolBarDropdownButtonStyle()=0;
				virtual controls::GuiToolstripButton::IStyleController*						CreateToolBarSplitButtonStyle()=0;
				virtual controls::GuiControl::IStyleController*								CreateToolBarSplitterStyle()=0;
				
				virtual controls::GuiButton::IStyleController*								CreateButtonStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()=0;
				virtual controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()=0;
				virtual controls::GuiDatePicker::IStyleProvider*							CreateDatePickerStyle()=0;
				
				virtual controls::GuiScroll::IStyleController*								CreateHScrollStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateVScrollStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateHTrackerStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateVTrackerStyle()=0;
				virtual controls::GuiScroll::IStyleController*								CreateProgressBarStyle()=0;
				virtual vint																GetScrollDefaultSize()=0;
				virtual vint																GetTrackerDefaultSize()=0;
				
				virtual controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()=0;
				virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()=0;
			};

			extern ITheme*						GetCurrentTheme();
			extern void							SetCurrentTheme(ITheme* theam);

			namespace g
			{
				extern controls::GuiWindow*						NewWindow();
				extern controls::GuiCustomControl*				NewCustomControl();
				extern controls::GuiLabel*						NewLabel();
				extern controls::GuiScrollContainer*			NewScrollContainer();
				extern controls::GuiControl*					NewGroupBox();
				extern controls::GuiTab*						NewTab();
				extern controls::GuiComboBoxListControl*		NewComboBox(controls::GuiSelectableListControl* containedListControl);
				extern controls::GuiMultilineTextBox*			NewMultilineTextBox();
				extern controls::GuiSinglelineTextBox*			NewTextBox();
				extern controls::GuiDocumentViewer*				NewDocumentViewer();
				extern controls::GuiDocumentLabel*				NewDocumentLabel();
				extern controls::GuiListView*					NewListViewBigIcon();
				extern controls::GuiListView*					NewListViewSmallIcon();
				extern controls::GuiListView*					NewListViewList();
				extern controls::GuiListView*					NewListViewDetail();
				extern controls::GuiListView*					NewListViewTile();
				extern controls::GuiListView*					NewListViewInformation();
				extern controls::GuiTreeView*					NewTreeView();
				extern controls::GuiStringGrid*					NewStringGrid();

				extern controls::GuiToolstripMenu*				NewMenu(controls::GuiControl* owner);
				extern controls::GuiToolstripMenuBar*			NewMenuBar();
				extern controls::GuiControl*					NewMenuSplitter();
				extern controls::GuiToolstripButton*			NewMenuBarButton();
				extern controls::GuiToolstripButton*			NewMenuItemButton();
				extern controls::GuiToolstripToolBar*			NewToolBar();
				extern controls::GuiToolstripButton*			NewToolBarButton();
				extern controls::GuiToolstripButton*			NewToolBarDropdownButton();
				extern controls::GuiToolstripButton*			NewToolBarSplitButton();
				extern controls::GuiControl*					NewToolBarSplitter();

				extern controls::GuiButton*						NewButton();
				extern controls::GuiSelectableButton*			NewCheckBox();
				extern controls::GuiSelectableButton*			NewRadioButton();
				extern controls::GuiDatePicker*					NewDatePicker();
				extern controls::GuiDateComboBox*				NewDateComboBox();

				extern controls::GuiScroll*						NewHScroll();
				extern controls::GuiScroll*						NewVScroll();
				extern controls::GuiScroll*						NewHTracker();
				extern controls::GuiScroll*						NewVTracker();
				extern controls::GuiScroll*						NewProgressBar();

				extern controls::GuiTextList*					NewTextList();
				extern controls::GuiTextList*					NewCheckTextList();
				extern controls::GuiTextList*					NewRadioTextList();
			}
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\GUIWIN7STYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES
#define VCZH_PRESENTATION_CONTROLS_GUIWIN7STYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Theme
***********************************************************************/

			class Win7Theme : public Object, public theme::ITheme
			{
			public:
				Win7Theme();
				~Win7Theme();

				controls::GuiWindow::IStyleController*								CreateWindowStyle()override;
				controls::GuiCustomControl::IStyleController*						CreateCustomControlStyle()override;
				controls::GuiTooltip::IStyleController*								CreateTooltipStyle()override;
				controls::GuiLabel::IStyleController*								CreateLabelStyle()override;
				controls::GuiLabel::IStyleController*								CreateShortcutKeyStyle()override;
				controls::GuiScrollContainer::IStyleProvider*						CreateScrollContainerStyle()override;
				controls::GuiControl::IStyleController*								CreateGroupBoxStyle()override;
				controls::GuiTab::IStyleController*									CreateTabStyle()override;
				controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()override;
				controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()override;
				controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()override;
				elements::text::ColorEntry											GetDefaultTextBoxColorEntry()override;
				controls::GuiDocumentViewer::IStyleProvider*						CreateDocumentViewerStyle()override;
				controls::GuiDocumentLabel::IStyleController*						CreateDocumentLabelStyle()override;
				controls::GuiListView::IStyleProvider*								CreateListViewStyle()override;
				controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateListItemBackgroundStyle()override;
				
				controls::GuiToolstripMenu::IStyleController*						CreateMenuStyle()override;
				controls::GuiToolstripMenuBar::IStyleController*					CreateMenuBarStyle()override;
				controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuBarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuItemButtonStyle()override;
				controls::GuiToolstripToolBar::IStyleController*					CreateToolBarStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolBarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolBarDropdownButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolBarSplitButtonStyle()override;
				controls::GuiControl::IStyleController*								CreateToolBarSplitterStyle()override;

				controls::GuiButton::IStyleController*								CreateButtonStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()override;
				controls::GuiDatePicker::IStyleProvider*							CreateDatePickerStyle()override;
				
				controls::GuiScroll::IStyleController*								CreateHScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateVScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateHTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateVTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateProgressBarStyle()override;
				vint																GetScrollDefaultSize()override;
				vint																GetTrackerDefaultSize()override;

				controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\GUIWIN8STYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUIWIN8STYLES
#define VCZH_PRESENTATION_CONTROLS_GUIWIN8STYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Theme
***********************************************************************/

			class Win8Theme : public Object, public theme::ITheme
			{
			public:
				Win8Theme();
				~Win8Theme();

				controls::GuiWindow::IStyleController*								CreateWindowStyle()override;
				controls::GuiCustomControl::IStyleController*						CreateCustomControlStyle()override;
				controls::GuiTooltip::IStyleController*								CreateTooltipStyle()override;
				controls::GuiLabel::IStyleController*								CreateLabelStyle()override;
				controls::GuiLabel::IStyleController*								CreateShortcutKeyStyle()override;
				controls::GuiScrollContainer::IStyleProvider*						CreateScrollContainerStyle()override;
				controls::GuiControl::IStyleController*								CreateGroupBoxStyle()override;
				controls::GuiTab::IStyleController*									CreateTabStyle()override;
				controls::GuiComboBoxBase::IStyleController*						CreateComboBoxStyle()override;
				controls::GuiScrollView::IStyleProvider*							CreateMultilineTextBoxStyle()override;
				controls::GuiSinglelineTextBox::IStyleProvider*						CreateTextBoxStyle()override;
				elements::text::ColorEntry											GetDefaultTextBoxColorEntry()override;
				controls::GuiDocumentViewer::IStyleProvider*						CreateDocumentViewerStyle()override;
				controls::GuiDocumentLabel::IStyleController*						CreateDocumentLabelStyle()override;
				controls::GuiListView::IStyleProvider*								CreateListViewStyle()override;
				controls::GuiTreeView::IStyleProvider*								CreateTreeViewStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateListItemBackgroundStyle()override;

				controls::GuiToolstripMenu::IStyleController*						CreateMenuStyle()override;
				controls::GuiToolstripMenuBar::IStyleController*					CreateMenuBarStyle()override;
				controls::GuiControl::IStyleController*								CreateMenuSplitterStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuBarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateMenuItemButtonStyle()override;
				controls::GuiToolstripToolBar::IStyleController*					CreateToolBarStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolBarButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolBarDropdownButtonStyle()override;
				controls::GuiToolstripButton::IStyleController*						CreateToolBarSplitButtonStyle()override;
				controls::GuiControl::IStyleController*								CreateToolBarSplitterStyle()override;

				controls::GuiButton::IStyleController*								CreateButtonStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateCheckBoxStyle()override;
				controls::GuiSelectableButton::IStyleController*					CreateRadioButtonStyle()override;
				controls::GuiDatePicker::IStyleProvider*							CreateDatePickerStyle()override;

				controls::GuiScroll::IStyleController*								CreateHScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateVScrollStyle()override;
				controls::GuiScroll::IStyleController*								CreateHTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateVTrackerStyle()override;
				controls::GuiScroll::IStyleController*								CreateProgressBarStyle()override;
				vint																GetScrollDefaultSize()override;
				vint																GetTrackerDefaultSize()override;

				controls::GuiScrollView::IStyleProvider*							CreateTextListStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateCheckTextListItemStyle()override;
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*		CreateRadioTextListItemStyle()override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEMPLATES\GUICONTROLTEMPLATES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATES
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATES


namespace vl
{
	namespace presentation
	{
		namespace templates
		{

#define GUI_TEMPLATE_PROPERTY_DECL(CLASS, TYPE, NAME)\
			private:\
				TYPE NAME##_;\
			public:\
				TYPE Get##NAME();\
				void Set##NAME(TYPE const& value);\
				compositions::GuiNotifyEvent NAME##Changed;\

#define GUI_TEMPLATE_PROPERTY_IMPL(CLASS, TYPE, NAME)\
			TYPE CLASS::Get##NAME()\
			{\
				return NAME##_;\
			}\
			void CLASS::Set##NAME(TYPE const& value)\
			{\
				if (NAME##_ != value)\
				{\
					NAME##_ = value;\
					NAME##Changed.Execute(compositions::GuiEventArgs(this));\
				}\
			}\

#define GUI_TEMPLATE_PROPERTY_EVENT_INIT(CLASS, TYPE, NAME)\
			NAME##Changed.SetAssociatedComposition(this);

			class GuiTemplate : public compositions::GuiBoundsComposition, public controls::GuiInstanceRootObject, public Description<GuiTemplate>
			{
			public:
				class IFactory : public IDescriptable, public Description<IFactory>
				{
				public:
					virtual GuiTemplate*				CreateTemplate(const description::Value& viewModel) = 0;

					static Ptr<IFactory>				CreateTemplateFactory(const collections::List<description::ITypeDescriptor*>& types);
				};

				GuiTemplate();
				~GuiTemplate();
				
#define GuiTemplate_PROPERTIES(F)\
				F(GuiTemplate, FontProperties, Font)\
				F(GuiTemplate, bool, VisuallyEnabled)\

				GuiTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

/***********************************************************************
Control Template
***********************************************************************/

			class GuiControlTemplate : public GuiTemplate, public Description<GuiControlTemplate>
			{
			public:
				GuiControlTemplate();
				~GuiControlTemplate();
				
#define GuiControlTemplate_PROPERTIES(F)\
				F(GuiControlTemplate, WString, Text)\
				F(GuiControlTemplate, compositions::GuiGraphicsComposition*, ContainerComposition)\
				F(GuiControlTemplate, compositions::GuiGraphicsComposition*, FocusableComposition)\

				GuiControlTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiLabelTemplate :public GuiControlTemplate, public Description<GuiLabelTemplate>
			{
			public:
				GuiLabelTemplate();
				~GuiLabelTemplate();

#define GuiLabelTemplate_PROPERTIES(F)\
				F(GuiLabelTemplate, Color, DefaultTextColor)\
				F(GuiLabelTemplate, Color, TextColor)\

				GuiLabelTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiSinglelineTextBoxTemplate : public GuiControlTemplate, public Description<GuiSinglelineTextBoxTemplate>
			{
			public:
				GuiSinglelineTextBoxTemplate();
				~GuiSinglelineTextBoxTemplate();

#define GuiSinglelineTextBoxTemplate_PROPERTIES(F)\
				F(GuiSinglelineTextBoxTemplate, elements::text::ColorEntry, TextColor)\
				F(GuiSinglelineTextBoxTemplate, Color, CaretColor)\

				GuiSinglelineTextBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiDocumentLabelTemplate : public GuiControlTemplate, public Description<GuiDocumentLabelTemplate>
			{
			public:
				GuiDocumentLabelTemplate();
				~GuiDocumentLabelTemplate();

#define GuiDocumentLabelTemplate_PROPERTIES(F)\
				F(GuiDocumentLabelTemplate, Ptr<DocumentModel>, BaselineDocument)\

				GuiDocumentLabelTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiMenuTemplate : public GuiControlTemplate, public Description<GuiMenuTemplate>
			{
			public:
				GuiMenuTemplate();
				~GuiMenuTemplate();
			};

			enum class BoolOption
			{
				AlwaysTrue,
				AlwaysFalse,
				Customizable,
			};

			class GuiWindowTemplate : public GuiControlTemplate, public Description<GuiWindowTemplate>
			{
			public:
				GuiWindowTemplate();
				~GuiWindowTemplate();

#define GuiWindowTemplate_PROPERTIES(F)\
				F(GuiWindowTemplate, BoolOption, MaximizedBoxOption)\
				F(GuiWindowTemplate, BoolOption, MinimizedBoxOption)\
				F(GuiWindowTemplate, BoolOption, BorderOption)\
				F(GuiWindowTemplate, BoolOption, SizeBoxOption)\
				F(GuiWindowTemplate, BoolOption, IconVisibleOption)\
				F(GuiWindowTemplate, BoolOption, TitleBarOption)\
				F(GuiWindowTemplate, bool, MaximizedBox)\
				F(GuiWindowTemplate, bool, MinimizedBox)\
				F(GuiWindowTemplate, bool, Border)\
				F(GuiWindowTemplate, bool, SizeBox)\
				F(GuiWindowTemplate, bool, IconVisible)\
				F(GuiWindowTemplate, bool, TitleBar)\
				F(GuiWindowTemplate, bool, CustomizedBorder)\
				F(GuiWindowTemplate, bool, Maximized)\
				F(GuiWindowTemplate, WString, TooltipTemplate)\
				F(GuiWindowTemplate, WString, ShortcutKeyTemplate)

				GuiWindowTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiButtonTemplate : public GuiControlTemplate, public Description<GuiButtonTemplate>
			{
			public:
				GuiButtonTemplate();
				~GuiButtonTemplate();

#define GuiButtonTemplate_PROPERTIES(F)\
				F(GuiButtonTemplate, controls::GuiButton::ControlState, State)\

				GuiButtonTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiSelectableButtonTemplate : public GuiButtonTemplate, public Description<GuiSelectableButtonTemplate>
			{
			public:
				GuiSelectableButtonTemplate();
				~GuiSelectableButtonTemplate();

#define GuiSelectableButtonTemplate_PROPERTIES(F)\
				F(GuiSelectableButtonTemplate, bool, Selected)\

				GuiSelectableButtonTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiToolstripButtonTemplate : public GuiSelectableButtonTemplate, public Description<GuiToolstripButtonTemplate>
			{
			public:
				GuiToolstripButtonTemplate();
				~GuiToolstripButtonTemplate();

#define GuiToolstripButtonTemplate_PROPERTIES(F)\
				F(GuiToolstripButtonTemplate, WString, SubMenuTemplate)\
				F(GuiToolstripButtonTemplate, bool, SubMenuExisting)\
				F(GuiToolstripButtonTemplate, bool, SubMenuOpening)\
				F(GuiToolstripButtonTemplate, controls::GuiButton*, SubMenuHost)\
				F(GuiToolstripButtonTemplate, Ptr<GuiImageData>, Image)\
				F(GuiToolstripButtonTemplate, WString, ShortcutText)\

				GuiToolstripButtonTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiListViewColumnHeaderTemplate :public GuiToolstripButtonTemplate, public Description<GuiListViewColumnHeaderTemplate>
			{
			public:
				GuiListViewColumnHeaderTemplate();
				~GuiListViewColumnHeaderTemplate();

#define GuiListViewColumnHeaderTemplate_PROPERTIES(F)\
				F(GuiListViewColumnHeaderTemplate, controls::GuiListViewColumnHeader::ColumnSortingState, SortingState)\

				GuiListViewColumnHeaderTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiComboBoxTemplate : public GuiToolstripButtonTemplate, public Description<GuiComboBoxTemplate>
			{
			public:
				GuiComboBoxTemplate();
				~GuiComboBoxTemplate();

#define GuiComboBoxTemplate_PROPERTIES(F)\
				F(GuiComboBoxTemplate, controls::GuiComboBoxBase::ICommandExecutor*, Commands)\

				GuiComboBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiDatePickerTemplate : public GuiControlTemplate, public Description<GuiDatePickerTemplate>
			{
			public:
				GuiDatePickerTemplate();
				~GuiDatePickerTemplate();

#define GuiDatePickerTemplate_PROPERTIES(F)\
				F(GuiDatePickerTemplate, WString, DateButtonTemplate)\
				F(GuiDatePickerTemplate, WString, DateTextListTemplate)\
				F(GuiDatePickerTemplate, WString, DateComboBoxTemplate)\
				F(GuiDatePickerTemplate, Color, BackgroundColor)\
				F(GuiDatePickerTemplate, Color, PrimaryTextColor)\
				F(GuiDatePickerTemplate, Color, SecondaryTextColor)\

				GuiDatePickerTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiDateComboBoxTemplate : public GuiComboBoxTemplate, public Description<GuiDateComboBoxTemplate>
			{
			public:
				GuiDateComboBoxTemplate();
				~GuiDateComboBoxTemplate();

#define GuiDateComboBoxTemplate_PROPERTIES(F)\
				F(GuiDateComboBoxTemplate, WString, DatePickerTemplate)\

				GuiDateComboBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiScrollTemplate : public GuiControlTemplate, public Description<GuiScrollTemplate>
			{
			public:
				GuiScrollTemplate();
				~GuiScrollTemplate();

#define GuiScrollTemplate_PROPERTIES(F)\
				F(GuiScrollTemplate, controls::GuiScroll::ICommandExecutor*, Commands)\
				F(GuiScrollTemplate, vint, TotalSize)\
				F(GuiScrollTemplate, vint, PageSize)\
				F(GuiScrollTemplate, vint, Position)\

				GuiScrollTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiScrollViewTemplate : public GuiControlTemplate, public Description<GuiScrollViewTemplate>
			{
			public:
				GuiScrollViewTemplate();
				~GuiScrollViewTemplate();

#define GuiScrollViewTemplate_PROPERTIES(F)\
				F(GuiScrollViewTemplate, WString, HScrollTemplate)\
				F(GuiScrollViewTemplate, WString, VScrollTemplate)\
				F(GuiScrollViewTemplate, vint, DefaultScrollSize)\

				GuiScrollViewTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiMultilineTextBoxTemplate : public GuiScrollViewTemplate, public Description<GuiMultilineTextBoxTemplate>
			{
			public:
				GuiMultilineTextBoxTemplate();
				~GuiMultilineTextBoxTemplate();

#define GuiMultilineTextBoxTemplate_PROPERTIES(F)\
				F(GuiMultilineTextBoxTemplate, elements::text::ColorEntry, TextColor)\
				F(GuiMultilineTextBoxTemplate, Color, CaretColor)\

				GuiMultilineTextBoxTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiDocumentViewerTemplate : public GuiScrollViewTemplate, public Description<GuiDocumentViewerTemplate>
			{
			public:
				GuiDocumentViewerTemplate();
				~GuiDocumentViewerTemplate();

#define GuiDocumentViewerTemplate_PROPERTIES(F)\
				F(GuiDocumentViewerTemplate, Ptr<DocumentModel>, BaselineDocument)\

				GuiDocumentViewerTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiTextListTemplate : public GuiScrollViewTemplate, public Description<GuiTextListTemplate>
			{
			public:
				GuiTextListTemplate();
				~GuiTextListTemplate();

#define GuiTextListTemplate_PROPERTIES(F)\
				F(GuiTextListTemplate, WString, BackgroundTemplate)\
				F(GuiTextListTemplate, WString, BulletTemplate)\
				F(GuiTextListTemplate, Color, TextColor)\

				GuiTextListTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiListViewTemplate : public GuiScrollViewTemplate, public Description<GuiListViewTemplate>
			{
			public:
				GuiListViewTemplate();
				~GuiListViewTemplate();

#define GuiListViewTemplate_PROPERTIES(F)\
				F(GuiListViewTemplate, WString, BackgroundTemplate)\
				F(GuiListViewTemplate, WString, ColumnHeaderTemplate)\
				F(GuiListViewTemplate, Color, PrimaryTextColor)\
				F(GuiListViewTemplate, Color, SecondaryTextColor)\
				F(GuiListViewTemplate, Color, ItemSeparatorColor)\

				GuiListViewTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiTreeViewTemplate : public GuiScrollViewTemplate, public Description<GuiTreeViewTemplate>
			{
			public:
				GuiTreeViewTemplate();
				~GuiTreeViewTemplate();

#define GuiTreeViewTemplate_PROPERTIES(F)\
				F(GuiTreeViewTemplate, WString, BackgroundTemplate)\
				F(GuiTreeViewTemplate, WString, ExpandingDecoratorTemplate)\
				F(GuiTreeViewTemplate, Color, TextColor)\

				GuiTreeViewTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiTabTemplate : public GuiControlTemplate, public Description<GuiTabTemplate>
			{
			public:
				GuiTabTemplate();
				~GuiTabTemplate();

#define GuiTabTemplate_PROPERTIES(F)\
				F(GuiTabTemplate, WString, HeaderTemplate)\
				F(GuiTabTemplate, WString, DropdownTemplate)\
				F(GuiTabTemplate, WString, MenuTemplate)\
				F(GuiTabTemplate, WString, MenuItemTemplate)\
				F(GuiTabTemplate, vint, HeaderPadding)\
				F(GuiTabTemplate, compositions::GuiGraphicsComposition*, HeaderComposition)\

				GuiTabTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

/***********************************************************************
Item Template
***********************************************************************/

			class GuiListItemTemplate : public GuiTemplate, public Description<GuiListItemTemplate>
			{
			public:
				GuiListItemTemplate();
				~GuiListItemTemplate();
				
#define GuiListItemTemplate_PROPERTIES(F)\
				F(GuiListItemTemplate, bool, Selected)\
				F(GuiListItemTemplate, vint, Index)\

				GuiListItemTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiTreeItemTemplate : public GuiListItemTemplate, public Description<GuiTreeItemTemplate>
			{
			public:
				GuiTreeItemTemplate();
				~GuiTreeItemTemplate();
				
#define GuiTreeItemTemplate_PROPERTIES(F)\
				F(GuiTreeItemTemplate, bool, Expanding)\

				GuiTreeItemTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiGridVisualizerTemplate : public GuiControlTemplate , public Description<GuiGridVisualizerTemplate>
			{
			public:
				GuiGridVisualizerTemplate();
				~GuiGridVisualizerTemplate();

#define GuiGridVisualizerTemplate_PROPERTIES(F)\
				F(GuiGridVisualizerTemplate, description::Value, RowValue)\
				F(GuiGridVisualizerTemplate, description::Value, CellValue)\
				F(GuiGridVisualizerTemplate, bool, Selected)\

				GuiGridVisualizerTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};

			class GuiGridEditorTemplate : public GuiControlTemplate , public Description<GuiGridEditorTemplate>
			{
			public:
				GuiGridEditorTemplate();
				~GuiGridEditorTemplate();

#define GuiGridEditorTemplate_PROPERTIES(F)\
				F(GuiGridEditorTemplate, description::Value, RowValue)\
				F(GuiGridEditorTemplate, description::Value, CellValue)\

				GuiGridEditorTemplate_PROPERTIES(GUI_TEMPLATE_PROPERTY_DECL)
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEMPLATES\GUICONTROLTEMPLATESTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Template System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATESTYLES
#define VCZH_PRESENTATION_CONTROLS_TEMPLATES_GUICONTROLTEMPLATESTYLES


namespace vl
{
	namespace presentation
	{
		namespace templates
		{
#pragma warning(push)
#pragma warning(disable:4250)

/***********************************************************************
Control Template
***********************************************************************/

			class GuiControlTemplate_StyleProvider
				: public Object
				, public virtual controls::GuiControl::IStyleController
				, public virtual controls::GuiControl::IStyleProvider
				, public Description<GuiControlTemplate_StyleProvider>
			{
			protected:
				controls::GuiControl::IStyleController*							associatedStyleController;
				GuiControlTemplate*												controlTemplate;

			public:
				GuiControlTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiControlTemplate_StyleProvider();

				compositions::GuiBoundsComposition*								GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*							GetContainerComposition()override;
				void															AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void															SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void															SetText(const WString& value)override;
				void															SetFont(const FontProperties& value)override;
				void															SetVisuallyEnabled(bool value)override;
			};

			class GuiLabelTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public controls::GuiLabel::IStyleController
				, public Description<GuiLabelTemplate_StyleProvider>
			{
			protected:
				GuiLabelTemplate*												controlTemplate;

			public:
				GuiLabelTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiLabelTemplate_StyleProvider();

				Color															GetDefaultTextColor()override;
				void															SetTextColor(Color value)override;
			};

			class GuiSinglelineTextBoxTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public virtual controls::GuiSinglelineTextBox::IStyleProvider
				, public Description<GuiSinglelineTextBoxTemplate_StyleProvider>
			{
			protected:
				GuiSinglelineTextBoxTemplate*									controlTemplate;
				
			public:
				GuiSinglelineTextBoxTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiSinglelineTextBoxTemplate_StyleProvider();
				
				void															SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				compositions::GuiGraphicsComposition*							InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

			class GuiDocumentLabelTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public virtual controls::GuiDocumentLabel::IStyleController
				, public Description<GuiDocumentLabelTemplate_StyleProvider>
			{
			protected:
				GuiDocumentLabelTemplate*										controlTemplate;
				
			public:
				GuiDocumentLabelTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiDocumentLabelTemplate_StyleProvider();
				
				Ptr<DocumentModel>												GetBaselineDocument()override;
			};

			class GuiMenuTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public controls::GuiWindow::DefaultBehaviorStyleController
				, public Description<GuiMenuTemplate_StyleProvider>
			{
			public:
				GuiMenuTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiMenuTemplate_StyleProvider();
			};

			class GuiWindowTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public controls::GuiWindow::IStyleController
				, public Description<GuiWindowTemplate_StyleProvider>
			{
			protected:
				GuiWindowTemplate*												controlTemplate;
				controls::GuiWindow*											window;
				Ptr<GuiTemplate::IFactory>										tooltipTemplateFactory;
				Ptr<GuiTemplate::IFactory>										shortcutKeyTemplateFactory;

			public:
				GuiWindowTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiWindowTemplate_StyleProvider();

				void															AttachWindow(controls::GuiWindow* _window)override;
				void															InitializeNativeWindowProperties()override;
				void															SetSizeState(INativeWindow::WindowSizeState value)override;
				bool															GetMaximizedBox()override;
				void															SetMaximizedBox(bool visible)override;
				bool															GetMinimizedBox()override;
				void															SetMinimizedBox(bool visible)override;
				bool															GetBorder()override;
				void															SetBorder(bool visible)override;
				bool															GetSizeBox()override;
				void															SetSizeBox(bool visible)override;
				bool															GetIconVisible()override;
				void															SetIconVisible(bool visible)override;
				bool															GetTitleBar()override;
				void															SetTitleBar(bool visible)override;
				controls::GuiWindow::IStyleController*							CreateTooltipStyle()override;
				controls::GuiLabel::IStyleController*							CreateShortcutKeyStyle()override;
			};

			class GuiButtonTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public virtual controls::GuiButton::IStyleController
				, public Description<GuiButtonTemplate_StyleProvider>
			{
			protected:
				GuiButtonTemplate*												controlTemplate;

			public:
				GuiButtonTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiButtonTemplate_StyleProvider();

				void															Transfer(controls::GuiButton::ControlState value)override;
			};

			class GuiSelectableButtonTemplate_StyleProvider
				: public GuiButtonTemplate_StyleProvider
				, public virtual controls::GuiSelectableButton::IStyleController
				, public Description<GuiSelectableButtonTemplate_StyleProvider>
			{
			protected:
				GuiSelectableButtonTemplate*									controlTemplate;

			public:
				GuiSelectableButtonTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiSelectableButtonTemplate_StyleProvider();

				void															SetSelected(bool value)override;
			};

			class GuiToolstripButtonTemplate_StyleProvider
				: public GuiSelectableButtonTemplate_StyleProvider
				, public virtual controls::GuiMenuButton::IStyleController
				, public Description<GuiToolstripButtonTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										subMenuTemplateFactory;
				GuiToolstripButtonTemplate*										controlTemplate;

			public:
				GuiToolstripButtonTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiToolstripButtonTemplate_StyleProvider();
				
				controls::GuiMenu::IStyleController*							CreateSubMenuStyleController()override;
				void															SetSubMenuExisting(bool value)override;
				void															SetSubMenuOpening(bool value)override;
				controls::GuiButton*											GetSubMenuHost()override;
				void															SetImage(Ptr<GuiImageData> value)override;
				void															SetShortcutText(const WString& value)override;
			};

			class GuiListViewColumnHeaderTemplate_StyleProvider
				: public GuiToolstripButtonTemplate_StyleProvider
				, public virtual controls::GuiListViewColumnHeader::IStyleController
				, public Description<GuiListViewColumnHeaderTemplate_StyleProvider>
			{
			protected:
				GuiListViewColumnHeaderTemplate*								controlTemplate;

			public:
				GuiListViewColumnHeaderTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiListViewColumnHeaderTemplate_StyleProvider();

				void															SetColumnSortingState(controls::GuiListViewColumnHeader::ColumnSortingState value)override;
			};

			class GuiComboBoxTemplate_StyleProvider
				: public GuiToolstripButtonTemplate_StyleProvider
				, public virtual controls::GuiComboBoxBase::IStyleController
				, public Description<GuiComboBoxTemplate_StyleProvider>
			{
			protected:
				GuiComboBoxTemplate*											controlTemplate;

			public:
				GuiComboBoxTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiComboBoxTemplate_StyleProvider();
				
				void															SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)override;
				void															OnItemSelected()override;
			};

			class GuiTextListTemplate_StyleProvider;

			class GuiDatePickerTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public virtual controls::GuiDatePicker::IStyleProvider
				, public Description<GuiDatePickerTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										dateButtonTemplateFactory;
				Ptr<GuiTemplate::IFactory>										dateTextListTemplateFactory;
				Ptr<GuiTemplate::IFactory>										dateComboBoxTemplateFactory;
				GuiDatePickerTemplate*											controlTemplate;

			public:
				GuiDatePickerTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiDatePickerTemplate_StyleProvider();

				controls::GuiSelectableButton::IStyleController*				CreateDateButtonStyle()override;
				GuiTextListTemplate_StyleProvider*								CreateTextListStyle();
				controls::GuiTextList*											CreateTextList()override;
				controls::GuiComboBoxListControl::IStyleController*				CreateComboBoxStyle()override;
				Color															GetBackgroundColor()override;
				Color															GetPrimaryTextColor()override;
				Color															GetSecondaryTextColor()override;
			};

			class GuiDateComboBoxTemplate_StyleProvider
				: public GuiComboBoxTemplate_StyleProvider
				, public Description<GuiDateComboBoxTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										datePickerTemplateFactory;
				GuiDateComboBoxTemplate*										controlTemplate;

			public:
				GuiDateComboBoxTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiDateComboBoxTemplate_StyleProvider();

				controls::GuiDatePicker*										CreateArgument();
				controls::GuiDatePicker::IStyleProvider*						CreateDatePickerStyle();
			};

			class GuiScrollTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public virtual controls::GuiScroll::IStyleController
				, public Description<GuiScrollTemplate_StyleProvider>
			{
			protected:
				GuiScrollTemplate*												controlTemplate;

			public:
				GuiScrollTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiScrollTemplate_StyleProvider();

				void															SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void															SetTotalSize(vint value)override;
				void															SetPageSize(vint value)override;
				void															SetPosition(vint value)override;
			};

			class GuiScrollViewTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public virtual controls::GuiScrollView::IStyleProvider
				, public Description<GuiScrollViewTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										hScrollTemplateFactory;
				Ptr<GuiTemplate::IFactory>										vScrollTemplateFactory;
				GuiScrollViewTemplate*											controlTemplate;
				
			public:
				GuiScrollViewTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiScrollViewTemplate_StyleProvider();
				
				controls::GuiScroll::IStyleController*							CreateHorizontalScrollStyle()override;
				controls::GuiScroll::IStyleController*							CreateVerticalScrollStyle()override;
				vint															GetDefaultScrollSize()override;
				compositions::GuiGraphicsComposition*							InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

			class GuiMultilineTextBoxTemplate_StyleProvider
				: public GuiScrollViewTemplate_StyleProvider
				, public Description<GuiMultilineTextBoxTemplate_StyleProvider>
			{
			protected:
				GuiMultilineTextBoxTemplate*									controlTemplate;
				
			public:
				GuiMultilineTextBoxTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiMultilineTextBoxTemplate_StyleProvider();
				
				void															SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
			};

			class GuiDocumentViewerTemplate_StyleProvider
				: public GuiScrollViewTemplate_StyleProvider
				, public virtual controls::GuiDocumentViewer::IStyleProvider
				, public Description<GuiDocumentViewerTemplate_StyleProvider>
			{
			protected:
				GuiDocumentViewerTemplate*										controlTemplate;
				
			public:
				GuiDocumentViewerTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiDocumentViewerTemplate_StyleProvider();
				
				Ptr<DocumentModel>												GetBaselineDocument()override;
			};

			class GuiTextListTemplate_StyleProvider
				: public GuiScrollViewTemplate_StyleProvider
				, public virtual controls::GuiScrollView::IStyleProvider
				, public Description<GuiTextListTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										backgroundTemplateFactory;
				Ptr<GuiTemplate::IFactory>										bulletTemplateFactory;
				GuiTextListTemplate*											controlTemplate;
				
				class ItemStyleProvider
					: public Object
					, public virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider
				{
				protected:
					GuiTextListTemplate_StyleProvider*							styleProvider;

				public:
					ItemStyleProvider(GuiTextListTemplate_StyleProvider* _styleProvider);
					~ItemStyleProvider();

					controls::GuiSelectableButton::IStyleController*			CreateBackgroundStyleController()override;
					controls::GuiSelectableButton::IStyleController*			CreateBulletStyleController()override;
					Color														GetTextColor()override;
				};
			public:
				GuiTextListTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiTextListTemplate_StyleProvider();
				
				controls::list::TextItemStyleProvider::ITextItemStyleProvider*	CreateArgument();
				controls::GuiSelectableButton::IStyleController*				CreateBackgroundStyle();
				controls::GuiSelectableButton::IStyleController*				CreateBulletStyle();
			};

			class GuiListViewTemplate_StyleProvider
				: public GuiScrollViewTemplate_StyleProvider
				, public virtual controls::GuiListViewBase::IStyleProvider
				, public Description<GuiListViewTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										backgroundTemplateFactory;
				Ptr<GuiTemplate::IFactory>										columnHeaderTemplateFactory;
				GuiListViewTemplate*											controlTemplate;
				
			public:
				GuiListViewTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiListViewTemplate_StyleProvider();
				
				controls::GuiSelectableButton::IStyleController*				CreateItemBackground()override;
				controls::GuiListViewColumnHeader::IStyleController*			CreateColumnStyle()override;
				Color															GetPrimaryTextColor()override;
				Color															GetSecondaryTextColor()override;
				Color															GetItemSeparatorColor()override;
			};

			class GuiTreeViewTemplate_StyleProvider
				: public GuiScrollViewTemplate_StyleProvider
				, public virtual controls::GuiVirtualTreeView::IStyleProvider
				, public Description<GuiTreeViewTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										backgroundTemplateFactory;
				Ptr<GuiTemplate::IFactory>										expandingDecoratorTemplateFactory;
				GuiTreeViewTemplate*											controlTemplate;
				
			public:
				GuiTreeViewTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiTreeViewTemplate_StyleProvider();
				
				controls::GuiSelectableButton::IStyleController*				CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*				CreateItemExpandingDecorator()override;
				Color															GetTextColor()override;
			};

			class GuiTabTemplate_StyleProvider
				: public GuiControlTemplate_StyleProvider
				, public virtual controls::GuiTab::IStyleController
				, public Description<GuiTabTemplate_StyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>										headerTemplateFactory;
				Ptr<GuiTemplate::IFactory>										dropdownTemplateFactory;
				Ptr<GuiTemplate::IFactory>										menuTemplateFactory;
				Ptr<GuiTemplate::IFactory>										menuItemTemplateFactory;
				GuiTabTemplate*													controlTemplate;
				
				compositions::GuiTableComposition*								tabBoundsComposition;
				compositions::GuiStackComposition*								tabHeaderComposition;
				compositions::GuiBoundsComposition*								tabContentTopLineComposition;
				controls::GuiTab::ICommandExecutor*								commandExecutor;

				Ptr<controls::GuiSelectableButton::MutexGroupController>		headerController;
				collections::List<controls::GuiSelectableButton*>				headerButtons;
				controls::GuiButton*											headerOverflowButton;
				controls::GuiToolstripMenu*										headerOverflowMenu;
				
				controls::GuiSelectableButton::IStyleController*				CreateHeaderTemplate();
				controls::GuiButton::IStyleController*							CreateDropdownTemplate();
				controls::GuiMenu::IStyleController*							CreateMenuTemplate();
				controls::GuiToolstripButton::IStyleController*					CreateMenuItemTemplate();

				void															OnHeaderButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void															OnTabHeaderBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void															OnHeaderOverflowButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void															OnHeaderOverflowMenuButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void															UpdateHeaderOverflowButtonVisibility();
				void															UpdateHeaderZOrder();
				void															UpdateHeaderVisibilityIndex();
				void															UpdateHeaderLayout();

				void															Initialize();
			public:
				GuiTabTemplate_StyleProvider(Ptr<GuiTemplate::IFactory> factory);
				~GuiTabTemplate_StyleProvider();

				void															SetCommandExecutor(controls::GuiTab::ICommandExecutor* value)override;
				void															InsertTab(vint index)override;
				void															SetTabText(vint index, const WString& value)override;
				void															RemoveTab(vint index)override;
				void															MoveTab(vint oldIndex, vint newIndex)override;
				void															SetSelectedTab(vint index)override;
				void															SetTabAlt(vint index, const WString& value, compositions::IGuiAltActionHost* host)override;
				compositions::IGuiAltAction*									GetTabAltAction(vint index)override;
			};

/***********************************************************************
Item Template (GuiListItemTemplate)
***********************************************************************/

			class GuiListItemTemplate_ItemStyleProvider
				: public Object
				, public virtual controls::GuiSelectableListControl::IItemStyleProvider
				, public Description<GuiListItemTemplate_ItemStyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>							factory;
				controls::GuiListControl*							listControl;
				controls::GuiListControl::IItemBindingView*			bindingView;

			public:
				GuiListItemTemplate_ItemStyleProvider(Ptr<GuiTemplate::IFactory> _factory);
				~GuiListItemTemplate_ItemStyleProvider();

				void												AttachListControl(controls::GuiListControl* value)override;
				void												DetachListControl()override;
				vint												GetItemStyleId(vint itemIndex)override;
				controls::GuiListControl::IItemStyleController*		CreateItemStyle(vint styleId)override;
				void												DestroyItemStyle(controls::GuiListControl::IItemStyleController* style)override;
				void												Install(controls::GuiListControl::IItemStyleController* style, vint itemIndex)override;
				void												SetStyleIndex(controls::GuiListControl::IItemStyleController* style, vint value)override;
				void												SetStyleSelected(controls::GuiListControl::IItemStyleController* style, bool value)override;
			};

			class GuiListItemTemplate_ItemStyleController
				: public Object
				, public virtual controls::GuiListControl::IItemStyleController
				, public Description<GuiListItemTemplate_ItemStyleController>
			{
			protected:
				GuiListItemTemplate_ItemStyleProvider*				itemStyleProvider;
				GuiListItemTemplate*								itemTemplate;
				bool												installed;

			public:
				GuiListItemTemplate_ItemStyleController(GuiListItemTemplate_ItemStyleProvider* _itemStyleProvider);
				~GuiListItemTemplate_ItemStyleController();

				GuiListItemTemplate*								GetTemplate();
				void												SetTemplate(GuiListItemTemplate* _itemTemplate);

				controls::GuiListControl::IItemStyleProvider*		GetStyleProvider()override;
				vint												GetItemStyleId()override;
				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				bool												IsCacheable()override;
				bool												IsInstalled()override;
				void												OnInstalled()override;
				void												OnUninstalled()override;
			};

/***********************************************************************
Item Template (GuiTreeItemTemplate)
***********************************************************************/

			class GuiTreeItemTemplate_ItemStyleProvider
				: public Object
				, public virtual controls::tree::INodeItemStyleProvider
				, protected virtual controls::tree::INodeProviderCallback
				, public Description<GuiTreeItemTemplate_ItemStyleProvider>
			{
			protected:
				Ptr<GuiTemplate::IFactory>							factory;
				controls::GuiVirtualTreeListControl*				treeListControl;
				controls::tree::INodeItemBindingView*				bindingView;
				controls::GuiListControl::IItemStyleProvider*		itemStyleProvider;
				
				void												UpdateExpandingButton(controls::tree::INodeProvider* node);
				void												OnAttached(controls::tree::INodeRootProvider* provider)override;
				void												OnBeforeItemModified(controls::tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void												OnAfterItemModified(controls::tree::INodeProvider* parentNode, vint start, vint count, vint newCount)override;
				void												OnItemExpanded(controls::tree::INodeProvider* node)override;
				void												OnItemCollapsed(controls::tree::INodeProvider* node)override;

			public:
				GuiTreeItemTemplate_ItemStyleProvider(Ptr<GuiTemplate::IFactory> _factory);
				~GuiTreeItemTemplate_ItemStyleProvider();
				
				void												BindItemStyleProvider(controls::GuiListControl::IItemStyleProvider* styleProvider)override;
				controls::GuiListControl::IItemStyleProvider*		GetBindedItemStyleProvider()override;
				void												AttachListControl(controls::GuiListControl* value)override;
				void												DetachListControl()override;
				vint												GetItemStyleId(controls::tree::INodeProvider* node)override;
				controls::tree::INodeItemStyleController*			CreateItemStyle(vint styleId)override;
				void												DestroyItemStyle(controls::tree::INodeItemStyleController* style)override;
				void												Install(controls::tree::INodeItemStyleController* style, controls::tree::INodeProvider* node, vint itemIndex)override;
				void												SetStyleIndex(controls::tree::INodeItemStyleController* style, vint value)override;
				void												SetStyleSelected(controls::tree::INodeItemStyleController* style, bool value)override;
			};
			
			class GuiTreeItemTemplate_ItemStyleController
				: public GuiListItemTemplate_ItemStyleController
				, public virtual controls::tree::INodeItemStyleController
				, public Description<GuiTreeItemTemplate_ItemStyleController>
			{
			protected:
				GuiTreeItemTemplate_ItemStyleProvider*				nodeStyleProvider;

			public:
				GuiTreeItemTemplate_ItemStyleController(GuiTreeItemTemplate_ItemStyleProvider* _nodeStyleProvider);
				~GuiTreeItemTemplate_ItemStyleController();
				
				controls::GuiListControl::IItemStyleProvider*		GetStyleProvider()override;
				controls::tree::INodeItemStyleProvider*				GetNodeStyleProvider()override;
			};

/***********************************************************************
Item Template (GuiGridVisualizerTemplate)
***********************************************************************/

			class GuiBindableDataVisualizer : public controls::list::DataVisualizerBase, public Description<GuiBindableDataVisualizer>
			{
			public:
				class Factory : public controls::list::DataVisualizerFactory<GuiBindableDataVisualizer>
				{
				protected:
					Ptr<GuiTemplate::IFactory>						templateFactory;
					controls::list::BindableDataColumn*				ownerColumn;

				public:
					Factory(Ptr<GuiTemplate::IFactory> _templateFactory, controls::list::BindableDataColumn* _ownerColumn);
					~Factory();

					Ptr<controls::list::IDataVisualizer>			CreateVisualizer(const FontProperties& font, controls::GuiListViewBase::IStyleProvider* styleProvider)override;
				};

				class DecoratedFactory : public controls::list::DataDecoratableVisualizerFactory<GuiBindableDataVisualizer>
				{
				protected:
					Ptr<GuiTemplate::IFactory>						templateFactory;
					controls::list::BindableDataColumn*				ownerColumn;

				public:
					DecoratedFactory(Ptr<GuiTemplate::IFactory> _templateFactory, controls::list::BindableDataColumn* _ownerColumn, Ptr<IDataVisualizerFactory> _decoratedFactory);
					~DecoratedFactory();

					Ptr<controls::list::IDataVisualizer>			CreateVisualizer(const FontProperties& font, controls::GuiListViewBase::IStyleProvider* styleProvider)override;
				};

			protected:
				Ptr<GuiTemplate::IFactory>							templateFactory;
				controls::list::BindableDataColumn*					ownerColumn = nullptr;
				GuiGridVisualizerTemplate*							visualizerTemplate = nullptr;

				compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal(compositions::GuiBoundsComposition* decoratedComposition)override;
			public:
				GuiBindableDataVisualizer();
				GuiBindableDataVisualizer(Ptr<controls::list::IDataVisualizer> _decoratedVisualizer);
				~GuiBindableDataVisualizer();

				void												BeforeVisualizeCell(controls::list::IDataProvider* dataProvider, vint row, vint column)override;
				void												SetSelected(bool value)override;
			};

/***********************************************************************
Item Template (GuiGridEditorTemplate)
***********************************************************************/

			class GuiBindableDataEditor : public controls::list::DataEditorBase, public Description<GuiBindableDataEditor>
			{
			public:
				class Factory : public controls::list::DataEditorFactory<GuiBindableDataEditor>
				{
				protected:
					Ptr<GuiTemplate::IFactory>						templateFactory;
					controls::list::BindableDataColumn*				ownerColumn;

				public:
					Factory(Ptr<GuiTemplate::IFactory> _templateFactory, controls::list::BindableDataColumn* _ownerColumn);
					~Factory();

					Ptr<IDataEditor>								CreateEditor(controls::list::IDataEditorCallback* callback)override;
				};

			protected:
				Ptr<GuiTemplate::IFactory>							templateFactory;
				controls::list::BindableDataColumn*					ownerColumn = nullptr;
				GuiGridEditorTemplate*								editorTemplate = nullptr;

				compositions::GuiBoundsComposition*					CreateBoundsCompositionInternal()override;
				void												editorTemplate_CellValueChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				GuiBindableDataEditor();
				~GuiBindableDataEditor();

				void												BeforeEditCell(controls::list::IDataProvider* dataProvider, vint row, vint column)override;
				description::Value									GetEditedCellValue();
			};

/***********************************************************************
Helper Functions
***********************************************************************/

			extern void												SplitBySemicolon(const WString& input, collections::List<WString>& fragments);
			extern Ptr<GuiTemplate::IFactory>						CreateTemplateFactory(const WString& typeValues);

#pragma warning(pop)
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\GUICOMMONSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Common Style Helpers

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES
#define VCZH_PRESENTATION_CONTROLS_GUICOMMONSTYLES


namespace vl
{
	namespace presentation
	{
		namespace common_styles
		{

/***********************************************************************
CommonScrollStyle
***********************************************************************/

			class CommonScrollStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonScrollStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				controls::GuiButton*								decreaseButton;
				controls::GuiButton*								increaseButton;
				controls::GuiButton*								handleButton;
				compositions::GuiPartialViewComposition*			handleComposition;
				compositions::GuiBoundsComposition*					boundsComposition;
				compositions::GuiBoundsComposition*					containerComposition;

				vint												totalSize;
				vint												pageSize;
				vint												position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnDecreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnIncreaseButtonClicked(compositions::GuiGraphicsComposition* sender,compositions::GuiEventArgs& arguments);
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);;
				void												OnBigMoveMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);

				virtual controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction)=0;
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual compositions::GuiBoundsComposition*			InstallBackground(compositions::GuiBoundsComposition* boundsComposition, Direction direction)=0;
				void												BuildStyle(vint defaultSize, vint arrowSize);
			public:
				CommonScrollStyle(Direction _direction);
				~CommonScrollStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(vint value)override;
				void												SetPageSize(vint value)override;
				void												SetPosition(vint value)override;
			};

/***********************************************************************
CommonTrackStyle
***********************************************************************/
			
			class CommonTrackStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<CommonTrackStyle>
			{
			public:
				enum Direction
				{
					Horizontal,
					Vertical,
				};
			protected:
				Direction											direction;
				controls::GuiScroll::ICommandExecutor*				commandExecutor;
				compositions::GuiBoundsComposition*					boundsComposition;
				controls::GuiButton*								handleButton;
				compositions::GuiTableComposition*					handleComposition;

				vint												totalSize;
				vint												pageSize;
				vint												position;
				Point												draggingStartLocation;
				bool												draggingHandle;

				void												UpdateHandle();
				void												OnHandleMouseDown(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseMove(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				void												OnHandleMouseUp(compositions::GuiGraphicsComposition* sender,compositions::GuiMouseEventArgs& arguments);
				
				virtual controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)=0;
				virtual void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)=0;
				virtual void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)=0;
				void												BuildStyle(vint trackThickness, vint trackPadding, vint handleLong, vint handleShort);
			public:
				CommonTrackStyle(Direction _direction);
				~CommonTrackStyle();

				compositions::GuiBoundsComposition*					GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*				GetContainerComposition()override;
				void												SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void												SetText(const WString& value)override;
				void												SetFont(const FontProperties& value)override;
				void												SetVisuallyEnabled(bool value)override;
				void												SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void												SetTotalSize(vint value)override;
				void												SetPageSize(vint value)override;
				void												SetPosition(vint value)override;
			};

/***********************************************************************
CommonFragmentBuilder
***********************************************************************/

			class CommonFragmentBuilder
			{
			private:
				static compositions::GuiBoundsComposition*			BuildDockedElementContainer(elements::IGuiGraphicsElement* element);
			public:
				static void											FillUpArrow(elements::GuiPolygonElement* element);
				static void											FillDownArrow(elements::GuiPolygonElement* element);
				static void											FillLeftArrow(elements::GuiPolygonElement* element);
				static void											FillRightArrow(elements::GuiPolygonElement* element);

				static elements::GuiPolygonElement*					BuildUpArrow();
				static elements::GuiPolygonElement*					BuildDownArrow();
				static elements::GuiPolygonElement*					BuildLeftArrow();
				static elements::GuiPolygonElement*					BuildRightArrow();

				static compositions::GuiBoundsComposition*			BuildUpArrow(elements::GuiPolygonElement*& elementOut);
				static compositions::GuiBoundsComposition*			BuildDownArrow(elements::GuiPolygonElement*& elementOut);
				static compositions::GuiBoundsComposition*			BuildLeftArrow(elements::GuiPolygonElement*& elementOut);
				static compositions::GuiBoundsComposition*			BuildRightArrow(elements::GuiPolygonElement*& elementOut);
			};
		}

/***********************************************************************
Helper Functions
***********************************************************************/
			
		extern unsigned char							IntToColor(vint color);
		extern Color									BlendColor(Color c1, Color c2, vint currentPosition, vint totalLength);

/***********************************************************************
Animation
***********************************************************************/

#define DEFINE_TRANSFERRING_ANIMATION(TSTATE, TSTYLECONTROLLER)\
				class TransferringAnimation : public compositions::GuiTimeBasedAnimation\
				{\
				protected:\
					TSTATE									colorBegin;\
					TSTATE									colorEnd;\
					TSTATE									colorCurrent;\
					TSTYLECONTROLLER*						style;\
					bool									stopped;\
					bool									disabled;\
					bool									enableAnimation;\
					void									PlayInternal(vint currentPosition, vint totalLength);\
				public:\
					TransferringAnimation(TSTYLECONTROLLER* _style, const TSTATE& begin);\
					void									Disable();\
					void									Play(vint currentPosition, vint totalLength)override;\
					void									Stop()override;\
					bool									GetEnableAnimation();\
					void									SetEnableAnimation(bool value);\
					void									Transfer(const TSTATE& end);\
				};\

/***********************************************************************
Animation Implementation
***********************************************************************/

#define DEFAULT_TRANSFERRING_ANIMATION_HOST_GETTER(STYLE) (STYLE->GetBoundsComposition()->GetRelatedGraphicsHost())

#define IMPLEMENT_TRANSFERRING_ANIMATION_BASE(TSTATE, TSTYLECONTROLLER, HOST_GETTER)\
			TSTYLECONTROLLER::TransferringAnimation::TransferringAnimation(TSTYLECONTROLLER* _style, const TSTATE& begin)\
				:GuiTimeBasedAnimation(0)\
				,colorBegin(begin)\
				,colorEnd(begin)\
				,colorCurrent(begin)\
				,style(_style)\
				,stopped(true)\
				,disabled(false)\
				,enableAnimation(true)\
			{\
			}\
			void TSTYLECONTROLLER::TransferringAnimation::Disable()\
			{\
				disabled=true;\
			}\
			void TSTYLECONTROLLER::TransferringAnimation::Play(vint currentPosition, vint totalLength)\
			{\
				if(!disabled)\
				{\
					PlayInternal(currentPosition, totalLength);\
				}\
			}\
			void TSTYLECONTROLLER::TransferringAnimation::Stop()\
			{\
				stopped=true;\
			}\
			bool TSTYLECONTROLLER::TransferringAnimation::GetEnableAnimation()\
			{\
				return enableAnimation;\
			}\
			void TSTYLECONTROLLER::TransferringAnimation::SetEnableAnimation(bool value)\
			{\
				enableAnimation=value;\
			}\
			void TSTYLECONTROLLER::TransferringAnimation::Transfer(const TSTATE& end)\
			{\
				if(colorEnd!=end)\
				{\
					GuiGraphicsHost* host=HOST_GETTER(style);\
					if(enableAnimation && host)\
					{\
						Restart(120);\
						if(stopped)\
						{\
							colorBegin=colorEnd;\
							colorEnd=end;\
							host->GetAnimationManager()->AddAnimation(style->transferringAnimation);\
							stopped=false;\
						}\
						else\
						{\
							colorBegin=colorCurrent;\
							colorEnd=end;\
						}\
					}\
					else\
					{\
						colorBegin=end;\
						colorEnd=end;\
						colorCurrent=end;\
						Play(1, 1);\
					}\
				}\
			}\
			void TSTYLECONTROLLER::TransferringAnimation::PlayInternal(vint currentPosition, vint totalLength)\

#define IMPLEMENT_TRANSFERRING_ANIMATION(TSTATE, TSTYLECONTROLLER)\
	IMPLEMENT_TRANSFERRING_ANIMATION_BASE(TSTATE, TSTYLECONTROLLER, DEFAULT_TRANSFERRING_ANIMATION_HOST_GETTER)
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7STYLESCOMMON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7STYLESCOMMON
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7STYLESCOMMON


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Button Configuration
***********************************************************************/
			
			struct Win7ButtonColors
			{
				Color										borderColor;
				Color										backgroundColor;
				Color										g1;
				Color										g2;
				Color										g3;
				Color										g4;
				Color										textColor;
				Color										bulletLight;
				Color										bulletDark;

				bool operator==(const Win7ButtonColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor &&
						g1 == colors.g1 &&
						g2 == colors.g2 &&
						g3 == colors.g3 &&
						g4 == colors.g4 &&
						textColor == colors.textColor &&
						bulletLight == colors.bulletLight &&
						bulletDark == colors.bulletDark;
				}

				bool operator!=(const Win7ButtonColors& colors)
				{
					return !(*this==colors);
				}

				void										SetAlphaWithoutText(unsigned char a);

				static Win7ButtonColors						Blend(const Win7ButtonColors& c1, const Win7ButtonColors& c2, vint ratio, vint total);

				static Win7ButtonColors						ButtonNormal();
				static Win7ButtonColors						ButtonActive();
				static Win7ButtonColors						ButtonPressed();
				static Win7ButtonColors						ButtonDisabled();
				
				static Win7ButtonColors						ItemNormal();
				static Win7ButtonColors						ItemActive();
				static Win7ButtonColors						ItemSelected();
				static Win7ButtonColors						ItemDisabled();
				
				static Win7ButtonColors						CheckedNormal(bool selected);
				static Win7ButtonColors						CheckedActive(bool selected);
				static Win7ButtonColors						CheckedPressed(bool selected);
				static Win7ButtonColors						CheckedDisabled(bool selected);

				static Win7ButtonColors						ToolstripButtonNormal();
				static Win7ButtonColors						ToolstripButtonActive();
				static Win7ButtonColors						ToolstripButtonPressed();
				static Win7ButtonColors						ToolstripButtonSelected();
				static Win7ButtonColors						ToolstripButtonDisabled();

				static Win7ButtonColors						MenuBarButtonNormal();
				static Win7ButtonColors						MenuBarButtonActive();
				static Win7ButtonColors						MenuBarButtonPressed();
				static Win7ButtonColors						MenuBarButtonDisabled();

				static Win7ButtonColors						MenuItemButtonNormal();
				static Win7ButtonColors						MenuItemButtonNormalActive();
				static Win7ButtonColors						MenuItemButtonSelected();
				static Win7ButtonColors						MenuItemButtonSelectedActive();
				static Win7ButtonColors						MenuItemButtonDisabled();
				static Win7ButtonColors						MenuItemButtonDisabledActive();

				static Win7ButtonColors						TabPageHeaderNormal();
				static Win7ButtonColors						TabPageHeaderActive();
				static Win7ButtonColors						TabPageHeaderSelected();
			};

			struct Win7ButtonElements
			{
				elements::GuiSolidBorderElement*			rectBorderElement;
				elements::GuiRoundBorderElement*			roundBorderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		topGradientElement;
				elements::GuiGradientBackgroundElement*		bottomGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			backgroundComposition;
				compositions::GuiTableComposition*			gradientComposition;

				static Win7ButtonElements					Create(bool verticalGradient, bool roundBorder, Alignment horizontal=Alignment::Center, Alignment vertical=Alignment::Center);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7CheckedButtonElements
			{
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		outerGradientElement;
				elements::GuiGradientBackgroundElement*		innerGradientElement;
				elements::GuiSolidLabelElement*				textElement;
				elements::GuiSolidLabelElement*				bulletCheckElement;
				elements::GuiSolidBackgroundElement*		bulletRadioElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7CheckedButtonElements			Create(elements::ElementShape shape, bool backgroundVisible);
				void										Apply(const Win7ButtonColors& colors);
			};

			struct Win7MenuItemButtonElements
			{
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::Gui3DSplitterElement*				splitterElement;
				compositions::GuiCellComposition*			splitterComposition;
				elements::GuiImageFrameElement*				imageElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiSharedSizeItemComposition*	textComposition;
				elements::GuiSolidLabelElement*				shortcutElement;
				compositions::GuiSharedSizeItemComposition*	shortcutComposition;
				elements::GuiPolygonElement*				subMenuArrowElement;
				compositions::GuiGraphicsComposition*		subMenuArrowComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win7MenuItemButtonElements			Create();
				void										Apply(const Win7ButtonColors& colors);
				void										SetActive(bool value);
				void										SetSubMenuExisting(bool value);
			};

			struct Win7TextBoxColors
			{
				Color										borderColor;
				Color										backgroundColor;

				bool operator==(const Win7TextBoxColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor;
				}

				bool operator!=(const Win7TextBoxColors& colors)
				{
					return !(*this==colors);
				}

				static Win7TextBoxColors					Blend(const Win7TextBoxColors& c1, const Win7TextBoxColors& c2, vint ratio, vint total);

				static Win7TextBoxColors					Normal();
				static Win7TextBoxColors					Active();
				static Win7TextBoxColors					Focused();
				static Win7TextBoxColors					Disabled();
			};

/***********************************************************************
Helper Functions
***********************************************************************/
			
			extern Color									Win7GetSystemWindowColor();
			extern Color									Win7GetSystemTabContentColor();
			extern Color									Win7GetSystemBorderColor();
			extern Color									Win7GetSystemBorderSinkColor();
			extern Color									Win7GetSystemBorderRaiseColor();
			extern Color									Win7GetSystemTextColor(bool enabled);
			extern void										Win7SetFont(elements::GuiSolidLabelElement* element, compositions::GuiBoundsComposition* composition, const FontProperties& fontProperties);
			extern void										Win7CreateSolidLabelElement(elements::GuiSolidLabelElement*& element, compositions::GuiBoundsComposition*& composition, Alignment horizontal, Alignment vertical);
			extern void										Win7CreateSolidLabelElement(elements::GuiSolidLabelElement*& element, compositions::GuiSharedSizeItemComposition*& composition, const WString& group, Alignment horizontal, Alignment vertical);
			extern elements::text::ColorEntry				Win7GetTextBoxTextColor();
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7BUTTONSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7BUTTONSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7BUTTONSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Button
***********************************************************************/
			
			class Win7ButtonStyleBase : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ButtonStyleBase>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7ButtonStyleBase)

				Win7ButtonElements							elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;
				bool										transparentWhenInactive;
				bool										transparentWhenDisabled;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)=0;
				virtual void								AfterApplyColors(const Win7ButtonColors& colors);
			public:
				Win7ButtonStyleBase(bool verticalGradient, bool roundBorder, const Win7ButtonColors& initialColor, Alignment horizontal, Alignment vertical);
				~Win7ButtonStyleBase();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;

				bool										GetTransparentWhenInactive();
				void										SetTransparentWhenInactive(bool value);
				bool										GetTransparentWhenDisabled();
				void										SetTransparentWhenDisabled(bool value);
				bool										GetAutoSizeForText();
				void										SetAutoSizeForText(bool value);
			};
			
			class Win7ButtonStyle : public Win7ButtonStyleBase, public Description<Win7ButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7ButtonStyle(bool verticalGradient=true);
				~Win7ButtonStyle();
			};
			
			class Win7CheckBoxStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7CheckBoxStyle>
			{
			public:
				enum BulletStyle
				{
					CheckBox,
					RadioButton,
				};
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7CheckBoxStyle)

				Win7CheckedButtonElements					elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7CheckBoxStyle(BulletStyle bulletStyle, bool backgroundVisible=false);
				~Win7CheckBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7SCROLLABLESTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7SCROLLABLESTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7SCROLLABLESTYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Scroll
***********************************************************************/
			
			class Win7ScrollArrowButtonStyle : public Win7ButtonStyleBase, public Description<Win7ButtonStyle>
			{
			protected:
				elements::GuiPolygonElement*				arrowElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
				void										AfterApplyColors(const Win7ButtonColors& colors)override;
			public:
				Win7ScrollArrowButtonStyle(common_styles::CommonScrollStyle::Direction direction, bool increaseButton);
				~Win7ScrollArrowButtonStyle();
			};
			
			class Win7ScrollStyle : public common_styles::CommonScrollStyle, public Description<Win7ScrollStyle>
			{
			public:
				static const vint							DefaultSize=18;
				static const vint							ArrowSize=10;
			protected:
				controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction)override;
				controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction)override;
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)override;
				compositions::GuiBoundsComposition*			InstallBackground(compositions::GuiBoundsComposition* boundsComposition, Direction direction)override;
			public:
				Win7ScrollStyle(Direction _direction);
				~Win7ScrollStyle();
			};
			
			class Win7TrackStyle : public common_styles::CommonTrackStyle, public Description<Win7TrackStyle>
			{
			public:
				static const vint							TrackThickness=4;
				static const vint							TrackPadding=8;
				static const vint							HandleLong=21;
				static const vint							HandleShort=10;

			protected:
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)override;
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
				void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)override;
			public:
				Win7TrackStyle(Direction _direction);
				~Win7TrackStyle();
			};

			class Win7ProgressBarStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<Win7ProgressBarStyle>
			{
			protected:
				vint										totalSize;
				vint										pageSize;
				vint										position;
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				compositions::GuiPartialViewComposition*	progressComposition;

				void										UpdateProgressBar();
				void										FillProgressColors(compositions::GuiGraphicsComposition* parent, Color g1, Color g2, Color g3, Color g4, Color g5);
			public:
				Win7ProgressBarStyle();
				~Win7ProgressBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void										SetTotalSize(vint value)override;
				void										SetPageSize(vint value)override;
				void										SetPosition(vint value)override;
			};

/***********************************************************************
ScrollView
***********************************************************************/
			
			class Win7ScrollViewProvider : public Object, public virtual controls::GuiScrollView::IStyleProvider, public Description<Win7ScrollViewProvider>
			{
			public:
				Win7ScrollViewProvider();
				~Win7ScrollViewProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				controls::GuiScroll::IStyleController*		CreateHorizontalScrollStyle()override;
				controls::GuiScroll::IStyleController*		CreateVerticalScrollStyle()override;
				vint										GetDefaultScrollSize()override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
TextBox
***********************************************************************/
			
			class Win7TextBoxBackground : public Object, public Description<Win7TextBoxBackground>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7TextBoxColors, Win7TextBoxBackground)
					
				elements::GuiRoundBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				compositions::GuiGraphicsComposition*		focusableComposition;
				bool										isMouseEnter;
				bool										isFocused;
				bool										isVisuallyEnabled;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiControl::IStyleController*		styleController;
				elements::GuiColorizedTextElement*			textElement;

				void										UpdateStyle();
				void										Apply(const Win7TextBoxColors& colors);

				void										OnBoundsMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				Win7TextBoxBackground();
				~Win7TextBoxBackground();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller);
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value);
				void										SetVisuallyEnabled(bool value);
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition);
				void										InitializeTextElement(elements::GuiColorizedTextElement* _textElement);
			};
			
			class Win7MultilineTextBoxProvider : public Win7ScrollViewProvider, public Description<Win7MultilineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7MultilineTextBoxProvider();
				~Win7MultilineTextBoxProvider();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};
			
			class Win7SinglelineTextBoxProvider : public Object, public virtual controls::GuiSinglelineTextBox::IStyleProvider, public Description<Win7SinglelineTextBoxProvider>
			{
			protected:
				Win7TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win7SinglelineTextBoxProvider();
				~Win7SinglelineTextBoxProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};
			
#pragma warning(push)
#pragma warning(disable:4250)
			class Win7DocumentViewerStyle : public Win7MultilineTextBoxProvider, public virtual controls::GuiDocumentViewer::IStyleProvider, public Description<Win7DocumentViewerStyle>
			{
			public:
				Win7DocumentViewerStyle();
				~Win7DocumentViewerStyle();

				Ptr<DocumentModel>							GetBaselineDocument()override;
			};

			class Win7DocumentlabelStyle : public controls::GuiControl::EmptyStyleController, public virtual controls::GuiDocumentLabel::IStyleController, public Description<Win7DocumentlabelStyle>
			{
			public:
				Win7DocumentlabelStyle();
				~Win7DocumentlabelStyle();

				Ptr<DocumentModel>							GetBaselineDocument()override;
			};
#pragma warning(pop)
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7CONTROLSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7CONTROLSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7CONTROLSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Container
***********************************************************************/

			class Win7EmptyStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7EmptyStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7EmptyStyle(Color color);
				~Win7EmptyStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7WindowStyle : public virtual controls::GuiWindow::DefaultBehaviorStyleController, public Description<Win7WindowStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7WindowStyle();
				~Win7WindowStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7TooltipStyle : public virtual controls::GuiWindow::DefaultBehaviorStyleController, public Description<Win7TooltipStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win7TooltipStyle();
				~Win7TooltipStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7LabelStyle : public Object, public virtual controls::GuiLabel::IStyleController, public Description<Win7LabelStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				elements::GuiSolidLabelElement*				textElement;
			public:
				Win7LabelStyle(bool forShortcutKey);
				~Win7LabelStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				Color										GetDefaultTextColor()override;
				void										SetTextColor(Color value)override;
			};
			
			class Win7GroupBoxStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7GroupBoxStyle>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Color, Win7GroupBoxStyle)

				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			sinkBorderComposition;
				compositions::GuiBoundsComposition*			raisedBorderComposition;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			textBackgroundComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				elements::GuiSolidLabelElement*				textElement;
				Ptr<TransferringAnimation>					transferringAnimation;

				void										SetMargins(vint fontSize);
			public:
				Win7GroupBoxStyle();
				~Win7GroupBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win7DatePickerStyle : public Object, public virtual controls::GuiDatePicker::IStyleProvider, public Description<Win7DatePickerStyle>
			{
			public:
				Win7DatePickerStyle();
				~Win7DatePickerStyle();

				void													AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void													SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void													SetText(const WString& value)override;
				void													SetFont(const FontProperties& value)override;
				void													SetVisuallyEnabled(bool value)override;

				controls::GuiSelectableButton::IStyleController*		CreateDateButtonStyle()override;
				controls::GuiTextList*									CreateTextList()override;
				controls::GuiComboBoxListControl::IStyleController*		CreateComboBoxStyle()override;

				Color													GetBackgroundColor()override;
				Color													GetPrimaryTextColor()override;
				Color													GetSecondaryTextColor()override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7MENUSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7MENUSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7MENUSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Menu Container
***********************************************************************/
			
			class Win7MenuStyle : public Object, public virtual controls::GuiWindow::DefaultBehaviorStyleController, public Description<Win7MenuStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win7MenuStyle();
				~Win7MenuStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
			
			class Win7MenuBarStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuBarStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuBarStyle();
				~Win7MenuBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

/***********************************************************************
Menu Button
***********************************************************************/
			
			class Win7MenuBarButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuBarButtonStyle>
			{
			protected:
				Win7ButtonElements							elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win7MenuBarButtonStyle();
				~Win7MenuBarButtonStyle();

				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;
				void														SetSelected(bool value)override;
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win7MenuItemButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7MenuItemButtonStyle>
			{
			protected:
				Win7MenuItemButtonElements									elements;
				controls::GuiButton::ControlState							controlStyle;
				bool														isVisuallyEnabled;
				bool														isSelected;
				bool														isOpening;

				void														TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected, bool opening);
			public:
				Win7MenuItemButtonStyle();
				~Win7MenuItemButtonStyle();

				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;
				void														SetSelected(bool value)override;
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win7MenuSplitterStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7MenuSplitterStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7MenuSplitterStyle();
				~Win7MenuSplitterStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8STYLESCOMMON.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8STYLESCOMMON
#define VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8STYLESCOMMON


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Button Configuration
***********************************************************************/
			
			struct Win8ButtonColors
			{
				Color										borderColor;
				Color										g1;
				Color										g2;
				Color										textColor;
				Color										bullet;

				bool operator==(const Win8ButtonColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						g1 == colors.g1 &&
						g2 == colors.g2 &&
						textColor == colors.textColor &&
						bullet == colors.bullet;
				}

				bool operator!=(const Win8ButtonColors& colors)
				{
					return !(*this==colors);
				}

				void										SetAlphaWithoutText(unsigned char a);

				static Win8ButtonColors						Blend(const Win8ButtonColors& c1, const Win8ButtonColors& c2, vint ratio, vint total);

				static Win8ButtonColors						ButtonNormal();
				static Win8ButtonColors						ButtonActive();
				static Win8ButtonColors						ButtonPressed();
				static Win8ButtonColors						ButtonDisabled();
				
				static Win8ButtonColors						ItemNormal();
				static Win8ButtonColors						ItemActive();
				static Win8ButtonColors						ItemSelected();
				static Win8ButtonColors						ItemDisabled();
				
				static Win8ButtonColors						CheckedNormal(bool selected);
				static Win8ButtonColors						CheckedActive(bool selected);
				static Win8ButtonColors						CheckedPressed(bool selected);
				static Win8ButtonColors						CheckedDisabled(bool selected);

				static Win8ButtonColors						ToolstripButtonNormal();
				static Win8ButtonColors						ToolstripButtonActive();
				static Win8ButtonColors						ToolstripButtonPressed();
				static Win8ButtonColors						ToolstripButtonSelected();
				static Win8ButtonColors						ToolstripButtonDisabled();

				static Win8ButtonColors						ScrollHandleNormal();
				static Win8ButtonColors						ScrollHandleActive();
				static Win8ButtonColors						ScrollHandlePressed();
				static Win8ButtonColors						ScrollHandleDisabled();
				static Win8ButtonColors						ScrollArrowNormal();
				static Win8ButtonColors						ScrollArrowActive();
				static Win8ButtonColors						ScrollArrowPressed();
				static Win8ButtonColors						ScrollArrowDisabled();

				static Win8ButtonColors						MenuBarButtonNormal();
				static Win8ButtonColors						MenuBarButtonActive();
				static Win8ButtonColors						MenuBarButtonPressed();
				static Win8ButtonColors						MenuBarButtonDisabled();

				static Win8ButtonColors						MenuItemButtonNormal();
				static Win8ButtonColors						MenuItemButtonNormalActive();
				static Win8ButtonColors						MenuItemButtonSelected();
				static Win8ButtonColors						MenuItemButtonSelectedActive();
				static Win8ButtonColors						MenuItemButtonDisabled();
				static Win8ButtonColors						MenuItemButtonDisabledActive();

				static Win8ButtonColors						TabPageHeaderNormal();
				static Win8ButtonColors						TabPageHeaderActive();
				static Win8ButtonColors						TabPageHeaderSelected();
			};

			struct Win8ButtonElements
			{
				elements::GuiSolidBorderElement*			rectBorderElement;
				elements::GuiGradientBackgroundElement*		backgroundElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			backgroundComposition;

				static Win8ButtonElements					Create(Alignment horizontal=Alignment::Center, Alignment vertical=Alignment::Center);
				void										Apply(const Win8ButtonColors& colors);
			};

			struct Win8CheckedButtonElements
			{
				elements::GuiSolidBorderElement*			bulletBorderElement;
				elements::GuiGradientBackgroundElement*		bulletBackgroundElement;
				elements::GuiSolidLabelElement*				bulletCheckElement;
				elements::GuiSolidBackgroundElement*		bulletRadioElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win8CheckedButtonElements			Create(elements::ElementShape shape, bool backgroundVisible);
				void										Apply(const Win8ButtonColors& colors);
			};

			struct Win8MenuItemButtonElements
			{
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		backgroundElement;
				elements::GuiSolidBorderElement*			splitterElement;
				compositions::GuiCellComposition*			splitterComposition;
				elements::GuiImageFrameElement*				imageElement;
				elements::GuiSolidLabelElement*				textElement;
				compositions::GuiSharedSizeItemComposition*	textComposition;
				elements::GuiSolidLabelElement*				shortcutElement;
				compositions::GuiSharedSizeItemComposition*	shortcutComposition;
				elements::GuiPolygonElement*				subMenuArrowElement;
				compositions::GuiGraphicsComposition*		subMenuArrowComposition;
				compositions::GuiBoundsComposition*			mainComposition;

				static Win8MenuItemButtonElements			Create();
				void										Apply(const Win8ButtonColors& colors);
				void										SetActive(bool value);
				void										SetSubMenuExisting(bool value);
			};

			struct Win8TextBoxColors
			{
				Color										borderColor;
				Color										backgroundColor;

				bool operator==(const Win8TextBoxColors& colors)
				{
					return
						borderColor == colors.borderColor &&
						backgroundColor == colors.backgroundColor;
				}

				bool operator!=(const Win8TextBoxColors& colors)
				{
					return !(*this==colors);
				}

				static Win8TextBoxColors					Blend(const Win8TextBoxColors& c1, const Win8TextBoxColors& c2, vint ratio, vint total);

				static Win8TextBoxColors					Normal();
				static Win8TextBoxColors					Active();
				static Win8TextBoxColors					Focused();
				static Win8TextBoxColors					Disabled();
			};

/***********************************************************************
Helper Functions
***********************************************************************/
			
			extern Color									Win8GetSystemWindowColor();
			extern Color									Win8GetSystemTabContentColor();
			extern Color									Win8GetSystemBorderColor();
			extern Color									Win8GetSystemTextColor(bool enabled);
			extern Color									Win8GetMenuBorderColor();
			extern Color									Win8GetMenuSplitterColor();
			extern void										Win8SetFont(elements::GuiSolidLabelElement* element, compositions::GuiBoundsComposition* composition, const FontProperties& fontProperties);
			extern void										Win8CreateSolidLabelElement(elements::GuiSolidLabelElement*& element, compositions::GuiBoundsComposition*& composition, Alignment horizontal, Alignment vertical);
			extern void										Win8CreateSolidLabelElement(elements::GuiSolidLabelElement*& element, compositions::GuiSharedSizeItemComposition*& composition, const WString& group, Alignment horizontal, Alignment vertical);
			extern elements::text::ColorEntry				Win8GetTextBoxTextColor();
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8BUTTONSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN8BUTTONSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN8BUTTONSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Button
***********************************************************************/
			
			class Win8ButtonStyleBase : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win8ButtonStyleBase>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win8ButtonColors, Win8ButtonStyleBase)

				Win8ButtonElements							elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;
				bool										transparentWhenInactive;
				bool										transparentWhenDisabled;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)=0;
				virtual void								AfterApplyColors(const Win8ButtonColors& colors);
			public:
				Win8ButtonStyleBase(const Win8ButtonColors& initialColor, Alignment horizontal, Alignment vertical);
				~Win8ButtonStyleBase();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;

				bool										GetTransparentWhenInactive();
				void										SetTransparentWhenInactive(bool value);
				bool										GetTransparentWhenDisabled();
				void										SetTransparentWhenDisabled(bool value);
				bool										GetAutoSizeForText();
				void										SetAutoSizeForText(bool value);
			};
			
			class Win8ButtonStyle : public Win8ButtonStyleBase, public Description<Win8ButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win8ButtonStyle();
				~Win8ButtonStyle();
			};
			
			class Win8CheckBoxStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win8CheckBoxStyle>
			{
			public:
				enum BulletStyle
				{
					CheckBox,
					RadioButton,
				};
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win8ButtonColors, Win8CheckBoxStyle)

				Win8CheckedButtonElements					elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win8CheckBoxStyle(BulletStyle bulletStyle, bool backgroundVisible=false);
				~Win8CheckBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8SCROLLABLESTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWin8SCROLLABLESTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWin8SCROLLABLESTYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Scroll
***********************************************************************/
			
			class Win8ScrollHandleButtonStyle : public Win8ButtonStyleBase, public Description<Win8ScrollHandleButtonStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win8ScrollHandleButtonStyle();
				~Win8ScrollHandleButtonStyle();
			};
			
			class Win8ScrollArrowButtonStyle : public Win8ButtonStyleBase, public Description<Win8ScrollArrowButtonStyle>
			{
			protected:
				elements::GuiPolygonElement*				arrowElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
				void										AfterApplyColors(const Win8ButtonColors& colors)override;
			public:
				Win8ScrollArrowButtonStyle(common_styles::CommonScrollStyle::Direction direction, bool increaseButton);
				~Win8ScrollArrowButtonStyle();
			};
			
			class Win8ScrollStyle : public common_styles::CommonScrollStyle, public Description<Win8ScrollStyle>
			{
			public:
				static const vint							DefaultSize=16;
				static const vint							ArrowSize=8;
			protected:
				controls::GuiButton::IStyleController*		CreateDecreaseButtonStyle(Direction direction)override;
				controls::GuiButton::IStyleController*		CreateIncreaseButtonStyle(Direction direction)override;
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)override;
				compositions::GuiBoundsComposition*			InstallBackground(compositions::GuiBoundsComposition* boundsComposition, Direction direction)override;
			public:
				Win8ScrollStyle(Direction _direction);
				~Win8ScrollStyle();
			};
			
			class Win8TrackStyle : public common_styles::CommonTrackStyle, public Description<Win8TrackStyle>
			{
			public:
				static const vint							TrackThickness=4;
				static const vint							TrackPadding=6;
				static const vint							HandleLong=16;
				static const vint							HandleShort=10;

			protected:
				controls::GuiButton::IStyleController*		CreateHandleButtonStyle(Direction direction)override;
				void										InstallBackground(compositions::GuiGraphicsComposition* boundsComposition, Direction direction)override;
				void										InstallTrack(compositions::GuiGraphicsComposition* trackComposition, Direction direction)override;
			public:
				Win8TrackStyle(Direction _direction);
				~Win8TrackStyle();
			};

			class Win8ProgressBarStyle : public Object, public virtual controls::GuiScroll::IStyleController, public Description<Win8ProgressBarStyle>
			{
			protected:
				vint											totalSize;
				vint											pageSize;
				vint											position;
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				compositions::GuiPartialViewComposition*	progressComposition;

				void										UpdateProgressBar();
			public:
				Win8ProgressBarStyle();
				~Win8ProgressBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetCommandExecutor(controls::GuiScroll::ICommandExecutor* value)override;
				void										SetTotalSize(vint value)override;
				void										SetPageSize(vint value)override;
				void										SetPosition(vint value)override;
			};

/***********************************************************************
ScrollView
***********************************************************************/
			
			class Win8ScrollViewProvider : public Object, public virtual controls::GuiScrollView::IStyleProvider, public Description<Win8ScrollViewProvider>
			{
			public:
				Win8ScrollViewProvider();
				~Win8ScrollViewProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;

				controls::GuiScroll::IStyleController*		CreateHorizontalScrollStyle()override;
				controls::GuiScroll::IStyleController*		CreateVerticalScrollStyle()override;
				vint										GetDefaultScrollSize()override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};

/***********************************************************************
TextBox
***********************************************************************/
			
			class Win8TextBoxBackground : public Object, public Description<Win8TextBoxBackground>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win8TextBoxColors, Win8TextBoxBackground)
					
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiSolidBackgroundElement*		backgroundElement;
				compositions::GuiGraphicsComposition*		focusableComposition;
				bool										isMouseEnter;
				bool										isFocused;
				bool										isVisuallyEnabled;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiControl::IStyleController*		styleController;
				elements::GuiColorizedTextElement*			textElement;

				void										UpdateStyle();
				void										Apply(const Win8TextBoxColors& colors);

				void										OnBoundsMouseEnter(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsMouseLeave(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsGotFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void										OnBoundsLostFocus(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
			public:
				Win8TextBoxBackground();
				~Win8TextBoxBackground();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller);
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value);
				void										SetVisuallyEnabled(bool value);
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition);
				void										InitializeTextElement(elements::GuiColorizedTextElement* _textElement);
			};
			
			class Win8MultilineTextBoxProvider : public Win8ScrollViewProvider, public Description<Win8MultilineTextBoxProvider>
			{
			protected:
				Win8TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win8MultilineTextBoxProvider();
				~Win8MultilineTextBoxProvider();
				
				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};
			
			class Win8SinglelineTextBoxProvider : public Object, public virtual controls::GuiSinglelineTextBox::IStyleProvider, public Description<Win8SinglelineTextBoxProvider>
			{
			protected:
				Win8TextBoxBackground						background;
				controls::GuiControl::IStyleController*		styleController;
			public:
				Win8SinglelineTextBoxProvider();
				~Win8SinglelineTextBoxProvider();

				void										AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				compositions::GuiGraphicsComposition*		InstallBackground(compositions::GuiBoundsComposition* boundsComposition)override;
			};
			
#pragma warning(push)
#pragma warning(disable:4250)
			class Win8DocumentViewerStyle : public Win8MultilineTextBoxProvider, public virtual controls::GuiDocumentViewer::IStyleProvider, public Description<Win8DocumentViewerStyle>
			{
			public:
				Win8DocumentViewerStyle();
				~Win8DocumentViewerStyle();

				Ptr<DocumentModel>							GetBaselineDocument()override;
			};

			class Win8DocumentlabelStyle : public controls::GuiControl::EmptyStyleController, public virtual controls::GuiDocumentLabel::IStyleController, public Description<Win8DocumentlabelStyle>
			{
			public:
				Win8DocumentlabelStyle();
				~Win8DocumentlabelStyle();

				Ptr<DocumentModel>							GetBaselineDocument()override;
			};
#pragma warning(pop)
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8CONTROLSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWin8CONTROLSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWin8CONTROLSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Container
***********************************************************************/

			class Win8EmptyStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win8EmptyStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win8EmptyStyle(Color color);
				~Win8EmptyStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win8WindowStyle : public virtual controls::GuiWindow::DefaultBehaviorStyleController, public Description<Win8WindowStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win8WindowStyle();
				~Win8WindowStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win8TooltipStyle : public virtual controls::GuiWindow::DefaultBehaviorStyleController, public Description<Win8TooltipStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win8TooltipStyle();
				~Win8TooltipStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win8LabelStyle : public Object, public virtual controls::GuiLabel::IStyleController, public Description<Win8LabelStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				elements::GuiSolidLabelElement*				textElement;
			public:
				Win8LabelStyle(bool forShortcutKey);
				~Win8LabelStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				Color										GetDefaultTextColor()override;
				void										SetTextColor(Color value)override;
			};
			
			class Win8GroupBoxStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win8GroupBoxStyle>
			{
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Color, Win8GroupBoxStyle)

				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			textBackgroundComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				elements::GuiSolidLabelElement*				textElement;
				Ptr<TransferringAnimation>					transferringAnimation;

				void										SetMargins(vint fontSize);
			public:
				Win8GroupBoxStyle();
				~Win8GroupBoxStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win8DatePickerStyle : public Object, public virtual controls::GuiDatePicker::IStyleProvider, public Description<Win8DatePickerStyle>
			{
			public:
				Win8DatePickerStyle();
				~Win8DatePickerStyle();

				void													AssociateStyleController(controls::GuiControl::IStyleController* controller)override;
				void													SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void													SetText(const WString& value)override;
				void													SetFont(const FontProperties& value)override;
				void													SetVisuallyEnabled(bool value)override;

				controls::GuiSelectableButton::IStyleController*		CreateDateButtonStyle()override;
				controls::GuiTextList*									CreateTextList()override;
				controls::GuiComboBoxListControl::IStyleController*		CreateComboBoxStyle()override;

				Color													GetBackgroundColor()override;
				Color													GetPrimaryTextColor()override;
				Color													GetSecondaryTextColor()override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8MENUSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8MENUSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8MENUSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Menu Container
***********************************************************************/
			
			class Win8MenuStyle : public Object, public virtual controls::GuiWindow::DefaultBehaviorStyleController, public Description<Win8MenuStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win8MenuStyle();
				~Win8MenuStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
			
			class Win8MenuBarStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win8MenuBarStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win8MenuBarStyle();
				~Win8MenuBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

/***********************************************************************
Menu Button
***********************************************************************/
			
			class Win8MenuBarButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win8MenuBarButtonStyle>
			{
			protected:
				Win8ButtonElements							elements;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isOpening;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool opening);
			public:
				Win8MenuBarButtonStyle();
				~Win8MenuBarButtonStyle();

				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;
				void														SetSelected(bool value)override;
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win8MenuItemButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win8MenuItemButtonStyle>
			{
			protected:
				Win8MenuItemButtonElements									elements;
				controls::GuiButton::ControlState							controlStyle;
				bool														isVisuallyEnabled;
				bool														isSelected;
				bool														isOpening;

				void														TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected, bool opening);
			public:
				Win8MenuItemButtonStyle();
				~Win8MenuItemButtonStyle();

				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;
				void														SetSelected(bool value)override;
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win8MenuSplitterStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win8MenuSplitterStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win8MenuSplitterStyle();
				~Win8MenuSplitterStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7TABSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7TABSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7TABSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Tab
***********************************************************************/
			
			class Win7TabPageHeaderStyle : public Win7ButtonStyleBase, public Description<Win7TabPageHeaderStyle>
			{
			protected:
				void														TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7TabPageHeaderStyle();
				~Win7TabPageHeaderStyle();

				void														SetFont(const FontProperties& value)override;
			};
			
			class Win7TabStyle : public Object, public virtual controls::GuiTab::IStyleController, public Description<Win7TabStyle>
			{
			protected:
				compositions::GuiTableComposition*							boundsComposition;
				compositions::GuiBoundsComposition*							containerComposition;
				compositions::GuiStackComposition*							tabHeaderComposition;
				compositions::GuiBoundsComposition*							tabContentTopLineComposition;
				FontProperties												headerFont;
				controls::GuiTab::ICommandExecutor*							commandExecutor;

				Ptr<controls::GuiSelectableButton::MutexGroupController>	headerController;
				collections::List<controls::GuiSelectableButton*>			headerButtons;
				elements::GuiPolygonElement*								headerOverflowArrowElement;
				controls::GuiButton*										headerOverflowButton;
				controls::GuiToolstripMenu*									headerOverflowMenu;

				void														OnHeaderButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void														OnTabHeaderBoundsChanged(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void														OnHeaderOverflowButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);
				void														OnHeaderOverflowMenuButtonClicked(compositions::GuiGraphicsComposition* sender, compositions::GuiEventArgs& arguments);

				void														UpdateHeaderOverflowButtonVisibility();
				void														UpdateHeaderZOrder();
				void														UpdateHeaderVisibilityIndex();
				void														UpdateHeaderLayout();

				void														Initialize();
			protected:
				
				virtual controls::GuiSelectableButton::IStyleController*	CreateHeaderStyleController();
				virtual controls::GuiButton::IStyleController*				CreateMenuButtonStyleController();
				virtual controls::GuiToolstripMenu::IStyleController*		CreateMenuStyleController();
				virtual controls::GuiToolstripButton::IStyleController*		CreateMenuItemStyleController();
				virtual Color												GetBorderColor();
				virtual Color												GetBackgroundColor();
			public:
				Win7TabStyle(bool initialize=true);
				~Win7TabStyle();

				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;

				void														SetCommandExecutor(controls::GuiTab::ICommandExecutor* value)override;
				void														InsertTab(vint index)override;
				void														SetTabText(vint index, const WString& value)override;
				void														RemoveTab(vint index)override;
				void														MoveTab(vint oldIndex, vint newIndex)override;
				void														SetSelectedTab(vint index)override;
				void														SetTabAlt(vint index, const WString& value, compositions::IGuiAltActionHost* host)override;
				compositions::IGuiAltAction*								GetTabAltAction(vint index)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGEOPERATIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGEOPERATIONS
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGEOPERATIONS


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
ParsingInput
***********************************************************************/

			class RepeatingParsingExecutor;

			struct RepeatingParsingInput
			{
				vuint													editVersion = 0;
				WString													code;
			};

/***********************************************************************
ParsingOutput
***********************************************************************/

			struct RepeatingParsingOutput
			{
				Ptr<parsing::ParsingTreeObject>							node;
				vuint													editVersion = 0;
				WString													code;
				Ptr<DescriptableObject>									cache;
			};

/***********************************************************************
PartialParsingOutput
***********************************************************************/
			
			struct RepeatingPartialParsingOutput
			{
				RepeatingParsingOutput									input;
				WString													rule;
				parsing::ParsingTextRange								originalRange;
				Ptr<parsing::ParsingTreeObject>							originalNode;
				Ptr<parsing::ParsingTreeObject>							modifiedNode;
				WString													modifiedCode;
			};

/***********************************************************************
PartialParsingOutput
***********************************************************************/

			struct ParsingCandidateItem
			{
				vint													semanticId = -1;
				WString													name;
				description::Value										tag;
			};

/***********************************************************************
ParsingContext
***********************************************************************/

			struct ParsingTokenContext
			{
				parsing::ParsingTreeToken*								foundToken = nullptr;
				parsing::ParsingTreeObject*								tokenParent = nullptr;
				WString													type;
				WString													field;
				Ptr<collections::List<vint>>							acceptableSemanticIds;

				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTreeNode* foundNode, RepeatingParsingExecutor* executor);
				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTextPos pos, parsing::ParsingTreeObject* rootNode, RepeatingParsingExecutor* executor);
				static bool												RetriveContext(ParsingTokenContext& output, parsing::ParsingTextRange range, parsing::ParsingTreeObject* rootNode, RepeatingParsingExecutor* executor);
			};

/***********************************************************************
RepeatingParsingExecutor
***********************************************************************/

			class RepeatingParsingExecutor : public RepeatingTaskExecutor<RepeatingParsingInput>, public Description<RepeatingParsingExecutor>
			{
			public:
				class ICallback : public virtual Interface
				{
				public:
					virtual void											OnParsingFinishedAsync(const RepeatingParsingOutput& output)=0;
					virtual void											RequireAutoSubmitTask(bool enabled)=0;
				};

				class IParsingAnalyzer : public virtual Interface
				{
				private:
					parsing::ParsingTreeNode*								ToParent(parsing::ParsingTreeNode* node, const RepeatingPartialParsingOutput* output);
					parsing::ParsingTreeObject*								ToChild(parsing::ParsingTreeObject* node, const RepeatingPartialParsingOutput* output);
					Ptr<parsing::ParsingTreeNode>							ToChild(Ptr<parsing::ParsingTreeNode> node, const RepeatingPartialParsingOutput* output);

				protected:
					parsing::ParsingTreeNode*								GetParent(parsing::ParsingTreeNode* node, const RepeatingPartialParsingOutput* output);
					Ptr<parsing::ParsingTreeNode>							GetMember(parsing::ParsingTreeObject* node, const WString& name, const RepeatingPartialParsingOutput* output);
					Ptr<parsing::ParsingTreeNode>							GetItem(parsing::ParsingTreeArray* node, vint index, const RepeatingPartialParsingOutput* output);

				public:
					virtual void											Attach(RepeatingParsingExecutor* executor) = 0;

					virtual void											Detach(RepeatingParsingExecutor* executor) = 0;

					virtual Ptr<DescriptableObject>							CreateCacheAsync(const RepeatingParsingOutput& output) = 0;

					virtual vint											GetSemanticIdForTokenAsync(const ParsingTokenContext& tokenContext, const RepeatingParsingOutput& output) = 0;

					virtual void											GetCandidateItemsAsync(const ParsingTokenContext& tokenContext, const RepeatingPartialParsingOutput& partialOutput, collections::List<ParsingCandidateItem>& candidateItems) = 0;					

					virtual description::Value								CreateTagForCandidateItem(ParsingCandidateItem& item) = 0;
				};

				class CallbackBase : public virtual ICallback, public virtual ICommonTextEditCallback
				{
				private:
					bool													callbackAutoPushing;
					elements::GuiColorizedTextElement*						callbackElement;
					SpinLock*												callbackElementModifyLock;

				protected:
					Ptr<RepeatingParsingExecutor>							parsingExecutor;

				public:
					CallbackBase(Ptr<RepeatingParsingExecutor> _parsingExecutor);
					~CallbackBase();

					void													RequireAutoSubmitTask(bool enabled)override;
					void													Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
					void													Detach()override;
					void													TextEditPreview(TextEditPreviewStruct& arguments)override;
					void													TextEditNotify(const TextEditNotifyStruct& arguments)override;
					void													TextCaretChanged(const TextCaretChangedStruct& arguments)override;
					void													TextEditFinished(vuint editVersion)override;
				};

				struct TokenMetaData
				{
					vint													tableTokenIndex;
					vint													lexerTokenIndex;
					vint													defaultColorIndex;
					bool													hasContextColor;
					bool													hasAutoComplete;
					bool													isCandidate;
					WString													unescapedRegexText;
				};

				struct FieldMetaData
				{
					vint													colorIndex;
					Ptr<collections::List<vint>>							semantics;
				};
			private:
				Ptr<parsing::tabling::ParsingGeneralParser>					grammarParser;
				WString														grammarRule;
				Ptr<IParsingAnalyzer>										analyzer;
				collections::List<ICallback*>								callbacks;
				collections::List<ICallback*>								activatedCallbacks;
				ICallback*													autoPushingCallback;

				typedef collections::Pair<WString, WString>					FieldDesc;
				collections::Dictionary<WString, vint>						tokenIndexMap;
				collections::SortedList<WString>							semanticIndexMap;
				collections::Dictionary<vint, TokenMetaData>				tokenMetaDatas;
				collections::Dictionary<FieldDesc, FieldMetaData>			fieldMetaDatas;

			protected:

				void														Execute(const RepeatingParsingInput& input)override;
				void														PrepareMetaData();

				virtual void												OnContextFinishedAsync(RepeatingParsingOutput& context);
			public:
				RepeatingParsingExecutor(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule, Ptr<IParsingAnalyzer> _analyzer = 0);
				~RepeatingParsingExecutor();
				
				Ptr<parsing::tabling::ParsingGeneralParser>					GetParser();
				bool														AttachCallback(ICallback* value);
				bool														DetachCallback(ICallback* value);
				bool														ActivateCallback(ICallback* value);
				bool														DeactivateCallback(ICallback* value);
				Ptr<IParsingAnalyzer>										GetAnalyzer();

				vint														GetTokenIndex(const WString& tokenName);
				vint														GetSemanticId(const WString& name);
				WString														GetSemanticName(vint id);
				const TokenMetaData&										GetTokenMetaData(vint regexTokenIndex);
				const FieldMetaData&										GetFieldMetaData(const WString& type, const WString& field);

				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetAttribute(vint index, const WString& name, vint argumentCount);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetColorAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetContextColorAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetSemanticAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetCandidateAttribute(vint index);
				Ptr<parsing::tabling::ParsingTable::AttributeInfo>			GetAutoCompleteAttribute(vint index);

				/*
				@Color(ColorName)
					field:	color of the token field when the token type is marked with @ContextColor
					token:	color of the token
				@ContextColor()
					token:	the color of the token may be changed if the token field is marked with @Color or @Semantic
				@Semantic(Type1, Type2, ...)
					field:	After resolved symbols for this field, only types of symbols that specified in the arguments are acceptable.
				@Candidate()
					token:	when the token can be available after the editing caret, than it will be in the auto complete list.
				@AutoComplete()
					token:	when the token is editing, an auto complete list will appear if possible
				*/
			};
		}
	}
}

#endif

/***********************************************************************
GACUI.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI Header Files and Common Namespaces

Global Objects:
	vl::reflection::description::					GetGlobalTypeManager
	vl::presentation::								GetParserManager
	vl::presentation::								GetResourceResolverManager
	vl::presentation::								GetCurrentController
	vl::presentation::								GetInstanceLoaderManager
	vl::presentation::elements::					GetGuiGraphicsResourceManager
	vl::presentation::controls::					GetApplication
	vl::presentation::controls::					GetPluginManager
	vl::presentation::theme::						GetCurrentTheme

	vl::presentation::windows::						GetDirect2DFactory
	vl::presentation::windows::						GetDirectWriteFactory
	vl::presentation::elements_windows_gdi::		GetWindowsGDIResourceManager
	vl::presentation::elements_windows_gdi::		GetWindowsGDIObjectProvider
	vl::presentation::elements_windows_d2d::		GetWindowsDirect2DResourceManager
	vl::presentation::elements_windows_d2d::		GetWindowsDirect2DObjectProvider
***********************************************************************/

#ifndef VCZH_PRESENTATION_GACUI
#define VCZH_PRESENTATION_GACUI


#if !defined(__APPLE__) && !defined(__APPLE_CC__) && !defined(GAC_HEADER_USE_NAMESPACE)
 
using namespace vl;
using namespace vl::presentation;
using namespace vl::presentation::elements;
using namespace vl::presentation::compositions;
using namespace vl::presentation::controls;
using namespace vl::presentation::theme;
using namespace vl::presentation::templates;

#endif

extern int SetupWindowsGDIRenderer();
extern int SetupWindowsDirect2DRenderer();
extern int SetupOSXCoreGraphicsRenderer();

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGECOLORIZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGECOLORIZER
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGECOLORIZER


namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiGrammarColorizer
***********************************************************************/

			class GuiGrammarColorizer : public GuiTextBoxRegexColorizer, private RepeatingParsingExecutor::CallbackBase
			{
				typedef collections::Pair<WString, WString>					FieldDesc;
				typedef collections::Dictionary<FieldDesc, vint>			FieldContextColors;
				typedef collections::Dictionary<FieldDesc, vint>			FieldSemanticColors;
				typedef elements::text::ColorEntry							ColorEntry;
			public:
				struct SemanticColorizeContext : ParsingTokenContext
				{
					vint													semanticId;
				};
			private:
				collections::Dictionary<WString, ColorEntry>				colorSettings;
				collections::Dictionary<vint, vint>							semanticColorMap;

				SpinLock													contextLock;
				RepeatingParsingOutput										context;

				void														OnParsingFinishedAsync(const RepeatingParsingOutput& output)override;
			protected:
				virtual void												OnContextFinishedAsync(const RepeatingParsingOutput& context);

				void														Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void														Detach()override;
				void														TextEditPreview(TextEditPreviewStruct& arguments)override;
				void														TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void														TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void														TextEditFinished(vuint editVersion)override;

				virtual void												OnSemanticColorize(SemanticColorizeContext& context, const RepeatingParsingOutput& input);

				void														EnsureColorizerFinished();
			public:
				GuiGrammarColorizer(Ptr<RepeatingParsingExecutor> _parsingExecutor);
				GuiGrammarColorizer(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule);
				~GuiGrammarColorizer();

				void														BeginSetColors();
				const collections::SortedList<WString>&						GetColorNames();
				ColorEntry													GetColor(const WString& name);
				void														SetColor(const WString& name, const ColorEntry& entry);
				void														SetColor(const WString& name, const Color& color);
				void														EndSetColors();
				void														ColorizeTokenContextSensitive(vint lineIndex, const wchar_t* text, vint start, vint length, vint& token, vint& contextState)override;

				Ptr<RepeatingParsingExecutor>								GetParsingExecutor();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\TEXTEDITORPACKAGE\LANGUAGESERVICE\GUILANGUAGEAUTOCOMPLETE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control System

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_GUILANGUAGEAUTOCOMPLETE
#define VCZH_PRESENTATION_CONTROLS_GUILANGUAGEAUTOCOMPLETE

namespace vl
{
	namespace presentation
	{
		namespace controls
		{

/***********************************************************************
GuiGrammarAutoComplete
***********************************************************************/
			
			class GuiGrammarAutoComplete
				: public GuiTextBoxAutoCompleteBase
				, private RepeatingParsingExecutor::CallbackBase
				, private RepeatingTaskExecutor<RepeatingParsingOutput>
			{
			public:

				struct AutoCompleteData : ParsingTokenContext
				{
					collections::List<vint>							candidates;
					collections::List<vint>							shownCandidates;
					collections::List<ParsingCandidateItem>			candidateItems;
					TextPos											startPosition;
				};

				struct AutoCompleteContext : RepeatingPartialParsingOutput
				{
					vuint											modifiedEditVersion = 0;
					Ptr<AutoCompleteData>							autoComplete;
				};
			private:
				Ptr<parsing::tabling::ParsingGeneralParser>			grammarParser;
				collections::SortedList<WString>					leftRecursiveRules;
				bool												editing;

				SpinLock											editTraceLock;
				collections::List<TextEditNotifyStruct>				editTrace;

				SpinLock											contextLock;
				AutoCompleteContext									context;
				
				void												Attach(elements::GuiColorizedTextElement* _element, SpinLock& _elementModifyLock, compositions::GuiGraphicsComposition* _ownerComposition, vuint editVersion)override;
				void												Detach()override;
				void												TextEditPreview(TextEditPreviewStruct& arguments)override;
				void												TextEditNotify(const TextEditNotifyStruct& arguments)override;
				void												TextCaretChanged(const TextCaretChangedStruct& arguments)override;
				void												TextEditFinished(vuint editVersion)override;
				void												OnParsingFinishedAsync(const RepeatingParsingOutput& output)override;
				void												CollectLeftRecursiveRules();

				vint												UnsafeGetEditTraceIndex(vuint editVersion);
				TextPos												ChooseCorrectTextPos(TextPos pos, const regex::RegexTokens& tokens);
				void												ExecuteRefresh(AutoCompleteContext& newContext);

				bool												NormalizeTextPos(AutoCompleteContext& newContext, elements::text::TextLines& lines, TextPos& pos);
				void												ExecuteEdit(AutoCompleteContext& newContext);

				void												DeleteFutures(collections::List<parsing::tabling::ParsingState::Future*>& futures);
				regex::RegexToken*									TraverseTransitions(
																		parsing::tabling::ParsingState& state,
																		parsing::tabling::ParsingTransitionCollector& transitionCollector,
																		TextPos stopPosition,
																		collections::List<parsing::tabling::ParsingState::Future*>& nonRecoveryFutures,
																		collections::List<parsing::tabling::ParsingState::Future*>& recoveryFutures
																		);
				regex::RegexToken*									SearchValidInputToken(
																		parsing::tabling::ParsingState& state,
																		parsing::tabling::ParsingTransitionCollector& transitionCollector,
																		TextPos stopPosition,
																		AutoCompleteContext& newContext,
																		collections::SortedList<vint>& tableTokenIndices
																		);

				TextPos												GlobalTextPosToModifiedTextPos(AutoCompleteContext& newContext, TextPos pos);
				TextPos												ModifiedTextPosToGlobalTextPos(AutoCompleteContext& newContext, TextPos pos);
				void												ExecuteCalculateList(AutoCompleteContext& newContext);

				void												Execute(const RepeatingParsingOutput& input)override;
				void												PostList(const AutoCompleteContext& newContext, bool byGlobalCorrection);
				void												Initialize();
			protected:

				virtual void										OnContextFinishedAsync(AutoCompleteContext& context);

				void												EnsureAutoCompleteFinished();
			public:
				GuiGrammarAutoComplete(Ptr<RepeatingParsingExecutor> _parsingExecutor);
				GuiGrammarAutoComplete(Ptr<parsing::tabling::ParsingGeneralParser> _grammarParser, const WString& _grammarRule);
				~GuiGrammarAutoComplete();

				Ptr<RepeatingParsingExecutor>						GetParsingExecutor();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7TOOLSTRIPSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7TOOLSTRIPSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7TOOLSTRIPSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
Toolstrip Button
***********************************************************************/

			class Win7ToolstripToolBarStyle : public Win7EmptyStyle, public Description<Win7ToolstripToolBarStyle>
			{
			public:
				Win7ToolstripToolBarStyle();
				~Win7ToolstripToolBarStyle();
			};

			class Win7ToolstripButtonDropdownStyle : public Object, public virtual controls::GuiButton::IStyleController, public Description<Win7ToolstripButtonDropdownStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			splitterComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				bool										isVisuallyEnabled;
				controls::GuiButton::ControlState			controlState;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled);
			public:
				Win7ToolstripButtonDropdownStyle();
				~Win7ToolstripButtonDropdownStyle();
				
				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7ToolstripButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win7ToolstripButtonStyle>
			{
			public:
				enum ButtonStyle
				{
					CommandButton,
					DropdownButton,
					SplitButton,
				};
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win7ButtonColors, Win7ToolstripButtonStyle)

				Win7ButtonElements							elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;
				bool										isOpening;
				elements::GuiImageFrameElement*				imageElement;
				compositions::GuiBoundsComposition*			imageComposition;
				ButtonStyle									buttonStyle;
				controls::GuiButton*						subMenuHost;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected, bool menuOpening);
			public:
				Win7ToolstripButtonStyle(ButtonStyle _buttonStyle);
				~Win7ToolstripButtonStyle();
				
				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;
				void														SetSelected(bool value)override;
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win7ToolstripSplitterStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win7ToolstripSplitterStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win7ToolstripSplitterStyle();
				~Win7ToolstripSplitterStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN7STYLES\GUIWIN7LISTSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows7 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7LISTSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN7STYLES_GUIWIN7LISTSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win7
		{

/***********************************************************************
List Control Buttons
***********************************************************************/
			
			class Win7SelectableItemStyle : public Win7ButtonStyleBase, public Description<Win7SelectableItemStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win7SelectableItemStyle();
				~Win7SelectableItemStyle();
			};
			
			class Win7ListViewColumnDropDownStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7ListViewColumnDropDownStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			leftBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			arrowComposition;

				elements::GuiGradientBackgroundElement*		leftBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiPolygonElement*				arrowElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7ListViewColumnDropDownStyle();
				~Win7ListViewColumnDropDownStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};
			
			class Win7ListViewColumnHeaderStyle : public Object, public virtual controls::GuiListViewColumnHeader::IStyleController, public Description<Win7ListViewColumnHeaderStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSubMenuExisting;
				bool										isSubMenuOpening;

				compositions::GuiBoundsComposition*			mainComposition;
				compositions::GuiBoundsComposition*			rightBorderComposition;
				compositions::GuiBoundsComposition*			borderComposition;
				compositions::GuiBoundsComposition*			gradientComposition;
				compositions::GuiBoundsComposition*			textComposition;
				compositions::GuiBoundsComposition*			arrowComposition;

				elements::GuiSolidBackgroundElement*		backgroundElement;
				elements::GuiGradientBackgroundElement*		rightBorderElement;
				elements::GuiSolidBorderElement*			borderElement;
				elements::GuiGradientBackgroundElement*		gradientElement;
				elements::GuiSolidLabelElement*				textElement;
				elements::GuiPolygonElement*				arrowElement;

				controls::GuiButton*						dropdownButton;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool subMenuExisting, bool subMenuOpening);
			public:
				Win7ListViewColumnHeaderStyle();
				~Win7ListViewColumnHeaderStyle();

				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;
				void														SetSelected(bool value)override;
				void														Transfer(controls::GuiButton::ControlState value)override;
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														SetColumnSortingState(controls::GuiListViewColumnHeader::ColumnSortingState value)override;
			};
			
			class Win7TreeViewExpandingButtonStyle : public Object, public virtual controls::GuiSelectableButton::IStyleController, public Description<Win7TreeViewExpandingButtonStyle>
			{
			protected:
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;

				compositions::GuiBoundsComposition*			mainComposition;
				elements::GuiPolygonElement*				polygonElement;

				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected);
			public:
				Win7TreeViewExpandingButtonStyle();
				~Win7TreeViewExpandingButtonStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										SetSelected(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

/***********************************************************************
ComboBox
***********************************************************************/
			
#pragma warning(push)
#pragma warning(disable:4250)
			class Win7DropDownComboBoxStyle : public Win7ButtonStyle, public virtual controls::GuiComboBoxBase::IStyleController, public Description<Win7DropDownComboBoxStyle>
			{
			protected:
				controls::GuiComboBoxBase::ICommandExecutor*	commandExecutor;
				compositions::GuiTableComposition*				table;
				compositions::GuiCellComposition*				textComposition;
				compositions::GuiCellComposition*				dropDownComposition;
				elements::GuiPolygonElement*					dropDownElement;

				void											TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
				void											AfterApplyColors(const Win7ButtonColors& colors)override;
			public:
				Win7DropDownComboBoxStyle();
				~Win7DropDownComboBoxStyle();
				
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)override;
				void														OnItemSelected()override;
			};
#pragma warning(pop)

/***********************************************************************
List
***********************************************************************/
			
			class Win7TextListProvider : public Object, public virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider, public Description<Win7TextListProvider>
			{
			public:
				Win7TextListProvider();
				~Win7TextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()override;
				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
				Color													GetTextColor()override;
			};
			
			class Win7CheckTextListProvider : public Win7TextListProvider, public Description<Win7CheckTextListProvider>
			{
			public:
				Win7CheckTextListProvider();
				~Win7CheckTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};
			
			class Win7RadioTextListProvider : public Win7TextListProvider, public Description<Win7RadioTextListProvider>
			{
			public:
				Win7RadioTextListProvider();
				~Win7RadioTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

#pragma warning(push)
#pragma warning(disable:4250)
			class Win7ListViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiListView::IStyleProvider, public Description<Win7ListViewProvider>
			{
			public:
				Win7ListViewProvider();
				~Win7ListViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiListViewColumnHeader::IStyleController*	CreateColumnStyle()override;
				Color													GetPrimaryTextColor()override;
				Color													GetSecondaryTextColor()override;
				Color													GetItemSeparatorColor()override;
			};
			
			class Win7TreeViewProvider : public Win7MultilineTextBoxProvider, public virtual controls::GuiTreeView::IStyleProvider, public Description<Win7TreeViewProvider>
			{
			public:
				Win7TreeViewProvider();
				~Win7TreeViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()override;
				Color													GetTextColor()override;
			};
#pragma warning(pop)
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8TABSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8TABSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8TABSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Tab
***********************************************************************/

			class Win8TabPageHeaderStyle : public Win8ButtonStyleBase, public Description<Win8TabPageHeaderStyle>
			{
			protected:
				void														TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win8TabPageHeaderStyle();
				~Win8TabPageHeaderStyle();

				void														SetFont(const FontProperties& value)override;
			};

			class Win8TabStyle : public win7::Win7TabStyle, public Description<Win8TabStyle>
			{
			protected:
				
				controls::GuiSelectableButton::IStyleController*			CreateHeaderStyleController()override;
				controls::GuiButton::IStyleController*						CreateMenuButtonStyleController()override;
				controls::GuiToolstripMenu::IStyleController*				CreateMenuStyleController()override;
				controls::GuiToolstripButton::IStyleController*				CreateMenuItemStyleController()override;
				Color														GetBorderColor()override;
				Color														GetBackgroundColor()override;
			public:
				Win8TabStyle();
				~Win8TabStyle();
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8TOOLSTRIPSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8TOOLSTRIPSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWIN8TOOLSTRIPSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
Toolstrip Button
***********************************************************************/

			class Win8ToolstripToolBarStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win8ToolstripToolBarStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			containerComposition;
			public:
				Win8ToolstripToolBarStyle();
				~Win8ToolstripToolBarStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};

			class Win8ToolstripButtonDropdownStyle : public Object, public virtual controls::GuiButton::IStyleController, public Description<Win8ToolstripButtonDropdownStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
				compositions::GuiBoundsComposition*			splitterComposition;
				compositions::GuiBoundsComposition*			containerComposition;
				bool										isVisuallyEnabled;
				controls::GuiButton::ControlState			controlState;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled);
			public:
				Win8ToolstripButtonDropdownStyle();
				~Win8ToolstripButtonDropdownStyle();
				
				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
				void										Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win8ToolstripButtonStyle : public Object, public virtual controls::GuiMenuButton::IStyleController, public Description<Win8ToolstripButtonStyle>
			{
			public:
				enum ButtonStyle
				{
					CommandButton,
					DropdownButton,
					SplitButton,
				};
			protected:
				DEFINE_TRANSFERRING_ANIMATION(Win8ButtonColors, Win8ToolstripButtonStyle)

				Win8ButtonElements							elements;
				Ptr<TransferringAnimation>					transferringAnimation;
				controls::GuiButton::ControlState			controlStyle;
				bool										isVisuallyEnabled;
				bool										isSelected;
				bool										isOpening;
				elements::GuiImageFrameElement*				imageElement;
				compositions::GuiBoundsComposition*			imageComposition;
				ButtonStyle									buttonStyle;
				controls::GuiButton*						subMenuHost;

				virtual void								TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected, bool menuOpening);
			public:
				Win8ToolstripButtonStyle(ButtonStyle _buttonStyle);
				~Win8ToolstripButtonStyle();
				
				compositions::GuiBoundsComposition*							GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				void														SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void														SetText(const WString& value)override;
				void														SetFont(const FontProperties& value)override;
				void														SetVisuallyEnabled(bool value)override;
				void														SetSelected(bool value)override;
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														Transfer(controls::GuiButton::ControlState value)override;
			};

			class Win8ToolstripSplitterStyle : public Object, public virtual controls::GuiControl::IStyleController, public Description<Win8ToolstripSplitterStyle>
			{
			protected:
				compositions::GuiBoundsComposition*			boundsComposition;
			public:
				Win8ToolstripSplitterStyle();
				~Win8ToolstripSplitterStyle();

				compositions::GuiBoundsComposition*			GetBoundsComposition()override;
				compositions::GuiGraphicsComposition*		GetContainerComposition()override;
				void										SetFocusableComposition(compositions::GuiGraphicsComposition* value)override;
				void										SetText(const WString& value)override;
				void										SetFont(const FontProperties& value)override;
				void										SetVisuallyEnabled(bool value)override;
			};
		}
	}
}

#endif

/***********************************************************************
CONTROLS\STYLES\WIN8STYLES\GUIWIN8LISTSTYLES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Control Styles::Windows8 Styles

Clases:
***********************************************************************/

#ifndef VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWin8LISTSTYLES
#define VCZH_PRESENTATION_CONTROLS_WIN8STYLES_GUIWin8LISTSTYLES


namespace vl
{
	namespace presentation
	{
		namespace win8
		{

/***********************************************************************
List Control Buttons
***********************************************************************/
			
			class Win8SelectableItemStyle : public Win8ButtonStyleBase, public Description<Win8SelectableItemStyle>
			{
			protected:
				void										TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
			public:
				Win8SelectableItemStyle();
				~Win8SelectableItemStyle();
			};

/***********************************************************************
ComboBox
***********************************************************************/
			
#pragma warning(push)
#pragma warning(disable:4250)
			class Win8DropDownComboBoxStyle : public Win8ButtonStyle, public virtual controls::GuiComboBoxBase::IStyleController, public Description<Win8DropDownComboBoxStyle>
			{
			protected:
				controls::GuiComboBoxBase::ICommandExecutor*	commandExecutor;
				compositions::GuiTableComposition*				table;
				compositions::GuiCellComposition*				textComposition;
				compositions::GuiCellComposition*				dropDownComposition;
				elements::GuiPolygonElement*					dropDownElement;

				void											TransferInternal(controls::GuiButton::ControlState value, bool enabled, bool selected)override;
				void											AfterApplyColors(const Win8ButtonColors& colors)override;
			public:
				Win8DropDownComboBoxStyle();
				~Win8DropDownComboBoxStyle();
				
				compositions::GuiGraphicsComposition*						GetContainerComposition()override;
				
				controls::GuiMenu::IStyleController*						CreateSubMenuStyleController()override;
				void														SetSubMenuExisting(bool value)override;
				void														SetSubMenuOpening(bool value)override;
				controls::GuiButton*										GetSubMenuHost()override;
				void														SetImage(Ptr<GuiImageData> value)override;
				void														SetShortcutText(const WString& value)override;
				void														SetCommandExecutor(controls::GuiComboBoxBase::ICommandExecutor* value)override;
				void														OnItemSelected()override;
			};
#pragma warning(pop)

/***********************************************************************
List
***********************************************************************/
			
			class Win8TextListProvider : public Object, public virtual controls::list::TextItemStyleProvider::ITextItemStyleProvider, public Description<Win8TextListProvider>
			{
			public:
				Win8TextListProvider();
				~Win8TextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBackgroundStyleController()override;
				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
				Color													GetTextColor()override;
			};
			
			class Win8CheckTextListProvider : public Win8TextListProvider, public Description<Win8CheckTextListProvider>
			{
			public:
				Win8CheckTextListProvider();
				~Win8CheckTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};
			
			class Win8RadioTextListProvider : public Win8TextListProvider, public Description<Win8RadioTextListProvider>
			{
			public:
				Win8RadioTextListProvider();
				~Win8RadioTextListProvider();

				controls::GuiSelectableButton::IStyleController*		CreateBulletStyleController()override;
			};

#pragma warning(push)
#pragma warning(disable:4250)
			class Win8ListViewProvider : public Win8MultilineTextBoxProvider, public virtual controls::GuiListView::IStyleProvider, public Description<Win8ListViewProvider>
			{
			public:
				Win8ListViewProvider();
				~Win8ListViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiListViewColumnHeader::IStyleController*	CreateColumnStyle()override;
				Color													GetPrimaryTextColor()override;
				Color													GetSecondaryTextColor()override;
				Color													GetItemSeparatorColor()override;
			};
			
			class Win8TreeViewProvider : public Win8MultilineTextBoxProvider, public virtual controls::GuiTreeView::IStyleProvider, public Description<Win8TreeViewProvider>
			{
			public:
				Win8TreeViewProvider();
				~Win8TreeViewProvider();

				controls::GuiSelectableButton::IStyleController*		CreateItemBackground()override;
				controls::GuiSelectableButton::IStyleController*		CreateItemExpandingDecorator()override;
				Color													GetTextColor()override;
			};
#pragma warning(pop)
		}
	}
}

#endif

/***********************************************************************
RESOURCES\GUIPARSERMANAGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
GacUI::Resource

Interfaces:
***********************************************************************/

#ifndef VCZH_PRESENTATION_RESOURCES_GUIPARSERMANAGER
#define VCZH_PRESENTATION_RESOURCES_GUIPARSERMANAGER


namespace vl
{
	namespace presentation
	{
		using namespace reflection;

/***********************************************************************
Parser
***********************************************************************/

		class IGuiGeneralParser : public IDescriptable, public Description<IGuiGeneralParser>
		{
		public:
			virtual Ptr<Object>						Parse(const WString& text, collections::List<WString>& errors)=0;
		};

		template<typename T>
		class IGuiParser : public IGuiGeneralParser
		{
		public:
			virtual Ptr<T>							TypedParse(const WString& text, collections::List<WString>& errors)=0;

			Ptr<Object> Parse(const WString& text, collections::List<WString>& errors)override
			{
				return TypedParse(text, errors);
			}
		};

/***********************************************************************
Parser Manager
***********************************************************************/

		class IGuiParserManager : public IDescriptable, public Description<IGuiParserManager>
		{
		protected:
			typedef parsing::tabling::ParsingTable			Table;

		public:
			virtual Ptr<Table>						GetParsingTable(const WString& name)=0;
			virtual bool							SetParsingTable(const WString& name, Func<Ptr<Table>()> loader)=0;
			virtual Ptr<IGuiGeneralParser>			GetParser(const WString& name)=0;
			virtual bool							SetParser(const WString& name, Ptr<IGuiGeneralParser> parser)=0;

			template<typename T>
			Ptr<IGuiParser<T>>						GetParser(const WString& name);

			template<typename T>
			bool									SetTableParser(const WString& tableName, const WString& parserName, Ptr<T>(*function)(const WString&, Ptr<Table>, collections::List<Ptr<parsing::ParsingError>>&, vint));
		};

		extern IGuiParserManager*					GetParserManager();

/***********************************************************************
Strong Typed Table Parser
***********************************************************************/

		template<typename T>
		class GuiStrongTypedTableParser : public Object, public IGuiParser<T>
		{
		protected:
			typedef parsing::tabling::ParsingTable				Table;
			typedef Ptr<T>(ParserFunction)(const WString&, Ptr<Table>, collections::List<Ptr<parsing::ParsingError>>&, vint);
		protected:
			WString									name;
			Ptr<Table>								table;
			Func<ParserFunction>					function;
		public:
			GuiStrongTypedTableParser(const WString& _name, ParserFunction* _function)
				:name(_name)
				,function(_function)
			{
			}

			Ptr<T> TypedParse(const WString& text, collections::List<WString>& errors)override
			{
				if(!table)
				{
					table = GetParserManager()->GetParsingTable(name);
				}
				if(table)
				{
					collections::List<Ptr<parsing::ParsingError>> parsingErrors;
					auto result = function(text, table, parsingErrors, -1);
					if (!result)
					{
						errors.Add(L"Failed to parse the following input as format \"" + name + L"\":");
						errors.Add(text);
					}
					for (vint i = 0; i < parsingErrors.Count(); i++)
					{
						auto error = parsingErrors[i];
						errors.Add(
							L"Format: " + name +
							L", Row: " + itow(error->codeRange.start.row + 1) +
							L", Column: " + itow(error->codeRange.start.column + 1) +
							L", Message: " + error->errorMessage);
					}
					return result;
				}
				return 0;
			}
		};

/***********************************************************************
Parser Manager
***********************************************************************/

		template<typename T>
		Ptr<IGuiParser<T>> IGuiParserManager::GetParser(const WString& name)
		{
			return GetParser(name).Cast<IGuiParser<T>>();
		}

		template<typename T>
		bool IGuiParserManager::SetTableParser(const WString& tableName, const WString& parserName, Ptr<T>(*function)(const WString&, Ptr<Table>, collections::List<Ptr<parsing::ParsingError>>&, vint))
		{
			Ptr<IGuiParser<T>> parser=new GuiStrongTypedTableParser<T>(tableName, function);
			return SetParser(parserName, parser);
		}
	}
}

#endif
