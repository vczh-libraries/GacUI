# !!!TASK!!!

# PROBLEM DESCRIPTION
## TASK No.2: Fix Multi-Paragraph Document Rendering (Client)

Fix the remote-rendered rich text document so that multiple paragraphs (created via Enter / Ctrl+Enter, depending on editor semantics) are all rendered, not just the last one. The fix must be in the client-side renderer (`GuiRemoteRendererSingle`) because the core remote protocol is already covered well by unit tests, and the symptom strongly suggests the client renderer is dropping or overwriting previously created paragraph elements during incremental updates.

### what to be done

- Reproduce the symptom by reasoning from editor semantics:
  - Ctrl+Enter likely inserts a line break inside a single paragraph (single `RendererType::DocumentParagraph` element id), while Enter creates a new paragraph (multiple paragraph element ids in the DOM).
  - Use this to guide where the bug must be: element scheduling / batching / redraw vs per-paragraph update logic.
- Verify element id correctness and collisions:
  - Confirm the core sends distinct element ids for each new paragraph created by Enter.
  - Confirm the client does not overwrite prior entries in `availableElements` for different paragraphs (no accidental key reuse / collision).
- Clarify whether the bug is composition-tree lifecycle vs render traversal:
  - Verify paragraph wrapper elements are created and inserted into the composition / visual tree (not just stored in `availableElements`).
  - Verify the rendering loop traverses and renders all paragraph nodes, not only the most recently updated one.
- Ensure there is no shared global paragraph state:
  - Ensure each paragraph element id maps to its own wrapper instance and its own underlying `IGuiGraphicsParagraph`.
- Validate render-target binding & registration behavior per paragraph:
  - Because `IGuiGraphicsParagraph` is render-target-bound, ensure per-paragraph registration/unregistration cannot inadvertently drop earlier paragraphs.
  - Keep `id == -1` as the single source of truth for “not registered / not available”.
- Investigate whether the renderer actually repaints after paragraph updates:
  - In `GuiRemoteRendererSingle_Rendering.cpp`, `needRefresh` is set via `CheckDom()` (dom changes) and `Paint()` (OS repaint), but `RequestRendererUpdateElement_*` handlers do not trigger a refresh by themselves.
  - Verify whether the core sends DOM diffs for Enter (new paragraph) vs Ctrl+Enter (no paragraph count change) and whether the client relies on `RequestRendererBeginRendering` / `RequestRendererEndRendering` as the “frame boundary” to trigger refresh.
- Ensure paragraph updates and frame boundaries always schedule a redraw:
  - Decide and implement a consistent policy: mark `needRefresh = true` on `RequestRendererEndRendering` (recommended), and/or on `RequestRendererUpdateElement_DocumentParagraph` when paragraph content/metrics changes.
  - Make sure the policy covers the case where only element updates happen (DOM tree unchanged) so previously rendered paragraphs are not left stale or implicitly cleared.
- Cross-check client behavior against the mock/spec implementation:
  - Use `Source\UnitTestUtilities\GuiUnitTestProtocol_Rendering_Document.cpp` as the reference for update semantics and element lifecycle expectations (including multiple paragraphs).
- Validate compilation using the normal build scripts; skip unit testing for this task.
  - In future task documents created from this task, include in `## AFFECTED PROJECTS` a note that unit tests should not be run if the core remote protocol code is not changed.

### rationale

- The Ctrl+Enter vs Enter difference strongly suggests “single paragraph vs multiple paragraphs” is the triggering condition, so the most likely failures are:
  - redraw scheduling (only the last updated paragraph causes a repaint), or
  - DOM traversal / clipping behavior (multiple paragraph nodes exist but only one is rendered).
- In the current client implementation, `needRefresh` is driven primarily by DOM updates (`CheckDom`) and OS paint events (`Paint`), so if the core sends element updates without an accompanying DOM diff, the client can fail to redraw updated content.
- The core remote protocol is already well-covered by unit tests, while `GuiRemoteRendererSingle` is not and is hard to end-to-end test here, so this task should focus on making the renderer’s refresh / composition behavior robust and predictable without changing protocol semantics.

# UPDATES

# INSIGHTS AND REASONING

## Current rendering pipeline (core → client)

- Core-side rendering (`Source\PlatformProviders\Remote\GuiRemoteGraphics*.cpp`) issues a **rendering cycle**:
  - `RequestRendererBeginRendering(frameId)`
  - a sequence of `RequestRendererRenderElement(...)` and optional `RequestRendererBeginBoundary/EndBoundary(...)` (generated by clippers)
  - `RequestRendererEndRendering()`
- The **dom-diff converter** (`Source\PlatformProviders\Remote\GuiRemoteProtocol_DomDiff.cpp`) intercepts the above and converts the per-frame rendering commands into:
  - `RequestRendererRenderDom(dom)` on first frame, and then
  - `RequestRendererRenderDomDiff(diffs)` on subsequent frames.
- Client-side `GuiRemoteRendererSingle` (`Source\PlatformProviders\RemoteRenderer\GuiRemoteRendererSingle_Rendering.cpp`) is currently implemented as:
  - store the latest DOM / apply diffs (`RequestRendererRenderDom*`), which sets `needRefresh = true` via `CheckDom()`
  - a timer (`GlobalTimer`) does `StartRendering()` → `Render(dom)` recursion → `StopRendering()` → `window->RedrawContent()`.

## What the symptom implies

- Ctrl+Enter producing “two lines” strongly suggests a **single paragraph element id** whose text contains a line break (or equivalent), meaning the client pipeline can draw multi-line text inside one `RendererType::DocumentParagraph`.
- Enter producing “only the last paragraph” strongly suggests a **multi-paragraph scenario** (multiple `RendererType::DocumentParagraph` ids) where:
  - earlier paragraph elements either disappear from the client DOM, or
  - multiple paragraphs are laid out to the same bounds (overlap), so the last one drawn covers the others.

## Most likely root cause (client-side, systematic)

### Hypothesis A (highest likelihood): DOM diffs represent a partial frame, but the client redraw is full-frame

Evidence from code:

- The DOM is reconstructed from **rendering commands** (see `RenderingDomBuilder` in `GuiRemoteProtocolSchema_BuildFrame.cpp`). Those commands are naturally affected by:
  - invalid regions / clipping (the underlying render pipeline may choose to paint only a portion of the window), and
  - element-level culling (only elements intersecting the current clipper are rendered).
- The client, however, treats the latest DOM as a **complete scene graph** and redraws the whole window from scratch each `needRefresh` tick.

Failure mode:

- If the core paints only the region that contains the *newly inserted paragraph* (a common outcome for Enter: content below moves, invalidation may concentrate on the changed area), the reconstructed DOM for that frame can legally contain only the last paragraph.
- `DiffDom(...)` will then generate **Deleted** diffs for DOM nodes that were not emitted in that frame.
- Client applies deletions via `UpdateDomInplace(...)`, and then redraws from scratch → earlier paragraphs vanish.

Why Ctrl+Enter differs:

- Ctrl+Enter modifies the same paragraph; invalidation tends to stay within the existing paragraph bounds, and the “only rendered paragraph in the frame” is still the correct one.

### Hypothesis B (secondary): refresh scheduling is too DOM-driven

- Client refresh is primarily driven by `CheckDom()` and `Paint()`.
- If some text updates only cause `RequestRendererUpdateElement_DocumentParagraph` but do not produce a DOM diff (or if the diff is empty), the client may not refresh reliably.

## Mandatory verification before implementation

- Trace/log what requests are issued on **Enter** (new paragraph) vs **Ctrl+Enter** (line break):
  - `RequestRendererBeginRendering` / `RequestRendererEndRendering`
  - `RequestRendererRenderDomDiff` diff counts and whether any `Deleted` diffs appear
  - `RequestRendererRenderElement` / `RequestRendererUpdateElement_DocumentParagraph` (element id + bounds)
- Confirm whether paragraphs whose bounds change (shift) but are outside the dirty region still arrive as `Modified` with updated bounds, or are omitted and therefore appear as `Deleted` in `DiffDom(...)`.
- Confirm whether `DiffDom(...)` classifies moved elements as `Modified` vs `Deleted`.

## Design proposals

### Proposal 1 (conditional): tolerate partial-frame DOM diffs by not applying element-node deletions

Goal: prevent “only last paragraph remains” when a frame contains only a partial repaint and `DiffDom(...)` produces `Deleted` diffs for element nodes not emitted in that frame.

High-level approach (only if verification shows shifted paragraphs still receive updated bounds):

- Keep `RenderDom` / `RenderDomDiff` as the primary protocol.
- When applying diffs client-side, ignore `RenderingDom_DiffType::Deleted` for **element nodes** (and their virtual parents) based on `GuiRemoteProtocolSchema_FrameOperations.h` id encoding:
  - element nodes: `id % 4 == 0` (and virtual parents: `id % 4 == 1`)
  - hit-test nodes: `id % 4 == 2/3`
- Still apply deletions for hit-test nodes (`%4 == 2/3`) to avoid accumulating stale hit-test nodes.
- Preserve existing lifecycle conventions:
  - do not introduce parallel “existence tracking” beyond `RequestRendererCreated/Destroyed`
  - keep `id == -1` registration state as authoritative

Critical risk / why conditional:

- If a new paragraph is inserted, subsequent paragraphs may shift (bounds/Y changes).
- If those shifted paragraphs are **not** sent with updated bounds in the same/next frames, keeping them client-side will retain stale bounds and can cause overlap/layout corruption (worse than missing paragraphs).
- Therefore, if verification shows bounds updates for shifted paragraphs are omitted, this approach is not viable as-is; prefer core-side “full bounds update” behavior or command-based rendering (Proposal 3).

### Proposal 2: enforce refresh on frame boundary and paragraph update

- Set `needRefresh = true` on:
  - `RequestRendererEndRendering(...)` (frame boundary)
  - and/or `RequestRendererUpdateElement_DocumentParagraph(...)` (content/metrics updates)
- This addresses missed redraw cases, but does not alone prevent the “deleted DOM nodes due to partial frame” issue.

### Proposal 3 (fallback): support command-based rendering (BeginBoundary/RenderElement)

- Implement `RequestRendererBeginBoundary`, `RequestRendererEndBoundary`, and `RequestRendererRenderElement` in `GuiRemoteRendererSingle` instead of failing.
- This would allow a future mode where the client can paint exactly what the core paints (including partial invalid regions) without relying on DOM diffs.
- This requires core-side configuration changes (disabling dom-diff converter) and is therefore not preferred for a “client-only” fix.

## Recommended decision

1) Do the mandatory verification first and decide based on evidence:

- If shifted paragraphs **are** sent as `Modified` with updated bounds, focus on fixing DOM diff correctness (ID matching / diff classification / DOM building), and optionally apply Proposal 1 as a robustness layer against partial-frame deletions.
- If shifted paragraphs **are not** sent with updated bounds (i.e. frames are partial and moved elements are omitted), do **not** apply Proposal 1 alone; instead:
  - prefer a core-side change to ensure full frames (or at least bounds updates for all moved elements) when dom-diff mode is active, and/or
  - move toward command-based rendering (Proposal 3) so the client consumes exactly what the core produces.

2) Apply Proposal 2 regardless (refresh scheduling hygiene), since it improves stability when only element updates happen.

## Verification requirements

- Manual verification (required):
  - Create 3+ paragraphs; insert a paragraph at the top/middle; ensure all paragraphs render and none overlap.
  - Compare Enter vs Ctrl+Enter behavior.
  - Scroll/resize to force repaints; ensure content persists.
- Automated verification:
  - Run any existing remote-renderer tests if available; otherwise document the exact manual steps above to prevent regressions.

# AFFECTED PROJECTS

- Build the solution in folder REPO-ROOT\Test\GacUISrc
  - Run Test Project UnitTest (optional; can be skipped for this task if core remote protocol code is not changed)

# !!!FINISHED!!!
