# !!!TASK!!!

# PROBLEM DESCRIPTION
## TASK No.2: Fix Multi-Paragraph Document Rendering (Client)

Fix the remote-rendered rich text document so that multiple paragraphs (created via Enter / Ctrl+Enter, depending on editor semantics) are all rendered, not just the last one. The fix must be in the client-side renderer (`GuiRemoteRendererSingle`) because the core remote protocol is already covered well by unit tests, and the symptom strongly suggests the client renderer is dropping or overwriting previously created paragraph elements during incremental updates.

### what to be done

- Reproduce the symptom by reasoning from editor semantics:
  - Ctrl+Enter likely inserts a line break inside a single paragraph (single `RendererType::DocumentParagraph` element id), while Enter creates a new paragraph (multiple paragraph element ids in the DOM).
  - Use this to guide where the bug must be: element scheduling / batching / redraw vs per-paragraph update logic.
- Verify element id correctness and collisions:
  - Confirm the core sends distinct element ids for each new paragraph created by Enter.
  - Confirm the client does not overwrite prior entries in `availableElements` for different paragraphs (no accidental key reuse / collision).
- Clarify whether the bug is composition-tree lifecycle vs render traversal:
  - Verify paragraph wrapper elements are created and inserted into the composition / visual tree (not just stored in `availableElements`).
  - Verify the rendering loop traverses and renders all paragraph nodes, not only the most recently updated one.
- Ensure there is no shared global paragraph state:
  - Ensure each paragraph element id maps to its own wrapper instance and its own underlying `IGuiGraphicsParagraph`.
- Validate render-target binding & registration behavior per paragraph:
  - Because `IGuiGraphicsParagraph` is render-target-bound, ensure per-paragraph registration/unregistration cannot inadvertently drop earlier paragraphs.
  - Keep `id == -1` as the single source of truth for “not registered / not available”.
- Investigate whether the renderer actually repaints after paragraph updates:
  - In `GuiRemoteRendererSingle_Rendering.cpp`, `needRefresh` is set via `CheckDom()` (dom changes) and `Paint()` (OS repaint), but `RequestRendererUpdateElement_*` handlers do not trigger a refresh by themselves.
  - Verify whether the core sends DOM diffs for Enter (new paragraph) vs Ctrl+Enter (no paragraph count change) and whether the client relies on `RequestRendererBeginRendering` / `RequestRendererEndRendering` as the “frame boundary” to trigger refresh.
- Ensure paragraph updates and frame boundaries always schedule a redraw:
  - Decide and implement a consistent policy: mark `needRefresh = true` on `RequestRendererEndRendering` (recommended), and/or on `RequestRendererUpdateElement_DocumentParagraph` when paragraph content/metrics changes.
  - Make sure the policy covers the case where only element updates happen (DOM tree unchanged) so previously rendered paragraphs are not left stale or implicitly cleared.
- Cross-check client behavior against the mock/spec implementation:
  - Use `Source\UnitTestUtilities\GuiUnitTestProtocol_Rendering_Document.cpp` as the reference for update semantics and element lifecycle expectations (including multiple paragraphs).
- Validate compilation using the normal build scripts; skip unit testing for this task.
  - In future task documents created from this task, include in `## AFFECTED PROJECTS` a note that unit tests should not be run if the core remote protocol code is not changed.

### rationale

- The Ctrl+Enter vs Enter difference strongly suggests “single paragraph vs multiple paragraphs” is the triggering condition, so the most likely failures are:
  - redraw scheduling (only the last updated paragraph causes a repaint), or
  - DOM traversal / clipping behavior (multiple paragraph nodes exist but only one is rendered).
- In the current client implementation, `needRefresh` is driven primarily by DOM updates (`CheckDom`) and OS paint events (`Paint`), so if the core sends element updates without an accompanying DOM diff, the client can fail to redraw updated content.
- The core remote protocol is already well-covered by unit tests, while `GuiRemoteRendererSingle` is not and is hard to end-to-end test here, so this task should focus on making the renderer’s refresh / composition behavior robust and predictable without changing protocol semantics.

# UPDATES

# INSIGHTS AND REASONING

## Current rendering pipeline (core → client)

- Core-side rendering (`Source\PlatformProviders\Remote\GuiRemoteGraphics*.cpp`) issues a **rendering cycle**:
  - `RequestRendererBeginRendering(frameId)`
  - a sequence of `RequestRendererRenderElement(...)` and optional `RequestRendererBeginBoundary/EndBoundary(...)` (generated by clippers)
  - `RequestRendererEndRendering()`
- The **dom-diff converter** (`Source\PlatformProviders\Remote\GuiRemoteProtocol_DomDiff.cpp`) intercepts the above and converts the per-frame rendering commands into:
  - `RequestRendererRenderDom(dom)` on first frame, and then
  - `RequestRendererRenderDomDiff(diffs)` on subsequent frames.
- Client-side `GuiRemoteRendererSingle` (`Source\PlatformProviders\RemoteRenderer\GuiRemoteRendererSingle_Rendering.cpp`) is currently implemented as:
  - store the latest DOM / apply diffs (`RequestRendererRenderDom*`), which sets `needRefresh = true` via `CheckDom()`
  - a timer (`GlobalTimer`) does `StartRendering()` → `Render(dom)` recursion → `StopRendering()` → `window->RedrawContent()`.

## What the symptom implies

- Ctrl+Enter producing “two lines” strongly suggests a **single paragraph element id** whose text contains a line break (or equivalent), meaning the client pipeline can draw multi-line text inside one `RendererType::DocumentParagraph`.
- Enter producing “only the last paragraph” strongly suggests a **multi-paragraph scenario** (multiple `RendererType::DocumentParagraph` ids) where:
  - earlier paragraph elements either disappear from the client DOM, or
  - multiple paragraphs are laid out to the same bounds (overlap), so the last one drawn covers the others.

## Most likely root cause (client-side, systematic)

### Hypothesis A (highest likelihood): DOM diffs represent a partial frame, but the client redraw is full-frame

Evidence from code:

- The DOM is reconstructed from **rendering commands** (see `RenderingDomBuilder` in `GuiRemoteProtocolSchema_BuildFrame.cpp`). Those commands are naturally affected by:
  - invalid regions / clipping (the underlying render pipeline may choose to paint only a portion of the window), and
  - element-level culling (only elements intersecting the current clipper are rendered).
- The client, however, treats the latest DOM as a **complete scene graph** and redraws the whole window from scratch each `needRefresh` tick.

Failure mode:

- If the core paints only the region that contains the *newly inserted paragraph* (a common outcome for Enter: content below moves, invalidation may concentrate on the changed area), the reconstructed DOM for that frame can legally contain only the last paragraph.
- `DiffDom(...)` will then generate **Deleted** diffs for DOM nodes that were not emitted in that frame.
- Client applies deletions via `UpdateDomInplace(...)`, and then redraws from scratch → earlier paragraphs vanish.

Why Ctrl+Enter differs:

- Ctrl+Enter modifies the same paragraph; invalidation tends to stay within the existing paragraph bounds, and the “only rendered paragraph in the frame” is still the correct one.

### Hypothesis B (secondary): refresh scheduling is too DOM-driven

- Client refresh is primarily driven by `CheckDom()` and `Paint()`.
- If some text updates only cause `RequestRendererUpdateElement_DocumentParagraph` but do not produce a DOM diff (or if the diff is empty), the client may not refresh reliably.

## Design proposals

### Proposal 1 (recommended): make the client DOM-diff application robust against partial frames

Goal: avoid dropping previously known paragraph nodes just because they were not included in a partial repaint.

High-level approach:

- Continue accepting `RenderDom` / `RenderDomDiff` as the primary protocol.
- Change the client-side DOM-diff application so that **DOM deletions for element nodes are not treated as authoritative**.
  - Use the DOM id encoding documented in `GuiRemoteProtocolSchema_FrameOperations.h`:
    - element nodes: `id % 4 == 0` (and their virtual parents: `id % 4 == 1`)
    - hit-test nodes: `id % 4 == 2/3`
  - Filter out `RenderingDom_DiffType::Deleted` diffs where `diff.id % 4 == 0 || diff.id % 4 == 1`.
    - This keeps paragraph nodes and avoids “only last paragraph remains”.
  - Keep deletions for hit-test nodes (`%4 == 2/3`) so hit-testing/cursor updates do not accumulate stale nodes.
- Element lifetime still remains correct because the actual renderable objects are managed by `RequestRendererCreated/Destroyed`, and render traversal already guards with `availableElements` lookups.

Tradeoffs:

- Pros: client-only change; preserves correct rendering when the core emits a partial repaint; minimal risk to the protocol surface.
- Cons: element DOM nodes can accumulate if the scene changes drastically without full redraws; however the element id map remains the authoritative existence check, and future modified diffs can still update bounds.

### Proposal 2: enforce refresh on frame boundary and paragraph update

- Set `needRefresh = true` on:
  - `RequestRendererEndRendering(...)` (frame boundary)
  - and/or `RequestRendererUpdateElement_DocumentParagraph(...)` (content/metrics updates)
- This addresses missed redraw cases, but does not alone prevent the “deleted DOM nodes due to partial frame” issue.

### Proposal 3 (fallback): support command-based rendering (BeginBoundary/RenderElement)

- Implement `RequestRendererBeginBoundary`, `RequestRendererEndBoundary`, and `RequestRendererRenderElement` in `GuiRemoteRendererSingle` instead of failing.
- This would allow a future mode where the client can paint exactly what the core paints (including partial invalid regions) without relying on DOM diffs.
- This requires core-side configuration changes (disabling dom-diff converter) and is therefore not preferred for a “client-only” fix.

## Recommended decision

Adopt Proposal 1 + Proposal 2:

- Proposal 1 directly targets the most plausible disappearance mechanism (partial repaint → deletions → full redraw).
- Proposal 2 improves stability in cases where only element updates happen.

# AFFECTED PROJECTS

- Build the solution in folder REPO-ROOT\Test\GacUISrc
  - Run Test Project UnitTest (optional; can be skipped for this task if core remote protocol code is not changed)

# !!!FINISHED!!!
