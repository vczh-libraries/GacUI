# Interfaces

Interfaces can be defined in **modules**, **namespaces**, **classes** and **interfaces**.

An interface shapes an object by defining how methods, properties and events look like.

An interface usually begins with: - **interface IMyInterface**: it means the new interface expression creates an object that implements this interface and returns a shared pointer holding this object. Such expression should look like: **new IMyInterface^ { ... }**. - **interface IMyInterface***: it means the new interface expression creates an object that implements this interface and returns a raw pointer holding this object. Such expression should look like: **new IMyInterface* { ... }**.

Methods, properties and events are allowed in both interface declaration and new interface expressions.

Static methods, classes, interfaces, enums are allowed in interfaces, they are accessed by **TYPE::MEMBER** outside of the interface. Static methods must have a body, and they cannot be implemented in new interface expressions.

Variables are allowed in new interface expressions. Variables are only accessible to methods in this new interface expression.

All methods, including that are generated by properties, must be overrided in the new interface expression, using **override** keyword before functions.

``` module sampleModule; interface ICounter { func Increase(): int; } func main(): string { var counter = new ICounter^ { var x: int = 0; override func Increase(): int { x = x + 1; return x; } }; var r = ""; for (i in range [0, 10)) { r = r & $"$(counter.Increase()); "; } return r; } ```

In this example, we define an interface **ICounter**. Note that we didn't use **interface ICounter*** here, it means that **new ICounter^ { ... }** is legal, but **new ICounter* { ... }** is not. So the type of **counter** is **ICounter^**.

This interface has a method called **Increase**, which makes **counter.Increase()** a valid expression.

All variables defined at parent scopes of this new interface expression are captured by value. But since **counter** doesn't have an explicit type, so visiting **counter** in this new interface expression results in an error, because the type is not recognized yet when processing members of this new interface expression.

**IMPORTANT**: even if **counter** is hidden from the method, but when the method is resolving the name **counter**, all symbols called **counter** will be examined before picking the right one, so it still generates an error.

Now we call **counter.Increase()** 10 times, which generates numbers from 1 to 10. Function **main** returns **"1; 2; 3; 4; 5; 6; 7; 8; 9; 10; "**.

