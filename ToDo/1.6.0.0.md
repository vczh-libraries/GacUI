# 1.6.0.0

# TODO

## Milestone

- UI Automation
  - An interface to create an object and store in a control.
  - When children list of a control is updated, the object will get notified.
  - When template or template name is updated, the object will get notified.
  - Association is lazy: if a control leaves the top level window, the connection is released. Only when the object is required (e.g. read children from parent), it is connected.
  - An Windows implementation will convert the tree to UI Automation COM interfaces and expose through WM_GETOBJECT

https://learn.microsoft.com/en-us/windows/win32/winauto/entry-uiauto-win32#developer-audience
https://learn.microsoft.com/en-us/windows/win32/winauto/handling-the-wm-getobject-message
https://github.com/github/copilot-sdk/blob/main/docs/getting-started.md

## Instructions

You goal is to fill `Plan` and `Details` in this document.
GacUI is going to support Windows OS UI Automation technology, not the old MSA technology.
The first job is to fill the `Plan` section. It includes:
- First item: You need to get the link from MSDN (aka learn.microsoft.com) about this topic, write it down under the bullet item.
- Second item: There maybe multiple MSDN pages associated with it, write them down under the bullet item.
- Third item: Work out all UI Automation control types and their interfaces, organize them with their inheritance relationship (either actually or semantically inherited), list them in bullet using "- [ ]". Bullet items of a sub class must be under the base class. Each UI Automation must with its MSDN link.
- Fourth item: One actual `vl::presentation::controls::GuiX` class maps to multiple `ThemeName`, you are able to connect class to theme names based on their template class types. List all `ThemeName` enum item with "- [ ]" in their inheritance relationship, work out their mapping UI Automation control interface
- Other items: These controls are super complex, you must provide deeply details for them.

Now you got check lists of topics to research. Follow these instructions until you checks every item:
- Pick the first incomplete item in `Plan`, change from "- [ ]" to "- [+]" meaning you are working on it. You must immediately save the file to disk.
  - If the first incomplete item is "- [ ]", you are on a fresh start with this item. You can start a sub agent to work on it.
  - If the first incomplete item is "- [+]", it means you stopped at the middle, find out the corresponding title under `Details` and continue.
- Add it as a "###" title under `Details` section.
- Find out enough information and fill the title. The criteria of successful is that, one can follow the idea under this title, with helps from related mentioned MSDN links, and finish the coding work. You must immediatelly save the file to disk.
- Mark the item in `Plan` from "- [+]" to "- [*]" meaning you have finished this item.

At the moment, you don't need to mention in details about how to implement an UI Automation control interface using the GacUI control class. The more important work is to help one understand what a certain UI Automation control interface expectes the implementation to do. For examples, how many properties/events/actions can this UI Automation control interface offer, which in them are must have (aka not optional). You don't need to repeat in a child interface what is already in the parent interface.

## Plan

- [*] How WM_GETOBJECT works
  - Primary: https://learn.microsoft.com/en-us/windows/win32/winauto/wm-getobject
  - Related:
    - https://learn.microsoft.com/en-us/windows/win32/winauto/handling-the-wm-getobject-message
    - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiareturnrawelementprovider
    - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiahostproviderfromhwnd
- [*] How does UI Automation properties, events and actions work?
  - Primary: https://learn.microsoft.com/en-us/windows/win32/winauto/entry-uiauto-win32
  - Properties:
    - Overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-propertiesoverview
    - Property IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-automation-element-propids
    - Not supported sentinel: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiagetreservednotsupportedvalue
  - Events:
    - Overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-eventsoverview
    - Event IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-event-ids
    - Raise events:
      - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraiseautomationevent
      - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraiseautomationpropertychangedevent
      - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraisestructurechangedevent
      - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaclientsarelistening
  - Actions (control patterns):
    - Overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controlpatternsoverview
    - Pattern IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controlpattern-ids
- [*] UI Automation supported interfaces for controls
  - Primary: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-providerportal
  - Related:
    - Provider overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-providersoverview
    - Supporting control types: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-supportinguiautocontroltypes
    - Implementing patterns: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementinguiautocontrolpatterns
  - [*] Provider interfaces (tree/navigation)
    - [*] `IRawElementProviderSimple`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementprovidersimple
    - [*] `IRawElementProviderFragment`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderfragment
    - [*] `IRawElementProviderFragmentRoot`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderfragmentroot
    - [*] `IRawElementProviderAdviseEvents` (optional): https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementprovideradviseevents
    - [*] `IRawElementProviderHwndOverride` (optional): https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderhwndoverride
    - [*] `ICustomNavigationProvider` (optional): https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-icustomnavigationprovider
  - [*] Pattern provider interfaces (control behavior)
    - [*] Invoke: `IInvokeProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iinvokeprovider
    - [*] Toggle: `IToggleProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itoggleprovider
    - [*] Selection: `ISelectionProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iselectionprovider
    - [*] Selection item: `ISelectionItemProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iselectionitemprovider
    - [*] Expand/collapse: `IExpandCollapseProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iexpandcollapseprovider
    - [*] Value: `IValueProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-ivalueprovider
    - [*] Range value: `IRangeValueProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irangevalueprovider
    - [*] Scroll: `IScrollProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iscrollprovider
    - [*] Scroll item: `IScrollItemProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iscrollitemprovider
    - [*] Grid: `IGridProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-igridprovider
    - [*] Grid item: `IGridItemProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-igriditemprovider
    - [*] Table: `ITableProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itableprovider
    - [*] Table item: `ITableItemProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itableitemprovider
    - [*] Text: `ITextProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextprovider
    - [*] Text range: `ITextRangeProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextrangeprovider
    - [*] Text edit: `ITextEditProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itexteditprovider
    - [*] Item container: `IItemContainerProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iitemcontainerprovider
    - [*] Virtualized item: `IVirtualizedItemProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-ivirtualizeditemprovider
    - [*] Window: `IWindowProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iwindowprovider
    - [*] Transform: `ITransformProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itransformprovider
    - [*] Transform 2: `ITransformProvider2` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itransformprovider2
    - [*] Dock: `IDockProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-idockprovider
    - [*] Multiple view: `IMultipleViewProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-imultipleviewprovider
    - [*] Styles: `IStylesProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-istylesprovider
    - [*] Spreadsheet: `ISpreadsheetProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-ispreadsheetprovider
    - [*] Spreadsheet item: `ISpreadsheetItemProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-ispreadsheetitemprovider
    - [*] Drag: `IDragProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-idragprovider
    - [*] Drop target: `IDropTargetProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-idroptargetprovider
    - [*] Synchronized input: `ISynchronizedInputProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-isynchronizedinputprovider
    - [*] Annotation: `IAnnotationProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iannotationprovider
    - [*] Text 2: `ITextProvider2` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextprovider2
    - [*] Text range 2: `ITextRangeProvider2` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextrangeprovider2
    - [*] Text child: `ITextChildProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextchildprovider
    - [*] Legacy bridge: `ILegacyIAccessibleProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-ilegacyiaccessibleprovider
- [*] Inheritance between `vl::presentation::templates::theme::ThemeName` and matching UI Automation control
  - Primary: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-supportinguiautocontroltypes
  - Related:
    - Control type IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controltype-ids
    - Pattern overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controlpatternsoverview
  - [*] `WindowTemplate`
    - [*] `SystemFrameWindow`
    - [*] `CustomFrameWindow`
    - [*] `Tooltip`
  - [*] `ControlTemplate`
    - [*] `CustomControl`
    - [*] `GroupBox`
    - [*] `MenuBar`
    - [*] `MenuSplitter`
    - [*] `ToolstripToolBar`
    - [*] `ToolstripToolBarInMenu`
    - [*] `ToolstripSplitter`
    - [*] `ToolstripSplitterInMenu`
    - [*] `RibbonSplitter`
    - [*] `RibbonToolstripHeader`
  - [*] `LabelTemplate`
    - [*] `Label`
    - [*] `ShortcutKey`
  - [*] `ScrollViewTemplate`
    - [*] `ScrollView`
  - [*] `TabTemplate`
    - [*] `Tab`
  - [*] `ComboBoxTemplate`
    - [*] `ComboBox`
  - [*] `DocumentViewerTemplate`
    - [*] `DocumentViewer`
    - [*] `MultilineTextBox`
  - [*] `DocumentLabelTemplate`
    - [*] `DocumentLabel`
    - [*] `DocumentTextBox`
    - [*] `SinglelineTextBox`
  - [*] `ListViewTemplate`
    - [*] `ListView`
  - [*] `TreeViewTemplate`
    - [*] `TreeView`
  - [*] `TextListTemplate`
    - [*] `TextList`
    - [*] `RibbonGalleryItemList`
  - [*] `SelectableButtonTemplate`
    - [*] `ListItemBackground`
    - [*] `TreeItemExpander`
    - [*] `CheckTextListItem`
    - [*] `RadioTextListItem`
    - [*] `CheckBox`
    - [*] `RadioButton`
  - [*] `MenuTemplate`
    - [*] `Menu`
  - [*] `ToolstripButtonTemplate`
    - [*] `MenuBarButton`
    - [*] `MenuItemButton`
    - [*] `ToolstripButton`
    - [*] `ToolstripDropdownButton`
    - [*] `ToolstripSplitButton`
    - [*] `RibbonSmallButton`
    - [*] `RibbonSmallDropdownButton`
    - [*] `RibbonSmallSplitButton`
    - [*] `RibbonLargeButton`
    - [*] `RibbonLargeDropdownButton`
    - [*] `RibbonLargeSplitButton`
  - [*] Ribbon-specific templates
    - [*] `RibbonTabTemplate` / `RibbonTab`
    - [*] `RibbonGroupTemplate` / `RibbonGroup`
    - [*] `RibbonGroupMenuTemplate` / `RibbonGroupMenu`
    - [*] `RibbonIconLabelTemplate` / `RibbonIconLabel`
    - [*] `RibbonIconLabelTemplate` / `RibbonSmallIconLabel`
    - [*] `RibbonButtonsTemplate` / `RibbonButtons`
    - [*] `RibbonToolstripsTemplate` / `RibbonToolstrips`
    - [*] `RibbonGalleryTemplate` / `RibbonGallery`
    - [*] `RibbonToolstripMenuTemplate` / `RibbonToolstripMenu`
    - [*] `RibbonGalleryListTemplate` / `RibbonGalleryList`
  - [*] `ButtonTemplate`
    - [*] `Button`
  - [*] `DatePickerTemplate`
    - [*] `DatePicker`
  - [*] `DateComboBoxTemplate`
    - [*] `DateComboBox`
  - [*] `ScrollTemplate`
    - [*] `HScroll`
    - [*] `VScroll`
    - [*] `HTracker`
    - [*] `VTracker`
    - [*] `ProgressBar`
- [*] Details about container control with items (combo, list, tab, etc) and virtualization
  - Primary: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementinguiautocontrolpatterns
  - Related:
    - `IVirtualizedItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-ivirtualizeditemprovider
    - `IScrollItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iscrollitemprovider
    - `IItemContainerProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iitemcontainerprovider
- [*] Details about list view detail view (grid/table semantics)
  - Primary: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-igridprovider
  - Related:
    - `IGridItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-igriditemprovider
    - `ITableProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itableprovider
    - `ITableItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itableitemprovider
- [*] Details about plain text and rich text controls (Text pattern)
  - Primary: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementingtextandtextrange
  - Related:
    - `ITextProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextprovider
    - `ITextRangeProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextrangeprovider
    - `ITextEditProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itexteditprovider

## Details

### How WM_GETOBJECT works

References:
- WM_GETOBJECT message: https://learn.microsoft.com/en-us/windows/win32/winauto/wm-getobject
- Handling the message: https://learn.microsoft.com/en-us/windows/win32/winauto/handling-the-wm-getobject-message
- Returning a provider (`UiaReturnRawElementProvider`): https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiareturnrawelementprovider

What the message means:
- `WM_GETOBJECT` is sent by accessibility clients to obtain an accessibility object from a window.
- The message identifies what kind of accessibility object is requested via `dwObjId`. When `dwObjId == UiaRootObjectId`, the request is specifically for a UI Automation provider.
- A server responds by returning an `LRESULT` that encodes the provider pointer (for UIA: via `UiaReturnRawElementProvider`).

Minimum returned object:
- For UI Automation, the returned object must implement `IRawElementProviderSimple`:
  - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementprovidersimple

Fragment tree model (needed for real control trees):
- If you want a navigable element tree (parent/child/siblings) and hit-testing/focus within the window, implement a fragment:
  - Root: `IRawElementProviderFragmentRoot` (hit-test + focus entry points)
    - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderfragmentroot
  - Children: `IRawElementProviderFragment` (navigation, runtime id, bounding rect, focus)
    - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderfragment

Composing with HWND hosting:
- If some parts of the UI are real HWNDs (or you want to delegate to system default behavior), you can obtain a host provider:
  - `UiaHostProviderFromHwnd`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiahostproviderfromhwnd
- If you have “windowless” content inside an HWND and need to override the provider returned for that HWND, check:
  - `IRawElementProviderHwndOverride`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderhwndoverride

What to get right (so clients can actually use it):
- The root provider must represent the correct top-level surface (usually the client-area root of the window).
- Bounding rectangles must match what is on screen (or consistently report offscreen).
- Focus must be coherent: `GetFocus` returns the focused element; `SetFocus` moves focus to what the user perceives as the focusable target.
- When the control tree changes, raise structure changed events so clients can update their cached model.

### How does UI Automation properties, events and actions work?

References:
- Entry: https://learn.microsoft.com/en-us/windows/win32/winauto/entry-uiauto-win32
- Properties:
  - Overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-propertiesoverview
  - Property IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-automation-element-propids
- Events:
  - Overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-eventsoverview
  - Event IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-event-ids
- Control patterns:
  - Overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controlpatternsoverview
  - Pattern IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controlpattern-ids

Properties:
- Clients query properties by `PROPERTYID`.
- Providers answer via `IRawElementProviderSimple::GetPropertyValue`.
- Return “not supported” for properties that do not apply:
  - `UiaGetReservedNotSupportedValue`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiagetreservednotsupportedvalue

Actions and “behavior”:
- UIA “actions” are modeled as control patterns (Invoke/Toggle/Selection/Scroll/Text/...).
- Clients request a pattern by `PATTERNID`; providers return an object implementing the matching provider interface from `GetPatternProvider`.
- A pattern is not a visual part; it is a contract for behavior. If the behavior exists, expose the pattern even if the control looks custom.

Events:
- Clients subscribe to events; providers must raise them when the UI changes.
- Common raising functions:
  - `UiaRaiseAutomationEvent`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraiseautomationevent
  - `UiaRaiseAutomationPropertyChangedEvent`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraiseautomationpropertychangedevent
  - `UiaRaiseStructureChangedEvent`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraisestructurechangedevent
- Use this to avoid expensive work when nobody listens:
  - `UiaClientsAreListening`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaclientsarelistening

“Must have” patterns by common control semantics (examples):
- Push button: `ControlType.Button` + `IInvokeProvider`.
- Check box: `ControlType.CheckBox` + `IToggleProvider`.
- Radio button: `ControlType.RadioButton` + `ISelectionItemProvider` (in a selection container).
- Scrollbar/slider/progress: `IRangeValueProvider` (and read-only where appropriate).
- List/tree/tab: `ISelectionProvider` (+ `ISelectionItemProvider` on items) and `IScrollProvider` when scrollable.

### UI Automation supported interfaces for controls

References:
- Provider portal: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-providerportal
- Providers overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-providersoverview
- Supporting control types: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-supportinguiautocontroltypes
- Implementing patterns: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementinguiautocontrolpatterns

Provider interfaces (tree shape):
- `IRawElementProviderSimple` (base for everything):
  - Exposes properties and patterns and optionally a host provider for HWND.
  - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementprovidersimple
- `IRawElementProviderFragment` (element in a tree):
  - Navigation, runtime id, bounding rectangle, focus, root link.
  - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderfragment
- `IRawElementProviderFragmentRoot` (tree root for hit-test and focus):
  - `ElementProviderFromPoint` and `GetFocus`.
  - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementproviderfragmentroot

Pattern interfaces (behavior):
- Use the minimal set that describes the control's user-facing behavior; avoid exposing patterns for internal visual parts.
- Typical mapping:
  - Command-like: `IInvokeProvider`
  - On/off: `IToggleProvider`
  - Selectable: `ISelectionProvider` / `ISelectionItemProvider`
  - Popup / hierarchy: `IExpandCollapseProvider`
  - Editable text: `IValueProvider` (often also `ITextProvider` for good accessibility)
  - Ranged: `IRangeValueProvider`
  - Scroll containers: `IScrollProvider` (and `IScrollItemProvider` on items)
  - Virtualized items: `IVirtualizedItemProvider`
  - Tables/grids: `IGridProvider`/`IGridItemProvider` and optionally `ITableProvider`/`ITableItemProvider`
  - Text: `ITextProvider` + `ITextRangeProvider` (+ `ITextEditProvider` when editable)

Optional-but-useful interfaces (only when needed):
- `IRawElementProviderAdviseEvents` (UIA tells provider what events are subscribed): https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-irawelementprovideradviseevents
- `ICustomNavigationProvider` (non-standard navigation models): https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-icustomnavigationprovider

### Inheritance between `vl::presentation::templates::theme::ThemeName` and matching UI Automation control

References:
- Supporting control types: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-supportinguiautocontroltypes
- Control type IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controltype-ids
- Pattern overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controlpatternsoverview

Purpose of this mapping:
- `vl::presentation::templates::theme::ThemeName` is a theme/style selector.
- UI Automation requires a semantic role (`ControlType`) and behavior (patterns).
- Use theme name as a hint only; the actual control class behavior decides patterns.

Legend:
- CT: `ControlType.*`
- Patterns: Invoke=`IInvokeProvider`, Toggle=`IToggleProvider`, Sel=`ISelectionProvider`, SelItem=`ISelectionItemProvider`, ExpCol=`IExpandCollapseProvider`, Val=`IValueProvider`, Range=`IRangeValueProvider`, Scroll=`IScrollProvider`, Text=`ITextProvider`, Grid=`IGridProvider`, Table=`ITableProvider`, Win=`IWindowProvider`, Xform=`ITransformProvider`.

Suggested mapping per template group (from `Source/Application/Controls/GuiThemeManager.h`):
- `WindowTemplate`
  - `SystemFrameWindow`: CT=Window, Patterns=Win + Xform
  - `CustomFrameWindow`: CT=Window, Patterns=Win + Xform
  - `Tooltip`: CT=ToolTip
- `ControlTemplate`
  - `CustomControl`: CT=Custom (patterns depend on the actual control; do not guess)
  - `GroupBox`: CT=Group
  - `MenuBar`: CT=MenuBar
  - `MenuSplitter`: CT=Separator
  - `ToolstripToolBar`: CT=ToolBar
  - `ToolstripToolBarInMenu`: CT=ToolBar
  - `ToolstripSplitter`: CT=Separator
  - `ToolstripSplitterInMenu`: CT=Separator
  - `RibbonSplitter`: CT=Separator
  - `RibbonToolstripHeader`: CT=Header
- `LabelTemplate`
  - `Label`: CT=Text
  - `ShortcutKey`: CT=Text (use `AccessKey` property when meaningful)
- `ScrollViewTemplate`
  - `ScrollView`: CT=Pane, Patterns=Scroll
- `TabTemplate`
  - `Tab`: CT=Tab, Patterns=Sel
- `ComboBoxTemplate`
  - `ComboBox`: CT=ComboBox, Patterns=ExpCol + Sel (+ Val if editable)
- `DocumentViewerTemplate`
  - `DocumentViewer`: CT=Document, Patterns=Text (+ Scroll if scrollable)
  - `MultilineTextBox`: CT=Edit, Patterns=Val + Text (+ Scroll if scrollable)
- `DocumentLabelTemplate`
  - `DocumentLabel`: CT=Text (or CT=Document if it is a document surface), Patterns=Text when rich navigation is supported
  - `DocumentTextBox`: CT=Edit, Patterns=Val + Text
  - `SinglelineTextBox`: CT=Edit, Patterns=Val (Text optional but recommended)
- `ListViewTemplate`
  - `ListView`: CT=List (or CT=DataGrid for detail view), Patterns=Sel + Scroll (+ Grid/Table for detail view)
- `TreeViewTemplate`
  - `TreeView`: CT=Tree, Patterns=Sel + Scroll (tree items should be ExpCol + SelItem)
- `TextListTemplate`
  - `TextList`: CT=List, Patterns=Sel + Scroll
  - `RibbonGalleryItemList`: CT=List, Patterns=Sel + Scroll
- `SelectableButtonTemplate`
  - `ListItemBackground`: CT=ListItem, Patterns=SelItem (and Toggle if checkable)
  - `TreeItemExpander`: usually model as part of the owning tree item (ExpCol); expose separately only if independently focusable/clickable
  - `CheckTextListItem`: CT=ListItem, Patterns=SelItem + Toggle
  - `RadioTextListItem`: CT=ListItem, Patterns=SelItem
  - `CheckBox`: CT=CheckBox, Patterns=Toggle
  - `RadioButton`: CT=RadioButton, Patterns=SelItem (in a selection container)
- `MenuTemplate`
  - `Menu`: CT=Menu (menu items: CT=MenuItem + Invoke, and ExpCol when they open a submenu)
- `ToolstripButtonTemplate`
  - `MenuBarButton`: CT=MenuItem, Patterns=Invoke (+ ExpCol for submenu)
  - `MenuItemButton`: CT=MenuItem, Patterns=Invoke (+ Toggle if checkable)
  - `ToolstripButton`: CT=Button, Patterns=Invoke (+ Toggle if checkable)
  - `ToolstripDropdownButton`: CT=SplitButton, Patterns=Invoke + ExpCol
  - `ToolstripSplitButton`: CT=SplitButton, Patterns=Invoke + ExpCol
  - `RibbonSmallButton`: CT=Button, Patterns=Invoke
  - `RibbonSmallDropdownButton`: CT=SplitButton, Patterns=Invoke + ExpCol
  - `RibbonSmallSplitButton`: CT=SplitButton, Patterns=Invoke + ExpCol
  - `RibbonLargeButton`: CT=Button, Patterns=Invoke
  - `RibbonLargeDropdownButton`: CT=SplitButton, Patterns=Invoke + ExpCol
  - `RibbonLargeSplitButton`: CT=SplitButton, Patterns=Invoke + ExpCol
- Ribbon-specific templates
  - `RibbonTabTemplate` / `RibbonTab`: CT=Tab, Patterns=Sel
  - `RibbonGroupTemplate` / `RibbonGroup`: CT=Group
  - `RibbonGroupMenuTemplate` / `RibbonGroupMenu`: CT=Menu
  - `RibbonIconLabelTemplate` / `RibbonIconLabel`: CT=Text (or CT=Image if decorative)
  - `RibbonIconLabelTemplate` / `RibbonSmallIconLabel`: CT=Text (or CT=Image if decorative)
  - `RibbonButtonsTemplate` / `RibbonButtons`: CT=ToolBar
  - `RibbonToolstripsTemplate` / `RibbonToolstrips`: CT=ToolBar
  - `RibbonGalleryTemplate` / `RibbonGallery`: CT=List, Patterns=Sel + Scroll
  - `RibbonToolstripMenuTemplate` / `RibbonToolstripMenu`: CT=Menu
  - `RibbonGalleryListTemplate` / `RibbonGalleryList`: CT=List, Patterns=Sel + Scroll
- `ButtonTemplate`
  - `Button`: CT=Button, Patterns=Invoke
- `DatePickerTemplate`
  - `DatePicker`: CT=Calendar (or CT=Custom if composite), Patterns=Val (+ ExpCol if drop-down)
- `DateComboBoxTemplate`
  - `DateComboBox`: CT=ComboBox, Patterns=ExpCol + Val
- `ScrollTemplate`
  - `HScroll`: CT=ScrollBar, Patterns=Range
  - `VScroll`: CT=ScrollBar, Patterns=Range
  - `HTracker`: CT=Slider, Patterns=Range
  - `VTracker`: CT=Slider, Patterns=Range
  - `ProgressBar`: CT=ProgressBar, Patterns=Range (read-only)

### Details about container control with items (combo, list, tab, etc) and virtualization

References:
- Implementing patterns: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementinguiautocontrolpatterns
- `ISelectionProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iselectionprovider
- `ISelectionItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iselectionitemprovider
- `IScrollProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iscrollprovider
- `IScrollItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iscrollitemprovider
- `IVirtualizedItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-ivirtualizeditemprovider
- `IItemContainerProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-iitemcontainerprovider

Item containers:
- The container exposes structure/selection/scrolling; items expose item-level behavior and properties.
- Items should be discoverable and actionable even if currently scrolled out or virtualized.

Selection:
- Container implements `ISelectionProvider` and items implement `ISelectionItemProvider`.
- Raise selection-related events when selection changes.
  - Container must report `CanSelectMultiple` and `IsSelectionRequired` accurately.
  - `GetSelection()` returns the currently selected item providers (empty only when selection is optional).
  - Items must implement selection actions consistently:
    - `Select()` always selects the item (and clears others when single-select).
    - `AddToSelection()` / `RemoveFromSelection()` must work when multi-select is supported; otherwise return a correct failure.

Scrolling and "bring into view":
- Container implements `IScrollProvider` when scrollable.
- Items implement `IScrollItemProvider` so clients can bring them into view.
  - `IScrollProvider` must report:
    - `HorizontallyScrollable` / `VerticallyScrollable`
    - `HorizontalScrollPercent` / `VerticalScrollPercent`
    - `HorizontalViewSize` / `VerticalViewSize`
  - `Scroll()` and `SetScrollPercent()` should match user-perceived scrolling (page/line semantics should feel consistent).

Virtualization:
- If items are created on demand, item providers implement `IVirtualizedItemProvider`.
- `Realize()` must ensure the item becomes available for querying and interaction.
- When virtualization changes the element tree, raise structure changed events.
  - If the container supports searching without enumerating all children, implement `IItemContainerProvider::FindItemByProperty` and make it work with virtualized data sets (return the next matching item after a given start item).

Combo box popup behavior:
- Combo box element uses `IExpandCollapseProvider` to represent open/closed.
- Popup list presence must be consistent with expand state; raise property/structure changes appropriately.

Tab behavior:
- Tab control is the container (`ISelectionProvider`).
- Tab headers are items (`ISelectionItemProvider`), and selecting them switches the active content.

### Details about list view detail view (grid/table semantics)

References:
- `IGridProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-igridprovider
- `IGridItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-igriditemprovider
- `ITableProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itableprovider
- `ITableItemProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itableitemprovider

When to expose grid/table:
- Use grid/table patterns when the view is logically rows and columns (detail view), not just visually aligned.
- For icon/list/tile views, prefer list + items and avoid a cell model unless needed.

Minimum model:
- The container implements `IGridProvider` (row/column counts + `GetItem(row, column)`).
- Each cell implements `IGridItemProvider` (row/column indices + containing grid).
- If headers exist, add `ITableProvider`/`ITableItemProvider` to associate cells with headers.
  - `IGridItemProvider` must report `Row`, `Column`, `RowSpan`, `ColumnSpan`, and `ContainingGrid`.
  - `ITableProvider` should report `RowOrColumnMajor` and return row/column header elements from `GetRowHeaders()` / `GetColumnHeaders()` when the UI has headers.

Selection, focus, scrolling:
- Selection is typically per row (item), not per cell, unless the UI supports cell selection.
- If scrollable, expose `IScrollProvider` on the container.
- If virtualized, keep `GetItem` behavior consistent (realize on demand or clearly not supported).

### Details about plain text and rich text controls (Text pattern)

References:
- Implementing text and ranges: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementingtextandtextrange
- `ITextProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextprovider
- `ITextRangeProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextrangeprovider
- `ITextEditProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itexteditprovider
- Mixed attribute sentinel: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiagetreservedmixedattributevalue

Plain text vs rich text:
- `IValueProvider` is not enough for many assistive technology scenarios; `ITextProvider` enables reading by word/line and reliable caret/selection support.
- Rich text requires correct ranges and attribute reporting; otherwise clients cannot interpret formatting.

Core expectations for `ITextProvider`:
- Provide `DocumentRange` and consistent range objects.
- Implement selection (`GetSelection`) and report correct `SupportedTextSelection`.
- Provide visible ranges (`GetVisibleRanges`) to reflect the viewport.
- Provide hit-testing (`RangeFromPoint`) and child mapping (`RangeFromChild`) when needed.
  - `DocumentRange` must span the whole document, not only visible text.
  - `GetVisibleRanges()` should return ranges that correspond to the visible layout (if paginated/virtualized, keep ranges stable across minor scroll changes).

Core expectations for `ITextRangeProvider`:
- Ranges must normalize and behave consistently under all operations.
- `GetText(maxLength)` must return the exact text for the range.
- Movement must respect UIA text units (character/word/line/paragraph/page/document) matching the control's behavior.
  - `GetBoundingRectangles()` must match layout (multiple rectangles for wrapped lines is normal).
  - `ScrollIntoView(alignToTop)` should reveal the range in the viewport.
  - Selection methods (`Select`, `AddToSelection`, `RemoveFromSelection`) must match the control's selection model.
- `GetAttributeValue(TEXTATTRIBUTEID)` must return a uniform value, or the mixed-attribute reserved value when needed:
  - https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiagetreservedmixedattributevalue

Editing (`ITextEditProvider`):
- For editable controls, expose editing semantics and raise the appropriate text-change events so clients can track incremental edits (not only full value replacement).

### Dynamic changes: `ControlType`, view modes, and pattern availability

References:
- Control type IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-controltype-ids
- Automation element property IDs (includes `ControlTypeProperty` and `Is*PatternAvailableProperty`): https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-automation-element-propids
- Property changed event raising: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraiseautomationpropertychangedevent
- Structure changed event raising: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraisestructurechangedevent
- Multiple view pattern: `IMultipleViewProvider` https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-imultipleviewprovider

What should (not) cause semantic changes:
- Theme changes (`ThemeName`) should normally not change UIA semantics. Visual restyling is not a semantic role change.
- Only real behavior changes should affect patterns: e.g. a combo box becomes editable (Value/Text becomes applicable), a list view switches into a true detail grid, a control becomes read-only, etc.

Can a provider change `ControlType` and patterns dynamically?
- Yes, but it is a compatibility risk because UIA clients often cache properties and pattern pointers.
- UIA does not provide a dedicated "pattern invalidated" event; clients discover pattern availability by querying again.

Recommended strategy (in order of preference):
1. Keep element identity stable, keep `ControlType` stable, and make view/mode differences visible via patterns and properties.
   - Example: list view view modes: keep CT=List and expose an additional grid/table pattern only when in detail view, plus `IMultipleViewProvider` so clients can understand and control the view switch.
2. If a pattern becomes temporarily inapplicable, keep returning the same pattern object, but make its methods validate current state and fail gracefully when the feature is not currently supported.
   - Also raise `AutomationPropertyChanged` for the corresponding `Is*PatternAvailableProperty` so well-behaved clients re-query.
3. If the semantic role truly changes (CT change, or the subtree is fundamentally replaced), treat it as a structural replacement.
   - Raise a structure changed event for the container/root (often "children invalidated" semantics).
   - Consider changing runtime id / provider identity so cached clients naturally reacquire properties/patterns from the "new" element.

What if the client already obtained a pattern that is no longer supported?
- You cannot assume the client will drop the old pointer immediately.
- Make old pattern objects safe to call:
  - Either continue to support the methods and map them to the new behavior, or
  - Return a consistent "not supported" / "not available" failure from the method calls when the feature is truly gone.
- Always raise the relevant property changed events so clients have a chance to detect the transition and query the current pattern set again.

### Text editing details: unsupported text units, embedded objects, and copy/paste

References:
- Implementing text and ranges: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-implementingtextandtextrange
- `ITextEditProvider`: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itexteditprovider
- `ITextChildProvider` (embedded objects): https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcore/nn-uiautomationcore-itextchildprovider
- Text edit change event: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiaraisetextedittextchangedevent

If you do not support Word/Page units in UIA text units:
- Clients (especially screen readers) typically expect at least Character/Word/Line navigation to work.
- If a unit is not meaningful for your control (e.g. Page in a continuously scrolling surface), you have two practical options:
  - Define "Page" as the current viewport/page of layout (a screenful) and implement it consistently, or
  - Do not support it, but still provide solid behavior for Character/Line/Paragraph/Document (and ideally Word).
- If you only partially support a unit, be consistent:
  - Return the actual number of units moved.
  - Do not silently treat Word as Character; clients will misbehave if unit semantics are incorrect.
- Practical recommendation when you "really do not support" Word and Page:
  - Page: it is usually acceptable to treat `TextUnit_Page` the same as `TextUnit_Document` for movement/expansion, as long as you do it consistently and `ScrollIntoView()` works.
  - Word: try very hard to provide a best-effort Word definition, even if your engine doesn't have "word" as a first-class concept. A simple (but consistent) heuristic is better than "not supported" because many AT features rely on word navigation.
    - A common heuristic is "a maximal run of non-whitespace characters" (or Unicode word-breaking if available).
  - If you still choose to not support Word:
    - Keep behavior deterministic: the range must not move and the method must clearly report "moved 0 units".
    - Ensure Character/Line/Paragraph/Document are high quality, and raise text-change + selection-change notifications reliably, so clients can still read and track edits.

Embedded images and embedded controls inside a document:
- UIA Text pattern supports embedded objects.
- The text stream typically contains an "object replacement" placeholder character for embedded objects; clients use this to understand there is a non-text object at that position.
- Embedded objects should also exist as UIA elements (children) so clients can interact with them:
  - `ITextRangeProvider::GetChildren()` returns embedded element providers contained in the range.
  - `ITextProvider::RangeFromChild()` maps an embedded element back to its text position.
  - Embedded elements implement `ITextChildProvider` so they can report their `TextContainer` and `TextRange`.
- For an embedded button, the embedded element should expose its own semantic patterns (e.g. `IInvokeProvider`) while remaining anchored into the document text via the text child relationship.

Copy/paste expectations:
- UIA does not give a dedicated clipboard pattern; clients often rely on a combination of:
  - Selection (`ITextProvider::GetSelection` and range selection methods)
  - Reading selected text (`ITextRangeProvider::GetText`)
  - Setting value / editing semantics (`IValueProvider` and/or `ITextEditProvider`)
  - Keyboard interaction (Ctrl+C / Ctrl+V) when driving the UI like a user
- Make sure selection + caret behavior is correct and events are raised:
  - Use `UiaRaiseTextEditTextChangedEvent` for edits so clients can track incremental changes rather than polling the entire document.
- For rich content, define a clear conversion policy for copy:
  - Plain text copy should produce reasonable text with placeholders for embedded objects.
  - If you support rich formats internally, ensure UIA text attributes and embedded children remain consistent with what the user sees and edits.

### Plain text vs rich text: how clients tell, and how to expose formatting

References:
- Text attributes overview: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-textattributes
- Text attribute IDs: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-textattribute-ids
- Not supported sentinel: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiagetreservednotsupportedvalue
- Mixed attribute sentinel: https://learn.microsoft.com/en-us/windows/win32/api/uiautomationcoreapi/nf-uiautomationcoreapi-uiagetreservedmixedattributevalue

How clients usually distinguish plain vs rich:
- There is no single "PlainText/RichText" flag in UIA that every client uses.
- Clients infer it from a combination of:
  - Pattern availability (Text pattern is a strong signal; Value-only is usually plain).
  - Whether text attributes are supported and vary inside a range (rich text).
  - Whether embedded objects exist (rich document behavior).

Recommended provider behavior:
- For both plain and rich text, support `ITextProvider` if you want good accessibility (caret, selection, reading by word/line, etc.).
- For plain text:
  - `ITextRangeProvider::GetAttributeValue(TEXTATTRIBUTEID)` can return:
    - A uniform default value (e.g. a single font for the entire document), or
    - The reserved not-supported value when the attribute has no meaning in this control.
  - If formatting is not user-editable and never varies, returning a single uniform value for common attributes (font name/size/foreground color) is often helpful.
- For rich text:
  - `GetAttributeValue` must return:
    - A specific value when the whole range has that attribute, or
    - The reserved mixed value when multiple attribute values exist in the range.
  - At minimum, ensure the common attributes are correct and consistent with rendering:
    - Font name, font size, font weight/bold, italic, underline, strikethrough
    - Foreground/background color
    - Horizontal alignment, indentation (if applicable)

How to expose "this part is bold/italic/underlined" (what UIA expects):
- UIA expects rich formatting to be discoverable by querying attributes on a range.
- Clients will typically:
  - Read text via `GetText()`.
  - Move/expand ranges by units (character/word/line/paragraph).
  - Call `GetAttributeValue()` for specific `TEXTATTRIBUTEID`s to determine formatting at the caret or across a selection.
- If your document model has runs/spans, make sure range endpoints can fall inside runs and attribute queries reflect the run at that position.

Embedded objects and formatting together:
- Embedded images/controls should appear in `GetChildren()` and also influence attributes/range text as needed.
- Keep a stable mapping between:
  - (text position) <-> (embedded UIA element) using `RangeFromChild()` and `ITextChildProvider`.

### Testing and validating a UIA provider implementation

References:
- Inspect Objects (Inspect.exe): https://learn.microsoft.com/en-us/windows/win32/winauto/inspect-objects
- WM_GETOBJECT: https://learn.microsoft.com/en-us/windows/win32/winauto/wm-getobject
- Supporting control types: https://learn.microsoft.com/en-us/windows/win32/winauto/uiauto-supportinguiautocontroltypes

Basic workflow (manual testing):
- Use Inspect.exe (Windows SDK) to:
  - Navigate the UIA tree, verify element order and parent/child relationships.
  - Check key properties: `ControlType`, `Name`, `AutomationId` (if any), `BoundingRectangle`, `IsEnabled`, `IsOffscreen`, focus properties.
  - Check which patterns are available on each element (and that they match expected behavior).
- Exercise interactions while Inspect is attached:
  - Toggle/view-mode switches: verify `Is*PatternAvailable` properties and relevant behavior changes.
  - Add/remove children (list items, tree nodes): verify structure changed events are raised and the tree updates.
  - Text editing: verify caret/selection behavior and that text-change notifications fire during typing/paste.

What to specifically validate for dynamic behavior:
- If a view mode changes (e.g. list view detail vs icons):
  - Verify whether `IMultipleViewProvider` is present and reflects the current view.
  - Verify whether grid/table patterns appear only when meaningful, and that old pattern objects remain safe to call.

What to validate for Text pattern:
- Range correctness:
  - `RangeFromPoint` hits the expected caret/character.
  - `GetBoundingRectangles` matches rendering (including wrapped lines).
- Editing correctness:
  - Selection changes are reflected immediately.
  - Copy/paste behaves like the UI (selected text is what gets copied; paste updates the document consistently).
- Rich text correctness:
  - Attribute queries match rendered formatting.
  - Mixed vs uniform attributes are reported correctly on multi-style selections.

Debugging hints:
- If Inspect cannot see your elements at all, start from `WM_GETOBJECT` and confirm the window responds with a UIA provider (`UiaRootObjectId` path).
- If properties/patterns look right but clients behave oddly, it is often an eventing issue: ensure you raise property/structure/text-change events consistently when the UI changes.
