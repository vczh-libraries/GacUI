/***********************************************************************
This file is generated by : Vczh GacUI Remote Protocol Generator
Licensed under https ://github.com/vczh-libraries/License
***********************************************************************/

#include "GuiRemoteProtocolSchema.h"

namespace vl::presentation::remoteprotocol
{
	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeWindowListener::HitTestResult>(const ::vl::presentation::INativeWindowListener::HitTestResult & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::INativeWindowListener::HitTestResult>(const ::vl::presentation::INativeWindowListener::HitTestResult&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::INativeWindowListener::BorderNoSizing: node->content.value = WString::Unmanaged(L"BorderNoSizing"); break;
		case ::vl::presentation::INativeWindowListener::BorderLeft: node->content.value = WString::Unmanaged(L"BorderLeft"); break;
		case ::vl::presentation::INativeWindowListener::BorderRight: node->content.value = WString::Unmanaged(L"BorderRight"); break;
		case ::vl::presentation::INativeWindowListener::BorderTop: node->content.value = WString::Unmanaged(L"BorderTop"); break;
		case ::vl::presentation::INativeWindowListener::BorderBottom: node->content.value = WString::Unmanaged(L"BorderBottom"); break;
		case ::vl::presentation::INativeWindowListener::BorderLeftTop: node->content.value = WString::Unmanaged(L"BorderLeftTop"); break;
		case ::vl::presentation::INativeWindowListener::BorderRightTop: node->content.value = WString::Unmanaged(L"BorderRightTop"); break;
		case ::vl::presentation::INativeWindowListener::BorderLeftBottom: node->content.value = WString::Unmanaged(L"BorderLeftBottom"); break;
		case ::vl::presentation::INativeWindowListener::BorderRightBottom: node->content.value = WString::Unmanaged(L"BorderRightBottom"); break;
		case ::vl::presentation::INativeWindowListener::Title: node->content.value = WString::Unmanaged(L"Title"); break;
		case ::vl::presentation::INativeWindowListener::ButtonMinimum: node->content.value = WString::Unmanaged(L"ButtonMinimum"); break;
		case ::vl::presentation::INativeWindowListener::ButtonMaximum: node->content.value = WString::Unmanaged(L"ButtonMaximum"); break;
		case ::vl::presentation::INativeWindowListener::ButtonClose: node->content.value = WString::Unmanaged(L"ButtonClose"); break;
		case ::vl::presentation::INativeWindowListener::Client: node->content.value = WString::Unmanaged(L"Client"); break;
		case ::vl::presentation::INativeWindowListener::Icon: node->content.value = WString::Unmanaged(L"Icon"); break;
		case ::vl::presentation::INativeWindowListener::NoDecision: node->content.value = WString::Unmanaged(L"NoDecision"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeCursor::SystemCursorType>(const ::vl::presentation::INativeCursor::SystemCursorType & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::INativeCursor::SystemCursorType>(const ::vl::presentation::INativeCursor::SystemCursorType&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::INativeCursor::SmallWaiting: node->content.value = WString::Unmanaged(L"SmallWaiting"); break;
		case ::vl::presentation::INativeCursor::LargeWaiting: node->content.value = WString::Unmanaged(L"LargeWaiting"); break;
		case ::vl::presentation::INativeCursor::Arrow: node->content.value = WString::Unmanaged(L"Arrow"); break;
		case ::vl::presentation::INativeCursor::Cross: node->content.value = WString::Unmanaged(L"Cross"); break;
		case ::vl::presentation::INativeCursor::Hand: node->content.value = WString::Unmanaged(L"Hand"); break;
		case ::vl::presentation::INativeCursor::Help: node->content.value = WString::Unmanaged(L"Help"); break;
		case ::vl::presentation::INativeCursor::IBeam: node->content.value = WString::Unmanaged(L"IBeam"); break;
		case ::vl::presentation::INativeCursor::SizeAll: node->content.value = WString::Unmanaged(L"SizeAll"); break;
		case ::vl::presentation::INativeCursor::SizeNESW: node->content.value = WString::Unmanaged(L"SizeNESW"); break;
		case ::vl::presentation::INativeCursor::SizeNS: node->content.value = WString::Unmanaged(L"SizeNS"); break;
		case ::vl::presentation::INativeCursor::SizeNWSE: node->content.value = WString::Unmanaged(L"SizeNWSE"); break;
		case ::vl::presentation::INativeCursor::SizeWE: node->content.value = WString::Unmanaged(L"SizeWE"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeWindow::WindowSizeState>(const ::vl::presentation::INativeWindow::WindowSizeState & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::INativeWindow::WindowSizeState>(const ::vl::presentation::INativeWindow::WindowSizeState&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::INativeWindow::WindowSizeState::Minimized: node->content.value = WString::Unmanaged(L"Minimized"); break;
		case ::vl::presentation::INativeWindow::WindowSizeState::Restored: node->content.value = WString::Unmanaged(L"Restored"); break;
		case ::vl::presentation::INativeWindow::WindowSizeState::Maximized: node->content.value = WString::Unmanaged(L"Maximized"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::IOMouseButton>(const ::vl::presentation::remoteprotocol::IOMouseButton & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::IOMouseButton>(const ::vl::presentation::remoteprotocol::IOMouseButton&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::remoteprotocol::IOMouseButton::Left: node->content.value = WString::Unmanaged(L"Left"); break;
		case ::vl::presentation::remoteprotocol::IOMouseButton::Middle: node->content.value = WString::Unmanaged(L"Middle"); break;
		case ::vl::presentation::remoteprotocol::IOMouseButton::Right: node->content.value = WString::Unmanaged(L"Right"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::ElementShapeType>(const ::vl::presentation::elements::ElementShapeType & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::elements::ElementShapeType>(const ::vl::presentation::elements::ElementShapeType&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::elements::ElementShapeType::Rectangle: node->content.value = WString::Unmanaged(L"Rectangle"); break;
		case ::vl::presentation::elements::ElementShapeType::Ellipse: node->content.value = WString::Unmanaged(L"Ellipse"); break;
		case ::vl::presentation::elements::ElementShapeType::RoundRect: node->content.value = WString::Unmanaged(L"RoundRect"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::GuiGradientBackgroundElement::Direction>(const ::vl::presentation::elements::GuiGradientBackgroundElement::Direction & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::elements::GuiGradientBackgroundElement::Direction>(const ::vl::presentation::elements::GuiGradientBackgroundElement::Direction&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::elements::GuiGradientBackgroundElement::Horizontal: node->content.value = WString::Unmanaged(L"Horizontal"); break;
		case ::vl::presentation::elements::GuiGradientBackgroundElement::Vertical: node->content.value = WString::Unmanaged(L"Vertical"); break;
		case ::vl::presentation::elements::GuiGradientBackgroundElement::Slash: node->content.value = WString::Unmanaged(L"Slash"); break;
		case ::vl::presentation::elements::GuiGradientBackgroundElement::Backslash: node->content.value = WString::Unmanaged(L"Backslash"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::Gui3DSplitterElement::Direction>(const ::vl::presentation::elements::Gui3DSplitterElement::Direction & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::elements::Gui3DSplitterElement::Direction>(const ::vl::presentation::elements::Gui3DSplitterElement::Direction&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::elements::Gui3DSplitterElement::Horizontal: node->content.value = WString::Unmanaged(L"Horizontal"); break;
		case ::vl::presentation::elements::Gui3DSplitterElement::Vertical: node->content.value = WString::Unmanaged(L"Vertical"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementHorizontalAlignment>(const ::vl::presentation::remoteprotocol::ElementHorizontalAlignment & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementHorizontalAlignment>(const ::vl::presentation::remoteprotocol::ElementHorizontalAlignment&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::remoteprotocol::ElementHorizontalAlignment::Left: node->content.value = WString::Unmanaged(L"Left"); break;
		case ::vl::presentation::remoteprotocol::ElementHorizontalAlignment::Right: node->content.value = WString::Unmanaged(L"Right"); break;
		case ::vl::presentation::remoteprotocol::ElementHorizontalAlignment::Center: node->content.value = WString::Unmanaged(L"Center"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementVerticalAlignment>(const ::vl::presentation::remoteprotocol::ElementVerticalAlignment & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementVerticalAlignment>(const ::vl::presentation::remoteprotocol::ElementVerticalAlignment&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::remoteprotocol::ElementVerticalAlignment::Top: node->content.value = WString::Unmanaged(L"Top"); break;
		case ::vl::presentation::remoteprotocol::ElementVerticalAlignment::Bottom: node->content.value = WString::Unmanaged(L"Bottom"); break;
		case ::vl::presentation::remoteprotocol::ElementVerticalAlignment::Center: node->content.value = WString::Unmanaged(L"Center"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest>(const ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest>(const ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest::FontHeight: node->content.value = WString::Unmanaged(L"FontHeight"); break;
		case ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest::TotalSize: node->content.value = WString::Unmanaged(L"TotalSize"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::INativeImage::FormatType>(const ::vl::presentation::INativeImage::FormatType & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::INativeImage::FormatType>(const ::vl::presentation::INativeImage::FormatType&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::INativeImage::Bmp: node->content.value = WString::Unmanaged(L"Bmp"); break;
		case ::vl::presentation::INativeImage::Gif: node->content.value = WString::Unmanaged(L"Gif"); break;
		case ::vl::presentation::INativeImage::Icon: node->content.value = WString::Unmanaged(L"Icon"); break;
		case ::vl::presentation::INativeImage::Jpeg: node->content.value = WString::Unmanaged(L"Jpeg"); break;
		case ::vl::presentation::INativeImage::Png: node->content.value = WString::Unmanaged(L"Png"); break;
		case ::vl::presentation::INativeImage::Tiff: node->content.value = WString::Unmanaged(L"Tiff"); break;
		case ::vl::presentation::INativeImage::Wmp: node->content.value = WString::Unmanaged(L"Wmp"); break;
		case ::vl::presentation::INativeImage::Unknown: node->content.value = WString::Unmanaged(L"Unknown"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RendererType>(const ::vl::presentation::remoteprotocol::RendererType & value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RendererType>(const ::vl::presentation::remoteprotocol::RendererType&)#"
		auto node = Ptr(new glr::json::JsonString);
		switch (value)
		{
		case ::vl::presentation::remoteprotocol::RendererType::FocusRectangle: node->content.value = WString::Unmanaged(L"FocusRectangle"); break;
		case ::vl::presentation::remoteprotocol::RendererType::SolidBorder: node->content.value = WString::Unmanaged(L"SolidBorder"); break;
		case ::vl::presentation::remoteprotocol::RendererType::SinkBorder: node->content.value = WString::Unmanaged(L"SinkBorder"); break;
		case ::vl::presentation::remoteprotocol::RendererType::SinkSplitter: node->content.value = WString::Unmanaged(L"SinkSplitter"); break;
		case ::vl::presentation::remoteprotocol::RendererType::SolidBackground: node->content.value = WString::Unmanaged(L"SolidBackground"); break;
		case ::vl::presentation::remoteprotocol::RendererType::GradientBackground: node->content.value = WString::Unmanaged(L"GradientBackground"); break;
		case ::vl::presentation::remoteprotocol::RendererType::InnerShadow: node->content.value = WString::Unmanaged(L"InnerShadow"); break;
		case ::vl::presentation::remoteprotocol::RendererType::SolidLabel: node->content.value = WString::Unmanaged(L"SolidLabel"); break;
		case ::vl::presentation::remoteprotocol::RendererType::Polygon: node->content.value = WString::Unmanaged(L"Polygon"); break;
		case ::vl::presentation::remoteprotocol::RendererType::ImageFrame: node->content.value = WString::Unmanaged(L"ImageFrame"); break;
		case ::vl::presentation::remoteprotocol::RendererType::UnsupportedColorizedText: node->content.value = WString::Unmanaged(L"UnsupportedColorizedText"); break;
		case ::vl::presentation::remoteprotocol::RendererType::UnsupportedDocument: node->content.value = WString::Unmanaged(L"UnsupportedDocument"); break;
		default: CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
		}
		return node;
#undef ERROR_MESSAGE_PREFIX
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeCoordinate>(const ::vl::presentation::NativeCoordinate & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"value", value.value);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativePoint>(const ::vl::presentation::NativePoint & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"x", value.x);
		ConvertCustomTypeToJsonField(node, L"y", value.y);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeSize>(const ::vl::presentation::NativeSize & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"x", value.x);
		ConvertCustomTypeToJsonField(node, L"y", value.y);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeRect>(const ::vl::presentation::NativeRect & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"x1", value.x1);
		ConvertCustomTypeToJsonField(node, L"y1", value.y1);
		ConvertCustomTypeToJsonField(node, L"x2", value.x2);
		ConvertCustomTypeToJsonField(node, L"y2", value.y2);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeMargin>(const ::vl::presentation::NativeMargin & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"left", value.left);
		ConvertCustomTypeToJsonField(node, L"top", value.top);
		ConvertCustomTypeToJsonField(node, L"right", value.right);
		ConvertCustomTypeToJsonField(node, L"bottom", value.bottom);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::Point>(const ::vl::presentation::Point & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"x", value.x);
		ConvertCustomTypeToJsonField(node, L"y", value.y);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::Size>(const ::vl::presentation::Size & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"x", value.x);
		ConvertCustomTypeToJsonField(node, L"y", value.y);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::Rect>(const ::vl::presentation::Rect & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"x1", value.x1);
		ConvertCustomTypeToJsonField(node, L"y1", value.y1);
		ConvertCustomTypeToJsonField(node, L"x2", value.x2);
		ConvertCustomTypeToJsonField(node, L"y2", value.y2);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::FontProperties>(const ::vl::presentation::FontProperties & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"fontFamily", value.fontFamily);
		ConvertCustomTypeToJsonField(node, L"size", value.size);
		ConvertCustomTypeToJsonField(node, L"bold", value.bold);
		ConvertCustomTypeToJsonField(node, L"italic", value.italic);
		ConvertCustomTypeToJsonField(node, L"underline", value.underline);
		ConvertCustomTypeToJsonField(node, L"strikeline", value.strikeline);
		ConvertCustomTypeToJsonField(node, L"antialias", value.antialias);
		ConvertCustomTypeToJsonField(node, L"verticalAntialias", value.verticalAntialias);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::FontConfig>(const ::vl::presentation::remoteprotocol::FontConfig & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"defaultFont", value.defaultFont);
		ConvertCustomTypeToJsonField(node, L"supportedFonts", value.supportedFonts);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ScreenConfig>(const ::vl::presentation::remoteprotocol::ScreenConfig & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"bounds", value.bounds);
		ConvertCustomTypeToJsonField(node, L"clientBounds", value.clientBounds);
		ConvertCustomTypeToJsonField(node, L"scalingX", value.scalingX);
		ConvertCustomTypeToJsonField(node, L"scalingY", value.scalingY);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::WindowSizingConfig>(const ::vl::presentation::remoteprotocol::WindowSizingConfig & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"bounds", value.bounds);
		ConvertCustomTypeToJsonField(node, L"clientBounds", value.clientBounds);
		ConvertCustomTypeToJsonField(node, L"sizeState", value.sizeState);
		ConvertCustomTypeToJsonField(node, L"customFramePadding", value.customFramePadding);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::WindowShowing>(const ::vl::presentation::remoteprotocol::WindowShowing & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"activate", value.activate);
		ConvertCustomTypeToJsonField(node, L"sizeState", value.sizeState);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeWindowMouseInfo>(const ::vl::presentation::NativeWindowMouseInfo & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"ctrl", value.ctrl);
		ConvertCustomTypeToJsonField(node, L"shift", value.shift);
		ConvertCustomTypeToJsonField(node, L"left", value.left);
		ConvertCustomTypeToJsonField(node, L"middle", value.middle);
		ConvertCustomTypeToJsonField(node, L"right", value.right);
		ConvertCustomTypeToJsonField(node, L"x", value.x);
		ConvertCustomTypeToJsonField(node, L"y", value.y);
		ConvertCustomTypeToJsonField(node, L"wheel", value.wheel);
		ConvertCustomTypeToJsonField(node, L"nonClient", value.nonClient);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::IOMouseInfoWithButton>(const ::vl::presentation::remoteprotocol::IOMouseInfoWithButton & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"button", value.button);
		ConvertCustomTypeToJsonField(node, L"info", value.info);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeWindowKeyInfo>(const ::vl::presentation::NativeWindowKeyInfo & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"code", value.code);
		ConvertCustomTypeToJsonField(node, L"ctrl", value.ctrl);
		ConvertCustomTypeToJsonField(node, L"shift", value.shift);
		ConvertCustomTypeToJsonField(node, L"alt", value.alt);
		ConvertCustomTypeToJsonField(node, L"capslock", value.capslock);
		ConvertCustomTypeToJsonField(node, L"autoRepeatKeyDown", value.autoRepeatKeyDown);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::NativeWindowCharInfo>(const ::vl::presentation::NativeWindowCharInfo & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"code", value.code);
		ConvertCustomTypeToJsonField(node, L"ctrl", value.ctrl);
		ConvertCustomTypeToJsonField(node, L"shift", value.shift);
		ConvertCustomTypeToJsonField(node, L"alt", value.alt);
		ConvertCustomTypeToJsonField(node, L"capslock", value.capslock);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::GlobalShortcutKey>(const ::vl::presentation::remoteprotocol::GlobalShortcutKey & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"ctrl", value.ctrl);
		ConvertCustomTypeToJsonField(node, L"shift", value.shift);
		ConvertCustomTypeToJsonField(node, L"alt", value.alt);
		ConvertCustomTypeToJsonField(node, L"code", value.code);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::elements::ElementShape>(const ::vl::presentation::elements::ElementShape & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"shapeType", value.shapeType);
		ConvertCustomTypeToJsonField(node, L"radiusX", value.radiusX);
		ConvertCustomTypeToJsonField(node, L"radiusY", value.radiusY);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SolidBorder>(const ::vl::presentation::remoteprotocol::ElementDesc_SolidBorder & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"borderColor", value.borderColor);
		ConvertCustomTypeToJsonField(node, L"shape", value.shape);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SinkBorder>(const ::vl::presentation::remoteprotocol::ElementDesc_SinkBorder & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"leftTopColor", value.leftTopColor);
		ConvertCustomTypeToJsonField(node, L"rightBottomColor", value.rightBottomColor);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter>(const ::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"leftTopColor", value.leftTopColor);
		ConvertCustomTypeToJsonField(node, L"rightBottomColor", value.rightBottomColor);
		ConvertCustomTypeToJsonField(node, L"direction", value.direction);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SolidBackground>(const ::vl::presentation::remoteprotocol::ElementDesc_SolidBackground & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"backgroundColor", value.backgroundColor);
		ConvertCustomTypeToJsonField(node, L"shape", value.shape);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_GradientBackground>(const ::vl::presentation::remoteprotocol::ElementDesc_GradientBackground & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"leftTopColor", value.leftTopColor);
		ConvertCustomTypeToJsonField(node, L"rightBottomColor", value.rightBottomColor);
		ConvertCustomTypeToJsonField(node, L"direction", value.direction);
		ConvertCustomTypeToJsonField(node, L"shape", value.shape);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_InnerShadow>(const ::vl::presentation::remoteprotocol::ElementDesc_InnerShadow & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"shadowColor", value.shadowColor);
		ConvertCustomTypeToJsonField(node, L"thickness", value.thickness);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_Polygon>(const ::vl::presentation::remoteprotocol::ElementDesc_Polygon & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"size", value.size);
		ConvertCustomTypeToJsonField(node, L"borderColor", value.borderColor);
		ConvertCustomTypeToJsonField(node, L"backgroundColor", value.backgroundColor);
		ConvertCustomTypeToJsonField(node, L"points", value.points);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_SolidLabel>(const ::vl::presentation::remoteprotocol::ElementDesc_SolidLabel & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"textColor", value.textColor);
		ConvertCustomTypeToJsonField(node, L"horizontalAlignment", value.horizontalAlignment);
		ConvertCustomTypeToJsonField(node, L"verticalAlignment", value.verticalAlignment);
		ConvertCustomTypeToJsonField(node, L"wrapLine", value.wrapLine);
		ConvertCustomTypeToJsonField(node, L"wrapLineHeightCalculation", value.wrapLineHeightCalculation);
		ConvertCustomTypeToJsonField(node, L"ellipse", value.ellipse);
		ConvertCustomTypeToJsonField(node, L"multiline", value.multiline);
		ConvertCustomTypeToJsonField(node, L"font", value.font);
		ConvertCustomTypeToJsonField(node, L"text", value.text);
		ConvertCustomTypeToJsonField(node, L"measuringRequest", value.measuringRequest);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ImageCreation>(const ::vl::presentation::remoteprotocol::ImageCreation & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"imageData", value.imageData);
		ConvertCustomTypeToJsonField(node, L"imageDataOmitted", value.imageDataOmitted);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ImageFrameMetadata>(const ::vl::presentation::remoteprotocol::ImageFrameMetadata & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"size", value.size);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ImageMetadata>(const ::vl::presentation::remoteprotocol::ImageMetadata & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"format", value.format);
		ConvertCustomTypeToJsonField(node, L"frames", value.frames);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementDesc_ImageFrame>(const ::vl::presentation::remoteprotocol::ElementDesc_ImageFrame & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"imageId", value.imageId);
		ConvertCustomTypeToJsonField(node, L"imageFrame", value.imageFrame);
		ConvertCustomTypeToJsonField(node, L"horizontalAlignment", value.horizontalAlignment);
		ConvertCustomTypeToJsonField(node, L"verticalAlignment", value.verticalAlignment);
		ConvertCustomTypeToJsonField(node, L"stretch", value.stretch);
		ConvertCustomTypeToJsonField(node, L"enabled", value.enabled);
		ConvertCustomTypeToJsonField(node, L"imageCreation", value.imageCreation);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RendererCreation>(const ::vl::presentation::remoteprotocol::RendererCreation & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"type", value.type);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementBeginRendering>(const ::vl::presentation::remoteprotocol::ElementBeginRendering & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"frameId", value.frameId);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementRendering>(const ::vl::presentation::remoteprotocol::ElementRendering & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"bounds", value.bounds);
		ConvertCustomTypeToJsonField(node, L"areaClippedByParent", value.areaClippedByParent);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementBoundary>(const ::vl::presentation::remoteprotocol::ElementBoundary & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"hitTestResult", value.hitTestResult);
		ConvertCustomTypeToJsonField(node, L"cursor", value.cursor);
		ConvertCustomTypeToJsonField(node, L"bounds", value.bounds);
		ConvertCustomTypeToJsonField(node, L"areaClippedBySelf", value.areaClippedBySelf);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight>(const ::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"fontFamily", value.fontFamily);
		ConvertCustomTypeToJsonField(node, L"fontSize", value.fontSize);
		ConvertCustomTypeToJsonField(node, L"height", value.height);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize>(const ::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"id", value.id);
		ConvertCustomTypeToJsonField(node, L"minSize", value.minSize);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::ElementMeasurings>(const ::vl::presentation::remoteprotocol::ElementMeasurings & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"fontHeights", value.fontHeights);
		ConvertCustomTypeToJsonField(node, L"minSizes", value.minSizes);
		ConvertCustomTypeToJsonField(node, L"createdImages", value.createdImages);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingDom>(const ::vl::presentation::remoteprotocol::RenderingDom & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"hitTestResult", value.hitTestResult);
		ConvertCustomTypeToJsonField(node, L"cursor", value.cursor);
		ConvertCustomTypeToJsonField(node, L"element", value.element);
		ConvertCustomTypeToJsonField(node, L"bounds", value.bounds);
		ConvertCustomTypeToJsonField(node, L"validArea", value.validArea);
		ConvertCustomTypeToJsonField(node, L"children", value.children);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary>(const ::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"boundary", value.boundary);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary>(const ::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingCommand_Element>(const ::vl::presentation::remoteprotocol::RenderingCommand_Element & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"rendering", value.rendering);
		ConvertCustomTypeToJsonField(node, L"element", value.element);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingFrame>(const ::vl::presentation::remoteprotocol::RenderingFrame & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"frameId", value.frameId);
		ConvertCustomTypeToJsonField(node, L"frameName", value.frameName);
		ConvertCustomTypeToJsonField(node, L"windowSize", value.windowSize);
		ConvertCustomTypeToJsonField(node, L"elements", value.elements);
		ConvertCustomTypeToJsonField(node, L"commands", value.commands);
		ConvertCustomTypeToJsonField(node, L"root", value.root);
		return node;
	}

	template<> vl::Ptr<vl::glr::json::JsonNode> ConvertCustomTypeToJson<::vl::presentation::remoteprotocol::RenderingTrace>(const ::vl::presentation::remoteprotocol::RenderingTrace & value)
	{
		auto node = Ptr(new glr::json::JsonObject);
		ConvertCustomTypeToJsonField(node, L"createdElements", value.createdElements);
		ConvertCustomTypeToJsonField(node, L"imageCreations", value.imageCreations);
		ConvertCustomTypeToJsonField(node, L"imageMetadatas", value.imageMetadatas);
		ConvertCustomTypeToJsonField(node, L"frames", value.frames);
		return node;
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::INativeWindowListener::HitTestResult>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeWindowListener::HitTestResult& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::INativeWindowListener::HitTestResult>(Ptr<JsonNode>, ::vl::presentation::INativeWindowListener::HitTestResult&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"BorderNoSizing") value = ::vl::presentation::INativeWindowListener::BorderNoSizing; else
		if (jsonNode->content.value == L"BorderLeft") value = ::vl::presentation::INativeWindowListener::BorderLeft; else
		if (jsonNode->content.value == L"BorderRight") value = ::vl::presentation::INativeWindowListener::BorderRight; else
		if (jsonNode->content.value == L"BorderTop") value = ::vl::presentation::INativeWindowListener::BorderTop; else
		if (jsonNode->content.value == L"BorderBottom") value = ::vl::presentation::INativeWindowListener::BorderBottom; else
		if (jsonNode->content.value == L"BorderLeftTop") value = ::vl::presentation::INativeWindowListener::BorderLeftTop; else
		if (jsonNode->content.value == L"BorderRightTop") value = ::vl::presentation::INativeWindowListener::BorderRightTop; else
		if (jsonNode->content.value == L"BorderLeftBottom") value = ::vl::presentation::INativeWindowListener::BorderLeftBottom; else
		if (jsonNode->content.value == L"BorderRightBottom") value = ::vl::presentation::INativeWindowListener::BorderRightBottom; else
		if (jsonNode->content.value == L"Title") value = ::vl::presentation::INativeWindowListener::Title; else
		if (jsonNode->content.value == L"ButtonMinimum") value = ::vl::presentation::INativeWindowListener::ButtonMinimum; else
		if (jsonNode->content.value == L"ButtonMaximum") value = ::vl::presentation::INativeWindowListener::ButtonMaximum; else
		if (jsonNode->content.value == L"ButtonClose") value = ::vl::presentation::INativeWindowListener::ButtonClose; else
		if (jsonNode->content.value == L"Client") value = ::vl::presentation::INativeWindowListener::Client; else
		if (jsonNode->content.value == L"Icon") value = ::vl::presentation::INativeWindowListener::Icon; else
		if (jsonNode->content.value == L"NoDecision") value = ::vl::presentation::INativeWindowListener::NoDecision; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::INativeCursor::SystemCursorType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeCursor::SystemCursorType& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::INativeCursor::SystemCursorType>(Ptr<JsonNode>, ::vl::presentation::INativeCursor::SystemCursorType&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"SmallWaiting") value = ::vl::presentation::INativeCursor::SmallWaiting; else
		if (jsonNode->content.value == L"LargeWaiting") value = ::vl::presentation::INativeCursor::LargeWaiting; else
		if (jsonNode->content.value == L"Arrow") value = ::vl::presentation::INativeCursor::Arrow; else
		if (jsonNode->content.value == L"Cross") value = ::vl::presentation::INativeCursor::Cross; else
		if (jsonNode->content.value == L"Hand") value = ::vl::presentation::INativeCursor::Hand; else
		if (jsonNode->content.value == L"Help") value = ::vl::presentation::INativeCursor::Help; else
		if (jsonNode->content.value == L"IBeam") value = ::vl::presentation::INativeCursor::IBeam; else
		if (jsonNode->content.value == L"SizeAll") value = ::vl::presentation::INativeCursor::SizeAll; else
		if (jsonNode->content.value == L"SizeNESW") value = ::vl::presentation::INativeCursor::SizeNESW; else
		if (jsonNode->content.value == L"SizeNS") value = ::vl::presentation::INativeCursor::SizeNS; else
		if (jsonNode->content.value == L"SizeNWSE") value = ::vl::presentation::INativeCursor::SizeNWSE; else
		if (jsonNode->content.value == L"SizeWE") value = ::vl::presentation::INativeCursor::SizeWE; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::INativeWindow::WindowSizeState>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeWindow::WindowSizeState& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::INativeWindow::WindowSizeState>(Ptr<JsonNode>, ::vl::presentation::INativeWindow::WindowSizeState&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Minimized") value = ::vl::presentation::INativeWindow::WindowSizeState::Minimized; else
		if (jsonNode->content.value == L"Restored") value = ::vl::presentation::INativeWindow::WindowSizeState::Restored; else
		if (jsonNode->content.value == L"Maximized") value = ::vl::presentation::INativeWindow::WindowSizeState::Maximized; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::IOMouseButton>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::IOMouseButton& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::IOMouseButton>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::IOMouseButton&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Left") value = ::vl::presentation::remoteprotocol::IOMouseButton::Left; else
		if (jsonNode->content.value == L"Middle") value = ::vl::presentation::remoteprotocol::IOMouseButton::Middle; else
		if (jsonNode->content.value == L"Right") value = ::vl::presentation::remoteprotocol::IOMouseButton::Right; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::elements::ElementShapeType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::ElementShapeType& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::elements::ElementShapeType>(Ptr<JsonNode>, ::vl::presentation::elements::ElementShapeType&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Rectangle") value = ::vl::presentation::elements::ElementShapeType::Rectangle; else
		if (jsonNode->content.value == L"Ellipse") value = ::vl::presentation::elements::ElementShapeType::Ellipse; else
		if (jsonNode->content.value == L"RoundRect") value = ::vl::presentation::elements::ElementShapeType::RoundRect; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::elements::GuiGradientBackgroundElement::Direction>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::GuiGradientBackgroundElement::Direction& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::elements::GuiGradientBackgroundElement::Direction>(Ptr<JsonNode>, ::vl::presentation::elements::GuiGradientBackgroundElement::Direction&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Horizontal") value = ::vl::presentation::elements::GuiGradientBackgroundElement::Horizontal; else
		if (jsonNode->content.value == L"Vertical") value = ::vl::presentation::elements::GuiGradientBackgroundElement::Vertical; else
		if (jsonNode->content.value == L"Slash") value = ::vl::presentation::elements::GuiGradientBackgroundElement::Slash; else
		if (jsonNode->content.value == L"Backslash") value = ::vl::presentation::elements::GuiGradientBackgroundElement::Backslash; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::elements::Gui3DSplitterElement::Direction>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::Gui3DSplitterElement::Direction& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::elements::Gui3DSplitterElement::Direction>(Ptr<JsonNode>, ::vl::presentation::elements::Gui3DSplitterElement::Direction&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Horizontal") value = ::vl::presentation::elements::Gui3DSplitterElement::Horizontal; else
		if (jsonNode->content.value == L"Vertical") value = ::vl::presentation::elements::Gui3DSplitterElement::Vertical; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementHorizontalAlignment>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementHorizontalAlignment& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementHorizontalAlignment>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementHorizontalAlignment&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Left") value = ::vl::presentation::remoteprotocol::ElementHorizontalAlignment::Left; else
		if (jsonNode->content.value == L"Right") value = ::vl::presentation::remoteprotocol::ElementHorizontalAlignment::Right; else
		if (jsonNode->content.value == L"Center") value = ::vl::presentation::remoteprotocol::ElementHorizontalAlignment::Center; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementVerticalAlignment>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementVerticalAlignment& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementVerticalAlignment>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementVerticalAlignment&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Top") value = ::vl::presentation::remoteprotocol::ElementVerticalAlignment::Top; else
		if (jsonNode->content.value == L"Bottom") value = ::vl::presentation::remoteprotocol::ElementVerticalAlignment::Bottom; else
		if (jsonNode->content.value == L"Center") value = ::vl::presentation::remoteprotocol::ElementVerticalAlignment::Center; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"FontHeight") value = ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest::FontHeight; else
		if (jsonNode->content.value == L"TotalSize") value = ::vl::presentation::remoteprotocol::ElementSolidLabelMeasuringRequest::TotalSize; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::INativeImage::FormatType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::INativeImage::FormatType& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::INativeImage::FormatType>(Ptr<JsonNode>, ::vl::presentation::INativeImage::FormatType&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"Bmp") value = ::vl::presentation::INativeImage::Bmp; else
		if (jsonNode->content.value == L"Gif") value = ::vl::presentation::INativeImage::Gif; else
		if (jsonNode->content.value == L"Icon") value = ::vl::presentation::INativeImage::Icon; else
		if (jsonNode->content.value == L"Jpeg") value = ::vl::presentation::INativeImage::Jpeg; else
		if (jsonNode->content.value == L"Png") value = ::vl::presentation::INativeImage::Png; else
		if (jsonNode->content.value == L"Tiff") value = ::vl::presentation::INativeImage::Tiff; else
		if (jsonNode->content.value == L"Wmp") value = ::vl::presentation::INativeImage::Wmp; else
		if (jsonNode->content.value == L"Unknown") value = ::vl::presentation::INativeImage::Unknown; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RendererType>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RendererType& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RendererType>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RendererType&)#"
		auto jsonNode = node.Cast<glr::json::JsonString>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		if (jsonNode->content.value == L"FocusRectangle") value = ::vl::presentation::remoteprotocol::RendererType::FocusRectangle; else
		if (jsonNode->content.value == L"SolidBorder") value = ::vl::presentation::remoteprotocol::RendererType::SolidBorder; else
		if (jsonNode->content.value == L"SinkBorder") value = ::vl::presentation::remoteprotocol::RendererType::SinkBorder; else
		if (jsonNode->content.value == L"SinkSplitter") value = ::vl::presentation::remoteprotocol::RendererType::SinkSplitter; else
		if (jsonNode->content.value == L"SolidBackground") value = ::vl::presentation::remoteprotocol::RendererType::SolidBackground; else
		if (jsonNode->content.value == L"GradientBackground") value = ::vl::presentation::remoteprotocol::RendererType::GradientBackground; else
		if (jsonNode->content.value == L"InnerShadow") value = ::vl::presentation::remoteprotocol::RendererType::InnerShadow; else
		if (jsonNode->content.value == L"SolidLabel") value = ::vl::presentation::remoteprotocol::RendererType::SolidLabel; else
		if (jsonNode->content.value == L"Polygon") value = ::vl::presentation::remoteprotocol::RendererType::Polygon; else
		if (jsonNode->content.value == L"ImageFrame") value = ::vl::presentation::remoteprotocol::RendererType::ImageFrame; else
		if (jsonNode->content.value == L"UnsupportedColorizedText") value = ::vl::presentation::remoteprotocol::RendererType::UnsupportedColorizedText; else
		if (jsonNode->content.value == L"UnsupportedDocument") value = ::vl::presentation::remoteprotocol::RendererType::UnsupportedDocument; else
		CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported enum value.");
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativeCoordinate>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeCoordinate& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativeCoordinate>(Ptr<JsonNode>, ::vl::presentation::NativeCoordinate&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"value") ConvertJsonToCustomType(field->value, value.value); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativePoint>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativePoint& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativePoint>(Ptr<JsonNode>, ::vl::presentation::NativePoint&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"x") ConvertJsonToCustomType(field->value, value.x); else
			if (field->name.value == L"y") ConvertJsonToCustomType(field->value, value.y); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativeSize>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeSize& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativeSize>(Ptr<JsonNode>, ::vl::presentation::NativeSize&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"x") ConvertJsonToCustomType(field->value, value.x); else
			if (field->name.value == L"y") ConvertJsonToCustomType(field->value, value.y); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativeRect>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeRect& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativeRect>(Ptr<JsonNode>, ::vl::presentation::NativeRect&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"x1") ConvertJsonToCustomType(field->value, value.x1); else
			if (field->name.value == L"y1") ConvertJsonToCustomType(field->value, value.y1); else
			if (field->name.value == L"x2") ConvertJsonToCustomType(field->value, value.x2); else
			if (field->name.value == L"y2") ConvertJsonToCustomType(field->value, value.y2); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativeMargin>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeMargin& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativeMargin>(Ptr<JsonNode>, ::vl::presentation::NativeMargin&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"left") ConvertJsonToCustomType(field->value, value.left); else
			if (field->name.value == L"top") ConvertJsonToCustomType(field->value, value.top); else
			if (field->name.value == L"right") ConvertJsonToCustomType(field->value, value.right); else
			if (field->name.value == L"bottom") ConvertJsonToCustomType(field->value, value.bottom); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::Point>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::Point& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::Point>(Ptr<JsonNode>, ::vl::presentation::Point&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"x") ConvertJsonToCustomType(field->value, value.x); else
			if (field->name.value == L"y") ConvertJsonToCustomType(field->value, value.y); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::Size>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::Size& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::Size>(Ptr<JsonNode>, ::vl::presentation::Size&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"x") ConvertJsonToCustomType(field->value, value.x); else
			if (field->name.value == L"y") ConvertJsonToCustomType(field->value, value.y); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::Rect>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::Rect& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::Rect>(Ptr<JsonNode>, ::vl::presentation::Rect&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"x1") ConvertJsonToCustomType(field->value, value.x1); else
			if (field->name.value == L"y1") ConvertJsonToCustomType(field->value, value.y1); else
			if (field->name.value == L"x2") ConvertJsonToCustomType(field->value, value.x2); else
			if (field->name.value == L"y2") ConvertJsonToCustomType(field->value, value.y2); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::FontProperties>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::FontProperties& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::FontProperties>(Ptr<JsonNode>, ::vl::presentation::FontProperties&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"fontFamily") ConvertJsonToCustomType(field->value, value.fontFamily); else
			if (field->name.value == L"size") ConvertJsonToCustomType(field->value, value.size); else
			if (field->name.value == L"bold") ConvertJsonToCustomType(field->value, value.bold); else
			if (field->name.value == L"italic") ConvertJsonToCustomType(field->value, value.italic); else
			if (field->name.value == L"underline") ConvertJsonToCustomType(field->value, value.underline); else
			if (field->name.value == L"strikeline") ConvertJsonToCustomType(field->value, value.strikeline); else
			if (field->name.value == L"antialias") ConvertJsonToCustomType(field->value, value.antialias); else
			if (field->name.value == L"verticalAntialias") ConvertJsonToCustomType(field->value, value.verticalAntialias); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::FontConfig>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::FontConfig& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::FontConfig>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::FontConfig&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"defaultFont") ConvertJsonToCustomType(field->value, value.defaultFont); else
			if (field->name.value == L"supportedFonts") ConvertJsonToCustomType(field->value, value.supportedFonts); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ScreenConfig>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ScreenConfig& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ScreenConfig>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ScreenConfig&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"bounds") ConvertJsonToCustomType(field->value, value.bounds); else
			if (field->name.value == L"clientBounds") ConvertJsonToCustomType(field->value, value.clientBounds); else
			if (field->name.value == L"scalingX") ConvertJsonToCustomType(field->value, value.scalingX); else
			if (field->name.value == L"scalingY") ConvertJsonToCustomType(field->value, value.scalingY); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::WindowSizingConfig>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::WindowSizingConfig& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::WindowSizingConfig>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::WindowSizingConfig&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"bounds") ConvertJsonToCustomType(field->value, value.bounds); else
			if (field->name.value == L"clientBounds") ConvertJsonToCustomType(field->value, value.clientBounds); else
			if (field->name.value == L"sizeState") ConvertJsonToCustomType(field->value, value.sizeState); else
			if (field->name.value == L"customFramePadding") ConvertJsonToCustomType(field->value, value.customFramePadding); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::WindowShowing>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::WindowShowing& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::WindowShowing>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::WindowShowing&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"activate") ConvertJsonToCustomType(field->value, value.activate); else
			if (field->name.value == L"sizeState") ConvertJsonToCustomType(field->value, value.sizeState); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativeWindowMouseInfo>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeWindowMouseInfo& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativeWindowMouseInfo>(Ptr<JsonNode>, ::vl::presentation::NativeWindowMouseInfo&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"ctrl") ConvertJsonToCustomType(field->value, value.ctrl); else
			if (field->name.value == L"shift") ConvertJsonToCustomType(field->value, value.shift); else
			if (field->name.value == L"left") ConvertJsonToCustomType(field->value, value.left); else
			if (field->name.value == L"middle") ConvertJsonToCustomType(field->value, value.middle); else
			if (field->name.value == L"right") ConvertJsonToCustomType(field->value, value.right); else
			if (field->name.value == L"x") ConvertJsonToCustomType(field->value, value.x); else
			if (field->name.value == L"y") ConvertJsonToCustomType(field->value, value.y); else
			if (field->name.value == L"wheel") ConvertJsonToCustomType(field->value, value.wheel); else
			if (field->name.value == L"nonClient") ConvertJsonToCustomType(field->value, value.nonClient); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::IOMouseInfoWithButton>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::IOMouseInfoWithButton& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::IOMouseInfoWithButton>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::IOMouseInfoWithButton&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"button") ConvertJsonToCustomType(field->value, value.button); else
			if (field->name.value == L"info") ConvertJsonToCustomType(field->value, value.info); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativeWindowKeyInfo>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeWindowKeyInfo& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativeWindowKeyInfo>(Ptr<JsonNode>, ::vl::presentation::NativeWindowKeyInfo&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"code") ConvertJsonToCustomType(field->value, value.code); else
			if (field->name.value == L"ctrl") ConvertJsonToCustomType(field->value, value.ctrl); else
			if (field->name.value == L"shift") ConvertJsonToCustomType(field->value, value.shift); else
			if (field->name.value == L"alt") ConvertJsonToCustomType(field->value, value.alt); else
			if (field->name.value == L"capslock") ConvertJsonToCustomType(field->value, value.capslock); else
			if (field->name.value == L"autoRepeatKeyDown") ConvertJsonToCustomType(field->value, value.autoRepeatKeyDown); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::NativeWindowCharInfo>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::NativeWindowCharInfo& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::NativeWindowCharInfo>(Ptr<JsonNode>, ::vl::presentation::NativeWindowCharInfo&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"code") ConvertJsonToCustomType(field->value, value.code); else
			if (field->name.value == L"ctrl") ConvertJsonToCustomType(field->value, value.ctrl); else
			if (field->name.value == L"shift") ConvertJsonToCustomType(field->value, value.shift); else
			if (field->name.value == L"alt") ConvertJsonToCustomType(field->value, value.alt); else
			if (field->name.value == L"capslock") ConvertJsonToCustomType(field->value, value.capslock); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::GlobalShortcutKey>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::GlobalShortcutKey& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::GlobalShortcutKey>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::GlobalShortcutKey&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"ctrl") ConvertJsonToCustomType(field->value, value.ctrl); else
			if (field->name.value == L"shift") ConvertJsonToCustomType(field->value, value.shift); else
			if (field->name.value == L"alt") ConvertJsonToCustomType(field->value, value.alt); else
			if (field->name.value == L"code") ConvertJsonToCustomType(field->value, value.code); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::elements::ElementShape>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::elements::ElementShape& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::elements::ElementShape>(Ptr<JsonNode>, ::vl::presentation::elements::ElementShape&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"shapeType") ConvertJsonToCustomType(field->value, value.shapeType); else
			if (field->name.value == L"radiusX") ConvertJsonToCustomType(field->value, value.radiusX); else
			if (field->name.value == L"radiusY") ConvertJsonToCustomType(field->value, value.radiusY); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidBorder>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SolidBorder& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidBorder>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_SolidBorder&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"borderColor") ConvertJsonToCustomType(field->value, value.borderColor); else
			if (field->name.value == L"shape") ConvertJsonToCustomType(field->value, value.shape); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SinkBorder>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SinkBorder& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SinkBorder>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_SinkBorder&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"leftTopColor") ConvertJsonToCustomType(field->value, value.leftTopColor); else
			if (field->name.value == L"rightBottomColor") ConvertJsonToCustomType(field->value, value.rightBottomColor); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_SinkSplitter&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"leftTopColor") ConvertJsonToCustomType(field->value, value.leftTopColor); else
			if (field->name.value == L"rightBottomColor") ConvertJsonToCustomType(field->value, value.rightBottomColor); else
			if (field->name.value == L"direction") ConvertJsonToCustomType(field->value, value.direction); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidBackground>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SolidBackground& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidBackground>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_SolidBackground&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"backgroundColor") ConvertJsonToCustomType(field->value, value.backgroundColor); else
			if (field->name.value == L"shape") ConvertJsonToCustomType(field->value, value.shape); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_GradientBackground>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_GradientBackground& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_GradientBackground>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_GradientBackground&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"leftTopColor") ConvertJsonToCustomType(field->value, value.leftTopColor); else
			if (field->name.value == L"rightBottomColor") ConvertJsonToCustomType(field->value, value.rightBottomColor); else
			if (field->name.value == L"direction") ConvertJsonToCustomType(field->value, value.direction); else
			if (field->name.value == L"shape") ConvertJsonToCustomType(field->value, value.shape); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_InnerShadow>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_InnerShadow& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_InnerShadow>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_InnerShadow&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"shadowColor") ConvertJsonToCustomType(field->value, value.shadowColor); else
			if (field->name.value == L"thickness") ConvertJsonToCustomType(field->value, value.thickness); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_Polygon>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_Polygon& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_Polygon>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_Polygon&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"size") ConvertJsonToCustomType(field->value, value.size); else
			if (field->name.value == L"borderColor") ConvertJsonToCustomType(field->value, value.borderColor); else
			if (field->name.value == L"backgroundColor") ConvertJsonToCustomType(field->value, value.backgroundColor); else
			if (field->name.value == L"points") ConvertJsonToCustomType(field->value, value.points); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidLabel>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_SolidLabel& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_SolidLabel>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_SolidLabel&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"textColor") ConvertJsonToCustomType(field->value, value.textColor); else
			if (field->name.value == L"horizontalAlignment") ConvertJsonToCustomType(field->value, value.horizontalAlignment); else
			if (field->name.value == L"verticalAlignment") ConvertJsonToCustomType(field->value, value.verticalAlignment); else
			if (field->name.value == L"wrapLine") ConvertJsonToCustomType(field->value, value.wrapLine); else
			if (field->name.value == L"wrapLineHeightCalculation") ConvertJsonToCustomType(field->value, value.wrapLineHeightCalculation); else
			if (field->name.value == L"ellipse") ConvertJsonToCustomType(field->value, value.ellipse); else
			if (field->name.value == L"multiline") ConvertJsonToCustomType(field->value, value.multiline); else
			if (field->name.value == L"font") ConvertJsonToCustomType(field->value, value.font); else
			if (field->name.value == L"text") ConvertJsonToCustomType(field->value, value.text); else
			if (field->name.value == L"measuringRequest") ConvertJsonToCustomType(field->value, value.measuringRequest); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageCreation>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ImageCreation& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageCreation>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ImageCreation&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"imageData") ConvertJsonToCustomType(field->value, value.imageData); else
			if (field->name.value == L"imageDataOmitted") ConvertJsonToCustomType(field->value, value.imageDataOmitted); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageFrameMetadata>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ImageFrameMetadata& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageFrameMetadata>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ImageFrameMetadata&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"size") ConvertJsonToCustomType(field->value, value.size); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageMetadata>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ImageMetadata& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ImageMetadata>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ImageMetadata&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"format") ConvertJsonToCustomType(field->value, value.format); else
			if (field->name.value == L"frames") ConvertJsonToCustomType(field->value, value.frames); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_ImageFrame>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementDesc_ImageFrame& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementDesc_ImageFrame>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementDesc_ImageFrame&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"imageId") ConvertJsonToCustomType(field->value, value.imageId); else
			if (field->name.value == L"imageFrame") ConvertJsonToCustomType(field->value, value.imageFrame); else
			if (field->name.value == L"horizontalAlignment") ConvertJsonToCustomType(field->value, value.horizontalAlignment); else
			if (field->name.value == L"verticalAlignment") ConvertJsonToCustomType(field->value, value.verticalAlignment); else
			if (field->name.value == L"stretch") ConvertJsonToCustomType(field->value, value.stretch); else
			if (field->name.value == L"enabled") ConvertJsonToCustomType(field->value, value.enabled); else
			if (field->name.value == L"imageCreation") ConvertJsonToCustomType(field->value, value.imageCreation); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RendererCreation>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RendererCreation& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RendererCreation>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RendererCreation&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"type") ConvertJsonToCustomType(field->value, value.type); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementBeginRendering>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementBeginRendering& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementBeginRendering>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementBeginRendering&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"frameId") ConvertJsonToCustomType(field->value, value.frameId); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementRendering>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementRendering& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementRendering>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementRendering&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"bounds") ConvertJsonToCustomType(field->value, value.bounds); else
			if (field->name.value == L"areaClippedByParent") ConvertJsonToCustomType(field->value, value.areaClippedByParent); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementBoundary>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementBoundary& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementBoundary>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementBoundary&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"hitTestResult") ConvertJsonToCustomType(field->value, value.hitTestResult); else
			if (field->name.value == L"cursor") ConvertJsonToCustomType(field->value, value.cursor); else
			if (field->name.value == L"bounds") ConvertJsonToCustomType(field->value, value.bounds); else
			if (field->name.value == L"areaClippedBySelf") ConvertJsonToCustomType(field->value, value.areaClippedBySelf); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementMeasuring_FontHeight&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"fontFamily") ConvertJsonToCustomType(field->value, value.fontFamily); else
			if (field->name.value == L"fontSize") ConvertJsonToCustomType(field->value, value.fontSize); else
			if (field->name.value == L"height") ConvertJsonToCustomType(field->value, value.height); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementMeasuring_ElementMinSize&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"id") ConvertJsonToCustomType(field->value, value.id); else
			if (field->name.value == L"minSize") ConvertJsonToCustomType(field->value, value.minSize); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasurings>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::ElementMeasurings& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::ElementMeasurings>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::ElementMeasurings&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"fontHeights") ConvertJsonToCustomType(field->value, value.fontHeights); else
			if (field->name.value == L"minSizes") ConvertJsonToCustomType(field->value, value.minSizes); else
			if (field->name.value == L"createdImages") ConvertJsonToCustomType(field->value, value.createdImages); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingDom>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingDom& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingDom>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RenderingDom&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"hitTestResult") ConvertJsonToCustomType(field->value, value.hitTestResult); else
			if (field->name.value == L"cursor") ConvertJsonToCustomType(field->value, value.cursor); else
			if (field->name.value == L"element") ConvertJsonToCustomType(field->value, value.element); else
			if (field->name.value == L"bounds") ConvertJsonToCustomType(field->value, value.bounds); else
			if (field->name.value == L"validArea") ConvertJsonToCustomType(field->value, value.validArea); else
			if (field->name.value == L"children") ConvertJsonToCustomType(field->value, value.children); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RenderingCommand_BeginBoundary&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"boundary") ConvertJsonToCustomType(field->value, value.boundary); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RenderingCommand_EndBoundary&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_Element>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingCommand_Element& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingCommand_Element>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RenderingCommand_Element&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"rendering") ConvertJsonToCustomType(field->value, value.rendering); else
			if (field->name.value == L"element") ConvertJsonToCustomType(field->value, value.element); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingFrame>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingFrame& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingFrame>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RenderingFrame&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"frameId") ConvertJsonToCustomType(field->value, value.frameId); else
			if (field->name.value == L"frameName") ConvertJsonToCustomType(field->value, value.frameName); else
			if (field->name.value == L"windowSize") ConvertJsonToCustomType(field->value, value.windowSize); else
			if (field->name.value == L"elements") ConvertJsonToCustomType(field->value, value.elements); else
			if (field->name.value == L"commands") ConvertJsonToCustomType(field->value, value.commands); else
			if (field->name.value == L"root") ConvertJsonToCustomType(field->value, value.root); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

	template<> void ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingTrace>(vl::Ptr<vl::glr::json::JsonNode> node, ::vl::presentation::remoteprotocol::RenderingTrace& value)
	{
#define ERROR_MESSAGE_PREFIX L"vl::presentation::remoteprotocol::ConvertJsonToCustomType<::vl::presentation::remoteprotocol::RenderingTrace>(Ptr<JsonNode>, ::vl::presentation::remoteprotocol::RenderingTrace&)#"
		auto jsonNode = node.Cast<glr::json::JsonObject>();
		CHECK_ERROR(jsonNode, ERROR_MESSAGE_PREFIX L"Json node does not match the expected type.");
		for (auto field : jsonNode->fields)
		{
			if (field->name.value == L"createdElements") ConvertJsonToCustomType(field->value, value.createdElements); else
			if (field->name.value == L"imageCreations") ConvertJsonToCustomType(field->value, value.imageCreations); else
			if (field->name.value == L"imageMetadatas") ConvertJsonToCustomType(field->value, value.imageMetadatas); else
			if (field->name.value == L"frames") ConvertJsonToCustomType(field->value, value.frames); else
			CHECK_FAIL(ERROR_MESSAGE_PREFIX L"Unsupported struct member.");
		}
#undef ERROR_MESSAGE_PREFIX
	}

}
