/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "Vlpp.h"

/***********************************************************************
WORKFLOWVLPPREFERENCES.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Koncept Language Vczh Library++ 3.0 References

Interfaces:
***********************************************************************/

#ifndef VCZH_SCRIPTING_WORKFLOW_WORKFLOWVLPPREFERENCES
#define VCZH_SCRIPTING_WORKFLOW_WORKFLOWVLPPREFERENCES


#endif

/***********************************************************************
EXPRESSION\WFEXPRESSIONPARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpressionParser

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER


namespace vl
{
	namespace workflow
	{
		enum class WfParserTokenIndex
		{
			EXP = 0,
			ADD = 1,
			SUB = 2,
			MUL = 3,
			DIV = 4,
			MOD = 5,
			CONCAT = 6,
			LE = 7,
			GE = 8,
			LT = 9,
			GT = 10,
			EQ = 11,
			NE = 12,
			ASSIGN = 13,
			FAILED_THEN = 14,
			QUESTION_MARK = 15,
			SCOPE_DELIMITER = 16,
			COLON = 17,
			SEMICOLON = 18,
			COMMA = 19,
			DOT = 20,
			OPEN_ARRAY = 21,
			CLOSE_ARRAY = 22,
			OPEN_BRACE = 23,
			CLOSE_BRACE = 24,
			OPEN_BRACKET = 25,
			CLOSE_BRACKET = 26,
			TYPE_VOID = 27,
			TYPE_OBJECT = 28,
			TYPE_INTERFACE = 29,
			TYPE_INT = 30,
			TYPE_UINT = 31,
			TYPE_FLOAT = 32,
			TYPE_DOUBLE = 33,
			TYPE_STRING = 34,
			TYPE_CHAR = 35,
			TYPE_BOOL = 36,
			KEYWORD_CONST = 37,
			KEYWORD_SHL = 38,
			KEYWORD_SHR = 39,
			KEYWORD_XOR = 40,
			KEYWORD_AND = 41,
			KEYWORD_OR = 42,
			KEYWORD_NOT = 43,
			KEYWORD_NULL = 44,
			KEYWORD_TRUE = 45,
			KEYWORD_FALSE = 46,
			KEYWORD_LET = 47,
			KEYWORD_IN = 48,
			KEYWORD_RANGE = 49,
			KEYWORD_NEW = 50,
			KEYWORD_OF = 51,
			KEYWORD_AS = 52,
			KEYWORD_IS = 53,
			KEYWORD_CAST = 54,
			KEYWORD_FUNC = 55,
			KEYWORD_TYPEOF = 56,
			KEYWORD_TYPE = 57,
			KEYWORD_BIND = 58,
			KEYWORD_OBSERVE = 59,
			KEYWORD_ON = 60,
			KEYWORD_ATTACH = 61,
			KEYWORD_DETACH = 62,
			KEYWORD_VAR = 63,
			KEYWORD_BREAK = 64,
			KEYWORD_CONTINUE = 65,
			KEYWORD_RETURN = 66,
			KEYWORD_DELETE = 67,
			KEYWORD_RAISE = 68,
			KEYWORD_IF = 69,
			KEYWORD_ELSE = 70,
			KEYWORD_SWITCH = 71,
			KEYWORD_CASE = 72,
			KEYWORD_DEFAULT = 73,
			KEYWORD_WHILE = 74,
			KEYWORD_FOR = 75,
			KEYWORD_REVERSED = 76,
			KEYWORD_TRY = 77,
			KEYWORD_CATCH = 78,
			KEYWORD_FINALLY = 79,
			KEYWORD_CLASS = 80,
			KEYWORD_PROP = 81,
			KEYWORD_EVENT = 82,
			KEYWORD_STATIC = 83,
			KEYWORD_USING = 84,
			KEYWORD_NAMESPACE = 85,
			KEYWORD_MODULE = 86,
			KEYWORD_UNIT = 87,
			NAME = 88,
			ORDERED_NAME = 89,
			FLOAT = 90,
			INTEGER = 91,
			STRING = 92,
			FORMATSTRING = 93,
			SPACE = 94,
		};
		class WfType;
		class WfPredefinedType;
		class WfTopQualifiedType;
		class WfReferenceType;
		class WfRawPointerType;
		class WfSharedPointerType;
		class WfNullableType;
		class WfEnumerableType;
		class WfMapType;
		class WfFunctionType;
		class WfChildType;
		class WfExpression;
		class WfTopQualifiedExpression;
		class WfReferenceExpression;
		class WfOrderedNameExpression;
		class WfOrderedLambdaExpression;
		class WfMemberExpression;
		class WfChildExpression;
		class WfLiteralExpression;
		class WfFloatingExpression;
		class WfIntegerExpression;
		class WfStringExpression;
		class WfFormatExpression;
		class WfUnaryExpression;
		class WfBinaryExpression;
		class WfLetVariable;
		class WfLetExpression;
		class WfIfExpression;
		class WfRangeExpression;
		class WfSetTestingExpression;
		class WfConstructorArgument;
		class WfConstructorExpression;
		class WfInferExpression;
		class WfTypeCastingExpression;
		class WfTypeTestingExpression;
		class WfTypeOfTypeExpression;
		class WfTypeOfExpressionExpression;
		class WfAttachEventExpression;
		class WfDetachEventExpression;
		class WfBindExpression;
		class WfObserveExpression;
		class WfCallExpression;
		class WfStatement;
		class WfBreakStatement;
		class WfContinueStatement;
		class WfReturnStatement;
		class WfDeleteStatement;
		class WfRaiseExceptionStatement;
		class WfIfStatement;
		class WfSwitchCase;
		class WfSwitchStatement;
		class WfWhileStatement;
		class WfForEachStatement;
		class WfTryStatement;
		class WfBlockStatement;
		class WfExpressionStatement;
		class WfDeclaration;
		class WfNamespaceDeclaration;
		class WfFunctionArgument;
		class WfFunctionDeclaration;
		class WfFunctionExpression;
		class WfVariableDeclaration;
		class WfVariableStatement;
		class WfNewTypeExpression;
		class WfClassMember;
		class WfEventDeclaration;
		class WfPropertyDeclaration;
		class WfClassDeclaration;
		class WfModuleUsingFragment;
		class WfModuleUsingNameFragment;
		class WfModuleUsingWildCardFragment;
		class WfModuleUsingItem;
		class WfModuleUsingPath;
		class WfModule;

		class WfType abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfType>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfPredefinedType* node)=0;
				virtual void Visit(WfTopQualifiedType* node)=0;
				virtual void Visit(WfReferenceType* node)=0;
				virtual void Visit(WfRawPointerType* node)=0;
				virtual void Visit(WfSharedPointerType* node)=0;
				virtual void Visit(WfNullableType* node)=0;
				virtual void Visit(WfEnumerableType* node)=0;
				virtual void Visit(WfMapType* node)=0;
				virtual void Visit(WfFunctionType* node)=0;
				virtual void Visit(WfChildType* node)=0;
			};

			virtual void Accept(WfType::IVisitor* visitor)=0;

		};

		enum class WfPredefinedTypeName
		{
			Void,
			Object,
			Interface,
			Int,
			UInt,
			Float,
			Double,
			String,
			Char,
			Bool,
		};

		class WfPredefinedType : public WfType, vl::reflection::Description<WfPredefinedType>
		{
		public:
			WfPredefinedTypeName name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfPredefinedType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTopQualifiedType : public WfType, vl::reflection::Description<WfTopQualifiedType>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfTopQualifiedType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReferenceType : public WfType, vl::reflection::Description<WfReferenceType>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfReferenceType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfRawPointerType : public WfType, vl::reflection::Description<WfRawPointerType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfRawPointerType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSharedPointerType : public WfType, vl::reflection::Description<WfSharedPointerType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfSharedPointerType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNullableType : public WfType, vl::reflection::Description<WfNullableType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfNullableType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEnumerableType : public WfType, vl::reflection::Description<WfEnumerableType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfEnumerableType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfMapWritability
		{
			Readonly,
			Writable,
		};

		class WfMapType : public WfType, vl::reflection::Description<WfMapType>
		{
		public:
			WfMapWritability writability;
			vl::Ptr<WfType> key;
			vl::Ptr<WfType> value;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfMapType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionType : public WfType, vl::reflection::Description<WfFunctionType>
		{
		public:
			vl::Ptr<WfType> result;
			vl::collections::List<vl::Ptr<WfType>> arguments;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfChildType : public WfType, vl::reflection::Description<WfChildType>
		{
		public:
			vl::Ptr<WfType> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfChildType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfExpression abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfExpression>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfTopQualifiedExpression* node)=0;
				virtual void Visit(WfReferenceExpression* node)=0;
				virtual void Visit(WfOrderedNameExpression* node)=0;
				virtual void Visit(WfOrderedLambdaExpression* node)=0;
				virtual void Visit(WfMemberExpression* node)=0;
				virtual void Visit(WfChildExpression* node)=0;
				virtual void Visit(WfLiteralExpression* node)=0;
				virtual void Visit(WfFloatingExpression* node)=0;
				virtual void Visit(WfIntegerExpression* node)=0;
				virtual void Visit(WfStringExpression* node)=0;
				virtual void Visit(WfFormatExpression* node)=0;
				virtual void Visit(WfUnaryExpression* node)=0;
				virtual void Visit(WfBinaryExpression* node)=0;
				virtual void Visit(WfLetExpression* node)=0;
				virtual void Visit(WfIfExpression* node)=0;
				virtual void Visit(WfRangeExpression* node)=0;
				virtual void Visit(WfSetTestingExpression* node)=0;
				virtual void Visit(WfConstructorExpression* node)=0;
				virtual void Visit(WfInferExpression* node)=0;
				virtual void Visit(WfTypeCastingExpression* node)=0;
				virtual void Visit(WfTypeTestingExpression* node)=0;
				virtual void Visit(WfTypeOfTypeExpression* node)=0;
				virtual void Visit(WfTypeOfExpressionExpression* node)=0;
				virtual void Visit(WfAttachEventExpression* node)=0;
				virtual void Visit(WfDetachEventExpression* node)=0;
				virtual void Visit(WfBindExpression* node)=0;
				virtual void Visit(WfObserveExpression* node)=0;
				virtual void Visit(WfCallExpression* node)=0;
				virtual void Visit(WfFunctionExpression* node)=0;
				virtual void Visit(WfNewTypeExpression* node)=0;
			};

			virtual void Accept(WfExpression::IVisitor* visitor)=0;

		};

		class WfTopQualifiedExpression : public WfExpression, vl::reflection::Description<WfTopQualifiedExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTopQualifiedExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReferenceExpression : public WfExpression, vl::reflection::Description<WfReferenceExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfReferenceExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfOrderedNameExpression : public WfExpression, vl::reflection::Description<WfOrderedNameExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfOrderedNameExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfOrderedLambdaExpression : public WfExpression, vl::reflection::Description<WfOrderedLambdaExpression>
		{
		public:
			vl::Ptr<WfExpression> body;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfOrderedLambdaExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfMemberExpression : public WfExpression, vl::reflection::Description<WfMemberExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfMemberExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfChildExpression : public WfExpression, vl::reflection::Description<WfChildExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfChildExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfLiteralValue
		{
			Null,
			True,
			False,
		};

		class WfLiteralExpression : public WfExpression, vl::reflection::Description<WfLiteralExpression>
		{
		public:
			WfLiteralValue value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfLiteralExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFloatingExpression : public WfExpression, vl::reflection::Description<WfFloatingExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFloatingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIntegerExpression : public WfExpression, vl::reflection::Description<WfIntegerExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfIntegerExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStringExpression : public WfExpression, vl::reflection::Description<WfStringExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfStringExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFormatExpression : public WfExpression, vl::reflection::Description<WfFormatExpression>
		{
		public:
			vl::parsing::ParsingToken value;
			vl::Ptr<WfExpression> expandedExpression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFormatExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfUnaryOperator
		{
			Positive,
			Negative,
			Not,
		};

		class WfUnaryExpression : public WfExpression, vl::reflection::Description<WfUnaryExpression>
		{
		public:
			WfUnaryOperator op;
			vl::Ptr<WfExpression> operand;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfUnaryExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfBinaryOperator
		{
			Assign,
			Index,
			Concat,
			FailedThen,
			Exp,
			Add,
			Sub,
			Mul,
			Div,
			Mod,
			Shl,
			Shr,
			LT,
			GT,
			LE,
			GE,
			EQ,
			NE,
			Xor,
			And,
			Or,
		};

		class WfBinaryExpression : public WfExpression, vl::reflection::Description<WfBinaryExpression>
		{
		public:
			WfBinaryOperator op;
			vl::Ptr<WfExpression> first;
			vl::Ptr<WfExpression> second;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfBinaryExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfLetVariable : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfLetVariable>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfLetVariable> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfLetExpression : public WfExpression, vl::reflection::Description<WfLetExpression>
		{
		public:
			vl::collections::List<vl::Ptr<WfLetVariable>> variables;
			vl::Ptr<WfExpression> expression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfLetExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIfExpression : public WfExpression, vl::reflection::Description<WfIfExpression>
		{
		public:
			vl::Ptr<WfExpression> condition;
			vl::Ptr<WfExpression> trueBranch;
			vl::Ptr<WfExpression> falseBranch;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfIfExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfRangeBoundary
		{
			Inclusive,
			Exclusive,
		};

		class WfRangeExpression : public WfExpression, vl::reflection::Description<WfRangeExpression>
		{
		public:
			vl::Ptr<WfExpression> begin;
			WfRangeBoundary beginBoundary;
			vl::Ptr<WfExpression> end;
			WfRangeBoundary endBoundary;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfRangeExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfSetTesting
		{
			In,
			NotIn,
		};

		class WfSetTestingExpression : public WfExpression, vl::reflection::Description<WfSetTestingExpression>
		{
		public:
			WfSetTesting test;
			vl::Ptr<WfExpression> element;
			vl::Ptr<WfExpression> collection;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfSetTestingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfConstructorArgument>
		{
		public:
			vl::Ptr<WfExpression> key;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfConstructorArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorExpression : public WfExpression, vl::reflection::Description<WfConstructorExpression>
		{
		public:
			vl::collections::List<vl::Ptr<WfConstructorArgument>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfConstructorExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfInferExpression : public WfExpression, vl::reflection::Description<WfInferExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfInferExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfTypeCastingStrategy
		{
			Strong,
			Weak,
		};

		class WfTypeCastingExpression : public WfExpression, vl::reflection::Description<WfTypeCastingExpression>
		{
		public:
			WfTypeCastingStrategy strategy;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeCastingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfTypeTesting
		{
			IsType,
			IsNotType,
			IsNull,
			IsNotNull,
		};

		class WfTypeTestingExpression : public WfExpression, vl::reflection::Description<WfTypeTestingExpression>
		{
		public:
			WfTypeTesting test;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeTestingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTypeOfTypeExpression : public WfExpression, vl::reflection::Description<WfTypeOfTypeExpression>
		{
		public:
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeOfTypeExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTypeOfExpressionExpression : public WfExpression, vl::reflection::Description<WfTypeOfExpressionExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeOfExpressionExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfAttachEventExpression : public WfExpression, vl::reflection::Description<WfAttachEventExpression>
		{
		public:
			vl::Ptr<WfExpression> event;
			vl::Ptr<WfExpression> function;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfAttachEventExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDetachEventExpression : public WfExpression, vl::reflection::Description<WfDetachEventExpression>
		{
		public:
			vl::Ptr<WfExpression> handler;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfDetachEventExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfBindExpression : public WfExpression, vl::reflection::Description<WfBindExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfExpression> expandedExpression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfBindExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfObserveType
		{
			SimpleObserve,
			ExtendedObserve,
		};

		class WfObserveExpression : public WfExpression, vl::reflection::Description<WfObserveExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			WfObserveType observeType;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> expression;
			vl::collections::List<vl::Ptr<WfExpression>> events;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfObserveExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCallExpression : public WfExpression, vl::reflection::Description<WfCallExpression>
		{
		public:
			vl::Ptr<WfExpression> function;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfCallExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStatement abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfBreakStatement* node)=0;
				virtual void Visit(WfContinueStatement* node)=0;
				virtual void Visit(WfReturnStatement* node)=0;
				virtual void Visit(WfDeleteStatement* node)=0;
				virtual void Visit(WfRaiseExceptionStatement* node)=0;
				virtual void Visit(WfIfStatement* node)=0;
				virtual void Visit(WfSwitchStatement* node)=0;
				virtual void Visit(WfWhileStatement* node)=0;
				virtual void Visit(WfForEachStatement* node)=0;
				virtual void Visit(WfTryStatement* node)=0;
				virtual void Visit(WfBlockStatement* node)=0;
				virtual void Visit(WfExpressionStatement* node)=0;
				virtual void Visit(WfVariableStatement* node)=0;
			};

			virtual void Accept(WfStatement::IVisitor* visitor)=0;

		};

		class WfBreakStatement : public WfStatement, vl::reflection::Description<WfBreakStatement>
		{
		public:

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfBreakStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfContinueStatement : public WfStatement, vl::reflection::Description<WfContinueStatement>
		{
		public:

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfContinueStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReturnStatement : public WfStatement, vl::reflection::Description<WfReturnStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfReturnStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDeleteStatement : public WfStatement, vl::reflection::Description<WfDeleteStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfDeleteStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfRaiseExceptionStatement : public WfStatement, vl::reflection::Description<WfRaiseExceptionStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfRaiseExceptionStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIfStatement : public WfStatement, vl::reflection::Description<WfIfStatement>
		{
		public:
			vl::Ptr<WfType> type;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfStatement> trueBranch;
			vl::Ptr<WfStatement> falseBranch;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfIfStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSwitchCase : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfSwitchCase>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfStatement> statement;

			static vl::Ptr<WfSwitchCase> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSwitchStatement : public WfStatement, vl::reflection::Description<WfSwitchStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::collections::List<vl::Ptr<WfSwitchCase>> caseBranches;
			vl::Ptr<WfStatement> defaultBranch;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfSwitchStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfWhileStatement : public WfStatement, vl::reflection::Description<WfWhileStatement>
		{
		public:
			vl::Ptr<WfExpression> condition;
			vl::Ptr<WfStatement> statement;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfWhileStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfForEachDirection
		{
			Normal,
			Reversed,
		};

		class WfForEachStatement : public WfStatement, vl::reflection::Description<WfForEachStatement>
		{
		public:
			vl::parsing::ParsingToken name;
			WfForEachDirection direction;
			vl::Ptr<WfExpression> collection;
			vl::Ptr<WfStatement> statement;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfForEachStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTryStatement : public WfStatement, vl::reflection::Description<WfTryStatement>
		{
		public:
			vl::Ptr<WfStatement> protectedStatement;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfStatement> catchStatement;
			vl::Ptr<WfStatement> finallyStatement;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfTryStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfBlockStatement : public WfStatement, vl::reflection::Description<WfBlockStatement>
		{
		public:
			vl::collections::List<vl::Ptr<WfStatement>> statements;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfBlockStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfExpressionStatement : public WfStatement, vl::reflection::Description<WfExpressionStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfExpressionStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDeclaration abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfDeclaration>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfNamespaceDeclaration* node)=0;
				virtual void Visit(WfFunctionDeclaration* node)=0;
				virtual void Visit(WfVariableDeclaration* node)=0;
				virtual void Visit(WfEventDeclaration* node)=0;
				virtual void Visit(WfPropertyDeclaration* node)=0;
				virtual void Visit(WfClassDeclaration* node)=0;
			};

			virtual void Accept(WfDeclaration::IVisitor* visitor)=0;

			vl::parsing::ParsingToken name;
		};

		class WfNamespaceDeclaration : public WfDeclaration, vl::reflection::Description<WfNamespaceDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfNamespaceDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfFunctionArgument>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfType> type;

			static vl::Ptr<WfFunctionArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfFunctionAnonymity
		{
			Named,
			Anonymous,
		};

		class WfFunctionDeclaration : public WfDeclaration, vl::reflection::Description<WfFunctionDeclaration>
		{
		public:
			WfFunctionAnonymity anonymity;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
			vl::Ptr<WfType> returnType;
			vl::Ptr<WfStatement> statement;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionExpression : public WfExpression, vl::reflection::Description<WfFunctionExpression>
		{
		public:
			vl::Ptr<WfFunctionDeclaration> function;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVariableDeclaration : public WfDeclaration, vl::reflection::Description<WfVariableDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			vl::Ptr<WfExpression> expression;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfVariableDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVariableStatement : public WfStatement, vl::reflection::Description<WfVariableStatement>
		{
		public:
			vl::Ptr<WfVariableDeclaration> variable;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfVariableStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNewTypeExpression : public WfExpression, vl::reflection::Description<WfNewTypeExpression>
		{
		public:
			vl::Ptr<WfType> type;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;
			vl::collections::List<vl::Ptr<WfFunctionDeclaration>> functions;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfNewTypeExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfClassMemberKind
		{
			Static,
			Normal,
		};

		enum class WfClassKind
		{
			Class,
			Interface,
		};

		class WfClassMember : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfClassMember>
		{
		public:
			WfClassMemberKind kind;
			vl::Ptr<WfDeclaration> declaration;

			static vl::Ptr<WfClassMember> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEventDeclaration : public WfDeclaration, vl::reflection::Description<WfEventDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfType>> arguments;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfEventDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfPropertyDeclaration : public WfDeclaration, vl::reflection::Description<WfPropertyDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			vl::parsing::ParsingToken getter;
			vl::parsing::ParsingToken setter;
			vl::parsing::ParsingToken valueChangedEvent;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfPropertyDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfClassDeclaration : public WfDeclaration, vl::reflection::Description<WfClassDeclaration>
		{
		public:
			WfClassKind kind;
			vl::collections::List<vl::Ptr<WfType>> baseTypes;
			vl::collections::List<vl::Ptr<WfClassMember>> members;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfClassDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingFragment abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingFragment>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfModuleUsingNameFragment* node)=0;
				virtual void Visit(WfModuleUsingWildCardFragment* node)=0;
			};

			virtual void Accept(WfModuleUsingFragment::IVisitor* visitor)=0;

		};

		class WfModuleUsingNameFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingNameFragment>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfModuleUsingFragment::IVisitor* visitor)override;

			static vl::Ptr<WfModuleUsingNameFragment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingWildCardFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingWildCardFragment>
		{
		public:

			void Accept(WfModuleUsingFragment::IVisitor* visitor)override;

			static vl::Ptr<WfModuleUsingWildCardFragment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingItem : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingItem>
		{
		public:
			vl::collections::List<vl::Ptr<WfModuleUsingFragment>> fragments;

			static vl::Ptr<WfModuleUsingItem> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingPath : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingPath>
		{
		public:
			vl::collections::List<vl::Ptr<WfModuleUsingItem>> items;

			static vl::Ptr<WfModuleUsingPath> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfModuleType
		{
			Module,
			Unit,
		};

		class WfModule : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModule>
		{
		public:
			WfModuleType moduleType;
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfModuleUsingPath>> paths;
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			static vl::Ptr<WfModule> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		extern vl::WString WfGetParserTextBuffer();
		extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> WfConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		extern vl::Ptr<vl::parsing::tabling::ParsingTable> WfLoadTable();

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::workflow::WfType)
			DECL_TYPE_INFO(vl::workflow::WfPredefinedTypeName)
			DECL_TYPE_INFO(vl::workflow::WfPredefinedType)
			DECL_TYPE_INFO(vl::workflow::WfTopQualifiedType)
			DECL_TYPE_INFO(vl::workflow::WfReferenceType)
			DECL_TYPE_INFO(vl::workflow::WfRawPointerType)
			DECL_TYPE_INFO(vl::workflow::WfSharedPointerType)
			DECL_TYPE_INFO(vl::workflow::WfNullableType)
			DECL_TYPE_INFO(vl::workflow::WfEnumerableType)
			DECL_TYPE_INFO(vl::workflow::WfMapWritability)
			DECL_TYPE_INFO(vl::workflow::WfMapType)
			DECL_TYPE_INFO(vl::workflow::WfFunctionType)
			DECL_TYPE_INFO(vl::workflow::WfChildType)
			DECL_TYPE_INFO(vl::workflow::WfExpression)
			DECL_TYPE_INFO(vl::workflow::WfTopQualifiedExpression)
			DECL_TYPE_INFO(vl::workflow::WfReferenceExpression)
			DECL_TYPE_INFO(vl::workflow::WfOrderedNameExpression)
			DECL_TYPE_INFO(vl::workflow::WfOrderedLambdaExpression)
			DECL_TYPE_INFO(vl::workflow::WfMemberExpression)
			DECL_TYPE_INFO(vl::workflow::WfChildExpression)
			DECL_TYPE_INFO(vl::workflow::WfLiteralValue)
			DECL_TYPE_INFO(vl::workflow::WfLiteralExpression)
			DECL_TYPE_INFO(vl::workflow::WfFloatingExpression)
			DECL_TYPE_INFO(vl::workflow::WfIntegerExpression)
			DECL_TYPE_INFO(vl::workflow::WfStringExpression)
			DECL_TYPE_INFO(vl::workflow::WfFormatExpression)
			DECL_TYPE_INFO(vl::workflow::WfUnaryOperator)
			DECL_TYPE_INFO(vl::workflow::WfUnaryExpression)
			DECL_TYPE_INFO(vl::workflow::WfBinaryOperator)
			DECL_TYPE_INFO(vl::workflow::WfBinaryExpression)
			DECL_TYPE_INFO(vl::workflow::WfLetVariable)
			DECL_TYPE_INFO(vl::workflow::WfLetExpression)
			DECL_TYPE_INFO(vl::workflow::WfIfExpression)
			DECL_TYPE_INFO(vl::workflow::WfRangeBoundary)
			DECL_TYPE_INFO(vl::workflow::WfRangeExpression)
			DECL_TYPE_INFO(vl::workflow::WfSetTesting)
			DECL_TYPE_INFO(vl::workflow::WfSetTestingExpression)
			DECL_TYPE_INFO(vl::workflow::WfConstructorArgument)
			DECL_TYPE_INFO(vl::workflow::WfConstructorExpression)
			DECL_TYPE_INFO(vl::workflow::WfInferExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeCastingStrategy)
			DECL_TYPE_INFO(vl::workflow::WfTypeCastingExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeTesting)
			DECL_TYPE_INFO(vl::workflow::WfTypeTestingExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeOfTypeExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeOfExpressionExpression)
			DECL_TYPE_INFO(vl::workflow::WfAttachEventExpression)
			DECL_TYPE_INFO(vl::workflow::WfDetachEventExpression)
			DECL_TYPE_INFO(vl::workflow::WfBindExpression)
			DECL_TYPE_INFO(vl::workflow::WfObserveType)
			DECL_TYPE_INFO(vl::workflow::WfObserveExpression)
			DECL_TYPE_INFO(vl::workflow::WfCallExpression)
			DECL_TYPE_INFO(vl::workflow::WfStatement)
			DECL_TYPE_INFO(vl::workflow::WfBreakStatement)
			DECL_TYPE_INFO(vl::workflow::WfContinueStatement)
			DECL_TYPE_INFO(vl::workflow::WfReturnStatement)
			DECL_TYPE_INFO(vl::workflow::WfDeleteStatement)
			DECL_TYPE_INFO(vl::workflow::WfRaiseExceptionStatement)
			DECL_TYPE_INFO(vl::workflow::WfIfStatement)
			DECL_TYPE_INFO(vl::workflow::WfSwitchCase)
			DECL_TYPE_INFO(vl::workflow::WfSwitchStatement)
			DECL_TYPE_INFO(vl::workflow::WfWhileStatement)
			DECL_TYPE_INFO(vl::workflow::WfForEachDirection)
			DECL_TYPE_INFO(vl::workflow::WfForEachStatement)
			DECL_TYPE_INFO(vl::workflow::WfTryStatement)
			DECL_TYPE_INFO(vl::workflow::WfBlockStatement)
			DECL_TYPE_INFO(vl::workflow::WfExpressionStatement)
			DECL_TYPE_INFO(vl::workflow::WfDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfNamespaceDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfFunctionArgument)
			DECL_TYPE_INFO(vl::workflow::WfFunctionAnonymity)
			DECL_TYPE_INFO(vl::workflow::WfFunctionDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfFunctionExpression)
			DECL_TYPE_INFO(vl::workflow::WfVariableDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfVariableStatement)
			DECL_TYPE_INFO(vl::workflow::WfNewTypeExpression)
			DECL_TYPE_INFO(vl::workflow::WfClassMemberKind)
			DECL_TYPE_INFO(vl::workflow::WfClassKind)
			DECL_TYPE_INFO(vl::workflow::WfClassMember)
			DECL_TYPE_INFO(vl::workflow::WfEventDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfPropertyDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfClassDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingNameFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingWildCardFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingItem)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingPath)
			DECL_TYPE_INFO(vl::workflow::WfModuleType)
			DECL_TYPE_INFO(vl::workflow::WfModule)
			DECL_TYPE_INFO(vl::workflow::WfType::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfExpression::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfDeclaration::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment::IVisitor)

			namespace interface_proxy
			{
				class WfType_IVisitor : public ValueInterfaceRoot, public virtual vl::workflow::WfType::IVisitor
				{
				public:
					WfType_IVisitor(Ptr<IValueInterfaceProxy> proxy)
						:ValueInterfaceRoot(proxy)
					{
					}

					static Ptr<vl::workflow::WfType::IVisitor> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new WfType_IVisitor(proxy);
					}

					void Visit(vl::workflow::WfPredefinedType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfTopQualifiedType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfReferenceType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfRawPointerType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfSharedPointerType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfNullableType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfEnumerableType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfMapType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfFunctionType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfChildType* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

				};

				class WfExpression_IVisitor : public ValueInterfaceRoot, public virtual vl::workflow::WfExpression::IVisitor
				{
				public:
					WfExpression_IVisitor(Ptr<IValueInterfaceProxy> proxy)
						:ValueInterfaceRoot(proxy)
					{
					}

					static Ptr<vl::workflow::WfExpression::IVisitor> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new WfExpression_IVisitor(proxy);
					}

					void Visit(vl::workflow::WfTopQualifiedExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfReferenceExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfOrderedNameExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfOrderedLambdaExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfMemberExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfChildExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfLiteralExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfFloatingExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfIntegerExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfStringExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfFormatExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfUnaryExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfBinaryExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfLetExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfIfExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfRangeExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfSetTestingExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfConstructorExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfInferExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfTypeCastingExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfTypeTestingExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfTypeOfTypeExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfTypeOfExpressionExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfAttachEventExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfDetachEventExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfBindExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfObserveExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfCallExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfFunctionExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfNewTypeExpression* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

				};

				class WfStatement_IVisitor : public ValueInterfaceRoot, public virtual vl::workflow::WfStatement::IVisitor
				{
				public:
					WfStatement_IVisitor(Ptr<IValueInterfaceProxy> proxy)
						:ValueInterfaceRoot(proxy)
					{
					}

					static Ptr<vl::workflow::WfStatement::IVisitor> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new WfStatement_IVisitor(proxy);
					}

					void Visit(vl::workflow::WfBreakStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfContinueStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfReturnStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfDeleteStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfRaiseExceptionStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfIfStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfSwitchStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfWhileStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfForEachStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfTryStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfBlockStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfExpressionStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfVariableStatement* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

				};

				class WfDeclaration_IVisitor : public ValueInterfaceRoot, public virtual vl::workflow::WfDeclaration::IVisitor
				{
				public:
					WfDeclaration_IVisitor(Ptr<IValueInterfaceProxy> proxy)
						:ValueInterfaceRoot(proxy)
					{
					}

					static Ptr<vl::workflow::WfDeclaration::IVisitor> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new WfDeclaration_IVisitor(proxy);
					}

					void Visit(vl::workflow::WfNamespaceDeclaration* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfFunctionDeclaration* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfVariableDeclaration* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfEventDeclaration* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfPropertyDeclaration* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfClassDeclaration* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

				};

				class WfModuleUsingFragment_IVisitor : public ValueInterfaceRoot, public virtual vl::workflow::WfModuleUsingFragment::IVisitor
				{
				public:
					WfModuleUsingFragment_IVisitor(Ptr<IValueInterfaceProxy> proxy)
						:ValueInterfaceRoot(proxy)
					{
					}

					static Ptr<vl::workflow::WfModuleUsingFragment::IVisitor> Create(Ptr<IValueInterfaceProxy> proxy)
					{
						return new WfModuleUsingFragment_IVisitor(proxy);
					}

					void Visit(vl::workflow::WfModuleUsingNameFragment* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

					void Visit(vl::workflow::WfModuleUsingWildCardFragment* node)override
					{
						INVOKE_INTERFACE_PROXY(Visit, node);
					}

				};

			}
#endif

			extern bool WfLoadTypes();
		}
	}
}
#endif

/***********************************************************************
EXPRESSION\WFEXPRESSION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression

Interfaces:
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSION
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSION


namespace vl
{
	namespace workflow
	{
		/// <summary>Print a Workflow type.</summary>
		/// <param name="node">The Workflow type.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfType> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow expression.</summary>
		/// <param name="node">The Workflow expression.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfExpression> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow statement.</summary>
		/// <param name="node">The Workflow statement.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfStatement> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow declaration.</summary>
		/// <param name="node">The Workflow declaration.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfDeclaration> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow module.</summary>
		/// <param name="node">The Workflow module.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfModule> node, const WString& indent, parsing::ParsingWriter& writer);
		
		/// <summary>Print a Workflow type.</summary>
		/// <param name="node">The Workflow type.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfType> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow expression.</summary>
		/// <param name="node">The Workflow expression.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfExpression> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow statement.</summary>
		/// <param name="node">The Workflow statement.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfStatement> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow declaration.</summary>
		/// <param name="node">The Workflow declaration.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfDeclaration> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow module.</summary>
		/// <param name="node">The Workflow module.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfModule> node, const WString& indent, stream::TextWriter& writer);
	}
}
#endif

/***********************************************************************
RUNTIME\WFRUNTIMEINSTRUCTION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Runtime

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_RUNTIME_WFRUNTIMEINSTRUCTION
#define VCZH_WORKFLOW_RUNTIME_WFRUNTIMEINSTRUCTION


namespace vl
{
	namespace workflow
	{
		namespace runtime
		{

/***********************************************************************
Instruction
***********************************************************************/

			enum class WfInsCode
			{
				// Instruction		// param				: <Stack-Pattern> -> <Stack-Pattern> in the order of <bottom ---- top>
				Nop,				// 						: () -> ()										;
				LoadValue,			// value				: () -> Value									;
				LoadClosure,		// function, count		: Value-1, ..., Value-count -> Value			;
				LoadException,		// 						: () -> Value									;
				LoadLocalVar,		// variable				: () -> Value									;
				LoadCapturedVar,	// variable				: () -> Value									;
				LoadGlobalVar,		// variable				: () -> Value									;
				StoreLocalVar,		// variable				: Value -> ()									;
				StoreGlobalVar,		// variable				: Value -> ()									;
				Duplicate,			// count				: () -> Value									; copy stack[stack.Count()-1-count]
				Pop,				//						: Value -> ()									;
				Return,				// 						: Value -> Value								; (exit function)
				CreateArray,		// count				: Value-count, ..., Value-1 -> <array>			; {1 2 3} -> <3 2 1>
				CreateMap,			// count				: Value-count, ..., Value-1 -> <map>			; {1:2 3:4} -> <3 4 1 2>
				CreateInterface,	// count				: Value-count, ..., Value-1 -> <map>			; {"Get":a "Set":b} -> InterfaceProxy^
				CreateRange,		// I1248/U1248			: Value-begin, Value-end -> <enumerable>		;
				ReverseEnumerable,	//						: Value -> Value								;
				DeleteRawPtr,		//						: Value -> ()									;
				ConvertToType,		// flag, typeDescriptor	: Value -> Value								;
				TryConvertToType,	// flag, typeDescriptor	: Value -> Value								;
				TestType,			// flag, typeDescriptor	: Value -> <bool>								;
				GetType,			//						: Value -> <ITypeDescriptor*>					;
				Jump,				// label				: () -> ()										;
				JumpIf,				// label				: () -> ()										;
				Invoke,				// function, count		: Value-1, ..., Value-n -> Value				;
				GetProperty,		// IPropertyInfo*		: Value-this -> Value							;
				SetProperty,		// IPropertyInfo*		: Value, Value-this -> ()						;
				InvokeProxy,		// count				: Value-1, ..., Value-n, Value-this -> Value	;
				InvokeMethod,		// IMethodInfo*, count	: Value-1, ..., Value-n, Value-this -> Value	;
				AttachEvent,		// IEventInfo*			: Value-this, <function> -> <Listener>			;
				DetachEvent,		// 						: <Listener> -> bool							;
				InstallTry,			// label				: () -> ()										;
				UninstallTry,		// count				: () -> ()										;
				RaiseException,		// 						: Value -> ()									; (trap)
				TestElementInSet,	//						: Value-element, Value-set -> bool				;
				CompareLiteral,		// I48/U48/F48/S		: Value, Value -> <int>							;
				CompareStruct,		// 						: Value, Value -> <bool>						;
				CompareReference,	// 						: Value, Value -> <bool>						;
				CompareValue,		// 						: Value, Value -> <bool>						;
				OpNot,				// B/I1248/U1248		: Value -> Value								;
				OpPositive,			// I1248/U1248			: Value -> Value								;
				OpNegative,			// I1248				: Value -> Value								;
				OpConcat,			// 						: <string>, <string> -> <string>				;
				OpExp,				// I48/U48/F48			: Value, Value -> Value							;
				OpAdd,				// I48/U48/F48			: Value, Value -> Value							;
				OpSub,				// I48/U48/F48			: Value, Value -> Value							;
				OpMul,				// I48/U48/F48			: Value, Value -> Value							;
				OpDiv,				// I48/U48/F48			: Value, Value -> Value							;
				OpMod,				// I48/U48				: Value, Value -> Value							;
				OpShl,				// I48/U48				: Value, Value -> Value							;
				OpShr,				// I48/U48				: Value, Value -> Value							;
				OpXor,				// B/I1248/U1248		: <bool>, <bool> -> <bool>						;
				OpAnd,				// B/I1248/U1248		: <bool>, <bool> -> <bool>						;
				OpOr,				// B/I1248/U1248		: <bool>, <bool> -> <bool>						;
				OpLT,				// 						: <int> -> <bool>								;
				OpGT,				// 						: <int> -> <bool>								;
				OpLE,				// 						: <int> -> <bool>								;
				OpGE,				// 						: <int> -> <bool>								;
				OpEQ,				// 						: <int> -> <bool>								;
				OpNE,				// 						: <int> -> <bool>								;
			};

#define INSTRUCTION_CASES(APPLY, APPLY_VALUE, APPLY_FUNCTION, APPLY_FUNCTION_COUNT, APPLY_VARIABLE, APPLY_COUNT, APPLY_FLAG_TYPEDESCRIPTOR, APPLY_PROPERTY, APPLY_METHOD_COUNT, APPLY_EVENT, APPLY_LABEL, APPLY_TYPE)\
			APPLY(Nop)\
			APPLY_VALUE(LoadValue)\
			APPLY_FUNCTION_COUNT(LoadClosure)\
			APPLY(LoadException)\
			APPLY_VARIABLE(LoadLocalVar)\
			APPLY_VARIABLE(LoadCapturedVar)\
			APPLY_VARIABLE(LoadGlobalVar)\
			APPLY_VARIABLE(StoreLocalVar)\
			APPLY_VARIABLE(StoreGlobalVar)\
			APPLY_COUNT(Duplicate)\
			APPLY(Pop)\
			APPLY(Return)\
			APPLY_COUNT(CreateArray)\
			APPLY_COUNT(CreateMap)\
			APPLY_COUNT(CreateInterface)\
			APPLY_TYPE(CreateRange)\
			APPLY(ReverseEnumerable)\
			APPLY(DeleteRawPtr)\
			APPLY_FLAG_TYPEDESCRIPTOR(ConvertToType)\
			APPLY_FLAG_TYPEDESCRIPTOR(TryConvertToType)\
			APPLY_FLAG_TYPEDESCRIPTOR(TestType)\
			APPLY(GetType)\
			APPLY_LABEL(Jump)\
			APPLY_LABEL(JumpIf)\
			APPLY_FUNCTION_COUNT(Invoke)\
			APPLY_PROPERTY(GetProperty)\
			APPLY_PROPERTY(SetProperty)\
			APPLY_COUNT(InvokeProxy)\
			APPLY_METHOD_COUNT(InvokeMethod)\
			APPLY_EVENT(AttachEvent)\
			APPLY(DetachEvent)\
			APPLY_LABEL(InstallTry)\
			APPLY_COUNT(UninstallTry)\
			APPLY(RaiseException)\
			APPLY(TestElementInSet)\
			APPLY_TYPE(CompareLiteral)\
			APPLY(CompareStruct)\
			APPLY(CompareReference)\
			APPLY(CompareValue)\
			APPLY_TYPE(OpNot)\
			APPLY_TYPE(OpPositive)\
			APPLY_TYPE(OpNegative)\
			APPLY(OpConcat)\
			APPLY_TYPE(OpExp)\
			APPLY_TYPE(OpAdd)\
			APPLY_TYPE(OpSub)\
			APPLY_TYPE(OpMul)\
			APPLY_TYPE(OpDiv)\
			APPLY_TYPE(OpMod)\
			APPLY_TYPE(OpShl)\
			APPLY_TYPE(OpShr)\
			APPLY_TYPE(OpXor)\
			APPLY_TYPE(OpAnd)\
			APPLY_TYPE(OpOr)\
			APPLY(OpLT)\
			APPLY(OpGT)\
			APPLY(OpLE)\
			APPLY(OpGE)\
			APPLY(OpEQ)\
			APPLY(OpNE)\

			enum class WfInsType
			{
				Bool,
				I1,
				I2,
				I4,
				I8,
				U1,
				U2,
				U4,
				U8,
				F4,
				F8,
				String,
				Unknown,
			};

			struct WfInstruction
			{
				WfInsCode											code = WfInsCode::Nop;
				reflection::description::Value						valueParameter;
				vint												countParameter = 0;
				union
				{
					struct
					{
						reflection::description::Value::ValueType		flagParameter;
						reflection::description::ITypeDescriptor*		typeDescriptorParameter;
					};
					WfInsType											typeParameter;
					vint												indexParameter;
					reflection::description::IPropertyInfo*				propertyParameter;
					reflection::description::IMethodInfo*				methodParameter;
					reflection::description::IEventInfo*				eventParameter;
				};

				WfInstruction();

				#define CTOR(NAME)						static WfInstruction NAME();
				#define CTOR_VALUE(NAME)				static WfInstruction NAME(const reflection::description::Value& value);
				#define CTOR_FUNCTION(NAME)				static WfInstruction NAME(vint function);
				#define CTOR_FUNCTION_COUNT(NAME)		static WfInstruction NAME(vint function, vint count);
				#define CTOR_VARIABLE(NAME)				static WfInstruction NAME(vint variable);
				#define CTOR_COUNT(NAME)				static WfInstruction NAME(vint count);
				#define CTOR_FLAG_TYPEDESCRIPTOR(NAME)	static WfInstruction NAME(reflection::description::Value::ValueType flag, reflection::description::ITypeDescriptor* typeDescriptor);
				#define CTOR_PROPERTY(NAME)				static WfInstruction NAME(reflection::description::IPropertyInfo* propertyInfo);
				#define CTOR_METHOD_COUNT(NAME)			static WfInstruction NAME(reflection::description::IMethodInfo* methodInfo, vint count);
				#define CTOR_EVENT(NAME)				static WfInstruction NAME(reflection::description::IEventInfo* eventInfo);
				#define CTOR_LABEL(NAME)				static WfInstruction NAME(vint label);
				#define CTOR_TYPE(NAME)					static WfInstruction NAME(WfInsType type);

				INSTRUCTION_CASES(
					CTOR,
					CTOR_VALUE,
					CTOR_FUNCTION,
					CTOR_FUNCTION_COUNT,
					CTOR_VARIABLE,
					CTOR_COUNT,
					CTOR_FLAG_TYPEDESCRIPTOR,
					CTOR_PROPERTY,
					CTOR_METHOD_COUNT,
					CTOR_EVENT,
					CTOR_LABEL,
					CTOR_TYPE)

				#undef CTOR
				#undef CTOR_VALUE
				#undef CTOR_FUNCTION
				#undef CTOR_FUNCTION_COUNT
				#undef CTOR_VARIABLE
				#undef CTOR_COUNT
				#undef CTOR_FLAG_TYPEDESCRIPTOR
				#undef CTOR_PROPERTY
				#undef CTOR_METHOD_COUNT
				#undef CTOR_EVENT
				#undef CTOR_LABEL
				#undef CTOR_TYPE
			};
		}
	}
}

#endif

/***********************************************************************
RUNTIME\WFRUNTIMETYPEDESCRIPTOR.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Runtime

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_RUNTIME_WFRUNTIMETYPEDESCRIPTOR
#define VCZH_WORKFLOW_RUNTIME_WFRUNTIMETYPEDESCRIPTOR


namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			class WfRuntimeGlobalContext;
		}

		namespace typeimpl
		{
			class WfCustomType;
			class WfTypeImpl;

/***********************************************************************
Method
***********************************************************************/

			class WfMethodBase : public reflection::description::MethodInfoImpl
			{
				friend class WfCustomType;
				typedef reflection::description::ITypeInfo					ITypeInfo;
			protected:
				runtime::WfRuntimeGlobalContext*		globalContext = nullptr;
				
				void									SetGlobalContext(runtime::WfRuntimeGlobalContext* _globalContext);
			public:
				WfMethodBase(bool isStatic);
				~WfMethodBase();

				runtime::WfRuntimeGlobalContext*		GetGlobalContext();
				void									SetReturn(Ptr<ITypeInfo> type);
			};

			class WfStaticMethod : public WfMethodBase
			{
				typedef reflection::description::Value						Value;
			protected:

				Value									InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override;
				Value									CreateFunctionProxyInternal(const Value& thisObject)override;
			public:
				vint									functionIndex = -1;

				WfStaticMethod();
			};

			class WfInterfaceMethod : public WfMethodBase
			{
				typedef reflection::description::Value						Value;
			protected:

				Value									InvokeInternal(const Value& thisObject, collections::Array<Value>& arguments)override;
				Value									CreateFunctionProxyInternal(const Value& thisObject)override;
			public:
				WfInterfaceMethod();
			};

/***********************************************************************
Event
***********************************************************************/

			class WfEvent : public reflection::description::EventInfoImpl
			{
				typedef reflection::description::ITypeDescriptor			ITypeDescriptor;
				typedef reflection::description::ITypeInfo					ITypeInfo;
				typedef reflection::description::IEventHandler				IEventHandler;
				typedef reflection::description::Value						Value;
			protected:

				void									AttachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)override;
				void									DetachInternal(DescriptableObject* thisObject, IEventHandler* eventHandler)override;
				void									InvokeInternal(DescriptableObject* thisObject, collections::Array<Value>& arguments)override;
				Ptr<ITypeInfo>							GetHandlerTypeInternal()override;
			public:
				WfEvent(ITypeDescriptor* ownerTypeDescriptor, const WString& name);
				~WfEvent();

				void									SetHandlerType(Ptr<ITypeInfo> typeInfo);
			};

/***********************************************************************
Property
***********************************************************************/

			class WfProperty : public reflection::description::PropertyInfoImpl
			{
				typedef reflection::description::ITypeDescriptor			ITypeDescriptor;
				typedef reflection::description::MethodInfoImpl				MethodInfoImpl;
				typedef reflection::description::EventInfoImpl				EventInfoImpl;
			public:
				WfProperty(ITypeDescriptor* ownerTypeDescriptor, const WString& name);
				~WfProperty();

				void									SetGetter(MethodInfoImpl* value);
				void									SetSetter(MethodInfoImpl* value);
				void									SetValueChangedEvent(EventInfoImpl* value);
			};

/***********************************************************************
Custom Type
***********************************************************************/

			class WfCustomType : public reflection::description::TypeDescriptorImpl
			{
				typedef reflection::description::ITypeDescriptor			ITypeDescriptor;
				typedef reflection::description::ITypeInfo					ITypeInfo;
			protected:
				runtime::WfRuntimeGlobalContext*		globalContext = nullptr;
				
				void									SetGlobalContext(runtime::WfRuntimeGlobalContext* _globalContext);
				void									LoadInternal()override;
			public:
				WfCustomType(const WString& typeName);
				~WfCustomType();
				
				runtime::WfRuntimeGlobalContext*		GetGlobalContext();
				void									AddBaseType(ITypeDescriptor* type);
				void									AddMember(const WString& name, Ptr<WfMethodBase> value);
				void									AddMember(Ptr<WfProperty> value);
				void									AddMember(Ptr<WfEvent> value);
			};

			class WfClass : public WfCustomType
			{
				friend class WfTypeImpl;
			public:
				WfClass(const WString& typeName);
				~WfClass();
			};

			class WfInterface : public WfCustomType
			{
				friend class WfTypeImpl;
			public:
				WfInterface(const WString& typeName);
				~WfInterface();
			};

/***********************************************************************
Plugin
***********************************************************************/

			class WfTypeImpl : public Object, public reflection::description::ITypeLoader, public reflection::Description<WfTypeImpl>
			{
			protected:
				runtime::WfRuntimeGlobalContext*		globalContext = nullptr;

			public:
				collections::List<Ptr<WfClass>>			classes;
				collections::List<Ptr<WfInterface>>		interfaces;
				
				runtime::WfRuntimeGlobalContext*		GetGlobalContext();
				void									SetGlobalContext(runtime::WfRuntimeGlobalContext* _globalContext);
				void									Load(reflection::description::ITypeManager* manager)override;
				void									Unload(reflection::description::ITypeManager* manager)override;
			};
		}
	}
}

#endif

/***********************************************************************
RUNTIME\WFRUNTIMEASSEMBLY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Runtime

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_RUNTIME_WFRUNTIMEASSEMBLY
#define VCZH_WORKFLOW_RUNTIME_WFRUNTIMEASSEMBLY


namespace vl
{
	namespace workflow
	{
		namespace runtime
		{

/***********************************************************************
Assembly
***********************************************************************/

			/// <summary>Representing a compiled function.</summary>
			class WfAssemblyFunction : public Object
			{
			public:
				/// <summary>Name of the function.</summary>
				WString												name;
				/// <summary>Argument names of the function. This index is for accessing [F:vl.workflow.runtime.WfRuntimeVariableContext.variables] in [F:vl.workflow.runtime.WfRuntimeCallStackInfo.arguments] when debugging.</summary>
				collections::List<WString>							argumentNames;
				/// <summary>Captured variable names of the function. This index is for accessing [F:vl.workflow.runtime.WfRuntimeVariableContext.variables] in [F:vl.workflow.runtime.WfRuntimeCallStackInfo.captured] when debugging.</summary>
				collections::List<WString>							capturedVariableNames;
				/// <summary>Local variable names of the function. This index is for accessing [F:vl.workflow.runtime.WfRuntimeVariableContext.variables] in [F:vl.workflow.runtime.WfRuntimeCallStackInfo.localVariables] when debugging.</summary>
				collections::List<WString>							localVariableNames;
				/// <summary>First instruction index of the function. This index is for accessing [F:vl.workflow.runtime.WfAssembly.instructions].</summary>
				vint												firstInstruction = -1;
				/// <summary>Last instruction index of the function. This index is for accessing [F:vl.workflow.runtime.WfAssembly.instructions].</summary>
				vint												lastInstruction = -1;
			};

			/// <summary>Representing debug informations.</summary>
			class WfInstructionDebugInfo : public Object
			{
			public:

				/// <summary>Module codes.</summary>
				collections::List<WString>							moduleCodes;				// codeIndex -> code
				/// <summary>Mapping information from every instruction to code. Use[F:vl.parsing.ParsingTextRange.codeIndex] for accessing <see cref="moduleCodes"/>.</summary>
				collections::List<parsing::ParsingTextRange>		instructionCodeMapping;		// instruction -> range
				/// <summary>Mapping information from every row in codes to instructions. Value of the key is (codeIndex, row).</summary>
				collections::Group<Tuple<vint, vint>, vint>			codeInstructionMapping;		// (codeIndex, row) -> instruction [generated]

				void												Initialize();
			};

			/// <summary>Representing a Workflow assembly.</summary>
			class WfAssembly : public Object, public reflection::Description<WfAssembly>
			{
			protected:
				template<typename TIO>
				void IO(TIO& io);
			public:
				/// <summary>Debug informations using the module code.</summary>
				Ptr<WfInstructionDebugInfo>							insBeforeCodegen;
				/// <summary>Debug informations using the module code from generated syntax trees from the final compiling pass.</summary>
				Ptr<WfInstructionDebugInfo>							insAfterCodegen;
				/// <summary>Global variable names. This index is for accessing [F:vl.workflow.runtime.WfRuntimeVariableContext.variables] in [F:vl.workflow.runtime.WfRuntimeCallStackInfo.global] when debugging.</summary>
				collections::List<WString>							variableNames;
				/// <summary>Mapping from function names to function indexes for accessing <see cref="functions"/>.</summary>
				collections::Group<WString, vint>					functionByName;
				/// <summary>Functions.</summary>
				collections::List<Ptr<WfAssemblyFunction>>			functions;
				/// <summary>Instructions.</summary>
				collections::List<WfInstruction>					instructions;
				/// <summary>Custom types.</summary>
				Ptr<typeimpl::WfTypeImpl>							typeImpl;

				/// <summary>Create an empty assembly.</summary>
				WfAssembly();
				/// <summary>Deserialize an assembly.</summary>
				/// <param name="input">Serialized binary data.</param>
				WfAssembly(stream::IStream& input);
				
				void												Initialize();
				/// <summary>Serialize an assembly.</summary>
				/// <param name="output">Serialized binary data.</param>
				void												Serialize(stream::IStream& output);
			};
		}
	}
}

#endif

/***********************************************************************
RUNTIME\WFRUNTIMECONSTRUCTIONS.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Runtime

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_RUNTIME_WFRUNTIMECONSTRUCTIONS
#define VCZH_WORKFLOW_RUNTIME_WFRUNTIMECONSTRUCTIONS


namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			class WfRuntimeGlobalContext;
			class WfRuntimeVariableContext;
			
/***********************************************************************
Range
***********************************************************************/

			template<typename T>
			class WfRuntimeRange : public Object, public reflection::description::IValueEnumerable
			{
			protected:
				T						begin;
				T						end;

				class Enumerator : public Object, public reflection::description::IValueEnumerator
				{
				protected:
					T					begin;
					T					end;
					T					current;
				public:
					Enumerator(T _begin, T _end)
						:begin(_begin), end(_end), current(_begin - 1)
					{
					}

					reflection::description::Value GetCurrent()
					{
						return reflection::description::BoxValue<T>(current);
					}

					vint GetIndex()
					{
						return (vint)(current - begin);
					}

					bool Next()
					{
						if (current >= end) return false;
						current++;
						return true;
					}
				};
			public:
				WfRuntimeRange(T _begin, T _end)
					:begin(_begin), end(_end)
				{
				}

				Ptr<reflection::description::IValueEnumerator> CreateEnumerator()override
				{
					return MakePtr<Enumerator>(begin, end);
				}
			};
			
/***********************************************************************
ReverseEnumerable
***********************************************************************/

			class WfRuntimeReverseEnumerable : public Object, public reflection::description::IValueEnumerable
			{
			protected:
				Ptr<reflection::description::IValueList>		list;

				class Enumerator : public Object, public reflection::description::IValueEnumerator
				{
				protected:
					Ptr<reflection::description::IValueList>	list;
					vint										index;

				public:
					Enumerator(Ptr<reflection::description::IValueList> _list);
					reflection::description::Value				GetCurrent();
					vint										GetIndex();
					bool										Next();
				};

			public:
				WfRuntimeReverseEnumerable(Ptr<reflection::description::IValueList> _list);

				Ptr<reflection::description::IValueEnumerator>	CreateEnumerator()override;
			};
			
/***********************************************************************
Lambda
***********************************************************************/

			class WfRuntimeLambda : public Object, public reflection::description::IValueFunctionProxy
			{
			public:
				Ptr<WfRuntimeGlobalContext>			globalContext;
				Ptr<WfRuntimeVariableContext>		capturedVariables;
				vint								functionIndex;

				WfRuntimeLambda(Ptr<WfRuntimeGlobalContext> _globalContext, Ptr<WfRuntimeVariableContext> _capturedVariables, vint _functionIndex);

				reflection::description::Value		Invoke(Ptr<reflection::description::IValueList> arguments)override;
			};
			
/***********************************************************************
InterfaceInstance
***********************************************************************/

			class WfRuntimeInterfaceInstance : public Object, public reflection::description::IValueInterfaceProxy
			{
				typedef collections::Dictionary<WString, Ptr<reflection::description::IValueFunctionProxy>>		FunctionMap;
			public:
				FunctionMap							functions;

				reflection::description::Value		Invoke(const WString& name, Ptr<reflection::description::IValueList> arguments)override;
			};
		}
	}
}

#endif

/***********************************************************************
RUNTIME\WFRUNTIMEDEBUGGER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Runtime

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_RUNTIME_WFRUNTIMEDEBUGGER
#define VCZH_WORKFLOW_RUNTIME_WFRUNTIMEDEBUGGER


namespace vl
{
	namespace workflow
	{
		namespace runtime
		{
			class WfRuntimeThreadContext;
			class WfRuntimeExceptionInfo;
			class IWfDebuggerCallback;
			class WfDebugger;

/***********************************************************************
Debugger
***********************************************************************/

			/// <summary>Break point action.</summary>
			class IWfBreakPointAction : public virtual Interface
			{
			public:
				/// <summary>Called a break point is about to activate.</summary>
				/// <returns>Returns false to skip this break point.</returns>
				/// <param name="debugger">The current attached debugger.</param>
				virtual bool					EvaluateCondition(WfDebugger* debugger) = 0;
				/// <summary>Called when a break point is about to activate, even <see cref="EvaluateCondition"/> returns false.</summary>
				/// <param name="debugger">The current attached debugger.</param>
				virtual void					PostAction(WfDebugger* debugger) = 0;
			};

			/// <summary>Break point.</summary>
			struct WfBreakPoint
			{
				enum Type
				{
					Instruction,	// assembly, instruction
					ReadGlobalVar,	// assembly, variable
					WriteGlobalVar,	// assembly, variable
					GetProperty,	// [thisObject], propertyInfo
					SetProperty,	// [thisObject], propertyInfo
					AttachEvent,	// [thisObject], eventInfo
					DetachEvent,	// [thisObject], eventInfo
					InvokeMethod,	// [thisObject], methodInfo
					CreateObject,	// typeDescriptor
				};

				vint											id = -1;
				bool											available = false;
				bool											enabled = false;
				Ptr<IWfBreakPointAction>						action;

				Type											type;
				WfAssembly*										assembly = nullptr;
				union
				{
					vint										instruction = -1;
					vint										variable;
				};

				reflection::DescriptableObject*					thisObject = nullptr;
				union
				{
					reflection::description::IPropertyInfo*		propertyInfo = nullptr;
					reflection::description::IEventInfo*		eventInfo;
					reflection::description::IMethodInfo*		methodInfo;
					reflection::description::ITypeDescriptor*	typeDescriptor;
				};

				/// <summary>Create an instruction break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="assembly">The assembly that contains the instruction.</param>
				/// <param name="instruction">The index of the instruction.</param>
				static WfBreakPoint								Ins(WfAssembly* assembly, vint instruction);
				
				/// <summary>Create an global variable reading break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="assembly">The assembly that contains the instruction.</param>
				/// <param name="variable">The index of the global variable.</param>
				static WfBreakPoint								Read(WfAssembly* assembly, vint variable);
				
				/// <summary>Create an global variable writing break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="assembly">The assembly that contains the instruction.</param>
				/// <param name="variable">The index of the global variable.</param>
				static WfBreakPoint								Write(WfAssembly* assembly, vint variable);
				
				/// <summary>Create an property reading break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="thisObject">The target object. Set to null to apply to every object.</param>
				/// <param name="propertyInfo">The property.</param>
				static WfBreakPoint								Get(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo);
				
				/// <summary>Create an property writing break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="thisObject">The target object. Set to null to apply to every object.</param>
				/// <param name="propertyInfo">The property.</param>
				static WfBreakPoint								Set(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo);
				
				/// <summary>Create an event attaching break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="thisObject">The target object. Set to null to apply to every object.</param>
				/// <param name="eventInfo">The event.</param>
				static WfBreakPoint								Attach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo);
				
				/// <summary>Create an event detaching break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="thisObject">The target object. Set to null to apply to every object.</param>
				/// <param name="eventInfo">The event.</param>
				static WfBreakPoint								Detach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo);
				
				/// <summary>Create an function invoking break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="thisObject">The target object. Set to null to apply to every object.</param>
				/// <param name="methodInfo">The function.</param>
				static WfBreakPoint								Invoke(reflection::DescriptableObject* thisObject, reflection::description::IMethodInfo* methodInfo);
				
				/// <summary>Create an object creating break point.</summary>
				/// <returns>The created break point.</returns>
				/// <param name="typeDescriptor">The target object type.</param>
				static WfBreakPoint								Create(reflection::description::ITypeDescriptor* typeDescriptor);
			};

			class IWfDebuggerCallback : public virtual Interface
			{
			public:
				virtual void					EnterThreadContext(WfRuntimeThreadContext* context) = 0;
				virtual void					LeaveThreadContext(WfRuntimeThreadContext* context) = 0;
				virtual bool					BreakIns(WfAssembly* assembly, vint instruction) = 0;
				virtual bool					BreakRead(WfAssembly* assembly, vint variable) = 0;
				virtual bool					BreakWrite(WfAssembly* assembly, vint variable) = 0;
				virtual bool					BreakGet(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo) = 0;
				virtual bool					BreakSet(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo) = 0;
				virtual bool					BreakAttach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo) = 0;
				virtual bool					BreakDetach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo) = 0;
				virtual bool					BreakInvoke(reflection::DescriptableObject* thisObject, reflection::description::IMethodInfo* methodInfo) = 0;
				virtual bool					BreakCreate(reflection::description::ITypeDescriptor* typeDescriptor) = 0;
				virtual bool					BreakException(Ptr<WfRuntimeExceptionInfo> info) = 0;
				virtual bool					WaitForContinue() = 0;
			};

			/// <summary>Workflow debugger.</summary>
			class WfDebugger : public Object, protected virtual IWfDebuggerCallback
			{
				friend IWfDebuggerCallback* GetDebuggerCallback(WfDebugger* debugger);

				typedef collections::List<WfBreakPoint>					BreakPointList;
				typedef collections::List<WfRuntimeThreadContext*>		ThreadContextList;

				typedef Tuple<WfAssembly*, vint>														AssemblyKey;
				typedef Tuple<reflection::DescriptableObject*, reflection::description::IPropertyInfo*>	PropertyKey;
				typedef Tuple<reflection::DescriptableObject*, reflection::description::IEventInfo*>	EventKey;
				typedef Tuple<reflection::DescriptableObject*, reflection::description::IMethodInfo*>	MethodKey;
				typedef reflection::description::ITypeDescriptor*										TypeKey;

				typedef collections::Dictionary<AssemblyKey, vint>		AssemblyBreakPointMap;
				typedef collections::Dictionary<PropertyKey, vint>		PropertyBreakPointMap;
				typedef collections::Dictionary<EventKey, vint>			EventBreakPointMap;
				typedef collections::Dictionary<MethodKey, vint>		MethodBreakPointMap;
				typedef collections::Dictionary<TypeKey, vint>			TypeBreakPointMap;
			public:
				enum State
				{						//		Run		Pause	Stop	StepOver	StepInto
					Running,			// R			*RTP	*RTS
					PauseByOperation,	// PBO	*C				*RTS	*C			*C
					PauseByBreakPoint,	// PBB	*C				*RTS	*C			*C
					Stopped,			// S			*RTP			*			*
					Continue,			// C	soon becomes Running
					RequiredToPause,	// RTP	soon becomes PauseByOperation
					RequiredToStop,		// RTS	soon becomes Stop
				};

				enum RunningType
				{
					RunUntilBreakPoint,
					RunStepOver,
					RunStepInto,
				};

				struct InstructionLocation
				{
					vint								contextIndex = -1;
					WfAssembly*							assembly = nullptr;
					vint								stackFrameIndex = -1;
					vint								instruction = -1;

					bool								BreakStepOver(const InstructionLocation& il, bool beforeCodegen);
					bool								BreakStepInto(const InstructionLocation& il, bool beforeCodegen);
				};

				static const vint						InvalidBreakPoint = -1;
				static const vint						PauseBreakPoint = -2;
			protected:
				BreakPointList							breakPoints;
				collections::List<vint>					freeBreakPointIndices;
				volatile bool							evaluatingBreakPoint = false;
				volatile bool							breakException = false;

				ThreadContextList						threadContexts;

				volatile State							state = Stopped;
				volatile RunningType					runningType = RunUntilBreakPoint;
				volatile vint							lastActivatedBreakPoint = InvalidBreakPoint;
				bool									stepBeforeCodegen = true;
				InstructionLocation						instructionLocation;

				AssemblyBreakPointMap					insBreakPoints;
				AssemblyBreakPointMap					getGlobalVarBreakPoints;
				AssemblyBreakPointMap					setGlobalVarBreakPoints;
				PropertyBreakPointMap					getPropertyBreakPoints;
				PropertyBreakPointMap					setPropertyBreakPoints;
				EventBreakPointMap						attachEventBreakPoints;
				EventBreakPointMap						detachEventBreakPoints;
				MethodBreakPointMap						invokeMethodBreakPoints;
				TypeBreakPointMap						createObjectBreakPoints;

				/// <summary>Called for doing something when a break point is activated. This function will be called multiple times before some one let the debugger to continue.</summary>
				virtual void							OnBlockExecution();
				/// <summary>Called when a new Workflow program is about to run.</summary>
				virtual void							OnStartExecution();
				/// <summary>Called when a Workflow program is stopped by any reason.</summary>
				virtual void							OnStopExecution();
				
				InstructionLocation						MakeCurrentInstructionLocation();
				template<typename TKey>
				bool									HandleBreakPoint(const TKey& key, collections::Dictionary<TKey, vint>& breakPointMap);
				bool									SetBreakPoint(const WfBreakPoint& breakPoint, bool available, vint index);
				
				void									EnterThreadContext(WfRuntimeThreadContext* context)override;
				void									LeaveThreadContext(WfRuntimeThreadContext* context)override;
				bool									BreakIns(WfAssembly* assembly, vint instruction)override;
				bool									BreakRead(WfAssembly* assembly, vint variable)override;
				bool									BreakWrite(WfAssembly* assembly, vint variable)override;
				bool									BreakGet(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo)override;
				bool									BreakSet(reflection::DescriptableObject* thisObject, reflection::description::IPropertyInfo* propertyInfo)override;
				bool									BreakAttach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo)override;
				bool									BreakDetach(reflection::DescriptableObject* thisObject, reflection::description::IEventInfo* eventInfo)override;
				bool									BreakInvoke(reflection::DescriptableObject* thisObject, reflection::description::IMethodInfo* methodInfo)override;
				bool									BreakCreate(reflection::description::ITypeDescriptor* typeDescriptor)override;
				bool									BreakException(Ptr<WfRuntimeExceptionInfo> info)override;
				bool									WaitForContinue()override;
			public:
				/// <summary>Create a debugger.</summary>
				WfDebugger();
				~WfDebugger();

				/// <summary>Add a new break point.</summary>
				/// <returns>Returns the index of this break point. Returns -1 if failed.</returns>
				/// <param name="breakPoint">The break point.</param>
				vint									AddBreakPoint(const WfBreakPoint& breakPoint);
				/// <summary>Add a new source code break point.</summary>
				/// <returns>Returns the index of this break point. Returns -1 if failed.</returns>
				/// <param name="assembly">The assembly.</param>
				/// <param name="codeIndex">The code index of a module.</param>
				/// <param name="row">The row number, starts from 0.</param>
				/// <param name="beforeCodegen">Set to true to apply source code information to original source code.</param>
				vint									AddCodeLineBreakPoint(WfAssembly* assembly, vint codeIndex, vint row, bool beforeCodegen = true);
				/// <summary>Get the number of all break points.</summary>
				/// <returns>The number of all break points.</returns>
				vint									GetBreakPointCount();
				/// <summary>Get a specified break point.</summary>
				/// <returns>The break point.</returns>
				/// <param name="index">The index of the break point.</param>
				const WfBreakPoint&						GetBreakPoint(vint index);
				/// <summary>Delete a specified break point.</summary>
				/// <returns>Returns true if this operation is succeeded.</returns>
				/// <param name="index">The index of the break point.</param>
				bool									RemoveBreakPoint(vint index);
				/// <summary>Enable or disable a specified break point.</summary>
				/// <returns>Returns true if this operation is succeeded.</returns>
				/// <param name="index">The index of the break point.</param>
				/// <param name="enabled">Set to true to enable a break point.</param>
				bool									EnableBreakPoint(vint index, bool enabled);
				/// <summary>Test if the exception break point is enabled or not.</summary>
				/// <returns>Returns true if the exception break point is enabled.</returns>
				bool									GetBreakException();
				/// <summary>Enable or disable the exception break point.</summary>
				/// <param name="value">Set to true to enable the exception break point.</param>
				void									SetBreakException(bool value);

				/// <summary>Continue to run the Workflow program.</summary>
				/// <returns>Returns true if this operation is succeeded.</returns>
				bool									Run();
				/// <summary>Pause the Workflow program.</summary>
				/// <returns>Returns true if this operation is succeeded.</returns>
				bool									Pause();
				/// <summary>Stop the Workflow program.</summary>
				/// <returns>Returns true if this operation is succeeded.</returns>
				bool									Stop();
				/// <summary>Run until reached the next row in the same function or outside of this function.</summary>
				/// <returns>Returns true if this operation is succeeded.</returns>
				/// <param name="beforeCodegen">Set to true to apply the source code information to original source code.</param>
				bool									StepOver(bool beforeCodegen = true);
				/// <summary>Run until reached the next row.</summary>
				/// <returns>Returns true if this operation is succeeded.</returns>
				/// <param name="beforeCodegen">Set to true to apply the source code information to original source code.</param>
				bool									StepInto(bool beforeCodegen = true);
				/// <summary>Get the current state of the debugger.</summary>
				/// <returns>The state of the debugger.</returns>
				State									GetState();
				/// <summary>Get the running type of the debugger.</summary>
				/// <returns>The running type of the debugger.</returns>
				RunningType								GetRunningType();
				/// <summary>Get the index of the last activated break point.</summary>
				/// <returns>The index of the last activated break point.</returns>
				vint									GetLastActivatedBreakPoint();

				const ThreadContextList&				GetThreadContexts();
				WfRuntimeThreadContext*					GetCurrentThreadContext();
				/// <summary>Get the current position of the executing instruction in the source code.</summary>
				/// <returns>The current position in the source code.</returns>
				/// <param name="beforeCodegen">Set to true to apply the source code information to original source code.</param>
				/// <param name="context">Specify a thread context. Set to null to use the top thread context.</param>
				/// <param name="callStackIndex">Specify a call stack index. Set to null to use the top call stack item of the specified thread context.</param>
				const parsing::ParsingTextRange&		GetCurrentPosition(bool beforeCodegen = true, WfRuntimeThreadContext* context = nullptr, vint callStackIndex = -1);
				/// <summary>Get the variable value by name in the current scope.</summary>
				/// <returns>The value.</returns>
				/// <param name="name">The name.</param>
				/// <param name="context">Specify a thread context. Set to null to use the top thread context.</param>
				/// <param name="callStackIndex">Specify a call stack index. Set to null to use the top call stack item of the specified thread context.</param>
				reflection::description::Value			GetValueByName(const WString& name, WfRuntimeThreadContext* context = nullptr, vint callStackIndex = -1);
			};

			extern IWfDebuggerCallback*					GetDebuggerCallback();
			extern IWfDebuggerCallback*					GetDebuggerCallback(WfDebugger* debugger);
			
			/// <summary>Get the debugger for the current thread.</summary>
			/// <returns>The debugger.</returns>
			extern Ptr<WfDebugger>						GetDebuggerForCurrentThread();
			/// <summary>Set the debugger for the current thread.</summary>
			/// <param name="debugger">The debugger.</param>
			extern void									SetDebuggerForCurrentThread(Ptr<WfDebugger> debugger);
		}
	}
}

#endif

/***********************************************************************
RUNTIME\WFRUNTIME.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Runtime

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_RUNTIME_WFRUNTIME
#define VCZH_WORKFLOW_RUNTIME_WFRUNTIME


namespace vl
{
	namespace workflow
	{
		namespace runtime
		{

/***********************************************************************
RuntimeEnvironment
***********************************************************************/

			class WfRuntimeVariableContext : public Object
			{
				typedef collections::Array<reflection::description::Value>		VariableArray;

			public:
				VariableArray					variables;
			};

			/// <summary>Global context for executing a Workflow program. After the context is prepared, use [M:vl.workflow.runtime.LoadFunction] to call any functions inside the assembly. Function "&lt;initialize&gt;" should be the first to execute.</summary>
			class WfRuntimeGlobalContext : public Object, public reflection::Description<WfRuntimeGlobalContext>
			{
			public:
				Ptr<WfAssembly>					assembly;
				Ptr<WfRuntimeVariableContext>	globalVariables;
				
				/// <summary>Create a global context for executing a Workflow program.</summary>
				/// <param name="_assembly">The assembly.</param>
				WfRuntimeGlobalContext(Ptr<WfAssembly> _assembly);
				~WfRuntimeGlobalContext();
			};

			struct WfRuntimeStackFrame
			{
				Ptr<WfRuntimeVariableContext>	capturedVariables;
				vint							functionIndex = -1;
				vint							nextInstructionIndex = -1;
				vint							stackBase = 0;
				vint							fixedVariableCount = 0;
				vint							freeStackBase = 0;
			};

			struct WfRuntimeTrapFrame
			{
				vint							stackFrameIndex = -1;
				vint							instructionIndex = -1;
				vint							stackPatternCount = -1;
			};

/***********************************************************************
RuntimeException
***********************************************************************/

			/// <summary>Representing a call stack item.</summary>
			class WfRuntimeCallStackInfo : public Object, public virtual reflection::description::IValueCallStack
			{
				using IValueReadonlyDictionary = reflection::description::IValueReadonlyDictionary;
			protected:
				Ptr<IValueReadonlyDictionary>	cachedLocalVariables;
				Ptr<IValueReadonlyDictionary>	cachedLocalArguments;
				Ptr<IValueReadonlyDictionary>	cachedCapturedVariables;
				Ptr<IValueReadonlyDictionary>	cachedGlobalVariables;

				Ptr<IValueReadonlyDictionary>	GetVariables(collections::List<WString>& names, Ptr<WfRuntimeVariableContext> context, Ptr<IValueReadonlyDictionary>& cache);
			public:
				WfRuntimeCallStackInfo();
				WfRuntimeCallStackInfo(WfRuntimeThreadContext* context, const WfRuntimeStackFrame& stackFrame);
				~WfRuntimeCallStackInfo();

				/// <summary>The executing assembly.</summary>
				Ptr<WfAssembly>					assembly;
				/// <summary>Global variable values.</summary>
				Ptr<WfRuntimeVariableContext>	global;
				/// <summary>Captured variable values.</summary>
				Ptr<WfRuntimeVariableContext>	captured;
				/// <summary>Argument values.</summary>
				Ptr<WfRuntimeVariableContext>	arguments;
				/// <summary>Local variable values.</summary>
				Ptr<WfRuntimeVariableContext>	localVariables;
				/// <summary>The executing function.</summary>
				vint							functionIndex = -1;
				/// <summary>The executing instruction.</summary>
				vint							instruction = -1;

				Ptr<IValueReadonlyDictionary>	GetLocalVariables()override;
				Ptr<IValueReadonlyDictionary>	GetLocalArguments()override;
				Ptr<IValueReadonlyDictionary>	GetCapturedVariables()override;
				Ptr<IValueReadonlyDictionary>	GetGlobalVariables()override;

				/// <summary>Get the name of the executing function.</summary>
				/// <returns>The name of the execution function.</returns>
				WString							GetFunctionName()override;
				/// <summary>Get the source code of the executing module.</summary>
				/// <returns>The source code.</returns>
				WString							GetSourceCodeBeforeCodegen()override;
				/// <summary>Get the source code of the executing module from generated syntax trees from the final compiling pass.</summary>
				/// <returns>The source code.</returns>
				WString							GetSourceCodeAfterCodegen()override;
				/// <summary>Get the row number (starts at 0) of the source code of the executing module.</summary>
				/// <returns>The row number.</returns>
				vint							GetRowBeforeCodegen()override;
				/// <summary>Get the row number (starts at 0) of the source code of the executing module from generated syntax trees from the final compiling pass.</summary>
				/// <returns>The row number.</returns>
				vint							GetRowAfterCodegen()override;
			};
			
			/// <summary>Representing an raised exception.</summary>
			class WfRuntimeExceptionInfo : public Object, public virtual reflection::description::IValueException
			{
				typedef collections::List<Ptr<WfRuntimeCallStackInfo>>		CallStackList;
				using IValueReadonlyList = reflection::description::IValueReadonlyList;
			protected:
				Ptr<IValueReadonlyList>			cachedCallStack;

			public:
				/// <summary>Exception message.</summary>
				WString							message;
				/// <summary>Fatal error flag.</summary>
				bool							fatal = false;
				/// <summary>All call stack items.</summary>
				CallStackList					callStack;

				WfRuntimeExceptionInfo(const WString& _message, bool _fatal);
				~WfRuntimeExceptionInfo();
				
#pragma push_macro("GetMessage")
#if defined GetMessage
#undef GetMessage
#endif
				WString							GetMessage()override;
#pragma pop_macro("GetMessage")
				bool							GetFatal()override;
				Ptr<IValueReadonlyList>			GetCallStack()override;
			};
			
			/// <summary>Representing an raised exception object for upper level C++ code.</summary>
			class WfRuntimeException : public reflection::description::TypeDescriptorException
			{
			protected:
				Ptr<WfRuntimeExceptionInfo>		info;
				bool							fatal = false;
			public:
				WfRuntimeException(Ptr<WfRuntimeExceptionInfo> _info)
					:reflection::description::TypeDescriptorException(_info->message)
					, info(_info)
					, fatal(_info->fatal)
				{
				}

				WfRuntimeException(const WString& _message, bool _fatal)
					:reflection::description::TypeDescriptorException(_message)
					, fatal(_fatal)
				{
				}

				/// <summary>Get the detailed information.</summary>
				/// <returns>The detailed information.</returns>
				Ptr<WfRuntimeExceptionInfo> GetInfo()const
				{
					return info;
				}

				/// <summary>Get the fatal error flag.</summary>
				/// <returns>Returns true if this exception is a fatal error, which normally means state corruption in a Workflow runtime.</returns>
				bool IsFatal()const
				{
					return fatal;
				}
			};

/***********************************************************************
RuntimeThreadContext
***********************************************************************/

			enum class WfRuntimeExecutionStatus
			{
				Ready,
				Executing,
				RaisedException,
				Finished,
				FatalError,
			};

			enum class WfRuntimeExecutionAction
			{
				ExecuteInstruction,
				UnwrapStack,
				EnterStackFrame,
				ExitStackFrame,
				Nop,
			};

			enum class WfRuntimeThreadContextError
			{
				Success,
				WrongStackItemIndex,
				WrongVariableIndex,
				WrongFunctionIndex,
				WrongArgumentCount,
				WrongCapturedVariableCount,
				EmptyStackFrame,
				EmptyTrapFrame,
				EmptyStack,
				TrapFrameCorrupted,
				StackCorrupted,
			};

			class WfRuntimeThreadContext
			{
				typedef collections::List<reflection::description::Value>		VariableList;
				typedef collections::List<WfRuntimeStackFrame>					StackFrameList;
				typedef collections::List<WfRuntimeTrapFrame>					TrapFrameList;
			public:

				Ptr<WfRuntimeGlobalContext>		globalContext;
				Ptr<WfRuntimeExceptionInfo>		exceptionInfo;
				VariableList					stack;
				StackFrameList					stackFrames;
				TrapFrameList					trapFrames;
				WfRuntimeExecutionStatus		status = WfRuntimeExecutionStatus::Finished;

				WfRuntimeThreadContext(Ptr<WfRuntimeGlobalContext> _context);
				WfRuntimeThreadContext(Ptr<WfAssembly> _assembly);

				WfRuntimeStackFrame&			GetCurrentStackFrame();
				WfRuntimeThreadContextError		PushStackFrame(vint functionIndex, vint argumentCount, Ptr<WfRuntimeVariableContext> capturedVariables = 0);
				WfRuntimeThreadContextError		PopStackFrame();
				WfRuntimeTrapFrame&				GetCurrentTrapFrame();
				WfRuntimeThreadContextError		PushTrapFrame(vint instructionIndex);
				WfRuntimeThreadContextError		PopTrapFrame(vint saveStackPatternCount);
				WfRuntimeThreadContextError		PushValue(const reflection::description::Value& value);
				WfRuntimeThreadContextError		PopValue(reflection::description::Value& value);
				WfRuntimeThreadContextError		RaiseException(const WString& exception, bool fatalError, bool skipDebugger = false);
				WfRuntimeThreadContextError		RaiseException(Ptr<WfRuntimeExceptionInfo> info, bool skipDebugger = false);

				WfRuntimeThreadContextError		LoadStackValue(vint stackItemIndex, reflection::description::Value& value);
				WfRuntimeThreadContextError		LoadGlobalVariable(vint variableIndex, reflection::description::Value& value);
				WfRuntimeThreadContextError		StoreGlobalVariable(vint variableIndex, const reflection::description::Value& value);
				WfRuntimeThreadContextError		LoadCapturedVariable(vint variableIndex, reflection::description::Value& value);
				WfRuntimeThreadContextError		LoadLocalVariable(vint variableIndex, reflection::description::Value& value);
				WfRuntimeThreadContextError		StoreLocalVariable(vint variableIndex, const reflection::description::Value& value);

				WfRuntimeExecutionAction		ExecuteInternal(WfInstruction& ins, WfRuntimeStackFrame& stackFrame, IWfDebuggerCallback* callback);
				WfRuntimeExecutionAction		Execute(IWfDebuggerCallback* callback);
				void							ExecuteToEnd();
			};

/***********************************************************************
Helper Functions
***********************************************************************/
			
			/// <summary>Load a function from a global context, raise an exception if multiple functions are found under the same name. Function "&gt;initialize&lt;" should be the first to execute.</summary>
			/// <returns>The loaded function.</returns>
			/// <param name="context">The context to the evaluation environment.</param>
			/// <param name="name">The function name.</param>
			extern Ptr<reflection::description::IValueFunctionProxy>		LoadFunction(Ptr<WfRuntimeGlobalContext> context, const WString& name);
			
			/// <summary>Load a C++ friendly function from a global context, raise an exception if multiple functions are found under the same name. Function "&gt;initialize&lt;" should be the first to execute.</summary>
			/// <typeparam name="TFunction">Type of the function.</typeparam>
			/// <returns>The loaded C++ friendly function.</returns>
			/// <param name="context">The context to the evaluation environment.</param>
			/// <param name="name">The function name.</param>
			template<typename TFunction>
			Func<TFunction> LoadFunction(Ptr<WfRuntimeGlobalContext> context, const WString& name)
			{
				auto proxy = LoadFunction(context, name);
				Func<TFunction> function;
				reflection::description::UnboxParameter<Func<TFunction>>(reflection::description::Value::From(proxy), function);
				return function;
			}
		}
	}
}

#endif

/***********************************************************************
ANALYZER\WFANALYZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Analyzer

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_ANALYZER_WFANALYZER
#define VCZH_WORKFLOW_ANALYZER_WFANALYZER


namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{

			class WfLexicalSymbol;
			class WfLexicalScope;
			class WfLexicalScopeManager;

/***********************************************************************
Scope
***********************************************************************/

			class WfLexicalSymbol : public Object
			{
			public:
				WString										name;				// name of this symbol
				Ptr<WfType>									type;				// type of this symbol
				Ptr<reflection::description::ITypeInfo>		typeInfo;			// reflection type info of this symbol, nullable
				Ptr<WfDeclaration>							creatorDeclaration;	// nullable
				Ptr<WfStatement>							creatorStatement;	// nullable
				Ptr<WfExpression>							creatorExpression;	// nullable
				Ptr<WfFunctionArgument>						creatorArgument;	// nullable
				WfLexicalScope*								ownerScope;			// scope that contains this symbol

				WfLexicalSymbol(WfLexicalScope* _ownerScope);
				~WfLexicalSymbol();
				
				WString										GetFriendlyName();
			};

			class WfLexicalScope : public Object
			{
				typedef collections::Group<WString, Ptr<WfLexicalSymbol>>		TypeGroup;
			public:
				WfLexicalScopeManager*						ownerManager;		// nullable and inheritable
				Ptr<WfModule>								ownerModule;		// nullable and inheritable
				Ptr<WfClassMember>							ownerClassMember;	// nullable and inheritable
				Ptr<WfDeclaration>							ownerDeclaration;	// nullable and inheritable
				Ptr<WfStatement>							ownerStatement;		// nullable
				Ptr<WfExpression>							ownerExpression;	// nullable

				Ptr<WfLexicalScope>							parentScope;		// null means that this is the root scope
				TypeGroup									symbols;			// all symbols in this scope

				WfLexicalScope(WfLexicalScopeManager* _ownerManager);
				WfLexicalScope(Ptr<WfLexicalScope> _parentScope);
				~WfLexicalScope();

				WfLexicalScopeManager*						FindManager();
				Ptr<WfModule>								FindModule();
				Ptr<WfDeclaration>							FindDeclaration();
				WString										GetFriendlyName();
			};

/***********************************************************************
Scope Manager
***********************************************************************/

			class WfLexicalScopeName : public Object
			{
				typedef collections::Dictionary<WString, Ptr<WfLexicalScopeName>>		NameMap;
				typedef collections::List<Ptr<WfDeclaration>>							DeclarationList;
			public:
				WfLexicalScopeName*							parent;
				bool										createdByTypeDescriptor;
				NameMap										children;
				WString										name;
				reflection::description::ITypeDescriptor*	typeDescriptor;		// type that form this name
				DeclarationList								declarations;		// declarations that form this name

				WfLexicalScopeName(bool _createdByTypeDescriptor);
				~WfLexicalScopeName();

				Ptr<WfLexicalScopeName>						AccessChild(const WString& name, bool createdByTypeDescriptor);
				void										RemoveNonTypeDescriptorNames();
				WString										GetFriendlyName();
			};

			struct ResolveExpressionResult
			{
				Ptr<WfLexicalScopeName>						scopeName;
				Ptr<WfLexicalSymbol>						symbol;
				reflection::description::IPropertyInfo*		propertyInfo;
				reflection::description::IMethodInfo*		methodInfo;
				reflection::description::IEventInfo*		eventInfo;
				Ptr<reflection::description::ITypeInfo>		type;
				Ptr<reflection::description::ITypeInfo>		leftValueType;
				Ptr<reflection::description::ITypeInfo>		expectedType;

				ResolveExpressionResult();
				ResolveExpressionResult(Ptr<WfLexicalScopeName> _scopeName);
				ResolveExpressionResult(Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType = 0);
				ResolveExpressionResult(Ptr<WfLexicalSymbol> _symbol, Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType = 0);
				ResolveExpressionResult(reflection::description::IPropertyInfo* _propertyInfo, Ptr<reflection::description::ITypeInfo> _type, Ptr<reflection::description::ITypeInfo> _leftValueType = 0);
				ResolveExpressionResult(reflection::description::IMethodInfo* _methodInfo, Ptr<reflection::description::ITypeInfo> _type);
				ResolveExpressionResult(reflection::description::IEventInfo* _eventInfo);

				WString										GetFriendlyName()const;
			};

			/// <summary>Workflow compiler.</summary>
			class WfLexicalScopeManager : public Object
			{
				typedef reflection::description::ITypeDescriptor											ITypeDescriptor;
				typedef reflection::description::IMemberInfo												IMemberInfo;

				typedef collections::List<Ptr<WfModule>>													ModuleList;
				typedef collections::List<WString>															ModuleCodeList;
				typedef collections::List<Ptr<parsing::ParsingError>>										ParsingErrorList;
				typedef collections::Dictionary<Ptr<WfNamespaceDeclaration>, Ptr<WfLexicalScopeName>>		NamespaceNameMap;
				typedef collections::SortedList<Ptr<WfLexicalScope>>										ScopeSortedList;
				typedef collections::Dictionary<Ptr<WfModule>, Ptr<WfLexicalScope>>							ModuleScopeMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, Ptr<WfLexicalScope>>					DeclarationScopeMap;
				typedef collections::Dictionary<Ptr<WfStatement>, Ptr<WfLexicalScope>>						StatementScopeMap;
				typedef collections::Dictionary<Ptr<WfExpression>, Ptr<WfLexicalScope>>						ExpressionScopeMap;
				typedef collections::Dictionary<Ptr<WfExpression>, ResolveExpressionResult>					ExpressionResolvingMap;
				typedef collections::Group<WfFunctionDeclaration*, Ptr<WfLexicalSymbol>>					FunctionLambdaCaptureGroup;
				typedef collections::Group<WfOrderedLambdaExpression*, Ptr<WfLexicalSymbol>>				OrderedLambdaCaptureGroup;

				typedef collections::Dictionary<Ptr<WfDeclaration>, Ptr<ITypeDescriptor>>					DeclarationTypeMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, Ptr<IMemberInfo>>						DeclarationMemberInfoMap;

			protected:
				ModuleList									modules;
				ModuleCodeList								moduleCodes;
				vint										usedCodeIndex = 0;

			public:
				Ptr<parsing::tabling::ParsingTable>			parsingTable;
				ParsingErrorList							errors;

				Ptr<WfLexicalScopeName>						globalName;
				NamespaceNameMap							namespaceNames;
				ScopeSortedList								analyzedScopes;

				ModuleScopeMap								moduleScopes;				// the nearest scope for the module
				DeclarationScopeMap							declarationScopes;			// the nearest scope for the declaration
				StatementScopeMap							statementScopes;			// the nearest scope for the statement
				ExpressionScopeMap							expressionScopes;			// the nearest scope for the expression
				ExpressionResolvingMap						expressionResolvings;		// the resolving result for the expression
				FunctionLambdaCaptureGroup					functionLambdaCaptures;		// all captured symbols in an lambda expression
				OrderedLambdaCaptureGroup					orderedLambdaCaptures;		// all captured symbols in an lambda expression

				DeclarationTypeMap							declarationTypes;			// type descriptor for type declaration
				DeclarationMemberInfoMap					declarationMemberInfos;		// member for type description

				/// <summary>Create a Workflow compiler.</summary>
				/// <param name="_parsingTable">The workflow parser table. It can be retrived from [M:vl.workflow.WfLoadTable].</param>
				WfLexicalScopeManager(Ptr<parsing::tabling::ParsingTable> _parsingTable);
				~WfLexicalScopeManager();
				
				/// <summary>Add a Workflow module. Syntax errors can be found at <see cref="errors"/>.</summary>
				/// <param name="moduleCode">The source code of a workflow module.</param>
				/// <returns>Returns the code index, which is a number representing a module in data structured used in Workflow compiler, runtime and debugger.</returns>
				vint										AddModule(const WString& moduleCode);
				/// <summary>Add a Workflow module.</summary>
				/// <param name="module">The syntax tree of a workflow module.</param>
				/// <returns>Returns the code index, which is a number representing a module in data structured used in Workflow compiler, runtime and debugger.</returns>
				vint										AddModule(Ptr<WfModule> module);
				/// <summary>Get all added modules.</summary>
				/// <returns>All added modules.</returns>
				ModuleList&									GetModules();
				/// <summary>Get all module codes. If a module is added from a syntax tree, then the source code is empty.</summary>
				/// <returns>All module codes.</returns>
				ModuleCodeList&								GetModuleCodes();

				/// <summary>Clean compiling results.</summary>
				/// <param name="keepTypeDescriptorNames">Set to false to delete all cache of reflectable C++ types.</param>
				/// <param name="deleteModules">Set to true to delete all added modules.</param>
				void										Clear(bool keepTypeDescriptorNames, bool deleteModules);
				/// <summary>Compile.</summary>
				/// <param name="keepTypeDescriptorNames">Set to false to delete all cache of reflectable C++ types before compiling.</param>
				void										Rebuild(bool keepTypeDescriptorNames);
				void										ResolveSymbol(WfLexicalScope* scope, const WString& symbolName, collections::List<Ptr<WfLexicalSymbol>>& symbols);
				void										ResolveScopeName(WfLexicalScope* scope, const WString& symbolName, collections::List<Ptr<WfLexicalScopeName>>& names);
				Ptr<WfLexicalSymbol>						GetDeclarationSymbol(WfLexicalScope* scope, WfDeclaration* node);
			};

/***********************************************************************
Type Analyzing
***********************************************************************/

			enum class TypeFlag
			{
				Bool,
				I1,
				I2,
				I4,
				I8,
				U1,
				U2,
				U4,
				U8,
				F4,
				F8,
				String,
				Others,
				Count,
				Unknown = -1,
#ifdef VCZH_64
				I = I8,
				U = U8,
#else
				I = I4,
				U = U4,
#endif
			};

			extern TypeFlag									GetTypeFlag(reflection::description::ITypeDescriptor* typeDescriptor);
			extern TypeFlag									GetTypeFlag(reflection::description::ITypeInfo* typeInfo);
			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromTypeFlag(TypeFlag flag);

			extern Ptr<WfType>								GetTypeFromTypeInfo(reflection::description::ITypeInfo* typeInfo);
			extern Ptr<WfLexicalScopeName>					GetScopeNameFromReferenceType(WfLexicalScope* scope, Ptr<WfType> type);
			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromType(WfLexicalScope* scope, Ptr<WfType> type);

			extern Ptr<WfType>								CopyType(Ptr<WfType> type);
			extern Ptr<reflection::description::ITypeInfo>	CopyTypeInfo(reflection::description::ITypeInfo* typeInfo);
			extern bool										CanConvertToType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, bool explicitly);
			extern bool										IsSameType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
			extern Ptr<reflection::description::ITypeInfo>	GetMergedType(Ptr<reflection::description::ITypeInfo> firstType, Ptr<reflection::description::ITypeInfo> secondType);
			extern bool										IsNullAcceptableType(reflection::description::ITypeInfo* type);

			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromMethodInfo(reflection::description::IMethodInfo* info);

			extern bool										IsExpressionDependOnExpectedType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern WString									GetExpressionName(Ptr<WfExpression> expression);
			extern void										SearchOrderedName(WfLexicalScope* scope, Ptr<WfDeclaration> declaration, collections::SortedList<vint>& names);
			extern void										SearchOrderedName(WfLexicalScope* scope, Ptr<WfStatement> statement, collections::SortedList<vint>& names);
			extern void										SearchOrderedName(WfLexicalScope* scope, Ptr<WfExpression> expression, collections::SortedList<vint>& names);

/***********************************************************************
Structure Analyzing
***********************************************************************/
			
			struct ValidateStructureContext
			{
				WfBindExpression*							currentBindExpression;
				WfObserveExpression*						currentObserveExpression;
				WfStatement*								currentLoopStatement;
				WfStatement*								currentCatchStatement;

				ValidateStructureContext();
			};
			extern void										ValidateTypeStructure(WfLexicalScopeManager* manager, Ptr<WfType> type, bool returnType = false);
			extern void										ValidateModuleStructure(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ValidateDeclarationStructure(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration, WfClassDeclaration* classDecl = 0 , parsing::ParsingTreeCustomBase* source = 0);
			extern void										ValidateStatementStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfStatement>& statement);
			extern void										ValidateExpressionStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfExpression>& expression);

/***********************************************************************
Global Name
***********************************************************************/

			extern void										BuildGlobalNameFromTypeDescriptors(WfLexicalScopeManager* manager);
			extern void										BuildGlobalNameFromModules(WfLexicalScopeManager* manager);
			extern void										ValidateScopeName(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name);

/***********************************************************************
Scope Analyzing
***********************************************************************/
			
			extern void										CompleteScopeForClassMember(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member);
			extern void										CompleteScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration);
			extern void										CompleteScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module);

			extern void										BuildScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										BuildScopeForClassMember(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<typeimpl::WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member, parsing::ParsingTreeCustomBase* source = 0);
			extern void										BuildScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfDeclaration> declaration, parsing::ParsingTreeCustomBase* source = 0);
			extern void										BuildScopeForStatement(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement);
			extern void										BuildScopeForExpression(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression);
			extern bool										CheckScopes(WfLexicalScopeManager* manager);

/***********************************************************************
Semantic Analyzing
***********************************************************************/

			class WfObservingDependency : public Object
			{
				typedef collections::Group<WfExpression*, WfExpression*>			DependencyGroup;
				typedef collections::List<WfExpression*>							ObserveList;
			public:
				ObserveList							inputObserves;
				ObserveList							outputObserves;
				DependencyGroup&					dependencies;
				
				WfObservingDependency(WfObservingDependency& dependency);
				WfObservingDependency(DependencyGroup& _dependencies);
				WfObservingDependency(DependencyGroup& _dependencies, ObserveList& _inputObserves);
				
				void								Prepare(WfExpression* observe);
				void								AddInternal(WfExpression* observe, WfExpression* dependedObserve);
				void								Add(WfExpression* observe);
				void								Add(WfExpression* observe, WfObservingDependency& dependency);
				void								TurnToInput();
				void								Cleanup();
			};

			extern void										ValidateModuleSemantic(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ValidateClassMemberSemantic(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfClassMember> member);
			extern void										ValidateDeclarationSemantic(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration);
			extern void										ValidateStatementSemantic(WfLexicalScopeManager* manager, Ptr<WfStatement> statement);
			extern void										ValidateExpressionSemantic(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results);
			extern void										GetObservingDependency(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, WfObservingDependency& dependency);
			extern Ptr<WfExpression>						ExpandObserveExpression(WfExpression* expression, collections::Dictionary<WfExpression*, WString>& cacheNames, collections::Dictionary<WString, WString>& referenceReplacement, bool useCache = true);
			extern Ptr<WfExpression>						CopyExpression(Ptr<WfExpression> expression);
			extern Ptr<WfStatement>							CopyStatement(Ptr<WfStatement> statement);
			extern void										ExpandBindExpression(WfLexicalScopeManager* manager, WfBindExpression* node);

			extern Ptr<WfLexicalScopeName>					GetExpressionScopeName(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern reflection::description::IEventInfo*		GetExpressionEventInfo(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern void										GetExpressionTypes(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results);
			extern Ptr<reflection::description::ITypeInfo>	GetExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);
			extern Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);

/***********************************************************************
Code Generation
***********************************************************************/

			struct WfCodegenLambdaContext
			{
				WfFunctionDeclaration*				functionDeclaration = 0;
				WfFunctionExpression*				functionExpression = 0;
				WfOrderedLambdaExpression*			orderedLambdaExpression = 0;
				WfMemberExpression*					methodReferenceExpression = 0;
				WfExpression*						staticMethodReferenceExpression = 0;
			};

			enum class WfCodegenScopeType
			{
				Function,	// contains the whole function
				Switch,		// contains all switchs
				Loop,		// contains all loops
				TryCatch,	// contains try and catch, not finally
			};

			class WfCodegenScopeContext : public Object
			{
				typedef collections::List<vint>										InstructionIndexList;
				typedef collections::List<runtime::WfInstruction>					InstructionList;
				typedef collections::List<parsing::ParsingTextRange>				RangeMap;
			public:
				WfCodegenScopeType					type = WfCodegenScopeType::Function;
				InstructionIndexList				continueInstructions;
				InstructionIndexList				breakInstructions;
				
				InstructionList						exitInstructions;
				RangeMap							instructionCodeMappingBeforeCodegen;
				RangeMap							instructionCodeMappingAfterCodegen;
				Ptr<WfStatement>					exitStatement;
			};

			class WfCodegenFunctionContext : public Object
			{
				typedef collections::Dictionary<WfLexicalSymbol*, vint>				VariableIndexMap;
				typedef collections::Dictionary<vint, WfCodegenLambdaContext>		ClosureIndexMap;
				typedef collections::List<Ptr<WfCodegenScopeContext>>				ScopeContextList;
			public:
				Ptr<runtime::WfAssemblyFunction>	function;
				VariableIndexMap					capturedVariables;
				VariableIndexMap					arguments;
				VariableIndexMap					localVariables;
				ClosureIndexMap						closuresToCodegen;
				ScopeContextList					scopeContextStack;

				WfCodegenFunctionContext();
				
				Ptr<WfCodegenScopeContext>			GetCurrentScopeContext();
				Ptr<WfCodegenScopeContext>			GetCurrentScopeContext(WfCodegenScopeType type);
				Ptr<WfCodegenScopeContext>			PushScopeContext(WfCodegenScopeType type);
				void								PopScopeContext();
			};

			class WfCodegenContext : public Object
			{
				typedef collections::Dictionary<WfLexicalSymbol*, vint>											VariableIndexMap;
				typedef collections::Dictionary<WfLexicalSymbol*, vint>											FunctionIndexMap;
				typedef collections::Dictionary<parsing::ParsingTreeCustomBase*, parsing::ParsingTextRange>		NodePositionMap;
			public:
				Ptr<runtime::WfAssembly>			assembly;
				WfLexicalScopeManager*				manager;
				VariableIndexMap					globalVariables;
				FunctionIndexMap					globalFunctions;
				Ptr<WfCodegenFunctionContext>		functionContext;
				NodePositionMap						nodePositionsBeforeCodegen;
				NodePositionMap						nodePositionsAfterCodegen;

				WfCodegenContext(Ptr<runtime::WfAssembly> _assembly, WfLexicalScopeManager* _manager);

				vint								AddInstruction(parsing::ParsingTreeCustomBase* node, const runtime::WfInstruction& ins);
				void								AddExitInstruction(parsing::ParsingTreeCustomBase* node, const runtime::WfInstruction& ins);
				void								ApplyExitInstructions(Ptr<WfCodegenScopeContext> scopeContext);
			};

			extern void										GenerateFunctionDeclarationMetadata(WfCodegenContext& context, WfFunctionDeclaration* node, Ptr<runtime::WfAssemblyFunction> meta);
			extern void										GenerateGlobalDeclarationMetadata(WfCodegenContext& context, Ptr<WfDeclaration> declaration, const WString& namePrefix = L"");
			extern void										GenerateClosureInstructions(WfCodegenContext& context, Ptr<WfCodegenFunctionContext> functionContext);
			extern void										GenerateInitializeInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration);
			extern void										GenerateDeclarationInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration);
			extern void										GenerateStatementInstructions(WfCodegenContext& context, Ptr<WfStatement> statement);
			extern Ptr<reflection::description::ITypeInfo>	GenerateExpressionInstructions(WfCodegenContext& context, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType = 0);
			extern void										GenerateTypeCastInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, bool strongCast, WfExpression* node);
			extern void										GenerateTypeTestingInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, WfExpression* node);
			extern runtime::WfInsType						GetInstructionTypeArgument(Ptr<reflection::description::ITypeInfo> expectedType);

			/// <summary>Generate an assembly from a compiler. [M:vl.workflow.analyzer.WfLexicalScopeManager.Rebuild] should be called before using this function.</summary>
			/// <returns>The generated assembly.</returns>
			/// <param name="manager">The Workflow compiler.</param>
			extern Ptr<runtime::WfAssembly>					GenerateAssembly(WfLexicalScopeManager* manager);

			/// <summary>Compile a Workflow program.</summary>
			/// <returns>The generated assembly.</returns>
			/// <param name="table">The workflow parser table. It can be retrived from [M:vl.workflow.WfLoadTable].</param>
			/// <param name="manager">The workflow compiler to reuse the cache of C++ reflectable types.</param>
			/// <param name="moduleCodes">All workflow module codes.</param>
			/// <param name="errors">Container to get all compileing errors.</param>
			extern Ptr<runtime::WfAssembly>					Compile(Ptr<parsing::tabling::ParsingTable> table, WfLexicalScopeManager* manager, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors);
			
			/// <summary>Compile a Workflow program.</summary>
			/// <returns>The generated assembly.</returns>
			/// <param name="table">The workflow parser table. It can be retrived from [M:vl.workflow.WfLoadTable].</param>
			/// <param name="moduleCodes">All workflow module codes.</param>
			/// <param name="errors">Container to get all compileing errors.</param>
			extern Ptr<runtime::WfAssembly>					Compile(Ptr<parsing::tabling::ParsingTable> table, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors);

/***********************************************************************
Error Messages
***********************************************************************/

			struct WfErrors
			{
				// A: Expression error
				static Ptr<parsing::ParsingError>			WrongFormatStringSyntax(WfExpression* node);
				static Ptr<parsing::ParsingError>			WrongSimpleObserveExpression(WfExpression* node);
				static Ptr<parsing::ParsingError>			WrongSimpleObserveEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			EmptyObserveEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			ObserveNotInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			ObserveInObserveEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			BindInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			AttachInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			DetachInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorMixMapAndList(WfExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorMixClassAndInterface(WfExpression* node);
				static Ptr<parsing::ParsingError>			ScopeNameIsNotExpression(WfExpression* node, Ptr<WfLexicalScopeName> scopeName);
				static Ptr<parsing::ParsingError>			EventIsNotExpression(WfExpression* node, reflection::description::IEventInfo* eventInfo);
				static Ptr<parsing::ParsingError>			ExpressionIsNotScopeName(WfExpression* node);
				static Ptr<parsing::ParsingError>			ExpressionIsNotEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			ExpressionCannotResolveType(WfExpression* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			NullCannotResolveType(WfExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorCannotResolveType(WfExpression* node);
				static Ptr<parsing::ParsingError>			OrderedLambdaCannotResolveType(WfExpression* node);
				static Ptr<parsing::ParsingError>			NullCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ConstructorCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			OrderedLambdaCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ExpressionCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ExpressionCannotExplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			CannotWeakCastToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			IntegerLiteralOutOfRange(WfIntegerExpression* node);
				static Ptr<parsing::ParsingError>			CannotMergeTwoType(WfExpression* node, reflection::description::ITypeInfo* firstType, reflection::description::ITypeInfo* secondType);
				static Ptr<parsing::ParsingError>			RangeShouldBeInteger(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			UnaryOperatorOnWrongType(WfUnaryExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			BinaryOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			IndexOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* containerType);
				static Ptr<parsing::ParsingError>			ExpressionIsNotCollection(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			ExpressionIsNotFunction(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			FunctionArgumentCountMismatched(WfExpression* node, vint expectedCount, const ResolveExpressionResult& function);
				static Ptr<parsing::ParsingError>			FunctionArgumentTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, vint index, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			CannotPickOverloadedFunctions(WfExpression* node, collections::List<ResolveExpressionResult>& results);
				static Ptr<parsing::ParsingError>			ClassContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			InterfaceContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			ConstructorReturnTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ExpressionIsNotLeftValue(WfExpression* node, const ResolveExpressionResult& result);

				// B: Type error
				static Ptr<parsing::ParsingError>			WrongVoidType(WfType* node);
				static Ptr<parsing::ParsingError>			WrongInterfaceType(WfType* node);
				static Ptr<parsing::ParsingError>			RawPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static Ptr<parsing::ParsingError>			SharedPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static Ptr<parsing::ParsingError>			NullableToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static Ptr<parsing::ParsingError>			ChildOfNonReferenceType(WfType* node);
				static Ptr<parsing::ParsingError>			TypeNotExists(WfType* node, Ptr<WfLexicalScopeName> scopeName);
				static Ptr<parsing::ParsingError>			TypeNotExists(WfType* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			TypeNotForValue(WfType* node, reflection::description::ITypeInfo* typeInfo);
				
				// C: Statement error
				static Ptr<parsing::ParsingError>			BreakNotInLoop(WfStatement* node);
				static Ptr<parsing::ParsingError>			ContinueNotInLoop(WfStatement* node);
				static Ptr<parsing::ParsingError>			RethrowNotInCatch(WfStatement* node);
				static Ptr<parsing::ParsingError>			TryMissCatchAndFinally(WfStatement* node);
				static Ptr<parsing::ParsingError>			ReturnMissExpression(WfStatement* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			DeleteNonRawPointer(WfStatement* node, reflection::description::ITypeInfo* type);

				// D: Declaration error
				static Ptr<parsing::ParsingError>			FunctionShouldHaveName(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			FunctionShouldHaveImplementation(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			InterfaceMethodShouldNotHaveImplementation(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			DuplicatedDeclaration(WfDeclaration* node, const WString& firstDeclarationCategory);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfDeclaration* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfFunctionArgument* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfStatement* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfExpression* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			InterfaceMethodNotImplemented(WfNewTypeExpression* node, reflection::description::IMethodInfo* method);
				static Ptr<parsing::ParsingError>			InterfaceMethodNotFound(WfFunctionDeclaration* node, reflection::description::ITypeInfo* interfaceType, reflection::description::ITypeInfo* methodType);
				static Ptr<parsing::ParsingError>			CannotPickOverloadedInterfaceMethods(WfExpression* node, collections::List<ResolveExpressionResult>& results);
				static Ptr<parsing::ParsingError>			CannotPickOverloadedImplementMethods(WfFunctionDeclaration* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			WrontDeclaration(WfEventDeclaration* node);
				static Ptr<parsing::ParsingError>			WrontDeclaration(WfPropertyDeclaration* node);

				// E: Module error
				static Ptr<parsing::ParsingError>			WrongUsingPathWildCard(WfModuleUsingPath* node);

				// F: Symbol Error
				static Ptr<parsing::ParsingError>			TopQualifiedSymbolNotExists(parsing::ParsingTreeCustomBase* node, const WString& name);
				static Ptr<parsing::ParsingError>			ChildSymbolNotExists(parsing::ParsingTreeCustomBase* node, Ptr<WfLexicalScopeName> scopeName, const WString& name);
				static Ptr<parsing::ParsingError>			MemberNotExists(parsing::ParsingTreeCustomBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name);
				static Ptr<parsing::ParsingError>			ReferenceNotExists(parsing::ParsingTreeCustomBase* node, const WString& name);
				static Ptr<parsing::ParsingError>			TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<ResolveExpressionResult>& results, const WString& name);
				static Ptr<parsing::ParsingError>			TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<Ptr<WfLexicalSymbol>>& symbols, const WString& name);
				static Ptr<parsing::ParsingError>			TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<Ptr<WfLexicalScopeName>>& names, const WString& name);

				// G: Class error
				static Ptr<parsing::ParsingError>			ClassFeatureNotSupported(WfClassDeclaration* node, const WString& name);
				static Ptr<parsing::ParsingError>			ClassFeatureNotSupported(WfClassMember* node, const WString& name);
				static Ptr<parsing::ParsingError>			NonFunctionClassMemberCannotBeStatic(WfClassMember* node);
				static Ptr<parsing::ParsingError>			WrongClassMember(WfNamespaceDeclaration* node);
				static Ptr<parsing::ParsingError>			PropertyGetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertySetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertyEventNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			TooManyPropertyGetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			TooManyPropertySetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			TooManyPropertyEvent(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertyGetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertySetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			WrongBaseType(WfClassDeclaration* node, WfType* type);
			};
		}
	}
}

#endif
