/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "VlppWorkflowCompiler.h"

/***********************************************************************
.\ANALYZER\WFANALYZER.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;

/***********************************************************************
WfLexicalSymbol
***********************************************************************/

			WfLexicalSymbol::WfLexicalSymbol(WfLexicalScope* _ownerScope)
				:ownerScope(_ownerScope)
			{
			}

			WfLexicalSymbol::~WfLexicalSymbol()
			{
			}

			WString WfLexicalSymbol::GetFriendlyName()
			{
				return ownerScope->GetFriendlyName() + L"::" + name;
			}

/***********************************************************************
WfLexicalScope
***********************************************************************/

			WfLexicalScope::WfLexicalScope(WfLexicalScopeManager* _ownerManager)
				:ownerManager(_ownerManager)
			{
			}

			WfLexicalScope::WfLexicalScope(Ptr<WfLexicalScope> _parentScope)
				:ownerManager(0)
				, parentScope(_parentScope)
			{
			}

			WfLexicalScope::~WfLexicalScope()
			{
			}

			WfLexicalScopeManager* WfLexicalScope::FindManager()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (scope->ownerManager)
					{
						return scope->ownerManager;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			Ptr<WfModule> WfLexicalScope::FindModule()
			{
				WfLexicalScope* scope = this;
				while (scope)
				{
					if (auto module = scope->ownerNode.Cast<WfModule>())
					{
						return module;
					}
					scope = scope->parentScope.Obj();
				}
				return 0;
			}

			WfLexicalScope* WfLexicalScope::FindFunctionScope()
			{
				auto scope = this;
				while (scope)
				{
					if (scope->functionConfig)
					{
						return scope;
					}
					scope = scope->parentScope.Obj();
				}
				return nullptr;
			}

			WString WfLexicalScope::GetFriendlyName()
			{
				if (auto module = ownerNode.Cast<WfModule>())
				{
					return L"<" + module->name.value + L">";
				}
				else if (auto decl = ownerNode.Cast<WfDeclaration>())
				{
					auto name = decl->name.value;
					if (name == L"")
					{
						name = L"<anonymous>";
					}
					return parentScope->GetFriendlyName() + L"::" + name;
				}
				else if (!parentScope)
				{
					return L"";
				}
				else
				{
					return parentScope->GetFriendlyName() + L"::<>";
				}
			}

/***********************************************************************
WfLexicalScopeName
***********************************************************************/

			WfLexicalScopeName::WfLexicalScopeName(bool _imported)
				:imported(_imported)
			{
			}

			WfLexicalScopeName::~WfLexicalScopeName()
			{
			}

			Ptr<WfLexicalScopeName> WfLexicalScopeName::AccessChild(const WString& name, bool imported)
			{
				vint index = children.Keys().IndexOf(name);
				if (index == -1)
				{
					auto newName = Ptr(new WfLexicalScopeName(imported));
					newName->name = name;
					newName->parent = this;
					children.Add(name, newName);
					return newName;
				}
				else
				{
					return children.Values()[index];
				}
			}

			void WfLexicalScopeName::RemoveNonTypeDescriptorNames(WfLexicalScopeManager* manager)
			{
				for (auto name : children.Values())
				{
					name->RemoveNonTypeDescriptorNames(manager);
				}

				for (vint i = children.Count() - 1; i >= 0; i--)
				{
					auto subScopeName = children.Values()[i];
					if (!subScopeName->imported)
					{
						children.Remove(children.Keys()[i]);
						if (subScopeName->typeDescriptor)
						{
							manager->typeNames.Remove(subScopeName->typeDescriptor);
						}
					}
				}
				
				declarations.Clear();
			}

			WString WfLexicalScopeName::GetFriendlyName()
			{
				if (parent)
				{
					WString parentName = parent->GetFriendlyName();
					if (parentName == L"")
					{
						return name;
					}
					else
					{
						return parentName + L"::" + name;
					}
				}
				else
				{
					return L"";
				}
			}

/***********************************************************************
ResolveExpressionResult
***********************************************************************/

			WString ResolveExpressionResult::GetFriendlyName(bool upperCase)const
			{
				WString typeName, result;
				if (type)
				{
					typeName= + L" of type \"" + type->GetTypeFriendlyName() + L"\"";
				}

				if (scopeName)
				{
					result = scopeName->GetFriendlyName();
				}
				else if (symbol)
				{
					result = symbol->GetFriendlyName() + typeName;
				}
				else if (propertyInfo)
				{
					result = L"property \"" + propertyInfo->GetName() + L"\" in \"" + propertyInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
				}
				else if (methodInfo)
				{
					if (methodInfo->GetName() == L"")
					{
						result = L"constructor in \"" + methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
					}
					else
					{
						result = L"method \"" + methodInfo->GetName() + L"\" in \"" + methodInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"" + typeName;
					}
				}
				else if (eventInfo)
				{
					result = L"event \"" + eventInfo->GetName() + L"\" in \"" + eventInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\"";
				}
				else if (type)
				{
					result = L"expression" + typeName;
				}
				else
				{
					result = L"<unknown>";
				}

				if (result.Length() > 0 && upperCase)
				{
					result = INVLOC.ToUpper(result.Left(1)) + result.Right(result.Length() - 1);
				}
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::ScopeName(Ptr<WfLexicalScopeName> _scopeName)
			{
				ResolveExpressionResult result;
				result.scopeName = _scopeName;
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::ReadonlySymbol(Ptr<WfLexicalSymbol> _symbol)
			{
				ResolveExpressionResult result;
				result.symbol = _symbol;
				result.type = _symbol->typeInfo;
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::Symbol(Ptr<WfLexicalSymbol> _symbol)
			{
				ResolveExpressionResult result;
				result.symbol = _symbol;
				result.type = _symbol->typeInfo;
				if (_symbol->creatorNode.Cast<WfVariableDeclaration>())
				{
					result.writableType = _symbol->typeInfo;
				}
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::ReadonlyType(Ptr<reflection::description::ITypeInfo> _type)
			{
				ResolveExpressionResult result;
				result.type = _type;
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::WritableType(Ptr<reflection::description::ITypeInfo> _type)
			{
				ResolveExpressionResult result;
				result.type = _type;
				result.writableType = _type;
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::Property(reflection::description::IPropertyInfo* _propertyInfo)
			{
				Ptr<ITypeInfo> getterType = CopyTypeInfo(_propertyInfo->GetReturn());
				Ptr<ITypeInfo> setterType;

				if (getterType)
				{
					if (IMethodInfo* setter = _propertyInfo->GetSetter())
					{
						setterType = getterType;
						if (setter->GetParameterCount() == 1 && !IsSameType(getterType.Obj(), setter->GetParameter(0)->GetType()))
						{
							setterType = CopyTypeInfo(setter->GetParameter(0)->GetType());
						}
					}
					else if (_propertyInfo->IsWritable())
					{
						auto td = _propertyInfo->GetOwnerTypeDescriptor();
						if ((td->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined)
						{
							setterType = CopyTypeInfo(_propertyInfo->GetReturn());
						}
					}
				}

				ResolveExpressionResult result;
				result.propertyInfo = _propertyInfo;
				result.type = getterType;
				result.writableType = setterType;
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::Method(reflection::description::IMethodInfo* _methodInfo)
			{
				ResolveExpressionResult result;
				result.methodInfo = _methodInfo;
				result.type = CreateTypeInfoFromMethodInfo(_methodInfo);
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::Constructor(reflection::description::IMethodInfo* _constructorInfo)
			{
				ResolveExpressionResult result;
				result.constructorInfo = _constructorInfo;
				result.type = CopyTypeInfo(_constructorInfo->GetReturn());
				return result;
			}

			ResolveExpressionResult ResolveExpressionResult::Event(reflection::description::IEventInfo* _eventInfo)
			{
				ResolveExpressionResult result;
				result.eventInfo = _eventInfo;
				return result;
			}

			bool IsSameTypeOrNull(ITypeInfo* fromType, ITypeInfo* toType)
			{
				if (fromType == toType) return true;
				if ((fromType == nullptr) ^ (toType == nullptr)) return false;
				return IsSameType(fromType, toType);
			}

			bool ResolveExpressionResult::operator==(const ResolveExpressionResult& result) const
			{
				if (scopeName != result.scopeName) return false;
				if (symbol != result.symbol) return false;
				if (propertyInfo != result.propertyInfo) return false;
				if (methodInfo != result.methodInfo) return false;
				if (constructorInfo != result.constructorInfo) return false;
				if (eventInfo != result.eventInfo) return false;

				if (!IsSameTypeOrNull(type.Obj(), result.type.Obj())) return false;
				if (!IsSameTypeOrNull(writableType.Obj(), result.writableType.Obj())) return false;
				if (!IsSameTypeOrNull(expectedType.Obj(), result.expectedType.Obj())) return false;
				return true;
			}

			bool ResolveExpressionResult::operator!=(const ResolveExpressionResult& result) const
			{
				return !(*this == result);
			}

/***********************************************************************
WfLexicalScopeManager
***********************************************************************/

			WfLexicalScopeManager::WfLexicalScopeManager(workflow::Parser& _workflowParser, WfCpuArchitecture _cpuArchitecture)
				:workflowParser(_workflowParser)
				, cpuArchitecture(_cpuArchitecture)
			{
				workflowParserHandler = glr::InstallDefaultErrorMessageGenerator(workflowParser, errors);
				attributes.Add({ L"cpp", L"File" }, TypeInfoRetriver<WString>::CreateTypeInfo());
				attributes.Add({ L"cpp", L"UserImpl" }, TypeInfoRetriver<void>::CreateTypeInfo());
				attributes.Add({ L"cpp", L"Private" }, TypeInfoRetriver<void>::CreateTypeInfo());
				attributes.Add({ L"cpp", L"Protected" }, TypeInfoRetriver<void>::CreateTypeInfo());
				attributes.Add({ L"cpp", L"Friend" }, TypeInfoRetriver<ITypeDescriptor*>::CreateTypeInfo());

				switch (cpuArchitecture)
				{
				case WfCpuArchitecture::x86:
					cputdSInt = reflection::description::GetTypeDescriptor<vint32_t>();
					cputdUInt = reflection::description::GetTypeDescriptor<vuint32_t>();
					cputiSInt = reflection::description::TypeInfoRetriver<vint32_t>::CreateTypeInfo();
					cputiUInt = reflection::description::TypeInfoRetriver<vuint32_t>::CreateTypeInfo();
					break;
				case WfCpuArchitecture::x64:
					cputdSInt = reflection::description::GetTypeDescriptor<vint64_t>();
					cputdUInt = reflection::description::GetTypeDescriptor<vuint64_t>();
					cputiSInt = reflection::description::TypeInfoRetriver<vint64_t>::CreateTypeInfo();
					cputiUInt = reflection::description::TypeInfoRetriver<vuint64_t>::CreateTypeInfo();
					break;
				case WfCpuArchitecture::AsExecutable:
					cputdSInt = reflection::description::GetTypeDescriptor<vint>();
					cputdUInt = reflection::description::GetTypeDescriptor<vuint>();
					cputiSInt = reflection::description::TypeInfoRetriver<vint>::CreateTypeInfo();
					cputiUInt = reflection::description::TypeInfoRetriver<vuint>::CreateTypeInfo();
					break;
				}
			}

			WfLexicalScopeManager::~WfLexicalScopeManager()
			{
				workflowParser.OnError.Remove(workflowParserHandler);
			}

			vint WfLexicalScopeManager::AddModule(const WString& moduleCode)
			{
				if (auto module = ParseModule(moduleCode, workflowParser, usedCodeIndex))
				{
					modules.Add(module);
					moduleCodes.Add(moduleCode);
				}
				return usedCodeIndex++;
			}

			vint WfLexicalScopeManager::AddModule(Ptr<WfModule> module)
			{
				module->codeRange.codeIndex = usedCodeIndex;
				modules.Add(module);
				moduleCodes.Add(L"");
				return usedCodeIndex++;
			}

			WfLexicalScopeManager::ModuleList& WfLexicalScopeManager::GetModules()
			{
				return modules;
			}

			WfLexicalScopeManager::ModuleCodeList& WfLexicalScopeManager::GetModuleCodes()
			{
				return moduleCodes;
			}

			void WfLexicalScopeManager::Clear(bool keepTypeDescriptorNames, bool deleteModules)
			{
				if (globalName)
				{
					if (keepTypeDescriptorNames)
					{
						globalName->RemoveNonTypeDescriptorNames(this);
					}
					else
					{
						globalName = 0;
						typeNames.Clear();
					}
				}
				
				if (deleteModules)
				{
					modules.Clear();
					moduleCodes.Clear();
					usedCodeIndex = 0;
				}

				usedTempVars = 0;
				errors.Clear();
				namespaceNames.Clear();
				nodeScopes.Clear();
				checkedScopes_DuplicatedSymbol.Clear();
				checkedScopes_SymbolType.Clear();

				expressionResolvings.Clear();
				coNewCoroutineResolvings.Clear();
				coOperatorResolvings.Clear();
				coProviderResolvings.Clear();
				coCastResultResolvings.Clear();
				baseConstructorCallResolvings.Clear();

				lambdaCaptures.Clear();
				interfaceMethodImpls.Clear();
				declaractionScopeSources.Clear();
				declarationTypes.Clear();
				declarationMemberInfos.Clear();
				stateInputMethods.Clear();
				stateInputArguments.Clear();
				stateDeclArguments.Clear();
				stateMachineInfos.Clear();
			}

#define EXECUTE_CALLBACK(EXPR) if (callback) callback->EXPR

			void WfLexicalScopeManager::Rebuild(bool keepTypeDescriptorNames, IWfCompilerCallback* callback)
			{
				EXECUTE_CALLBACK(OnLoadEnvironment());
				Clear(keepTypeDescriptorNames, false);
				if (!globalName)
				{
					globalName = Ptr(new WfLexicalScopeName(true));
					BuildGlobalNameFromTypeDescriptors(this);
				}

				EXECUTE_CALLBACK(OnInitialize(this));
				vint errorCount = errors.Count();

#define EXIT_IF_ERRORS_EXIST\
				do\
				{\
					if (errors.Count() != errorCount) return;\
				}while (0)
				
				EXIT_IF_ERRORS_EXIST;
				for (auto module : modules)
				{
					ContextFreeModuleDesugar(this, module);
					ValidateModuleStructure(this, module);
				}
				
				EXIT_IF_ERRORS_EXIST;
				BuildGlobalNameFromModules(this);
				for (auto module : modules)
				{
					BuildScopeForModule(this, module);
				}
				ValidateScopeName(this, globalName);
				CheckScopes_DuplicatedSymbol(this);
				
				EXIT_IF_ERRORS_EXIST;
				for (auto module : modules)
				{
					CompleteScopeForModule(this, module);
				}
				CheckScopes_SymbolType(this);
				CheckScopes_CycleDependency(this);
				
				EXIT_IF_ERRORS_EXIST;
				for (auto module : modules)
				{
					EXECUTE_CALLBACK(OnValidateModule(module));
					ValidateModuleSemantic(this, module);
				}

#undef EXIT_IF_ERRORS_EXIST
			}

#undef EXECUTE_CALLBACK

			bool WfLexicalScopeManager::ResolveMember(ITypeDescriptor* typeDescriptor, const WString& name, bool preferStatic, collections::SortedList<ITypeDescriptor*>& searchedTypes, collections::List<ResolveExpressionResult>& results)
			{
				if (searchedTypes.Contains(typeDescriptor))
				{
					return true;
				}
				searchedTypes.Add(typeDescriptor);

				bool found = false;
				bool foundStaticMember = false;


				if ((typeDescriptor->GetTypeDescriptorFlags() & TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
				{
					if (preferStatic)
					{
						auto enumType = typeDescriptor->GetEnumType();
						vint index = enumType->IndexOfItem(name);
						if (index != -1)
						{
							results.Add(ResolveExpressionResult::ReadonlyType(Ptr(new TypeDescriptorTypeInfo(typeDescriptor, TypeInfoHint::Normal))));
							return true;
						}
					}
					return false;
				}

				{
					auto scopeName = typeNames[typeDescriptor];
					vint index = scopeName->children.Keys().IndexOf(name);
					if (index != -1)
					{
						auto subScopeName = scopeName->children.Values()[index];
						found = true;
						foundStaticMember = true;
						results.Add(ResolveExpressionResult::ScopeName(subScopeName));
					}
				}

				if (auto group = typeDescriptor->GetMethodGroupByName(name, false))
				{
					for (vint i = 0; i < group->GetMethodCount(); i++)
					{
						auto info = group->GetMethod(i);
						if (info->IsStatic())
						{
							found = true;
							foundStaticMember = true;
							results.Add(ResolveExpressionResult::Method(info));
						}
					}
				}

				if (foundStaticMember && preferStatic)
				{
					return true;
				}

				if (auto group = typeDescriptor->GetMethodGroupByName(name, false))
				{
					for (vint i = 0; i < group->GetMethodCount(); i++)
					{
						auto info = group->GetMethod(i);
						if (!info->IsStatic())
						{
							found = true;
							results.Add(ResolveExpressionResult::Method(info));
						}
					}
				}
				if (auto info = typeDescriptor->GetPropertyByName(name, false))
				{
					found = true;
					results.Add(ResolveExpressionResult::Property(info));
				}
				if (auto info = typeDescriptor->GetEventByName(name, false))
				{
					found = true;
					results.Add(ResolveExpressionResult::Event(info));
				}

				if (!found)
				{
					vint count = typeDescriptor->GetBaseTypeDescriptorCount();
					for (vint i = 0; i < count; i++)
					{
						if (ResolveMember(typeDescriptor->GetBaseTypeDescriptor(i), name, preferStatic, searchedTypes, results))
						{
							found = true;
						}
					}
				}
				return found;
			}

			class UsingPathToNameVisitor :public Object, public WfModuleUsingFragment::IVisitor
			{
			public:
				WString					name;
				WString					result;

				UsingPathToNameVisitor(const WString& _name)
					:name(_name)
				{
				}

				void Visit(WfModuleUsingNameFragment* node)
				{
					result = node->name.value;
				}

				void Visit(WfModuleUsingWildCardFragment* node)
				{
					result = name;
				}

				static WString Execute(Ptr<WfModuleUsingFragment> fragment, const WString& name)
				{
					UsingPathToNameVisitor visitor(name);
					fragment->Accept(&visitor);
					return visitor.result;
				}
			};

			bool WfLexicalScopeManager::ResolveName(WfLexicalScope* scope, const WString& name, collections::List<ResolveExpressionResult>& results)
			{
				vint oldResultCount = results.Count();
				bool visibleToNonStatic = false;
				WfLexicalScope* firstConfigScope = nullptr;
				while (scope)
				{
					if (scope->ownerNode.Cast<WfModule>() || scope->ownerNode.Cast<WfNamespaceDeclaration>())
					{
						break;
					}

					if (scope->functionConfig)
					{
						visibleToNonStatic = scope->functionConfig->thisAccessable || scope->functionConfig->parentThisAccessable;
						if (!firstConfigScope)
						{
							firstConfigScope = scope;
						}
					}
					
					vint index = scope->symbols.Keys().IndexOf(name);
					if (index != -1)
					{
						if (scope->typeOfThisExpr)
						{
							if (scope->ownerNode.Cast<WfNewInterfaceExpression>())
							{
								for (auto symbol : scope->symbols.GetByIndex(index))
								{
									if (auto functionDecl = symbol->creatorNode.Cast<WfFunctionDeclaration>())
									{
										if (firstConfigScope->parentScope != scope || functionDecl->functionKind != WfFunctionKind::Normal)
										{
											continue;
										}
									}
									else if (auto autoPropDecl = symbol->creatorNode.Cast<WfAutoPropertyDeclaration>())
									{
										if (firstConfigScope->parentScope != scope || autoPropDecl->functionKind != WfFunctionKind::Normal)
										{
											continue;
										}
									}

									auto result = ResolveExpressionResult::Symbol(symbol);
									if (!results.Contains(result))
									{
										results.Add(result);
									}
								}
							}
						}
						else
						{
							for (auto symbol : scope->symbols.GetByIndex(index))
							{
								auto result = ResolveExpressionResult::Symbol(symbol);
								if (!results.Contains(result))
								{
									results.Add(result);
								}
							}
						}
					}

					if (scope->typeOfThisExpr)
					{
						SortedList<ITypeDescriptor*> searchedTypes;
						ResolveMember(scope->typeOfThisExpr, name, !visibleToNonStatic, searchedTypes, results);
					}

					scope = scope->parentScope.Obj();
				}
				
				while (scope)
				{
					if (auto nsDecl = scope->ownerNode.Cast<WfNamespaceDeclaration>())
					{
						auto scopeName = namespaceNames[nsDecl.Obj()];
						vint index = scopeName->children.Keys().IndexOf(name);
						if (index != -1)
						{
							auto subScopeName = scopeName->children.Values()[index];
							auto result = ResolveExpressionResult::ScopeName(subScopeName);
							if (!results.Contains(result))
							{
								results.Add(result);
							}
						}
						scope = scope->parentScope.Obj();
					}
					else
					{
						break;
					}
				}
				
				vint index = globalName->children.Keys().IndexOf(name);
				if (index != -1)
				{
					auto subScopeName = globalName->children.Values()[index];
					auto result = ResolveExpressionResult::ScopeName(subScopeName);
					if (!results.Contains(result))
					{
						results.Add(result);
					}
				}

				if (auto module = scope->ownerNode.Cast<WfModule>())
				{
					for (auto path : module->paths)
					{
						auto scopeName = globalName;
						for (auto item : path->items)
						{
							WString fragmentName;
							for (auto fragment : item->fragments)
							{
								fragmentName += UsingPathToNameVisitor::Execute(fragment, name);
							}
							vint index = scopeName->children.Keys().IndexOf(fragmentName);
							if (index == -1) goto USING_PATH_MATCHING_FAILED;
							scopeName = scopeName->children.Values()[index];
						}

						{
							auto result = ResolveExpressionResult::ScopeName(scopeName);
							if (!results.Contains(result))
							{
								results.Add(result);
							}
						}
					USING_PATH_MATCHING_FAILED:;
					}
				}

				return results.Count() > oldResultCount;
			}

			Ptr<WfLexicalSymbol> WfLexicalScopeManager::GetDeclarationSymbol(WfLexicalScope* scope, WfDeclaration* node)
			{
				auto symbol = From(scope->parentScope->symbols[node->name.value])
					.Where([=](Ptr<WfLexicalSymbol> symbol)
					{
						return symbol->creatorNode == node;
					})
					.First();
				return symbol;
			}

			void WfLexicalScopeManager::CreateLambdaCapture(glr::ParsingAstBase* node, Ptr<WfLexicalCapture> capture)
			{
				if (!capture)
				{
					capture = Ptr(new WfLexicalCapture);
				}
				lambdaCaptures.Add(node, capture);
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_BUILDGLOBALNAMEFROMMODULES.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
BuildGlobalNameFromModules
***********************************************************************/

			class BuildClassMemberVisitor
				: public Object
				, public WfDeclaration::IVisitor
				, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*			manager;
				Ptr<WfLexicalScopeName>			scopeName;
				WfClassDeclaration*				classDecl;
				Ptr<WfCustomType>				td;

				BuildClassMemberVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScopeName> _scopeName, WfClassDeclaration* _classDecl, Ptr<WfCustomType> _td)
					:manager(_manager)
					, scopeName(_scopeName)
					, classDecl(_classDecl)
					, td(_td)
				{
				}

				static WString GetTypeName(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> scopeName)
				{
					WString typeName = scopeName->name;
					{
						WfLexicalScopeName* name = scopeName->parent;
						while (name && name != manager->globalName.Obj())
						{
							typeName = name->name + L"::" + typeName;
							name = name->parent;
						}
					}
					return typeName;
				}

				static void AddCustomType(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> scopeName, WfDeclaration* declaration, Ptr<ITypeDescriptor> td)
				{
					manager->declarationTypes.Add(Ptr(declaration), td);

					if (!scopeName->typeDescriptor)
					{
						scopeName->typeDescriptor = td.Obj();
						manager->typeNames.Add(td.Obj(), scopeName);
					}
				}

				static void BuildClass(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> scopeName, WfClassDeclaration* declaration)
				{
					WString typeName = GetTypeName(manager, scopeName);
					Ptr<WfCustomType> td;
					switch (declaration->kind)
					{
					case WfClassKind::Class:
						td = Ptr(new WfClass(typeName));
						break;
					case WfClassKind::Interface:
						td = Ptr(new WfInterface(typeName));
						break;
					default:;
					}
					AddCustomType(manager, scopeName, declaration, td);

					for (auto memberDecl : declaration->declarations)
					{
						BuildClassMemberVisitor visitor(manager, scopeName, declaration, td);
						memberDecl->Accept(&visitor);
					}
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (node->functionKind == WfFunctionKind::Static)
					{
						auto info = Ptr(new WfStaticMethod);
						td->AddMember(node->name.value, info);
						manager->declarationMemberInfos.Add(Ptr(node), info);
					}
					else
					{
						switch (classDecl->kind)
						{
						case WfClassKind::Class:
							{
								auto info = Ptr(new WfClassMethod);
								td->AddMember(node->name.value, info);
								manager->declarationMemberInfos.Add(Ptr(node), info);
							}
							break;
						case WfClassKind::Interface:
							{
								auto info = Ptr(new WfInterfaceMethod);
								td->AddMember(node->name.value, info);
								manager->declarationMemberInfos.Add(Ptr(node), info);
							}
							break;
						default:;
						}
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto info = Ptr(new WfField(td.Obj(), node->name.value));
					td->AddMember(info);
					manager->declarationMemberInfos.Add(Ptr(node), info);
				}

				void Visit(WfEventDeclaration* node)override
				{
					auto info = Ptr(new WfEvent(td.Obj(), node->name.value));
					td->AddMember(info);
					manager->declarationMemberInfos.Add(Ptr(node), info);
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					auto info = Ptr(new WfProperty(td.Obj(), node->name.value));
					td->AddMember(info);
					manager->declarationMemberInfos.Add(Ptr(node), info);
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					Ptr<ITypeInfo> typeInfo;
					{
						auto elementType = Ptr(new TypeDescriptorTypeInfo(td.Obj(), TypeInfoHint::Normal));
						if (node->constructorType == WfConstructorType::RawPtr)
						{
							typeInfo = Ptr(new RawPtrTypeInfo(elementType));
						}
						else
						{
							typeInfo = Ptr(new SharedPtrTypeInfo(elementType));
						}
					}

					auto info = Ptr(new WfClassConstructor(typeInfo));
					td->AddMember(info);
					manager->declarationMemberInfos.Add(Ptr(node), info);
				}
				
				void Visit(WfDestructorDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto newScopeName = scopeName->AccessChild(node->name.value, false);
					newScopeName->declarations.Add(Ptr(node));
					BuildClass(manager, newScopeName, node);
				}

				void Visit(WfEnumDeclaration* node)override
				{
					BuildNameForDeclaration(manager, scopeName, Ptr(node));
				}

				void Visit(WfStructDeclaration* node)override
				{
					BuildNameForDeclaration(manager, scopeName, Ptr(node));
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
					for (auto input : node->inputs)
					{
						auto info = Ptr(new WfClassMethod);
						td->AddMember(input->name.value, info);
						manager->stateInputMethods.Add(input, info);

						for (auto argument : input->arguments)
						{
							auto info = Ptr(new WfField(td.Obj(), L"<stateip-" + input->name.value + L">" + argument->name.value));
							td->AddMember(info);
							manager->stateInputArguments.Add(argument, info);
						}
					}
					
					for (auto state : node->states)
					{
						for (auto argument : state->arguments)
						{
							auto info = Ptr(new WfField(td.Obj(), L"<statesp-" + state->name.value + L">" + argument->name.value));
							td->AddMember(info);
							manager->stateDeclArguments.Add(argument, info);
						}
					}

					auto smInfo = Ptr(new WfStateMachineInfo);
					{
						smInfo->createCoroutineMethod = Ptr(new WfClassMethod);
						td->AddMember(L"<state>CreateCoroutine", smInfo->createCoroutineMethod);
					}
					manager->stateMachineInfos.Add(Ptr(node), smInfo);
				}
			};

			class BuildNameDeclarationVisitor
				: public empty_visitor::DeclarationVisitor
				, public empty_visitor::VirtualCseDeclarationVisitor
			{
			public:
				WfLexicalScopeManager*			manager;
				Ptr<WfLexicalScopeName>			scopeName;

				BuildNameDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScopeName> _scopeName)
					:manager(_manager)
					, scopeName(_scopeName)
				{
				}

				void Dispatch(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Dispatch(WfVirtualCseDeclaration* node)override
				{
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					manager->namespaceNames.Add(Ptr(node), scopeName);
					for (auto subDecl : node->declarations)
					{
						BuildNameForDeclaration(manager, scopeName, subDecl);
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
					BuildClassMemberVisitor::BuildClass(manager, scopeName, node);
				}

				void Visit(WfEnumDeclaration* node)override
				{
					auto td = Ptr(new WfEnum(node->kind == WfEnumKind::Flag, BuildClassMemberVisitor::GetTypeName(manager, scopeName)));
					BuildClassMemberVisitor::AddCustomType(manager, scopeName, node, td);
				}

				void Visit(WfStructDeclaration* node)override
				{
					auto td = Ptr(new WfStruct(BuildClassMemberVisitor::GetTypeName(manager, scopeName)));
					BuildClassMemberVisitor::AddCustomType(manager, scopeName, node, td);
				}
			};

			void BuildNameForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name, Ptr<WfDeclaration> decl)
			{
				auto scopeName = name->AccessChild(decl->name.value, false);
				scopeName->declarations.Add(decl);

				BuildNameDeclarationVisitor visitor(manager, scopeName);
				decl->Accept(&visitor);
			}

			void BuildGlobalNameFromModules(WfLexicalScopeManager* manager)
			{
				for (auto module : manager->GetModules())
				{
					for (auto decl : module->declarations)
					{
						BuildNameForDeclaration(manager, manager->globalName, decl);
					}
				}
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_BUILDGLOBALNAMEFROMTYPEDESCRIPTORS.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace reflection::description;

/***********************************************************************
BuildGlobalNameFromTypeDescriptors
***********************************************************************/

			void BuildGlobalNameFromTypeDescriptors(WfLexicalScopeManager* manager)
			{
				for (vint i = 0; i < GetGlobalTypeManager()->GetTypeDescriptorCount(); i++)
				{
					ITypeDescriptor* typeDescriptor = GetGlobalTypeManager()->GetTypeDescriptor(i);
					WString name = typeDescriptor->GetTypeName();
					const wchar_t* reading = name.Buffer();
					Ptr<WfLexicalScopeName> currentName = manager->globalName;

					while (true)
					{
						WString fragment;
						const wchar_t* delimiter = wcsstr(reading, L"::");
						if (delimiter)
						{
							fragment = WString::CopyFrom(reading, vint(delimiter - reading));
							reading = delimiter + 2;
						}
						else
						{
							fragment = reading;
							reading = 0;
						}

						currentName = currentName->AccessChild(fragment, true);
						if (!reading)
						{
							currentName->typeDescriptor = typeDescriptor;
							manager->typeNames.Add(typeDescriptor, currentName);
							break;
						}
					}
				}
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_BUILDSCOPE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;

/***********************************************************************
BuildScopeForDeclaration
***********************************************************************/

			class BuildScopeForDeclarationVisitor
				: public Object
				, public WfDeclaration::IVisitor
				, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				glr::ParsingAstBase*					source;
				Ptr<WfLexicalScope>						parentScope;

				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope, glr::ParsingAstBase* _source)
					:manager(_manager)
					, source(_source)
					, parentScope(_parentScope)
				{
				}

				void Visit(Ptr<WfLexicalScope> scope, List<Ptr<WfAttribute>>& attributes)
				{
					for (auto attribute : attributes)
					{
						if (attribute->value)
						{
							BuildScopeForExpression(manager, scope, attribute->value);
						}
					}
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					parentScope->symbols.Add(symbol->name, symbol);

					resultScope = Ptr(new WfLexicalScope(parentScope));
					for (auto declaration : node->declarations)
					{
						BuildScopeForDeclaration(manager, resultScope, declaration, node);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));
					auto config = Ptr(new WfLexicalFunctionConfig);
					resultScope->functionConfig = config;
					resultScope->ownerNodeSource = source;

					if (source)
					{
						if (dynamic_cast<WfFunctionExpression*>(source))
						{
							config->lambda = true;
							config->thisAccessable = false;
							config->parentThisAccessable = true;
						}
						else if (dynamic_cast<WfNewInterfaceExpression*>(source))
						{
							config->lambda = true;
							config->thisAccessable = true;
							config->parentThisAccessable = true;
						}
						else if (dynamic_cast<WfClassDeclaration*>(source))
						{
							config->lambda = false;
							config->thisAccessable = node->functionKind != WfFunctionKind::Static;
							config->parentThisAccessable = false;
						}
					}

					if (node->anonymity == WfFunctionAnonymity::Named)
					{
						Ptr<WfLexicalScope> functionNameScope = parentScope;
						if (source && dynamic_cast<WfFunctionExpression*>(source))
						{
							functionNameScope = resultScope;
						}

						auto symbol = Ptr(new WfLexicalSymbol(functionNameScope.Obj()));
						symbol->name = node->name.value;
						symbol->creatorNode = Ptr(node);
						{
							auto type = Ptr(new WfFunctionType);
							type->result = node->returnType;
							for (auto argument : node->arguments)
							{
								type->arguments.Add(argument->type);
							}
							symbol->type = type;
						}
						functionNameScope->symbols.Add(symbol->name, symbol);
					}

					if (node->statement)
					{
						for (auto argument : node->arguments)
						{
							auto argumentSymbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
							argumentSymbol->name = argument->name.value;
							argumentSymbol->type = argument->type;
							argumentSymbol->creatorNode = argument;
							resultScope->symbols.Add(argumentSymbol->name, argumentSymbol);

							Visit(parentScope, argument->attributes);
						}

						BuildScopeForStatement(manager, resultScope, node->statement);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					symbol->type = node->type;
					parentScope->symbols.Add(symbol->name, symbol);

					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfEventDeclaration* node)override
				{
					auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					parentScope->symbols.Add(symbol->name, symbol);
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					symbol->type = node->type;
					parentScope->symbols.Add(symbol->name, symbol);
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));
					auto config = Ptr(new WfLexicalFunctionConfig);
					resultScope->functionConfig = config;
					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));

					for (auto argument : node->arguments)
					{
						auto argumentSymbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						argumentSymbol->name = argument->name.value;
						argumentSymbol->type = argument->type;
						argumentSymbol->creatorNode = argument;
						resultScope->symbols.Add(argumentSymbol->name, argumentSymbol);
					}

					for (auto call : node->baseConstructorCalls)
					{
						for (auto argument : call->arguments)
						{
							BuildScopeForExpression(manager, resultScope, argument);
						}
					}

					auto bodyScope = Ptr(new WfLexicalScope(resultScope));
					{
						auto config = Ptr(new WfLexicalFunctionConfig);
						bodyScope->functionConfig = config;

						config->lambda = false;
						config->thisAccessable = true;
						config->parentThisAccessable = false;
					}
					BuildScopeForStatement(manager, bodyScope, node->statement);
				}

				void Visit(WfDestructorDeclaration* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));
					{
						auto config = Ptr(new WfLexicalFunctionConfig);
						resultScope->functionConfig = config;

						config->lambda = false;
						config->thisAccessable = true;
						config->parentThisAccessable = false;
					}
					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					parentScope->symbols.Add(symbol->name, symbol);
					
					auto td = manager->declarationTypes[node];
					resultScope = Ptr(new WfLexicalScope(parentScope));
					resultScope->typeOfThisExpr = td.Obj();
					for (auto memberDecl : node->declarations)
					{
						BuildScopeForDeclaration(manager, resultScope, memberDecl, node);
					}
				}

				void Visit(WfEnumDeclaration* node)override
				{
					auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					parentScope->symbols.Add(symbol->name, symbol);

					for (auto item : node->items)
					{
						Visit(parentScope, item->attributes);
					}
				}

				void Visit(WfStructDeclaration* node)override
				{
					auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					parentScope->symbols.Add(symbol->name, symbol);

					for (auto member : node->members)
					{
						Visit(parentScope, member->attributes);
					}
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						Execute(manager, parentScope, source, decl);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
					for (auto input : node->inputs)
					{
						auto stateSymbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
						stateSymbol->name = input->name.value;
						stateSymbol->creatorNode = input;
						parentScope->symbols.Add(stateSymbol->name, stateSymbol);
					}

					for (auto state : node->states)
					{
						auto stateSymbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
						stateSymbol->name = state->name.value;
						stateSymbol->creatorNode = state;
						parentScope->symbols.Add(stateSymbol->name, stateSymbol);

						auto stateScope = Ptr(new WfLexicalScope(parentScope));
						{
							auto config = Ptr(new WfLexicalFunctionConfig);
							stateScope->functionConfig = config;

							config->lambda = false;
							config->thisAccessable = true;
							config->parentThisAccessable = true;
						}
						stateScope->ownerNode = state;
						manager->nodeScopes.Add(state.Obj(), stateScope);

						for (auto argument : state->arguments)
						{
							auto argumentSymbol = Ptr(new WfLexicalSymbol(stateScope.Obj()));
							argumentSymbol->name = argument->name.value;
							argumentSymbol->type = argument->type;
							argumentSymbol->creatorNode = argument;
							stateScope->symbols.Add(argumentSymbol->name, argumentSymbol);
						}

						BuildScopeForStatement(manager, stateScope, state->statement);
					}
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, glr::ParsingAstBase* source, Ptr<WfDeclaration> declaration)
				{
					BuildScopeForDeclarationVisitor visitor(manager, parentScope, source);
					declaration->Accept(&visitor);
					visitor.Visit(parentScope, declaration->attributes);

					manager->declaractionScopeSources.Add(declaration, source);
					if (visitor.resultScope)
					{
						manager->nodeScopes.Add(declaration.Obj(), visitor.resultScope);
						visitor.resultScope->ownerNode = declaration;
					}
					else
					{
						manager->nodeScopes.Add(declaration.Obj(), parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScopeForStatement
***********************************************************************/

			class BuildScopeForStatementVisitor
				: public Object
				, public WfStatement::IVisitor
				, public WfVirtualCseStatement::IVisitor
				, public WfCoroutineStatement::IVisitor
				, public WfStateMachineStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfLexicalScope>						parentScope;
				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForStatementVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope)
					:manager(_manager)
					, parentScope(_parentScope)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfIfStatement* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));
					if (node->type)
					{
						auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						symbol->name = node->name.value;
						symbol->type = node->type;
						symbol->creatorNode = Ptr(node);
						resultScope->symbols.Add(symbol->name, symbol);
					}

					BuildScopeForExpression(manager, resultScope, node->expression);
					BuildScopeForStatement(manager, resultScope, node->trueBranch);
					if (node->falseBranch)
					{
						BuildScopeForStatement(manager, resultScope, node->falseBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->condition);
					BuildScopeForStatement(manager, parentScope, node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					BuildScopeForStatement(manager, parentScope, node->protectedStatement);
					if (node->catchStatement)
					{
						resultScope = Ptr(new WfLexicalScope(parentScope));

						auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						symbol->name = node->name.value;
						symbol->creatorNode = Ptr(node);
						{
							auto system = Ptr(new WfTopQualifiedType);
							system->name.value = L"system";

							auto exception = Ptr(new WfChildType);
							exception->parent = system;
							exception->name.value = L"Exception";

							auto sharedPtr = Ptr(new WfSharedPointerType);
							sharedPtr->element = exception;

							symbol->type = sharedPtr;
						}
						resultScope->symbols.Add(symbol->name, symbol);

						BuildScopeForStatement(manager, resultScope, node->catchStatement);
					}
					if (node->finallyStatement)
					{
						BuildScopeForStatement(manager, parentScope, node->finallyStatement);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));

					for (auto statement : node->statements)
					{
						BuildScopeForStatement(manager, resultScope, statement);
					}
				}

				void Visit(WfGotoStatement* node)override
				{
				}

				void Visit(WfExpressionStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfVariableStatement* node)override
				{
					BuildScopeForDeclaration(manager, parentScope, node->variable, node);
				}

				void Visit(WfVirtualCseStatement* node)override
				{
					node->Accept((WfVirtualCseStatement::IVisitor*)this);
				}

				void Visit(WfSwitchStatement* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
					for (auto switchCase : node->caseBranches)
					{
						BuildScopeForExpression(manager, parentScope, switchCase->expression);
						BuildScopeForStatement(manager, parentScope, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						BuildScopeForStatement(manager, parentScope, node->defaultBranch);
					}
				}

				void Visit(WfForEachStatement* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));

					auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
					symbol->name = node->name.value;
					symbol->creatorNode = Ptr(node);
					resultScope->symbols.Add(symbol->name, symbol);

					BuildScopeForExpression(manager, parentScope, node->collection);
					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfCoProviderStatement* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));
					{
						auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						symbol->name = L"$PROVIDER";
						symbol->creatorNode = Ptr(node);
						resultScope->symbols.Add(symbol->name, symbol);
					}
					{
						auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						symbol->name = L"$IMPL";
						symbol->creatorNode = Ptr(node);
						resultScope->symbols.Add(symbol->name, symbol);
					}
					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfCoroutineStatement* node)override
				{
					node->Accept((WfCoroutineStatement::IVisitor*)this);
				}

				void Visit(WfCoPauseStatement* node)override
				{
					if (node->statement)
					{
						BuildScopeForStatement(manager, parentScope, node->statement);
					}
				}

				void Visit(WfCoOperatorStatement* node)override
				{
					if (node->varName.value != L"")
					{
						auto symbol = Ptr(new WfLexicalSymbol(parentScope.Obj()));
						symbol->name = node->varName.value;
						symbol->creatorNode = Ptr(node);
						parentScope->symbols.Add(symbol->name, symbol);
					}

					for (auto argument : node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}
				}

				void Visit(WfStateMachineStatement* node)override
				{
					node->Accept((WfStateMachineStatement::IVisitor*)this);
				}

				void Visit(WfStateSwitchStatement* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));

					for (auto switchCase : node->caseBranches)
					{
						auto caseScope = Ptr(new WfLexicalScope(resultScope));
						caseScope->ownerNode = switchCase;
						manager->nodeScopes.Add(switchCase.Obj(), caseScope);

						for (auto argument : switchCase->arguments)
						{
							auto symbol = Ptr(new WfLexicalSymbol(caseScope.Obj()));
							symbol->name = argument->name.value;
							symbol->creatorNode = argument;
							caseScope->symbols.Add(symbol->name, symbol);
						}

						BuildScopeForStatement(manager, caseScope, switchCase->statement);
					}
				}

				void Visit(WfStateInvokeStatement* node)override
				{
					for (auto argument : node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement)
				{
					BuildScopeForStatementVisitor visitor(manager, parentScope);
					statement->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->nodeScopes.Add(statement.Obj(), visitor.resultScope);
						visitor.resultScope->ownerNode = statement;
					}
					else
					{
						manager->nodeScopes.Add(statement.Obj(), parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScopeForExpression
***********************************************************************/

			class BuildScopeForExpressionVisitor
				: public Object
				, public WfExpression::IVisitor
				, public WfVirtualCseExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfLexicalScope>						parentScope;
				Ptr<WfLexicalScope>						resultScope;

				BuildScopeForExpressionVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScope> _parentScope)
					:manager(_manager)
					, parentScope(_parentScope)
				{
				}

				void Visit(WfThisExpression* node)override
				{
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					manager->CreateLambdaCapture(node);

					SortedList<vint> names;
					SearchOrderedName(parentScope.Obj(), node->body, names);

					resultScope = Ptr(new WfLexicalScope(parentScope));
					auto config = Ptr(new WfLexicalFunctionConfig);
					resultScope->functionConfig = config;

					config->lambda = true;
					config->thisAccessable = false;
					config->parentThisAccessable = true;

					for (auto name : names)
					{
						auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						symbol->name = L"$" + itow(name);
						symbol->creatorNode = Ptr(node);
						resultScope->symbols.Add(symbol->name, symbol);
					}

					BuildScopeForExpression(manager, resultScope, node->body);
				}

				void Visit(WfMemberExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
				}

				void Visit(WfChildExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfUnaryExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->operand);
				}

				void Visit(WfBinaryExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->first);
					BuildScopeForExpression(manager, parentScope, node->second);
				}

				void Visit(WfLetExpression* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));
					for (auto variable : node->variables)
					{
						auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						symbol->name = variable->name.value;
						symbol->creatorNode = Ptr(node);
						resultScope->symbols.Add(symbol->name, symbol);
						BuildScopeForExpression(manager, resultScope, variable->value);
					}

					BuildScopeForExpression(manager, resultScope, node->expression);
				}

				void Visit(WfIfExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->condition);
					BuildScopeForExpression(manager, parentScope, node->trueBranch);
					BuildScopeForExpression(manager, parentScope, node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->begin);
					BuildScopeForExpression(manager, parentScope, node->end);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->element);
					BuildScopeForExpression(manager, parentScope, node->collection);
				}

				void Visit(WfConstructorExpression* node)override
				{
					for (auto argument : node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument->key);
						if (argument->value)
						{
							BuildScopeForExpression(manager, parentScope, argument->value);
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->expression)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->event);
					BuildScopeForExpression(manager, parentScope, node->function);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->event);
					BuildScopeForExpression(manager, parentScope, node->handler);
				}

				void Visit(WfObserveExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->parent);
					if (node->observeType == WfObserveType::SimpleObserve)
					{
						BuildScopeForExpression(manager, parentScope, node->expression);
						for (auto event : node->events)
						{
							BuildScopeForExpression(manager, parentScope, event);
						}
					}
					else
					{
						resultScope = Ptr(new WfLexicalScope(parentScope));
						{
							auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
							symbol->name = node->name.value;
							symbol->creatorNode = Ptr(node);
							resultScope->symbols.Add(symbol->name, symbol);
						}

						BuildScopeForExpression(manager, resultScope, node->expression);
						for (auto event : node->events)
						{
							BuildScopeForExpression(manager, resultScope, event);
						}
					}
				}

				void Visit(WfCallExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->function);
					for (auto argument : node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					manager->CreateLambdaCapture(node->function.Obj());
					BuildScopeForDeclaration(manager, parentScope, node->function, node);
				}

				void Visit(WfNewClassExpression* node)override
				{
					for (auto argument : node->arguments)
					{
						BuildScopeForExpression(manager, parentScope, argument);
					}
				}

				class CreateLambdaCaptureVisitor
					: public empty_visitor::DeclarationVisitor
				{
				public:
					WfLexicalScopeManager*				manager;
					Ptr<WfLexicalCapture>				capture;

					CreateLambdaCaptureVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalCapture> _capture)
						:manager(_manager)
						, capture(_capture)
					{
					}

					void Dispatch(WfVirtualCfeDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							decl->Accept(this);
						}
					}

					void Dispatch(WfVirtualCseDeclaration* node)override
					{
					}

					void Visit(WfFunctionDeclaration* node)override
					{
						manager->CreateLambdaCapture(node, capture);
					}
				};

				void Visit(WfNewInterfaceExpression* node)override
				{
					resultScope = Ptr(new WfLexicalScope(parentScope));
					auto capture = Ptr(new WfLexicalCapture);
					manager->CreateLambdaCapture(node, capture);

					CreateLambdaCaptureVisitor visitor(manager, capture);
					for (auto memberDecl : node->declarations)
					{
						memberDecl->Accept(&visitor);
						BuildScopeForDeclaration(manager, resultScope, memberDecl, node);
					}
				}

				void Visit(WfVirtualCfeExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expandedExpression);
				}

				void Visit(WfVirtualCseExpression* node)override
				{
					node->Accept((WfVirtualCseExpression::IVisitor*)this);
				}

				void Visit(WfBindExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfNewCoroutineExpression* node)override
				{
					manager->CreateLambdaCapture(node);

					resultScope = Ptr(new WfLexicalScope(parentScope));
					auto config = Ptr(new WfLexicalFunctionConfig);
					resultScope->functionConfig = config;

					if (node->name.value != L"")
					{
						auto symbol = Ptr(new WfLexicalSymbol(resultScope.Obj()));
						symbol->name = node->name.value;
						symbol->creatorNode = Ptr(node);
						symbol->typeInfo = TypeInfoRetriver<Ptr<CoroutineResult>>::CreateTypeInfo();
						symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
						resultScope->symbols.Add(symbol->name, symbol);
					}

					config->lambda = true;
					config->thisAccessable = false;
					config->parentThisAccessable = true;

					BuildScopeForStatement(manager, resultScope, node->statement);
				}

				void Visit(WfMixinCastExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfExpectedTypeCastExpression* node)override
				{
					BuildScopeForExpression(manager, parentScope, node->expression);
				}

				void Visit(WfCoOperatorExpression* node)override
				{
				}

				static Ptr<WfLexicalScope> Execute(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression)
				{
					BuildScopeForExpressionVisitor visitor(manager, parentScope);
					expression->Accept(&visitor);
					if (visitor.resultScope)
					{
						manager->nodeScopes.Add(expression.Obj(), visitor.resultScope);
						visitor.resultScope->ownerNode = expression;
					}
					else
					{
						manager->nodeScopes.Add(expression.Obj(), parentScope);
					}
					return visitor.resultScope;
				}
			};

/***********************************************************************
BuildScope
***********************************************************************/

			void BuildScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				auto scope = Ptr(new WfLexicalScope(manager));
				scope->ownerNode = module;
				manager->nodeScopes.Add(module.Obj(), scope);

				for (auto declaration : module->declarations)
				{
					BuildScopeForDeclaration(manager, scope, declaration, module.Obj());
				}
			}

			void BuildScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfDeclaration> declaration, glr::ParsingAstBase* source)
			{
				BuildScopeForDeclarationVisitor::Execute(manager, parentScope, source, declaration);
			}

			void BuildScopeForStatement(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement)
			{
				BuildScopeForStatementVisitor::Execute(manager, parentScope, statement);
			}

			void BuildScopeForExpression(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression)
			{
				BuildScopeForExpressionVisitor::Execute(manager, parentScope, expression);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_CHECKSCOPES_CYCLEDEPENDENCY.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
CheckBaseClass
***********************************************************************/

			class CheckCycleDependencyDeclarationVisitor
				: public empty_visitor::DeclarationVisitor
				, public empty_visitor::VirtualCseDeclarationVisitor
			{
			public:
				WfLexicalScopeManager*							manager;
				ITypeDescriptor*								tdDescriptableObject = description::GetTypeDescriptor<DescriptableObject>();
				ITypeDescriptor*								tdIDescriptable = description::GetTypeDescriptor<IDescriptable>();
				vint											step = 0;
				Dictionary<ITypeDescriptor*, WfDeclaration*>	depItems;
				Group<ITypeDescriptor*, ITypeDescriptor*>		depGroup;

				CheckCycleDependencyDeclarationVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Dispatch(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Dispatch(WfVirtualCseDeclaration* node)override
				{
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					for (auto decl : node->declarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfStructDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto td = manager->declarationTypes[node].Obj();

					if (step == 1)
					{
						depItems.Add(td, node);
					}
					else if (step == 2)
					{
						vint count = td->GetPropertyCount();
						for (vint i = 0; i < count; i++)
						{
							auto propType = td->GetProperty(i)->GetReturn();
							if (propType->GetDecorator() == ITypeInfo::Nullable)
							{
								propType = propType->GetElementType();
							}
							if (propType->GetDecorator() == ITypeInfo::TypeDescriptor)
							{
								auto propTd = propType->GetTypeDescriptor();
								if (!depItems.Keys().Contains(propTd)) continue;

								if (td == propTd)
								{
									List<ITypeDescriptor*> tds;
									tds.Add(td);
									manager->errors.Add(WfErrors::StructRecursivelyIncludeItself(node, tds));
								}
								else if (propTd->GetTypeDescriptorFlags() == TypeDescriptorFlags::Struct)
								{
									if (!depGroup.Contains(td, propTd))
									{
										depGroup.Add(td, propTd);
									}
								}
							}
						}
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto td = manager->declarationTypes[node].Obj();

					if (step == 1)
					{
						depItems.Add(td, node);
					}
					else if (step == 2)
					{
						vint count = td->GetBaseTypeDescriptorCount();
						for (vint i = 0; i < count; i++)
						{
							auto baseTd = td->GetBaseTypeDescriptor(i);

							bool isClass = baseTd->GetTypeDescriptorFlags() == TypeDescriptorFlags::Class;
							bool isInterface = baseTd->GetTypeDescriptorFlags() == TypeDescriptorFlags::Interface;

							switch (node->kind)
							{
							case WfClassKind::Class:
								{
									if (!isClass || !baseTd->IsAggregatable())
									{
										if (!dynamic_cast<WfClass*>(baseTd) && baseTd != tdDescriptableObject)
										{
											manager->errors.Add(WfErrors::WrongBaseTypeOfClass(node, baseTd));
										}
									}
								}
								break;
							case WfClassKind::Interface:
								{
									if (!isInterface && baseTd != tdIDescriptable)
									{
										manager->errors.Add(WfErrors::WrongBaseTypeOfInterface(node, baseTd));
									}
								}
								break;
							default:;
							}

							if (!depItems.Keys().Contains(baseTd)) continue;

							if (baseTd == td)
							{
								List<ITypeDescriptor*> tds;
								tds.Add(td);
								if (isClass)
								{
									manager->errors.Add(WfErrors::ClassRecursiveInheritance(node, tds));
								}
								else if (isInterface)
								{
									manager->errors.Add(WfErrors::InterfaceRecursiveInheritance(node, tds));
								}
							}
							else if (baseTd->GetTypeDescriptorFlags() == td->GetTypeDescriptorFlags())
							{
								if (!depGroup.Contains(td, baseTd))
								{
									depGroup.Add(td, baseTd);
								}
							}
						}
					}

					for (auto memberDecl : node->declarations)
					{
						memberDecl->Accept(this);
					}
				}

				void Execute(vint _step)
				{
					step = _step;
					for (auto module : manager->GetModules())
					{
						for (auto declaration : module->declarations)
						{
							declaration->Accept(this);
						}
					}
				}

				void ExecuteCollectTypes()
				{
					Execute(1);
				}

				void ExecuteCollectDependencies()
				{
					Execute(2);
				}
			};

/***********************************************************************
CheckScopes_CycleDependency
***********************************************************************/

			void CheckScopes_DuplicatedBaseClass(WfLexicalScopeManager* manager, WfClassDeclaration* node, ITypeDescriptor* td)
			{
				List<ITypeDescriptor*> baseTypes;
				SortedList<ITypeDescriptor*> duplicatedTypes;
				baseTypes.Add(td);

				for (vint i = 0; i < baseTypes.Count(); i++)
				{
					auto currentTd = baseTypes[i];
					vint count = currentTd->GetBaseTypeDescriptorCount();
					for (vint j = 0; j < count; j++)
					{
						auto baseTd = currentTd->GetBaseTypeDescriptor(j);
						if (baseTd->GetTypeDescriptorFlags() == TypeDescriptorFlags::Class && baseTd != description::GetTypeDescriptor<DescriptableObject>())
						{
							if (baseTypes.Contains(baseTd))
							{
								if (!duplicatedTypes.Contains(baseTd))
								{
									duplicatedTypes.Add(baseTd);
									manager->errors.Add(WfErrors::DuplicatedBaseClass(node, baseTd));
								}
							}
							else
							{
								baseTypes.Add(baseTd);
							}
						}
					}
				}
			}

			bool CheckScopes_CycleDependency(WfLexicalScopeManager* manager)
			{
				vint errorCount = manager->errors.Count();
				CheckCycleDependencyDeclarationVisitor visitor(manager);
				visitor.ExecuteCollectTypes();
				visitor.ExecuteCollectDependencies();

				{
					PartialOrderingProcessor pop;
					pop.InitWithGroup(visitor.depItems.Keys(), visitor.depGroup);
					pop.Sort();

					for (vint i = 0; i < pop.components.Count(); i++)
					{
						auto& component = pop.components[i];
						if (component.nodeCount > 1)
						{
							List<ITypeDescriptor*> tds;
							CopyFrom(
								tds,
								From(component.firstNode, component.firstNode + component.nodeCount)
									.Select([&](vint nodeIndex)
									{
										return visitor.depItems.Keys()[nodeIndex];
									})
								);

							auto selectedTd = tds[0];
							for (auto candidateTd : From(tds).Skip(1))
							{
								auto selectedRange = visitor.depItems[selectedTd]->codeRange;
								auto candidateRange = visitor.depItems[candidateTd]->codeRange;

								if (candidateRange.codeIndex > selectedRange.codeIndex) { selectedTd = candidateTd; continue; }
								if (candidateRange.start > selectedRange.start) { selectedTd = candidateTd; continue; }
							}

							switch (selectedTd->GetTypeDescriptorFlags())
							{
							case TypeDescriptorFlags::Struct:
								manager->errors.Add(WfErrors::StructRecursivelyIncludeItself(dynamic_cast<WfStructDeclaration*>(visitor.depItems[selectedTd]), tds));
								break;
							case TypeDescriptorFlags::Class:
								manager->errors.Add(WfErrors::ClassRecursiveInheritance(dynamic_cast<WfClassDeclaration*>(visitor.depItems[selectedTd]), tds));
								break;
							case TypeDescriptorFlags::Interface:
								manager->errors.Add(WfErrors::InterfaceRecursiveInheritance(dynamic_cast<WfClassDeclaration*>(visitor.depItems[selectedTd]), tds));
								break;
							default:;
							}
						}
					}
				}

				if (errorCount == manager->errors.Count())
				{
					for (vint i = 0; i < visitor.depItems.Count(); i++)
					{
						auto key = visitor.depItems.Keys()[i];
						auto value = dynamic_cast<WfClassDeclaration*>(visitor.depItems.Values()[i]);
						if (value && value->kind == WfClassKind::Class)
						{
							CheckScopes_DuplicatedBaseClass(manager, value, key);
						}
					}
				}
				return errorCount == manager->errors.Count();
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_CHECKSCOPE_DUPLICATEDSYMBOL.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;

/***********************************************************************
CheckScopes_DuplicatedSymbol
***********************************************************************/

			bool CheckScopes_DuplicatedSymbol(WfLexicalScopeManager* manager)
			{
				vint errorCount = manager->errors.Count();
				for (auto scope : manager->nodeScopes.Values())
				{
					if (!manager->checkedScopes_DuplicatedSymbol.Contains(scope.Obj()))
					{
						manager->checkedScopes_DuplicatedSymbol.Add(scope.Obj());

						for (vint i = 0; i < scope->symbols.Count(); i++)
						{
							const auto& symbols = scope->symbols.GetByIndex(i);
							if (symbols.Count() > 1)
							{
								if (!scope->ownerNode.Cast<WfModule>() && !scope->ownerNode.Cast<WfNamespaceDeclaration>())
								{
									if (symbols.Count() > 1)
									{
										for (auto symbol : From(symbols))
										{
											if (auto decl = symbol->creatorNode.Cast<WfDeclaration>())
											{
												if (!decl.Cast<WfFunctionDeclaration>())
												{
													manager->errors.Add(WfErrors::DuplicatedSymbol(decl.Obj(), symbol));
												}
											}
											else if (auto arg = symbol->creatorNode.Cast<WfFunctionArgument>())
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(arg.Obj(), symbol));
											}
											else if (auto stat = symbol->creatorNode.Cast<WfStatement>())
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(stat.Obj(), symbol));
											}
											else if (auto expr = symbol->creatorNode.Cast<WfExpression>())
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(expr.Obj(), symbol));
											}
											else if (auto input = symbol->creatorNode.Cast<WfStateInput>())
											{
												if (symbols.Count() == 2)
												{
													// Ignore the generated function from the state input
													auto methodSymbol = symbols[1 - symbols.IndexOf(symbol.Obj())];
													auto funcDecl = methodSymbol->creatorNode.Cast<WfFunctionDeclaration>();
													vint index = manager->declarationMemberInfos.Keys().IndexOf(funcDecl.Obj());
													if (index != -1)
													{
														auto methodInfo = manager->declarationMemberInfos.Values()[index];
														if (manager->stateInputMethods[input.Obj()].Obj() == methodInfo.Obj())
														{
															goto NO_ERROR;
														}
													}
												}
												manager->errors.Add(WfErrors::DuplicatedSymbol(input.Obj(), symbol));
											NO_ERROR:;
											}
											else if (auto state = symbol->creatorNode.Cast<WfStateDeclaration>())
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(state.Obj(), symbol));
											}
											else if (auto sarg = symbol->creatorNode.Cast<WfStateSwitchArgument>())
											{
												manager->errors.Add(WfErrors::DuplicatedSymbol(sarg.Obj(), symbol));
											}
										}
									}
								}
							}
						}
					}
				}
				return errorCount == manager->errors.Count();
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_CHECKSCOPE_SYMBOLTYPE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;

/***********************************************************************
CheckScopes_SymbolType
***********************************************************************/

			bool CheckScopes_SymbolType(WfLexicalScopeManager* manager)
			{
				vint errorCount = manager->errors.Count();
				for (auto scope : From(manager->nodeScopes)
					.Select([](auto&& pair) -> Pair<glr::ParsingAstBase*, Ptr<WfLexicalScope>> { return pair; })
					.OrderBy([](auto&& a, auto&& b)
					{
						auto rangeA = a.key->codeRange;
						auto rangeB = b.key->codeRange;

						std::strong_ordering
						result = rangeA.codeIndex <=> rangeB.codeIndex; if (result != 0) return result;
						result = rangeA.start <=> rangeB.start; if (result != 0) return result;
						return result;
					})
					.Select([](auto&& pair) { return pair.value; })
					)
				{
					if (!manager->checkedScopes_SymbolType.Contains(scope.Obj()))
					{
						manager->checkedScopes_SymbolType.Add(scope.Obj());

						for (vint i = 0; i < scope->symbols.Count(); i++)
						{
							for (auto symbol : scope->symbols.GetByIndex(i))
							{
								if (symbol->type)
								{
									symbol->typeInfo = CreateTypeInfoFromType(scope.Obj(), symbol->type);
								}
							}
						}
					}
				}
				return errorCount == manager->errors.Count();
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_COMPLETESCOPE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
CompleteScopeForClassMember
***********************************************************************/

			class CompleteScopeForClassMemberVisitor
				: public Object
				, public WfDeclaration::IVisitor
				, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Ptr<WfCustomType>						td;

				CompleteScopeForClassMemberVisitor(WfLexicalScopeManager* _manager, Ptr<WfCustomType> _td)
					:manager(_manager)
					, td(_td)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto info = manager->declarationMemberInfos[node].Cast<WfMethodBase>();

					for (auto argument : node->arguments)
					{
						if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), argument->type))
						{
							auto paramInfo = Ptr(new ParameterInfoImpl(info.Obj(), argument->name.value, typeInfo));
							info->AddParameter(paramInfo);
						}
					}

					if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), node->returnType))
					{
						info->SetReturn(typeInfo);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), node->type))
					{
						auto info = manager->declarationMemberInfos[node].Cast<WfField>();
						info->SetReturn(typeInfo);
					}
				}

				void Visit(WfEventDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto type = Ptr(new WfFunctionType);
					{
						auto voidType = Ptr(new WfPredefinedType);
						voidType->name = WfPredefinedTypeName::Void;
						type->result = voidType;
					}
					for (auto argument : node->arguments)
					{
						type->arguments.Add(argument);
					}

					if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), type))
					{
						auto info = manager->declarationMemberInfos[node].Cast<WfEvent>();
						info->SetHandlerType(typeInfo);
					}
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto info = manager->declarationMemberInfos[node].Cast<WfProperty>();

					if (node->getter.value != L"")
					{
						info->SetGetter(dynamic_cast<MethodInfoImpl*>(td->GetMethodGroupByName(node->getter.value, false)->GetMethod(0)));
					}

					if (node->setter.value != L"")
					{
						info->SetSetter(dynamic_cast<MethodInfoImpl*>(td->GetMethodGroupByName(node->setter.value, false)->GetMethod(0)));
					}

					if (node->valueChangedEvent.value != L"")
					{
						info->SetValueChangedEvent(dynamic_cast<EventInfoImpl*>(td->GetEventByName(node->valueChangedEvent.value, false)));
					}
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto info = manager->declarationMemberInfos[node].Cast<WfClassConstructor>();

					for (auto argument : node->arguments)
					{
						if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), argument->type))
						{
							auto paramInfo = Ptr(new ParameterInfoImpl(info.Obj(), argument->name.value, typeInfo));
							info->AddParameter(paramInfo);
						}
					}
				}

				void Visit(WfDestructorDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					CompleteScopeForDeclaration(manager, node);
				}

				void Visit(WfEnumDeclaration* node)override
				{
					CompleteScopeForDeclaration(manager, node);
				}

				void Visit(WfStructDeclaration* node)override
				{
					CompleteScopeForDeclaration(manager, node);
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					for (auto input : node->inputs)
					{
						auto method = manager->stateInputMethods[input.Obj()];
						method->SetReturn(TypeInfoRetriver<void>::CreateTypeInfo());

						for (auto argument : input->arguments)
						{
							if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), argument->type))
							{
								auto field = manager->stateInputArguments[argument.Obj()];
								field->SetReturn(typeInfo);

								method->AddParameter(Ptr(new ParameterInfoImpl(method.Obj(), argument->name.value, typeInfo)));
							}
						}
					}

					for (auto state : node->states)
					{
						for (auto argument : state->arguments)
						{
							if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), argument->type))
							{
								auto field = manager->stateDeclArguments[argument.Obj()];
								field->SetReturn(typeInfo);
							}
						}
					}

					auto& smInfo = manager->stateMachineInfos[node];
					smInfo->createCoroutineMethod->AddParameter(Ptr(new ParameterInfoImpl(smInfo->createCoroutineMethod.Obj(), L"<state>startState", manager->cputiSInt)));
					smInfo->createCoroutineMethod->SetReturn(TypeInfoRetriver<void>::CreateTypeInfo());
				}

				static void Execute(WfLexicalScopeManager* manager, Ptr<WfCustomType> td, Ptr<WfDeclaration> memberDecl)
				{
					CompleteScopeForClassMemberVisitor visitor(manager, td);
					memberDecl->Accept(&visitor);
				}
			};

/***********************************************************************
CompleteScopeForDeclaration
***********************************************************************/

			class CompleteScopeForDeclarationVisitor
				: public Object
				, public WfDeclaration::IVisitor
				, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;

				CompleteScopeForDeclarationVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					for (auto decl : node->declarations)
					{
						CompleteScopeForDeclaration(manager, decl.Obj());
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
				}

				void Visit(WfDestructorDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto td = manager->declarationTypes[node].Cast<WfCustomType>();

					if (node->baseTypes.Count() > 0)
					{
						for (auto baseType : node->baseTypes)
						{
							if (auto scopeName = GetScopeNameFromReferenceType(scope->parentScope.Obj(), baseType))
							{
								if (scopeName->typeDescriptor)
								{
									td->AddBaseType(scopeName->typeDescriptor);
								}
							}
						}
					}
					else if (node->kind == WfClassKind::Class)
					{
						td->AddBaseType(description::GetTypeDescriptor<DescriptableObject>());
					}
					else if (node->kind == WfClassKind::Interface)
					{
						td->AddBaseType(description::GetTypeDescriptor<IDescriptable>());
					}

					if (node->kind == WfClassKind::Interface)
					{
						switch (node->constructorType)
						{
						case WfConstructorType::SharedPtr:
							{
								auto elementType = Ptr(new TypeDescriptorTypeInfo(td.Obj(), TypeInfoHint::Normal));
								auto pointerType = Ptr(new SharedPtrTypeInfo(elementType));

								auto ctor = Ptr(new WfInterfaceConstructor(pointerType));
								td->AddMember(ctor);
							}
							break;
						case WfConstructorType::RawPtr:
							{
								auto elementType = Ptr(new TypeDescriptorTypeInfo(td.Obj(), TypeInfoHint::Normal));
								auto pointerType = Ptr(new RawPtrTypeInfo(elementType));

								auto ctor = Ptr(new WfInterfaceConstructor(pointerType));
								td->AddMember(ctor);
							}
							break;
						default:;
						}
					}

					for (auto memberDecl : node->declarations)
					{
						CompleteScopeForClassMember(manager, td, memberDecl);
					}
				}

				void Visit(WfEnumDeclaration* node)override
				{
					auto td = manager->declarationTypes[node].Cast<WfEnum>();
					Dictionary<WString, vuint64_t> items;
					for (auto item : node->items)
					{
						vuint64_t value = 0;
						switch (item->kind)
						{
						case WfEnumItemKind::Constant:
							TypedValueSerializerProvider<vuint64_t>::Deserialize(item->number.value, value);
							break;
						case WfEnumItemKind::Intersection:
							for (auto itemInt : item->intersections)
							{
								value |= items[itemInt->name.value];
							}
							break;
						default:;
						}
						td->AddEnumItem(item->name.value, value);
						items.Add(item->name.value, value);
					}
				}

				void Visit(WfStructDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto td = manager->declarationTypes[node].Cast<WfStruct>();
					for (auto member : node->members)
					{
						if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), member->type))
						{
							auto field = Ptr(new WfStructField(td.Obj(), member->name.value));
							field->SetReturn(typeInfo);
							td->AddMember(field);
						}
					}
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
				}

				static void Execute(WfLexicalScopeManager* manager, WfDeclaration* declaration)
				{
					CompleteScopeForDeclarationVisitor visitor(manager);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
CompleteScope
***********************************************************************/

			void CompleteScopeForClassMember(WfLexicalScopeManager* manager, Ptr<WfCustomType> td, Ptr<WfDeclaration> memberDecl)
			{
				CompleteScopeForClassMemberVisitor::Execute(manager, td, memberDecl);
			}

			void CompleteScopeForDeclaration(WfLexicalScopeManager* manager, WfDeclaration* declaration)
			{
				CompleteScopeForDeclarationVisitor::Execute(manager, declaration);
			}

			void CompleteScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				for (auto declaration : module->declarations)
				{
					CompleteScopeForDeclaration(manager, declaration.Obj());
				}
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_CONTEXTFREEDESUGAR.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace glr;
			using namespace reflection::description;

/***********************************************************************
SetCodeRange
***********************************************************************/

			class SetCodeRangeVisitor : public traverse_visitor::AstVisitor
			{
			public:
				ParsingTextRange						range;
				bool									asOffset;

				SetCodeRangeVisitor(ParsingTextRange _range, bool _asOffset)
					:range(_range)
					, asOffset(_asOffset)
				{
				}

				void UpdateTextPos(ParsingTextPos& pos)
				{
					if (pos.row == -1 || pos.column == -1)
					{
						pos = range.start;
					}
					else 
					{
						if (pos.row == 0)
						{
							pos.column += range.start.column;
						}
						pos.row += range.start.row;
					}
				}

				void Traverse(ParsingAstBase *node)override
				{
					if (node->codeRange == ParsingTextRange())
					{
						node->codeRange = range;
					}
					else if (asOffset)
					{
						UpdateTextPos(node->codeRange.start);
						UpdateTextPos(node->codeRange.end);
						if (node->codeRange.codeIndex == -1)
						{
							node->codeRange.codeIndex = range.codeIndex;
						}
					}
				}

				void Traverse(ParsingToken& token)override
				{
					if (token.codeRange == ParsingTextRange())
					{
						token.codeRange = range;
					}
					else if (asOffset)
					{
						UpdateTextPos(token.codeRange.start);
						UpdateTextPos(token.codeRange.end);
						if (token.codeRange.codeIndex == -1)
						{
							token.codeRange.codeIndex = range.codeIndex;
						}
					}
				}
			};

			void SetCodeRange(Ptr<WfType> node, glr::ParsingTextRange codeRange, bool asOffset)
			{
				SetCodeRangeVisitor(codeRange, asOffset).InspectInto(node.Obj());
			}

			void SetCodeRange(Ptr<WfExpression> node, glr::ParsingTextRange codeRange, bool asOffset)
			{
				SetCodeRangeVisitor(codeRange, asOffset).InspectInto(node.Obj());
			}

			void SetCodeRange(Ptr<WfStatement> node, glr::ParsingTextRange codeRange, bool asOffset)
			{
				SetCodeRangeVisitor(codeRange, asOffset).InspectInto(node.Obj());
			}

			void SetCodeRange(Ptr<WfDeclaration> node, glr::ParsingTextRange codeRange, bool asOffset)
			{
				SetCodeRangeVisitor(codeRange, asOffset).InspectInto(node.Obj());
			}

			void SetCodeRange(Ptr<WfModule> node, glr::ParsingTextRange codeRange, bool asOffset)
			{
				SetCodeRangeVisitor(codeRange, asOffset).InspectInto(node.Obj());
			}

/***********************************************************************
ContextFreeModuleDesugar
***********************************************************************/

			class ContextFreeDesugarVisitor : public traverse_visitor::AstVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				WfClassDeclaration*						surroundingClassDecl = nullptr;
				WfNewInterfaceExpression*				surroundingLambda = nullptr;

				ContextFreeDesugarVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Traverse(WfFormatExpression* node)override
				{
					if (node->expandedExpression)
					{
						return;
					}

					List<Ptr<WfExpression>> expressions;
					const wchar_t* reading = node->value.value.Buffer();

					const wchar_t* textPosCounter = reading;
					ParsingTextPos formatPos = node->codeRange.start;
					formatPos.column += 2;

					while (*reading)
					{
						const wchar_t* begin = wcsstr(reading, L"$(");
						if (begin)
						{
							auto expression = Ptr(new WfStringExpression);
							expression->codeRange = node->codeRange;
							expression->value.value = WString::CopyFrom(reading, vint(begin - reading));
							expressions.Add(expression);
						}
						else
						{
							break;
						}

						const wchar_t* end = begin + 2;
						vint counter = 1;
						while (wchar_t c = *end++)
						{
							switch (c)
							{
							case L'(':
								counter++;
								break;
							case L')':
								counter--;
								break;
							}
							if (counter == 0)
							{
								break;
							}
						}

						if (counter != 0)
						{
							auto error = WfErrors::WrongFormatStringSyntax(node);
							error.message += L" (Does not find matched close bracket.)";
							manager->errors.Add(error);
							return;
						}
						else
						{
							WString input = WString::CopyFrom(begin + 2, vint(end - begin - 3));
							vint currentErrorCount = manager->errors.Count();

							if (auto expression = ParseExpression(input, manager->workflowParser))
							{
								expressions.Add(expression);

								while (textPosCounter++ < begin + 2)
								{
									switch (textPosCounter[-1])
									{
									case '\n':
										formatPos.row++;
										formatPos.column = 0;
										break;
									default:
										formatPos.column++;
										break;
									}
								}
								SetCodeRange(expression, { formatPos,formatPos,node->codeRange.codeIndex }, true);
							}

							for (vint i = currentErrorCount; i < manager->errors.Count(); i++)
							{
								auto&& existing = manager->errors[i];
								auto error = WfErrors::WrongFormatStringSyntax(node);
								existing.message = error.message + L" (" + existing.message + L")";
							}
							reading = end;
						}
					}
					if (*reading || expressions.Count() == 0)
					{
						auto expression = Ptr(new WfStringExpression);
						expression->codeRange = node->codeRange;
						expression->value.value = reading;
						expressions.Add(expression);
					}

					if (expressions.Count() > 0)
					{
						Ptr<WfExpression> current = expressions[0];
						for (auto expression : From(expressions).Skip(1))
						{
							auto binary = Ptr(new WfBinaryExpression);
							binary->codeRange = node->codeRange;
							binary->first = current;
							binary->second = expression;
							binary->op = WfBinaryOperator::FlagAnd;
							current = binary;
						}

						node->expandedExpression = current;
						SetCodeRange(node->expandedExpression, node->codeRange);
					}
				}

				void Traverse(WfAutoPropertyDeclaration* node)override
				{
					if (node->expandedDeclarations.Count() > 0)
					{
						return;
					}

					bool needVariable = false;
					bool needVirtual = false;
					bool needEvent = false;
					bool needProperty = false;

					if (surroundingClassDecl)
					{
						switch (surroundingClassDecl->kind)
						{
						case WfClassKind::Class:
							{
								needVariable = true;
								needVirtual = false;
								needEvent = node->configObserve == WfAPObserve::Observable;
								needProperty = true;
							}
							break;
						case WfClassKind::Interface:
							{
								needVariable = false;
								needVirtual = true;
								needEvent = node->configObserve == WfAPObserve::Observable;
								needProperty = true;
							}
							break;
						default:;
						}
					}
					else if (surroundingLambda)
					{
						needVariable = true;
						needVirtual = false;
						needEvent = false;
						needProperty = false;
					}

					auto varName = L"<prop>" + node->name.value;
					auto getterName = L"Get" + node->name.value;
					auto setterName = L"Set" + node->name.value;
					auto eventName = node->name.value + L"Changed";

					if (needVariable && node->expression)
					{
						auto decl = Ptr(new WfVariableDeclaration);
						node->expandedDeclarations.Add(decl);

						decl->name.value = varName;
						decl->type = CopyType(node->type);
						decl->expression = CopyExpression(node->expression, true);

						auto att = Ptr(new WfAttribute);
						att->category.value = L"cpp";
						att->name.value = L"Private";
						decl->attributes.Add(att);
					}

					{
						auto decl = Ptr(new WfFunctionDeclaration);
						node->expandedDeclarations.Add(decl);

						decl->functionKind = WfFunctionKind::Normal;
						decl->anonymity = WfFunctionAnonymity::Named;
						decl->name.value = getterName;
						decl->returnType = CopyType(node->type);

						if (!needVirtual)
						{
							auto refExpr = Ptr(new WfReferenceExpression);
							refExpr->name.value = varName;

							auto returnStat = Ptr(new WfReturnStatement);
							returnStat->expression = refExpr;

							auto block = Ptr(new WfBlockStatement);
							block->statements.Add(returnStat);
							decl->statement = block;
						}
					}

					if (!needVirtual || node->configConst == WfAPConst::Writable)
					{
						auto decl = Ptr(new WfFunctionDeclaration);
						node->expandedDeclarations.Add(decl);

						decl->functionKind = WfFunctionKind::Normal;
						decl->anonymity = WfFunctionAnonymity::Named;
						decl->name.value = setterName;

						if (node->configConst == WfAPConst::Readonly)
						{
							auto att = Ptr(new WfAttribute);
							att->category.value = L"cpp";
							att->name.value = L"Protected";
							decl->attributes.Add(att);
						}

						{
							auto argument = Ptr(new WfFunctionArgument);
							argument->name.value = L"<value>";
							argument->type = CopyType(node->type);
							decl->arguments.Add(argument);
						}
						{
							auto voidType = Ptr(new WfPredefinedType);
							voidType->name = WfPredefinedTypeName::Void;
							decl->returnType = voidType;
						}

						if (!needVirtual)
						{
							auto block = Ptr(new WfBlockStatement);
							decl->statement = block;

							auto createBinaryExpr = [&](WfBinaryOperator op)
							{
								auto refArgument = Ptr(new WfReferenceExpression);
								refArgument->name.value = L"<value>";

								auto refVar = Ptr(new WfReferenceExpression);
								refVar->name.value = varName;

								auto binaryExpr = Ptr(new WfBinaryExpression);
								binaryExpr->first = refVar;
								binaryExpr->second = refArgument;
								binaryExpr->op = op;

								return binaryExpr;
							};

							if (node->configObserve == WfAPObserve::Observable)
							{
								auto ifStat = Ptr(new WfIfStatement);
								ifStat->expression = createBinaryExpr(WfBinaryOperator::NE);

								auto trueBlock = Ptr(new WfBlockStatement);
								ifStat->trueBranch = trueBlock;

								{
									auto stat = Ptr(new WfExpressionStatement);
									stat->expression = createBinaryExpr(WfBinaryOperator::Assign);
									trueBlock->statements.Add(stat);
								}
								{
									auto refEvent = Ptr(new WfReferenceExpression);
									refEvent->name.value = eventName;

									auto callExpr = Ptr(new WfCallExpression);
									callExpr->function = refEvent;

									auto stat = Ptr(new WfExpressionStatement);
									stat->expression = callExpr;
									trueBlock->statements.Add(stat);
								}

								block->statements.Add(ifStat);
							}
							else
							{
								auto stat = Ptr(new WfExpressionStatement);
								stat->expression = createBinaryExpr(WfBinaryOperator::Assign);

								block->statements.Add(stat);
							}
						}
					}

					if (needEvent)
					{
						auto decl = Ptr(new WfEventDeclaration);
						node->expandedDeclarations.Add(decl);

						decl->name.value = eventName;
					}

					if (needProperty)
					{
						auto decl = Ptr(new WfPropertyDeclaration);
						node->expandedDeclarations.Add(decl);

						decl->type = CopyType(node->type);
						decl->name.value = node->name.value;
						decl->getter.value = getterName;
						if (node->configConst == WfAPConst::Writable)
						{
							decl->setter.value = setterName;
						}
						if (node->configObserve == WfAPObserve::Observable)
						{
							decl->valueChangedEvent.value = eventName;
						}
					}

					for (auto decl : From(node->expandedDeclarations).FindType<WfFunctionDeclaration>())
					{
						decl->functionKind = WfFunctionKind::Normal;
						if (surroundingLambda)
						{
							if (decl->name.value == getterName)
							{
								decl->functionKind = WfFunctionKind::Override;
							}
							else if (decl->name.value == setterName)
							{
								if (node->configConst == WfAPConst::Writable)
								{
									decl->functionKind = WfFunctionKind::Override;
								}
							}
						}

						SetCodeRange(decl, node->codeRange);
					}
				}

				void Traverse(WfCastResultInterfaceDeclaration* node)override
				{
					if (node->expandedDeclarations.Count() > 0)
					{
						return;
					}

					auto decl = Ptr(new WfClassDeclaration);
					node->expandedDeclarations.Add(decl);
					decl->kind = WfClassKind::Interface;
					decl->constructorType = WfConstructorType::SharedPtr;
					decl->name.value = node->name.value;
					decl->baseTypes.Add(CopyType(node->baseType));

					{
						auto funcDecl = Ptr(new WfFunctionDeclaration);
						decl->declarations.Add(funcDecl);
						funcDecl->functionKind = WfFunctionKind::Static;
						funcDecl->anonymity = WfFunctionAnonymity::Named;
						funcDecl->name.value = L"CastResult";
						funcDecl->returnType = CopyType(node->elementType);
						{
							auto argument = Ptr(new WfFunctionArgument);
							funcDecl->arguments.Add(argument);
							argument->name.value = L"value";
							argument->type = GetTypeFromTypeInfo(TypeInfoRetriver<Value>::CreateTypeInfo().Obj());
						}
						{
							auto block = Ptr(new WfBlockStatement);
							funcDecl->statement = block;

							auto refValue = Ptr(new WfReferenceExpression);
							refValue->name.value = L"value";

							auto castExpr = Ptr(new WfTypeCastingExpression);
							castExpr->strategy = WfTypeCastingStrategy::Strong;
							castExpr->type = CopyType(node->elementType);
							castExpr->expression = refValue;

							auto stat = Ptr(new WfReturnStatement);
							stat->expression = castExpr;

							block->statements.Add(stat);
						}
					}
					{
						auto funcDecl = Ptr(new WfFunctionDeclaration);
						decl->declarations.Add(funcDecl);
						funcDecl->functionKind = WfFunctionKind::Static;
						funcDecl->anonymity = WfFunctionAnonymity::Named;
						funcDecl->name.value = L"StoreResult";
						funcDecl->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<Value>::CreateTypeInfo().Obj());
						{
							auto argument = Ptr(new WfFunctionArgument);
							funcDecl->arguments.Add(argument);
							argument->name.value = L"value";
							argument->type = CopyType(node->elementType);
						}
						{
							auto block = Ptr(new WfBlockStatement);
							funcDecl->statement = block;

							auto refValue = Ptr(new WfReferenceExpression);
							refValue->name.value = L"value";

							auto stat = Ptr(new WfReturnStatement);
							stat->expression = refValue;

							block->statements.Add(stat);
						}
					}

					SetCodeRange(Ptr<WfDeclaration>(decl), node->codeRange);
				}

#define PUSH_SURROUNDING\
					auto o1 = surroundingClassDecl;\
					auto o2 = surroundingLambda;\
					surroundingClassDecl = nullptr;\
					surroundingLambda = nullptr;\

#define POP_SURROUNDING\
					surroundingClassDecl = o1;\
					surroundingLambda = o2;\

				void Visit(WfClassDeclaration* node)override
				{
					PUSH_SURROUNDING
					surroundingClassDecl = node;
					traverse_visitor::AstVisitor::Visit(node);
					POP_SURROUNDING
				}

				void Visit(WfNewInterfaceExpression* node)override
				{
					PUSH_SURROUNDING
					surroundingLambda = node;
					traverse_visitor::AstVisitor::Visit(node);
					POP_SURROUNDING
				}

#undef PUSH_SURROUNDING
#undef POP_SURROUNDING
			};

			void ContextFreeModuleDesugar(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				ContextFreeDesugarVisitor(manager).InspectInto(module.Obj());
			}

			void ContextFreeDeclarationDesugar(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration)
			{
				ContextFreeDesugarVisitor(manager).InspectInto(declaration.Obj());
			}

			void ContextFreeStatementDesugar(WfLexicalScopeManager* manager, Ptr<WfStatement> statement)
			{
				ContextFreeDesugarVisitor(manager).InspectInto(statement.Obj());
			}

			void ContextFreeExpressionDesugar(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				ContextFreeDesugarVisitor(manager).InspectInto(expression.Obj());
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_ERRORS.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace glr;
			using namespace reflection;
			using namespace reflection::description;

			ParsingError MakeParsingError(ParsingAstBase* node, const WString& message)
			{
				return { node, node->codeRange, message };
			}

			template<typename T, typename F>
			WString ListToErrorMessage(List<T>& items, F&& f)
			{
				WString description;
				for (auto friendlyName : From(items)
					.Select(f)
					.OrderBySelf()
					)
				{
					description += L"\r\n\t";
					description += friendlyName;
				}
				return description;
			}

/***********************************************************************
WfErrors
***********************************************************************/

			glr::ParsingError WfErrors::WrongFormatStringSyntax(WfExpression* node)
			{
				return MakeParsingError(node, L"A0: Wrong format string syntax.");
			}

			glr::ParsingError WfErrors::WrongSimpleObserveExpression(WfExpression* node)
			{
				return MakeParsingError(node, L"A1: Simple observe expression should observe a property under the observed object.");
			}

			glr::ParsingError WfErrors::WrongSimpleObserveEvent(WfExpression* node)
			{
				return MakeParsingError(node, L"A2: Simple observe expression should react to an event under the observed object.");
			}

			glr::ParsingError WfErrors::EmptyObserveEvent(WfExpression* node)
			{
				return MakeParsingError(node, L"A2: Observe expression should react to at least one event.");
			}

			glr::ParsingError WfErrors::ObserveNotInBind(WfExpression* node)
			{
				return MakeParsingError(node, L"A3: Observe expression should appear in a bind expression.");
			}

			glr::ParsingError WfErrors::ObserveInObserveEvent(WfExpression* node)
			{
				return MakeParsingError(node, L"A4: Observe expression should not appear in the event expression in another observe expression.");
			}

			glr::ParsingError WfErrors::BindInBind(WfExpression* node)
			{
				return MakeParsingError(node, L"A4: Bind expression should not appear in another bind expression.");
			}

			glr::ParsingError WfErrors::AttachInBind(WfExpression* node)
			{
				return MakeParsingError(node, L"A4: Attach expression should not appear in another bind expression.");
			}

			glr::ParsingError WfErrors::DetachInBind(WfExpression* node)
			{
				return MakeParsingError(node, L"A4: Detach expression should not appear in another bind expression.");
			}

			glr::ParsingError WfErrors::ConstructorMixMapAndList(WfExpression* node)
			{
				return MakeParsingError(node, L"A5: Key-value pairs are not allowed in list constructor expression.");
			}

			glr::ParsingError WfErrors::ConstructorMixStructAndList(WfExpression* node)
			{
				return MakeParsingError(node, L"A5: Field-value pairs are expected in struct constructor expression.");
			}

			glr::ParsingError WfErrors::DuplicatedConstructorField(WfReferenceExpression* node)
			{
				return MakeParsingError(node, L"A5: The same field cannot be assigned more than once in struct constructor expression.");
			}

			glr::ParsingError WfErrors::ConstructorMixClassAndInterface(WfNewClassExpression* node)
			{
				return MakeParsingError(node, L"A6: Arguments are not allowed in new interface expression.");
			}

			glr::ParsingError WfErrors::ConstructorMixClassAndInterface(WfNewInterfaceExpression* node)
			{
				return MakeParsingError(node, L"A6: Members are not allowed in new class expression.");
			}

			glr::ParsingError WfErrors::ScopeNameIsNotExpression(WfExpression* node, Ptr<WfLexicalScopeName> scopeName)
			{
				return MakeParsingError(node, L"A7: Symbol \"" + scopeName->GetFriendlyName() + L"\" cannot be used as an expression.");
			}

			glr::ParsingError WfErrors::EventIsNotExpression(WfExpression* node, reflection::description::IEventInfo* eventInfo)
			{
				return MakeParsingError(node, L"A7: Event \"" + eventInfo->GetName() + L"\" of type \"" + eventInfo->GetOwnerTypeDescriptor()->GetTypeName() + L"\" cannot be used as an expression.");
			}

			glr::ParsingError WfErrors::ExpressionIsNotScopeName(WfExpression* node)
			{
				return MakeParsingError(node, L"A8: Expression does not reference to a declaration.");
			}

			glr::ParsingError WfErrors::ExpressionIsNotEvent(WfExpression* node)
			{
				return MakeParsingError(node, L"A8: Expression does not reference to an event.");
			}

			glr::ParsingError WfErrors::ExpressionCannotResolveType(WfExpression* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"A9: Expression referencing to symbol \"" + symbol->name + L"\" failed to resolve its type.");
			}

			glr::ParsingError WfErrors::NullCannotResolveType(WfExpression* node)
			{
				return MakeParsingError(node, L"A9: Expression \"null\" failed to resolve its type.");
			}

			glr::ParsingError WfErrors::ConstructorCannotResolveType(WfExpression* node)
			{
				return MakeParsingError(node, L"A9: Expression \"{}\" failed to resolve its type.");
			}

			glr::ParsingError WfErrors::OrderedLambdaCannotResolveType(WfExpression* node)
			{
				return MakeParsingError(node, L"A9: Ordered lambda expression failed to resolve its type.");
			}

			glr::ParsingError WfErrors::NullCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A10: Expression \"null\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::ConstructorCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A10: Expression \"{}\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::OrderedLambdaCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A10: Ordered lambda expression cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::ExpressionCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A10: Expression of type \"" + fromType->GetTypeFriendlyName() + L"\" cannot implicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::ExpressionCannotExplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A11: Expression of type \"" + fromType->GetTypeFriendlyName() + L"\" cannot explicitly convert to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::CannotWeakCastToType(WfExpression* node, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A12: Expression cannot weakly cast to \"" + toType->GetTypeFriendlyName() + L"\" because it cannot be \"null\".");
			}

			glr::ParsingError WfErrors::IntegerLiteralOutOfRange(WfIntegerExpression* node)
			{
				return MakeParsingError(node, L"A13: Integer literal \"" + node->value.value + L"\" out of range.");
			}

			glr::ParsingError WfErrors::FloatingLiteralOutOfRange(WfFloatingExpression* node)
			{
				return MakeParsingError(node, L"A13: Floating literal \"" + node->value.value + L"\" out of range.");
			}

			glr::ParsingError WfErrors::CannotMergeTwoType(WfExpression* node, reflection::description::ITypeInfo* firstType, reflection::description::ITypeInfo* secondType)
			{
				return MakeParsingError(node, L"A14: Failed to merge type \"" + firstType->GetTypeFriendlyName() + L"\" with type \"" + secondType->GetTypeFriendlyName() + L"\" together to calculate the result type.");
			}

			glr::ParsingError WfErrors::RangeShouldBeInteger(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A15: Elements in a range expression should be integer, not \"" + type->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::UnaryOperatorOnWrongType(WfUnaryExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A16: Unary operator cannot apply on expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::BinaryOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A16: Binary operator cannot apply on expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::IndexOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* containerType)
			{
				return MakeParsingError(node, L"A17: Container of type \"" + containerType->GetTypeFriendlyName() + L"\" cannot be accessed using index.");
			}

			glr::ParsingError WfErrors::ExpressionIsNotCollection(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A18: Expression of type \"" + type->GetTypeFriendlyName() + L"\" is not an enumerable type.");
			}

			glr::ParsingError WfErrors::ExpressionIsNotFunction(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A19: Expression of type \"" + type->GetTypeFriendlyName() + L"\" is not an invokable function type.");
			}

			glr::ParsingError WfErrors::FunctionArgumentCountMismatched(glr::ParsingAstBase* node, vint expectedCount, const ResolveExpressionResult& function)
			{
				return MakeParsingError(node, L"A20: Function " + function.GetFriendlyName() + L"\" is not allowed to call with " + itow(expectedCount) + L" arguments.");
			}

			glr::ParsingError WfErrors::FunctionArgumentTypeMismatched(glr::ParsingAstBase* node, const ResolveExpressionResult& function, vint index, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A21: The " + itow(index) + L"-th argument of function " + function.GetFriendlyName() + L" cannot implicitly convert from \"" + fromType->GetTypeFriendlyName() + L"\" to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::CannotPickOverloadedFunctions(glr::ParsingAstBase* node, collections::List<ResolveExpressionResult>& results)
			{
				auto description = ListToErrorMessage(results, [](auto&& result) { return result.GetFriendlyName(); });
				return MakeParsingError(node, L"A22: Cannot decide which function to call in multiple targets: " + description + L".");
			}

			glr::ParsingError WfErrors::ClassContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A23: Class \"" + type->GetTypeFriendlyName() + L"\" does not contain any constructor.");
			}

			glr::ParsingError WfErrors::InterfaceContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				Ptr<ITypeInfo> proxy = TypeInfoRetriver<Ptr<IValueInterfaceProxy>>::CreateTypeInfo();
				return MakeParsingError(node, L"A23: Interface \"" + type->GetTypeFriendlyName() + L"\" does not contain any constructor receiving an \"" + proxy->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::ConstructorReturnTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A24: The return type of " + function.GetFriendlyName() + L" cannot implicitly convert from \"" + fromType->GetTypeFriendlyName() + L"\" to \"" + toType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::ExpressionIsNotLeftValue(WfExpression* node, const ResolveExpressionResult& result)
			{
				return MakeParsingError(node, L"A25: " + result.GetFriendlyName(true) + L" is not assignable.");
			}

			glr::ParsingError WfErrors::CannotCallMemberOutsideOfClass(WfExpression* node, const ResolveExpressionResult& result)
			{
				return MakeParsingError(node, L"A26: " + result.GetFriendlyName(true) + L" cannot be called as a static member.");
			}

			glr::ParsingError WfErrors::CannotCallMemberInStaticFunction(WfExpression* node, const ResolveExpressionResult& result)
			{
				return MakeParsingError(node, L"A27: " + result.GetFriendlyName(true) + L" cannot be called in static functions of its class or interface.");
			}

			glr::ParsingError WfErrors::FieldCannotInitializeUsingEachOther(WfExpression* node, const ResolveExpressionResult& result)
			{
				return MakeParsingError(node, L"A28: " + result.GetFriendlyName(true) + L" cannot be used to initialize other fields in the same type or new interface expression.");
			}

			glr::ParsingError WfErrors::WrongThisExpression(WfExpression* node)
			{
				return MakeParsingError(node, L"A29: The \"this\" expression can only be used in class methods or functions in new interface expressions");
			}

			glr::ParsingError WfErrors::IncorrectTypeForUnion(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A30: Expression of type \"" + type->GetTypeFriendlyName() + L"\" cannot be used in union (&) expression because it is not string or flag enum.");
			}

			glr::ParsingError WfErrors::IncorrectTypeForIntersect(WfExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"A30: Expression of type \"" + type->GetTypeFriendlyName() + L"\" cannot be used in intersect (|) expression because it is not flag enum.");
			}

			glr::ParsingError WfErrors::ExpressionIsNotConstant(WfExpression* node)
			{
				return MakeParsingError(node, L"A31: Expression is not constant. A constant expression consists of:\r\n"
					L"\tconstant primitive values\r\n"
					L"\tenum items\r\n"
					L"\tconstant unary (+, -, not) expressions\r\n"
					L"\tconstant binary (|) expressions\r\n"
					L"\tconstant range expressions\r\n"
					L"\tconstant constructor expressions (to create values of structs, lists or dictionarys)\r\n"
					L"\ttype() or typeof() expressions.");
			}

			glr::ParsingError WfErrors::WrongMixinTargetType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				return MakeParsingError(node, L"A32: Mixin cast cannot implicitly convert from \"" + fromType->GetTypeFriendlyName() + L"\" to \"" + toType->GetTypeFriendlyName() + L"\". It is only for converting from an interface to a derived interface.");
			}

			glr::ParsingError WfErrors::ExpectedTypeCastCannotResolveType(WfExpression* node)
			{
				return MakeParsingError(node, L"A33: Cannot resolve type \"*\". This expression should only appear on a place which has an explicit type, including variables and arguments.");
			}

			glr::ParsingError WfErrors::WrongVoidType(WfType* node)
			{
				return MakeParsingError(node, L"B0: Void is not a type for a value.");
			}

			glr::ParsingError WfErrors::WrongInterfaceType(WfType* node)
			{
				return MakeParsingError(node, L"B1: Interface is not a type for a value.");
			}

			glr::ParsingError WfErrors::RawPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return MakeParsingError(node, L"B2: A raw pointer" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a class or interface.");
			}

			glr::ParsingError WfErrors::SharedPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return MakeParsingError(node, L"B3: A shared pointer" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a class or interface.");
			}

			glr::ParsingError WfErrors::NullableToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return MakeParsingError(node, L"B4: A nullable value" + (typeInfo ? L" \"" + typeInfo->GetTypeFriendlyName() + L"\"" : L"") + L" should point to a struct.");
			}

			glr::ParsingError WfErrors::ChildOfNonReferenceType(WfType* node)
			{
				return MakeParsingError(node, L"B5: Only a reference type have child types.");
			}

			glr::ParsingError WfErrors::TypeNotExists(WfType* node, Ptr<WfLexicalScopeName> scopeName)
			{
				return MakeParsingError(node, L"B6: \"" + scopeName->GetFriendlyName() + L"\" is not a type.");
			}

			glr::ParsingError WfErrors::TypeNotExists(WfType* node, const ResolveExpressionResult& result)
			{
				return MakeParsingError(node, L"B6: \"" + result.GetFriendlyName() + L"\" is not a type.");
			}

			glr::ParsingError WfErrors::TypeNotForValue(WfType* node, reflection::description::ITypeInfo* typeInfo)
			{
				return MakeParsingError(node, L"B7: Type \"" + typeInfo->GetTypeFriendlyName() + L"\" is not a type for a value.");
			}

			glr::ParsingError WfErrors::BreakNotInLoop(WfStatement* node)
			{
				return MakeParsingError(node, L"C0: Break statement should appear in a loop.");
			}

			glr::ParsingError WfErrors::ContinueNotInLoop(WfStatement* node)
			{
				return MakeParsingError(node, L"C1: Continue statement should appear in a loop.");
			}

			glr::ParsingError WfErrors::RethrowNotInCatch(WfStatement* node)
			{
				return MakeParsingError(node, L"C2: Re-raise exception statement should appear in catch.");
			}

			glr::ParsingError WfErrors::TryMissCatchAndFinally(WfStatement* node)
			{
				return MakeParsingError(node, L"C3: Try statement should not appear without both catch and finally.");
			}

			glr::ParsingError WfErrors::ReturnMissExpression(WfStatement* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"C4: Return statement requires an expression of type \"" + type->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::DeleteNonRawPointer(WfStatement* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"C5: Delete statement cannot apply on an expression of type \"" + type->GetTypeFriendlyName() + L"\", which is expected to be a raw pointer.");
			}

			glr::ParsingError WfErrors::CannotReturnExpression(WfStatement* node)
			{
				return MakeParsingError(node, L"C6: Return statement cannot have a value inside void functions, constructors, destructors or $coroutine expressions.");
			}

			glr::ParsingError WfErrors::WrongCoPause(WfStatement* node)
			{
				return MakeParsingError(node, L"C7: $pause statement should appear inside a $coroutine expression, and it cannot be nested.");
			}

			glr::ParsingError WfErrors::WrongCoOperator(WfStatement* node)
			{
				return MakeParsingError(node, L"C8: $Operator statement should appear inside a coroutine function (which has a functiona body like ${} or $Provider{}).");
			}

			glr::ParsingError WfErrors::WrongCoOperator(WfExpression* node)
			{
				return MakeParsingError(node, L"C8: $.Operator expression should appear inside a coroutine function (which has a functiona body like ${} or $Provider{}).");
			}

			glr::ParsingError WfErrors::CoProviderNotExists(WfCoProviderStatement* node, collections::List<WString>& candidates)
			{
				auto description = ListToErrorMessage(candidates, [](auto&& candidate) { return candidate; });
				if (node->name.value == L"")
				{
					return MakeParsingError(node, L"C9: Cannot find a coroutine provider based on the function return type, all of the following types do not exist: " + description + L".");
				}
				else
				{
					return MakeParsingError(node, L"C9: Cannot find a coroutine provider based on the provider name \"" + node->name.value.Right(node->name.value.Length() - 1) + L"\", all of the following types do not exist: " + description + L".");
				}
			}

			glr::ParsingError WfErrors::CoOperatorNotExists(WfReturnStatement* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"C10: Static function \"ReturnAndExit\" does not exist in coroutine provider \"" + type->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::CoOperatorNotExists(WfCoOperatorStatement* node, reflection::description::ITypeInfo* type)
			{
				auto operatorName = node->opName.value.Right(node->opName.value.Length() - 1);
				if (node->varName.value == L"")
				{
					return MakeParsingError(node, L"C10: Static functions \"" + operatorName + L"AndPause\" and \"" + operatorName + L"AndRead\" do not exist in coroutine provider \"" + type->GetTypeFriendlyName() + L"\".");
				}
				else
				{
					return MakeParsingError(node, L"C10: Static function \"" + operatorName + L"AndRead\" does not exist in coroutine provider \"" + type->GetTypeFriendlyName() + L"\".");
				}
			}

			glr::ParsingError WfErrors::CoOperatorNotExists(WfCoOperatorExpression* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"C10: Static function \"QueryContext\" does not exist in coroutine provider \"" + type->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::CoOperatorCannotResolveResultType(WfCoOperatorStatement* node, collections::List<reflection::description::ITypeInfo*>& types)
			{
				auto operatorName = node->opName.value.Right(node->opName.value.Length() - 1);
				if (node->arguments.Count() == 0)
				{
					return MakeParsingError(node, L"C11: Failed to resolve the result type of coroutine operator \"" + operatorName + L"\", since there is no argument.");
				}
				else
				{
					auto description = ListToErrorMessage(types, [](auto&& type) { return type->GetTypeFriendlyName(); });
					return MakeParsingError(node, L"C11: Failed to resolve the result type of coroutine operator \"" + operatorName + L"\", no appropriate static function \"CastResult\" is found in the following types. It requires exactly one argument of type \"object\" with a return type which is not \"void\": " + description + L".");
				}
			}

			glr::ParsingError WfErrors::CoProviderCreateNotExists(WfCoProviderStatement* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"C12: The required static function \"Create\" does not exist in coroutine provider \"" + type->GetTypeFriendlyName() + L"\". It is required to have exactly one argument of a function type, which consumes a pointer type and returns system::Coroutine^");
			}

			glr::ParsingError WfErrors::CoProviderCreateAndRunNotExists(WfCoProviderStatement* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"C12: The required static function \"CreateAndRun\" does not exist in coroutine provider \"" + type->GetTypeFriendlyName() + L"\". It is required to have exactly one argument of a function type, which consumes a pointer type and returns system::Coroutine^");
			}

			glr::ParsingError WfErrors::GotoLabelNotExists(WfGotoStatement* node)
			{
				return MakeParsingError(node, L"C13: Goto label \"" + node->label.value + L"\" does not exists. A goto label can only jump to the end of any block statement that contains this goto statement in the current function.");
			}

			glr::ParsingError WfErrors::TooManyGotoLabel(WfGotoStatement* node)
			{
				return MakeParsingError(node, L"C14: Too many goto targets \"" + node->label.value + L"\" found.");
			}

			glr::ParsingError WfErrors::WrongStateSwitchStatement(WfStateSwitchStatement* node)
			{
				return MakeParsingError(node, L"C15: $switch statement should appear inside a $state declaration.");
			}

			glr::ParsingError WfErrors::WrongStateInvokeStatement(WfStateInvokeStatement* node)
			{
				return MakeParsingError(node, L"C16: $goto_state or $push_state statement should appear inside a $state declaration.");
			}

			glr::ParsingError WfErrors::StateInputNotExists(WfStateSwitchCase* node)
			{
				return MakeParsingError(node, L"C17: State input \"" + node->name.value + L"\" does not exist.");
			}

			glr::ParsingError WfErrors::StateSwitchArgumentCountNotMatch(WfStateSwitchCase* node)
			{
				return MakeParsingError(node, L"C18: The number of arguments doesn not match the declaration of state input \"" + node->name.value + L"\".");
			}

			glr::ParsingError WfErrors::StateNotExists(WfStateInvokeStatement* node)
			{
				return MakeParsingError(node, L"C19: State \"" + node->name.value + L"\" does not exist.");
			}

			glr::ParsingError WfErrors::StateArgumentCountNotMatch(WfStateInvokeStatement* node)
			{
				return MakeParsingError(node, L"C20: The number of arguments doesn not match the declaration of state \"" + node->name.value + L"\".");
			}

			glr::ParsingError WfErrors::FunctionShouldHaveName(WfDeclaration* node)
			{
				return MakeParsingError(node, L"D0: Function should have a name.");
			}

			glr::ParsingError WfErrors::FunctionShouldHaveImplementation(WfDeclaration* node)
			{
				return MakeParsingError(node, L"D0: Function should be implemented.");
			}

			glr::ParsingError WfErrors::InterfaceMethodShouldNotHaveImplementation(WfDeclaration* node)
			{
				return MakeParsingError(node, L"D0: Interface method should not be implemented.");
			}

			glr::ParsingError WfErrors::DuplicatedDeclaration(WfDeclaration* node, const WString& firstDeclarationCategory)
			{
				return MakeParsingError(node, L"D1: Duplicated declaration \"" + node->name.value + L"\", it has already beed defined as a " + firstDeclarationCategory + L".");
			}

			glr::ParsingError WfErrors::DuplicatedDeclaration(WfStateMachineDeclaration* node)
			{
				return MakeParsingError(node, L"D1: Duplicated $state_machine declaration.");
			}

			glr::ParsingError WfErrors::DuplicatedSymbol(WfDeclaration* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			glr::ParsingError WfErrors::DuplicatedSymbol(WfFunctionArgument* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			glr::ParsingError WfErrors::DuplicatedSymbol(WfStatement* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			glr::ParsingError WfErrors::DuplicatedSymbol(WfExpression* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			glr::ParsingError WfErrors::DuplicatedSymbol(WfStateInput* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			glr::ParsingError WfErrors::DuplicatedSymbol(WfStateDeclaration* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			glr::ParsingError WfErrors::DuplicatedSymbol(WfStateSwitchArgument* node, Ptr<WfLexicalSymbol> symbol)
			{
				return MakeParsingError(node, L"D2: Duplicated symbol \"" + symbol->name + L"\".");
			}

			glr::ParsingError WfErrors::InterfaceMethodNotImplemented(WfNewInterfaceExpression* node, reflection::description::IMethodInfo* method)
			{
				auto result = ResolveExpressionResult::Method(method);
				return MakeParsingError(node, L"D3: Interface method not implemented: " + result.GetFriendlyName() + L".");
			}

			glr::ParsingError WfErrors::InterfaceMethodNotFound(WfFunctionDeclaration* node, reflection::description::ITypeInfo* interfaceType, reflection::description::ITypeInfo* methodType)
			{
				return MakeParsingError(node, L"D4: Interface \"" + interfaceType->GetTypeFriendlyName() + L"\" does not contain method \"" + node->name.value + L"\" which is in type \"" + methodType->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::CannotPickOverloadedInterfaceMethods(WfExpression* node, collections::List<ResolveExpressionResult>& results)
			{
				auto description = ListToErrorMessage(results, [](auto&& result) { return result.GetFriendlyName(); });
				return MakeParsingError(node, L"D5: Cannot decide which function to implement in multiple targets:" + description + L".");
			}

			glr::ParsingError WfErrors::CannotPickOverloadedImplementMethods(WfFunctionDeclaration* node, reflection::description::ITypeInfo* type)
			{
				return MakeParsingError(node, L"D6: There are some other methods named \"" + node->name.value + L"\" whose types are also \"" + type->GetTypeFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::WrongDeclaration(WfEventDeclaration* node)
			{
				return MakeParsingError(node, L"D7: Event \"" + node->name.value + L"\" cannot be defined outside of classes or interfaces.");
			}

			glr::ParsingError WfErrors::WrongDeclaration(WfPropertyDeclaration* node)
			{
				return MakeParsingError(node, L"D7: Property \"" + node->name.value + L"\" cannot be defined outside of classes or interfaces.");
			}

			glr::ParsingError WfErrors::WrongDeclaration(WfConstructorDeclaration* node)
			{
				return MakeParsingError(node, L"D7: Constructor cannot be defined outside of classes.");
			}

			glr::ParsingError WfErrors::WrongDeclaration(WfDestructorDeclaration* node)
			{
				return MakeParsingError(node, L"D7: Destructor cannot be defined outside of classes.");
			}

			glr::ParsingError WfErrors::WrongDeclaration(WfAutoPropertyDeclaration* node)
			{
				return MakeParsingError(node, L"D7: Auto-property cannot be defined outside of classes.");
			}

			glr::ParsingError WfErrors::WrongDeclaration(WfStateMachineDeclaration* node)
			{
				return MakeParsingError(node, L"D7: State machine cannot be defined outside of classes.");
			}

			glr::ParsingError WfErrors::WrongDeclaration(WfStaticInitDeclaration* node)
			{
				return MakeParsingError(node, L"D7: Static initialization declaration cannot be defined inside classes or interfaces.");
			}

			glr::ParsingError WfErrors::WrongDeclarationInInterfaceConstructor(WfDeclaration* node)
			{
				return MakeParsingError(node, L"D8: \"" + node->name.value + L"\" cannot be defined in an new interface expression, only functions, variables and auto-properties are allowed.");
			}

			glr::ParsingError WfErrors::EnumValuesNotConsecutiveFromZero(WfEnumDeclaration* node)
			{
				return MakeParsingError(node, L"D9: Item values in enum \"" + node->name.value + L"\" should be consecutive and starts from zero, like 0, 1, 2, 3, 4, ...");
			}

			glr::ParsingError WfErrors::FlagValuesNotConsecutiveFromZero(WfEnumDeclaration* node)
			{
				return MakeParsingError(node, L"D9: Item values in flag enum \"" + node->name.value + L"\" should be consecutive powers of 2 and starts from zero, like 0, 1, 2, 4, 8, ...");
			}

			glr::ParsingError WfErrors::FlagValueNotExists(WfEnumItemIntersection* node, WfEnumDeclaration* owner)
			{
				return MakeParsingError(node, L"D10: Item \"" + node->name.value + L" does not exists in the current flag enum \"" + owner->name.value + L"\".");
			}

			glr::ParsingError WfErrors::DuplicatedEnumValue(WfEnumItem* node, WfEnumDeclaration* owner)
			{
				return MakeParsingError(node, L"D11: Item \"" + node->name.value + L" already exists in the current enum \"" + owner->name.value + L"\".");
			}

			glr::ParsingError WfErrors::StructContainsNonValueType(WfStructMember* node, WfStructDeclaration* owner)
			{
				return MakeParsingError(node, L"D12: Type of member \"" + node->name.value + L"\" of struct \"" + owner->name.value + L"\" is not value type.");
			}

			glr::ParsingError WfErrors::StructRecursivelyIncludeItself(WfStructDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds)
			{
				auto description = ListToErrorMessage(tds, [](auto&& td) { return td->GetTypeName(); });
				return MakeParsingError(node, L"D13: Recursive references are found in these struct definitions:" + description + L".");
			}

			glr::ParsingError WfErrors::DuplicatedStructMember(WfStructMember* node, WfStructDeclaration* owner)
			{
				return MakeParsingError(node, L"D14: Member \"" + node->name.value + L"\" already exists in struct \"" + owner->name.value + L"\".");
			}

			glr::ParsingError WfErrors::AttributeNotExists(WfAttribute* node)
			{
				return MakeParsingError(node, L"D15: Attribute \"" + node->category.value + L":" + node->name.value + L"\" does not exist.");
			}

			glr::ParsingError WfErrors::AttributeMissValue(WfAttribute* node)
			{
				return MakeParsingError(node, L"D15: Value of attribute \"" + node->category.value + L":" + node->name.value + L"\" is missing.");
			}

			glr::ParsingError WfErrors::StateMachineClassNotInheritFromStateMachine(WfClassDeclaration* node)
			{
				return MakeParsingError(node, L"D16: State machine class \"" + node->name.value + L"\" should inherit from \"system::StateMachine\" directly.");
			}

			glr::ParsingError WfErrors::MissingDefaultState(WfStateMachineDeclaration* node)
			{
				return MakeParsingError(node, L"D17: Missing default state.");
			}

			glr::ParsingError WfErrors::WrongUsingPathWildCard(WfModuleUsingPath* node)
			{
				return MakeParsingError(node, L"E0: Wild card \"*\" should only appear in the last item of the using path and should appear once.");
			}

			glr::ParsingError WfErrors::TopQualifiedSymbolNotExists(glr::ParsingAstBase* node, const WString& name)
			{
				return MakeParsingError(node, L"F0: Top qualified symbol \"" + name + L"\" does not exist.");
			}

			glr::ParsingError WfErrors::ChildSymbolNotExists(glr::ParsingAstBase* node, Ptr<WfLexicalScopeName> scopeName, const WString& name)
			{
				return MakeParsingError(node, L"F1: Symbol \"" + name + L"\" does not exist in \"" + scopeName->GetFriendlyName() + L"\".");
			}

			glr::ParsingError WfErrors::MemberNotExists(glr::ParsingAstBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name)
			{
				return MakeParsingError(node, L"F1: Member \"" + name + L"\" does not exist in \"" + typeDescriptor->GetTypeName() + L"\".");
			}

			glr::ParsingError WfErrors::ReferenceNotExists(glr::ParsingAstBase* node, const WString& name)
			{
				return MakeParsingError(node, L"F2: Symbol \"" + name + L"\" does not exist in the current scope.");
			}

			glr::ParsingError WfErrors::TooManyTargets(glr::ParsingAstBase* node, collections::List<ResolveExpressionResult>& results, const WString& name)
			{
				auto description = ListToErrorMessage(results, [](auto&& result) { return result.GetFriendlyName(); });
				return MakeParsingError(node, L"F3: Symbol \"" + name + L"\" references to too many targets: " + description + L".");
			}

			glr::ParsingError WfErrors::EnumItemNotExists(glr::ParsingAstBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name)
			{
				return MakeParsingError(node, L"F2: Enum item \"" + name + L"\" does not exist in enum type \"" + typeDescriptor->GetTypeName() + L"\".");
			}

			glr::ParsingError WfErrors::WrongClassMemberConfig(WfDeclaration* node)
			{
				return MakeParsingError(node, L"G1: Class member \"" + node->name.value + L"\" cannot be static or override because it is not a function or a auto-property.");
			}

			glr::ParsingError WfErrors::FunctionInNewTypeExpressionCannotBeStatic(WfDeclaration* node)
			{
				return MakeParsingError(node, L"G1: Class member \"" + node->name.value + L"\" cannot be static because it is in a new interface expression.");
			}

			glr::ParsingError WfErrors::AutoPropertyCannotBeNormalOutsideOfClass(WfDeclaration* node)
			{
				return MakeParsingError(node, L"G1: Auto property \"" + node->name.value + L"\" cannot be normal outside of classes or interfaces.");
			}

			glr::ParsingError WfErrors::AutoPropertyCannotBeStatic(WfDeclaration* node)
			{
				return MakeParsingError(node, L"G1: Auto property \"" + node->name.value + L"\" cannot be static  .");
			}

			glr::ParsingError WfErrors::WrongClassMember(WfNamespaceDeclaration* node)
			{
				return MakeParsingError(node, L"G2: Namespace \"" + node->name.value + L"\" cannot be a class member.");
			}

			glr::ParsingError WfErrors::PropertyGetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G3: Cannot find the getter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property getter should be a non-static method in the same type.");
			}

			glr::ParsingError WfErrors::PropertySetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G3: Cannot find the setter \"" + node->setter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property setter should be a non-static method in the same type.");
			}

			glr::ParsingError WfErrors::PropertyEventNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G3: Cannot find the event \"" + node->valueChangedEvent.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\".");
			}

			glr::ParsingError WfErrors::TooManyPropertyGetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G4: Too many symbols found for the getter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\".");
			}

			glr::ParsingError WfErrors::TooManyPropertySetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G4: Too many symbols found for the setter \"" + node->setter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\".");
			}

			glr::ParsingError WfErrors::TooManyPropertyEvent(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G4: Too many symbols found for the event \"" + node->valueChangedEvent.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\".");
			}

			glr::ParsingError WfErrors::PropertyGetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G5: Cannot match the getter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property getter should have no argument, and its return type should be identical to the property type.");
			}

			glr::ParsingError WfErrors::PropertySetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G5: Cannot match the setter \"" + node->getter.value + L"\" of property \"" + node->name.value + L"\" in type \"" + classDecl->name.value + L"\". A property setter should have no return value and have only one argument, and the argument type should be identical to the property type.");
			}

			glr::ParsingError WfErrors::WrongBaseType(WfClassDeclaration* node, WfType* type)
			{
				return MakeParsingError(node, L"G6: A base type of the type \"" + node->name.value + L"\" should be another custom type, it cannot be any predefined type, pointer type, shared pointer type, nullable type, collection type, or function type");
			}

			glr::ParsingError WfErrors::WrongBaseTypeOfClass(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type)
			{
				return MakeParsingError(node, L"G6: Base type \"" + type->GetTypeName() + L"\" of class \"" + node->name.value + L"\" is not a class, or it is a class but it is not aggregatable.");
			}

			glr::ParsingError WfErrors::WrongBaseTypeOfInterface(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type)
			{
				return MakeParsingError(node, L"G6: Base type \"" + type->GetTypeName() + L"\" of interface \"" + node->name.value + L"\" is not an interface.");
			}

			glr::ParsingError WfErrors::WrongInterfaceBaseType(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type)
			{
				Ptr<ITypeInfo> proxy = TypeInfoRetriver<Ptr<IValueInterfaceProxy>>::CreateTypeInfo();
				return MakeParsingError(node, L"G6: Interface \"" + type->GetTypeName() + L"\" should contain a constructor receiving an \"" + proxy->GetTypeFriendlyName() + L"\" to be the base type of \"" + node->name.value + L"\".");
			}

			glr::ParsingError WfErrors::ClassWithInterfaceConstructor(WfClassDeclaration* node)
			{
				return MakeParsingError(node, L"G7: Cannot use interface constructor type on class \"" + node->name.value + L"\".");
			}

			glr::ParsingError WfErrors::OverrideShouldImplementInterfaceMethod(WfFunctionDeclaration* node)
			{
				return MakeParsingError(node, L"G8: Function \"" + node->name.value + L"\" cannot be override because it doesn't implement any interface methods.");
			}

			glr::ParsingError WfErrors::OverrideShouldImplementInterfaceMethod(WfAutoPropertyDeclaration* node)
			{
				return MakeParsingError(node, L"G8: Auto-property \"" + node->name.value + L"\" cannot be override because it doesn't implement any interface methods.");
			}

			glr::ParsingError WfErrors::MissingFieldType(WfVariableDeclaration* node)
			{
				return MakeParsingError(node, L"G9: Type of field \"" + node->name.value + L"\" is missing.");
			}

			glr::ParsingError WfErrors::DuplicatedBaseClass(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type)
			{
				return MakeParsingError(node, L"G10: Class \"" + node->name.value + L"\" inherits from another class \"" + type->GetTypeName() + L"\" for multiple times.");
			}

			glr::ParsingError WfErrors::ClassRecursiveInheritance(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds)
			{
				auto description = ListToErrorMessage(tds, [](auto&& td) { return td->GetTypeName(); });
				return MakeParsingError(node, L"G10: Recursive inheriting are found in these class definitions:" + description + L".");
			}

			glr::ParsingError WfErrors::InterfaceRecursiveInheritance(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds)
			{
				auto description = ListToErrorMessage(tds, [](auto&& td) { return td->GetTypeName(); });
				return MakeParsingError(node, L"G10: Recursive inheriting are found in these interface definitions:" + description + L".");
			}

			glr::ParsingError WfErrors::WrongBaseConstructorCall(WfBaseConstructorCall* node, reflection::description::ITypeDescriptor* type)
			{
				return MakeParsingError(node, L"G11: Type \"" + type->GetTypeName() + L"\" is not a base type of this class.");
			}

			glr::ParsingError WfErrors::DuplicatedBaseConstructorCall(WfBaseConstructorCall* node, reflection::description::ITypeDescriptor* type)
			{
				return MakeParsingError(node, L"G12: Base type \"" + type->GetTypeName() + L"\" has already been initialized.");
			}
			
			glr::ParsingError WfErrors::TooManyDestructor(WfDestructorDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G13: Class \"" + classDecl->name.value + L"\" has too many destructors.");
			}

			glr::ParsingError WfErrors::AutoPropertyShouldBeInitialized(WfAutoPropertyDeclaration* node)
			{
				return MakeParsingError(node, L"G13: Auto property \"" + node->name.value + L"\" should be initialized.");
			}

			glr::ParsingError WfErrors::AutoPropertyCannotBeInitializedInInterface(WfAutoPropertyDeclaration* node, WfClassDeclaration* classDecl)
			{
				return MakeParsingError(node, L"G13: Auto property \"" + node->name.value + L"\" cannot be initialized in interface \"" + classDecl->name.value + L"\".");
			}

			glr::ParsingError WfErrors::CppUnableToDecideClassOrder(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds)
			{
				auto description = ListToErrorMessage(tds, [](auto&& td) { return td->GetTypeName(); });
				return MakeParsingError(node, L"CPP1: (C++ Code Generation) Cannot decide order of the following classes. It is probably caused by inheritance relationships of internal classes inside these classes:" + description + L".");
			}

			glr::ParsingError WfErrors::CppUnableToSeparateCustomFile(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds)
			{
				auto description = ListToErrorMessage(tds, [](auto&& td) { return td->GetTypeName(); });
				return MakeParsingError(node, L"CPP2: (C++ Code Generation) @cpp:File atrribute values for these classes are invalid. Generating classes to source files specified by these attribute values will create source files which do not compile. It is probably caused by inheritance relationships of internal classes inside these classes:" + description + L".");
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_EXPANDBINDEXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace stream;

/***********************************************************************
SearchUntilNonVirtualStatement
***********************************************************************/

			class SearchUntilNonVirtualStatementVisitor : public empty_visitor::StatementVisitor
			{
			public:
				Ptr<WfStatement>		result;

				SearchUntilNonVirtualStatementVisitor(Ptr<WfStatement> _result)
					:result(_result)
				{
				}

				void Dispatch(WfVirtualCseStatement* node)override
				{
					result = node->expandedStatement;
					result->Accept(this);
				}

				void Dispatch(WfCoroutineStatement* node)override
				{
				}

				void Dispatch(WfStateMachineStatement* node)override
				{
				}
			};

			Ptr<WfStatement> SearchUntilNonVirtualStatement(Ptr<WfStatement> statement)
			{
				SearchUntilNonVirtualStatementVisitor visitor(statement);
				statement->Accept(&visitor);
				return visitor.result;
			}

/***********************************************************************
Copy(Type|Expression|Statement|Declaration)
***********************************************************************/

			class CopyDeclarationWithExpandVirtualVisitor : empty_visitor::DeclarationVisitor
			{
			public:
				bool						expanded = false;
				List<Ptr<WfDeclaration>>&	decls;

				CopyDeclarationWithExpandVirtualVisitor(List<Ptr<WfDeclaration>>& _decls)
					:decls(_decls)
				{
				}

				void Dispatch(WfVirtualCfeDeclaration* node)override
				{
					expanded = true;
					for (auto decl : node->expandedDeclarations)
					{
						Execute(decls, decl);
					}
				}

				void Dispatch(WfVirtualCseDeclaration* node)override
				{
					expanded = true;
					for (auto decl : node->expandedDeclarations)
					{
						Execute(decls, decl);
					}
				}

				static void Execute(List<Ptr<WfDeclaration>>& decls, Ptr<WfDeclaration> decl)
				{
					CopyDeclarationWithExpandVirtualVisitor visitor(decls);
					decl->Accept(&visitor);
					if (!visitor.expanded)
					{
						decls.Add(decl);
					}
				}
			};

			void CopyWithExpandVirtualVisitor::Expand(collections::List<Ptr<WfDeclaration>>& decls)
			{
				if (expandVirtualAst)
				{
					List<Ptr<WfDeclaration>> copied;
					CopyFrom(copied, decls);
					decls.Clear();

					for (auto decl : copied)
					{
						CopyDeclarationWithExpandVirtualVisitor::Execute(decls, decl);
					}
				}
			}

			CopyWithExpandVirtualVisitor::CopyWithExpandVirtualVisitor(bool _expandVirtualAst)
				:expandVirtualAst(_expandVirtualAst)
			{
			}

			void CopyWithExpandVirtualVisitor::Visit(WfVirtualCfeExpression* node)
			{
				if (!expandVirtualAst || !node->expandedExpression)
				{
					return copy_visitor::AstVisitor::Visit(node);
				}
				node->expandedExpression->Accept(this);
			}

			void CopyWithExpandVirtualVisitor::Visit(WfVirtualCseExpression* node)
			{
				if (!expandVirtualAst || !node->expandedExpression)
				{
					return copy_visitor::AstVisitor::Visit(node);
				}
				node->expandedExpression->Accept(this);
			}

			void CopyWithExpandVirtualVisitor::Visit(WfVirtualCseStatement* node)
			{
				if (!expandVirtualAst || !node->expandedStatement)
				{
					return copy_visitor::AstVisitor::Visit(node);
				}
				node->expandedStatement->Accept(this);
			}

			void CopyWithExpandVirtualVisitor::Visit(WfNamespaceDeclaration* node)
			{
				copy_visitor::AstVisitor::Visit(node);
				Expand(result.Cast<WfNamespaceDeclaration>()->declarations);
			}

			void CopyWithExpandVirtualVisitor::Visit(WfClassDeclaration* node)
			{
				copy_visitor::AstVisitor::Visit(node);
				Expand(result.Cast<WfClassDeclaration>()->declarations);
			}

			void CopyWithExpandVirtualVisitor::Visit(WfNewInterfaceExpression* node)
			{
				copy_visitor::AstVisitor::Visit(node);
				Expand(result.Cast<WfNewInterfaceExpression>()->declarations);
			}

			Ptr<WfType> CopyType(Ptr<WfType> type)
			{
				return CopyWithExpandVirtualVisitor(false).CopyNode(type.Obj());
			}

			Ptr<WfExpression> CopyExpression(Ptr<WfExpression> expression, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(expression.Obj());
			}

			Ptr<WfStatement> CopyStatement(Ptr<WfStatement> statement, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(statement.Obj());
			}

			Ptr<WfDeclaration> CopyDeclaration(Ptr<WfDeclaration> declaration, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(declaration.Obj());
			}

			Ptr<WfModule> CopyModule(Ptr<WfModule> module, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(module.Obj());
			}

			Ptr<WfType> CopyType(WfType* type)
			{
				return CopyWithExpandVirtualVisitor(false).CopyNode(type);
			}

			Ptr<WfExpression> CopyExpression(WfExpression* expression, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(expression);
			}

			Ptr<WfStatement> CopyStatement(WfStatement* statement, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(statement);
			}

			Ptr<WfDeclaration> CopyDeclaration(WfDeclaration* declaration, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(declaration);
			}

			Ptr<WfModule> CopyModule(WfModule* module, bool expandVirtualExprStat)
			{
				return CopyWithExpandVirtualVisitor(expandVirtualExprStat).CopyNode(module);
			}

/***********************************************************************
observing expressions:
	WfObserveExpression
	WfMemberExpression that detects the event
***********************************************************************/

			class BindContext : public Object
			{
				typedef collections::List<WfExpression*>							ExprList;
				typedef collections::Dictionary<WfExpression*, WfExpression*>		ExprMap;
				typedef collections::Group<WfExpression*, WfExpression*>			ExprGroup;
				typedef collections::Group<WfExpression*, IEventInfo*>				ExprEventGroup;
			public:
				ExprMap											observeParents;
				ExprEventGroup									observeEvents;
				ExprList										orderedObserves;
				ExprList										cachedExprs;	// expression that need to cache its value
				ExprMap											renames;		// expression -> the expression being renamed

				ExprGroup										exprAffects;	// observe expression -> all expressions that it can cause to change
				ExprGroup										exprCauses;		// expression -> observe expressions that cause it to change
				ExprGroup										observeAffects;	// observe expression -> all observe expressions that it can cause to change
				ExprGroup										observeCauses;	// observe expression -> observe expressions that cause it to change

				WString GetCacheVariableName(vint index)
				{
					return L"<bind-cache>" + itow(index);
				}

				vint GetCachedExpressionIndex(WfExpression* expression, bool ensureExists)
				{
					vint index = cachedExprs.IndexOf(expression);
					if (ensureExists)
					{
						CHECK_ERROR(index != -1, L"BindContext::GetCachedExpressionIndex(WfExpression*, bool)#Cached expression not exists.");
					}
					return index;
				}

				vint GetCachedExpressionIndexRecursively(WfExpression* expression, bool ensureExists)
				{
					WfExpression* cache = expression;
					while (true)
					{
						vint index = renames.Keys().IndexOf(cache);
						if (index == -1)
						{
							return GetCachedExpressionIndex(cache, ensureExists);
						}
						else
						{
							cache = renames.Values()[index];
						}
					}
				}
			};

			struct CallbackInfo
			{
				WfExpression*									observe;
				IEventInfo*										eventInfo;
				vint											eventIndex;
				WString											handlerName;
				WString											callbackName;
			};

			struct BindCallbackInfo
			{
				Dictionary<WString, Ptr<ITypeInfo>>				handlerVariables;
				Dictionary<WString, Ptr<ITypeInfo>>				callbackFunctions;
				Group<WfExpression*, CallbackInfo>				observeCallbackInfos;
			};

/***********************************************************************
CreateBindContext
***********************************************************************/

			class CreateBindContextVisitor : public Object, public WfExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				BindContext&						context;

				CreateBindContextVisitor(WfLexicalScopeManager* _manager, BindContext& _context)
					:manager(_manager)
					, context(_context)
				{
				}

				void Call(WfExpression* node)
				{
					node->Accept(this);
				}

				void ObservableDepend(WfExpression* expr, WfExpression* parent)
				{
					if (context.observeParents.Keys().Contains(expr))
					{
						CHECK_ERROR(context.observeParents[expr] == parent, L"CreateBindContextVisitor::ObservableDepend assigned different parents to the same expression.");
						return;
					}
					context.orderedObserves.Add(expr);
					context.observeParents.Add(expr, parent);
					DirectDepend(expr, parent, false);
					{
						auto cache = parent;
						while (true)
						{
							vint index = context.renames.Keys().IndexOf(cache);
							if (index == -1)
							{
								index = context.cachedExprs.IndexOf(cache);
								if (index == -1)
								{
									context.cachedExprs.Add(cache);
								}
								break;
							}
							else
							{
								cache = context.renames.Values()[index];
							}
						}
					}

					vint index = context.exprCauses.Keys().IndexOf(parent);
					if (index != -1)
					{
						for (auto observe : context.exprCauses.GetByIndex(index))
						{
							context.observeAffects.Add(observe, expr);
							context.observeCauses.Add(expr, observe);
						}
					}

					context.exprAffects.Add(expr, expr);
					context.exprCauses.Add(expr, expr);
				}

				void DirectDepend(WfExpression* expr, WfExpression* depended, bool processDepended = true)
				{
					if (processDepended)
					{
						Call(depended);
					}

					vint index = context.exprCauses.Keys().IndexOf(depended);
					if (index != -1)
					{
						for (auto observe : context.exprCauses.GetByIndex(index))
						{
							context.exprCauses.Add(expr, observe);
							context.exprAffects.Add(observe, expr);
						}
					}
				}

				void Visit(WfThisExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfReferenceExpression* node)override
				{
					auto result = manager->expressionResolvings[node];
					if (result.symbol)
					{
						auto scope = result.symbol->ownerScope;
						if (auto letExpr = dynamic_cast<WfLetExpression*>(scope->ownerNode.Obj()))
						{
							auto letVar = From(letExpr->variables)
								.Where([=](const Ptr<WfLetVariable>& letVar)
								{
									return letVar->name.value == node->name.value;
								})
								.First();
							context.renames.Add(node, letVar->value.Obj());
							DirectDepend(node, letVar->value.Obj(), false);
						}
						else if (auto observeExpr = dynamic_cast<WfObserveExpression*>(scope->ownerNode.Obj()))
						{
							context.renames.Add(node, observeExpr->parent.Obj());
							DirectDepend(node, observeExpr->parent.Obj());
						}
					}
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfMemberExpression* node)override
				{
					Call(node->parent.Obj());

					auto scope = manager->nodeScopes[node].Obj();
					while (scope)
					{
						if (scope->ownerNode.Cast<WfObserveExpression>())
						{
							break;
						}
						scope = scope->parentScope.Obj();
					}

					if (!scope)
					{
						auto memberResult = manager->expressionResolvings[node];
						if (memberResult.propertyInfo)
						{
							auto td = memberResult.propertyInfo->GetOwnerTypeDescriptor();
							auto ev = memberResult.propertyInfo->GetValueChangedEvent();
							if (!ev)
							{
								ev = td->GetEventByName(memberResult.propertyInfo->GetName() + L"Changed", true);
							}
							if (ev)
							{
								ObservableDepend(node, node->parent.Obj());
								context.observeEvents.Add(node, ev);
								return;
							}
						}
					}

					DirectDepend(node, node->parent.Obj(), false);
				}

				void Visit(WfChildExpression* node)override
				{
					DirectDepend(node, node->parent.Obj());
				}

				void Visit(WfLiteralExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfFloatingExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfIntegerExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfStringExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfUnaryExpression* node)override
				{
					DirectDepend(node, node->operand.Obj());
				}

				void Visit(WfBinaryExpression* node)override
				{
					DirectDepend(node, node->first.Obj());
					DirectDepend(node, node->second.Obj());
				}

				void Visit(WfLetExpression* node)override
				{
					for (auto var : node->variables)
					{
						DirectDepend(node, var->value.Obj());
					}
					DirectDepend(node, node->expression.Obj());
				}

				void Visit(WfIfExpression* node)override
				{
					DirectDepend(node, node->condition.Obj());
					DirectDepend(node, node->trueBranch.Obj());
					DirectDepend(node, node->falseBranch.Obj());
				}

				void Visit(WfRangeExpression* node)override
				{
					DirectDepend(node, node->begin.Obj());
					DirectDepend(node, node->end.Obj());
				}

				void Visit(WfSetTestingExpression* node)override
				{
					DirectDepend(node, node->collection.Obj());
					DirectDepend(node, node->element.Obj());
				}

				void Visit(WfConstructorExpression* node)override
				{
					auto result = manager->expressionResolvings[node];
					bool isStruct = (result.type->GetTypeDescriptor()->GetTypeDescriptorFlags() == TypeDescriptorFlags::Struct);

					for (auto argument : node->arguments)
					{
						if (!isStruct)
						{
							DirectDepend(node, argument->key.Obj());
						}
						DirectDepend(node, argument->value.Obj());
					}
				}

				void Visit(WfInferExpression* node)override
				{
					DirectDepend(node, node->expression.Obj());
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					DirectDepend(node, node->expression.Obj());
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					DirectDepend(node, node->expression.Obj());
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfAttachEventExpression* node)override
				{
					DirectDepend(node, node->event.Obj());
					DirectDepend(node, node->function.Obj());
				}

				void Visit(WfDetachEventExpression* node)override
				{
					DirectDepend(node, node->event.Obj());
					DirectDepend(node, node->handler.Obj());
				}

				void Visit(WfObserveExpression* node)override
				{
					Call(node->parent.Obj());
					ObservableDepend(node, node->parent.Obj());
					Call(node->expression.Obj());
					for (auto eventExpr : node->events)
					{
						auto result = manager->expressionResolvings[eventExpr.Obj()];
						context.observeEvents.Add(node, result.eventInfo);
						Call(eventExpr.Obj());
					}
				}

				void Visit(WfCallExpression* node)override
				{
					DirectDepend(node, node->function.Obj());
					for (auto argument : node->arguments)
					{
						DirectDepend(node, argument.Obj());
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfNewClassExpression* node)override
				{
					for (auto argument : node->arguments)
					{
						DirectDepend(node, argument.Obj());
					}
				}

				void Visit(WfNewInterfaceExpression* node)override
				{
					// root expression, nothing to do
				}

				void Visit(WfVirtualCfeExpression* node)override
				{
					DirectDepend(node, node->expandedExpression.Obj());
				}

				void Visit(WfVirtualCseExpression* node)override
				{
					DirectDepend(node, node->expandedExpression.Obj());
				}
			};

/***********************************************************************
ExpandObserveExpression
***********************************************************************/

			Ptr<WfExpression> CreateReference(const WString& name)
			{
				auto ref = Ptr(new WfReferenceExpression);
				ref->name.value = name;
				return ref;
			}

			class ExpandObserveExpressionVisitor : public CopyWithExpandVirtualVisitor
			{
			public:
				BindContext&									context;

				ExpandObserveExpressionVisitor(BindContext& _context)
					:CopyWithExpandVirtualVisitor(true)
					, context(_context)
				{
				}

				vl::Ptr<WfExpression> CopyNode(WfExpression* node)override
				{
					return Execute(node, context);
				}

				static Ptr<WfExpression> Execute(WfExpression* expression, BindContext& context, bool expandImmediately = true)
				{
					if (!expression)
					{
						return nullptr;
					}

					{
						vint index = context.GetCachedExpressionIndexRecursively(expression, false);
						if (index != -1)
						{
							if (expandImmediately)
							{
								return CreateReference(context.GetCacheVariableName(index));
							}
							else
							{
								expression = context.cachedExprs[index];
							}
						}
					}

					ExpandObserveExpressionVisitor visitor(context);
					expression->Accept(&visitor);
					return visitor.result.Cast<WfExpression>();
				}

				void Visit(WfLetExpression* node)override
				{
					auto letExpr = Ptr(new WfLetExpression);
					for (auto var : node->variables)
					{
						if (context.GetCachedExpressionIndexRecursively(var->value.Obj(), false) == -1)
						{
							auto letVar = Ptr(new WfLetVariable);
							letVar->name.value = var->name.value;
							letVar->value = Execute(var->value.Obj(), context);
							letExpr->variables.Add(letVar);
						}
					}

					if (letExpr->variables.Count() == 0)
					{
						result = Execute(node->expression.Obj(), context);
					}
					else
					{
						letExpr->expression = Execute(node->expression.Obj(), context);
						result = letExpr;
					}
				}

				void Visit(WfObserveExpression* node)override
				{
					if (node->observeType == WfObserveType::SimpleObserve)
					{
						auto expr = Ptr(new WfMemberExpression);
						expr->parent = CopyNode(node->parent.Obj());
						expr->name.value = node->expression.Cast<WfReferenceExpression>()->name.value;
						result = expr;
					}
					else
					{
						result = CopyNode(node->expression.Obj());
					}
				}
			};

/***********************************************************************
CreateDefaultValue
***********************************************************************/

			Ptr<WfExpression> CreateDefaultValue(ITypeInfo* elementType)
			{
				auto valueType = elementType->GetTypeDescriptor()->GetValueType();
				if (elementType->GetDecorator()==ITypeInfo::TypeDescriptor && valueType != nullptr)
				{
					switch (GetTypeFlag(elementType))
					{
					case TypeFlag::Enum:
						{
							auto intExpr = Ptr(new WfIntegerExpression);
							intExpr->value.value = L"0";

							auto inferExpr = Ptr(new WfTypeCastingExpression);
							inferExpr->strategy = WfTypeCastingStrategy::Strong;
							inferExpr->expression = intExpr;
							inferExpr->type = GetTypeFromTypeInfo(CreateTypeInfoFromTypeFlag(TypeFlag::U8).Obj());

							auto castExpr = Ptr(new WfTypeCastingExpression);
							castExpr->strategy = WfTypeCastingStrategy::Strong;
							castExpr->expression = inferExpr;
							castExpr->type = GetTypeFromTypeInfo(elementType);

							return castExpr;
						}
					case TypeFlag::String:
						{
							auto stringExpr = Ptr(new WfStringExpression);
							return stringExpr;
						}
						break;
					case TypeFlag::Struct:
						if (elementType->GetTypeDescriptor()->GetSerializableType() == nullptr)
						{
							auto ctorExpr = Ptr(new WfConstructorExpression);

							auto castExpr = Ptr(new WfTypeCastingExpression);
							castExpr->strategy = WfTypeCastingStrategy::Strong;
							castExpr->expression = ctorExpr;
							castExpr->type = GetTypeFromTypeInfo(elementType);

							return castExpr;
						}
					default:
						{
							auto td = elementType->GetTypeDescriptor();
							if (td == description::GetTypeDescriptor<bool>())
							{
								auto expr = Ptr(new WfLiteralExpression);
								expr->value = WfLiteralValue::False;
								return expr;
							}
							if (td == description::GetTypeDescriptor<WString>())
							{
								auto expr = Ptr(new WfStringExpression);
								return expr;
							}
							else if (td == description::GetTypeDescriptor<float>()
								|| td == description::GetTypeDescriptor<double>())
							{
								auto valueExpr = Ptr(new WfFloatingExpression);
								valueExpr->value.value = L"0";

								auto inferExpr = Ptr(new WfInferExpression);
								inferExpr->expression = valueExpr;
								inferExpr->type = GetTypeFromTypeInfo(elementType);

								return inferExpr;
							}
							else if (td == description::GetTypeDescriptor<vint8_t>()
								|| td == description::GetTypeDescriptor<vint16_t>()
								|| td == description::GetTypeDescriptor<vint32_t>()
								|| td == description::GetTypeDescriptor<vint64_t>()
								|| td == description::GetTypeDescriptor<vuint8_t>()
								|| td == description::GetTypeDescriptor<vuint16_t>()
								|| td == description::GetTypeDescriptor<vuint32_t>()
								|| td == description::GetTypeDescriptor<vuint64_t>())
							{
								auto valueExpr = Ptr(new WfIntegerExpression);
								valueExpr->value.value = L"0";

								auto inferExpr = Ptr(new WfInferExpression);
								inferExpr->expression = valueExpr;
								inferExpr->type = GetTypeFromTypeInfo(elementType);

								return inferExpr;
							}
							else
							{
								// Consider adding a \"default (type)\" expression if CreateDefault() cannot be liminated from the compiler.
								CHECK_FAIL(L"All serializable types should have been handled!");
								/*
								auto stringExpr = Ptr(new WfStringExpression);
								elementType->GetTypeDescriptor()->GetSerializableType()->Serialize(valueType->CreateDefault(), stringExpr->value.value);

								auto castExpr = Ptr(new WfTypeCastingExpression);
								castExpr->strategy = WfTypeCastingStrategy::Strong;
								castExpr->expression = stringExpr;
								castExpr->type = GetTypeFromTypeInfo(elementType);

								return castExpr;
								*/
							}
						}
					}
				}
				else
				{
					auto nullExpr = Ptr(new WfLiteralExpression);
					nullExpr->value = WfLiteralValue::Null;

					auto inferExpr = Ptr(new WfInferExpression);
					inferExpr->expression = nullExpr;
					inferExpr->type = GetTypeFromTypeInfo(elementType);

					return inferExpr;
				}
			}

/***********************************************************************
CreateBindWritableVariable
***********************************************************************/

			Ptr<WfVariableDeclaration> CreateWritableVariable(const WString& name, ITypeInfo* type, Ptr<WfExpression> value = nullptr)
			{
				auto decl = Ptr(new WfVariableDeclaration);
				decl->name.value = name;
				decl->type = GetTypeFromTypeInfo(type);
				decl->expression = value ? value : CreateDefaultValue(type);
				return decl;
			}

			Ptr<WfVariableStatement> CreateWritableVariableStatement(const WString& name, ITypeInfo* type, Ptr<WfExpression> value = nullptr)
			{
				auto stat = Ptr(new WfVariableStatement);
				stat->variable = CreateWritableVariable(name, type, value);
				return stat;
			}

/***********************************************************************
IValueSubscription::Subscribe
***********************************************************************/

			Ptr<WfFunctionDeclaration> AssignNormalMember(Ptr<WfFunctionDeclaration> decl)
			{
				decl->functionKind = WfFunctionKind::Normal;
				return decl;
			}

			Ptr<WfFunctionDeclaration> AssignOverrideMember(Ptr<WfFunctionDeclaration> decl)
			{
				decl->functionKind = WfFunctionKind::Override;
				return decl;
			}

/***********************************************************************
ExpandObserveEvent
***********************************************************************/

			Ptr<WfExpression> ExpandObserveEvent(WfLexicalScopeManager* manager, WfExpression* observe, vint eventIndex, BindContext& context)
			{
				auto cacheName = context.GetCacheVariableName(context.GetCachedExpressionIndexRecursively(context.observeParents[observe], true));
				if (auto observeExpr = dynamic_cast<WfObserveExpression*>(observe))
				{
					if (observeExpr->observeType == WfObserveType::SimpleObserve)
					{
						auto expr = Ptr(new WfMemberExpression);
						expr->parent = CreateReference(cacheName);
						expr->name.value = observeExpr->events[eventIndex].Cast<WfReferenceExpression>()->name.value;
						return expr;
					}
					else
					{
						return ExpandObserveExpressionVisitor::Execute(observeExpr->events[eventIndex].Obj(), context);
					}
				}
				else
				{
					auto eventName = context.observeEvents[observe][0]->GetName();

					auto expr = Ptr(new WfMemberExpression);
					expr->parent = CreateReference(cacheName);
					expr->name.value = eventName;

					return expr;
				}
			}

/***********************************************************************
CreateBindAttachStatement
***********************************************************************/

			void CreateBindAttachStatement(Ptr<WfBlockStatement> block, WfLexicalScopeManager* manager, WfExpression* observe, BindContext& context, BindCallbackInfo& info)
			{
				for (auto callbackInfo : info.observeCallbackInfos[observe])
				{
					auto attach = Ptr(new WfAttachEventExpression);
					attach->event = ExpandObserveEvent(manager, observe, callbackInfo.eventIndex, context);
					attach->function = CreateReference(callbackInfo.callbackName);

					auto nullExpr = Ptr(new WfLiteralExpression);
					nullExpr->value = WfLiteralValue::Null;

					auto protect = Ptr(new WfBinaryExpression);
					protect->first = attach;
					protect->second = nullExpr;
					protect->op = WfBinaryOperator::FailedThen;

					auto assign = Ptr(new WfBinaryExpression);
					assign->op = WfBinaryOperator::Assign;
					assign->first = CreateReference(callbackInfo.handlerName);
					assign->second = protect;

					auto stat = Ptr(new WfExpressionStatement);
					stat->expression = assign;
					block->statements.Add(stat);
				}
			}

/***********************************************************************
CreateBindDetachStatement
***********************************************************************/

			void CreateBindDetachStatement(Ptr<WfBlockStatement> block, WfLexicalScopeManager* manager, WfExpression* observe, BindContext& context, BindCallbackInfo& info)
			{
				for (auto callbackInfo : info.observeCallbackInfos[observe])
				{
					auto testNull = Ptr(new WfTypeTestingExpression);
					testNull->expression = CreateReference(callbackInfo.handlerName);
					testNull->test = WfTypeTesting::IsNotNull;

					auto ifStat = Ptr(new WfIfStatement);
					ifStat->expression = testNull;

					auto trueBlock = Ptr(new WfBlockStatement);
					ifStat->trueBranch = trueBlock;

					block->statements.Add(ifStat);
					{
						auto detach = Ptr(new WfDetachEventExpression);
						detach->event = ExpandObserveEvent(manager, observe, callbackInfo.eventIndex, context);
						detach->handler = CreateReference(callbackInfo.handlerName);

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = detach;
						trueBlock->statements.Add(stat);
					}
					{
						auto nullExpr = Ptr(new WfLiteralExpression);
						nullExpr->value = WfLiteralValue::Null;

						auto assignExpr = Ptr(new WfBinaryExpression);
						assignExpr->first = CreateReference(callbackInfo.handlerName);
						assignExpr->second = nullExpr;
						assignExpr->op = WfBinaryOperator::Assign;

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = assignExpr;
						trueBlock->statements.Add(stat);
					}
				}
			}

/***********************************************************************
CreateBindCacheAssignStatement
***********************************************************************/

			void CreateBindCacheAssignStatement(WfLexicalScopeManager* manager, Ptr<WfBlockStatement> block, WfExpression* observe, BindContext& context)
			{
				auto parent = context.observeParents[observe];
				auto cacheName = context.GetCacheVariableName(context.GetCachedExpressionIndexRecursively(parent, true));

				auto protect = Ptr(new WfBinaryExpression);
				protect->first = ExpandObserveExpressionVisitor::Execute(parent, context, false);
				protect->second = CreateDefaultValue(manager->expressionResolvings[parent].type.Obj());
				protect->op = WfBinaryOperator::FailedThen;

				auto assign = Ptr(new WfBinaryExpression);
				assign->op = WfBinaryOperator::Assign;
				assign->first = CreateReference(cacheName);
				assign->second = protect;

				auto stat = Ptr(new WfExpressionStatement);
				stat->expression = assign;
				block->statements.Add(stat);
			}

/***********************************************************************
IValueSubscription::Open
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateBindOpenFunction(WfLexicalScopeManager* manager, BindContext& context, BindCallbackInfo& info)
			{
				auto func = Ptr(new WfFunctionDeclaration);
				func->name.value = L"Open";
				func->functionKind = WfFunctionKind::Normal;
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<bool>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = Ptr(new WfBlockStatement);
				func->statement = block;
				{
					auto ifStat = Ptr(new WfIfStatement);
					block->statements.Add(ifStat);
					{
						auto notExpr = Ptr(new WfUnaryExpression);
						notExpr->op = WfUnaryOperator::Not;
						notExpr->operand = CreateReference(L"<bind-opened>");
						ifStat->expression = notExpr;
					}

					auto ifBlock = Ptr(new WfBlockStatement);
					ifStat->trueBranch = ifBlock;
					{
						auto literal = Ptr(new WfLiteralExpression);
						literal->value = WfLiteralValue::True;

						auto assign = Ptr(new WfBinaryExpression);
						assign->op = WfBinaryOperator::Assign;
						assign->first = CreateReference(L"<bind-opened>");
						assign->second = literal;

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = assign;
						ifBlock->statements.Add(stat);
					}
					{
						SortedList<vint> assignedParents;
						SortedList<WfExpression*> observes;
						CopyFrom(observes, context.observeParents.Keys());

						SortedList<WfExpression*> freeObserves;
						while (observes.Count() > 0)
						{
							CopyFrom(
								freeObserves,
								From(observes)
									.Where([&](WfExpression* observe)
									{
										return !context.observeCauses.Keys().Contains(observe) ||
											From(context.observeCauses[observe])
											.All([&](WfExpression* depended)
											{
												return !observes.Contains(depended);
											});
									})
								);

							for (auto observe : context.orderedObserves)
							{
								if (freeObserves.Contains(observe))
								{
									auto parent = context.GetCachedExpressionIndexRecursively(context.observeParents[observe], true);
									if (!assignedParents.Contains(parent))
									{
										assignedParents.Add(parent);
										CreateBindCacheAssignStatement(manager, ifBlock, observe, context);
									}
								}
							}

							for (auto observe : freeObserves)
							{
								observes.Remove(observe);
							}
							freeObserves.Clear();
						}
					}
					{
						for (auto observe : context.orderedObserves)
						{
							CreateBindAttachStatement(ifBlock, manager, observe, context, info);
						}
					}
					{
						auto literal = Ptr(new WfLiteralExpression);
						literal->value = WfLiteralValue::True;

						auto returnStat = Ptr(new WfReturnStatement);
						returnStat->expression = literal;
						ifBlock->statements.Add(returnStat);
					}
				}
				{
					auto literal = Ptr(new WfLiteralExpression);
					literal->value = WfLiteralValue::False;

					auto returnStat = Ptr(new WfReturnStatement);
					returnStat->expression = literal;
					block->statements.Add(returnStat);
				}

				return func;
			}

/***********************************************************************
IValueSubscription::Update
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateBindUpdateFunction(BindCallbackInfo& info)
			{
				auto func = Ptr(new WfFunctionDeclaration);
				func->name.value = L"Update";
				func->functionKind = WfFunctionKind::Normal;
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<bool>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = Ptr(new WfBlockStatement);
				func->statement = block;
				{
					auto ifStat = Ptr(new WfIfStatement);
					block->statements.Add(ifStat);
					{
						auto notExpr = Ptr(new WfUnaryExpression);
						notExpr->op = WfUnaryOperator::Not;
						notExpr->operand = CreateReference(L"<bind-closed>");

						auto andExpr = Ptr(new WfBinaryExpression);
						andExpr->op = WfBinaryOperator::And;
						andExpr->first = CreateReference(L"<bind-opened>");
						andExpr->second = notExpr;

						ifStat->expression = andExpr;
					}

					auto ifBlock = Ptr(new WfBlockStatement);
					ifStat->trueBranch = ifBlock;
					{
						auto ref = CreateReference(L"<bind-activator>");

						auto call = Ptr(new WfCallExpression);
						call->function = ref;

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = call;
						ifBlock->statements.Add(stat);
					}
					{
						auto literal = Ptr(new WfLiteralExpression);
						literal->value = WfLiteralValue::True;

						auto returnStat = Ptr(new WfReturnStatement);
						returnStat->expression = literal;
						ifBlock->statements.Add(returnStat);
					}
				}
				{
					auto literal = Ptr(new WfLiteralExpression);
					literal->value = WfLiteralValue::False;

					auto returnStat = Ptr(new WfReturnStatement);
					returnStat->expression = literal;
					block->statements.Add(returnStat);
				}

				return func;
			}

/***********************************************************************
IValueSubscription::Close
***********************************************************************/

			Ptr<WfFunctionDeclaration> CreateBindCloseFunction(WfLexicalScopeManager* manager, BindContext& context, BindCallbackInfo& info)
			{
				auto func = Ptr(new WfFunctionDeclaration);
				func->name.value = L"Close";
				func->functionKind = WfFunctionKind::Normal;
				func->anonymity = WfFunctionAnonymity::Named;
				{
					auto typeInfo = TypeInfoRetriver<bool>::CreateTypeInfo();
					func->returnType = GetTypeFromTypeInfo(typeInfo.Obj());
				}

				auto block = Ptr(new WfBlockStatement);
				func->statement = block;
				{
					auto ifStat = Ptr(new WfIfStatement);
					block->statements.Add(ifStat);
					{
						auto notExpr = Ptr(new WfUnaryExpression);
						notExpr->op = WfUnaryOperator::Not;
						notExpr->operand = CreateReference(L"<bind-closed>");
						ifStat->expression = notExpr;
					}

					auto ifBlock = Ptr(new WfBlockStatement);
					ifStat->trueBranch = ifBlock;
					{
						auto literal = Ptr(new WfLiteralExpression);
						literal->value = WfLiteralValue::True;

						auto assign = Ptr(new WfBinaryExpression);
						assign->op = WfBinaryOperator::Assign;
						assign->first = CreateReference(L"<bind-closed>");
						assign->second = literal;

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = assign;
						ifBlock->statements.Add(stat);
					}
					for (auto observe : context.orderedObserves)
					{
						CreateBindDetachStatement(ifBlock, manager, observe, context, info);
					}

					for (vint i = 0; i < context.cachedExprs.Count(); i++)
					{
						auto cacheName = context.GetCacheVariableName(i);
						auto type = manager->expressionResolvings[context.cachedExprs[i]].type;

						auto assign = Ptr(new WfBinaryExpression);
						assign->op = WfBinaryOperator::Assign;
						assign->first = CreateReference(cacheName);
						assign->second = CreateDefaultValue(type.Obj());

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = assign;
						ifBlock->statements.Add(stat);
					}
					for (vint i = 0; i < info.handlerVariables.Count(); i++)
					{
						auto cacheName = info.handlerVariables.Keys()[i];
						auto result = info.handlerVariables.Values()[i];

						auto assign = Ptr(new WfBinaryExpression);
						assign->op = WfBinaryOperator::Assign;
						assign->first = CreateReference(cacheName);
						assign->second = CreateDefaultValue(result.Obj());

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = assign;
						ifBlock->statements.Add(stat);
					}

					{
						auto literal = Ptr(new WfLiteralExpression);
						literal->value = WfLiteralValue::True;

						auto returnStat = Ptr(new WfReturnStatement);
						returnStat->expression = literal;
						ifBlock->statements.Add(returnStat);
					}
				}
				{
					auto literal = Ptr(new WfLiteralExpression);
					literal->value = WfLiteralValue::False;

					auto returnStat = Ptr(new WfReturnStatement);
					returnStat->expression = literal;
					block->statements.Add(returnStat);
				}

				return func;
			}

/***********************************************************************
ExpandBindExpression
***********************************************************************/

			void ExpandBindExpression(WfLexicalScopeManager* manager, WfBindExpression* node)
			{
				BindContext context;
				CreateBindContextVisitor(manager, context).Call(node->expression.Obj());
				BindCallbackInfo bcInfo;
						
				auto newSubscription = Ptr(new WfNewInterfaceExpression);
				node->expandedExpression = newSubscription;
				{
					auto typeInfo = TypeInfoRetriver<Ptr<IValueSubscription>>::CreateTypeInfo();
					newSubscription->type = GetTypeFromTypeInfo(typeInfo.Obj());
				}
				{
					// stable symbol order by sorting them by code
					List<WfExpression*> orderedObserves;

					for (auto [parent, index] : indexed(context.cachedExprs))
					{
						WString cacheName = context.GetCacheVariableName(index);
						{
							auto elementType = manager->expressionResolvings[parent].type;
							newSubscription->declarations.Add(CreateWritableVariable(cacheName, elementType.Obj()));
						}
					}

					for (auto [observe, observeIndex] : indexed(context.orderedObserves))
					{
						const auto& events = context.observeEvents[observe];
						for (auto [ev, eventIndex] : indexed(events))
						{
							WString handlerName = L"<bind-handler>" + itow(observeIndex) + L"_" + itow(eventIndex);
							{
								auto elementType = TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo();
								bcInfo.handlerVariables.Add(handlerName, elementType);
								newSubscription->declarations.Add(CreateWritableVariable(handlerName, elementType.Obj()));
							}
						
							WString callbackName = L"<bind-callback>" + itow(observeIndex) + L"_" + itow(eventIndex);
							{
								auto elementType = CopyTypeInfo(ev->GetHandlerType());
								bcInfo.callbackFunctions.Add(callbackName, elementType);
							}

							CallbackInfo callbackInfo;
							callbackInfo.observe = observe;
							callbackInfo.eventInfo = ev;
							callbackInfo.eventIndex = eventIndex;
							callbackInfo.callbackName = callbackName;
							callbackInfo.handlerName = handlerName;
							bcInfo.observeCallbackInfos.Add(observe, callbackInfo);
						}
					}
					newSubscription->declarations.Add(CreateWritableVariable(L"<bind-opened>", TypeInfoRetriver<bool>::CreateTypeInfo().Obj()));
					newSubscription->declarations.Add(CreateWritableVariable(L"<bind-closed>", TypeInfoRetriver<bool>::CreateTypeInfo().Obj()));
					{
						auto func = Ptr(new WfFunctionDeclaration);
						func->name.value = L"<bind-activator>";
						func->functionKind = WfFunctionKind::Normal;
						func->anonymity = WfFunctionAnonymity::Named;
						func->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());
					
						auto block = Ptr(new WfBlockStatement);
						func->statement = block;
						{
							auto var = Ptr(new WfVariableDeclaration);
							var->name.value = L"<bind-activator-result>";
							var->expression = ExpandObserveExpressionVisitor::Execute(node->expression.Obj(), context);

							auto varStat = Ptr(new WfVariableStatement);
							varStat->variable = var;
							block->statements.Add(varStat);
						}
						{
							auto call = Ptr(new WfCallExpression);
							call->function = CreateReference(L"ValueChanged");
							call->arguments.Add(CreateReference(L"<bind-activator-result>"));

							auto stat = Ptr(new WfExpressionStatement);
							stat->expression = call;
							block->statements.Add(stat);
						}
					
						newSubscription->declarations.Add(AssignNormalMember(func));
					}
					for (auto observe : context.orderedObserves)
					{
						for (auto callbackInfo : bcInfo.observeCallbackInfos[observe])
						{
							auto func = Ptr(new WfFunctionDeclaration);
							func->name.value = callbackInfo.callbackName;
							func->functionKind = WfFunctionKind::Normal;
							func->anonymity = WfFunctionAnonymity::Named;
							{
								auto genericType = bcInfo.callbackFunctions[callbackInfo.callbackName]->GetElementType();
								func->returnType = GetTypeFromTypeInfo(genericType->GetGenericArgument(0));
								vint count = genericType->GetGenericArgumentCount();
								for (vint i = 1; i < count; i++)
								{
									auto arg = Ptr(new WfFunctionArgument);
									arg->name.value = L"<bind-callback-argument>" + itow(i - 1);
									arg->type = GetTypeFromTypeInfo(genericType->GetGenericArgument(i));
									func->arguments.Add(arg);
								}
							}
							auto block = Ptr(new WfBlockStatement);
							func->statement = block;
							{
								List<WfExpression*> affected;
								affected.Add(observe);
								for (vint i = 0; i < affected.Count(); i++)
								{
									auto current = affected[i];
									vint dependencyIndex = context.observeAffects.Keys().IndexOf(current);
									if (dependencyIndex != -1)
									{
										for (auto affectedObserve : context.observeAffects.GetByIndex(dependencyIndex))
										{
											if (affectedObserve && !affected.Contains(affectedObserve))
											{
												affected.Add(affectedObserve);
											}
										}
									}
								}
								affected.Remove(observe);

								for (auto affectedObserve : From(affected).Reverse())
								{
									CreateBindDetachStatement(block, manager, affectedObserve, context, bcInfo);
								}
								{
									SortedList<vint> assignedParents;
									for (auto affectedObserve : affected)
									{
										auto parent = context.GetCachedExpressionIndexRecursively(context.observeParents[affectedObserve], true);
										if (!assignedParents.Contains(parent))
										{
											assignedParents.Add(parent);
											CreateBindCacheAssignStatement(manager, block, affectedObserve, context);
										}
									}
								}
								for (auto affectedObserve : affected)
								{
									CreateBindAttachStatement(block, manager, affectedObserve, context, bcInfo);
								}
							}
							{
								auto ref = CreateReference(L"<bind-activator>");

								auto call = Ptr(new WfCallExpression);
								call->function = ref;

								auto stat = Ptr(new WfExpressionStatement);
								stat->expression = call;
								block->statements.Add(stat);
							}

							newSubscription->declarations.Add(AssignNormalMember(func));
						}
					}
				}
				newSubscription->declarations.Add(AssignOverrideMember(CreateBindOpenFunction(manager, context, bcInfo)));
				newSubscription->declarations.Add(AssignOverrideMember(CreateBindUpdateFunction(bcInfo)));
				newSubscription->declarations.Add(AssignOverrideMember(CreateBindCloseFunction(manager, context, bcInfo)));
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_EXPANDMIXINCASTEXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
ExpandNewCoroutineExpression
***********************************************************************/

			void ExpandMixinCastExpression(WfLexicalScopeManager* manager, WfMixinCastExpression* node)
			{
				auto sourceType = manager->expressionResolvings[node->expression.Obj()].type;

				auto newExpr = Ptr(new WfNewInterfaceExpression);
				node->expandedExpression = newExpr;

				newExpr->type = CopyType(node->type);
				{
					auto varDecl = Ptr(new WfVariableDeclaration);
					newExpr->declarations.Add(varDecl);
					varDecl->name.value = L"<mixin-source>";
					varDecl->expression = CopyExpression(node->expression, true);

					if (sourceType->GetDecorator() == ITypeInfo::RawPtr)
					{
						auto tdType = Ptr(new TypeDescriptorTypeInfo(sourceType->GetTypeDescriptor(), TypeInfoHint::Normal));
						auto pointerType = Ptr(new SharedPtrTypeInfo(tdType));

						auto castExpr = Ptr(new WfTypeCastingExpression);
						castExpr->strategy = WfTypeCastingStrategy::Strong;
						castExpr->expression = varDecl->expression;
						castExpr->type = GetTypeFromTypeInfo(pointerType.Obj());

						varDecl->expression = castExpr;
					}
				}
				List<ITypeDescriptor*> unprocessed;
				unprocessed.Add(sourceType->GetTypeDescriptor());
				for (vint i = 0; i < unprocessed.Count(); i++)
				{
					auto td = unprocessed[i];
					vint groupCount = td->GetMethodGroupCount();
					for (vint j = 0; j < groupCount; j++)
					{
						auto group = td->GetMethodGroup(j);
						vint methodCount = group->GetMethodCount();
						for (vint k = 0; k < methodCount; k++)
						{
							auto method = group->GetMethod(k);
							if (!method->IsStatic())
							{
								auto funcDecl = Ptr(new WfFunctionDeclaration);
								newExpr->declarations.Add(funcDecl);
								funcDecl->functionKind = WfFunctionKind::Override;
								funcDecl->anonymity = WfFunctionAnonymity::Named;
								funcDecl->name.value = method->GetName();
								funcDecl->returnType = GetTypeFromTypeInfo(method->GetReturn());
								vint parameterCount = method->GetParameterCount();
								for (vint l = 0; l < parameterCount; l++)
								{
									auto parameter = method->GetParameter(l);
									auto argument = Ptr(new WfFunctionArgument);
									argument->name.value = L"<mixin-parameter>" + parameter->GetName();
									argument->type = GetTypeFromTypeInfo(parameter->GetType());
									funcDecl->arguments.Add(argument);
								}

								auto implBlock = Ptr(new WfBlockStatement);
								funcDecl->statement = implBlock;
								{
									auto refSource = Ptr(new WfReferenceExpression);
									refSource->name.value = L"<mixin-source>";

									auto memberExpr = Ptr(new WfMemberExpression);
									if (sourceType->GetTypeDescriptor() == method->GetOwnerTypeDescriptor())
									{
										memberExpr->parent = refSource;
									}
									else if (sourceType->GetTypeDescriptor()->GetMethodGroupByName(method->GetName(), true) == method->GetOwnerMethodGroup())
									{
										memberExpr->parent = refSource;
									}
									else
									{
										auto castExpr = Ptr(new WfTypeCastingExpression);
										castExpr->strategy = WfTypeCastingStrategy::Strong;
										castExpr->expression = refSource;
										{
											auto tdType = Ptr(new TypeDescriptorTypeInfo(sourceType->GetTypeDescriptor(), TypeInfoHint::Normal));
											auto pointerType = Ptr(new RawPtrTypeInfo(tdType));
											castExpr->type = GetTypeFromTypeInfo(pointerType.Obj());
										}

										auto inferExpr = Ptr(new WfInferExpression);
										inferExpr->expression = castExpr;
										{
											auto tdType = Ptr(new TypeDescriptorTypeInfo(method->GetOwnerTypeDescriptor(), TypeInfoHint::Normal));
											auto pointerType = Ptr(new RawPtrTypeInfo(tdType));
											inferExpr->type = GetTypeFromTypeInfo(pointerType.Obj());
										}

										memberExpr->parent = inferExpr;
									}
									memberExpr->name.value = method->GetName();

									auto callExpr = Ptr(new WfCallExpression);
									callExpr->function = memberExpr;

									for (vint l = 0; l < parameterCount; l++)
									{
										auto parameter = method->GetParameter(l);

										auto argumentExpr = Ptr(new WfReferenceExpression);
										argumentExpr->name.value = L"<mixin-parameter>" + parameter->GetName();
										callExpr->arguments.Add(argumentExpr);
									}

									if (method->GetReturn()->GetTypeDescriptor() == description::GetTypeDescriptor<void>())
									{
										auto stat = Ptr(new WfExpressionStatement);
										stat->expression = callExpr;
										implBlock->statements.Add(stat);
									}
									else
									{
										auto stat = Ptr(new WfReturnStatement);
										stat->expression = callExpr;
										implBlock->statements.Add(stat);
									}
								}
							}
						}
					}

					vint count = td->GetBaseTypeDescriptorCount();
					for (vint j = 0; j < count; j++)
					{
						auto baseTd = td->GetBaseTypeDescriptor(j);
						if (!unprocessed.Contains(baseTd))
						{
							unprocessed.Add(baseTd);
						}
					}
				}
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_EXPANDNEWCOROUTINEEXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

			Ptr<WfExpression> GenerateCoroutineInvalidId()
			{
				auto refOne = Ptr(new WfIntegerExpression);
				refOne->value.value = L"1";

				auto refInvalid = Ptr(new WfUnaryExpression);
				refInvalid->op = WfUnaryOperator::Negative;
				refInvalid->operand = refOne;

				return refInvalid;
			}

/***********************************************************************
FindCoroutineAwaredStatements
***********************************************************************/

			class FindCoroutineAwaredStatementVisitor : public empty_visitor::StatementVisitor
			{
			public:
				List<WfStatement*>&						awaredStatements;
				bool									awared = false;

				FindCoroutineAwaredStatementVisitor(List<WfStatement*>& _awaredStatements)
					:awaredStatements(_awaredStatements)
				{
				}

				bool Call(Ptr<WfStatement> node)
				{
					if (!node) return false;

					awared = false;
					node->Accept(this);
					if (awared)
					{
						awaredStatements.Add(node.Obj());
					}
					return awared;
				}

				void Dispatch(WfVirtualCseStatement* node)override
				{
					awared = Call(node->expandedStatement);
				}

				void Dispatch(WfCoroutineStatement* node)override
				{
					awared = true;
				}

				void Dispatch(WfStateMachineStatement* node)override
				{
					CHECK_FAIL(L"FindCoroutineAwaredStatementVisitor::Visit(WfStateMachineStatement*)#Internal error, state machine statement is not allowed in $coroutine expression.");
				}

				void Visit(WfBreakStatement* node)override
				{
					awared = true;
				}

				void Visit(WfContinueStatement* node)override
				{
					awared = true;
				}

				void Visit(WfReturnStatement* node)override
				{
					awared = true;
				}

				void Visit(WfIfStatement* node)override
				{
					bool a = Call(node->trueBranch);
					bool b = Call(node->falseBranch);
					awared = a || b;
				}

				void Visit(WfWhileStatement* node)override
				{
					awared = Call(node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					bool a = Call(node->protectedStatement);
					bool b = Call(node->catchStatement);
					bool c = Call(node->finallyStatement);
					awared = a || b || c;
				}

				void Visit(WfBlockStatement* node)override
				{
					bool result = false;
					for (auto stat : node->statements)
					{
						bool a = Call(stat);
						result |= a;
					}
					awared = result;
				}

				void Visit(WfGotoStatement* node)override
				{
					awared = true;
				}
			};

			void FindCoroutineAwaredStatements(Ptr<WfStatement> node, List<WfStatement*>& awaredStatements)
			{
				FindCoroutineAwaredStatementVisitor(awaredStatements).Call(node);
			}

/***********************************************************************
FindCoroutineAwaredVariables
***********************************************************************/

			class FindCoroutineAwaredVariableVisitor : public empty_visitor::StatementVisitor
			{
			public:
				List<WfVariableStatement*>&				awaredVariables;

				FindCoroutineAwaredVariableVisitor(List<WfVariableStatement*>& _awaredVariables)
					:awaredVariables(_awaredVariables)
				{
				}

				void Dispatch(WfVirtualCseStatement* node)override
				{
					node->expandedStatement->Accept(this);
				}

				void Dispatch(WfCoroutineStatement* node)override
				{
				}

				void Dispatch(WfStateMachineStatement* node)override
				{
					CHECK_FAIL(L"FindCoroutineAwaredVariableVisitor::Visit(WfStateMachineStatement*)#Internal error, state machine statement is not allowed in $coroutine expression.");
				}

				void Visit(WfVariableStatement* node)override
				{
					awaredVariables.Add(node);
				}
			};

			class FindCoroutineAwaredBlockVisitor : public empty_visitor::StatementVisitor
			{
			public:
				List<WfVariableStatement*>&				awaredVariables;

				FindCoroutineAwaredBlockVisitor(List<WfVariableStatement*>& _awaredVariables)
					:awaredVariables(_awaredVariables)
				{
				}

				void Dispatch(WfVirtualCseStatement* node)override
				{
					// If an virtual node is coroutine awared
					// than its expandedStatement is also in the list
					// no need to find variables again
				}

				void Dispatch(WfCoroutineStatement* node)override
				{
				}

				void Dispatch(WfStateMachineStatement* node)override
				{
					CHECK_FAIL(L"FindCoroutineAwaredBlockVisitor::Visit(WfStateMachineStatement*)#Internal error, state machine statement is not allowed in $coroutine expression.");
				}

				void Visit(WfBlockStatement* node)override
				{
					FindCoroutineAwaredVariableVisitor visitor(awaredVariables);
					for (auto stat : node->statements)
					{
						stat->Accept(&visitor);
					}
				}
			};

			void FindCoroutineAwaredVariables(WfStatement* node, List<WfVariableStatement*>& awaredVariables)
			{
				FindCoroutineAwaredBlockVisitor visitor(awaredVariables);
				node->Accept(&visitor);
			}

/***********************************************************************
FindCoroutineReferenceRenaming
***********************************************************************/

			void FindCoroutineReferenceRenaming(WfLexicalScopeManager* manager, List<WfStatement*>& awaredStatements, List<WfVariableStatement*>& awaredVariables, Dictionary<WfLexicalSymbol*, WString>& referenceRenaming)
			{
				vint renameCounter = 0;
				auto rename = [&](const WString& name)
				{
					if (name.Length() > 0 && name[0] == L'<')
					{
						vint index = INVLOC.FindFirst(name, L">", Locale::None).key;
						auto category = name.Sub(1, index - 1);
						auto local = name.Sub(index + 1, name.Length() - index - 1);
						return L"<co" + itow(renameCounter++) + L"-" + category + L">" + local;
					}
					else
					{
						return L"<co" + itow(renameCounter++) + L">" + name;
					}
				};

				for (auto stat : awaredVariables)
				{
					auto scope = manager->nodeScopes[stat];
					auto symbol = scope->symbols[stat->variable->name.value][0];
					auto name = rename(stat->variable->name.value);
					referenceRenaming.Add(symbol.Obj(), name);
				}

				for (auto stat : awaredStatements)
				{
					if (auto tryStat = dynamic_cast<WfTryStatement*>(stat))
					{
						if (tryStat->catchStatement)
						{
							auto scope = manager->nodeScopes[tryStat->catchStatement.Obj()]->parentScope.Obj();
							auto symbol = scope->symbols[tryStat->name.value][0];
							auto name = rename(tryStat->name.value);
							referenceRenaming.Add(symbol.Obj(), name);
						}
					}
					else if (auto ifStat = dynamic_cast<WfIfStatement*>(stat))
					{
						if (ifStat->name.value != L"")
						{
							auto scope = manager->nodeScopes[ifStat->trueBranch.Obj()]->parentScope.Obj();
							auto symbol = scope->symbols[ifStat->name.value][0];
							auto name = rename(ifStat->name.value);
							referenceRenaming.Add(symbol.Obj(), name);
						}
					}
				}
			}

/***********************************************************************
FlowChart
***********************************************************************/

			class FlowChartNode;

			class FlowChartBranch : public Object
			{
			public:
				Ptr<WfExpression>						condition;
				FlowChartNode*							destination = nullptr;
			};

			enum class FlowChartNodeAction
			{
				None,
				SetPause,
			};

			class FlowChartNode : public Object
			{
			public:
				FlowChartNodeAction						action = FlowChartNodeAction::None;
				bool									embedInBranch = false;
				List<Ptr<WfStatement>>					statements;
				List<Ptr<FlowChartBranch>>				branches;
				FlowChartNode*							destination = nullptr;
				FlowChartNode*							exceptionDestination = nullptr;
				FlowChartNode*							pauseDestination = nullptr;
				WfLexicalSymbol*						exceptionVariable = nullptr;
			};

			class FlowChart : public Object
			{
				typedef Dictionary<WfTryStatement*, Ptr<WfLexicalSymbol>>		TempExVarMap;
			public:
				List<Ptr<FlowChartNode>>				nodes;
				FlowChartNode*							headNode = nullptr;
				FlowChartNode*							lastNode = nullptr;
				TempExVarMap							tempExVars;

				FlowChartNode* CreateNode(FlowChartNode* catchNode)
				{
					auto node = Ptr(new FlowChartNode);
					node->exceptionDestination = catchNode;
					nodes.Add(node);
					return node.Obj();
				}

				FlowChartNode* AppendNode(FlowChartNode* head, FlowChartNode* catchNode, FlowChartNodeAction action = FlowChartNodeAction::None)
				{
					auto node = CreateNode(catchNode);
					node->action = action;
					if (head)
					{
						CHECK_ERROR(head->destination == nullptr, L"FlowChart::AppendNode(FlowChartNode*, FlowChartNode*, FlowChartNodeAction)#Cannot append a new node to a flow chart node that already has a default destination.");
						head->destination = node;
					}
					return node;
				}

				FlowChartNode* EnsureAppendStatement(FlowChartNode* head, FlowChartNode* catchNode)
				{
					if (head == nullptr)
					{
						return CreateNode(catchNode);
					}
					else if(head->branches.Count() > 0 || head->exceptionDestination != catchNode)
					{
						CHECK_ERROR(head->destination == nullptr, L"FlowChart::EnsureAppendStatement(FlowChartNode*, FlowChartNode*)#Cannot append a statement to a flow chart node that already has a default destination.");
						auto node = CreateNode(catchNode);
						head->destination = node;
						return node;
					}
					else
					{
						return head;
					}
				}
			};

/***********************************************************************
GenerateFlowChart
***********************************************************************/

			class GenerateFlowChartModuleVisitor : public CopyWithExpandVirtualVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				Dictionary<WfLexicalSymbol*, WString>&	referenceRenaming;

				GenerateFlowChartModuleVisitor(WfLexicalScopeManager* _manager, Dictionary<WfLexicalSymbol*, WString>& _referenceRenaming)
					:CopyWithExpandVirtualVisitor(true)
					, manager(_manager)
					, referenceRenaming(_referenceRenaming)
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
					copy_visitor::AstVisitor::Visit(node);
					vint index = manager->expressionResolvings.Keys().IndexOf(node);
					if (index != -1)
					{
						auto resolvingResult = manager->expressionResolvings.Values()[index];
						vint index = referenceRenaming.Keys().IndexOf(resolvingResult.symbol.Obj());
						if (index != -1)
						{
							result.Cast<WfReferenceExpression>()->name.value = referenceRenaming.Values()[index];
						}
					}
				}
			};

			class GenerateFlowChartStatementVisitor
				: public Object
				, public WfStatement::IVisitor
				, public WfCoroutineStatement::IVisitor
			{
			public:
				enum class ScopeType
				{
					Function,
					Loop,
					TryCatch,
					Block,
				};

				struct ScopeContext
				{
					ScopeContext*						parent = nullptr;
					ScopeType							type = ScopeType::Function;
					WString								name;
					FlowChartNode*						enterNode = nullptr;
					FlowChartNode*						leaveNode = nullptr;
					ScopeContext*						exitStatementScope = nullptr;
					Ptr<WfStatement>					exitStatement;
				};

			public:
				WfLexicalScopeManager*					manager;
				SortedList<WfStatement*>&				awaredStatements;
				Dictionary<WfLexicalSymbol*, WString>&	referenceRenaming;
				Ptr<FlowChart>							flowChart;
				FlowChartNode*							headNode;
				FlowChartNode*							catchNode;
				ScopeContext*							scopeContext;
				FlowChartNode*							resultHead = nullptr;
				FlowChartNode*							resultLast = nullptr;

				GenerateFlowChartStatementVisitor(WfLexicalScopeManager* _manager, SortedList<WfStatement*>& _awaredStatements, Dictionary<WfLexicalSymbol*, WString>& _referenceRenaming, Ptr<FlowChart> _flowChart, FlowChartNode* _headNode, FlowChartNode* _catchNode, ScopeContext* _scopeContext)
					:manager(_manager)
					, awaredStatements(_awaredStatements)
					, referenceRenaming(_referenceRenaming)
					, flowChart(_flowChart)
					, headNode(_headNode)
					, catchNode(_catchNode)
					, scopeContext(_scopeContext)
				{
				}

#define COPY_AST_RAW(STATEMENT) GenerateFlowChartModuleVisitor(manager, referenceRenaming).CopyNode(STATEMENT)
#define COPY_AST_SHARED(STATEMENT) COPY_AST_RAW((STATEMENT).Obj())

				void AppendAwaredStatement(FlowChartNode* catchNode, ScopeContext* scopeContext, Ptr<WfStatement> statement)
				{
					if (!resultHead)
					{
						resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
						resultLast = resultHead;
					}
					resultLast = Execute(resultHead, catchNode, scopeContext, statement).value;
				}

				void AppendUnawaredCopiedStatement(FlowChartNode* catchNode, ScopeContext* scopeContext, Ptr<WfStatement> statement)
				{
					if (!resultHead)
					{
						resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
						resultLast = resultHead;
					}
					resultHead->statements.Add(statement);
				}

				ScopeContext* InlineScopeExitCode(ScopeType untilScopeType, bool exclusive, const WString name = WString::Empty)
				{
					auto current = scopeContext;
					while (current)
					{
						bool found = false;
						if (current->type == untilScopeType)
						{
							if (name == L"" || current->name == name)
							{
								found = true;
							}
						}

						if (exclusive && found) break;
						if (current->exitStatement)
						{
							AppendAwaredStatement(catchNode, current->exitStatementScope, current->exitStatement);
						}
						if (!exclusive && found) break;
						current = current->parent;
					}
					return current;
				}

				static Pair<FlowChartNode*, FlowChartNode*> Execute(WfLexicalScopeManager* manager, SortedList<WfStatement*>& awaredStatements, Dictionary<WfLexicalSymbol*, WString>& referenceRenaming, Ptr<FlowChart> flowChart, FlowChartNode* headNode, FlowChartNode* catchNode, ScopeContext* scopeContext, Ptr<WfStatement> statement)
				{
					GenerateFlowChartStatementVisitor visitor(manager, awaredStatements, referenceRenaming, flowChart, headNode, catchNode, scopeContext);
					if (awaredStatements.Contains(statement.Obj()))
					{
						statement->Accept(&visitor);
					}
					else
					{
						visitor.AppendUnawaredCopiedStatement(catchNode, scopeContext, COPY_AST_SHARED(statement));
					}
					return{ visitor.resultHead,visitor.resultLast };
				}

				Pair<FlowChartNode*, FlowChartNode*> Execute(FlowChartNode* headNode, FlowChartNode* catchNode, ScopeContext* scopeContext, Ptr<WfStatement> statement)
				{
					return Execute(manager, awaredStatements, referenceRenaming, flowChart, headNode, catchNode, scopeContext, statement);
				}

				void Visit(WfBreakStatement* node)override
				{
					auto targetContext = InlineScopeExitCode(ScopeType::Loop, false);
					resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
					resultLast = resultHead;

					auto branch = Ptr(new FlowChartBranch);
					branch->destination = targetContext->leaveNode;
					resultLast->branches.Add(branch);
				}

				void Visit(WfContinueStatement* node)override
				{
					auto targetContext = InlineScopeExitCode(ScopeType::Loop, true);
					resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
					resultLast = resultHead;

					auto branch = Ptr(new FlowChartBranch);
					branch->destination = targetContext->enterNode;
					resultLast->branches.Add(branch);
				}

				void Visit(WfReturnStatement* node)override
				{
					auto targetContext = InlineScopeExitCode(ScopeType::Function, false);
					AppendUnawaredCopiedStatement(catchNode, scopeContext, COPY_AST_RAW(node));

					auto branch = Ptr(new FlowChartBranch);
					branch->destination = targetContext->leaveNode;
					resultLast->branches.Add(branch);
				}

				void Visit(WfDeleteStatement* node)override
				{
					AppendUnawaredCopiedStatement(catchNode, scopeContext, COPY_AST_RAW(node));
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					AppendUnawaredCopiedStatement(catchNode, scopeContext, COPY_AST_RAW(node));
				}

				void GenerateIfWithVar(WfIfStatement* node)
				{
					resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
					{
						auto branch = Ptr(new FlowChartBranch);
						resultHead->branches.Add(branch);

						auto scope = manager->nodeScopes[node];
						auto symbol = scope->symbols[node->name.value][0].Obj();
						{
							auto refExpr = Ptr(new WfReferenceExpression);
							refExpr->name.value = referenceRenaming[symbol];

							auto assignExpr = Ptr(new WfBinaryExpression);
							assignExpr->op = WfBinaryOperator::Assign;
							assignExpr->first = refExpr;
							assignExpr->second = COPY_AST_SHARED(node->expression);

							auto stat = Ptr(new WfExpressionStatement);
							stat->expression = assignExpr;

							SetCodeRange((Ptr<WfStatement>)stat, node->expression->codeRange);
							resultHead->statements.Add(stat);
						}
						{
							auto refExpr = Ptr(new WfReferenceExpression);
							refExpr->name.value = referenceRenaming[symbol];

							auto testExpr = Ptr(new WfTypeTestingExpression);
							testExpr->test = WfTypeTesting::IsNotNull;
							testExpr->expression = refExpr;

							SetCodeRange((Ptr<WfExpression>)testExpr, node->expression->codeRange);
							branch->condition = testExpr;
						}
					}
					resultLast = flowChart->CreateNode(catchNode);

					{
						auto pair = Execute(nullptr, catchNode, scopeContext, node->trueBranch);
						pair.value->destination = resultLast;
						resultHead->branches[0]->destination = pair.key;
					}

					if (node->falseBranch)
					{
						auto pair = Execute(nullptr, catchNode, scopeContext, node->falseBranch);
						pair.value->destination = resultLast;
						resultHead->destination = pair.key;
					}
					else
					{
						resultHead->destination = resultLast;
					}
				}

				void GenerateIfWithoutVar(WfIfStatement* node)
				{
					resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
					resultLast = flowChart->CreateNode(catchNode);

					while (true)
					{
						auto branch = Ptr(new FlowChartBranch);
						resultHead->branches.Add(branch);
						branch->condition = COPY_AST_SHARED(node->expression);

						auto pair = Execute(nullptr, catchNode, scopeContext, node->trueBranch);
						pair.value->destination = resultLast;
						branch->destination = pair.key;

						auto next = dynamic_cast<WfIfStatement*>(node->falseBranch.Obj());
						if (next && next->name.value == L"")
						{
							node = next;
						}
						else
						{
							break;
						}
					}

					if (node->falseBranch)
					{
						auto pair = Execute(nullptr, catchNode, scopeContext, node->falseBranch);
						pair.value->destination = resultLast;
						resultHead->destination = pair.key;
					}
					else
					{
						resultHead->destination = resultLast;
					}
				}

				void Visit(WfIfStatement* node)override
				{
					if (node->name.value == L"")
					{
						GenerateIfWithoutVar(node);
					}
					else
					{
						GenerateIfWithVar(node);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
					{
						auto branch = Ptr(new FlowChartBranch);
						resultHead->branches.Add(branch);
						branch->condition = COPY_AST_SHARED(node->condition);
					}
					auto loopEnd = flowChart->CreateNode(catchNode);
					{
						auto branch = Ptr(new FlowChartBranch);
						loopEnd->branches.Add(branch);
						branch->condition = COPY_AST_SHARED(node->condition);
					}
					resultLast = flowChart->CreateNode(catchNode);

					ScopeContext loopContext;
					loopContext.parent = scopeContext;
					loopContext.type = ScopeType::Loop;
					loopContext.enterNode = loopEnd;
					loopContext.leaveNode = resultLast;
					auto pair = Execute(nullptr, catchNode, &loopContext, node->statement);
					pair.value->destination = loopEnd;

					resultHead->branches[0]->destination = pair.key;
					loopEnd->branches[0]->destination = pair.key;
					resultHead->destination = resultLast;
					loopEnd->destination = resultLast;
				}

				WfLexicalSymbol* GetExceptionVariableSymbol(WfTryStatement* node)
				{
					if (node->catchStatement)
					{
						auto scope = manager->nodeScopes[node->catchStatement.Obj()]->parentScope.Obj();
						auto symbol = scope->symbols[node->name.value][0];
						return symbol.Obj();
					}
					else
					{
						vint index = flowChart->tempExVars.Keys().IndexOf(node);
						if (index == -1)
						{
							auto symbol = Ptr(new WfLexicalSymbol(nullptr));
							symbol->name = L"ex";
							symbol->typeInfo = TypeInfoRetriver<Ptr<IValueException>>::CreateTypeInfo();
							flowChart->tempExVars.Add(node, symbol);

							referenceRenaming.Add(symbol.Obj(), L"<co-tempexvar" + itow(flowChart->tempExVars.Count() - 1) + L">ex");
							return symbol.Obj();
						}
						return flowChart->tempExVars.Values()[index].Obj();
					}
				}

				Pair<FlowChartNode*, FlowChartNode*> GenerateCatch(WfTryStatement* node, FlowChartNode* catchNode)
				{
					auto pair = Execute(nullptr, catchNode, scopeContext, node->catchStatement);
					pair.key->exceptionVariable = GetExceptionVariableSymbol(node);
					return pair;
				}

				Pair<FlowChartNode*, FlowChartNode*> GenerateFinally(WfTryStatement* node, FlowChartNode* catchNode)
				{
					return Execute(nullptr, catchNode, scopeContext, node->finallyStatement);
				}

				Pair<FlowChartNode*, FlowChartNode*> GenerateFinallyAndRaise(WfTryStatement* node, FlowChartNode* catchNode)
				{
					auto pair = Execute(nullptr, catchNode, scopeContext, node->finallyStatement);
					auto raiseNode = flowChart->CreateNode(catchNode);
					{
						pair.key->exceptionVariable = GetExceptionVariableSymbol(node);

						auto refExpr = Ptr(new WfReferenceExpression);
						refExpr->name.value = referenceRenaming[pair.key->exceptionVariable];

						auto memberExpr = Ptr(new WfMemberExpression);
						memberExpr->parent = refExpr;
						memberExpr->name.value = L"Message";

						auto raiseStat = Ptr(new WfRaiseExceptionStatement);
						raiseStat->expression = memberExpr;

						SetCodeRange((Ptr<WfStatement>)raiseStat, node->finallyStatement->codeRange);
						raiseNode->statements.Add(raiseStat);
					}
					pair.value->destination = raiseNode;
					return { pair.key,raiseNode };
				}

				void Visit(WfTryStatement* node)override
				{
					ScopeContext tryContext;
					tryContext.parent = scopeContext;
					tryContext.type = ScopeType::TryCatch;
					if (node->finallyStatement)
					{
						tryContext.exitStatementScope = scopeContext;
						tryContext.exitStatement = node->finallyStatement;
					}

					if (node->catchStatement && !node->finallyStatement)
					{
						auto pairCatch = GenerateCatch(node, catchNode);
						AppendAwaredStatement(pairCatch.key, &tryContext, node->protectedStatement);

						auto endNode = flowChart->CreateNode(catchNode);
						pairCatch.value->destination = endNode;
						resultLast->destination = endNode;
						resultLast = endNode;
					}
					else if (!node->catchStatement && node->finallyStatement)
					{
						auto pairFinallyAndRaise = GenerateFinallyAndRaise(node, catchNode);
						AppendAwaredStatement(pairFinallyAndRaise.key, &tryContext, node->protectedStatement);
						auto pairFinally = GenerateFinally(node, catchNode);

						auto endNode = flowChart->CreateNode(catchNode);
						resultLast->destination = pairFinally.key;
						pairFinally.value->destination = endNode;
						pairFinallyAndRaise.value->destination = endNode;
						resultLast = endNode;
					}
					else
					{
						auto pairFinallyAndRaise = GenerateFinallyAndRaise(node, catchNode);
						auto pairCatch = GenerateCatch(node, pairFinallyAndRaise.key);
						AppendAwaredStatement(pairCatch.key, &tryContext, node->protectedStatement);
						auto pairFinally = GenerateFinally(node, catchNode);

						auto endNode = flowChart->CreateNode(catchNode);
						resultLast->destination = pairFinally.key;
						pairCatch.value->destination = pairFinally.key;
						pairFinally.value->destination = endNode;
						pairFinallyAndRaise.value->destination = endNode;
						resultLast = endNode;
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					if (node->endLabel.value == L"")
					{
						resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
						resultLast = resultHead;

						for (auto [stat, index] : indexed(node->statements))
						{
							auto pair = Execute(resultLast, catchNode, scopeContext, stat);
							resultLast = pair.value;
						}
					}
					else
					{
						resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
						auto blockEnd = flowChart->CreateNode(catchNode);
						resultLast = resultHead;

						ScopeContext blockContext;
						blockContext.parent = scopeContext;
						blockContext.type = ScopeType::Block;
						blockContext.name = node->endLabel.value;
						blockContext.enterNode = resultHead;
						blockContext.leaveNode = blockEnd;

						for (auto [stat, index] : indexed(node->statements))
						{
							auto pair = Execute(resultLast, catchNode, &blockContext, stat);
							resultLast = pair.value;
						}

						resultLast->destination = blockEnd;
						resultLast = blockEnd;
					}
				}

				void Visit(WfGotoStatement* node)override
				{
					auto targetContext = InlineScopeExitCode(ScopeType::Block, false, node->label.value);
					resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
					resultLast = resultHead;

					auto branch = Ptr(new FlowChartBranch);
					branch->destination = targetContext->leaveNode;
					resultLast->branches.Add(branch);
				}

				void Visit(WfVariableStatement* node)override
				{
					resultHead = flowChart->EnsureAppendStatement(headNode, catchNode);
					resultLast = resultHead;

					auto scope = manager->nodeScopes[node];
					auto symbol = scope->symbols[node->variable->name.value][0].Obj();

					auto refExpr = Ptr(new WfReferenceExpression);
					refExpr->name.value = referenceRenaming[symbol];

					auto assignExpr = Ptr(new WfBinaryExpression);
					assignExpr->op = WfBinaryOperator::Assign;
					assignExpr->first = refExpr;
					assignExpr->second = COPY_AST_SHARED(node->variable->expression);

					auto stat = Ptr(new WfExpressionStatement);
					stat->expression = assignExpr;

					SetCodeRange((Ptr<WfStatement>)stat, node->codeRange);
					AppendUnawaredCopiedStatement(catchNode, scopeContext, stat);
				}

				void Visit(WfExpressionStatement* node)override
				{
					AppendUnawaredCopiedStatement(catchNode, scopeContext, COPY_AST_RAW(node));
				}

				void Visit(WfVirtualCseStatement* node)override
				{
					node->expandedStatement->Accept(this);
				}

				void Visit(WfCoroutineStatement* node)override
				{
					node->Accept(static_cast<WfCoroutineStatement::IVisitor*>(this));
				}

				void Visit(WfCoPauseStatement* node)override
				{
					resultHead = flowChart->AppendNode(headNode, catchNode, FlowChartNodeAction::SetPause);
					resultLast = resultHead;
					if (node->statement)
					{
						AppendUnawaredCopiedStatement(catchNode, scopeContext, COPY_AST_SHARED(node->statement));
					}

					resultLast = flowChart->AppendNode(resultLast, catchNode);
					{
						auto pauseStat = Ptr(new WfCoPauseStatement);
						SetCodeRange((Ptr<WfStatement>)pauseStat, node->codeRange);
						resultLast->statements.Add(pauseStat);
					}
					resultLast = flowChart->AppendNode(resultLast, catchNode);
					resultHead->pauseDestination = resultLast;
				}

				void Visit(WfCoOperatorStatement* node)override
				{
					CHECK_FAIL(L"GenerateFlowChartStatementVisitor::Visit(WfCoOperatorStatement*)#Internal error, co-operator statement is not allowed in $coroutine expression.");
				}

				void Visit(WfStateMachineStatement* node)override
				{
					CHECK_FAIL(L"GenerateFlowChartStatementVisitor::Visit(WfStateMachineStatement*)#Internal error, state machine statement is not allowed in $coroutine expression.");
				}

#undef COPY_STATEMENT
			};

			Ptr<FlowChart> GenerateFlowChart(WfLexicalScopeManager* manager, List<WfStatement*>& awaredStatements, List<WfVariableStatement*>& awaredVariables, Dictionary<WfLexicalSymbol*, WString>& referenceRenaming, Ptr<WfStatement> statement)
			{
				auto flowChart = Ptr(new FlowChart);
				SortedList<WfStatement*> sortedAwaredStatements;
				CopyFrom(sortedAwaredStatements, awaredStatements, true);
				CopyFrom(sortedAwaredStatements, awaredVariables, true);

				auto endNode = flowChart->CreateNode(nullptr);
				GenerateFlowChartStatementVisitor::ScopeContext context;
				context.leaveNode = endNode;

				auto pair = GenerateFlowChartStatementVisitor::Execute(manager, sortedAwaredStatements, referenceRenaming, flowChart, nullptr, nullptr, &context, statement);
				pair.value->destination = endNode;

				flowChart->headNode = pair.key;
				flowChart->lastNode = endNode;
				return flowChart;
			}

/***********************************************************************
RemoveUnnecessaryNodes
***********************************************************************/

			void CalculateEnterCounts(Ptr<FlowChart> flowChart, Dictionary<FlowChartNode*, vint>& enterCounts)
			{
				const auto& keys = enterCounts.Keys();
				auto& values = const_cast<Dictionary<FlowChartNode*, vint>::ValueContainer&>(enterCounts.Values());

				for (auto node : flowChart->nodes)
				{
					enterCounts.Add(node.Obj(), 0);
				}
				enterCounts.Set(flowChart->headNode, 1);

				auto Inc = [&](FlowChartNode* node)
				{
					if (node)
					{
						vint index = keys.IndexOf(node);
						values[index]++;
					}
				};

				for (auto node : flowChart->nodes)
				{
					Inc(node->destination);
					Inc(node->exceptionDestination);
					Inc(node->pauseDestination);
					for (auto branch : node->branches)
					{
						Inc(branch->destination);
					}
				}
			}

			void RemoveUnnecessaryNodesPass(Ptr<FlowChart> flowChart)
			{
				Dictionary<FlowChartNode*, vint> enterCounts;
				CalculateEnterCounts(flowChart, enterCounts);

				SortedList<FlowChartNode*> mergableNodes;
				List<Ptr<FlowChartNode>> keepingNodes;
				for (auto node : flowChart->nodes)
				{
					bool mergable = false;

					if (node->branches.Count() == 0 && node->destination)
					{
						if (node->statements.Count() == 0 && node->action == FlowChartNodeAction::None && !node->exceptionVariable)
						{
							mergable = true;
						}
						else if (node->destination->action == FlowChartNodeAction::None && !node->destination->exceptionVariable && enterCounts[node->destination] == 1)
						{
							mergable = true;
						}
					}

					if (mergable)
					{
						mergableNodes.Add(node.Obj());
					}
					else
					{
						keepingNodes.Add(node);
					}
				}

				Dictionary<FlowChartNode*, FlowChartNode*> merging;
				for (auto node : mergableNodes)
				{
					auto current = node;
					while (mergableNodes.Contains(current))
					{
						auto target = current->destination;

						if (current->action == FlowChartNodeAction::SetPause)
						{
							target->action = current->action;
							target->pauseDestination = current->pauseDestination;
						}
						if (current->exceptionVariable)
						{
							target->exceptionVariable = current->exceptionVariable;
						}
						if (current->statements.Count() > 0)
						{
							CopyFrom(current->statements, target->statements, true);
							CopyFrom(target->statements, current->statements);
							current->statements.Clear();
						}

						current = target;
					}
					merging.Add(node, current);
				}

#define MERGE_FLOW_CHART_NODE(DESTINATION)\
				{\
					vint index = merging.Keys().IndexOf(DESTINATION);\
					if (index != -1) DESTINATION = merging.Values()[index];\
				}\

				for (auto node : flowChart->nodes)
				{
					if (!mergableNodes.Contains(node.Obj()))
					{
						MERGE_FLOW_CHART_NODE(node->destination);
						MERGE_FLOW_CHART_NODE(node->exceptionDestination);
						MERGE_FLOW_CHART_NODE(node->pauseDestination);
						for (auto branch : node->branches)
						{
							MERGE_FLOW_CHART_NODE(branch->destination);
						}
					}
				}
				MERGE_FLOW_CHART_NODE(flowChart->headNode);
				MERGE_FLOW_CHART_NODE(flowChart->lastNode);

#undef MERGE_FLOW_CHART_NODE

				vint headNodeIndex = keepingNodes.IndexOf(flowChart->headNode);
				if (headNodeIndex != 0)
				{
					auto headNode = keepingNodes[headNodeIndex];
					keepingNodes.RemoveAt(headNodeIndex);
					keepingNodes.Insert(0, headNode);
				}
				CopyFrom(flowChart->nodes, keepingNodes);
			}

			void RemoveUnnecessaryNodes(Ptr<FlowChart> flowChart)
			{
				RemoveUnnecessaryNodesPass(flowChart);

				for (auto node : flowChart->nodes)
				{
					if (node->pauseDestination && node->statements.Count() > 0 && node->statements[node->statements.Count() - 1].Cast<WfCoPauseStatement>())
					{
						node->destination = nullptr;
					}
				}

				Dictionary<FlowChartNode*, vint> enterCounts;
				CalculateEnterCounts(flowChart, enterCounts);
				for (auto node : flowChart->nodes)
				{
					for (auto branch : node->branches)
					{
						if (enterCounts[branch->destination] == 1)
						{
							branch->destination->embedInBranch = true;
						}
					}
				}
			}

/***********************************************************************
GenerateSetStatus
***********************************************************************/

			Ptr<WfStatement> GenerateSetStatus(const WString& status)
			{
				auto refExpr = Ptr(new WfReferenceExpression);
				refExpr->name.value = status;

				auto funcExpr = Ptr(new WfReferenceExpression);
				funcExpr->name.value = L"SetStatus";

				auto callExpr = Ptr(new WfCallExpression);
				callExpr->function = funcExpr;
				callExpr->arguments.Add(refExpr);

				auto stat = Ptr(new WfExpressionStatement);
				stat->expression = callExpr;

				return stat;
			};

/***********************************************************************
GenerateSetCoState
***********************************************************************/

			Ptr<WfStatement> GenerateSetCoStateBeforePause()
			{
				auto refBefore = Ptr(new WfReferenceExpression);
				refBefore->name.value = L"<co-state-before-pause>";

				auto refState = Ptr(new WfReferenceExpression);
				refState->name.value = L"<co-state>";

				auto assignExpr = Ptr(new WfBinaryExpression);
				assignExpr->op = WfBinaryOperator::Assign;
				assignExpr->first = refBefore;
				assignExpr->second = refState;

				auto stat = Ptr(new WfExpressionStatement);
				stat->expression = assignExpr;

				return stat;
			}

			Ptr<WfStatement> GenerateSetCoStateBeforePauseToInvalid()
			{
				auto refBefore = Ptr(new WfReferenceExpression);
				refBefore->name.value = L"<co-state-before-pause>";

				auto assignExpr = Ptr(new WfBinaryExpression);
				assignExpr->op = WfBinaryOperator::Assign;
				assignExpr->first = refBefore;
				assignExpr->second = GenerateCoroutineInvalidId();

				auto stat = Ptr(new WfExpressionStatement);
				stat->expression = assignExpr;

				return stat;
			}

			Ptr<WfStatement> GenerateSetCoState(List<FlowChartNode*>& nodeOrders, FlowChartNode* node)
			{
				auto refState = Ptr(new WfReferenceExpression);
				refState->name.value = L"<co-state>";

				auto intState = Ptr(new WfIntegerExpression);
				intState->value.value = itow(nodeOrders.IndexOf(node));

				auto assignExpr = Ptr(new WfBinaryExpression);
				assignExpr->op = WfBinaryOperator::Assign;
				assignExpr->first = refState;
				assignExpr->second = intState;

				auto stat = Ptr(new WfExpressionStatement);
				stat->expression = assignExpr;

				return stat;
			};

/***********************************************************************
ExpandExceptionDestination
***********************************************************************/

			Ptr<WfBlockStatement> ExpandExceptionDestination(FlowChartNode* catchNode, Dictionary<WfLexicalSymbol*, WString>& referenceRenaming, List<FlowChartNode*>& nodeOrders, Ptr<WfBlockStatement> stateBlock)
			{
				/////////////////////////////////////////////////////////////////////////////
				// try { ... }
				/////////////////////////////////////////////////////////////////////////////

				auto nodeTryStat = Ptr(new WfTryStatement);
				auto nodeBlock = Ptr(new WfBlockStatement);
				nodeTryStat->protectedStatement = nodeBlock;

				/////////////////////////////////////////////////////////////////////////////
				// catch(<co-ex>)
				// {
				//      THE_EXCEPTION_VARIABLE = <co-ex>;
				//      <co-state> = THE_EXCEPTION_STATE;
				//      continue;
				// }
				/////////////////////////////////////////////////////////////////////////////

				nodeTryStat->name.value = L"<co-ex>";
				auto catchBlock = Ptr(new WfBlockStatement);
				nodeTryStat->catchStatement = catchBlock;
				{
					auto refTarget = Ptr(new WfReferenceExpression);
					refTarget->name.value = referenceRenaming[catchNode->exceptionVariable];

					auto refEx = Ptr(new WfReferenceExpression);
					refEx->name.value = L"<co-ex>";

					auto assignExpr = Ptr(new WfBinaryExpression);
					assignExpr->op = WfBinaryOperator::Assign;
					assignExpr->first = refTarget;
					assignExpr->second = refEx;

					auto stat = Ptr(new WfExpressionStatement);
					stat->expression = assignExpr;
					catchBlock->statements.Add(stat);
				}
				catchBlock->statements.Add(GenerateSetCoState(nodeOrders, catchNode));
				catchBlock->statements.Add(Ptr(new WfContinueStatement));

				stateBlock->statements.Add(nodeTryStat);
				return nodeBlock;
			}

/***********************************************************************
ExpandFlowChartNode
***********************************************************************/

			void ExpandFlowChartNode(Ptr<FlowChart> flowChart, FlowChartNode* flowChartNode, Dictionary<WfLexicalSymbol*, WString>& referenceRenaming, List<FlowChartNode*>& nodeOrders, FlowChartNode* parentCatchNode, Ptr<WfBlockStatement> stateBlock)
			{
				if (flowChartNode->action == FlowChartNodeAction::SetPause)
				{
					/////////////////////////////////////////////////////////////////////////////
					// <co-state> = THE_NEXT_STATE;
					// SetStatus(Waiting);
					/////////////////////////////////////////////////////////////////////////////
					stateBlock->statements.Add(GenerateSetStatus(L"Waiting"));
					stateBlock->statements.Add(GenerateSetCoStateBeforePause());
					stateBlock->statements.Add(GenerateSetCoState(nodeOrders, flowChartNode->pauseDestination));
				}

				auto nodeBlock = stateBlock;
				if (flowChartNode->exceptionDestination && parentCatchNode != flowChartNode->exceptionDestination)
				{
					nodeBlock = ExpandExceptionDestination(flowChartNode->exceptionDestination, referenceRenaming, nodeOrders, stateBlock);
				}

				bool exited = false;
				for (auto stat : flowChartNode->statements)
				{
					if (stat.Cast<WfCoPauseStatement>())
					{
						exited = true;
						/////////////////////////////////////////////////////////////////////////////
						// return;
						/////////////////////////////////////////////////////////////////////////////
						nodeBlock->statements.Add(Ptr(new WfReturnStatement));
					}
					else if (stat.Cast<WfReturnStatement>())
					{
						exited = true;
						/////////////////////////////////////////////////////////////////////////////
						// SetStatus(Stopped);
						// return;
						/////////////////////////////////////////////////////////////////////////////
						stateBlock->statements.Add(GenerateSetStatus(L"Stopped"));
						{
							auto returnStat = Ptr(new WfReturnStatement);
							stateBlock->statements.Add(returnStat);
						}
					}
					else
					{
						if (stat.Cast<WfRaiseExceptionStatement>())
						{
							exited = true;
						}
						nodeBlock->statements.Add(stat);
					}
				}

				for (auto branch : flowChartNode->branches)
				{
					Ptr<WfBlockStatement> trueBlock;

					if (branch->condition)
					{
						auto ifStat = Ptr(new WfIfStatement);
						ifStat->expression = branch->condition;

						trueBlock = Ptr(new WfBlockStatement);
						ifStat->trueBranch = trueBlock;

						nodeBlock->statements.Add(ifStat);
					}
					else
					{
						trueBlock = nodeBlock;
					}

					if (branch->destination->embedInBranch)
					{
						ExpandFlowChartNode(flowChart, branch->destination, referenceRenaming, nodeOrders, flowChartNode->exceptionDestination, trueBlock);
					}
					else
					{
						trueBlock->statements.Add(GenerateSetCoState(nodeOrders, branch->destination));
						trueBlock->statements.Add(Ptr(new WfContinueStatement));
					}
				}

				if (!exited)
				{
					if (flowChartNode == flowChart->lastNode)
					{
						/////////////////////////////////////////////////////////////////////////////
						// SetStatus(Stopped);
						// return;
						/////////////////////////////////////////////////////////////////////////////
						stateBlock->statements.Add(GenerateSetStatus(L"Stopped"));
						{
							auto returnStat = Ptr(new WfReturnStatement);
							stateBlock->statements.Add(returnStat);
						}
					}
					else
					{
						/////////////////////////////////////////////////////////////////////////////
						// <co-state> = THE_NEXT_STATE;
						// continue;
						/////////////////////////////////////////////////////////////////////////////
						stateBlock->statements.Add(GenerateSetCoState(nodeOrders, flowChartNode->destination));
						stateBlock->statements.Add(Ptr(new WfContinueStatement));
					}
				}
			}

/***********************************************************************
ExpandNewCoroutineExpression
***********************************************************************/

			void ExpandNewCoroutineExpression(WfLexicalScopeManager* manager, WfNewCoroutineExpression* node)
			{
				List<WfStatement*> awaredStatements;
				List<WfVariableStatement*> awaredVariables;
				Dictionary<WfLexicalSymbol*, WString> referenceRenaming;

				FindCoroutineAwaredStatements(node->statement, awaredStatements);
				for (auto stat : awaredStatements)
				{
					FindCoroutineAwaredVariables(stat, awaredVariables);
				}
				FindCoroutineReferenceRenaming(manager, awaredStatements, awaredVariables, referenceRenaming);
				auto flowChart = GenerateFlowChart(manager, awaredStatements, awaredVariables, referenceRenaming, node->statement);
				RemoveUnnecessaryNodes(flowChart);

				List<FlowChartNode*> nodeOrders;
				CopyFrom(
					nodeOrders,
					From(flowChart->nodes)
						.Select([](Ptr<FlowChartNode> node)
						{
							return node.Obj();
						})
						.Where([](FlowChartNode* node)
						{
							return !node->embedInBranch;
						})
				);

				auto newExpr = Ptr(new WfNewInterfaceExpression);
				node->expandedExpression = newExpr;
				newExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<ICoroutine>>::CreateTypeInfo().Obj());

				/////////////////////////////////////////////////////////////////////////////
				// Coroutine Awared Variables
				/////////////////////////////////////////////////////////////////////////////

				for (auto symbol : From(referenceRenaming.Keys())
					.OrderByKey([&](WfLexicalSymbol* a)
					{
						return referenceRenaming[a];
					}))
				{
					auto varDecl = Ptr(new WfVariableDeclaration);
					newExpr->declarations.Add(varDecl);
					varDecl->name.value = referenceRenaming[symbol];
					varDecl->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
					varDecl->expression = CreateDefaultValue(symbol->typeInfo.Obj());
				}

				/////////////////////////////////////////////////////////////////////////////
				// <co-state>
				/////////////////////////////////////////////////////////////////////////////

				{
					auto varDecl = Ptr(new WfVariableDeclaration);
					newExpr->declarations.Add(varDecl);
					varDecl->name.value = L"<co-state>";
					varDecl->type = GetTypeFromTypeInfo(manager->cputiSInt.Obj());

					auto stateExpr = Ptr(new WfIntegerExpression);
					stateExpr->value.value = L"0";
					varDecl->expression = stateExpr;
				}

				/////////////////////////////////////////////////////////////////////////////
				// <co-state-before-pause>
				/////////////////////////////////////////////////////////////////////////////

				{
					auto varDecl = Ptr(new WfVariableDeclaration);
					newExpr->declarations.Add(varDecl);
					varDecl->name.value = L"<co-state-before-pause>";
					varDecl->type = GetTypeFromTypeInfo(manager->cputiSInt.Obj());
					varDecl->expression = GenerateCoroutineInvalidId();
				}

				/////////////////////////////////////////////////////////////////////////////
				// prop Failure : Exception^ {const, not observe}
				/////////////////////////////////////////////////////////////////////////////

				{
					auto propDecl = Ptr(new WfAutoPropertyDeclaration);
					newExpr->declarations.Add(propDecl);
					propDecl->functionKind = WfFunctionKind::Override;
					propDecl->name.value = L"Failure";
					propDecl->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<IValueException>>::CreateTypeInfo().Obj());
					propDecl->configConst = WfAPConst::Readonly;
					propDecl->configObserve = WfAPObserve::NotObservable;

					auto nullExpr = Ptr(new WfLiteralExpression);
					nullExpr->value = WfLiteralValue::Null;
					propDecl->expression = nullExpr;
				}

				/////////////////////////////////////////////////////////////////////////////
				// prop Status : CoroutineStatus^ {const, not observe}
				/////////////////////////////////////////////////////////////////////////////

				{
					auto propDecl = Ptr(new WfAutoPropertyDeclaration);
					newExpr->declarations.Add(propDecl);
					propDecl->functionKind = WfFunctionKind::Override;
					propDecl->name.value = L"Status";
					propDecl->type = GetTypeFromTypeInfo(TypeInfoRetriver<CoroutineStatus>::CreateTypeInfo().Obj());
					propDecl->configConst = WfAPConst::Readonly;
					propDecl->configObserve = WfAPObserve::NotObservable;

					auto refExpr = Ptr(new WfReferenceExpression);
					refExpr->name.value = L"Waiting";

					propDecl->expression = refExpr;
				}

				/////////////////////////////////////////////////////////////////////////////
				// func Resume(<raise-exception> : bool, <coroutine-output> : CoroutineResult^) : void
				/////////////////////////////////////////////////////////////////////////////

				WString coResultName = node->name.value == L"" ? L"<coroutine-output>" : node->name.value;
				{
					auto funcDecl = Ptr(new WfFunctionDeclaration);
					newExpr->declarations.Add(funcDecl);
					funcDecl->functionKind = WfFunctionKind::Override;
					funcDecl->anonymity = WfFunctionAnonymity::Named;
					funcDecl->name.value = L"Resume";
					funcDecl->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());
					{
						auto argument = Ptr(new WfFunctionArgument);
						funcDecl->arguments.Add(argument);
						argument->name.value = L"<raise-exception>";
						argument->type = GetTypeFromTypeInfo(TypeInfoRetriver<bool>::CreateTypeInfo().Obj());
					}
					{
						auto argument = Ptr(new WfFunctionArgument);
						funcDecl->arguments.Add(argument);
						argument->name.value = coResultName;
						argument->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<CoroutineResult>>::CreateTypeInfo().Obj());
					}

					auto block = Ptr(new WfBlockStatement);
					funcDecl->statement = block;

					/////////////////////////////////////////////////////////////////////////////
					// if (Status != Waiting) raise "...";
					/////////////////////////////////////////////////////////////////////////////

					{
						auto ifStat = Ptr(new WfIfStatement);
						{
							auto refStatus = Ptr(new WfReferenceExpression);
							refStatus->name.value = L"Status";

							auto waitingStatus = Ptr(new WfChildExpression);
							waitingStatus->parent = GetExpressionFromTypeDescriptor(description::GetTypeDescriptor<CoroutineStatus>());
							waitingStatus->name.value = L"Waiting";

							auto compExpr = Ptr(new WfBinaryExpression);
							compExpr->op = WfBinaryOperator::NE;
							compExpr->first = refStatus;
							compExpr->second = waitingStatus;

							ifStat->expression = compExpr;
						}

						auto trueBlock = Ptr(new WfBlockStatement);
						ifStat->trueBranch = trueBlock;
						{
							auto exExpr = Ptr(new WfStringExpression);
							exExpr->value.value = L"Resume should be called only when the coroutine is in the waiting status.";

							auto raiseStat = Ptr(new WfRaiseExceptionStatement);
							raiseStat->expression = exExpr;
							trueBlock->statements.Add(raiseStat);
						}
						block->statements.Add(ifStat);
					}

					/////////////////////////////////////////////////////////////////////////////
					// SetStatus(Executing);
					/////////////////////////////////////////////////////////////////////////////

					block->statements.Add(GenerateSetStatus(L"Executing"));
					{
						/////////////////////////////////////////////////////////////////////////////
						// try { ... }
						/////////////////////////////////////////////////////////////////////////////

						auto tryStat = Ptr(new WfTryStatement);
						auto tryBlock = Ptr(new WfBlockStatement);
						tryStat->protectedStatement = tryBlock;
						{
							/////////////////////////////////////////////////////////////////////////////
							// if (<co-state-before-pause != -1) { ... }
							/////////////////////////////////////////////////////////////////////////////

							auto trueBlock = Ptr(new WfBlockStatement);
							{
								auto refBefore = Ptr(new WfReferenceExpression);
								refBefore->name.value = L"<co-state-before-pause>";

								auto compareInput = Ptr(new WfBinaryExpression);
								compareInput->op = WfBinaryOperator::NE;
								compareInput->first = refBefore;
								compareInput->second = GenerateCoroutineInvalidId();

								auto ifStat = Ptr(new WfIfStatement);
								tryBlock->statements.Add(ifStat);
								ifStat->expression = compareInput;
								ifStat->trueBranch = trueBlock;
							}

							/////////////////////////////////////////////////////////////////////////////
							// if (<coroutine-output> is null) { <co-state-before-pause> = -1; }
							// else if (<coroutine-output>.Failure is null) { <co-state-before-pause> = -1; }
							// else { ... }
							/////////////////////////////////////////////////////////////////////////////
							{
								auto nullTrueBlock = Ptr(new WfBlockStatement);
								Ptr<WfStatement>* nullFalseBlock = nullptr;
								auto exTrueBlock = Ptr(new WfBlockStatement);
								auto exFalseBlock = Ptr(new WfBlockStatement);

								{
									auto refOutput = Ptr(new WfReferenceExpression);
									refOutput->name.value = coResultName;

									auto testNullExpr = Ptr(new WfTypeTestingExpression);
									testNullExpr->test = WfTypeTesting::IsNull;
									testNullExpr->expression = refOutput;

									auto ifStat = Ptr(new WfIfStatement);
									trueBlock->statements.Add(ifStat);
									ifStat->expression = testNullExpr;

									ifStat->trueBranch = nullTrueBlock;
									nullTrueBlock->statements.Add(GenerateSetCoStateBeforePauseToInvalid());
									nullFalseBlock = &ifStat->falseBranch;
								}
								{
									auto refOutput = Ptr(new WfReferenceExpression);
									refOutput->name.value = coResultName;

									auto refFailure = Ptr(new WfMemberExpression);
									refFailure->parent = refOutput;
									refFailure->name.value = L"Failure";

									auto testNullExpr = Ptr(new WfTypeTestingExpression);
									testNullExpr->test = WfTypeTesting::IsNull;
									testNullExpr->expression = refFailure;

									auto ifStat = Ptr(new WfIfStatement);
									*nullFalseBlock = ifStat;
									ifStat->expression = testNullExpr;

									ifStat->trueBranch = exTrueBlock;
									exTrueBlock->statements.Add(GenerateSetCoStateBeforePauseToInvalid());
									ifStat->falseBranch = exFalseBlock;
								}
								{
									/////////////////////////////////////////////////////////////////////////////
									// Handle exception from <coroutine-output>
									/////////////////////////////////////////////////////////////////////////////

									Ptr<WfStatement> firstIfStatement;
									Ptr<WfStatement>* currentIfVar = &firstIfStatement;

									using GroupPair = Pair<FlowChartNode*, LazyList<FlowChartNode*>>;
									auto nodeByCatches = From(nodeOrders)
										.GroupBy([](FlowChartNode* node)
										{
											return node->exceptionDestination;
										})
										.OrderByKey([&](const GroupPair& p)
										{
											return nodeOrders.IndexOf(p.key);
										});

									for (auto group : nodeByCatches)
									{
										auto catchNode = group.key;
										if (!catchNode) continue;

										Ptr<WfExpression> condition;
										{
											List<Tuple<vint, vint>> conditionRanges;
											for (auto flowChartNode : group.value)
											{
												vint state = nodeOrders.IndexOf(flowChartNode);
												if (conditionRanges.Count() == 0)
												{
													conditionRanges.Add({ state,state });
												}
												else if (conditionRanges[conditionRanges.Count() - 1].get<1>() == state - 1)
												{
													conditionRanges[conditionRanges.Count() - 1].get<1>() = state;
												}
												else
												{
													conditionRanges.Add({ state,state });
												}
											}

											for (vint i = 0; i < conditionRanges.Count(); i++)
											{
												auto range = conditionRanges[i];

												Ptr<WfExpression> singleCondition;
												if (range.get<0>() == range.get<1>())
												{
													auto refState = Ptr(new WfReferenceExpression);
													refState->name.value = L"<co-state-before-pause>";

													auto intState = Ptr(new WfIntegerExpression);
													intState->value.value = itow(range.get<0>());

													auto compExpr = Ptr(new WfBinaryExpression);
													compExpr->op = WfBinaryOperator::EQ;
													compExpr->first = refState;
													compExpr->second = intState;

													singleCondition = compExpr;
												}
												else
												{
													auto refState = Ptr(new WfReferenceExpression);
													refState->name.value = L"<co-state-before-pause>";

													auto intState1 = Ptr(new WfIntegerExpression);
													intState1->value.value = itow(range.get<0>());

													auto intState2 = Ptr(new WfIntegerExpression);
													intState2->value.value = itow(range.get<1>());

													auto rangeExpr = Ptr(new WfRangeExpression);
													rangeExpr->begin = intState1;
													rangeExpr->beginBoundary = WfRangeBoundary::Inclusive;
													rangeExpr->end = intState2;
													rangeExpr->endBoundary = WfRangeBoundary::Inclusive;

													auto compExpr = Ptr(new WfSetTestingExpression);
													compExpr->test = WfSetTesting::In;
													compExpr->element = refState;
													compExpr->collection = rangeExpr;

													singleCondition = compExpr;
												}

												if (condition)
												{
													auto orExpr = Ptr(new WfBinaryExpression);
													orExpr->op = WfBinaryOperator::Or;
													orExpr->first = condition;
													orExpr->second = singleCondition;
													condition = orExpr;
												}
												else
												{
													condition = singleCondition;
												}
											}
										}

										auto ifStat = Ptr(new WfIfStatement);
										*currentIfVar = ifStat;
										currentIfVar = &ifStat->falseBranch;
										ifStat->expression = condition;

										auto catchBlock = Ptr(new WfBlockStatement);
										ifStat->trueBranch = catchBlock;

										catchBlock->statements.Add(GenerateSetCoStateBeforePauseToInvalid());
										{
											auto refTarget = Ptr(new WfReferenceExpression);
											refTarget->name.value = referenceRenaming[catchNode->exceptionVariable];

											auto refOutput = Ptr(new WfReferenceExpression);
											refOutput->name.value = coResultName;

											auto refFailure = Ptr(new WfMemberExpression);
											refFailure->parent = refOutput;
											refFailure->name.value = L"Failure";

											auto assignExpr = Ptr(new WfBinaryExpression);
											assignExpr->op = WfBinaryOperator::Assign;
											assignExpr->first = refTarget;
											assignExpr->second = refFailure;

											auto stat = Ptr(new WfExpressionStatement);
											stat->expression = assignExpr;
											catchBlock->statements.Add(stat);
										}
										catchBlock->statements.Add(GenerateSetCoState(nodeOrders, catchNode));
									}

									{
										auto block = Ptr(new WfBlockStatement);
										*currentIfVar = block;

										block->statements.Add(GenerateSetCoStateBeforePauseToInvalid());
										{
											auto refOutput = Ptr(new WfReferenceExpression);
											refOutput->name.value = coResultName;

											auto refFailure = Ptr(new WfMemberExpression);
											refFailure->parent = refOutput;
											refFailure->name.value = L"Failure";

											auto raiseStat = Ptr(new WfRaiseExceptionStatement);
											raiseStat->expression = refFailure;

											block->statements.Add(raiseStat);
										}
									}

									exFalseBlock->statements.Add(firstIfStatement);
								}
							}
						}
						{
							/////////////////////////////////////////////////////////////////////////////
							// while (true) { ... }
							/////////////////////////////////////////////////////////////////////////////

							auto whileStat = Ptr(new WfWhileStatement);
							{
								auto trueExpr = Ptr(new WfLiteralExpression);
								trueExpr->value = WfLiteralValue::True;
								whileStat->condition = trueExpr;
							}

							auto whileBlock = Ptr(new WfBlockStatement);
							whileStat->statement = whileBlock;

							using GroupPair = Pair<FlowChartNode*, LazyList<FlowChartNode*>>;
							auto nodeByCatches = From(nodeOrders)
								.GroupBy([](FlowChartNode* node)
								{
									return node->exceptionDestination;
								})
								.OrderByKey([&](const GroupPair& p)
								{
									return nodeOrders.IndexOf(p.key);
								});

							for (auto group : nodeByCatches)
							{
								auto catchNode = group.key;
								auto groupBlock = whileBlock;
								if (catchNode)
								{
									groupBlock = ExpandExceptionDestination(catchNode, referenceRenaming, nodeOrders, whileBlock);
								}

								for (auto flowChartNode : group.value)
								{
									/////////////////////////////////////////////////////////////////////////////
									// if (<co-state> == THE_CURRENT_STATE) { ... }
									/////////////////////////////////////////////////////////////////////////////

									auto ifStat = Ptr(new WfIfStatement);
									groupBlock->statements.Add(ifStat);
									{
										auto refState = Ptr(new WfReferenceExpression);
										refState->name.value = L"<co-state>";

										auto intState = Ptr(new WfIntegerExpression);
										intState->value.value = itow(nodeOrders.IndexOf(flowChartNode));

										auto compExpr = Ptr(new WfBinaryExpression);
										compExpr->op = WfBinaryOperator::EQ;
										compExpr->first = refState;
										compExpr->second = intState;

										ifStat->expression = compExpr;
									}

									auto stateBlock = Ptr(new WfBlockStatement);
									ifStat->trueBranch = stateBlock;
									{
										ExpandFlowChartNode(flowChart, flowChartNode, referenceRenaming, nodeOrders, catchNode, stateBlock);
									}
								}
							}
							tryBlock->statements.Add(whileStat);
						}

						/////////////////////////////////////////////////////////////////////////////
						// catch(<co-ex>)
						// {
						//      SetFailure(<co-ex>);
						//      SetStatus(Stopped);
						//      if (<raise-exception>) raise <co-ex>;
						// }
						/////////////////////////////////////////////////////////////////////////////

						tryStat->name.value = L"<co-ex>";
						auto catchBlock = Ptr(new WfBlockStatement);
						tryStat->catchStatement = catchBlock;
						{
							auto refExpr = Ptr(new WfReferenceExpression);
							refExpr->name.value = L"<co-ex>";

							auto funcExpr = Ptr(new WfReferenceExpression);
							funcExpr->name.value = L"SetFailure";

							auto callExpr = Ptr(new WfCallExpression);
							callExpr->function = funcExpr;
							callExpr->arguments.Add(refExpr);

							auto stat = Ptr(new WfExpressionStatement);
							stat->expression = callExpr;
							catchBlock->statements.Add(stat);
						}
						catchBlock->statements.Add(GenerateSetStatus(L"Stopped"));
						{
							auto refExpr = Ptr(new WfReferenceExpression);
							refExpr->name.value = L"<raise-exception>";

							auto ifStat = Ptr(new WfIfStatement);
							ifStat->expression = refExpr;

							auto trueBlock = Ptr(new WfBlockStatement);
							ifStat->trueBranch = trueBlock;
							{
								auto raiseStat = Ptr(new WfRaiseExceptionStatement);
								trueBlock->statements.Add(raiseStat);
							}
							catchBlock->statements.Add(ifStat);
						}

						block->statements.Add(tryStat);
					}
				}
			}

/***********************************************************************
ExpandNewCoroutineExpression
***********************************************************************/

			void ExpandCoOperatorExpression(WfLexicalScopeManager* manager, WfCoOperatorExpression* node)
			{
				auto scope = manager->nodeScopes[node].Obj();
				auto functionScope = scope->FindFunctionScope();
				auto newCoExpr = functionScope->ownerNode.Cast<WfNewCoroutineExpression>();
				auto providerType = manager->coNewCoroutineResolvings[newCoExpr.Obj()].type;

				auto refProvider = GetExpressionFromTypeDescriptor(providerType->GetTypeDescriptor());

				auto refQueryContext = Ptr(new WfChildExpression);
				refQueryContext->parent = refProvider;
				refQueryContext->name.value = L"QueryContext";

				auto refImpl = Ptr(new WfReferenceExpression);
				refImpl->name.value = L"<co-impl>";

				auto refCall = Ptr(new WfCallExpression);
				refCall->function = refQueryContext;
				refCall->arguments.Add(refImpl);

				auto refOperator = Ptr(new WfMemberExpression);
				refOperator->parent = refCall;
				refOperator->name.value = node->name.value;

				node->expandedExpression = refOperator;
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_EXPANDSTATEMACHINE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
ExpandStateMachineStatementVisitor
***********************************************************************/

			Ptr<WfExpression> GenerateStateMachineInvalidId()
			{
				auto refOne = Ptr(new WfIntegerExpression);
				refOne->value.value = L"1";

				auto refInvalid = Ptr(new WfUnaryExpression);
				refInvalid->op = WfUnaryOperator::Negative;
				refInvalid->operand = refOne;

				return refInvalid;
			}

			class ExpandStateMachineStatementVisitor
				: public copy_visitor::AstVisitor
			{
			protected:
				WfLexicalScopeManager*							manager;
				WfStateMachineInfo*								smInfo;

			public:
				ExpandStateMachineStatementVisitor(WfLexicalScopeManager* _manager, WfStateMachineInfo* _smInfo)
					:manager(_manager)
					, smInfo(_smInfo)
				{
				}

				using copy_visitor::AstVisitor::CopyNode;
				vl::Ptr<WfExpression> CopyNode(WfExpression* node)override
				{
					return CopyExpression(node, true);
				}

				void Visit(WfCoroutineStatement* node)override
				{
					CHECK_FAIL(L"ExpandStateMachineStatementVisitor::Dispatch(WfCoroutineStatement*)#ValidateStatementStructure should check coroutine statement's location.");
				}

				Ptr<WfStatement> GenerateIngoreInputStatement()
				{
					auto refThis = Ptr(new WfReferenceExpression);
					refThis->name.value = L"<state>stateMachineObject";

					auto refInput = Ptr(new WfMemberExpression);
					refInput->parent = refThis;
					refInput->name.value = L"stateMachineInput";

					auto assignExpr = Ptr(new WfBinaryExpression);
					assignExpr->op = WfBinaryOperator::Assign;
					assignExpr->first = refInput;
					assignExpr->second = GenerateStateMachineInvalidId();

					auto exprStat = Ptr(new WfExpressionStatement);
					exprStat->expression = assignExpr;

					return exprStat;
				}

				void GenerateStateSwitchCase(const WString& inputName, WfLexicalScope* smcScope, Ptr<WfSwitchStatement> switchStat, Ptr<WfStateInput>& input, Ptr<WfBlockStatement>& caseBlock)
				{
					input = From(smcScope->symbols[inputName])
						.Select([=](Ptr<WfLexicalSymbol> symbol)
						{
							return symbol->creatorNode.Cast<WfStateInput>();
						})
						.Where([=](Ptr<WfStateInput> decl)
						{
							return decl != nullptr;
						})
						.First();

					auto switchCase = Ptr(new WfSwitchCase);
					switchStat->caseBranches.Add(switchCase);
					{
						auto refInputId = Ptr(new WfIntegerExpression);
						refInputId->value.value = itow(smInfo->inputIds[inputName]);
						switchCase->expression = refInputId;
					}

					caseBlock = Ptr(new WfBlockStatement);
					switchCase->statement = caseBlock;
					caseBlock->statements.Add(GenerateIngoreInputStatement());
				}

				void Visit(WfStateSwitchStatement* node)override
				{
					auto smcScope = manager->nodeScopes[node]->FindFunctionScope()->parentScope.Obj();

					auto block = Ptr(new WfBlockStatement);
					{
						auto refThis = Ptr(new WfReferenceExpression);
						refThis->name.value = L"<state>stateMachineObject";

						auto refInput = Ptr(new WfMemberExpression);
						refInput->parent = refThis;
						refInput->name.value = L"stateMachineInput";

						auto compareInput = Ptr(new WfBinaryExpression);
						compareInput->op = WfBinaryOperator::EQ;
						compareInput->first = refInput;
						compareInput->second = GenerateStateMachineInvalidId();

						auto ifStat = Ptr(new WfIfStatement);
						block->statements.Add(ifStat);
						ifStat->expression = compareInput;

						auto trueBlock = Ptr(new WfBlockStatement);
						ifStat->trueBranch = trueBlock;

						trueBlock->statements.Add(Ptr(new WfCoPauseStatement));
					}

					auto switchStat = Ptr(new WfSwitchStatement);
					{
						auto refThis = Ptr(new WfReferenceExpression);
						refThis->name.value = L"<state>stateMachineObject";

						auto refInput = Ptr(new WfMemberExpression);
						refInput->parent = refThis;
						refInput->name.value = L"stateMachineInput";

						switchStat->expression = refInput;
					}
					block->statements.Add(switchStat);

					for (auto stateSwitchCase : node->caseBranches)
					{
						Ptr<WfStateInput> input;
						Ptr<WfBlockStatement> caseBlock;
						GenerateStateSwitchCase(stateSwitchCase->name.value, smcScope, switchStat, input, caseBlock);

						for (auto [argument, index] : indexed(stateSwitchCase->arguments))
						{
							auto refThis = Ptr(new WfReferenceExpression);
							refThis->name.value = L"<state>stateMachineObject";

							auto refArgument = Ptr(new WfMemberExpression);
							refArgument->parent = refThis;
							refArgument->name.value = manager->stateInputArguments[input->arguments[index].Obj()]->GetName();

							auto varDecl = Ptr(new WfVariableDeclaration);
							varDecl->name.value = argument->name.value;
							varDecl->expression = refArgument;

							auto varStat = Ptr(new WfVariableStatement);
							varStat->variable = varDecl;
							caseBlock->statements.Add(varStat);
						}
						caseBlock->statements.Add(CopyNode(stateSwitchCase->statement.Obj()));
						SetCodeRange(Ptr<WfStatement>(caseBlock), stateSwitchCase->codeRange);
					}

					if (node->type == WfStateSwitchType::Default)
					{
						auto invalidInputs=
							From(smInfo->inputIds.Keys())
							.Except(
								From(node->caseBranches)
								.Select([](Ptr<WfStateSwitchCase> switchCase) {return switchCase->name.value; })
								);
						for (auto inputName : invalidInputs)
						{
							Ptr<WfStateInput> input;
							Ptr<WfBlockStatement> caseBlock;
							GenerateStateSwitchCase(inputName, smcScope, switchStat, input, caseBlock);

							{
								auto refException = Ptr(new WfStringExpression);
								refException->value.value = L"Method \"" + inputName + L"\" of class \"" + manager->stateInputMethods[input.Obj()]->GetOwnerTypeDescriptor()->GetTypeName() + L"\" cannot be called at this moment.";

								auto raiseStat = Ptr(new WfRaiseExceptionStatement);
								raiseStat->expression = refException;

								caseBlock->statements.Add(raiseStat);
							}
						}
					}

					auto defaultBlock = Ptr(new WfBlockStatement);

					switch (node->type)
					{
					case WfStateSwitchType::Default:
					case WfStateSwitchType::Pass:
						break;
					case WfStateSwitchType::PassAndReturn:
						{
							auto gotoStat = Ptr(new WfGotoStatement);
							gotoStat->label.value = L"<state-label>OUT_OF_STATE_MACHINE";
							defaultBlock->statements.Add(gotoStat);
						}
						break;
					case WfStateSwitchType::Ignore:
						{
							defaultBlock->statements.Add(GenerateIngoreInputStatement());
						}
						break;
					case WfStateSwitchType::IgnoreAndReturn:
						{
							defaultBlock->statements.Add(GenerateIngoreInputStatement());

							auto gotoStat = Ptr(new WfGotoStatement);
							gotoStat->label.value = L"<state-label>OUT_OF_STATE_MACHINE";
							defaultBlock->statements.Add(gotoStat);
						}
						break;
					default:;
					}

					if (defaultBlock->statements.Count() > 0)
					{
						switchStat->defaultBranch = defaultBlock;
					}
					SetCodeRange(Ptr<WfStatement>(block), node->codeRange);
					result = block;
				}

				void Visit(WfStateInvokeStatement* node)override
				{
					auto smcScope = manager->nodeScopes[node]->FindFunctionScope()->parentScope.Obj();
					auto stateDecl = From(smcScope->symbols[node->name.value])
						.Select([=](Ptr<WfLexicalSymbol> symbol)
						{
							return symbol->creatorNode.Cast<WfStateDeclaration>();
						})
						.Where([=](Ptr<WfStateDeclaration> decl)
						{
							return decl != nullptr;
						})
						.First();

					auto block = Ptr(new WfBlockStatement);

					for (auto [argument, index] : indexed(stateDecl->arguments))
					{
						auto refThis = Ptr(new WfReferenceExpression);
						refThis->name.value = L"<state>stateMachineObject";
						
						auto refArgument = Ptr(new WfMemberExpression);
						refArgument->parent = refThis;
						refArgument->name.value = manager->stateDeclArguments[argument.Obj()]->GetName();

						auto assignExpr = Ptr(new WfBinaryExpression);
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refArgument;
						assignExpr->second = CopyNode(node->arguments[index].Obj());

						auto exprStat = Ptr(new WfExpressionStatement);
						exprStat->expression = assignExpr;
						block->statements.Add(exprStat);
					}

					switch (node->type)
					{
					case WfStateInvokeType::Goto:
						{
							{
								auto refState = Ptr(new WfReferenceExpression);
								refState->name.value = L"<state>state";

								auto refStateId = Ptr(new WfIntegerExpression);
								refStateId->value.value = itow(smInfo->stateIds[node->name.value]);

								auto assignExpr = Ptr(new WfBinaryExpression);
								assignExpr->op = WfBinaryOperator::Assign;
								assignExpr->first = refState;
								assignExpr->second = refStateId;

								auto exprStat = Ptr(new WfExpressionStatement);
								exprStat->expression = assignExpr;
								block->statements.Add(exprStat);
							}
							{
								auto gotoStat = Ptr(new WfGotoStatement);
								gotoStat->label.value = L"<state-label>OUT_OF_CURRENT_STATE";
								block->statements.Add(gotoStat);
							}
						}
						break;
					case WfStateInvokeType::Push:
						{
							{
								auto refThis = Ptr(new WfReferenceExpression);
								refThis->name.value = L"<state>stateMachineObject";

								auto refCoroutine = Ptr(new WfMemberExpression);
								refCoroutine->parent = refThis;
								refCoroutine->name.value = L"<state>CreateCoroutine";

								auto refStateId = Ptr(new WfIntegerExpression);
								refStateId->value.value = itow(smInfo->stateIds[node->name.value]);

								auto callExpr = Ptr(new WfCallExpression);
								callExpr->function = refCoroutine;
								callExpr->arguments.Add(refStateId);

								auto exprStat = Ptr(new WfExpressionStatement);
								exprStat->expression = callExpr;
								block->statements.Add(exprStat);
							}
							{
								block->statements.Add(Ptr(new WfCoPauseStatement));
							}
						}
						break;
					default:;
					}
					SetCodeRange(Ptr<WfStatement>(block), node->codeRange);
					result = block;
				}
			};

/***********************************************************************
ExpandStateMachine
***********************************************************************/

			void ExpandStateMachine(WfLexicalScopeManager* manager, WfStateMachineDeclaration* node)
			{
				auto& smInfo = manager->stateMachineInfos[node];

				for (auto input : node->inputs)
				{
					smInfo->inputIds.Add(input->name.value, smInfo->inputIds.Count());

					for (auto argument : input->arguments)
					{
						// var <stateip-INPUT>NAME = <DEFAULT-VALUE>;
						auto fieldInfo = manager->stateInputArguments[argument.Obj()];

						auto varDecl = Ptr(new WfVariableDeclaration);
						varDecl->name.value = fieldInfo->GetName();
						varDecl->type = GetTypeFromTypeInfo(fieldInfo->GetReturn());
						varDecl->expression = CreateDefaultValue(fieldInfo->GetReturn());

						auto att = Ptr(new WfAttribute);
						att->category.value = L"cpp";
						att->name.value = L"Private";
						varDecl->attributes.Add(att);

						node->expandedDeclarations.Add(varDecl);
						manager->declarationMemberInfos.Add(varDecl, fieldInfo);
					}
				}

				smInfo->stateIds.Add(L"", 0);
				for (auto state : node->states)
				{
					if (state->name.value != L"")
					{
						smInfo->stateIds.Add(state->name.value, smInfo->stateIds.Count());
					}

					for (auto argument : state->arguments)
					{
						// var <statesp-INPUT>NAME = <DEFAULT-VALUE>;
						auto fieldInfo = manager->stateDeclArguments[argument.Obj()];

						auto varDecl = Ptr(new WfVariableDeclaration);
						varDecl->name.value = fieldInfo->GetName();
						varDecl->type = GetTypeFromTypeInfo(fieldInfo->GetReturn());
						varDecl->expression = CreateDefaultValue(fieldInfo->GetReturn());

						auto att = Ptr(new WfAttribute);
						att->category.value = L"cpp";
						att->name.value = L"Private";
						varDecl->attributes.Add(att);

						node->expandedDeclarations.Add(varDecl);
						manager->declarationMemberInfos.Add(varDecl, fieldInfo);
					}
				}

				for (auto input : node->inputs)
				{
					auto methodInfo = manager->stateInputMethods[input.Obj()];

					// func INPUT(ARGUMENTS ...): void
					auto funcDecl = Ptr(new WfFunctionDeclaration);
					funcDecl->functionKind = WfFunctionKind::Normal;
					funcDecl->anonymity = WfFunctionAnonymity::Named;
					funcDecl->name.value = methodInfo->GetName();
					funcDecl->returnType = GetTypeFromTypeInfo(methodInfo->GetReturn());
					for (auto [argument, index] : indexed(input->arguments))
					{
						auto funcArgument = Ptr(new WfFunctionArgument);
						funcArgument->name.value = argument->name.value;
						funcArgument->type = GetTypeFromTypeInfo(methodInfo->GetParameter(index)->GetType());
						funcDecl->arguments.Add(funcArgument);
					}

					node->expandedDeclarations.Add(funcDecl);
					manager->declarationMemberInfos.Add(funcDecl, methodInfo);

					auto block = Ptr(new WfBlockStatement);
					funcDecl->statement = block;
					{
						// if (not this.stateMachineInitialized)
						auto trueBlock = Ptr(new WfBlockStatement);
						{
							auto refInit = Ptr(new WfMemberExpression);
							refInit->parent = Ptr(new WfThisExpression);
							refInit->name.value = L"stateMachineInitialized";

							auto notExpr = Ptr(new WfUnaryExpression);
							notExpr->op = WfUnaryOperator::Not;
							notExpr->operand = refInit;

							auto ifStat = Ptr(new WfIfStatement);
							ifStat->expression = notExpr;
							ifStat->trueBranch = trueBlock;

							block->statements.Add(ifStat);
						}
						{
							// this.stateMachineInitialized = true;
							auto refInit = Ptr(new WfMemberExpression);
							refInit->parent = Ptr(new WfThisExpression);
							refInit->name.value = L"stateMachineInitialized";

							auto refTrue = Ptr(new WfLiteralExpression);
							refTrue->value = WfLiteralValue::True;

							auto assignExpr = Ptr(new WfBinaryExpression);
							assignExpr->op = WfBinaryOperator::Assign;
							assignExpr->first = refInit;
							assignExpr->second = refTrue;

							auto exprStat = Ptr(new WfExpressionStatement);
							exprStat->expression = assignExpr;
							trueBlock->statements.Add(exprStat);
						}
						{
							// this.<state>CreateCoroutine(0);
							auto refCC = Ptr(new WfMemberExpression);
							refCC->parent = Ptr(new WfThisExpression);
							refCC->name.value = smInfo->createCoroutineMethod->GetName();

							auto refZero = Ptr(new WfIntegerExpression);
							refZero->value.value = L"0";

							auto callExpr = Ptr(new WfCallExpression);
							callExpr->function = refCC;
							callExpr->arguments.Add(refZero);

							auto exprStat = Ptr(new WfExpressionStatement);
							exprStat->expression = callExpr;
							trueBlock->statements.Add(exprStat);
						}
						{
							// this.ResumeStateMachine();
							auto refResume = Ptr(new WfMemberExpression);
							refResume->parent = Ptr(new WfThisExpression);
							refResume->name.value = L"ResumeStateMachine";

							auto callExpr = Ptr(new WfCallExpression);
							callExpr->function = refResume;

							auto exprStat = Ptr(new WfExpressionStatement);
							exprStat->expression = callExpr;
							trueBlock->statements.Add(exprStat);
						}
					}
					{
						// this.stateMachineInput = <INPUT>
						auto refInput = Ptr(new WfMemberExpression);
						refInput->parent = Ptr(new WfThisExpression);
						refInput->name.value = L"stateMachineInput";

						auto refInputId = Ptr(new WfIntegerExpression);
						refInputId->value.value = itow(smInfo->inputIds[input->name.value]);

						auto assignExpr = Ptr(new WfBinaryExpression);
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refInput;
						assignExpr->second = refInputId;

						auto exprStat = Ptr(new WfExpressionStatement);
						exprStat->expression = assignExpr;
						block->statements.Add(exprStat);
					}
					for (auto [argument, index] : indexed(input->arguments))
					{
						// this.<stateip-INPUT>NAME = NAME;
						auto refField = Ptr(new WfMemberExpression);
						refField->parent = Ptr(new WfThisExpression);
						refField->name.value = manager->stateInputArguments[argument.Obj()]->GetName();

						auto refArgument = Ptr(new WfReferenceExpression);
						refArgument->name.value = methodInfo->GetParameter(index)->GetName();

						auto assignExpr = Ptr(new WfBinaryExpression);
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refField;
						assignExpr->second = refArgument;

						auto exprStat = Ptr(new WfExpressionStatement);
						exprStat->expression = assignExpr;
						block->statements.Add(exprStat);
					}
					{
						// this.ResumeStateMachine();
						auto refResume = Ptr(new WfMemberExpression);
						refResume->parent = Ptr(new WfThisExpression);
						refResume->name.value = L"ResumeStateMachine";

						auto callExpr = Ptr(new WfCallExpression);
						callExpr->function = refResume;

						auto exprStat = Ptr(new WfExpressionStatement);
						exprStat->expression = callExpr;
						block->statements.Add(exprStat);
					}
				}

				{
					// func <state>CreateCoroutine(<state>startState: int): void
					auto funcDecl = Ptr(new WfFunctionDeclaration);
					funcDecl->functionKind = WfFunctionKind::Normal;
					funcDecl->anonymity = WfFunctionAnonymity::Named;
					funcDecl->name.value = smInfo->createCoroutineMethod->GetName();
					funcDecl->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<void>::CreateTypeInfo().Obj());
					{
						auto parameterInfo = smInfo->createCoroutineMethod->GetParameter(0);

						auto funcArgument = Ptr(new WfFunctionArgument);
						funcArgument->name.value = parameterInfo->GetName();
						funcArgument->type = GetTypeFromTypeInfo(parameterInfo->GetType());
						funcDecl->arguments.Add(funcArgument);
					}

					auto att = Ptr(new WfAttribute);
					att->category.value = L"cpp";
					att->name.value = L"Private";
					funcDecl->attributes.Add(att);

					node->expandedDeclarations.Add(funcDecl);
					manager->declarationMemberInfos.Add(funcDecl, smInfo->createCoroutineMethod);

					auto block = Ptr(new WfBlockStatement);
					funcDecl->statement = block;

					{
						// <state>stateMachineObject = this;
						auto varDecl = Ptr(new WfVariableDeclaration);
						varDecl->name.value = L"<state>stateMachineObject";
						varDecl->expression = Ptr(new WfThisExpression);

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = varDecl;

						block->statements.Add(stat);
					}
					{
						// <state>previousCoroutine = stateMachineCoroutine;
						auto refThis = Ptr(new WfReferenceExpression);
						refThis->name.value = L"<state>stateMachineObject";

						auto refCoroutine = Ptr(new WfMemberExpression);
						refCoroutine->parent = refThis;
						refCoroutine->name.value = L"stateMachineCoroutine";

						auto varDecl = Ptr(new WfVariableDeclaration);
						varDecl->name.value = L"<state>previousCoroutine";
						varDecl->expression = refCoroutine;

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = varDecl;

						block->statements.Add(stat);
					}
					{
						// stateMachineCoroutine = $coroutine{ ... }
						auto refThis = Ptr(new WfReferenceExpression);
						refThis->name.value = L"<state>stateMachineObject";

						auto refCoroutine = Ptr(new WfMemberExpression);
						refCoroutine->parent = refThis;
						refCoroutine->name.value = L"stateMachineCoroutine";

						auto coroutine = Ptr(new WfNewCoroutineExpression);
						auto coroutineBlock = Ptr(new WfBlockStatement);
						coroutine->statement = coroutineBlock;

						auto assignExpr = Ptr(new WfBinaryExpression);
						assignExpr->op = WfBinaryOperator::Assign;
						assignExpr->first = refCoroutine;
						assignExpr->second = coroutine;

						auto exprStat = Ptr(new WfExpressionStatement);
						exprStat->expression = assignExpr;
						block->statements.Add(exprStat);

						{
							auto tryStat = Ptr(new WfTryStatement);
							coroutineBlock->statements.Add(tryStat);

							auto tryBlock = Ptr(new WfBlockStatement);
							tryBlock->endLabel.value = L"<state-label>OUT_OF_STATE_MACHINE";
							tryStat->protectedStatement = tryBlock;

							auto finallyBlock = Ptr(new WfBlockStatement);
							tryStat->finallyStatement = finallyBlock;

							// try {... <state-label>OUT_OF_STATE_MACHINE:;}
							{
								// var <state>State = <state>startState;
								auto refStartState = Ptr(new WfReferenceExpression);
								refStartState->name.value = L"<state>startState";

								auto varDecl = Ptr(new WfVariableDeclaration);
								varDecl->name.value = L"<state>state";
								varDecl->expression = refStartState;

								auto stat = Ptr(new WfVariableStatement);
								stat->variable = varDecl;

								tryBlock->statements.Add(stat);
							}
							{
								// while(true){... <state-label>OUT_OF_CURRENT_STATE:;}
								auto whileBlock = Ptr(new WfBlockStatement);
								whileBlock->endLabel.value = L"<state-label>OUT_OF_CURRENT_STATE";
								{
									auto refTrue = Ptr(new WfLiteralExpression);
									refTrue->value = WfLiteralValue::True;

									auto whileStat = Ptr(new WfWhileStatement);
									whileStat->condition = refTrue;
									whileStat->statement = whileBlock;

									tryBlock->statements.Add(whileStat);
								}
								{
									// var <state>currentState = <state>state;
									auto refStartState = Ptr(new WfReferenceExpression);
									refStartState->name.value = L"<state>state";

									auto varDecl = Ptr(new WfVariableDeclaration);
									varDecl->name.value = L"<state>currentState";
									varDecl->expression = refStartState;

									auto stat = Ptr(new WfVariableStatement);
									stat->variable = varDecl;

									whileBlock->statements.Add(stat);
								}
								{
									// <state>state = -1;
									auto refState = Ptr(new WfReferenceExpression);
									refState->name.value = L"<state>state";

									auto assignExpr = Ptr(new WfBinaryExpression);
									assignExpr->op = WfBinaryOperator::Assign;
									assignExpr->first = refState;
									assignExpr->second = GenerateStateMachineInvalidId();

									auto exprStat = Ptr(new WfExpressionStatement);
									exprStat->expression = assignExpr;
									whileBlock->statements.Add(exprStat);
								}
								{
									// switch(<state>currentState) { case STATE:{... goto <state-label>OUT_OF_STATE_MACHINE;} ... }
									auto refCurrentState = Ptr(new WfReferenceExpression);
									refCurrentState->name.value = L"<state>currentState";

									auto switchStat = Ptr(new WfSwitchStatement);
									switchStat->expression = refCurrentState;
									whileBlock->statements.Add(switchStat);

									for (auto state : node->states)
									{
										auto switchCase = Ptr(new WfSwitchCase);
										switchStat->caseBranches.Add(switchCase);

										auto refStateId = Ptr(new WfIntegerExpression);
										refStateId->value.value = itow(smInfo->stateIds[state->name.value]);
										switchCase->expression = refStateId;

										auto caseBlock = Ptr(new WfBlockStatement);
										switchCase->statement = caseBlock;

										for (auto argument : state->arguments)
										{
											auto refThis = Ptr(new WfReferenceExpression);
											refThis->name.value = L"<state>stateMachineObject";

											auto refArgument = Ptr(new WfMemberExpression);
											refArgument->parent = refThis;
											refArgument->name.value = manager->stateDeclArguments[argument.Obj()]->GetName();

											auto varDecl = Ptr(new WfVariableDeclaration);
											varDecl->name.value = argument->name.value;
											varDecl->expression = refArgument;

											auto varStat = Ptr(new WfVariableStatement);
											varStat->variable = varDecl;
											caseBlock->statements.Add(varStat);
										}
										caseBlock->statements.Add(ExpandStateMachineStatementVisitor(manager, smInfo.Obj()).CopyNode(state->statement.Obj()));
										{
											auto gotoStat = Ptr(new WfGotoStatement);
											gotoStat->label.value = L"<state-label>OUT_OF_STATE_MACHINE";
											caseBlock->statements.Add(gotoStat);
										}
										SetCodeRange(Ptr<WfStatement>(caseBlock), state->codeRange);
									}
								}
							}
							// finally {stateMachineCoroutine = <state>previousCoroutine;}
							{
								auto refThis = Ptr(new WfReferenceExpression);
								refThis->name.value = L"<state>stateMachineObject";

								auto refCoroutine = Ptr(new WfMemberExpression);
								refCoroutine->parent = refThis;
								refCoroutine->name.value = L"stateMachineCoroutine";

								auto refPrevious = Ptr(new WfReferenceExpression);
								refPrevious->name.value = L"<state>previousCoroutine";

								auto assignExpr = Ptr(new WfBinaryExpression);
								assignExpr->op = WfBinaryOperator::Assign;
								assignExpr->first = refCoroutine;
								assignExpr->second = refPrevious;

								auto exprStat = Ptr(new WfExpressionStatement);
								exprStat->expression = assignExpr;
								finallyBlock->statements.Add(exprStat);
							}
						}
					}
				}
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_EXPANDSTATEMENT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
ExpandSwitchStatement
***********************************************************************/

			void ExpandSwitchStatement(WfLexicalScopeManager* manager, WfSwitchStatement* node)
			{
				auto block = Ptr(new WfBlockStatement);
				node->expandedStatement = block;
				auto varName = L"<switch>" + itow(manager->usedTempVars++);

				{
					auto result = manager->expressionResolvings[node->expression.Obj()];
					auto decl = Ptr(new WfVariableDeclaration);
					decl->name.value = varName;
					decl->type = GetTypeFromTypeInfo(result.type.Obj());
					decl->expression = CopyExpression(node->expression, true);

					auto stat = Ptr(new WfVariableStatement);
					stat->variable = decl;
					block->statements.Add(stat);
				}

				Ptr<WfStatement> rootIfStat;
				auto tailIfStat = &rootIfStat;

				for (auto switchCase : node->caseBranches)
				{
					auto ifStat = Ptr(new WfIfStatement);
					*tailIfStat = ifStat;
					tailIfStat = &ifStat->falseBranch;

					{
						auto refExpr = Ptr(new WfReferenceExpression);
						refExpr->name.value = varName;

						auto inferExpr = Ptr(new WfInferExpression);
						inferExpr->expression= CopyExpression(switchCase->expression, true);
						{
							auto result = manager->expressionResolvings[switchCase->expression.Obj()];
							inferExpr->type = GetTypeFromTypeInfo(result.type.Obj());
						}

						auto compare = Ptr(new WfBinaryExpression);
						compare->first = refExpr;
						compare->second = inferExpr;
						compare->op = WfBinaryOperator::EQ;

						ifStat->expression = compare;
					}
					ifStat->trueBranch = CopyStatement(switchCase->statement, true);
				}

				if (node->defaultBranch)
				{
					*tailIfStat = CopyStatement(node->defaultBranch, true);
				}

				if (rootIfStat)
				{
					block->statements.Add(rootIfStat);
				}
			}

/***********************************************************************
ExpandForEachStatement
***********************************************************************/

			Ptr<WfStatement> GenerateForEachStepStatement(WfForEachStatement* node)
			{
				auto refVar1 = Ptr(new WfReferenceExpression);
				refVar1->name.value = node->name.value;

				auto refVar2 = Ptr(new WfReferenceExpression);
				refVar2->name.value = node->name.value;

				auto one = Ptr(new WfIntegerExpression);
				one->value.value = L"1";

				auto stepExpr = Ptr(new WfBinaryExpression);
				stepExpr->first = refVar2;
				stepExpr->second = one;
				stepExpr->op = node->direction == WfForEachDirection::Normal ? WfBinaryOperator::Add : WfBinaryOperator::Sub;

				auto assignExpr = Ptr(new WfBinaryExpression);
				assignExpr->first = refVar1;
				assignExpr->second = stepExpr;
				assignExpr->op = WfBinaryOperator::Assign;

				auto stat = Ptr(new WfExpressionStatement);
				stat->expression = assignExpr;
				return stat;
			}

			class CopyForEachRangeBodyVisitor : public CopyWithExpandVirtualVisitor
			{
			public:
				WfLexicalScopeManager*						manager;
				WfForEachStatement*							forEach;

				CopyForEachRangeBodyVisitor(WfLexicalScopeManager* _manager, WfForEachStatement* _forEach)
					:CopyWithExpandVirtualVisitor(true)
					, manager(_manager)
					, forEach(_forEach)
				{
				}

				void Visit(WfContinueStatement* node)
				{
					auto scope = manager->nodeScopes[node];
					while (scope)
					{
						if (scope->ownerNode.Cast<WfWhileStatement>())
						{
							break;
						}
						else if (scope->ownerNode.Cast<WfForEachStatement>())
						{
							if (scope->ownerNode != forEach)
							{
								break;
							}
							else
							{
								auto block = Ptr(new WfBlockStatement);
								block->statements.Add(GenerateForEachStepStatement(forEach));
								block->statements.Add(Ptr(new WfContinueStatement));
								SetCodeRange((Ptr<WfStatement>)block, node->codeRange);
								result = block;
								return;
							}
						}
						scope = scope->parentScope;
					}
					copy_visitor::AstVisitor::Visit(node);
				}
			};

			void ExpandForEachStatement(WfLexicalScopeManager* manager, WfForEachStatement* node)
			{
				auto block = Ptr(new WfBlockStatement);
				node->expandedStatement = block;

				if (auto range = node->collection.Cast<WfRangeExpression>())
				{
					auto varBegin = L"<for-begin>" + node->name.value;
					auto varEnd = L"<for-end>" + node->name.value;
					{
						auto result = manager->expressionResolvings[range->begin.Obj()];
						auto decl = Ptr(new WfVariableDeclaration);
						decl->name.value = varBegin;
						decl->type = GetTypeFromTypeInfo(result.type.Obj());
						decl->expression = CopyExpression(range->begin, true);
						if (range->beginBoundary == WfRangeBoundary::Exclusive)
						{
							auto one = Ptr(new WfIntegerExpression);
							one->value.value = L"1";

							auto addExpr = Ptr(new WfBinaryExpression);
							addExpr->first = decl->expression;
							addExpr->second = one;
							addExpr->op = WfBinaryOperator::Add;
							
							decl->expression = addExpr;
						}

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = decl;
						block->statements.Add(stat);
					}
					{
						auto result = manager->expressionResolvings[range->end.Obj()];
						auto decl = Ptr(new WfVariableDeclaration);
						decl->name.value = varEnd;
						decl->type = GetTypeFromTypeInfo(result.type.Obj());
						decl->expression = CopyExpression(range->end, true);
						if (range->endBoundary == WfRangeBoundary::Exclusive)
						{
							auto one = Ptr(new WfIntegerExpression);
							one->value.value = L"1";

							auto subExpr = Ptr(new WfBinaryExpression);
							subExpr->first = decl->expression;
							subExpr->second = one;
							subExpr->op = WfBinaryOperator::Sub;

							decl->expression = subExpr;
						}

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = decl;
						block->statements.Add(stat);
					}
					{
						auto refBegin = Ptr(new WfReferenceExpression);
						refBegin->name.value = node->direction == WfForEachDirection::Normal ? varBegin : varEnd;

						auto decl = Ptr(new WfVariableDeclaration);
						decl->name.value = node->name.value;
						decl->expression = refBegin;

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = decl;
						block->statements.Add(stat);
					}
					{
						auto whileStat = Ptr(new WfWhileStatement);
						{
							auto refVar = Ptr(new WfReferenceExpression);
							refVar->name.value = node->name.value;

							auto refBegin = Ptr(new WfReferenceExpression);
							refBegin->name.value = node->direction == WfForEachDirection::Normal ? varEnd : varBegin;

							auto compare = Ptr(new WfBinaryExpression);
							compare->first = refVar;
							compare->second = refBegin;
							compare->op = node->direction == WfForEachDirection::Normal ? WfBinaryOperator::LE : WfBinaryOperator::GE;

							whileStat->condition = compare;
						}
						{
							auto whileBlock = Ptr(new WfBlockStatement);
							whileStat->statement = whileBlock;

							{
								CopyForEachRangeBodyVisitor visitor(manager, node);
								whileBlock->statements.Add(visitor.CopyNode(node->statement.Obj()));
							}
							whileBlock->statements.Add(GenerateForEachStepStatement(node));
						}
						block->statements.Add(whileStat);
					}
				}
				else
				{
					auto varEnum = L"<for-enumerable>" + node->name.value;
					auto varIter = L"<for-enumerator>" + node->name.value;
					{
						auto decl = Ptr(new WfVariableDeclaration);
						decl->name.value = varEnum;
						if (node->direction == WfForEachDirection::Normal)
						{
							auto inferExpr = Ptr(new WfInferExpression);
							inferExpr->expression = CopyExpression(node->collection, true);
							inferExpr->type = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<IValueEnumerable>>::CreateTypeInfo().Obj());

							decl->expression = inferExpr;
						}
						else
						{
							auto refMethod = Ptr(new WfChildExpression);
							refMethod->parent = GetExpressionFromTypeDescriptor(description::GetTypeDescriptor<Sys>());
							refMethod->name.value = L"ReverseEnumerable";

							auto refCall = Ptr(new WfCallExpression);
							refCall->function = refMethod;
							refCall->arguments.Add(CopyExpression(node->collection, true));

							decl->expression = refCall;
						}

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = decl;
						block->statements.Add(stat);
					}
					{
						auto refEnum = Ptr(new WfReferenceExpression);
						refEnum->name.value = varEnum;

						auto refMethod = Ptr(new WfMemberExpression);
						refMethod->parent = refEnum;
						refMethod->name.value = L"CreateEnumerator";

						auto callExpr = Ptr(new WfCallExpression);
						callExpr->function = refMethod;

						auto decl = Ptr(new WfVariableDeclaration);
						decl->name.value = varIter;
						decl->expression = callExpr;

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = decl;
						block->statements.Add(stat);
					}
					{
						auto whileStat = Ptr(new WfWhileStatement);
						{
							auto refIter = Ptr(new WfReferenceExpression);
							refIter->name.value = varIter;

							auto refMethod = Ptr(new WfMemberExpression);
							refMethod->parent = refIter;
							refMethod->name.value = L"Next";

							auto callExpr = Ptr(new WfCallExpression);
							callExpr->function = refMethod;

							whileStat->condition = callExpr;
						}
						{
							auto whileBlock = Ptr(new WfBlockStatement);
							whileStat->statement = whileBlock;

							{
								auto refIter = Ptr(new WfReferenceExpression);
								refIter->name.value = varIter;

								auto refMethod = Ptr(new WfMemberExpression);
								refMethod->parent = refIter;
								refMethod->name.value = L"GetCurrent";

								auto callExpr = Ptr(new WfCallExpression);
								callExpr->function = refMethod;

								auto castExpr = Ptr(new WfTypeCastingExpression);
								castExpr->expression = callExpr;
								castExpr->strategy = WfTypeCastingStrategy::Strong;
								{
									auto parentScope = manager->nodeScopes[node];
									auto symbol = parentScope->symbols[node->name.value][0];
									castExpr->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
								}

								auto decl = Ptr(new WfVariableDeclaration);
								decl->name.value = node->name.value;
								decl->expression = castExpr;

								auto stat = Ptr(new WfVariableStatement);
								stat->variable = decl;
								whileBlock->statements.Add(stat);
							}
							whileBlock->statements.Add(CopyStatement(node->statement, true));
						}
						block->statements.Add(whileStat);
					}
				}
			}

/***********************************************************************
ExpandCoProviderStatement
***********************************************************************/

			class ExpandCoProviderStatementVisitor : public CopyWithExpandVirtualVisitor
			{
			public:
				WfLexicalScopeManager*						manager;

				ExpandCoProviderStatementVisitor(WfLexicalScopeManager* _manager)
					:CopyWithExpandVirtualVisitor(true)
					, manager(_manager)
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					auto opInfo = manager->coOperatorResolvings[node].methodInfo;
					auto block = Ptr(new WfBlockStatement);

					{
						auto refImpl = Ptr(new WfReferenceExpression);
						refImpl->name.value = L"<co-impl>";

						auto funcExpr = Ptr(new WfChildExpression);
						funcExpr->parent = GetExpressionFromTypeDescriptor(opInfo->GetOwnerTypeDescriptor());
						funcExpr->name.value = opInfo->GetName();

						auto callExpr = Ptr(new WfCallExpression);
						callExpr->function = funcExpr;
						callExpr->arguments.Add(refImpl);
						if (node->expression)
						{
							auto returnValue = CopyNode(node->expression.Obj());
							{
								auto scope = manager->nodeScopes[node].Obj();
								auto functionScope = scope->FindFunctionScope();
								if (auto funcDecl = functionScope->ownerNode.Cast<WfFunctionDeclaration>())
								{
									auto returnType = CreateTypeInfoFromType(scope, funcDecl->returnType);
									if (auto group = returnType->GetTypeDescriptor()->GetMethodGroupByName(L"StoreResult", true))
									{
										vint count = group->GetMethodCount();
										for (vint i = 0; i < count; i++)
										{
											auto method = group->GetMethod(i);
											if (method->IsStatic() && method->GetParameterCount() == 1)
											{
												auto refType = GetExpressionFromTypeDescriptor(returnType->GetTypeDescriptor());

												auto refStoreResult = Ptr(new WfChildExpression);
												refStoreResult->parent = refType;
												refStoreResult->name.value = L"StoreResult";

												auto callExpr = Ptr(new WfCallExpression);
												callExpr->function = refStoreResult;
												callExpr->arguments.Add(returnValue);

												returnValue = callExpr;
												break;
											}
										}
									}
								}
							}
							callExpr->arguments.Add(returnValue);
						}

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = callExpr;
						block->statements.Add(stat);
					}
					block->statements.Add(Ptr(new WfReturnStatement));

					SetCodeRange(Ptr<WfStatement>(block), node->codeRange);
					result = block;
				}

				void Visit(WfCoOperatorStatement* node)override
				{
					auto opInfo = manager->coOperatorResolvings[node].methodInfo;
					auto block = Ptr(new WfBlockStatement);

					{
						auto refImpl = Ptr(new WfReferenceExpression);
						refImpl->name.value = L"<co-impl>";

						auto funcExpr = Ptr(new WfChildExpression);
						funcExpr->parent = GetExpressionFromTypeDescriptor(opInfo->GetOwnerTypeDescriptor());
						funcExpr->name.value = opInfo->GetName();

						auto callExpr = Ptr(new WfCallExpression);
						callExpr->function = funcExpr;
						callExpr->arguments.Add(refImpl);
						for (auto argument : node->arguments)
						{
							callExpr->arguments.Add(CopyNode(argument.Obj()));
						}

						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = callExpr;

						auto pauseBlock = Ptr(new WfBlockStatement);
						pauseBlock->statements.Add(stat);

						auto pauseStat = Ptr(new WfCoPauseStatement);
						pauseStat->statement = pauseBlock;

						block->statements.Add(pauseStat);
					}
					{
						Ptr<WfIfStatement> ifHasResultStat;

						if (node->varName.value == L"")
						{
							ifHasResultStat = Ptr(new WfIfStatement);
							{
								auto refCoResult = Ptr(new WfReferenceExpression);
								refCoResult->name.value = L"<co-result>";

								auto testExpr = Ptr(new WfTypeTestingExpression);
								testExpr->expression = refCoResult;
								testExpr->test = WfTypeTesting::IsNotNull;

								ifHasResultStat->expression = testExpr;
							}
						}

						auto ifStat = Ptr(new WfIfStatement);
						{
							auto refCoResult = Ptr(new WfReferenceExpression);
							refCoResult->name.value = L"<co-result>";

							auto refFailure = Ptr(new WfMemberExpression);
							refFailure->parent = refCoResult;
							refFailure->name.value = L"Failure";

							auto testExpr = Ptr(new WfTypeTestingExpression);
							testExpr->expression = refFailure;
							testExpr->test = WfTypeTesting::IsNotNull;

							ifStat->expression = testExpr;
						}
						{
							auto refCoResult = Ptr(new WfReferenceExpression);
							refCoResult->name.value = L"<co-result>";

							auto refFailure = Ptr(new WfMemberExpression);
							refFailure->parent = refCoResult;
							refFailure->name.value = L"Failure";

							auto raiseStat = Ptr(new WfRaiseExceptionStatement);
							raiseStat->expression = refFailure;

							auto ifBlock = Ptr(new WfBlockStatement);
							ifBlock->statements.Add(raiseStat);
							ifStat->trueBranch = ifBlock;
						}

						if (ifHasResultStat)
						{
							auto ifBlock = Ptr(new WfBlockStatement);
							ifHasResultStat->trueBranch = ifBlock;
							ifBlock->statements.Add(ifStat);
							block->statements.Add(ifHasResultStat);
						}
						else
						{
							block->statements.Add(ifStat);
						}
					}
					if (node->varName.value != L"")
					{
						auto refCoResult = Ptr(new WfReferenceExpression);
						refCoResult->name.value = L"<co-result>";

						auto refResult = Ptr(new WfMemberExpression);
						refResult->parent = refCoResult;
						refResult->name.value = L"Result";

						auto castResultInfo = manager->coCastResultResolvings[node].methodInfo;
						auto refCastResult = Ptr(new WfChildExpression);
						refCastResult->parent = GetExpressionFromTypeDescriptor(castResultInfo->GetOwnerTypeDescriptor());
						refCastResult->name.value = L"CastResult";

						auto callExpr = Ptr(new WfCallExpression);
						callExpr->function = refCastResult;
						callExpr->arguments.Add(refResult);

						auto varDecl = Ptr(new WfVariableDeclaration);
						varDecl->name.value = node->varName.value;
						varDecl->expression = callExpr;

						auto stat = Ptr(new WfVariableStatement);
						stat->variable = varDecl;
						block->statements.Add(stat);
					}

					SetCodeRange(Ptr<WfStatement>(block), node->codeRange);
					result = block;
				}

				void Visit(WfBlockStatement* node)override
				{
					auto block = Ptr(new WfBlockStatement);

					for (auto statement : node->statements)
					{
						statement = SearchUntilNonVirtualStatement(statement);

						if (auto coOperatorStat = statement.Cast<WfCoOperatorStatement>())
						{
							coOperatorStat->Accept(this);
							CopyFrom(block->statements, result.Cast<WfBlockStatement>()->statements, true);
						}
						else
						{
							block->statements.Add(CopyNode(statement.Obj()));
						}
					}

					SetCodeRange(Ptr<WfStatement>(block), node->codeRange);
					result = block;
				}
			};

			void ExpandCoProviderStatement(WfLexicalScopeManager* manager, WfCoProviderStatement* node)
			{
				auto scope = manager->nodeScopes[node].Obj();
				auto functionScope = scope->FindFunctionScope();
				auto funcDecl = functionScope->ownerNode.Cast<WfFunctionDeclaration>();
				auto providerScope = manager->nodeScopes[funcDecl->statement.Obj()];
				auto providerType = providerScope->symbols[L"$PROVIDER"][0]->typeInfo;
				auto implType = providerScope->symbols[L"$IMPL"][0]->typeInfo;

				auto coroutineExpr = Ptr(new WfNewCoroutineExpression);
				{
					coroutineExpr->name.value = L"<co-result>";
					coroutineExpr->statement = ExpandCoProviderStatementVisitor(manager).CopyNode(node->statement.Obj());
				}
				manager->coNewCoroutineResolvings.Add(coroutineExpr, ResolveExpressionResult::ReadonlyType(providerType));

				auto creatorExpr = Ptr(new WfFunctionExpression);
				{
					auto creatorDecl = Ptr(new WfFunctionDeclaration);
					creatorExpr->function = creatorDecl;
					creatorDecl->functionKind = WfFunctionKind::Normal;
					creatorDecl->anonymity = WfFunctionAnonymity::Anonymous;
					creatorDecl->returnType = GetTypeFromTypeInfo(TypeInfoRetriver<Ptr<ICoroutine>>::CreateTypeInfo().Obj());
					{
						auto argument = Ptr(new WfFunctionArgument);
						creatorDecl->arguments.Add(argument);
						argument->name.value = L"<co-impl>";
						argument->type = GetTypeFromTypeInfo(implType.Obj());
					}

					auto block = Ptr(new WfBlockStatement);
					creatorDecl->statement = block;

					auto returnStat = Ptr(new WfReturnStatement);
					returnStat->expression = coroutineExpr;
					block->statements.Add(returnStat);
				}

				auto providerBlock = Ptr(new WfBlockStatement);
				{
					auto funcReturnType = CreateTypeInfoFromType(functionScope, funcDecl->returnType);
					auto creatorInfo = manager->coProviderResolvings[node].methodInfo;

					auto funcExpr = Ptr(new WfChildExpression);
					funcExpr->parent = GetExpressionFromTypeDescriptor(creatorInfo->GetOwnerTypeDescriptor());
					funcExpr->name.value = creatorInfo->GetName();

					auto callExpr = Ptr(new WfCallExpression);
					callExpr->function = funcExpr;
					callExpr->arguments.Add(creatorExpr);

					if (funcReturnType->GetTypeDescriptor() == description::GetTypeDescriptor<void>())
					{
						auto stat = Ptr(new WfExpressionStatement);
						stat->expression = callExpr;
						providerBlock->statements.Add(stat);
					}
					else
					{
						if (IsSameType(funcReturnType.Obj(), creatorInfo->GetReturn()))
						{
							auto stat = Ptr(new WfReturnStatement);
							stat->expression = callExpr;
							providerBlock->statements.Add(stat);
						}
						else if (funcReturnType->GetTypeDescriptor() == creatorInfo->GetReturn()->GetTypeDescriptor())
						{
							auto castExpr = Ptr(new WfTypeCastingExpression);
							castExpr->strategy = WfTypeCastingStrategy::Strong;
							castExpr->type = GetTypeFromTypeInfo(funcReturnType.Obj());
							castExpr->expression = callExpr;

							auto stat = Ptr(new WfReturnStatement);
							stat->expression = castExpr;
							providerBlock->statements.Add(stat);
						}
						else
						{
							{
								auto varDecl = Ptr(new WfVariableDeclaration);
								varDecl->name.value = L"<co-mixin-source-variable>";
								varDecl->expression = callExpr;

								auto stat = Ptr(new WfVariableStatement);
								stat->variable = varDecl;
								providerBlock->statements.Add(stat);
							}
							{
								auto refExpr = Ptr(new WfReferenceExpression);
								refExpr->name.value = L"<co-mixin-source-variable>";

								auto castExpr = Ptr(new WfMixinCastExpression);
								castExpr->type = GetTypeFromTypeInfo(funcReturnType.Obj());
								castExpr->expression = refExpr;

								auto stat = Ptr(new WfReturnStatement);
								stat->expression = castExpr;
								providerBlock->statements.Add(stat);
							}
						}
					}
				}
				
				node->expandedStatement = providerBlock;
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_MISC.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
IsExpressionDependOnExpectedType(Expression)
***********************************************************************/

			class IsExpressionDependOnExpectedTypeVisitor
				: public empty_visitor::ExpressionVisitor
				, public empty_visitor::VirtualCseExpressionVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				bool								hasExpectedType;
				bool								result = false;

				IsExpressionDependOnExpectedTypeVisitor(WfLexicalScopeManager* _manager, bool _hasExpectedType)
					:manager(_manager)
					, hasExpectedType(_hasExpectedType)
				{
				}

				void Dispatch(WfVirtualCfeExpression* node)override
				{
					node->expandedExpression->Accept(this);
				}

				void Dispatch(WfVirtualCseExpression* node)override
				{
					node->Accept((WfVirtualCseExpression::IVisitor*)this);
				}

				bool Execute(Ptr<WfExpression> expression)
				{
					result = false;
					expression->Accept(this);
					return result;
				}

				void Visit(WfReferenceExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					List<ResolveExpressionResult> testResults;
					manager->ResolveName(scope, node->name.value, testResults);
					if (testResults.Count() == 0)
					{
						result = true;
					}
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					result = scope->symbols.Count() > 0;
				}

				void Visit(WfLiteralExpression* node)override
				{
					if (node->value == WfLiteralValue::Null)
					{
						result = true;
					}
				}

				void Visit(WfBinaryExpression* node)override
				{
					if (node->op == WfBinaryOperator::FlagOr)
					{
						result = Execute(node->first) && Execute(node->second);
					}
				}

				void Visit(WfIfExpression* node)override
				{
					result = Execute(node->trueBranch) && Execute(node->falseBranch);
				}

				void Visit(WfConstructorExpression* node)override
				{
					if (hasExpectedType || node->arguments.Count() == 0)
					{
						result = true;
					}
					else
					{
						vint possibleFieldCount = 0;
						bool unresolvableField = false;
						auto scope = manager->nodeScopes[node].Obj();

						for (auto argument : node->arguments)
						{
							if (argument->value)
							{
								if (auto refExpr = argument->key.Cast<WfReferenceExpression>())
								{
									possibleFieldCount++;
									List<ResolveExpressionResult> testResults;
									manager->ResolveName(scope, refExpr->name.value, testResults);
									if (testResults.Count() == 0)
									{
										unresolvableField = true;
									}
								}
							}
						}

						result = unresolvableField&&possibleFieldCount == node->arguments.Count();
					}
				}

				void Visit(WfExpectedTypeCastExpression* node)override
				{
					result = true;
				}
			};

			bool IsExpressionDependOnExpectedType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, bool hasExpectedType)
			{
				IsExpressionDependOnExpectedTypeVisitor visitor(manager, hasExpectedType);
				expression->Accept(&visitor);
				return visitor.result;
			}

/***********************************************************************
GetExpressionName(Expression)
***********************************************************************/

			class GetExpressionNameVisitor
				: public empty_visitor::ExpressionVisitor
				, public empty_visitor::VirtualCseExpressionVisitor
			{
			public:
				WString								result;

				void Dispatch(WfVirtualCfeExpression* node)override
				{
					node->expandedExpression->Accept(this);
				}

				void Dispatch(WfVirtualCseExpression* node)override
				{
					node->Accept((WfVirtualCseExpression::IVisitor*)this);
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfReferenceExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfMemberExpression* node)override
				{
					result = node->name.value;
				}

				void Visit(WfChildExpression* node)override
				{
					result = node->name.value;
				}
			};

			WString GetExpressionName(WfExpression* expression)
			{
				GetExpressionNameVisitor visitor;
				expression->Accept(&visitor);
				return visitor.result;
			}

			WString GetExpressionName(Ptr<WfExpression> expression)
			{
				return GetExpressionName(expression.Obj());
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_SEARCHORDEREDNAME.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;

/***********************************************************************
SearchOrderedName
***********************************************************************/

			class SearchOrderedNameVisitor : public traverse_visitor::AstVisitor
			{
			public:
				WfLexicalScope*							scope;
				SortedList<vint>&						names;

				SearchOrderedNameVisitor(WfLexicalScope* _scope, SortedList<vint>& _names)
					:scope(_scope)
					, names(_names)
				{
				}

				void Traverse(WfOrderedNameExpression* node)override
				{
					vint name = wtoi(node->name.value.Sub(1, node->name.value.Length() - 1));
					if (!names.Contains(name))
					{
						WfLexicalScope* currentScope = scope;
						while (currentScope)
						{
							if (currentScope->symbols.Keys().Contains(node->name.value))
							{
								return;
							}
							currentScope = currentScope->parentScope.Obj();
						}
						names.Add(name);
					}
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					// names in nested ordered lambda expression is not counted
				}

				static void Execute(WfLexicalScope* scope, WfExpression* expression, SortedList<vint>& names)
				{
					SearchOrderedNameVisitor visitor(scope, names);
					expression->Accept(&visitor);
				}
			};

			void SearchOrderedName(WfLexicalScope* scope, WfExpression* expression, collections::SortedList<vint>& names)
			{
				SearchOrderedNameVisitor::Execute(scope, expression, names);
			}

			void SearchOrderedName(WfLexicalScope* scope, Ptr<WfExpression> expression, collections::SortedList<vint>& names)
			{
				SearchOrderedNameVisitor::Execute(scope, expression.Obj(), names);
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_TYPEINFO.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
GetTypeFlag
***********************************************************************/

			TypeFlag GetTypeFlag(reflection::description::ITypeDescriptor* typeDescriptor)
			{
				if (typeDescriptor == GetTypeDescriptor<bool>())		return TypeFlag::Bool;
				if (typeDescriptor == GetTypeDescriptor<vint8_t>())		return TypeFlag::I1;
				if (typeDescriptor == GetTypeDescriptor<vint16_t>())	return TypeFlag::I2;
				if (typeDescriptor == GetTypeDescriptor<vint32_t>())	return TypeFlag::I4;
				if (typeDescriptor == GetTypeDescriptor<vint64_t>())	return TypeFlag::I8;
				if (typeDescriptor == GetTypeDescriptor<vuint8_t>())	return TypeFlag::U1;
				if (typeDescriptor == GetTypeDescriptor<vuint16_t>())	return TypeFlag::U2;
				if (typeDescriptor == GetTypeDescriptor<vuint32_t>())	return TypeFlag::U4;
				if (typeDescriptor == GetTypeDescriptor<vuint64_t>())	return TypeFlag::U8;
				if (typeDescriptor == GetTypeDescriptor<float>())		return TypeFlag::F4;
				if (typeDescriptor == GetTypeDescriptor<double>())		return TypeFlag::F8;
				if (typeDescriptor == GetTypeDescriptor<WString>())		return TypeFlag::String;
				switch (typeDescriptor->GetTypeDescriptorFlags())
				{
				case TypeDescriptorFlags::FlagEnum:
				case TypeDescriptorFlags::NormalEnum:
					return TypeFlag::Enum;
				case TypeDescriptorFlags::Struct:
					return TypeFlag::Struct;
				default:
					return TypeFlag::Others;
				}
			}

			TypeFlag GetTypeFlag(reflection::description::ITypeInfo* typeInfo)
			{
				ITypeDescriptor* td = typeInfo->GetTypeDescriptor();
				return GetTypeFlag(td);
			}

/***********************************************************************
CreateTypeInfoFromTypeFlag
***********************************************************************/

			Ptr<reflection::description::ITypeInfo> CreateTypeInfoFromTypeFlag(TypeFlag flag)
			{
				switch (flag)
				{
				case TypeFlag::Bool:	return TypeInfoRetriver<bool>::CreateTypeInfo();
				case TypeFlag::I1:		return TypeInfoRetriver<vint8_t>::CreateTypeInfo();
				case TypeFlag::I2:		return TypeInfoRetriver<vint16_t>::CreateTypeInfo();
				case TypeFlag::I4:		return TypeInfoRetriver<vint32_t>::CreateTypeInfo();
				case TypeFlag::I8:		return TypeInfoRetriver<vint64_t>::CreateTypeInfo();
				case TypeFlag::U1:		return TypeInfoRetriver<vuint8_t>::CreateTypeInfo();
				case TypeFlag::U2:		return TypeInfoRetriver<vuint16_t>::CreateTypeInfo();
				case TypeFlag::U4:		return TypeInfoRetriver<vuint32_t>::CreateTypeInfo();
				case TypeFlag::U8:		return TypeInfoRetriver<vuint64_t>::CreateTypeInfo();
				case TypeFlag::F4:		return TypeInfoRetriver<float>::CreateTypeInfo();
				case TypeFlag::F8:		return TypeInfoRetriver<double>::CreateTypeInfo();
				case TypeFlag::String:	return TypeInfoRetriver<WString>::CreateTypeInfo();
				default:				return nullptr;
				}
			}

/***********************************************************************
GetTypeFragments
***********************************************************************/

			void GetTypeFragments(reflection::description::ITypeDescriptor* typeDescriptor, collections::List<WString>& fragments)
			{
				WString name = typeDescriptor->GetTypeName();
				const wchar_t* reading = name.Buffer();
				while (reading)
				{
					const wchar_t* delimiter = wcsstr(reading, L"::");
					if (delimiter)
					{
						fragments.Add(WString::CopyFrom(reading, vint(delimiter - reading)));
						reading = delimiter + 2;
					}
					else
					{
						fragments.Add(reading);
						break;
					}
				}
			}

/***********************************************************************
GetExpressionFromTypeDescriptor
***********************************************************************/

			Ptr<WfExpression> GetExpressionFromTypeDescriptor(reflection::description::ITypeDescriptor* typeDescriptor)
			{
				List<WString> fragments;
				GetTypeFragments(typeDescriptor, fragments);

				Ptr<WfExpression> parentExpr;
				for (auto fragment : fragments)
				{
					if (!parentExpr)
					{
						auto expr = Ptr(new WfTopQualifiedExpression);
						expr->name.value = fragment;
						parentExpr = expr;
					}
					else
					{
						auto expr = Ptr(new WfChildExpression);
						expr->parent = parentExpr;
						expr->name.value = fragment;
						parentExpr = expr;
					}
				}
				return parentExpr;
			}

/***********************************************************************
GetTypeFromTypeInfo
***********************************************************************/

			Ptr<WfType> GetTypeFromTypeInfo(reflection::description::ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					{
						Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
						if (element)
						{
							auto type = Ptr(new WfRawPointerType);
							type->element = element;
							return type;
						}
						return 0;
					}
				case ITypeInfo::SharedPtr:
					{
						if (typeInfo->GetElementType()->GetDecorator() == ITypeInfo::Generic)
						{
							return GetTypeFromTypeInfo(typeInfo->GetElementType());
						}
						else
						{
							Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
							if (element)
							{
								auto type = Ptr(new WfSharedPointerType);
								type->element = element;
								return type;
							}
							return 0;
						}
					}
				case ITypeInfo::Nullable:
					{
						Ptr<WfType> element = GetTypeFromTypeInfo(typeInfo->GetElementType());
						if (element)
						{
							auto type = Ptr(new WfNullableType);
							type->element = element;
							return type;
						}
						return 0;
					}
				case ITypeInfo::TypeDescriptor:
					{
						List<WString> fragments;
						GetTypeFragments(typeInfo->GetTypeDescriptor(), fragments);

						Ptr<WfType> parentType;
						for (auto fragment : fragments)
						{
							if (!parentType)
							{
								auto type = Ptr(new WfTopQualifiedType);
								type->name.value = fragment;
								parentType = type;
							}
							else
							{
								auto type = Ptr(new WfChildType);
								type->parent = parentType;
								type->name.value = fragment;
								parentType = type;
							}
						}
						return parentType;
					}
				case ITypeInfo::Generic:
					{
						if (typeInfo->GetElementType()->GetDecorator() == ITypeInfo::TypeDescriptor)
						{
							if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueEnumerable>())
							{
								if (typeInfo->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> elementType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										auto type = Ptr(new WfEnumerableType);
										type->element = elementType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueReadonlyList>())
							{
								if (typeInfo->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										auto type = Ptr(new WfMapType);
										type->writability = WfMapWritability::Readonly;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueList>())
							{
								if (typeInfo->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										auto type = Ptr(new WfMapType);
										type->writability = WfMapWritability::Writable;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueObservableList>())
							{
								if (typeInfo->GetGenericArgumentCount() == 1)
								{
									if (Ptr<WfType> elementType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										auto type = Ptr(new WfObservableListType);
										type->element = elementType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueReadonlyDictionary>())
							{
								if (typeInfo->GetGenericArgumentCount() == 2)
								{
									if (Ptr<WfType> keyType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(1)))
									{
										auto type = Ptr(new WfMapType);
										type->writability = WfMapWritability::Readonly;
										type->key = keyType;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueDictionary>())
							{
								if (typeInfo->GetGenericArgumentCount() == 2)
								{
									if (Ptr<WfType> keyType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									if (Ptr<WfType> valueType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(1)))
									{
										auto type = Ptr(new WfMapType);
										type->writability = WfMapWritability::Writable;
										type->key = keyType;
										type->value = valueType;
										return type;
									}
								}
							}
							else if (typeInfo->GetTypeDescriptor() == GetTypeDescriptor<IValueFunctionProxy>())
							{
								if (typeInfo->GetGenericArgumentCount() >= 1)
								{
									if (Ptr<WfType> returnType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0)))
									{
										auto type = Ptr(new WfFunctionType);
										type->result = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(0));
										for (vint i = 1; i < typeInfo->GetGenericArgumentCount(); i++)
										{
											if (Ptr<WfType> argumentType = GetTypeFromTypeInfo(typeInfo->GetGenericArgument(i)))
											{
												type->arguments.Add(argumentType);
											}
											else
											{
												return 0;
											}
										}
										return type;
									}
								}
							}
						}
						return 0;
					}
				default:
					return 0;
				}
			}

/***********************************************************************
GetScopeNameFromReferenceType
***********************************************************************/

			class GetScopeNameFromReferenceTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScope*				scope;
				Ptr<WfLexicalScopeName>		result;

				GetScopeNameFromReferenceTypeVisitor(WfLexicalScope* _scope)
					:scope(_scope)
				{
				}

				Ptr<WfLexicalScopeName> Call(WfType* node)
				{
					node->Accept(this);
					Ptr<WfLexicalScopeName> scopeName = result;
					result = 0;
					return scopeName;
				}

				void Visit(WfPredefinedType* node)override
				{
					WString name;
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						name = L"Void";
						break;
					case WfPredefinedTypeName::Object:
						name = L"Object";
						break;
					case WfPredefinedTypeName::Interface:
						name = L"Interface";
						break;
					case WfPredefinedTypeName::Int:
#if defined VCZH_64
						name = L"Int64";
#else
						name = L"Int32";
#endif
						break;
					case WfPredefinedTypeName::UInt:
#if defined VCZH_64
						name = L"UInt64";
#else
						name = L"UInt32";
#endif
						break;
					case WfPredefinedTypeName::Float:
						name = L"Single";
						break;
					case WfPredefinedTypeName::Double:
						name = L"Double";
						break;
					case WfPredefinedTypeName::String:
						name = L"String";
						break;
					case WfPredefinedTypeName::Char:
						name = L"Char";
						break;
					case WfPredefinedTypeName::Bool:
						name = L"Boolean";
						break;
					default:
						CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfPredefinedType*)#Internal error, ValidateTypeStructure function should check correctly.");
					}

					auto ns = Ptr(new WfTopQualifiedType);
					ns->name.value = L"system";

					auto type = Ptr(new WfChildType);
					type->parent = ns;
					type->name.value = name;

					type->Accept(this);
				}

				void Visit(WfTopQualifiedType* node)override
				{
					auto manager = scope->FindManager();
					if (manager->globalName)
					{
						vint index = manager->globalName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							result = manager->globalName->children.Values()[index];
							return;
						}
					}
					manager->errors.Add(WfErrors::TopQualifiedSymbolNotExists(node, node->name.value));
				}

				void Visit(WfReferenceType* node)override
				{
					auto manager = scope->FindManager();
					List<ResolveExpressionResult> results;
					manager->ResolveName(scope, node->name.value, results);

					if (results.Count() > 1)
					{
						manager->errors.Add(WfErrors::TooManyTargets(node, results, node->name.value));
					}
					else if (results.Count() == 1)
					{
						if (auto scopeName = results[0].scopeName)
						{
							result = scopeName;
						}
						else
						{
							manager->errors.Add(WfErrors::TypeNotExists(node, results[0]));
						}
					}
					else
					{
						manager->errors.Add(WfErrors::ReferenceNotExists(node, node->name.value));
					}
				}

				void Visit(WfRawPointerType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfRawPointerType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfSharedPointerType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfSharedPointerType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfNullableType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfNullableType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfEnumerableType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfEnumerableType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfMapType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfMapType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfObservableListType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfObservableListType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfFunctionType* node)override
				{
					CHECK_FAIL(L"GetScopeNameFromReferenceTypeVisitor::Visit(WfFunctionType*)#Internal error, ValidateTypeStructure function should check correctly.");
				}

				void Visit(WfChildType* node)override
				{
					if (Ptr<WfLexicalScopeName> scopeName = Call(node->parent.Obj()))
					{
						vint index = scopeName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							result = scopeName->children.Values()[index];
							return;
						}
						scope->FindManager()->errors.Add(WfErrors::ChildSymbolNotExists(node, scopeName, node->name.value));
					}
				}

				static Ptr<WfLexicalScopeName> Execute(WfLexicalScope* scope, WfType* type)
				{
					return GetScopeNameFromReferenceTypeVisitor(scope).Call(type);
				}
			};

			Ptr<WfLexicalScopeName> GetScopeNameFromReferenceType(WfLexicalScope* scope, Ptr<WfType> type)
			{
				return GetScopeNameFromReferenceTypeVisitor::Execute(scope, type.Obj());
			}

/***********************************************************************
CreateTypeInfoFromType
***********************************************************************/

			class CreateTypeInfoFromTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScope*				scope;
				Ptr<ITypeInfo>				result;

				CreateTypeInfoFromTypeVisitor(WfLexicalScope* _scope)
					:scope(_scope)
				{
				}

				Ptr<ITypeInfo> Call(WfType* node, bool checkTypeForValue)
				{
					node->Accept(this);
					Ptr<ITypeInfo> typeInfo = result;
					result = 0;
					if (typeInfo)
					{
						auto manager = scope->FindManager();
						switch (typeInfo->GetDecorator())
						{
						case ITypeInfo::RawPtr:
						case ITypeInfo::SharedPtr:
							switch (typeInfo->GetTypeDescriptor()->GetTypeDescriptorFlags())
							{
							case TypeDescriptorFlags::IDescriptable:
							case TypeDescriptorFlags::Class:
							case TypeDescriptorFlags::Interface:
								break;
							default:
								if (typeInfo->GetDecorator() == ITypeInfo::RawPtr)
								{
									manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node, typeInfo.Obj()));
								}
								else
								{
									manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node, typeInfo.Obj()));
								}
							}
							break;
						case ITypeInfo::Nullable:
							switch (typeInfo->GetTypeDescriptor()->GetTypeDescriptorFlags())
							{
							case TypeDescriptorFlags::Primitive:
							case TypeDescriptorFlags::Struct:
							case TypeDescriptorFlags::FlagEnum:
							case TypeDescriptorFlags::NormalEnum:
								break;
							default:
								manager->errors.Add(WfErrors::NullableToNonReferenceType(node, typeInfo.Obj()));
							}
							break;
						case ITypeInfo::TypeDescriptor:
							if (checkTypeForValue)
							{
								switch (typeInfo->GetTypeDescriptor()->GetTypeDescriptorFlags())
								{
								case TypeDescriptorFlags::Object:
								case TypeDescriptorFlags::Primitive:
								case TypeDescriptorFlags::Struct:
								case TypeDescriptorFlags::FlagEnum:
								case TypeDescriptorFlags::NormalEnum:
									break;
								default:
									manager->errors.Add(WfErrors::TypeNotForValue(node, typeInfo.Obj()));
								}
							}
							break;
						case ITypeInfo::Generic:
							if (checkTypeForValue)
							{
								manager->errors.Add(WfErrors::TypeNotForValue(node, typeInfo.Obj()));
							}
							break;
						}
					}
					return typeInfo;
				}

				void VisitReferenceType(WfType* node)
				{
					if (auto scopeName = GetScopeNameFromReferenceTypeVisitor::Execute(scope, node))
					{
						if (scopeName->typeDescriptor)
						{
							result = Ptr(new TypeDescriptorTypeInfo(scopeName->typeDescriptor, TypeInfoHint::Normal));
						}
						else
						{
							scope->FindManager()->errors.Add(WfErrors::TypeNotExists(node, scopeName));
						}
					}
				}

				void Visit(WfPredefinedType* node)override
				{
					ITypeDescriptor* typeDescriptor = 0;
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						typeDescriptor = description::GetTypeDescriptor<VoidValue>();
						break;
					case WfPredefinedTypeName::Object:
						typeDescriptor = description::GetTypeDescriptor<Value>();
						break;
					case WfPredefinedTypeName::Interface:
						typeDescriptor = description::GetTypeDescriptor<IDescriptable>();
						break;
					case WfPredefinedTypeName::Int:
						typeDescriptor = scope->FindManager()->cputdSInt;
						break;
					case WfPredefinedTypeName::UInt:
						typeDescriptor = scope->FindManager()->cputdUInt;
						break;
					case WfPredefinedTypeName::Float:
						typeDescriptor = description::GetTypeDescriptor<float>();
						break;
					case WfPredefinedTypeName::Double:
						typeDescriptor = description::GetTypeDescriptor<double>();
						break;
					case WfPredefinedTypeName::String:
						typeDescriptor = description::GetTypeDescriptor<WString>();
						break;
					case WfPredefinedTypeName::Char:
						typeDescriptor = description::GetTypeDescriptor<wchar_t>();
						break;
					case WfPredefinedTypeName::Bool:
						typeDescriptor = description::GetTypeDescriptor<bool>();
						break;
					default:
						CHECK_FAIL(L"CreateTypeInfoFromTypeVisitor::Visit(WfPredefinedType*)#Internal error, ValidateTypeStructure function should check correctly.");
					}
					if (typeDescriptor)
					{
						result = Ptr(new TypeDescriptorTypeInfo(typeDescriptor, TypeInfoHint::Normal));
					}
				}

				void Visit(WfTopQualifiedType* node)override
				{
					VisitReferenceType(node);
				}

				void Visit(WfReferenceType* node)override
				{
					VisitReferenceType(node);
				}

				void Visit(WfRawPointerType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						result = Ptr(new RawPtrTypeInfo(element));
					}
				}

				void Visit(WfSharedPointerType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						result = Ptr(new SharedPtrTypeInfo(element));
					}
				}

				void Visit(WfNullableType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), false))
					{
						result = Ptr(new NullableTypeInfo(element));
					}
				}

				void Visit(WfEnumerableType* node)override
				{
					if (Ptr<ITypeInfo> element = Call(node->element.Obj(), true))
					{
						auto enumerableTypeInfo = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueEnumerable>(), TypeInfoHint::Normal));
						auto genericTypeInfo = Ptr(new GenericTypeInfo(enumerableTypeInfo));
						genericTypeInfo->AddGenericArgument(element);
						result = Ptr(new SharedPtrTypeInfo(genericTypeInfo));
					}
				}

				void Visit(WfMapType* node)override
				{
					Ptr<ITypeInfo> key, value;
					if (!(value = Call(node->value.Obj(), true))) return;
					if (node->key)
					{
						if (!(key = Call(node->key.Obj(), true))) return;
					}
					
					ITypeDescriptor* typeDescriptor = nullptr;
					if (node->writability == WfMapWritability::Writable)
					{
						if (node->key)
						{
							typeDescriptor = description::GetTypeDescriptor<IValueDictionary>();
						}
						else
						{
							typeDescriptor = description::GetTypeDescriptor<IValueList>();
						}
					}
					else
					{
						if (node->key)
						{
							typeDescriptor = description::GetTypeDescriptor<IValueReadonlyDictionary>();
						}
						else
						{
							typeDescriptor = description::GetTypeDescriptor<IValueReadonlyList>();
						}
					}

					auto mapTypeInfo = Ptr(new TypeDescriptorTypeInfo(typeDescriptor, TypeInfoHint::Normal));
					auto genericTypeInfo = Ptr(new GenericTypeInfo(mapTypeInfo));
					if (key) genericTypeInfo->AddGenericArgument(key);
					genericTypeInfo->AddGenericArgument(value);
					result = Ptr(new SharedPtrTypeInfo(genericTypeInfo));
				}

				void Visit(WfObservableListType* node)override
				{
					Ptr<ITypeInfo> element;
					if (!(element = Call(node->element.Obj(), true))) return;

					auto typeDescriptor = description::GetTypeDescriptor<IValueObservableList>();
					auto mapTypeInfo = Ptr(new TypeDescriptorTypeInfo(typeDescriptor, TypeInfoHint::Normal));
					auto genericTypeInfo = Ptr(new GenericTypeInfo(mapTypeInfo));
					genericTypeInfo->AddGenericArgument(element);
					result = Ptr(new SharedPtrTypeInfo(genericTypeInfo));
				}

				void Visit(WfFunctionType* node)override
				{
					if (Ptr<ITypeInfo> returnType = Call(node->result.Obj(), true))
					{
						auto enumerableTypeInfo = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueFunctionProxy>(), TypeInfoHint::Normal));
						auto genericTypeInfo = Ptr(new GenericTypeInfo(enumerableTypeInfo));
						genericTypeInfo->AddGenericArgument(returnType);
						for (auto argument : node->arguments)
						{
							if (Ptr<ITypeInfo> argumentType = Call(argument.Obj(), true))
							{
								genericTypeInfo->AddGenericArgument(argumentType);
							}
							else
							{
								return;
							}
						}
						result = Ptr(new SharedPtrTypeInfo(genericTypeInfo));
					}
				}

				void Visit(WfChildType* node)override
				{
					VisitReferenceType(node);
				}

				static Ptr<ITypeInfo> Execute(WfLexicalScope* scope, WfType* type, bool checkTypeForValue)
				{
					return CreateTypeInfoFromTypeVisitor(scope).Call(type, checkTypeForValue);
				}
			};

			Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromType(WfLexicalScope* scope, Ptr<WfType> type, bool checkTypeForValue)
			{
				return CreateTypeInfoFromTypeVisitor::Execute(scope, type.Obj(), checkTypeForValue);
			}

/***********************************************************************
CreateTypeInfoFromType
***********************************************************************/
			
			Ptr<reflection::description::ITypeInfo>	CopyTypeInfoInternal(reflection::description::ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					return Ptr(new RawPtrTypeInfo(CopyTypeInfo(typeInfo->GetElementType())));
				case ITypeInfo::SharedPtr:
					return Ptr(new SharedPtrTypeInfo(CopyTypeInfo(typeInfo->GetElementType())));
				case ITypeInfo::Nullable:
					return Ptr(new NullableTypeInfo(CopyTypeInfo(typeInfo->GetElementType())));
				case ITypeInfo::TypeDescriptor:
					return Ptr(new TypeDescriptorTypeInfo(typeInfo->GetTypeDescriptor(), typeInfo->GetHint()));
				case ITypeInfo::Generic:
				{
					auto impl = Ptr(new GenericTypeInfo(Ptr(typeInfo->GetElementType())));
					vint count = typeInfo->GetGenericArgumentCount();
					for (vint i = 0; i < count; i++)
					{
						impl->AddGenericArgument(CopyTypeInfo(typeInfo->GetGenericArgument(i)));
					}
					return impl;
				}
				default:;
					return nullptr;
				}
			}
			
			Ptr<reflection::description::ITypeInfo>	CopyTypeInfo(reflection::description::ITypeInfo* typeInfo)
			{
				if (!typeInfo) return nullptr;
				return CopyTypeInfoInternal(typeInfo);
			}

/***********************************************************************
CanConvertToType
***********************************************************************/

			bool CanConvertToType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, bool explicitly)
			{
				ITypeDescriptor* objectType = GetTypeDescriptor<Value>();
				bool fromObject = fromType->GetDecorator() == ITypeInfo::TypeDescriptor && fromType->GetTypeDescriptor() == objectType;
				bool toObject = toType->GetDecorator() == ITypeInfo::TypeDescriptor && toType->GetTypeDescriptor() == objectType;

				if (fromObject && toObject)
				{
					return true;
				}
				else if (fromObject)
				{
					return explicitly;
				}
				else if (toObject)
				{
					return true;
				}

				switch (fromType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::SharedPtr:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::SharedPtr:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::SharedPtr:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::Nullable:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
						return false;
					case ITypeInfo::Nullable:
						return CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly);
					case ITypeInfo::TypeDescriptor:
						return explicitly && CanConvertToType(fromType->GetElementType(), toType, explicitly);
					case ITypeInfo::Generic:
						return false;
					}
					break;
				case ITypeInfo::TypeDescriptor:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
						return false;
					case ITypeInfo::Nullable:
						return CanConvertToType(fromType, toType->GetElementType(), explicitly);
					case ITypeInfo::TypeDescriptor:
						{
							ITypeDescriptor* fromTd = fromType->GetTypeDescriptor();
							ITypeDescriptor* toTd = toType->GetTypeDescriptor();
							bool fromValue = (fromTd->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) == TypeDescriptorFlags::Undefined;
							bool toValue = (toTd->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) == TypeDescriptorFlags::Undefined;
							if (fromValue != toValue)
							{
								return false;
							}

							if (fromValue)
							{
								if (fromTd == toTd)
								{
									return true;
								}
								else if (fromTd == GetTypeDescriptor<WString>())
								{
									return explicitly && toTd->GetSerializableType() != nullptr;
								}
								else if (toTd == GetTypeDescriptor<WString>())
								{
									return fromTd->GetSerializableType() != nullptr;
								}

								TypeFlag fromFlag = GetTypeFlag(fromTd);
								TypeFlag toFlag = GetTypeFlag(toTd);
								static vint conversionTable[(vint)TypeFlag::Count][(vint)TypeFlag::Count] = {
									/*Bool		*/{1, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 0, /**/ 0, 0, /**/ 1, 0, 0, 0},
									//-------------------------------------------------------------------------------
									/*I1		*/{0, /**/ 1, 1, 1, 1, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0, 0, 0},
									/*I2		*/{0, /**/ 2, 1, 1, 1, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0, 0, 0},
									/*I4		*/{0, /**/ 2, 2, 1, 1, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0, 0, 0},
									/*I8		*/{0, /**/ 2, 2, 2, 1, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0, 0, 0},
									//-------------------------------------------------------------------------------
									/*U1		*/{0, /**/ 2, 2, 2, 2, /**/ 1, 1, 1, 1, /**/ 1, 1, /**/ 1, 0, 0, 0},
									/*U2		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 1, 1, 1, /**/ 1, 1, /**/ 1, 0, 0, 0},
									/*U4		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 1, 1, /**/ 2, 1, /**/ 1, 0, 0, 0},
									/*U8		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 1, /**/ 2, 1, /**/ 1, 2, 0, 0},
									//-------------------------------------------------------------------------------
									/*F4		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 1, 1, /**/ 1, 0, 0, 0},
									/*F8		*/{0, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 2, 1, /**/ 1, 0, 0, 0},
									//-------------------------------------------------------------------------------
									/*String	*/{2, /**/ 2, 2, 2, 2, /**/ 2, 2, 2, 2, /**/ 2, 2, /**/ 1, 0, 0, 0},
									/*Enum		*/{0, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 2, /**/ 0, 0, /**/ 0, 0, 0, 0},
									/*Struct	*/{0, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 0, /**/ 0, 0, /**/ 0, 0, 0, 0},
									/*Others	*/{0, /**/ 0, 0, 0, 0, /**/ 0, 0, 0, 0, /**/ 0, 0, /**/ 0, 0, 0, 0},
								};
								vint conversion = conversionTable[(vint)fromFlag][(vint)toFlag];
								return conversion == 1 || (explicitly && conversion == 2);
							}
							else
							{
								if (fromTd->CanConvertTo(toTd))
								{
									return true;
								}
								if (explicitly && toTd->CanConvertTo(fromTd))
								{
									return true;
								}
							}
						}
						break;
					case ITypeInfo::Generic:
						return explicitly && CanConvertToType(fromType, toType->GetElementType(), explicitly);
					}
					break;
				case ITypeInfo::Generic:
					switch (toType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
					case ITypeInfo::SharedPtr:
					case ITypeInfo::Nullable:
						return false;
					case ITypeInfo::TypeDescriptor:
						return CanConvertToType(fromType->GetElementType(), toType, explicitly);
					case ITypeInfo::Generic:
						if (explicitly) return true;
						if (fromType->GetGenericArgumentCount() != toType->GetGenericArgumentCount())
						{
							return false;
						}
						if (!CanConvertToType(fromType->GetElementType(), toType->GetElementType(), explicitly)) return false;
						for (vint i = 0; i < fromType->GetGenericArgumentCount(); i++)
						{
							if (!IsSameType(fromType->GetGenericArgument(i), toType->GetGenericArgument(i)))
							{
								return false;
							}
						}
						return true;
					}
					break;
				}
				return false;
			}

/***********************************************************************
IsSameType
***********************************************************************/

			bool IsSameType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType)
			{
				if (fromType->GetDecorator() != toType->GetDecorator())
				{
					return false;
				}
				switch (fromType->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					return IsSameType(fromType->GetElementType(), toType->GetElementType());
				case ITypeInfo::TypeDescriptor:
					return fromType->GetTypeDescriptor() == toType->GetTypeDescriptor();
				case ITypeInfo::Generic:
					if (fromType->GetGenericArgumentCount() != toType->GetGenericArgumentCount())
					{
						return false;
					}
					if (!IsSameType(fromType->GetElementType(), toType->GetElementType())) return false;
					for (vint i = 0; i < fromType->GetGenericArgumentCount(); i++)
					{
						if (!IsSameType(fromType->GetGenericArgument(i), toType->GetGenericArgument(i)))
						{
							return false;
						}
					}
					return true;
				}
				return false;
			}

/***********************************************************************
GetMergedType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo>	GetMergedType(Ptr<reflection::description::ITypeInfo> firstType, Ptr<reflection::description::ITypeInfo> secondType)
			{
				if (CanConvertToType(secondType.Obj(), firstType.Obj(), false))
				{
					return firstType;
				}
				else if (CanConvertToType(firstType.Obj(), secondType.Obj(), false))
				{
					return secondType;
				}
				else
				{
					return 0;
				}
			}

/***********************************************************************
IsNullAcceptableType
***********************************************************************/

			bool IsNullAcceptableType(reflection::description::ITypeInfo* type)
			{
				switch (type->GetDecorator())
				{
				case ITypeInfo::RawPtr:
				case ITypeInfo::SharedPtr:
				case ITypeInfo::Nullable:
					return true;
				case ITypeInfo::TypeDescriptor:
					return type->GetTypeDescriptor() == description::GetTypeDescriptor<Value>();
				case ITypeInfo::Generic:
					return false;
				}
				return false;
			}

/***********************************************************************
CreateTypeInfoFromMethodInfo
***********************************************************************/

			Ptr<reflection::description::ITypeInfo> CreateTypeInfoFromMethodInfo(reflection::description::IMethodInfo* info)
			{
				auto elementType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueFunctionProxy>(), TypeInfoHint::Normal));
				auto genericType = Ptr(new GenericTypeInfo(elementType));
				genericType->AddGenericArgument(CopyTypeInfo(info->GetReturn()));
				vint parameterCount = info->GetParameterCount();
				for (vint j = 0; j < parameterCount; j++)
				{
					genericType->AddGenericArgument(CopyTypeInfo(info->GetParameter(j)->GetType()));
				}
				return Ptr(new SharedPtrTypeInfo(genericType));
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESCOPENAME.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{

/***********************************************************************
ValidateScopeName
***********************************************************************/

			class ValidateScopeNameDeclarationVisitor
				: public Object
				, public WfDeclaration::IVisitor
				, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				enum Category
				{
					None,
					Type,
					Variable,
					Function,
					Namespace,
				};

				WfLexicalScopeManager*				manager;
				Ptr<WfLexicalScopeName>				name;
				Category							category;

				ValidateScopeNameDeclarationVisitor(WfLexicalScopeManager* _manager, Ptr<WfLexicalScopeName> _name)
					:manager(_manager)
					, name(_name)
					, category(name->typeDescriptor && name->imported ? Type : None)
				{
				}

				void AddError(WfDeclaration* node)
				{
					WString categoryName;
					switch (category)
					{
					case Type:
						categoryName = L"type";
						break;
					case Variable:
						categoryName = L"variable";
						break;
					case Function:
						categoryName = L"function";
						break;
					case Namespace:
						categoryName = L"namespace";
						break;
					default:
						CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::AddError(WfDeclaration*)#Internal error.");
					}
					manager->errors.Add(WfErrors::DuplicatedDeclaration(node, categoryName));
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					if (category == None)
					{
						category = Namespace;
					}
					else if (category != Namespace)
					{
						AddError(node);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (category == None)
					{
						category = Function;
					}
					else if (category != Function)
					{
						AddError(node);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					if (category == None)
					{
						category = Variable;
					}
					else
					{
						AddError(node);
					}
				}

				void Visit(WfEventDeclaration* node)override
				{
					CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::Visit(WfEventDeclaration*)#Internal error, ValidateDeclarationStructure function should check correctly.");
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::Visit(WfPropertyDeclaration*)#Internal error, ValidateDeclarationStructure function should check correctly.");
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::Visit(WfConstructorDeclaration*)#Internal error, ValidateDeclarationStructure function should check correctly.");
				}
				
				void Visit(WfDestructorDeclaration* node)override
				{
					CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::Visit(WfDestructorDeclaration*)#Internal error, ValidateDeclarationStructure function should check correctly.");
				}

				void Visit(WfClassDeclaration* node)override
				{
					if (category == None)
					{
						category = Type;
					}
					else
					{
						AddError(node);
					}
				}

				void Visit(WfEnumDeclaration* node)override
				{
					if (category == None)
					{
						category = Type;
					}
					else
					{
						AddError(node);
					}
				}

				void Visit(WfStructDeclaration* node)override
				{
					if (category == None)
					{
						category = Type;
					}
					else
					{
						AddError(node);
					}
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
					CHECK_FAIL(L"ValidateScopeNameDeclarationVisitor::Visit(WfStateMachineDeclaration*)#Internal error, ValidateDeclarationStructure function should check correctly.");
				}
			};

			void ValidateScopeName(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name)
			{
				ValidateScopeNameDeclarationVisitor visitor(manager, name);
				for (auto declaration : name->declarations)
				{
					declaration->Accept(&visitor);
				}

				for (auto child : name->children.Values())
				{
					ValidateScopeName(manager, child);
				}
			}
		}
	}
}

/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESEMANTIC.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
Helper Functions
***********************************************************************/

			IMethodInfo* FindInterfaceConstructor(ITypeDescriptor* type)
			{
				if (auto ctors = type->GetConstructorGroup())
				{
					auto proxyTd = description::GetTypeDescriptor<IValueInterfaceProxy>();
					for (vint i = 0; i < ctors->GetMethodCount(); i++)
					{
						IMethodInfo* info = ctors->GetMethod(i);
						if (info->GetParameterCount() == 1)
						{
							ITypeInfo* parameterType = info->GetParameter(0)->GetType();
							if (parameterType->GetDecorator() == ITypeInfo::SharedPtr)
							{
								parameterType = parameterType->GetElementType();
								if (parameterType->GetDecorator() == ITypeInfo::TypeDescriptor && parameterType->GetTypeDescriptor() == proxyTd)
								{
									return info;
								}
							}
						}
					}
				}
				return nullptr;
			}

			ITypeInfo* GetFunctionType(const ResolveExpressionResult& result)
			{
				if (result.eventInfo)
				{
					return result.eventInfo->GetHandlerType();
				}
				else if (result.type)
				{
					return result.type.Obj();
				}
				else
				{
					return nullptr;
				}
			}

			Ptr<ITypeInfo> SelectFunction(WfLexicalScopeManager* manager, glr::ParsingAstBase* node, Ptr<WfExpression> functionExpression, List<ResolveExpressionResult>& functions, List<Ptr<WfExpression>>& arguments, vint& selectedFunctionIndex)
			{
				selectedFunctionIndex = -1;

				List<bool> resolvables;
				List<Ptr<ITypeInfo>> types;
				for (auto argument : arguments)
				{
					if (!argument || IsExpressionDependOnExpectedType(manager, argument, true))
					{
						resolvables.Add(false);
						types.Add(nullptr);
					}
					else
					{
						resolvables.Add(true);
						types.Add(GetExpressionType(manager, argument, nullptr));
					}
				}

				List<glr::ParsingError> functionErrors, nonFunctionErrors;
				List<Pair<vint, vint>> selectedFunctionIndices;
				ITypeDescriptor* functionFd = description::GetTypeDescriptor<IValueFunctionProxy>();
				for (vint i = 0; i < functions.Count(); i++)
				{
					bool failed = false;
					vint convertCount = 0;
					auto result = functions[i];
					ITypeInfo* expressionType = GetFunctionType(result);

					if (expressionType->GetDecorator() == ITypeInfo::SharedPtr)
					{
						ITypeInfo* genericType = expressionType->GetElementType();
						if (genericType->GetDecorator() != ITypeInfo::Generic) goto FUNCTION_TYPE_FAILED;
						ITypeInfo* functionType = genericType->GetElementType();
						if (functionType->GetDecorator() != ITypeInfo::TypeDescriptor || functionType->GetTypeDescriptor() != functionFd) goto FUNCTION_TYPE_FAILED;
								
						if (genericType->GetGenericArgumentCount() != types.Count() + 1)
						{
							functionErrors.Add(WfErrors::FunctionArgumentCountMismatched(node, arguments.Count(), result));
							failed = true;
						}
						else
						{
							for (vint j = 0; j < types.Count(); j++)
							{
								if (resolvables[j] && types[j])
								{
									ITypeInfo* argumentType = genericType->GetGenericArgument(j + 1);
									if (CanConvertToType(types[j].Obj(), argumentType, false))
									{
										if (!IsSameType(types[j].Obj(), argumentType))
										{
											convertCount++;
										}
									}
									else
									{
										functionErrors.Add(WfErrors::FunctionArgumentTypeMismatched(node, result, j + 1, types[j].Obj(), argumentType));
										failed = true;
									}
								}
							}
						}
					}
					else
					{
						goto FUNCTION_TYPE_FAILED;
					}

					goto FUNCTION_TYPE_FINISHED;
				FUNCTION_TYPE_FAILED:
					nonFunctionErrors.Add(WfErrors::ExpressionIsNotFunction(functionExpression.Obj(), result.type.Obj()));
					failed = true;
				FUNCTION_TYPE_FINISHED:
					if (!failed)
					{
						selectedFunctionIndices.Add({ i,convertCount });
					}
				}

				if (selectedFunctionIndices.Count() > 1)
				{
					vint minScore = From(selectedFunctionIndices)
						.Select([](Pair<vint, vint> p)
						{
							return p.value;
						})
						.Min();

					for (vint i = selectedFunctionIndices.Count() - 1; i >= 0; i--)
					{
						if (selectedFunctionIndices[i].value != minScore)
						{
							selectedFunctionIndices.RemoveAt(i);
						}
					}
				}

				if (selectedFunctionIndices.Count() == 1)
				{
					selectedFunctionIndex = selectedFunctionIndices[0].key;
					ITypeInfo* genericType = GetFunctionType(functions[selectedFunctionIndex])->GetElementType();
					for (vint i = 0; i < types.Count(); i++)
					{
						ITypeInfo* argumentType = genericType->GetGenericArgument(i + 1);
						if (resolvables[i])
						{
							vint index = manager->expressionResolvings.Keys().IndexOf(arguments[i].Obj());
							if (index != -1)
							{
								auto resolvingResult = manager->expressionResolvings.Values()[index];
								CHECK_ERROR(resolvingResult.expectedType == nullptr, L"GetExpressionType should not set expectedType if it is null");
								resolvingResult.expectedType = CopyTypeInfo(argumentType);
								manager->expressionResolvings.Set(arguments[i], resolvingResult);
							}
						}
						else
						{
							if (arguments[i])
							{
								GetExpressionType(manager, arguments[i], CopyTypeInfo(argumentType));
							}
						}
					}
					return CopyTypeInfo(genericType->GetGenericArgument(0));
				}
				else
				{
					if (selectedFunctionIndices.Count() > 1)
					{
						List<ResolveExpressionResult> overloadedFunctions;
						CopyFrom(
							overloadedFunctions,
							From(selectedFunctionIndices)
							.Select([&functions](Pair<vint, vint> p)
							{
								return functions[p.key];
							}));
						manager->errors.Add(WfErrors::CannotPickOverloadedFunctions(node, overloadedFunctions));
					}

					if (functionErrors.Count() > 0)
					{
						CopyFrom(manager->errors, functionErrors, true);
					}
					else
					{
						CopyFrom(manager->errors, nonFunctionErrors, true);
					}
					return nullptr;
				}
			}

/***********************************************************************
ValidateSemantic
***********************************************************************/
			
			void ValidateModuleSemantic(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				for (auto declaration : module->declarations)
				{
					ValidateDeclarationSemantic(manager, declaration);
				}
			}

/***********************************************************************
GetExpressionScopeName
***********************************************************************/

			Ptr<WfLexicalScopeName> GetExpressionScopeName(WfLexicalScopeManager* manager, WfExpression* expression)
			{
				List<ResolveExpressionResult> results;
				ValidateExpressionSemantic(manager, expression, 0, results);
				if (results.Count() == 0) return 0;

				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (!result.scopeName)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					manager->errors.Add(WfErrors::ExpressionIsNotScopeName(expression));
					return 0;
				}
				else if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression, results, GetExpressionName(expression)));
					return 0;
				}

				auto result = results[0];
				manager->expressionResolvings.Add(Ptr(expression), result);
				return result.scopeName;
			}

			Ptr<WfLexicalScopeName> GetExpressionScopeName(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				return GetExpressionScopeName(manager, expression.Obj());
			}

/***********************************************************************
GetExpressionEventInfo
***********************************************************************/

			reflection::description::IEventInfo* GetExpressionEventInfo(WfLexicalScopeManager* manager, WfExpression* expression)
			{
				List<ResolveExpressionResult> results;
				ValidateExpressionSemantic(manager, expression, 0, results);
				if (results.Count() == 0) return 0;

				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (!result.eventInfo)
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					manager->errors.Add(WfErrors::ExpressionIsNotEvent(expression));
					return 0;
				}
				else if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression, results, GetExpressionName(expression)));
					return 0;
				}

				auto result = results[0];
				manager->expressionResolvings.Add(Ptr(expression), result);
				return result.eventInfo;
			}

			reflection::description::IEventInfo* GetExpressionEventInfo(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				return GetExpressionEventInfo(manager, expression.Obj());
			}

/***********************************************************************
GetExpressionTypes
***********************************************************************/

			void GetExpressionTypes(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType, bool allowEvent, collections::List<ResolveExpressionResult>& results)
			{
				ValidateExpressionSemantic(manager, expression, expectedType, results);
				if (results.Count() == 0) return;

				Ptr<WfLexicalScopeName> scopeName;
				IEventInfo* eventInfo = 0;
				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto& result = results[i];
					if (result.scopeName && !scopeName)
					{
						scopeName = result.scopeName;
					}
					if (result.eventInfo && !eventInfo)
					{
						eventInfo = result.eventInfo;
					}
					if (!result.type && !(allowEvent && eventInfo))
					{
						results.RemoveAt(i);
					}
				}
				if (results.Count() == 0)
				{
					if (scopeName)
					{
						manager->errors.Add(WfErrors::ScopeNameIsNotExpression(expression, scopeName));
					}
					if (eventInfo)
					{
						manager->errors.Add(WfErrors::EventIsNotExpression(expression, eventInfo));
					}
				}

				if (expectedType)
				{
					List<Ptr<ITypeInfo>> failedTypes;
					for (vint i = results.Count() - 1; i >= 0; i--)
					{
						auto& result = results[i];
						if (!CanConvertToType(result.type.Obj(), expectedType.Obj(), false))
						{
							failedTypes.Add(result.type);
							results.RemoveAt(i);
						}
					}

					if (results.Count() == 0)
					{
						for (auto type : failedTypes)
						{
							manager->errors.Add(WfErrors::ExpressionCannotImplicitlyConvertToType(expression, type.Obj(), expectedType.Obj()));
						}
					}
				}
			}

			void GetExpressionTypes(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, bool allowEvent, collections::List<ResolveExpressionResult>& results)
			{
				return GetExpressionTypes(manager, expression.Obj(), expectedType, allowEvent, results);
			}

/***********************************************************************
GetExpressionType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo> GetExpressionType(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				List<ResolveExpressionResult> results;
				GetExpressionTypes(manager, expression, expectedType, false, results);
				
				if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression, results, GetExpressionName(expression)));
					return expectedType;
				}
				else if (results.Count() == 1)
				{
					auto result = results[0];
					result.expectedType = expectedType;
					manager->expressionResolvings.Add(Ptr(expression), result);
					return expectedType ? expectedType : result.type;
				}
				else
				{
					return expectedType;
				}
			}

			Ptr<reflection::description::ITypeInfo> GetExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				return GetExpressionType(manager, expression.Obj(), expectedType);
			}

/***********************************************************************
GetLeftValueExpressionType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, WfExpression* expression)
			{
				List<ResolveExpressionResult> results;
				GetExpressionTypes(manager, expression, nullptr, false, results);

				if (results.Count() > 1)
				{
					manager->errors.Add(WfErrors::TooManyTargets(expression, results, GetExpressionName(expression)));
				}
				else if (results.Count() == 1)
				{
					if (results[0].writableType)
					{
						auto result = results[0];
						manager->expressionResolvings.Add(Ptr(expression), result);
						return result.writableType;
					}
					else
					{
						manager->errors.Add(WfErrors::ExpressionIsNotLeftValue(expression, results[0]));
					}
				}
				return nullptr;
			}

			Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression)
			{
				return GetLeftValueExpressionType(manager, expression.Obj());
			}

/***********************************************************************
GetEnumerableExpressionItemType
***********************************************************************/

			Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				Ptr<ITypeInfo> collectionType = GetExpressionType(manager, expression, expectedType);
				if (collectionType)
				{
					if (collectionType->GetTypeDescriptor()->CanConvertTo(description::GetTypeDescriptor<IValueEnumerable>()))
					{
						if (collectionType->GetDecorator() == ITypeInfo::SharedPtr)
						{
							ITypeInfo* genericType = collectionType->GetElementType();
							if (genericType->GetDecorator() == ITypeInfo::Generic && genericType->GetGenericArgumentCount() == 1)
							{
								return CopyTypeInfo(genericType->GetGenericArgument(0));
							}
						}
						return TypeInfoRetriver<Value>::CreateTypeInfo();
					}

					manager->errors.Add(WfErrors::ExpressionIsNotCollection(expression, collectionType.Obj()));
				}
				return nullptr;
			}

			Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				return GetEnumerableExpressionItemType(manager, expression.Obj(), expectedType);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESEMANTIC_DECLARATION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
ValidateSemantic(ClassMember)
***********************************************************************/

			class ValidateSemanticClassMemberVisitor
				: public Object
				, public WfDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				Ptr<WfCustomType>					td;
				WfClassDeclaration*					classDecl;

				ValidateSemanticClassMemberVisitor(Ptr<WfCustomType> _td, WfClassDeclaration* _classDecl, WfLexicalScopeManager* _manager)
					:td(_td)
					, classDecl(_classDecl)
					, manager(_manager)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				void Visit(WfEventDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				void Visit(WfPropertyDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);

					auto scope = manager->nodeScopes[node];
					if (auto typeInfo = CreateTypeInfoFromType(scope.Obj(), node->type))
					{
						if (node->getter.value != L"")
						{
							auto getter = td->GetMethodGroupByName(node->getter.value, false)->GetMethod(0);
							if (!IsSameType(typeInfo.Obj(), getter->GetReturn()) || getter->GetParameterCount() != 0)
							{
								manager->errors.Add(WfErrors::PropertyGetterTypeMismatched(node, classDecl));
							}
						}

						if (node->setter.value != L"")
						{
							auto setter = td->GetMethodGroupByName(node->setter.value, false)->GetMethod(0);
							if (setter->GetReturn()->GetTypeDescriptor() != description::GetTypeDescriptor<void>() || setter->GetParameterCount() != 1 || !IsSameType(typeInfo.Obj(), setter->GetParameter(0)->GetType()))
							{
								manager->errors.Add(WfErrors::PropertySetterTypeMismatched(node, classDecl));
							}
						}
					}
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				static void SelectConstructor(WfLexicalScopeManager* manager, WfConstructorDeclaration* ctorDecl, glr::ParsingAstBase* node, ITypeDescriptor* td, List<Ptr<WfExpression>>& arguments)
				{
					List<ResolveExpressionResult> functions;
					if (auto ctors = td->GetConstructorGroup())
					{
						vint count = ctors->GetMethodCount();
						for (vint i = 0; i < count; i++)
						{
							auto ctor = ctors->GetMethod(i);
							functions.Add(ResolveExpressionResult::Method(ctor));
						}
					}

					vint selectedFunctionIndex = -1;
					SelectFunction(manager, node, nullptr, functions, arguments, selectedFunctionIndex);
					if (selectedFunctionIndex != -1)
					{
						auto ctor = functions[selectedFunctionIndex].methodInfo;
						auto call = dynamic_cast<WfBaseConstructorCall*>(node);
						manager->baseConstructorCallResolvings.Add({ctorDecl, td}, {call, ctor});
					}
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);

					auto scope = manager->nodeScopes[node].Obj();
					auto classScope = scope->parentScope.Obj();
					SortedList<ITypeDescriptor*> baseTypes, initTypes;
					{
						auto td = classScope->typeOfThisExpr;
						vint count = td->GetBaseTypeDescriptorCount();
						for (vint i = 0; i < count; i++)
						{
							auto baseTd = td->GetBaseTypeDescriptor(i);
							if (!baseTypes.Contains(baseTd))
							{
								baseTypes.Add(baseTd);
							}
						}
					}

					for (auto call : node->baseConstructorCalls)
					{
						if (auto scopeName = GetScopeNameFromReferenceType(classScope, call->type))
						{
							if (auto td = scopeName->typeDescriptor)
							{
								if (initTypes.Contains(td))
								{
									manager->errors.Add(WfErrors::DuplicatedBaseConstructorCall(call.Obj(), td));
								}
								else if (baseTypes.Contains(td))
								{
									initTypes.Add(td);
									SelectConstructor(manager, node, call.Obj(), td, call->arguments);
								}
								else
								{
									manager->errors.Add(WfErrors::WrongBaseConstructorCall(call.Obj(), td));
								}
							}
						}
					}

					{
						vint index = -1;
						for (vint i = 0; i < initTypes.Count(); i++)
						{
							while (baseTypes[++index] != initTypes[i])
							{
								auto td = baseTypes[index];
								List<Ptr<WfExpression>> arguments;
								SelectConstructor(manager, node, node, td, arguments);
							}
						}
						while (++index < baseTypes.Count())
						{
							auto td = baseTypes[index];
							List<Ptr<WfExpression>> arguments;
							SelectConstructor(manager, node, node, td, arguments);
						}
					}

					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfDestructorDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfClassDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				void Visit(WfEnumDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				void Visit(WfStructDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					ValidateDeclarationSemantic(manager, node);
				}

				static void Execute(Ptr<WfCustomType> td, WfClassDeclaration* classDecl, Ptr<WfDeclaration> memberDecl, WfLexicalScopeManager* manager)
				{
					ValidateSemanticClassMemberVisitor visitor(td, classDecl, manager);
					memberDecl->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic(Declaration)
***********************************************************************/

			class ExpandVirtualDeclarationVisitor : public Object, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ExpandVirtualDeclarationVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
					ExpandStateMachine(manager, node);
				}
			};

			class ValidateSemanticDeclarationVisitor
				: public Object
				, public WfDeclaration::IVisitor
				, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ValidateSemanticDeclarationVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(List<Ptr<WfAttribute>>& attributes)
				{
					for (auto attribute : attributes)
					{
						auto key = Pair<WString, WString>(attribute->category.value, attribute->name.value);
						vint index = manager->attributes.Keys().IndexOf(key);
						if (index == -1)
						{
							manager->errors.Add(WfErrors::AttributeNotExists(attribute.Obj()));
						}
						else
						{
							auto expectedType = manager->attributes.Values()[index];
							if (attribute->value)
							{
								ValidateConstantExpression(manager, attribute->value, expectedType);
							}
							else if (expectedType->GetTypeDescriptor() != description::GetTypeDescriptor<void>())
							{
								manager->errors.Add(WfErrors::AttributeMissValue(attribute.Obj()));
							}
						}
					}
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					for (auto declaration : node->declarations)
					{
						ValidateDeclarationSemantic(manager, declaration);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (node->statement)
					{
						ValidateStatementSemantic(manager, node->statement);
					}
					for (auto argument : node->arguments)
					{
						Visit(argument->attributes);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto symbol = scope->symbols[node->name.value][0];
					symbol->typeInfo = GetExpressionType(manager, node->expression, symbol->typeInfo);
					if (symbol->typeInfo && !symbol->type)
					{
						symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
					}
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfConstructorDeclaration* node)override
				{
				}

				void Visit(WfDestructorDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto td = manager->declarationTypes[node].Cast<WfCustomType>();

					if (node->kind == WfClassKind::Interface)
					{
						for (auto baseType : node->baseTypes)
						{
							auto scopeName = GetScopeNameFromReferenceType(scope->parentScope.Obj(), baseType);
							auto baseTd = scopeName->typeDescriptor;
							auto ctor = FindInterfaceConstructor(baseTd);
							if (ctor == nullptr)
							{
								manager->errors.Add(WfErrors::WrongInterfaceBaseType(node, baseTd));
							}
						}
					}

					if (auto sm = From(node->declarations)
						.FindType<WfStateMachineDeclaration>()
						.First(nullptr)
						)
					{
						auto smtd = description::GetTypeDescriptor<StateMachine>();
						vint count = td->GetBaseTypeDescriptorCount();

						auto smbc = Range<vint>(0, count)
							.Select([=](vint index) {return td->GetBaseTypeDescriptor(index); })
							.Where([=](ITypeDescriptor* td) {return td == smtd; })
							.First(nullptr);
						if (!smbc)
						{
							manager->errors.Add(WfErrors::StateMachineClassNotInheritFromStateMachine(node));
						}
					}

					for (auto memberDecl : node->declarations)
					{
						ValidateClassMemberSemantic(manager, td, node, memberDecl);
					}
				}

				void Visit(WfEnumDeclaration* node)override
				{
					for (auto item : node->items)
					{
						Visit(item->attributes);
					}
				}

				void Visit(WfStructDeclaration* node)override
				{
					auto scope = manager->nodeScopes[node];
					auto td = manager->declarationTypes[node].Cast<WfStruct>();
					for (auto member : node->members)
					{
						auto memberTd = td->GetPropertyByName(member->name.value, false)->GetReturn()->GetTypeDescriptor();
						if ((memberTd->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined)
						{
							manager->errors.Add(WfErrors::StructContainsNonValueType(member.Obj(), node));
						}
					}

					for (auto member : node->members)
					{
						Visit(member->attributes);
					}
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						ValidateDeclarationSemantic(manager, decl);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					bool expanded = node->expandedDeclarations.Count() > 0;
					vint errorCount = manager->errors.Count();
					node->Accept((WfVirtualCseDeclaration::IVisitor*)this);

					if (!expanded && manager->errors.Count() == errorCount)
					{
						ExpandVirtualDeclarationVisitor visitor(manager);
						node->Accept(&visitor);

						for (auto decl : node->expandedDeclarations)
						{
							SetCodeRange(decl, node->codeRange);
						}

						auto parentScope = manager->nodeScopes[node];
						if (parentScope->ownerNode == node)
						{
							parentScope = parentScope->parentScope;
						}

						for (auto decl : node->expandedDeclarations)
						{
							ContextFreeDeclarationDesugar(manager, decl);
						}
						for (auto decl : node->expandedDeclarations)
						{
							BuildScopeForDeclaration(manager, parentScope, decl, manager->declaractionScopeSources[node]);
						}

						manager->checkedScopes_DuplicatedSymbol.Remove(parentScope.Obj());
						manager->checkedScopes_SymbolType.Remove(parentScope.Obj());
						if (!CheckScopes_DuplicatedSymbol(manager) || !CheckScopes_SymbolType(manager))
						{
							return;
						}
					}

					for (auto decl : node->expandedDeclarations)
					{
						ValidateDeclarationSemantic(manager, decl);
					}
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
					bool foundDefaultState = false;

					for (auto state : node->states)
					{
						if (state->name.value == L"")
						{
							foundDefaultState = true;
						}
						ValidateStatementSemantic(manager, state->statement);
					}

					if (!foundDefaultState)
					{
						manager->errors.Add(WfErrors::MissingDefaultState(node));
					}
				}

				static void Execute(WfDeclaration* declaration, WfLexicalScopeManager* manager)
				{
					ValidateSemanticDeclarationVisitor visitor(manager);
					declaration->Accept(&visitor);
					visitor.Visit(declaration->attributes);
				}
			};

/***********************************************************************
ValidateSemantic
***********************************************************************/

			void ValidateClassMemberSemantic(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, WfClassDeclaration* classDecl, Ptr<WfDeclaration> memberDecl)
			{
				return ValidateSemanticClassMemberVisitor::Execute(td, classDecl, memberDecl, manager);
			}

			void ValidateDeclarationSemantic(WfLexicalScopeManager* manager, WfDeclaration* declaration)
			{
				return ValidateSemanticDeclarationVisitor::Execute(declaration, manager);
			}

			void ValidateDeclarationSemantic(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration)
			{
				return ValidateSemanticDeclarationVisitor::Execute(declaration.Obj(), manager);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESEMANTIC_EXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
ValidateSemantic(Expression)
***********************************************************************/

			class ExpandVirtualExpressionVisitor : public Object, public WfVirtualCseExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				Ptr<ITypeInfo>						expectedType;

				ExpandVirtualExpressionVisitor(WfLexicalScopeManager* _manager, Ptr<ITypeInfo> _expectedType)
					:manager(_manager)
					, expectedType(_expectedType)
				{
				}

				void Visit(WfBindExpression* node)override
				{
					ExpandBindExpression(manager, node);
				}

				void Visit(WfNewCoroutineExpression* node)override
				{
					ExpandNewCoroutineExpression(manager, node);
				}

				void Visit(WfMixinCastExpression* node)override
				{
					ExpandMixinCastExpression(manager, node);
				}

				void Visit(WfExpectedTypeCastExpression* node)override
				{
					auto castExpr = Ptr(new WfTypeCastingExpression);
					castExpr->strategy = node->strategy;
					castExpr->expression = CopyExpression(node->expression, true);
					castExpr->type = GetTypeFromTypeInfo(expectedType.Obj());
					node->expandedExpression = castExpr;
				}

				void Visit(WfCoOperatorExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					auto functionScope = scope->FindFunctionScope();
					if (functionScope->ownerNode.Cast<WfNewCoroutineExpression>())
					{
						// <co-impl> variable is created after $coroutine{} is generated
						// so the expanding is delayed until $coroutine{} is ready
						ExpandCoOperatorExpression(manager, node);
					}
				}
			};

			class ValidateSemanticExpressionVisitor
				: public Object
				, public WfExpression::IVisitor
				, public WfVirtualCseExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				Ptr<ITypeInfo>						expectedType;
				List<ResolveExpressionResult>&		results;

				ValidateSemanticExpressionVisitor(WfLexicalScopeManager* _manager, Ptr<ITypeInfo> _expectedType, List<ResolveExpressionResult>& _results)
					:manager(_manager)
					, expectedType(_expectedType)
					, results(_results)
				{
				}

				void Visit(WfThisExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					Ptr<WfLexicalFunctionConfig> lastConfig;
					while (scope)
					{
						if (auto config = scope->functionConfig)
						{
							lastConfig = config;
							if (!lastConfig->thisAccessable)
							{
								break;
							}
						}

						if (scope->typeOfThisExpr)
						{
							if (!lastConfig)
							{
								break;
							}

							if (lastConfig->thisAccessable)
							{
								auto elementType = Ptr(new TypeDescriptorTypeInfo(scope->typeOfThisExpr, TypeInfoHint::Normal));
								auto pointerType = Ptr(new RawPtrTypeInfo(elementType));

								results.Add(ResolveExpressionResult::ReadonlyType(pointerType));
								return;
							}
						}
						scope = scope->parentScope.Obj();
					}
					manager->errors.Add(WfErrors::WrongThisExpression(node));
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					if (manager->globalName)
					{
						vint index = manager->globalName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							results.Add(ResolveExpressionResult::ScopeName(manager->globalName->children.Values()[index]));
							return;
						}
					}
					manager->errors.Add(WfErrors::TopQualifiedSymbolNotExists(node, node->name.value));
				}

				void ResolveName(WfExpression* node, const WString& name)
				{
					auto scope = manager->nodeScopes[node].Obj();
					List<ResolveExpressionResult> nameResults;
					manager->ResolveName(scope, name, nameResults);
					
					for (vint i = 0; i < nameResults.Count(); i++)
					{
						auto& result = nameResults[i];
						if (result.symbol)
						{
							if (!result.type)
							{
								manager->errors.Add(WfErrors::ExpressionCannotResolveType(node, result.symbol));
							}
							else if (!result.symbol->creatorNode.Cast<WfDeclaration>() || result.symbol->creatorNode.Cast<WfVariableDeclaration>())
							{
								bool readonlyCaptured = false;
								if (!result.symbol->ownerScope->ownerNode.Cast<WfModule>() && !result.symbol->ownerScope->ownerNode.Cast<WfNamespaceDeclaration>())
								{
									auto currentScope = scope;
									WfLexicalScope* firstConfigScope = nullptr;
									WfLexicalScope* lastConfigScope = nullptr;
									while (currentScope)
									{
										if (currentScope->functionConfig)
										{
											if (!firstConfigScope)
											{
												firstConfigScope = currentScope;
											}
											lastConfigScope = currentScope;
										}

										if (result.symbol->ownerScope == currentScope)
										{
											if (firstConfigScope && firstConfigScope->functionConfig->lambda)
											{
												readonlyCaptured = true;
											}

											if (currentScope->ownerNode.Cast<WfNewInterfaceExpression>())
											{
												if (firstConfigScope)
												{
													readonlyCaptured = firstConfigScope != lastConfigScope;

													if (
														lastConfigScope->parentScope != currentScope ||
														!lastConfigScope->ownerNode.Cast<WfFunctionDeclaration>() ||
														(lastConfigScope->ownerNodeSource && lastConfigScope->ownerNodeSource != currentScope->ownerNode)
														)
													{
														manager->errors.Add(WfErrors::FieldCannotInitializeUsingEachOther(node, result));
													}
												}
												else
												{
													manager->errors.Add(WfErrors::FieldCannotInitializeUsingEachOther(node, result));
												}
											}
											break;
										}

										if (currentScope->ownerNode.Cast<WfNewInterfaceExpression>())
										{
											auto capture = manager->lambdaCaptures[currentScope->ownerNode.Obj()];
											if (!capture->ctorArgumentSymbols.Contains(result.symbol.Obj()))
											{
												if (lastConfigScope == nullptr)
												{
													capture->ctorArgumentSymbols.Add(result.symbol);
												}
												else
												{
													auto functionCapture = manager->lambdaCaptures[lastConfigScope->ownerNode.Obj()];
													if (capture != functionCapture)
													{
														capture->ctorArgumentSymbols.Add(result.symbol);
													}
												}
											}
										}

										if (currentScope->functionConfig)
										{
											if (currentScope->functionConfig->lambda)
											{
												auto capture = manager->lambdaCaptures[currentScope->ownerNode.Obj()];
												if (!capture->symbols.Contains(result.symbol.Obj()))
												{
													capture->symbols.Add(result.symbol);
												}
											}
										}
										currentScope = currentScope->parentScope.Obj();
									}
								}

								if (readonlyCaptured)
								{
									results.Add(ResolveExpressionResult::ReadonlySymbol(result.symbol));
								}
								else
								{
									results.Add(ResolveExpressionResult::Symbol(result.symbol));
								}
							}
							else
							{
								results.Add(result);
							}
						}
						else
						{
							if (result.propertyInfo && dynamic_cast<WfReferenceExpression*>(node))
							{
								auto currentScope = scope;
								WfLexicalScope* firstConfigScope = nullptr;
								WfLexicalScope* lastConfigScope = nullptr;
								while (currentScope)
								{
									if (currentScope->functionConfig)
									{
										if (!firstConfigScope)
										{
											firstConfigScope = currentScope;
										}
										lastConfigScope = currentScope;
									}

									if (currentScope->ownerNode.Cast<WfClassDeclaration>() && currentScope->typeOfThisExpr == result.propertyInfo->GetOwnerTypeDescriptor())
									{
										if (firstConfigScope)
										{
											bool inMethodBody = 
												lastConfigScope->parentScope == currentScope &&
												lastConfigScope->ownerNodeSource == currentScope->ownerNode &&
												lastConfigScope->ownerNode.Cast<WfFunctionDeclaration>();
											bool inDtorBody = lastConfigScope->ownerNode.Cast<WfDestructorDeclaration>();
											bool inCtorBody = lastConfigScope->parentScope->ownerNode.Cast<WfConstructorDeclaration>();
											bool inStateBody = lastConfigScope->ownerNode.Cast<WfStateDeclaration>();

											if (!inMethodBody && !inDtorBody && !inCtorBody && !inStateBody)
											{
												manager->errors.Add(WfErrors::FieldCannotInitializeUsingEachOther(node, result));
											}
										}
										else if (!scope->ownerNode.Cast<WfConstructorDeclaration>())
										{
											manager->errors.Add(WfErrors::FieldCannotInitializeUsingEachOther(node, result));
										}
									}
									currentScope = currentScope->parentScope.Obj();
								}
							}
							results.Add(result);
						}
					}

					if (results.Count() == 0)
					{
						if (nameResults.Count() > 0)
						{
							for (auto result : nameResults)
							{
								manager->errors.Add(WfErrors::ExpressionCannotResolveType(node, result.symbol));
							}
						}
						else
						{
							manager->errors.Add(WfErrors::ReferenceNotExists(node, name));
						}
					}
				}

				void Visit(WfReferenceExpression* node)override
				{
					if (expectedType && (expectedType->GetTypeDescriptor()->GetTypeDescriptorFlags() & TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
					{
						auto scope = manager->nodeScopes[node].Obj();
						List<ResolveExpressionResult> testResults;
						manager->ResolveName(scope, node->name.value, testResults);

						if (testResults.Count() == 0)
						{
							auto enumType = expectedType->GetTypeDescriptor()->GetEnumType();
							if (enumType->IndexOfItem(node->name.value) == -1)
							{
								manager->errors.Add(WfErrors::EnumItemNotExists(node, expectedType->GetTypeDescriptor(), node->name.value));
							}
							else
							{
								results.Add(ResolveExpressionResult::ReadonlyType(expectedType));
							}
							return;
						}
					}

					ResolveName(node, node->name.value);
					for (auto result : results)
					{
						ITypeDescriptor* td = nullptr;
						if (result.methodInfo)
						{
							td = result.methodInfo->GetOwnerTypeDescriptor();
						}
						else if (result.propertyInfo)
						{
							td = result.propertyInfo->GetOwnerTypeDescriptor();
						}
						else if (result.eventInfo)
						{
							td = result.eventInfo->GetOwnerTypeDescriptor();
						}

						if (td)
						{
							auto scope = manager->nodeScopes[node].Obj();
							bool visibleToNonStatic = false;
							while (scope)
							{
								if (scope->functionConfig)
								{
									visibleToNonStatic = scope->functionConfig->thisAccessable || scope->functionConfig->parentThisAccessable;
								}

								if (scope->typeOfThisExpr && scope->typeOfThisExpr->CanConvertTo(td))
								{
									if (!visibleToNonStatic)
									{
										if (result.methodInfo)
										{
											if (!result.methodInfo->IsStatic())
											{
												manager->errors.Add(WfErrors::CannotCallMemberInStaticFunction(node, result));
											}
										}
										else if (result.propertyInfo)
										{
											manager->errors.Add(WfErrors::CannotCallMemberInStaticFunction(node, result));
										}
										else if (result.eventInfo)
										{
											manager->errors.Add(WfErrors::CannotCallMemberInStaticFunction(node, result));
										}
										break;
									}
								}
								scope = scope->parentScope.Obj();
							}
						}
					}
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					ResolveName(node, node->name.value);
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					List<Ptr<WfLexicalSymbol>> parameterSymbols;
					CopyFrom(
						parameterSymbols,
						Range<vint>(0, scope->symbols.Count())
							.Select([scope](vint index)->Ptr<WfLexicalSymbol>{return scope->symbols.GetByIndex(index)[0];})
							.OrderBy([](Ptr<WfLexicalSymbol> a, Ptr<WfLexicalSymbol> b)
							{
								vint aId = wtoi(a->name.Sub(1, a->name.Length() - 1));
								vint bId = wtoi(b->name.Sub(1, a->name.Length() - 1));
								return aId <=> bId;
							})
						);
					Ptr<ITypeInfo> resultType = expectedType;

					if (!expectedType && parameterSymbols.Count() > 0)
					{
						manager->errors.Add(WfErrors::OrderedLambdaCannotResolveType(node));
						return;
					}
					else if (expectedType)
					{
						ITypeInfo* type = expectedType.Obj();
						if (type->GetDecorator() != ITypeInfo::SharedPtr)
						{
							goto ORDERED_FAILED;
						}
						type = type->GetElementType();
						if (type->GetDecorator() != ITypeInfo::Generic)
						{
							goto ORDERED_FAILED;
						}
						{
							ITypeInfo* functionType = type->GetElementType();
							if (functionType->GetDecorator() != ITypeInfo::TypeDescriptor)
							{
								goto ORDERED_FAILED;
							}
							if (functionType->GetTypeDescriptor() != description::GetTypeDescriptor<IValueFunctionProxy>())
							{
								goto ORDERED_FAILED;
							}
						}

						if (type->GetGenericArgumentCount() != parameterSymbols.Count() + 1)
						{
							goto ORDERED_FAILED;
						}

						auto resultType = Ptr(type->GetGenericArgument(0));
						for (auto [symbol, index] : indexed(parameterSymbols))
						{
							symbol->typeInfo = Ptr(type->GetGenericArgument(index + 1));
							symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
						}
						GetExpressionType(manager, node->body, resultType);
					}
					else
					{
						auto bodyType = GetExpressionType(manager, node->body, 0);
						if (bodyType)
						{
							auto funcType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueFunctionProxy>(), TypeInfoHint::Normal));
							auto genericType = Ptr(new GenericTypeInfo(funcType));
							genericType->AddGenericArgument(bodyType);

							resultType = Ptr(new SharedPtrTypeInfo(genericType));
						}
					}

					goto ORDERED_FINISHED;
				ORDERED_FAILED:
					manager->errors.Add(WfErrors::OrderedLambdaCannotImplicitlyConvertToType(node, expectedType.Obj()));
				ORDERED_FINISHED:
					if (resultType)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(resultType));
					}
				}

				void Visit(WfMemberExpression* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->parent, 0);
					if (type)
					{
						SortedList<ITypeDescriptor*> searchedTypes;
						manager->ResolveMember(type->GetTypeDescriptor(), node->name.value, false, searchedTypes, results);

						if (results.Count() == 0)
						{
							manager->errors.Add(WfErrors::MemberNotExists(node, type->GetTypeDescriptor(), node->name.value));
						}
					}
				}

				void Visit(WfChildExpression* node)override
				{
					if (Ptr<WfLexicalScopeName> scopeName = GetExpressionScopeName(manager, node->parent))
					{
						vint index = scopeName->children.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							results.Add(ResolveExpressionResult::ScopeName(scopeName->children.Values()[index]));
							return;
						}
						
						if (scopeName->typeDescriptor)
						{
							SortedList<ITypeDescriptor*> searchedTypes;
							manager->ResolveMember(scopeName->typeDescriptor, node->name.value, true, searchedTypes, results);

							if (results.Count() > 0)
							{
								for (auto result : results)
								{
									if (result.methodInfo)
									{
										if (!result.methodInfo->IsStatic())
										{
											manager->errors.Add(WfErrors::CannotCallMemberOutsideOfClass(node, result));
										}
									}
									else if (result.propertyInfo)
									{
										manager->errors.Add(WfErrors::CannotCallMemberOutsideOfClass(node, result));
									}
									else if (result.eventInfo)
									{
										manager->errors.Add(WfErrors::CannotCallMemberOutsideOfClass(node, result));
									}
								}
								return;
							}
						}

						if (scopeName->typeDescriptor != nullptr && (scopeName->typeDescriptor->GetTypeDescriptorFlags() & TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
						{
							manager->errors.Add(WfErrors::EnumItemNotExists(node, scopeName->typeDescriptor, node->name.value));
						}
						else
						{
							manager->errors.Add(WfErrors::ChildSymbolNotExists(node, scopeName, node->name.value));
						}
					}
				}

				void Visit(WfLiteralExpression* node)override
				{
					if (node->value == WfLiteralValue::Null)
					{
						if (!expectedType)
						{
							manager->errors.Add(WfErrors::NullCannotResolveType(node));
						}
						else if (!IsNullAcceptableType(expectedType.Obj()))
						{
							manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node, expectedType.Obj()));
						}

						results.Add(ResolveExpressionResult::ReadonlyType(expectedType));
					}
					else
					{
						results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<bool>::CreateTypeInfo()));
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
					auto typeDescriptor = expectedType ? expectedType->GetTypeDescriptor() : nullptr;
					if (!typeDescriptor || typeDescriptor->GetTypeDescriptorFlags() == TypeDescriptorFlags::Object || typeDescriptor == description::GetTypeDescriptor<WString>())
					{
						typeDescriptor = description::GetTypeDescriptor<double>();
					}

					if (auto serializableType = typeDescriptor->GetSerializableType())
					{
						Value output;
						if (serializableType->Deserialize(node->value.value, output))
						{
							results.Add(ResolveExpressionResult::ReadonlyType(Ptr(new TypeDescriptorTypeInfo(typeDescriptor, TypeInfoHint::Normal))));
							return;
						}
					}
					manager->errors.Add(WfErrors::FloatingLiteralOutOfRange(node));
				}

				void Visit(WfIntegerExpression* node)override
				{
					auto typeDescriptor = expectedType ? expectedType->GetTypeDescriptor() : nullptr;
					if (!typeDescriptor || typeDescriptor->GetTypeDescriptorFlags() == TypeDescriptorFlags::Object || typeDescriptor==description::GetTypeDescriptor<WString>())
					{
						typeDescriptor = manager->cputdSInt;
					}

					if (auto serializableType = typeDescriptor->GetSerializableType())
					{
						Value output;
						if (serializableType->Deserialize(node->value.value, output))
						{
							results.Add(ResolveExpressionResult::ReadonlyType(Ptr(new TypeDescriptorTypeInfo(typeDescriptor, TypeInfoHint::Normal))));
							return;
						}
					}
					manager->errors.Add(WfErrors::IntegerLiteralOutOfRange(node));
				}

				void Visit(WfStringExpression* node)override
				{
					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<WString>::CreateTypeInfo()));
				}

				void Visit(WfUnaryExpression* node)override
				{
					Ptr<ITypeInfo> typeInfo = GetExpressionType(manager, node->operand, 0);
					if (typeInfo)
					{
						TypeFlag flag = GetTypeFlag(typeInfo.Obj());
						switch (node->op)
						{
						case WfUnaryOperator::Not:
							switch (flag)
							{
							case TypeFlag::F4:
							case TypeFlag::F8:
							case TypeFlag::String:
							case TypeFlag::Enum:
							case TypeFlag::Struct:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							default:;
							}
							break;
						case WfUnaryOperator::Positive:
							switch (flag)
							{
							case TypeFlag::Bool:
							case TypeFlag::String:
							case TypeFlag::Enum:
							case TypeFlag::Struct:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							default:;
							}
							break;
						case WfUnaryOperator::Negative:
							switch (flag)
							{
							case TypeFlag::Bool:
							case TypeFlag::U1:
							case TypeFlag::U2:
							case TypeFlag::U4:
							case TypeFlag::U8:
							case TypeFlag::String:
							case TypeFlag::Enum:
							case TypeFlag::Struct:
							case TypeFlag::Others:
								manager->errors.Add(WfErrors::UnaryOperatorOnWrongType(node, typeInfo.Obj()));
								break;
							default:;
							}
							break;
						default:;
						}

						results.Add(ResolveExpressionResult::ReadonlyType(typeInfo));
					}
				}

				void Visit(WfBinaryExpression* node)override
				{
					if (node->op == WfBinaryOperator::Assign)
					{
						Ptr<ITypeInfo> variableType = GetLeftValueExpressionType(manager, node->first);
						GetExpressionType(manager, node->second, variableType);
						if (variableType)
						{
							results.Add(ResolveExpressionResult::ReadonlyType(variableType));
						}
					}
					else if (node->op == WfBinaryOperator::Index)
					{
						Ptr<ITypeInfo> containerType = GetExpressionType(manager, node->first, 0);
						if (containerType)
						{
							if (containerType->GetDecorator() == ITypeInfo::SharedPtr)
							{
								ITypeInfo* genericType = containerType->GetElementType();
								Ptr<ITypeInfo> indexType;
								Ptr<ITypeInfo> resultType;
								bool leftValue = false;

								if (genericType->GetDecorator() == ITypeInfo::Generic)
								{
									ITypeInfo* classType = genericType->GetElementType();
									if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
									{
										indexType = manager->cputiSInt;
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueArray>())
									{
										indexType = manager->cputiSInt;
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
										leftValue = true;
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
									{
										indexType = manager->cputiSInt;
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
										leftValue = true;
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueObservableList>())
									{
										indexType = manager->cputiSInt;
										resultType = CopyTypeInfo(genericType->GetGenericArgument(0));
										leftValue = true;
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
									{
										indexType = CopyTypeInfo(genericType->GetGenericArgument(0));
										resultType = CopyTypeInfo(genericType->GetGenericArgument(1));
									}
									else if (classType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
									{
										indexType = CopyTypeInfo(genericType->GetGenericArgument(0));
										resultType = CopyTypeInfo(genericType->GetGenericArgument(1));
										leftValue = true;
									}
									else
									{
										manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
									}
								}
								else
								{
									if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>())
									{
										indexType = manager->cputiSInt;
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueArray>())
									{
										indexType = manager->cputiSInt;
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
									{
										indexType = manager->cputiSInt;
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueObservableList>())
									{
										indexType = manager->cputiSInt;
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
									{
										indexType = TypeInfoRetriver<Value>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
									{
										indexType = TypeInfoRetriver<Value>::CreateTypeInfo();
										resultType = TypeInfoRetriver<Value>::CreateTypeInfo();
										leftValue = true;
									}
									else
									{
										manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
									}
								}

								GetExpressionType(manager, node->second, indexType);
								if (resultType)
								{
									if (leftValue)
									{
										results.Add(ResolveExpressionResult::WritableType(resultType));
									}
									else
									{
										results.Add(ResolveExpressionResult::ReadonlyType(resultType));
									}
								}
							}
							else
							{
								manager->errors.Add(WfErrors::IndexOperatorOnWrongType(node, containerType.Obj()));
							}
						}
					}
					else if (node->op == WfBinaryOperator::FlagAnd)
					{
						auto typeA = GetExpressionType(manager, node->first, expectedType);
						auto typeB = GetExpressionType(manager, node->second, expectedType);

						if (typeA && typeB)
						{
							if (typeA->GetDecorator() == ITypeInfo::TypeDescriptor && typeB->GetDecorator() == ITypeInfo::TypeDescriptor)
							{
								auto stringType = TypeInfoRetriver<WString>::CreateTypeInfo();
								if (CanConvertToType(typeA.Obj(), stringType.Obj(), false) && CanConvertToType(typeB.Obj(), stringType.Obj(), false))
								{
									results.Add(ResolveExpressionResult::ReadonlyType(stringType));
									return;
								}
								else if (auto type = GetMergedType(typeA, typeB))
								{
									if (type->GetTypeDescriptor()->GetTypeDescriptorFlags() != TypeDescriptorFlags::FlagEnum)
									{
										manager->errors.Add(WfErrors::IncorrectTypeForUnion(node->first.Obj(), type.Obj()));
									}
									results.Add(ResolveExpressionResult::ReadonlyType(type));
									return;
								}
							}
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, typeA.Obj(), typeB.Obj()));
						}
					}
					else if (node->op == WfBinaryOperator::FlagOr)
					{
						auto typeA = GetExpressionType(manager, node->first, expectedType);
						auto typeB = GetExpressionType(manager, node->second, expectedType);

						if (typeA && typeB)
						{
							if (typeA->GetDecorator() == ITypeInfo::TypeDescriptor && typeB->GetDecorator() == ITypeInfo::TypeDescriptor)
							{
								if (auto type = GetMergedType(typeA, typeB))
								{
									if (type->GetTypeDescriptor()->GetTypeDescriptorFlags() != TypeDescriptorFlags::FlagEnum)
									{
										manager->errors.Add(WfErrors::IncorrectTypeForIntersect(node->first.Obj(), type.Obj()));
									}
									results.Add(ResolveExpressionResult::ReadonlyType(type));
									return;
								}
							}
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, typeA.Obj(), typeB.Obj()));
						}
					}
					else if (node->op == WfBinaryOperator::FailedThen)
					{
						Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->first, 0);
						bool depend = IsExpressionDependOnExpectedType(manager, node->second, firstType);
						Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->second, (depend ? firstType : nullptr));

						if (firstType && secondType)
						{
							if (auto mergedType = GetMergedType(firstType, secondType))
							{
								results.Add(ResolveExpressionResult::ReadonlyType(mergedType));
							}
							else
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
							}
						}
					}
					else
					{
						Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->first, 0);
						Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->second, 0);
						Ptr<ITypeInfo> elementType;
						if (firstType && secondType)
						{
							if (!(elementType = GetMergedType(firstType, secondType)))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
							}
						}

						if (elementType)
						{
							TypeFlag flag = GetTypeFlag(elementType.Obj());
							TypeFlag* selectedTable = 0;
							switch (node->op)
							{
							case WfBinaryOperator::Exp:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::F4,
										/*I2		*/TypeFlag::F4,
										/*I4		*/TypeFlag::F8,
										/*I8		*/TypeFlag::F8,
										/*U1		*/TypeFlag::F4,
										/*U2		*/TypeFlag::F4,
										/*U4		*/TypeFlag::F8,
										/*U8		*/TypeFlag::F8,
										/*F4		*/TypeFlag::F4,
										/*F8		*/TypeFlag::F8,
										/*String	*/TypeFlag::Unknown,
										/*Enum		*/TypeFlag::Unknown,
										/*Struct	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::Add:
							case WfBinaryOperator::Sub:
							case WfBinaryOperator::Mul:
							case WfBinaryOperator::Div:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::I4,
										/*I2		*/TypeFlag::I4,
										/*I4		*/TypeFlag::I4,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U4,
										/*U2		*/TypeFlag::U4,
										/*U4		*/TypeFlag::U4,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::F4,
										/*F8		*/TypeFlag::F8,
										/*String	*/TypeFlag::Unknown,
										/*Enum		*/TypeFlag::Unknown,
										/*Struct	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::Mod:
							case WfBinaryOperator::Shl:
							case WfBinaryOperator::Shr:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::I4,
										/*I2		*/TypeFlag::I4,
										/*I4		*/TypeFlag::I4,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U4,
										/*U2		*/TypeFlag::U4,
										/*U4		*/TypeFlag::U4,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::Unknown,
										/*F8		*/TypeFlag::Unknown,
										/*String	*/TypeFlag::Unknown,
										/*Enum		*/TypeFlag::Unknown,
										/*Struct	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::LT:
							case WfBinaryOperator::GT:
							case WfBinaryOperator::LE:
							case WfBinaryOperator::GE:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Unknown,
										/*I1		*/TypeFlag::Bool,
										/*I2		*/TypeFlag::Bool,
										/*I4		*/TypeFlag::Bool,
										/*I8		*/TypeFlag::Bool,
										/*U1		*/TypeFlag::Bool,
										/*U2		*/TypeFlag::Bool,
										/*U4		*/TypeFlag::Bool,
										/*U8		*/TypeFlag::Bool,
										/*F4		*/TypeFlag::Bool,
										/*F8		*/TypeFlag::Bool,
										/*String	*/TypeFlag::Bool,
										/*Enum		*/TypeFlag::Unknown,
										/*Struct	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							case WfBinaryOperator::EQ:
							case WfBinaryOperator::NE:
								{
									results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<bool>::CreateTypeInfo()));
									return;
								}
								break;
							case WfBinaryOperator::Xor:
							case WfBinaryOperator::And:
							case WfBinaryOperator::Or:
								{
									static TypeFlag conversionTable[(vint)TypeFlag::Count] = {
										/*Bool		*/TypeFlag::Bool,
										/*I1		*/TypeFlag::I1,
										/*I2		*/TypeFlag::I2,
										/*I4		*/TypeFlag::I4,
										/*I8		*/TypeFlag::I8,
										/*U1		*/TypeFlag::U1,
										/*U2		*/TypeFlag::U2,
										/*U4		*/TypeFlag::U4,
										/*U8		*/TypeFlag::U8,
										/*F4		*/TypeFlag::Unknown,
										/*F8		*/TypeFlag::Unknown,
										/*String	*/TypeFlag::Unknown,
										/*Enum		*/TypeFlag::Unknown,
										/*Struct	*/TypeFlag::Unknown,
										/*Others	*/TypeFlag::Unknown,
									};
									selectedTable = conversionTable;
								}
								break;
							default:;
							}

							TypeFlag resultFlag = selectedTable[(vint)flag];
							if (resultFlag == TypeFlag::Unknown)
							{
								manager->errors.Add(WfErrors::BinaryOperatorOnWrongType(node, elementType.Obj()));
							}
							else
							{
								results.Add(ResolveExpressionResult::ReadonlyType(CreateTypeInfoFromTypeFlag(resultFlag)));
							}
						}
					}
				}

				void Visit(WfLetExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();

					for (auto variable : node->variables)
					{
						auto symbol = scope->symbols[variable->name.value][0];
						symbol->typeInfo = GetExpressionType(manager, variable->value, 0);
						if (symbol->typeInfo)
						{
							symbol->type = GetTypeFromTypeInfo(symbol->typeInfo.Obj());
						}
					}
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, expectedType);
					if (type)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(type));
					}
				}

				void Visit(WfIfExpression* node)override
				{
					Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
					GetExpressionType(manager, node->condition, boolType);

					Ptr<ITypeInfo> firstType, secondType;

					if (expectedType)
					{
						firstType = GetExpressionType(manager, node->trueBranch, expectedType);
						secondType = GetExpressionType(manager, node->falseBranch, expectedType);
					}
					else
					{
						bool resolveFirst = !IsExpressionDependOnExpectedType(manager, node->trueBranch, false);
						bool resolveSecond = !IsExpressionDependOnExpectedType(manager, node->falseBranch, false);

						if (resolveFirst == resolveSecond)
						{
							firstType = GetExpressionType(manager, node->trueBranch, 0);
							secondType = GetExpressionType(manager, node->falseBranch, 0);
						}
						else if (resolveFirst)
						{
							firstType = GetExpressionType(manager, node->trueBranch, 0);
							secondType = GetExpressionType(manager, node->falseBranch, firstType);
						}
						else if (resolveSecond)
						{
							secondType = GetExpressionType(manager, node->falseBranch, 0);
							firstType = GetExpressionType(manager, node->trueBranch, secondType);
						}
					}
					
					if (firstType && !secondType)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(firstType));
					}
					else if (!firstType && secondType)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(secondType));
					}
					else if (firstType && secondType)
					{
						if (auto mergedType = GetMergedType(firstType, secondType))
						{
							results.Add(ResolveExpressionResult::ReadonlyType(mergedType));
						}
						else
						{
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
						}
					}
				}

				void Visit(WfRangeExpression* node)override
				{
					Ptr<ITypeInfo> firstType = GetExpressionType(manager, node->begin, 0);
					Ptr<ITypeInfo> secondType = GetExpressionType(manager, node->end, 0);
					Ptr<ITypeInfo> elementType;

					if (firstType && !secondType)
					{
						elementType = firstType;
					}
					else if (!firstType && secondType)
					{
						elementType = secondType;
					}
					else if (firstType && secondType)
					{
						if (!(elementType = GetMergedType(firstType, secondType)))
						{
							manager->errors.Add(WfErrors::CannotMergeTwoType(node, firstType.Obj(), secondType.Obj()));
						}
					}

					if (elementType)
					{
						TypeFlag flag = GetTypeFlag(elementType.Obj());
						switch (flag)
						{
						case TypeFlag::I1:
						case TypeFlag::I2:
						case TypeFlag::I4:
						case TypeFlag::I8:
						case TypeFlag::U1:
						case TypeFlag::U2:
						case TypeFlag::U4:
						case TypeFlag::U8:
							break;
						default:
							manager->errors.Add(WfErrors::RangeShouldBeInteger(node, elementType.Obj()));
						}

						auto enumerableType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueEnumerable>(), TypeInfoHint::Normal));
						auto genericType = Ptr(new GenericTypeInfo(enumerableType));
						genericType->AddGenericArgument(elementType);

						auto pointerType = Ptr(new SharedPtrTypeInfo(genericType));
						results.Add(ResolveExpressionResult::ReadonlyType(pointerType));
					}
				}

				void Visit(WfSetTestingExpression* node)override
				{
					Ptr<ITypeInfo> elementType = GetExpressionType(manager, node->element, 0);

					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						Ptr<ITypeInfo> beginType = GetExpressionType(manager, range->begin, 0);
						Ptr<ITypeInfo> endType = GetExpressionType(manager, range->end, 0);

						if (elementType && beginType)
						{
							if (!GetMergedType(elementType, beginType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), beginType.Obj()));
							}
						}
						if (elementType && endType)
						{
							if (!GetMergedType(elementType, endType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), endType.Obj()));
							}
						}
					}
					else
					{
						Ptr<ITypeInfo> itemType = GetEnumerableExpressionItemType(manager, node->collection, 0);
						if (elementType && itemType)
						{
							if (!GetMergedType(elementType, itemType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(node, elementType.Obj(), itemType.Obj()));
							}
						}
					}

					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfConstructorExpression* node)override
				{
					if (expectedType && expectedType->GetTypeDescriptor()->GetTypeDescriptorFlags() == TypeDescriptorFlags::Struct)
					{
						SortedList<WString> fields;
						for (auto argument : node->arguments)
						{
							if (!argument->value)
							{
								manager->errors.Add(WfErrors::ConstructorMixStructAndList(node));
								return;
							}
							else if (auto field = argument->key.Cast<WfReferenceExpression>())
							{
								if (auto prop = expectedType->GetTypeDescriptor()->GetPropertyByName(field->name.value, true))
								{
									if (fields.Contains(field->name.value))
									{
										manager->errors.Add(WfErrors::DuplicatedConstructorField(field.Obj()));
									}
									else
									{
										fields.Add(field->name.value);
									}
									GetExpressionType(manager, argument->value, CopyTypeInfo(prop->GetReturn()));
								}
								else
								{
									manager->errors.Add(WfErrors::MemberNotExists(field.Obj(), expectedType->GetTypeDescriptor(), field->name.value));
								}
							}
							else
							{
								manager->errors.Add(WfErrors::ConstructorMixStructAndList(argument->value.Obj()));
							}
						}
						results.Add(ResolveExpressionResult::ReadonlyType(expectedType));
					}
					else if (node->arguments.Count() == 0)
					{
						if (expectedType)
						{
							ITypeDescriptor* td = expectedType->GetTypeDescriptor();
							if (!td->CanConvertTo(description::GetTypeDescriptor<IValueEnumerable>()) && !td->CanConvertTo(description::GetTypeDescriptor<IValueReadonlyDictionary>()))
							{
								manager->errors.Add(WfErrors::ConstructorCannotImplicitlyConvertToType(node, expectedType.Obj()));
							}
							results.Add(ResolveExpressionResult::ReadonlyType(expectedType));
						}
						else
						{
							manager->errors.Add(WfErrors::ConstructorCannotResolveType(node));
						}
					}
					else
					{
						Ptr<ITypeInfo> expectedKeyType;
						Ptr<ITypeInfo> expectedValueType;
						if (expectedType)
						{
							if (expectedType->GetDecorator() == ITypeInfo::SharedPtr)
							{
								auto genericType = expectedType->GetElementType();
								if (genericType->GetDecorator() == ITypeInfo::Generic)
								{
									if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>()
										|| genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyDictionary>())
									{
										if (genericType->GetGenericArgumentCount() == 2)
										{
											expectedKeyType = Ptr(genericType->GetGenericArgument(0));
											expectedValueType = Ptr(genericType->GetGenericArgument(1));
										}
									}
									else if (genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueObservableList>()
										|| genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueArray>()
										|| genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>()
										|| genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>()
										|| genericType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>())
									{
										if (genericType->GetGenericArgumentCount() == 1)
										{
											expectedKeyType = Ptr(genericType->GetGenericArgument(0));
										}
									}
								}
							}
						}

						bool map = node->arguments[0]->value;
						Ptr<ITypeInfo> keyType, valueType;
						for (auto argument : node->arguments)
						{
							{
								Ptr<ITypeInfo> newKeyType = GetExpressionType(manager, argument->key, expectedKeyType);
								if (!keyType)
								{
									keyType = newKeyType;
								}
								else if (auto mergedType = GetMergedType(keyType, newKeyType))
								{
									keyType = mergedType;
								}
								else
								{
									manager->errors.Add(WfErrors::CannotMergeTwoType(node, keyType.Obj(), newKeyType.Obj()));
								}
							}
							if (map)
							{
								Ptr<ITypeInfo> newValueType = GetExpressionType(manager, argument->value, expectedValueType);
								if (!valueType)
								{
									valueType = newValueType;
								}
								else if (auto mergedType = GetMergedType(valueType, newValueType))
								{
									valueType = mergedType;
								}
								else
								{
									manager->errors.Add(WfErrors::CannotMergeTwoType(node, valueType.Obj(), newValueType.Obj()));
								}
							}
						}

						if (map)
						{
							if (keyType && valueType)
							{
								auto classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueDictionary>(), TypeInfoHint::Normal));
								auto genericType = Ptr(new GenericTypeInfo(classType));
								genericType->AddGenericArgument(keyType);
								genericType->AddGenericArgument(valueType);

								auto pointerType = Ptr(new SharedPtrTypeInfo(genericType));
								results.Add(ResolveExpressionResult::ReadonlyType(pointerType));
							}
						}
						else
						{
							if (keyType)
							{
								Ptr<ITypeInfo> classType;
								if (expectedType)
								{
									switch (expectedType->GetHint())
									{
									case TypeInfoHint::ObservableList:
										classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueObservableList>(), expectedType->GetHint()));
										break;
									case TypeInfoHint::Array:
										classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueArray>(), expectedType->GetHint()));
										break;
									case TypeInfoHint::Normal:
										if (expectedType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueObservableList>())
										{
											classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueObservableList>(), expectedType->GetHint()));
										}
										else
										{
											classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueList>(), expectedType->GetHint()));
										}
										break;
									default:
										classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueList>(), expectedType->GetHint()));
									}
								}
								else
								{
									classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueList>(), TypeInfoHint::Normal));
								}
								auto genericType = Ptr(new GenericTypeInfo(classType));
								genericType->AddGenericArgument(keyType);

								auto pointerType = Ptr(new SharedPtrTypeInfo(genericType));
								results.Add(ResolveExpressionResult::ReadonlyType(pointerType));
							}
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					Ptr<ITypeInfo> expressionType = GetExpressionType(manager, node->expression, type);
					if (expressionType)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(type));
					}
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					if (auto type = CreateTypeInfoFromType(scope, node->type))
					{
						if (auto expressionType = GetExpressionType(manager, node->expression, 0))
						{
							if (!CanConvertToType(expressionType.Obj(), type.Obj(), true))
							{
								manager->errors.Add(WfErrors::ExpressionCannotExplicitlyConvertToType(node->expression.Obj(), expressionType.Obj(), type.Obj()));
							}
						}
						if (node->strategy == WfTypeCastingStrategy::Weak)
						{
							switch (type->GetDecorator())
							{
							case ITypeInfo::RawPtr:
							case ITypeInfo::SharedPtr:
							case ITypeInfo::Nullable:
								break;
							default:
								manager->errors.Add(WfErrors::CannotWeakCastToType(node->expression.Obj(), type.Obj()));
							}
						}
						results.Add(ResolveExpressionResult::ReadonlyType(type));
					}
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						switch (node->test)
						{
						case WfTypeTesting::IsNull:
						case WfTypeTesting::IsNotNull:
							if (!IsNullAcceptableType(type.Obj()))
							{
								manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node->expression.Obj(), type.Obj()));
							}
							break;
						default:;
						}
					}
					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<ITypeDescriptor*>::CreateTypeInfo()));
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					GetExpressionType(manager, node->expression, 0);
					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<ITypeDescriptor*>::CreateTypeInfo()));
				}

				void Visit(WfAttachEventExpression* node)override
				{
					IEventInfo* eventInfo = GetExpressionEventInfo(manager, node->event);
					Ptr<ITypeInfo> functionType;
					if (eventInfo)
					{
						functionType = CopyTypeInfo(eventInfo->GetHandlerType());
					}
					GetExpressionType(manager, node->function, functionType);
					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo()));
				}

				void Visit(WfDetachEventExpression* node)override
				{
					GetExpressionEventInfo(manager, node->event);
					Ptr<ITypeInfo> pointerType = TypeInfoRetriver<Ptr<IEventHandler>>::CreateTypeInfo();
					GetExpressionType(manager, node->handler, pointerType);
					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<bool>::CreateTypeInfo()));
				}

				void Visit(WfObserveExpression* node)override
				{
					Ptr<ITypeInfo> parentType = GetExpressionType(manager, node->parent, 0);
					Ptr<ITypeInfo> observeeType;
					if (parentType)
					{
						if (node->observeType == WfObserveType::SimpleObserve)
						{
							ITypeDescriptor* td = parentType->GetTypeDescriptor();
							IPropertyInfo* propertyInfo = 0;
							{
								auto ref = node->expression.Cast<WfReferenceExpression>();
								propertyInfo = td->GetPropertyByName(ref->name.value, true);
								if (propertyInfo)
								{
									observeeType = CopyTypeInfo(propertyInfo->GetReturn());
									manager->expressionResolvings.Add(node->expression, ResolveExpressionResult::Property(propertyInfo));
								}
								else
								{
									manager->errors.Add(WfErrors::MemberNotExists(ref.Obj(), td, ref->name.value));
								}
							}

							if (node->events.Count() == 0)
							{
								if (propertyInfo)
								{
									IEventInfo* eventInfo = propertyInfo->GetValueChangedEvent();
									if (!eventInfo)
									{
										eventInfo = td->GetEventByName(propertyInfo->GetName() + L"Changed", true);
									}
									if (!eventInfo)
									{
										manager->errors.Add(WfErrors::MemberNotExists(node->expression.Obj(), td, propertyInfo->GetName() + L"Changed"));
									}
								}
							}
							else
							{
								for (auto eventExpr : node->events)
								{
									auto ref = eventExpr.Cast<WfReferenceExpression>();
									IEventInfo* info = td->GetEventByName(ref->name.value, true);
									if (info)
									{
										manager->expressionResolvings.Add(eventExpr, ResolveExpressionResult::Event(info));
									}
									else if (!info)
									{
										manager->errors.Add(WfErrors::MemberNotExists(ref.Obj(), td, ref->name.value));
									}
								}
							}
						}
						else
						{
							auto scope = manager->nodeScopes[node].Obj();
							auto symbol = scope->symbols[node->name.value][0];
							symbol->typeInfo = parentType;
							symbol->type = GetTypeFromTypeInfo(parentType.Obj());

							observeeType = GetExpressionType(manager, node->expression, 0);
							for (auto eventExpr : node->events)
							{
								GetExpressionEventInfo(manager, eventExpr);
							}
						}
					}

					if (observeeType)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(observeeType));
					}
				}

				void Visit(WfCallExpression* node)override
				{
					List<ResolveExpressionResult> functions;
					GetExpressionTypes(manager, node->function, nullptr, true, functions);

					vint selectedFunctionIndex = -1;
					Ptr<ITypeInfo> resultType = SelectFunction(manager, node, node->function, functions, node->arguments, selectedFunctionIndex);
					if (resultType)
					{
						manager->expressionResolvings.Add(node->function, functions[selectedFunctionIndex]);
						results.Add(ResolveExpressionResult::ReadonlyType(resultType));
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					ValidateDeclarationSemantic(manager, node->function);
					auto scope = manager->nodeScopes[node->function.Obj()].Obj();

					auto classType = Ptr(new TypeDescriptorTypeInfo(description::GetTypeDescriptor<IValueFunctionProxy>(), TypeInfoHint::Normal));
					auto genericType = Ptr(new GenericTypeInfo(classType));
					genericType->AddGenericArgument(CreateTypeInfoFromType(scope, node->function->returnType));
					for (auto argument : node->function->arguments)
					{
						genericType->AddGenericArgument(scope->symbols[argument->name.value][0]->typeInfo);
					}

					auto pointerType = Ptr(new SharedPtrTypeInfo(genericType));
					results.Add(ResolveExpressionResult::ReadonlyType(pointerType));
				}

				Ptr<ITypeInfo> GetFunctionDeclarationType(WfLexicalScope* scope, Ptr<WfFunctionDeclaration> decl)
				{
					Ptr<WfLexicalSymbol> symbol = From(manager->nodeScopes[decl.Obj()]->parentScope->symbols[decl->name.value])
						.Where([decl](Ptr<WfLexicalSymbol> symbol)
						{
							return symbol->creatorNode == decl;
						})
						.First();
					return symbol->typeInfo;
				}

				class NewInterfaceExpressionVisitor
					: public empty_visitor::DeclarationVisitor
				{
				public:
					WfLexicalScopeManager*							manager;
					List<Ptr<WfFunctionDeclaration>>				overrideFunctions;
					List<Ptr<WfLexicalSymbol>>						variableSymbols;
					WfFunctionDeclaration*							lastFunction = nullptr;

					NewInterfaceExpressionVisitor(WfLexicalScopeManager* _manager)
						:manager(_manager)
					{
					}

					void Dispatch(WfVirtualCfeDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							decl->Accept(this);
						}
					}

					void Dispatch(WfVirtualCseDeclaration* node)override
					{
						CHECK_FAIL(L"NewInterfaceExpressionVisitor::Visit(WfVirtualCseDeclaration*)#Internal error, Temporary not supported.");
					}

					void Visit(WfFunctionDeclaration* node)override
					{
						lastFunction = node;
						if (node->functionKind == WfFunctionKind::Override)
						{
							overrideFunctions.Add(Ptr(node));
						}
					}

					void Visit(WfVariableDeclaration* node)override
					{
						variableSymbols.Add(
							From(manager->nodeScopes[node]->symbols[node->name.value])
								.Where([=](Ptr<WfLexicalSymbol> symbol)
								{
									return symbol->creatorNode == node;
								})
								.First()
							);
					}

					void Execute(WfNewInterfaceExpression* node)
					{
						for (auto memberDecl : node->declarations)
						{
							memberDecl->Accept(this);
							ValidateDeclarationSemantic(manager, memberDecl);
						}
					}
				};

				void Visit(WfNewClassExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					if (type)
					{
						ITypeDescriptor* td = type->GetTypeDescriptor();
						IMethodGroupInfo* ctors = td->GetConstructorGroup();
						Ptr<ITypeInfo> selectedType;
						IMethodInfo* selectedConstructor = nullptr;

						if (!ctors || ctors->GetMethodCount() == 0)
						{
							manager->errors.Add(WfErrors::ClassContainsNoConstructor(node, type.Obj()));
						}
						else
						{
							if ((td->GetTypeDescriptorFlags() & TypeDescriptorFlags::ClassType) != TypeDescriptorFlags::Undefined)
							{
								List<ResolveExpressionResult> functions;
								for (vint i = 0; i < ctors->GetMethodCount(); i++)
								{
									IMethodInfo* info = ctors->GetMethod(i);
									functions.Add(ResolveExpressionResult::Method(info));
								}

								vint selectedFunctionIndex = -1;
								selectedType = SelectFunction(manager, node, nullptr, functions, node->arguments, selectedFunctionIndex);
								if (selectedType)
								{
									selectedConstructor = functions[selectedFunctionIndex].methodInfo;
								}
							}
							else if ((td->GetTypeDescriptorFlags() & TypeDescriptorFlags::InterfaceType) != TypeDescriptorFlags::Undefined)
							{
								manager->errors.Add(WfErrors::ConstructorMixClassAndInterface(node));
							}
							else
							{
								manager->errors.Add(WfErrors::ClassContainsNoConstructor(node, type.Obj()));
							}
						}

						if (selectedType)
						{
							auto result = ResolveExpressionResult::Constructor(selectedConstructor);
							if (!IsSameType(selectedType.Obj(), type.Obj()))
							{
								manager->errors.Add(WfErrors::ConstructorReturnTypeMismatched(node, result, selectedType.Obj(), type.Obj()));
							}
							results.Add(result);
						}
					}
				}

				void Visit(WfNewInterfaceExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					Ptr<ITypeInfo> type = CreateTypeInfoFromType(scope, node->type);
					if (type)
					{
						ITypeDescriptor* td = type->GetTypeDescriptor();
						IMethodGroupInfo* ctors = td->GetConstructorGroup();
						Ptr<ITypeInfo> selectedType;
						IMethodInfo* selectedConstructor = nullptr;

						scope->typeOfThisExpr = td;

						if (!ctors || ctors->GetMethodCount() == 0)
						{
							manager->errors.Add(WfErrors::ClassContainsNoConstructor(node, type.Obj()));
						}
						else
						{
							if ((td->GetTypeDescriptorFlags() & TypeDescriptorFlags::ClassType) != TypeDescriptorFlags::Undefined)
							{
								manager->errors.Add(WfErrors::ConstructorMixClassAndInterface(node));
							}
							else if ((td->GetTypeDescriptorFlags() & TypeDescriptorFlags::InterfaceType) != TypeDescriptorFlags::Undefined)
							{
								if (auto info = FindInterfaceConstructor(td))
								{
									selectedType = CopyTypeInfo(info->GetReturn());
									selectedConstructor = info;
								}
								else
								{
									manager->errors.Add(WfErrors::InterfaceContainsNoConstructor(node, type.Obj()));
								}

								Group<WString, IMethodInfo*> interfaceMethods;
								Group<WString, Ptr<WfFunctionDeclaration>> implementMethods;
								
								{
									NewInterfaceExpressionVisitor declVisitor(manager);
									declVisitor.Execute(node);

									if (declVisitor.lastFunction)
									{
										for (auto func : declVisitor.overrideFunctions)
										{
											implementMethods.Add(func->name.value, func);
										}

										auto capture = manager->lambdaCaptures[declVisitor.lastFunction];
										List<Ptr<WfLexicalSymbol>> readonlySymbols;
										CopyFrom(readonlySymbols, From(capture->symbols).Except(declVisitor.variableSymbols));
										CopyFrom(capture->symbols, declVisitor.variableSymbols);
										CopyFrom(capture->symbols, readonlySymbols, true);
									}
								}
								{
									SortedList<ITypeDescriptor*> searchedTypes;
									List<ITypeDescriptor*> types;
									types.Add(td);
									vint begin = 0;

									while (begin < types.Count())
									{
										ITypeDescriptor* currentType = types[begin++];
										if (searchedTypes.Contains(currentType))
										{
											continue;
										}
										searchedTypes.Add(currentType);

										vint count = currentType->GetBaseTypeDescriptorCount();
										for (vint i = 0; i < count; i++)
										{
											types.Add(currentType->GetBaseTypeDescriptor(i));
										}

										count = currentType->GetMethodGroupCount();
										for (vint i = 0; i < count; i++)
										{
											IMethodGroupInfo* group = currentType->GetMethodGroup(i);
											vint methodCount = group->GetMethodCount();
											for (vint j = 0; j < methodCount; j++)
											{
												auto method = group->GetMethod(j);
												if (!method->IsStatic())
												{
													interfaceMethods.Add(group->GetName(), method);
												}
											}
										}
									}
								}

								auto discardFirst = [=, this](const WString& key, const List<IMethodInfo*>& methods)
									{
										for (auto method : methods)
										{
											manager->errors.Add(WfErrors::InterfaceMethodNotImplemented(node, method));
										}
									};
								auto discardSecond = [=, this](const WString& key, const List<Ptr<WfFunctionDeclaration>>& methods)
									{
										for (auto decl : methods)
										{
											Ptr<ITypeInfo> declType = GetFunctionDeclarationType(scope, decl);
											manager->errors.Add(WfErrors::InterfaceMethodNotFound(decl.Obj(), type.Obj(), declType.Obj()));
										}
									};

								GroupInnerJoin(
									interfaceMethods,
									implementMethods,
									discardFirst,
									discardSecond,
									[=, this](const WString& key, const List<IMethodInfo*>& interfaces, const List<Ptr<WfFunctionDeclaration>>& implements)
									{
										Group<WString, IMethodInfo*> typedInterfaceMethods;
										Group<WString, Ptr<WfFunctionDeclaration>> typedImplementMethods;

										for (auto method : interfaces)
										{
											Ptr<ITypeInfo> methodType = CreateTypeInfoFromMethodInfo(method);
											typedInterfaceMethods.Add(methodType->GetTypeFriendlyName(), method);
										}

										for (auto decl : implements)
										{
											Ptr<ITypeInfo> methodType = GetFunctionDeclarationType(scope, decl);
											typedImplementMethods.Add(methodType->GetTypeFriendlyName(), decl);
										}

										GroupInnerJoin(
											typedInterfaceMethods,
											typedImplementMethods,
											discardFirst,
											discardSecond,
											[=, this](const WString& key, const List<IMethodInfo*>& interfaces, const List<Ptr<WfFunctionDeclaration>>& implements)
											{
												if (interfaces.Count() > 1)
												{
													List<ResolveExpressionResult> functions;
													for (auto method : interfaces)
													{
														functions.Add(ResolveExpressionResult::Constructor(method));
														manager->errors.Add(WfErrors::CannotPickOverloadedInterfaceMethods(node, functions));
													}
												}
												if (implements.Count() > 1)
												{
													auto decl = implements[0];
													Ptr<ITypeInfo> methodType = GetFunctionDeclarationType(scope, decl);
													manager->errors.Add(WfErrors::CannotPickOverloadedImplementMethods(decl.Obj(), methodType.Obj()));
												}

												if (interfaces.Count() == 1 && implements.Count() == 1)
												{
													manager->interfaceMethodImpls.Add(implements[0].Obj(), interfaces[0]);
												}
											});
									});
							}
							else
							{
								manager->errors.Add(WfErrors::ClassContainsNoConstructor(node, type.Obj()));
							}
						}

						if (selectedType)
						{
							auto result = ResolveExpressionResult::Constructor(selectedConstructor);
							if (!IsSameType(selectedType.Obj(), type.Obj()))
							{
								manager->errors.Add(WfErrors::ConstructorReturnTypeMismatched(node, result, selectedType.Obj(), type.Obj()));
							}
							results.Add(result);
						}
					}
				}

				void Visit(WfVirtualCfeExpression* node)override
				{
					if (GetExpressionType(manager, node->expandedExpression, expectedType))
					{
						results.Add(manager->expressionResolvings[node->expandedExpression.Obj()]);
					}
				}

				void Visit(WfVirtualCseExpression* node)override
				{
					bool expanded = node->expandedExpression;
					vint errorCount = manager->errors.Count();
					node->Accept((WfVirtualCseExpression::IVisitor*)this);

					if (!expanded && manager->errors.Count() == errorCount)
					{
						ExpandVirtualExpressionVisitor visitor(manager, expectedType);
						node->Accept(&visitor);
						if (!node->expandedExpression)
						{
							return;
						}

						SetCodeRange(node->expandedExpression, node->codeRange);

						auto parentScope = manager->nodeScopes[node];
						if (parentScope->ownerNode == node)
						{
							parentScope = parentScope->parentScope;
						}

						ContextFreeExpressionDesugar(manager, node->expandedExpression);
						BuildScopeForExpression(manager, parentScope, node->expandedExpression);

						manager->checkedScopes_DuplicatedSymbol.Remove(parentScope.Obj());
						manager->checkedScopes_SymbolType.Remove(parentScope.Obj());
						if (!CheckScopes_DuplicatedSymbol(manager) || !CheckScopes_SymbolType(manager))
						{
							return;
						}
					}

					if (node->expandedExpression)
					{
						if (results.Count() == 1)
						{
							GetExpressionType(manager, node->expandedExpression, results[0].type);
						}
						else
						{
							GetExpressionType(manager, node->expandedExpression, nullptr);
						}
					}
				}

				void Visit(WfBindExpression* node)override
				{
					GetExpressionType(manager, node->expression, 0);
					results.Add(ResolveExpressionResult::ReadonlyType(TypeInfoRetriver<Ptr<IValueSubscription>>::CreateTypeInfo()));
				}

				void Visit(WfNewCoroutineExpression* node)override
				{
					Ptr<ITypeInfo> typeInfo = TypeInfoRetriver<Ptr<ICoroutine>>::CreateTypeInfo();
					results.Add(ResolveExpressionResult::ReadonlyType(typeInfo));
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfMixinCastExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					auto type = CreateTypeInfoFromType(scope, node->type);
					auto expressionType = GetExpressionType(manager, node->expression, 0);
					if (type && expressionType)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(type));
						if (expressionType)
						{
							auto fromTd = expressionType->GetTypeDescriptor();
							auto toTd = type->GetTypeDescriptor();
							if ((fromTd->GetTypeDescriptorFlags() & TypeDescriptorFlags::InterfaceType) != TypeDescriptorFlags::Undefined)
							{
								if ((toTd->GetTypeDescriptorFlags() & TypeDescriptorFlags::InterfaceType) != TypeDescriptorFlags::Undefined)
								{
									if (fromTd != toTd && toTd->CanConvertTo(fromTd))
									{
										goto PASS_VALIDATION;
									}
								}
							}
							manager->errors.Add(WfErrors::WrongMixinTargetType(node, type.Obj(), expressionType.Obj()));
						PASS_VALIDATION:;
						}
					}
				}

				void Visit(WfExpectedTypeCastExpression* node)override
				{
					GetExpressionType(manager, node->expression, nullptr);
					if (expectedType)
					{
						results.Add(ResolveExpressionResult::ReadonlyType(expectedType));
					}
					else
					{
						manager->errors.Add(WfErrors::ExpectedTypeCastCannotResolveType(node));
					}
				}

				void Visit(WfCoOperatorExpression* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					auto functionScope = scope->FindFunctionScope();
					if (auto funcDecl = functionScope->ownerNode.Cast<WfFunctionDeclaration>())
					{
						if (funcDecl->statement.Cast<WfCoProviderStatement>())
						{
							auto providerScope = manager->nodeScopes[funcDecl->statement.Obj()];
							auto providerSymbol = providerScope->symbols[L"$PROVIDER"][0];
							auto implSymbol = providerScope->symbols[L"$IMPL"][0];
							if (providerSymbol->typeInfo && implSymbol->typeInfo)
							{
								List<ResolveExpressionResult> methods;
								if (auto group = providerSymbol->typeInfo->GetTypeDescriptor()->GetMethodGroupByName(L"QueryContext", true))
								{
									vint count = group->GetMethodCount();
									for (vint i = 0; i < count; i++)
									{
										auto method = group->GetMethod(i);
										if (method->IsStatic())
										{
											if (method->GetParameterCount() == 1 && IsSameType(implSymbol->typeInfo.Obj(), method->GetParameter(0)->GetType()))
											{
												methods.Add(ResolveExpressionResult::Method(method));
											}
										}
									}
								}

								if (methods.Count() > 1)
								{
									manager->errors.Add(WfErrors::CannotPickOverloadedFunctions(node, methods));
								}
								else if (methods.Count() == 1)
								{
									auto contextType = methods[0].methodInfo->GetReturn();
									SortedList<ITypeDescriptor*> searchedTypes;
									manager->ResolveMember(contextType->GetTypeDescriptor(), node->name.value, false, searchedTypes, results);

									if (results.Count() == 0)
									{
										manager->errors.Add(WfErrors::MemberNotExists(node, contextType->GetTypeDescriptor(), node->name.value));
									}
								}
								else
								{
									manager->errors.Add(WfErrors::CoOperatorNotExists(node, providerSymbol->typeInfo.Obj()));
								}
							}
						}
					}
				}

				static void Execute(WfExpression* expression, WfLexicalScopeManager* manager, Ptr<ITypeInfo> expectedType, List<ResolveExpressionResult>& results)
				{
					ValidateSemanticExpressionVisitor visitor(manager, expectedType, results);
					expression->Accept(&visitor);
				}
			};

/***********************************************************************
IsConstantExpression
***********************************************************************/

			class ValidateConstantExpressionVisitor
				: public empty_visitor::ExpressionVisitor
				, public empty_visitor::VirtualCseExpressionVisitor
			{
			public:
				WfLexicalScopeManager*				manager;
				bool								isConstant = false;

				ValidateConstantExpressionVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				bool Call(Ptr<WfExpression> node)
				{
					bool cache = isConstant;
					isConstant = false;
					node->Accept(this);
					bool result = isConstant;
					isConstant = cache;
					return result;
				}

				void VisitReferenceExpression(WfExpression* node, const WString& name)
				{
					auto result = manager->expressionResolvings[node];
					if (auto enumType = result.type->GetTypeDescriptor()->GetEnumType())
					{
						vint index = enumType->IndexOfItem(name);
						if (index != -1)
						{
							isConstant = true;
						}
					}
				}

				void Dispatch(WfVirtualCfeExpression* node)override
				{
					node->expandedExpression->Accept(this);
				}

				void Dispatch(WfVirtualCseExpression* node)override
				{
					node->Accept((WfVirtualCseExpression::IVisitor*)this);
				}

				void Visit(WfReferenceExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfChildExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfLiteralExpression* node)override
				{
					isConstant = true;
				}

				void Visit(WfFloatingExpression* node)override
				{
					isConstant = true;
				}

				void Visit(WfIntegerExpression* node)override
				{
					isConstant = true;
				}

				void Visit(WfStringExpression* node)override
				{
					isConstant = true;
				}

				/*

				void Visit(WfUnaryExpression* node)override
				{
					isConstant = Call(node->operand);
				}

				void Visit(WfBinaryExpression* node)override
				{
					if (node->op == WfBinaryOperator::FlagAnd || node->op == WfBinaryOperator::FlagOr)
					{
						isConstant = Call(node->first) && Call(node->second);
					}
				}

				void Visit(WfRangeExpression* node)override
				{
					isConstant = Call(node->begin) && Call(node->end);
				}

				void Visit(WfConstructorExpression* node)override
				{
					auto result = manager->expressionResolvings[node];
					bool isStruct = (result.type->GetTypeDescriptor()->GetTypeDescriptorFlags() == TypeDescriptorFlags::Struct);

					for (auto argument : node->arguments)
					{
						if (argument->key && !isStruct)
						{
							if (!Call(argument->key)) return;
						}
						if (argument->value)
						{
							if (!Call(argument->value)) return;
						}
					}
					isConstant = true;
				}

				*/

				void Visit(WfTypeOfTypeExpression* node)override
				{
					isConstant = true;
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					isConstant = true;
				}

				static void Execute(WfExpression* expression, WfLexicalScopeManager* manager, Ptr<ITypeInfo> expectedType)
				{
					if (GetExpressionType(manager, expression, expectedType))
					{
						ValidateConstantExpressionVisitor visitor(manager);
						expression->Accept(&visitor);
						if (!visitor.isConstant)
						{
							manager->errors.Add(WfErrors::ExpressionIsNotConstant(expression));
						}
					}
				}
			};

/***********************************************************************
ValidateSemantic
***********************************************************************/

			void ValidateExpressionSemantic(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results)
			{
				ValidateSemanticExpressionVisitor::Execute(expression, manager, expectedType, results);
				for (vint i = results.Count() - 1; i >= 0; i--)
				{
					auto result = results[i];
					if (result.scopeName && result.scopeName->declarations.Count() > 0)
					{
						List<ResolveExpressionResult> replaces;
						for (auto decl : result.scopeName->declarations)
						{
							vint index = manager->nodeScopes.Keys().IndexOf(decl.Obj());
							if (index == -1) continue;
							auto scope = manager->nodeScopes.Values()[index];
							if (scope->ownerNode == decl)
							{
								scope = scope->parentScope;
							}

							index = scope->symbols.Keys().IndexOf(decl->name.value);
							if (index == -1) continue;
							for (auto symbol : scope->symbols.GetByIndex(index))
							{
								if (symbol->creatorNode == decl && symbol->typeInfo)
								{
									replaces.Add(ResolveExpressionResult::Symbol(symbol));
								}
							}
						}

						if (replaces.Count() > 0)
						{
							results.RemoveAt(i);
							for (auto [replaceResult, index] : indexed(replaces))
							{
								results.Insert(i + index, replaceResult);
							}
						}
					}
				}
			}

			void ValidateExpressionSemantic(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results)
			{
				ValidateExpressionSemantic(manager, expression.Obj(), expectedType, results);
			}

			void ValidateConstantExpression(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				ValidateConstantExpressionVisitor::Execute(expression, manager, expectedType);
			}

			void ValidateConstantExpression(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				ValidateConstantExpressionVisitor::Execute(expression.Obj(), manager, expectedType);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESEMANTIC_STATEMENT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace typeimpl;

/***********************************************************************
ValidateSemantic(Statement)
***********************************************************************/

			class ExpandVirtualStatementVisitor : public Object, public WfVirtualCseStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ExpandVirtualStatementVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfSwitchStatement* node)override
				{
					ExpandSwitchStatement(manager, node);
				}

				void Visit(WfForEachStatement* node)override
				{
					ExpandForEachStatement(manager, node);
				}

				void Visit(WfCoProviderStatement* node)override
				{
					ExpandCoProviderStatement(manager, node);
				}
			};

			class ValidateSemanticStatementVisitor
				: public Object
				, public WfStatement::IVisitor
				, public WfVirtualCseStatement::IVisitor
				, public WfCoroutineStatement::IVisitor
				, public WfStateMachineStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*				manager;

				ValidateSemanticStatementVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
				}

				void Visit(WfContinueStatement* node)override
				{
				}

				void Visit(WfReturnStatement* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					auto functionScope = scope->FindFunctionScope();
					if (auto funcDecl = functionScope->ownerNode.Cast<WfFunctionDeclaration>())
					{
						auto providerStat = funcDecl->statement.Cast<WfCoProviderStatement>();
						if (providerStat && !providerStat->expandedStatement)
						{
							auto providerScope = manager->nodeScopes[funcDecl->statement.Obj()];
							auto providerSymbol = providerScope->symbols[L"$PROVIDER"][0];
							auto implSymbol = providerScope->symbols[L"$IMPL"][0];
							if (providerSymbol->typeInfo && implSymbol->typeInfo)
							{
								if (auto group = providerSymbol->typeInfo->GetTypeDescriptor()->GetMethodGroupByName(L"ReturnAndExit", true))
								{
									List<ResolveExpressionResult> functions;
									vint count = group->GetMethodCount();
									for (vint i = 0; i < count; i++)
									{
										auto method = group->GetMethod(i);
										if (method->IsStatic())
										{
											if (method->GetParameterCount() > 0 && IsSameType(implSymbol->typeInfo.Obj(), method->GetParameter(0)->GetType()))
											{
												functions.Add(ResolveExpressionResult::Method(method));
											}
										}
									}

									if (functions.Count() != 0)
									{
										vint selectedFunctionIndex = -1;
										List<Ptr<WfExpression>> arguments;
										arguments.Add(nullptr);
										if (node->expression)
										{
											arguments.Add(node->expression);
										}
										SelectFunction(manager, node, nullptr, functions, arguments, selectedFunctionIndex);
										if (selectedFunctionIndex != -1)
										{
											manager->coOperatorResolvings.Add(Ptr(node), functions[selectedFunctionIndex]);
										}
									}
									else
									{
										manager->errors.Add(WfErrors::CoOperatorNotExists(node, providerSymbol->typeInfo.Obj()));
									}
								}
								else
								{
									manager->errors.Add(WfErrors::CoOperatorNotExists(node, providerSymbol->typeInfo.Obj()));
								}
							}
						}
						else
						{
							auto returnType = CreateTypeInfoFromType(scope, funcDecl->returnType);
							if (node->expression)
							{
								if (returnType->GetTypeDescriptor() == description::GetTypeDescriptor<void>())
								{
									manager->errors.Add(WfErrors::CannotReturnExpression(node));
								}
								else
								{
									GetExpressionType(manager, node->expression, returnType);
								}
							}
							else if (returnType->GetDecorator() != ITypeInfo::TypeDescriptor || returnType->GetTypeDescriptor() != description::GetTypeDescriptor<void>())
							{
								manager->errors.Add(WfErrors::ReturnMissExpression(node, returnType.Obj()));
							}
						}
					}
					else
					{
						if (node->expression)
						{
							manager->errors.Add(WfErrors::CannotReturnExpression(node));
						}
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					if (type)
					{
						if (type->GetDecorator() != ITypeInfo::RawPtr)
						{
							manager->errors.Add(WfErrors::DeleteNonRawPointer(node, type.Obj()));
						}
					}
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						if (auto type = GetExpressionType(manager, node->expression, nullptr))
						{
							auto stringType = TypeInfoRetriver<WString>::CreateTypeInfo();
							auto exceptionType = TypeInfoRetriver<Ptr<IValueException>>::CreateTypeInfo();
							if (!CanConvertToType(type.Obj(), stringType.Obj(), false) && !CanConvertToType(type.Obj(), exceptionType.Obj(), false))
							{
								manager->errors.Add(WfErrors::ExpressionCannotImplicitlyConvertToType(node->expression.Obj(), type.Obj(), stringType.Obj()));
							}
						}
					}
				}

				void Visit(WfIfStatement* node)override
				{
					if (node->type)
					{
						auto scope = manager->nodeScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0];
						if (!IsNullAcceptableType(symbol->typeInfo.Obj()))
						{
							manager->errors.Add(WfErrors::NullCannotImplicitlyConvertToType(node->expression.Obj(), symbol->typeInfo.Obj()));
						}
						GetExpressionType(manager, node->expression, nullptr);
					}
					else
					{
						Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
						GetExpressionType(manager, node->expression, boolType);
					}
					ValidateStatementSemantic(manager, node->trueBranch);
					if (node->falseBranch)
					{
						ValidateStatementSemantic(manager, node->falseBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					Ptr<ITypeInfo> boolType = TypeInfoRetriver<bool>::CreateTypeInfo();
					GetExpressionType(manager, node->condition, boolType);
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					ValidateStatementSemantic(manager, node->protectedStatement);
					if (node->catchStatement)
					{
						ValidateStatementSemantic(manager, node->catchStatement);
					}
					if (node->finallyStatement)
					{
						ValidateStatementSemantic(manager, node->finallyStatement);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					for (auto statement : node->statements)
					{
						ValidateStatementSemantic(manager, statement);
					}
				}

				void Visit(WfGotoStatement* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					vint counter = 0;
					while (scope && !scope->functionConfig)
					{
						if (auto block = scope->ownerNode.Cast<WfBlockStatement>())
						{
							if (block->endLabel.value == node->label.value)
							{
								counter++;
							}
						}
						scope = scope->parentScope.Obj();
					}

					if (counter == 0)
					{
						manager->errors.Add(WfErrors::GotoLabelNotExists(node));
					}
					else if (counter > 1)
					{
						manager->errors.Add(WfErrors::TooManyGotoLabel(node));
					}
				}

				void Visit(WfExpressionStatement* node)override
				{
					GetExpressionType(manager, node->expression, 0);
				}

				void Visit(WfVariableStatement* node)override
				{
					ValidateDeclarationSemantic(manager, node->variable);
				}

				void Visit(WfVirtualCseStatement* node)override
				{
					bool expanded = node->expandedStatement;
					vint errorCount = manager->errors.Count();
					node->Accept((WfVirtualCseStatement::IVisitor*)this);

					if (!expanded && manager->errors.Count() == errorCount)
					{
						ExpandVirtualStatementVisitor visitor(manager);
						node->Accept(&visitor);
						SetCodeRange(node->expandedStatement, node->codeRange);

						auto parentScope = manager->nodeScopes[node];
						if (parentScope->ownerNode == node)
						{
							parentScope = parentScope->parentScope;
						}

						ContextFreeStatementDesugar(manager, node->expandedStatement);
						BuildScopeForStatement(manager, parentScope, node->expandedStatement);

						manager->checkedScopes_DuplicatedSymbol.Remove(parentScope.Obj());
						manager->checkedScopes_SymbolType.Remove(parentScope.Obj());
						if (!CheckScopes_DuplicatedSymbol(manager) || !CheckScopes_SymbolType(manager))
						{
							return;
						}
					}

					if (node->expandedStatement)
					{
						ValidateStatementSemantic(manager, node->expandedStatement);
					}
				}

				void Visit(WfSwitchStatement* node)override
				{
					Ptr<ITypeInfo> type = GetExpressionType(manager, node->expression, 0);
					for (auto switchCase : node->caseBranches)
					{
						Ptr<ITypeInfo> caseType;
						if (IsExpressionDependOnExpectedType(manager, switchCase->expression, type))
						{
							caseType = GetExpressionType(manager, switchCase->expression, type);
						}
						else
						{
							caseType = GetExpressionType(manager, switchCase->expression, 0);
						}

						if (type && caseType)
						{
							if (!GetMergedType(type, caseType))
							{
								manager->errors.Add(WfErrors::CannotMergeTwoType(switchCase->expression.Obj(), type.Obj(), caseType.Obj()));
							}
						}
						ValidateStatementSemantic(manager, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						ValidateStatementSemantic(manager, node->defaultBranch);
					}
				}

				void Visit(WfForEachStatement* node)override
				{
					Ptr<ITypeInfo> elementType = GetEnumerableExpressionItemType(manager, node->collection, 0);
					if (elementType)
					{
						auto scope = manager->nodeScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0];
						symbol->typeInfo = elementType;
						symbol->type = GetTypeFromTypeInfo(elementType.Obj());
					}
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfCoProviderStatement* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					auto providerSymbol = scope->symbols[L"$PROVIDER"][0];
					auto implSymbol = scope->symbols[L"$IMPL"][0];
					Ptr<ITypeInfo> funcReturnType;
					{
						auto decl = scope->parentScope->ownerNode.Cast<WfFunctionDeclaration>();
						funcReturnType = CreateTypeInfoFromType(scope->parentScope.Obj(), decl->returnType);
					}
					ITypeDescriptor* selectedProviderTd = nullptr;
					List<WString> candidates;

					if (node->name.value == L"")
					{
						if (funcReturnType)
						{
							List<ITypeDescriptor*> unprocessed;
							unprocessed.Add(funcReturnType->GetTypeDescriptor());

							for (vint i = 0; i < unprocessed.Count(); i++)
							{
								auto td = unprocessed[i];
								auto candidate = td->GetTypeName() + L"Coroutine";
								if ((selectedProviderTd = description::GetTypeDescriptor(candidate)))
								{
									break;
								}
								else
								{
									candidates.Add(candidate);
								}

								vint count = td->GetBaseTypeDescriptorCount();
								for (vint i = 0; i < count; i++)
								{
									auto baseTd = td->GetBaseTypeDescriptor(i);
									if (!unprocessed.Contains(baseTd))
									{
										unprocessed.Add(baseTd);
									}
								}
							}
						}
					}
					else
					{
						List<ResolveExpressionResult> results, resolveResults;
						auto providerName = node->name.value.Right(node->name.value.Length() - 1);

						if (manager->ResolveName(scope, providerName, resolveResults))
						{
							CopyFrom(results, resolveResults);

							for (vint i = results.Count() - 1; i >= 0; i--)
							{
								auto& result = results[i];
								ITypeDescriptor* providerTd = nullptr;

								if (result.scopeName && result.scopeName->typeDescriptor)
								{
									auto candidate = result.scopeName->typeDescriptor->GetTypeName() + L"Coroutine";
									providerTd = description::GetTypeDescriptor(candidate);
									if (providerTd)
									{
										selectedProviderTd = providerTd;
									}
									else
									{
										candidates.Add(candidate);
									}
								}

								if (!providerTd)
								{
									results.RemoveAt(i);
								}
							}

							if (results.Count() == 1)
							{
								goto FINISH_SEARCHING;
							}
							else if (results.Count() > 1)
							{
								manager->errors.Add(WfErrors::TooManyTargets(node, resolveResults, providerName));
								goto SKIP_SEARCHING;
							}
						}

						resolveResults.Clear();
						if (manager->ResolveName(scope, providerName + L"Coroutine", resolveResults))
						{
							CopyFrom(results, resolveResults);

							for (vint i = results.Count() - 1; i >= 0; i--)
							{
								auto& result = results[i];

								if (result.scopeName && result.scopeName->typeDescriptor)
								{
									selectedProviderTd = result.scopeName->typeDescriptor;
								}
								else
								{
									results.RemoveAt(i);
								}
							}

							if (results.Count() == 1)
							{
								goto FINISH_SEARCHING;
							}
							else if (results.Count() > 1)
							{
								manager->errors.Add(WfErrors::TooManyTargets(node, resolveResults, providerName));
								goto SKIP_SEARCHING;
							}
						}

						candidates.Add(providerName);
						candidates.Add(providerName + L"Coroutine");
					}

				FINISH_SEARCHING:
					if (selectedProviderTd)
					{
						providerSymbol->typeInfo = Ptr(new TypeDescriptorTypeInfo(selectedProviderTd, TypeInfoHint::Normal));

						if (funcReturnType)
						{
							WString creatorName;
							if (funcReturnType->GetTypeDescriptor() == description::GetTypeDescriptor<void>())
							{
								creatorName = L"CreateAndRun";
							}
							else
							{
								creatorName = L"Create";
							}

							if (auto group = selectedProviderTd->GetMethodGroupByName(creatorName, true))
							{
								List<ResolveExpressionResult> results;
								ITypeInfo* selectedImplType = nullptr;
								IMethodInfo* selectedCreator = nullptr;
								vint count = group->GetMethodCount();

								for (vint i = 0; i < count; i++)
								{
									auto method = group->GetMethod(i);
									if (method->IsStatic())
									{
										if (method->GetParameterCount() == 1)
										{
											auto creatorType = method->GetParameter(0)->GetType();
											if (creatorType->GetDecorator() == ITypeInfo::SharedPtr)
											{
												auto functionType = creatorType->GetElementType();
												if (functionType->GetDecorator() == ITypeInfo::Generic &&
													functionType->GetGenericArgumentCount() == 2 &&
													functionType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueFunctionProxy>()
													)
												{
													auto returnType = functionType->GetGenericArgument(0);
													if (returnType->GetDecorator() == ITypeInfo::SharedPtr &&returnType->GetTypeDescriptor() == description::GetTypeDescriptor<ICoroutine>())
													{
														selectedImplType = functionType->GetGenericArgument(1);
														selectedCreator = method;
														results.Add(ResolveExpressionResult::Method(method));
													}
												}
											}
										}
									}
								}

								if (results.Count() == 1)
								{
									implSymbol->typeInfo = CopyTypeInfo(selectedImplType);
									manager->coProviderResolvings.Add(Ptr(node), ResolveExpressionResult::Method(selectedCreator));
								}
								else if (results.Count() > 1)
								{
									manager->errors.Add(WfErrors::TooManyTargets(node, results, creatorName));
								}
							}

							if (!implSymbol->typeInfo)
							{
								if (funcReturnType->GetTypeDescriptor() == description::GetTypeDescriptor<void>())
								{
									manager->errors.Add(WfErrors::CoProviderCreateAndRunNotExists(node, providerSymbol->typeInfo.Obj()));
								}
								else
								{
									manager->errors.Add(WfErrors::CoProviderCreateNotExists(node, providerSymbol->typeInfo.Obj()));
								}
							}
						}
					}
					else
					{
						manager->errors.Add(WfErrors::CoProviderNotExists(node, candidates));
					}
				SKIP_SEARCHING:
					ValidateStatementSemantic(manager, node->statement);
				}

				void Visit(WfCoroutineStatement* node)override
				{
					node->Accept((WfCoroutineStatement::IVisitor*)this);
				}

				void Visit(WfCoPauseStatement* node)override
				{
					if (node->statement)
					{
						ValidateStatementSemantic(manager, node->statement);
					}
				}

				void Visit(WfCoOperatorStatement* node)override
				{
					auto scope = manager->nodeScopes[node].Obj();
					auto functionScope = scope->FindFunctionScope();
					if (auto funcDecl = functionScope->ownerNode.Cast<WfFunctionDeclaration>())
					{
						if (funcDecl->statement.Cast<WfCoProviderStatement>())
						{
							auto providerScope = manager->nodeScopes[funcDecl->statement.Obj()];
							auto providerSymbol = providerScope->symbols[L"$PROVIDER"][0];
							auto implSymbol = providerScope->symbols[L"$IMPL"][0];
							if (providerSymbol->typeInfo && implSymbol->typeInfo)
							{
								List<IMethodGroupInfo*> groups;
								auto operatorName = node->opName.value.Right(node->opName.value.Length() - 1);
								if (auto group = providerSymbol->typeInfo->GetTypeDescriptor()->GetMethodGroupByName(operatorName + L"AndRead", true))
								{
									groups.Add(group);
								}
								if (node->varName.value == L"")
								{
									if (auto group = providerSymbol->typeInfo->GetTypeDescriptor()->GetMethodGroupByName(operatorName + L"AndPause", true))
									{
										groups.Add(group);
									}
								}

								List<ResolveExpressionResult> functions;
								for (auto group : groups)
								{
									vint count = group->GetMethodCount();
									for (vint i = 0; i < count; i++)
									{
										auto method = group->GetMethod(i);
										if (method->IsStatic())
										{
											if (method->GetParameterCount() > 0 && IsSameType(implSymbol->typeInfo.Obj(), method->GetParameter(0)->GetType()))
											{
												functions.Add(ResolveExpressionResult::Method(method));
											}
										}
									}
								}

								if (functions.Count() == 0)
								{
									manager->errors.Add(WfErrors::CoOperatorNotExists(node, providerSymbol->typeInfo.Obj()));
								}
								else
								{
									vint selectedFunctionIndex = -1;
									vint oldErrorCount = manager->errors.Count();
									List<Ptr<WfExpression>> arguments;
									arguments.Add(nullptr);
									CopyFrom(arguments, node->arguments, true);
									SelectFunction(manager, node, nullptr, functions, arguments, selectedFunctionIndex);
									if (selectedFunctionIndex != -1)
									{
										manager->coOperatorResolvings.Add(Ptr(node), functions[selectedFunctionIndex]);
										if (node->varName.value != L"" && manager->errors.Count() == oldErrorCount)
										{
											auto symbol = scope->symbols[node->varName.value][0];
											List<ITypeInfo*> types;

											for (auto argument : node->arguments)
											{
												vint index = manager->expressionResolvings.Keys().IndexOf(argument.Obj());
												if (index != -1)
												{
													auto type = manager->expressionResolvings.Values()[index].type;
													if (!types.Contains(type.Obj()))
													{
														types.Add(type.Obj());
														if (auto group = type->GetTypeDescriptor()->GetMethodGroupByName(L"CastResult", true))
														{
															vint count = group->GetMethodCount();
															for (vint i = 0; i < count; i++)
															{
																auto method = group->GetMethod(i);
																if (method->IsStatic())
																{
																	if (method->GetParameterCount() == 1 &&
																		method->GetParameter(0)->GetType()->GetTypeDescriptor() == description::GetTypeDescriptor<Value>() &&
																		method->GetReturn()->GetTypeDescriptor() != description::GetTypeDescriptor<void>()
																		)
																	{
																		manager->coCastResultResolvings.Add(Ptr(node), ResolveExpressionResult::Method(method));
																		symbol->typeInfo = CopyTypeInfo(method->GetReturn());
																		break;
																	}
																}
															}
														}
													}
												}
											}

											if (!symbol->typeInfo)
											{
												manager->errors.Add(WfErrors::CoOperatorCannotResolveResultType(node, types));
											}
										}
									}
								}
							}
						}
					}
				}

				void Visit(WfStateMachineStatement* node)override
				{
					node->Accept((WfStateMachineStatement::IVisitor*)this);
				}

				void Visit(WfStateSwitchStatement* node)override
				{
					auto smcScope = manager->nodeScopes[node]->FindFunctionScope()->parentScope.Obj();
					CHECK_ERROR(smcScope->ownerNode.Cast<WfClassDeclaration>(), L"ValidateSemanticStatementVisitor::Visit(WfStateSwitchStatement*)#ValidateStatementStructure should check state machine statements' location.");

					for (auto switchCase : node->caseBranches)
					{
						auto caseScope = manager->nodeScopes[switchCase.Obj()].Obj();
						Ptr<WfLexicalSymbol> inputSymbol;
						{
							vint index = smcScope->symbols.Keys().IndexOf(switchCase->name.value);
							if (index != -1)
							{
								inputSymbol = smcScope->symbols.GetByIndex(index)[0];
							}
						}
						if (!inputSymbol || !inputSymbol->creatorNode.Cast<WfStateInput>())
						{
							manager->errors.Add(WfErrors::StateInputNotExists(switchCase.Obj()));
						}
						else
						{
							auto td = manager->declarationTypes[smcScope->ownerNode.Cast<WfClassDeclaration>().Obj()].Obj();
							auto inputMethod = td->GetMethodGroupByName(switchCase->name.value, false)->GetMethod(0);
							if (switchCase->arguments.Count() != inputMethod->GetParameterCount())
							{
								manager->errors.Add(WfErrors::StateSwitchArgumentCountNotMatch(switchCase.Obj()));
							}
							else
							{
								for (auto [argument, index] : indexed(switchCase->arguments))
								{
									auto argumentSymbol = caseScope->symbols[argument->name.value][0];
									argumentSymbol->typeInfo = CopyTypeInfo(inputMethod->GetParameter(index)->GetType());
									argumentSymbol->type = GetTypeFromTypeInfo(argumentSymbol->typeInfo.Obj());
								}
							}
						}

						ValidateStatementSemantic(manager, switchCase->statement);
					}
				}

				void Visit(WfStateInvokeStatement* node)override
				{
					auto smcScope = manager->nodeScopes[node]->FindFunctionScope()->parentScope.Obj();
					CHECK_ERROR(smcScope->ownerNode.Cast<WfClassDeclaration>(), L"ValidateSemanticStatementVisitor::Visit(WfStateSwitchStatement*)#ValidateStatementStructure should check state machine statements' location.");

					Ptr<WfLexicalSymbol> stateSymbol;
					{
						vint index = smcScope->symbols.Keys().IndexOf(node->name.value);
						if (index != -1)
						{
							stateSymbol = smcScope->symbols.GetByIndex(index)[0];
						}
					}
					if (!stateSymbol || !stateSymbol->creatorNode.Cast<WfStateDeclaration>())
					{
						manager->errors.Add(WfErrors::StateNotExists(node));
					}
					else
					{
						auto stateDecl = stateSymbol->creatorNode.Cast<WfStateDeclaration>();
						if (stateDecl->arguments.Count() != node->arguments.Count())
						{
							manager->errors.Add(WfErrors::StateArgumentCountNotMatch(node));
						}
						else
						{
							auto stateScope = manager->nodeScopes[stateDecl.Obj()];
							for (auto [argument, index] : indexed(node->arguments))
							{
								auto typeInfo = stateScope->symbols[stateDecl->arguments[index]->name.value][0]->typeInfo;
								GetExpressionType(manager, argument, typeInfo);
							}
						}
					}
				}

				static void Execute(WfStatement* statement, WfLexicalScopeManager* manager)
				{
					ValidateSemanticStatementVisitor visitor(manager);
					statement->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateSemantic
***********************************************************************/

			void ValidateStatementSemantic(WfLexicalScopeManager* manager, WfStatement* statement)
			{
				return ValidateSemanticStatementVisitor::Execute(statement, manager);
			}

			void ValidateStatementSemantic(WfLexicalScopeManager* manager, Ptr<WfStatement> statement)
			{
				return ValidateSemanticStatementVisitor::Execute(statement.Obj(), manager);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESTRUCTURE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;

/***********************************************************************
ValidateStructureContext
***********************************************************************/

			ValidateStructureContext::ValidateStructureContext()
				:currentBindExpression(0)
				, currentObserveExpression(0)
				, currentLoopStatement(0)
				, currentCatchStatement(0)
			{
			}

/***********************************************************************
ValidateStructure
***********************************************************************/

			void ValidateModuleStructure(WfLexicalScopeManager* manager, Ptr<WfModule> module)
			{
				for (auto path : module->paths)
				{
					for (auto [item, index] : indexed(path->items))
					{
						vint counter = 0;
						for (auto fragment : item->fragments)
						{
							if (fragment.Cast<WfModuleUsingWildCardFragment>())
							{
								if (index == path->items.Count() - 1)
								{
									counter++;
								}
								else
								{
									goto USING_PATH_INCORRECT;
								}
							}
						}

						if (index == path->items.Count() - 1 && counter != 1)
						{
							goto USING_PATH_INCORRECT;
						}
					}
					continue;
				USING_PATH_INCORRECT:
					manager->errors.Add(WfErrors::WrongUsingPathWildCard(path.Obj()));
				}
				for (vint i = 0; i < module->declarations.Count(); i++)
				{
					ValidateDeclarationStructure(manager, module->declarations[i]);
				}
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESTRUCTURE_DECLARATION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;

/***********************************************************************
ValidateStructure(Declaration)
***********************************************************************/

			class ValidateStructureDeclarationVisitor
				: public Object
				, public WfDeclaration::IVisitor
				, public WfVirtualCfeDeclaration::IVisitor
				, public WfVirtualCseDeclaration::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				WfClassDeclaration*						classDecl;
				WfExpression*							surroundingLambda;

				ValidateStructureDeclarationVisitor(WfLexicalScopeManager* _manager, WfClassDeclaration* _classDecl, WfExpression* _surroundingLambda)
					:manager(_manager)
					, classDecl(_classDecl)
					, surroundingLambda(_surroundingLambda)
				{
					CHECK_ERROR(!(_classDecl && _surroundingLambda), L"vl::workflow::analyzer::ValidateStructureDeclarationVisitor(WfLexicalScopeManager*, WfClassDeclaration*, WfExpression*)#Both classDecl or surroundingLambda should not exist at the same time.");
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					if (classDecl)
					{
						manager->errors.Add(WfErrors::WrongClassMember(node));
					}

					if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
					{
						manager->errors.Add(WfErrors::WrongDeclarationInInterfaceConstructor(node));
					}

					for (vint i = 0; i < node->declarations.Count(); i++)
					{
						ValidateDeclarationStructure(manager, node->declarations[i]);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (classDecl)
					{
						switch (classDecl->kind)
						{
						case WfClassKind::Class:
							{
								switch (node->functionKind)
								{
								case WfFunctionKind::Normal:
								case WfFunctionKind::Static:
									if (!node->statement)
									{
										manager->errors.Add(WfErrors::FunctionShouldHaveImplementation(node));
									}
									break;
								case WfFunctionKind::Override:
									manager->errors.Add(WfErrors::OverrideShouldImplementInterfaceMethod(node));
									break;
								default:;
								}
							}
							break;
						case WfClassKind::Interface:
							{
								switch (node->functionKind)
								{
								case WfFunctionKind::Normal:
									if (node->statement)
									{
										manager->errors.Add(WfErrors::InterfaceMethodShouldNotHaveImplementation(node));
									}
									break;
								case WfFunctionKind::Static:
									if (!node->statement)
									{
										manager->errors.Add(WfErrors::FunctionShouldHaveImplementation(node));
									}
									break;
								case WfFunctionKind::Override:
									manager->errors.Add(WfErrors::OverrideShouldImplementInterfaceMethod(node));
									break;
								default:;
								}
							}
							break;
						default:;
						}
					}
					else
					{
						if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
						{
							switch (node->functionKind)
							{
							case WfFunctionKind::Normal:
								break;
							case WfFunctionKind::Static:
								manager->errors.Add(WfErrors::FunctionInNewTypeExpressionCannotBeStatic(node));
								break;
							case WfFunctionKind::Override:
								break;
							default:;
							}
						}
						if (!node->statement)
						{
							manager->errors.Add(WfErrors::FunctionShouldHaveImplementation(node));
						}
					}

					if (node->anonymity == WfFunctionAnonymity::Anonymous)
					{
						if (!dynamic_cast<WfFunctionExpression*>(surroundingLambda))
						{
							manager->errors.Add(WfErrors::FunctionShouldHaveName(node));
						}
					}


					ValidateTypeStructure(manager, node->returnType, ValidateTypeStragety::ReturnType);
					for (auto argument : node->arguments)
					{
						ValidateTypeStructure(manager, argument->type);
					}

					if (node->statement)
					{
						ValidateStructureContext context;
						ValidateStatementStructure(manager, &context, node->statement);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					else if (classDecl)
					{
						manager->errors.Add(WfErrors::MissingFieldType(node));
					}
					ValidateStructureContext context;
					ValidateExpressionStructure(manager, &context, node->expression);
				}

				void Visit(WfEventDeclaration* node)override
				{
					if (classDecl)
					{
						for (auto argument : node->arguments)
						{
							ValidateTypeStructure(manager, argument);
						}
					}
					else if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
					{
						manager->errors.Add(WfErrors::WrongDeclarationInInterfaceConstructor(node));
					}
					else
					{
						manager->errors.Add(WfErrors::WrongDeclaration(node));
					}
				}

				class FindPropertyRelatedDeclVisitor
					: public empty_visitor::DeclarationVisitor
					, public empty_visitor::VirtualCseDeclarationVisitor
				{
				public:
					WfLexicalScopeManager*				manager;
					WfClassDeclaration*					classDecl;
					WfPropertyDeclaration*				propDecl;
					Ptr<WfDeclaration>					getter;
					Ptr<WfDeclaration>					setter;
					Ptr<WfDeclaration>					valueChangedEvent;
					bool								duplicateGetter = false;
					bool								duplicateSetter = false;
					bool								duplicateEvent = false;

					FindPropertyRelatedDeclVisitor(WfLexicalScopeManager* _manager, WfClassDeclaration* _classDecl, WfPropertyDeclaration* _propDecl)
						:manager(_manager)
						, classDecl(_classDecl)
						, propDecl(_propDecl)
					{
					}

					void Dispatch(WfVirtualCfeDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							Execute(decl);
						}
					}

					void Dispatch(WfVirtualCseDeclaration* node)override
					{
						node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
					}

					void Execute(Ptr<WfDeclaration> memberDecl)
					{
						memberDecl->Accept(this);
						if (!duplicateGetter && memberDecl->name.value == propDecl->getter.value)
						{
							if (getter)
							{
								duplicateGetter = true;
								manager->errors.Add(WfErrors::TooManyPropertyGetter(propDecl, classDecl));
							}
							else
							{
								getter = memberDecl;
							}
						}

						if (!duplicateSetter && propDecl->setter.value != L"" && memberDecl->name.value == propDecl->setter.value)
						{
							if (setter)
							{
								duplicateSetter = true;
								manager->errors.Add(WfErrors::TooManyPropertySetter(propDecl, classDecl));
							}
							else
							{
								setter = memberDecl;
							}
						}

						if (!duplicateEvent && propDecl->valueChangedEvent.value != L"" && memberDecl->name.value == propDecl->valueChangedEvent.value)
						{
							if (valueChangedEvent)
							{
								duplicateEvent = true;
								manager->errors.Add(WfErrors::TooManyPropertyEvent(propDecl, classDecl));
							}
							else
							{
								valueChangedEvent = memberDecl;
							}
						}
					}
				};

				void Visit(WfPropertyDeclaration* node)override
				{
					if (classDecl)
					{
						ValidateTypeStructure(manager, node->type);
						FindPropertyRelatedDeclVisitor visitor(manager, classDecl, node);

						for (auto memberDecl : classDecl->declarations)
						{
							visitor.Execute(memberDecl);
						}

						if (auto getter = visitor.getter.Cast<WfFunctionDeclaration>())
						{
							if (getter->functionKind == WfFunctionKind::Static)
							{
								manager->errors.Add(WfErrors::PropertyGetterNotFound(node, classDecl));
							}
						}
						else
						{
							manager->errors.Add(WfErrors::PropertyGetterNotFound(node, classDecl));
						}

						if (node->setter.value != L"")
						{
							if (auto setter = visitor.setter.Cast<WfFunctionDeclaration>())
							{
								if (setter->functionKind == WfFunctionKind::Static)
								{
									manager->errors.Add(WfErrors::PropertyGetterNotFound(node, classDecl));
								}
							}
							else
							{
								manager->errors.Add(WfErrors::PropertyGetterNotFound(node, classDecl));
							}
						}

						if (node->valueChangedEvent.value != L"" && (!visitor.valueChangedEvent || !visitor.valueChangedEvent.Cast<WfEventDeclaration>()))
						{
							manager->errors.Add(WfErrors::PropertyEventNotFound(node, classDecl));
						}
					}
					else if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
					{
						manager->errors.Add(WfErrors::WrongDeclarationInInterfaceConstructor(node));
					}
					else
					{
						manager->errors.Add(WfErrors::WrongDeclaration(node));
					}
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
					if (classDecl)
					{
						manager->errors.Add(WfErrors::WrongDeclaration(node));
					}
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					if (classDecl)
					{
						if (classDecl->kind != WfClassKind::Class)
						{
							manager->errors.Add(WfErrors::WrongDeclaration(node));
						}

						for (auto call : node->baseConstructorCalls)
						{
							ValidateTypeStructure(manager, call->type, ValidateTypeStragety::BaseType, classDecl);
							for (auto argument : call->arguments)
							{
								ValidateStructureContext context;
								ValidateExpressionStructure(manager, &context, argument);
							}
						}
						{
							ValidateStructureContext context;
							ValidateStatementStructure(manager, &context, node->statement);
						}
					}
					else
					{
						manager->errors.Add(WfErrors::WrongDeclaration(node));
					}
				}

				void Visit(WfDestructorDeclaration* node)override
				{
					if (classDecl)
					{
						if (classDecl->kind != WfClassKind::Class)
						{
							manager->errors.Add(WfErrors::WrongDeclaration(node));
						}

						ValidateStructureContext context;
						ValidateStatementStructure(manager, &context, node->statement);
					}
					else
					{
						manager->errors.Add(WfErrors::WrongDeclaration(node));
					}
				}

				class FindCtorVisitor
					: public empty_visitor::DeclarationVisitor
					, public empty_visitor::VirtualCseDeclarationVisitor
				{
				public:
					WfConstructorDeclaration*			ctor = nullptr;

					void Dispatch(WfVirtualCfeDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							decl->Accept(this);
						}
					}

					void Dispatch(WfVirtualCseDeclaration* node)override
					{
						node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
					}

					void Visit(WfConstructorDeclaration* node)override
					{
						ctor = node;
					}
				};

				class TooManyDtorVisitor
					: public empty_visitor::DeclarationVisitor
					, public empty_visitor::VirtualCseDeclarationVisitor
				{
				public:
					WfLexicalScopeManager*				manager;
					WfClassDeclaration*					classDecl;
					WfDestructorDeclaration*			dtor = nullptr;

					TooManyDtorVisitor(WfLexicalScopeManager* _manager, WfClassDeclaration* _classDecl)
						:manager(_manager)
						, classDecl(_classDecl)
					{
					}

					void Dispatch(WfVirtualCfeDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							decl->Accept(this);
						}
					}

					void Dispatch(WfVirtualCseDeclaration* node)override
					{
						node->Accept((WfVirtualCseDeclaration::IVisitor*)this);
					}

					void Visit(WfDestructorDeclaration* node)override
					{
						if (!dtor)
						{
							dtor = node;
						}
						else
						{
							manager->errors.Add(WfErrors::TooManyDestructor(node, classDecl));
						}
					}
				};

				void Visit(WfClassDeclaration* node)override
				{
					if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
					{
						manager->errors.Add(WfErrors::WrongDeclarationInInterfaceConstructor(node));
					}

					switch (node->kind)
					{
					case WfClassKind::Class:
						{
							if (node->constructorType != WfConstructorType::Undefined)
							{
								manager->errors.Add(WfErrors::ClassWithInterfaceConstructor(node));
							}
							{
								FindCtorVisitor visitor;
								for (auto memberDecl : node->declarations)
								{
									memberDecl->Accept(&visitor);
								}

								if (!visitor.ctor)
								{
									auto ctor = Ptr(new WfConstructorDeclaration);
									node->declarations.Add(ctor);
									ctor->codeRange = node->codeRange;
									ctor->constructorType = WfConstructorType::SharedPtr;

									auto stat = Ptr(new WfBlockStatement);
									ctor->statement = stat;
									stat->codeRange = node->codeRange;
								}
							}
						}
						break;
					default:;
					}

					for (auto type : node->baseTypes)
					{
						ValidateTypeStructure(manager, type, ValidateTypeStragety::BaseType, node);
					}

					{
						TooManyDtorVisitor visitor(manager, node);
						bool hasStateMachine = false;
						for (auto memberDecl : node->declarations)
						{
							if (auto smDecl = memberDecl.Cast<WfStateMachineDeclaration>())
							{
								if (!hasStateMachine)
								{
									hasStateMachine = true;
								}
								else
								{
									manager->errors.Add(WfErrors::DuplicatedDeclaration(smDecl.Obj()));
								}
							}
							ValidateDeclarationStructure(manager, memberDecl, node);
							memberDecl->Accept(&visitor);
						}
					}
				}

				void Visit(WfEnumDeclaration* node)override
				{
					if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
					{
						manager->errors.Add(WfErrors::WrongDeclarationInInterfaceConstructor(node));
					}

					vuint64_t current = 0;
					bool reportedNotConsecutive = false;
					SortedList<WString> discoveredItems;
					for (auto item : node->items)
					{
						switch (item->kind)
						{
						case WfEnumItemKind::Constant:
							{
								vuint64_t value = -1;
								TypedValueSerializerProvider<vuint64_t>::Deserialize(item->number.value, value);
								if (!reportedNotConsecutive && value != current)
								{
									reportedNotConsecutive = true;
									switch (node->kind)
									{
									case WfEnumKind::Normal:
										manager->errors.Add(WfErrors::EnumValuesNotConsecutiveFromZero(node));
										break;
									case WfEnumKind::Flag:
										manager->errors.Add(WfErrors::FlagValuesNotConsecutiveFromZero(node));
										break;
									default:;
									}
								}
								switch (node->kind)
								{
								case WfEnumKind::Normal:
									current++;
									break;
								case WfEnumKind::Flag:
									current = current == 0 ? 1 : current * 2;
									break;
								default:;
								}
							}
							break;
						case WfEnumItemKind::Intersection:
							for (auto enumInt : item->intersections)
							{
								if (!discoveredItems.Contains(enumInt->name.value))
								{
									manager->errors.Add(WfErrors::FlagValueNotExists(enumInt.Obj(), node));
								}
							}
							break;
						default:;
						}

						if (discoveredItems.Contains(item->name.value))
						{
							manager->errors.Add(WfErrors::DuplicatedEnumValue(item.Obj(), node));
						}
						else
						{
							discoveredItems.Add(item->name.value);
						}
					}
				}

				void Visit(WfStructDeclaration* node)override
				{
					if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
					{
						manager->errors.Add(WfErrors::WrongDeclarationInInterfaceConstructor(node));
					}

					SortedList<WString> discoveredItems;
					for (auto member : node->members)
					{
						if (discoveredItems.Contains(member->name.value))
						{
							manager->errors.Add(WfErrors::DuplicatedStructMember(member.Obj(), node));
						}
						else
						{
							discoveredItems.Add(member->name.value);
						}
					}
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					node->Accept(static_cast<WfVirtualCfeDeclaration::IVisitor*>(this));
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfAutoPropertyDeclaration* node)override
				{
					switch (node->functionKind)
					{
					case WfFunctionKind::Normal:
						if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
						{
							manager->errors.Add(WfErrors::AutoPropertyCannotBeNormalOutsideOfClass(node));
						}
						break;
					case WfFunctionKind::Static:
						manager->errors.Add(WfErrors::AutoPropertyCannotBeStatic(node));
						break;
					case WfFunctionKind::Override:
						if (!dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
						{
							manager->errors.Add(WfErrors::OverrideShouldImplementInterfaceMethod(node));
						}
						break;
					default:;
					}

					if (classDecl)
					{
						switch (classDecl->kind)
						{
						case WfClassKind::Class:
							if (!node->expression)
							{
								manager->errors.Add(WfErrors::AutoPropertyShouldBeInitialized(node));
							}
							break;
						case WfClassKind::Interface:
							if (node->expression)
							{
								manager->errors.Add(WfErrors::AutoPropertyCannotBeInitializedInInterface(node, classDecl));
							}
							break;
						default:;
						}
					}
					else if (dynamic_cast<WfNewInterfaceExpression*>(surroundingLambda))
					{
						if (!node->expression)
						{
							manager->errors.Add(WfErrors::AutoPropertyShouldBeInitialized(node));
						}
					}
					else
					{
						manager->errors.Add(WfErrors::WrongDeclaration(node));
					}

					ValidateTypeStructure(manager, node->type);
					if (node->expression)
					{
						ValidateStructureContext context;
						ValidateExpressionStructure(manager, &context, node->expression);
					}
				}

				void Visit(WfCastResultInterfaceDeclaration* node)override
				{
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					node->Accept(static_cast<WfVirtualCseDeclaration::IVisitor*>(this));
				}

				void Visit(WfStateMachineDeclaration* node)override
				{
					if (classDecl)
					{
						for (auto state : node->states)
						{
							ValidateStructureContext context;
							context.currentStateDeclaration = state.Obj();
							ValidateStatementStructure(manager, &context, state->statement);
						}
					}
					else
					{
						manager->errors.Add(WfErrors::WrongDeclaration(node));
					}
				}

				static void Execute(Ptr<WfDeclaration> declaration, WfLexicalScopeManager* manager, WfClassDeclaration* classDecl, WfExpression* surroundingLambda)
				{
					ValidateStructureDeclarationVisitor visitor(manager, classDecl, surroundingLambda);
					declaration->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateStructure
***********************************************************************/

			void ValidateDeclarationStructure(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration, WfClassDeclaration* classDecl, WfExpression* surroundingLambda)
			{
				ValidateStructureDeclarationVisitor::Execute(declaration, manager, classDecl, surroundingLambda);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESTRUCTURE_EXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;

/***********************************************************************
ValidateStructure(Expression)
***********************************************************************/

			class ValidateStructureExpressionVisitor
				: public Object
				, public WfExpression::IVisitor
				, public WfVirtualCseExpression::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ValidateStructureContext*				context;
				Ptr<WfExpression>						result;

				ValidateStructureExpressionVisitor(WfLexicalScopeManager* _manager, ValidateStructureContext* _context)
					:manager(_manager)
					, context(_context)
				{
				}

				void Visit(WfThisExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::WrongThisExpression(node));
					}
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
				}

				void Visit(WfReferenceExpression* node)override
				{
				}

				void Visit(WfOrderedNameExpression* node)override
				{
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					ValidateStructureContext context;
					ValidateExpressionStructure(manager, &context, node->body);
				}

				void Visit(WfMemberExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->parent);
				}

				void Visit(WfChildExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->parent);
				}

				void Visit(WfLiteralExpression* node)override
				{
				}

				void Visit(WfFloatingExpression* node)override
				{
				}

				void Visit(WfIntegerExpression* node)override
				{
				}

				void Visit(WfStringExpression* node)override
				{
				}

				void Visit(WfUnaryExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->operand);
				}

				void Visit(WfBinaryExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->first);
					ValidateExpressionStructure(manager, context, node->second);
				}

				void Visit(WfLetExpression* node)override
				{
					for (auto variable : node->variables)
					{
						ValidateExpressionStructure(manager, context, variable->value);
					}
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfIfExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->condition);
					ValidateExpressionStructure(manager, context, node->trueBranch);
					ValidateExpressionStructure(manager, context, node->falseBranch);
				}

				void Visit(WfRangeExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->begin);
					ValidateExpressionStructure(manager, context, node->end);
				}

				void Visit(WfSetTestingExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->element);
					ValidateExpressionStructure(manager, context, node->collection);
				}

				void Visit(WfConstructorExpression* node)override
				{
					vint listElementCount = 0;
					vint mapElementCount = 0;
					for (auto argument : node->arguments)
					{
						ValidateExpressionStructure(manager, context, argument->key);
						if (argument->value)
						{
							ValidateExpressionStructure(manager, context, argument->value);
							mapElementCount++;
						}
						else
						{
							listElementCount++;
						}
					}

					if (listElementCount*mapElementCount != 0)
					{
						manager->errors.Add(WfErrors::ConstructorMixMapAndList(node));
					}
				}

				void Visit(WfInferExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfAttachEventExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::AttachInBind(node));
					}
					ValidateExpressionStructure(manager, context, node->event);
					ValidateExpressionStructure(manager, context, node->function);
				}

				void Visit(WfDetachEventExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::DetachInBind(node));
					}
					ValidateExpressionStructure(manager, context, node->event);
					ValidateExpressionStructure(manager, context, node->handler);
				}

				void Visit(WfObserveExpression* node)override
				{
					if (!context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::ObserveNotInBind(node));
					}
					if (context->currentObserveExpression)
					{
						manager->errors.Add(WfErrors::ObserveInObserveEvent(node));
					}

					if (node->observeType == WfObserveType::SimpleObserve)
					{
						if (!node->expression.Cast<WfReferenceExpression>())
						{
							manager->errors.Add(WfErrors::WrongSimpleObserveExpression(node->expression.Obj()));
						}
						for (auto event : node->events)
						{
							if (!event.Cast<WfReferenceExpression>())
							{
								manager->errors.Add(WfErrors::WrongSimpleObserveEvent(event.Obj()));
							}
						}
					}
					else if (node->events.Count() == 0)
					{
						manager->errors.Add(WfErrors::EmptyObserveEvent(node));
					}

					ValidateExpressionStructure(manager, context, node->parent);
					ValidateExpressionStructure(manager, context, node->expression);
					context->currentObserveExpression = node;
					for (vint i = 0; i < node->events.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->events[i]);
					}
					context->currentObserveExpression = 0;
				}

				void Visit(WfCallExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->function);
					for (vint i = 0; i < node->arguments.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->arguments[i]);
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					ValidateDeclarationStructure(manager, node->function, nullptr, node);
				}

				void Visit(WfNewClassExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					for (vint i = 0; i < node->arguments.Count(); i++)
					{
						ValidateExpressionStructure(manager, context, node->arguments[i]);
					}
				}

				void Visit(WfNewInterfaceExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					for (auto memberDecl : node->declarations)
					{
						ValidateDeclarationStructure(manager, memberDecl, nullptr, node);
					}
				}

				void Visit(WfVirtualCfeExpression* node)override
				{
					if (node->expandedExpression)
					{
						ValidateExpressionStructure(manager, context, node->expandedExpression);
					}
				}

				void Visit(WfVirtualCseExpression* node)override
				{
					node->Accept((WfVirtualCseExpression::IVisitor*)this);
				}

				void Visit(WfBindExpression* node)override
				{
					if (context->currentBindExpression)
					{
						manager->errors.Add(WfErrors::BindInBind(node));
					}

					auto bind = context->currentBindExpression;
					context->currentBindExpression = node;
					ValidateExpressionStructure(manager, context, node->expression);
					context->currentBindExpression = bind;
				}

				void Visit(WfNewCoroutineExpression* node)override
				{
					ValidateStructureContext context;
					context.currentNewCoroutineExpression = node;
					ValidateStatementStructure(manager, &context, node->statement);
				}

				void Visit(WfMixinCastExpression* node)override
				{
					ValidateTypeStructure(manager, node->type);
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfExpectedTypeCastExpression* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfCoOperatorExpression* node)override
				{
					if (!context->currentCoProviderStatement)
					{
						manager->errors.Add(WfErrors::WrongCoOperator(node));
					}
				}

				static void Execute(Ptr<WfExpression>& expression, WfLexicalScopeManager* manager, ValidateStructureContext* context)
				{
					ValidateStructureExpressionVisitor visitor(manager, context);
					expression->Accept(&visitor);
					if (visitor.result)
					{
						expression = visitor.result;
					}
				}
			};

/***********************************************************************
ValidateStructure
***********************************************************************/

			void ValidateExpressionStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfExpression>& expression)
			{
				ValidateStructureExpressionVisitor::Execute(expression, manager, context);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESTRUCTURE_STATEMENT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;

/***********************************************************************
ValidateStructure(Statement)
***********************************************************************/

			class ValidateStructureStatementVisitor
				: public Object
				, public WfStatement::IVisitor
				, public WfVirtualCseStatement::IVisitor
				, public WfCoroutineStatement::IVisitor
				, public WfStateMachineStatement::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ValidateStructureContext*				context;
				Ptr<WfStatement>						result;

				ValidateStructureStatementVisitor(WfLexicalScopeManager* _manager, ValidateStructureContext* _context)
					:manager(_manager)
					, context(_context)
				{
				}

				void Visit(WfBreakStatement* node)override
				{
					if (!context->currentLoopStatement)
					{
						manager->errors.Add(WfErrors::BreakNotInLoop(node));
					}
				}

				void Visit(WfContinueStatement* node)override
				{
					if (!context->currentLoopStatement)
					{
						manager->errors.Add(WfErrors::ContinueNotInLoop(node));
					}
				}

				void Visit(WfReturnStatement* node)override
				{
					if (node->expression)
					{
						ValidateExpressionStructure(manager, context, node->expression);
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						ValidateExpressionStructure(manager, context, node->expression);
					}
					else if (!context->currentCatchStatement)
					{
						manager->errors.Add(WfErrors::RethrowNotInCatch(node));
					}
				}

				void Visit(WfIfStatement* node)override
				{
					if (node->type)
					{
						ValidateTypeStructure(manager, node->type);
					}
					ValidateExpressionStructure(manager, context, node->expression);
					ValidateStatementStructure(manager, context, node->trueBranch);
					if (node->falseBranch)
					{
						ValidateStatementStructure(manager, context, node->falseBranch);
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					auto oldLoop = context->currentLoopStatement;
					context->currentLoopStatement = node;
					ValidateExpressionStructure(manager, context, node->condition);
					ValidateStatementStructure(manager, context, node->statement);
					context->currentLoopStatement = oldLoop;
				}

				void Visit(WfTryStatement* node)override
				{
					ValidateStatementStructure(manager, context, node->protectedStatement);
					if (node->catchStatement)
					{
						auto oldCatch = context->currentCatchStatement;
						context->currentCatchStatement = node->catchStatement.Obj();
						ValidateStatementStructure(manager, context, node->catchStatement);
						context->currentCatchStatement = oldCatch;
					}
					if (node->finallyStatement)
					{
						ValidateStatementStructure(manager, context, node->finallyStatement);
					}
					if (!node->catchStatement && !node->finallyStatement)
					{
						manager->errors.Add(WfErrors::TryMissCatchAndFinally(node));
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					for (vint i = 0; i < node->statements.Count(); i++)
					{
						ValidateStatementStructure(manager, context, node->statements[i]);
					}
				}

				void Visit(WfGotoStatement* node)override
				{
				}

				void Visit(WfExpressionStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
				}

				void Visit(WfVariableStatement* node)override
				{
					ValidateDeclarationStructure(manager, node->variable);
				}

				void Visit(WfVirtualCseStatement* node)override
				{
					node->Accept((WfVirtualCseStatement::IVisitor*)this);
				}

				void Visit(WfSwitchStatement* node)override
				{
					ValidateExpressionStructure(manager, context, node->expression);
					for (auto switchCase : node->caseBranches)
					{
						ValidateExpressionStructure(manager, context, switchCase->expression);
						ValidateStatementStructure(manager, context, switchCase->statement);
					}
					if (node->defaultBranch)
					{
						ValidateStatementStructure(manager, context, node->defaultBranch);
					}
				}

				void Visit(WfForEachStatement* node)override
				{
					auto oldLoop = context->currentLoopStatement;
					context->currentLoopStatement = node;
					ValidateExpressionStructure(manager, context, node->collection);
					ValidateStatementStructure(manager, context, node->statement);
					context->currentLoopStatement = oldLoop;
				}

				void Visit(WfCoProviderStatement* node)override
				{
					auto oldProvider = context->currentCoProviderStatement;
					context->currentCoProviderStatement = node;
					ValidateStatementStructure(manager, context, node->statement);
					context->currentCoProviderStatement = oldProvider;
				}

				void Visit(WfCoroutineStatement* node)override
				{
					node->Accept((WfCoroutineStatement::IVisitor*)this);
				}

				void Visit(WfCoPauseStatement* node)override
				{
					if (!context->currentNewCoroutineExpression || context->currentCoPauseStatement)
					{
						manager->errors.Add(WfErrors::WrongCoPause(node));
					}
					if (node->statement)
					{
						auto oldCpPause = context->currentCoPauseStatement;
						context->currentCoPauseStatement = node;
						ValidateStatementStructure(manager, context, node->statement);
						context->currentCoPauseStatement = oldCpPause;
					}
				}

				void Visit(WfCoOperatorStatement* node)override
				{
					if (!context->currentCoProviderStatement)
					{
						manager->errors.Add(WfErrors::WrongCoOperator(node));
					}
				}

				void Visit(WfStateMachineStatement* node)override
				{
					node->Accept((WfStateMachineStatement::IVisitor*)this);
				}

				void Visit(WfStateSwitchStatement* node)override
				{
					if (!context->currentStateDeclaration)
					{
						manager->errors.Add(WfErrors::WrongStateSwitchStatement(node));
					}

					for (auto switchCase : node->caseBranches)
					{
						ValidateStatementStructure(manager, context, switchCase->statement);
					}
				}

				void Visit(WfStateInvokeStatement* node)override
				{
					if (!context->currentStateDeclaration)
					{
						manager->errors.Add(WfErrors::WrongStateInvokeStatement(node));
					}

					for (auto argument : node->arguments)
					{
						ValidateExpressionStructure(manager, context, argument);
					}
				}

				static void Execute(Ptr<WfStatement>& statement, WfLexicalScopeManager* manager, ValidateStructureContext* context)
				{
					ValidateStructureStatementVisitor visitor(manager, context);
					statement->Accept(&visitor);
					if (visitor.result)
					{
						statement = visitor.result;
					}
				}
			};

/***********************************************************************
ValidateStructure
***********************************************************************/

			void ValidateStatementStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfStatement>& statement)
			{
				ValidateStructureStatementVisitor::Execute(statement, manager, context);
			}
		}
	}
}


/***********************************************************************
.\ANALYZER\WFANALYZER_VALIDATESTRUCTURE_TYPE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			using namespace collections;
			using namespace reflection::description;

/***********************************************************************
ValidateStructure(Type)
***********************************************************************/

			class ValidateReferenceTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				bool									result;

				ValidateReferenceTypeVisitor(WfLexicalScopeManager* _manager)
					:manager(_manager)
					, result(true)
				{
				}
				
				void Visit(WfPredefinedType* node)override
				{
				}

				void Visit(WfTopQualifiedType* node)override
				{
				}

				void Visit(WfReferenceType* node)override
				{
				}

				void Visit(WfRawPointerType* node)override
				{
					result = false;
				}

				void Visit(WfSharedPointerType* node)override
				{
					result = false;
				}

				void Visit(WfNullableType* node)override
				{
					result = false;
				}

				void Visit(WfEnumerableType* node)override
				{
					result = false;
				}

				void Visit(WfMapType* node)override
				{
					result = false;
				}

				void Visit(WfObservableListType* node)override
				{
					result = false;
				}

				void Visit(WfFunctionType* node)override
				{
					result = false;
				}

				void Visit(WfChildType* node)override
				{
					node->parent->Accept(this);
				}

				static bool Execute(Ptr<WfType> type, WfLexicalScopeManager* manager)
				{
					ValidateReferenceTypeVisitor visitor(manager);
					type->Accept(&visitor);
					return visitor.result;
				}
			};

			class ValidateStructureTypeVisitor : public Object, public WfType::IVisitor
			{
			public:
				WfLexicalScopeManager*					manager;
				ValidateTypeStragety					strategy;
				WfClassDeclaration*						classDecl;

				ValidateStructureTypeVisitor(WfLexicalScopeManager* _manager, ValidateTypeStragety _strategy, WfClassDeclaration* _classDecl)
					:manager(_manager)
					, strategy(_strategy)
					, classDecl(_classDecl)
				{
				}
				
				void Visit(WfPredefinedType* node)override
				{
					switch (node->name)
					{
					case WfPredefinedTypeName::Void:
						switch (strategy)
						{
						case ValidateTypeStragety::Value:
							manager->errors.Add(WfErrors::WrongVoidType(node));
							break;
						case ValidateTypeStragety::BaseType:
							manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
						default:;
						}
						break;
					case WfPredefinedTypeName::Interface:
						switch (strategy)
						{
						case ValidateTypeStragety::ReturnType:
						case ValidateTypeStragety::Value:
							manager->errors.Add(WfErrors::WrongInterfaceType(node));
							break;
						default:;
						}
					default:;
					}
				}

				void Visit(WfTopQualifiedType* node)override
				{
				}

				void Visit(WfReferenceType* node)override
				{
				}

				void Visit(WfRawPointerType* node)override
				{
					if (strategy == ValidateTypeStragety::BaseType)
					{
						manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
					}

					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						if (predefinedType->name != WfPredefinedTypeName::Interface)
						{
							manager->errors.Add(WfErrors::RawPointerToNonReferenceType(node));
						}
					}
				}

				void Visit(WfSharedPointerType* node)override
				{
					if (strategy == ValidateTypeStragety::BaseType)
					{
						manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
					}

					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						if (predefinedType->name != WfPredefinedTypeName::Interface)
						{
							manager->errors.Add(WfErrors::SharedPointerToNonReferenceType(node));
						}
					}
				}

				void Visit(WfNullableType* node)override
				{
					if (strategy == ValidateTypeStragety::BaseType)
					{
						manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
					}

					if (!ValidateReferenceTypeVisitor::Execute(node->element, manager))
					{
						manager->errors.Add(WfErrors::NullableToNonReferenceType(node));
					}
					else if (auto predefinedType = node->element.Cast<WfPredefinedType>())
					{
						switch (predefinedType->name)
						{
						case WfPredefinedTypeName::Void:
						case WfPredefinedTypeName::Object:
						case WfPredefinedTypeName::Interface:
							manager->errors.Add(WfErrors::NullableToNonReferenceType(node));
							break;
						default:;
						}
					}
				}

				void Visit(WfEnumerableType* node)override
				{
					if (strategy == ValidateTypeStragety::BaseType)
					{
						manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
					}

					ValidateTypeStructure(manager, node->element);
				}

				void Visit(WfMapType* node)override
				{
					if (strategy == ValidateTypeStragety::BaseType)
					{
						manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
					}

					if (node->key)
					{
						ValidateTypeStructure(manager, node->key);
					}
					ValidateTypeStructure(manager, node->value);
				}

				void Visit(WfObservableListType* node)override
				{
					if (strategy == ValidateTypeStragety::BaseType)
					{
						manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
					}

					ValidateTypeStructure(manager, node->element);
				}

				void Visit(WfFunctionType* node)override
				{
					if (strategy == ValidateTypeStragety::BaseType)
					{
						manager->errors.Add(WfErrors::WrongBaseType(classDecl, node));
					}

					ValidateTypeStructure(manager, node->result, ValidateTypeStragety::ReturnType);
					for (auto argument : node->arguments)
					{
						ValidateTypeStructure(manager, argument);
					}
				}

				void Visit(WfChildType* node)override
				{
					if (!ValidateReferenceTypeVisitor::Execute(node->parent, manager))
					{
						manager->errors.Add(WfErrors::ChildOfNonReferenceType(node));
					}
				}

				static void Execute(Ptr<WfType> type, WfLexicalScopeManager* manager, ValidateTypeStragety strategy, WfClassDeclaration* classDecl)
				{
					ValidateStructureTypeVisitor visitor(manager, strategy, classDecl);
					type->Accept(&visitor);
				}
			};

/***********************************************************************
ValidateStructure
***********************************************************************/

			void ValidateTypeStructure(WfLexicalScopeManager* manager, Ptr<WfType> type, ValidateTypeStragety strategy, WfClassDeclaration* classDecl)
			{
				ValidateStructureTypeVisitor::Execute(type, manager, strategy, classDecl);
			}
		}
	}
}


/***********************************************************************
.\CPP\WFCPP.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace regex;
			using namespace reflection;
			using namespace reflection::description;
			using namespace stream;
			using namespace emitter;

/***********************************************************************
WfCppConfig
***********************************************************************/

			WfCppConfig::WfCppConfig(analyzer::WfLexicalScopeManager* _manager, const WString& _assemblyName, const WString& _assemblyNamespace)
				:manager(_manager)
				, regexSplitName(L"::")
				, regexSpecialName(L"/<(<category>/w+)(-(<category>/w+))*/>(<name>/w*)")
				, regexTemplate(L", /$Arguments|/$Arguments, |/$/l+")
				, specialName_category(regexSpecialName.CaptureNames().IndexOf(L"category"))
				, specialName_name(regexSpecialName.CaptureNames().IndexOf(L"name"))
				, assemblyName(_assemblyName)
				, assemblyNamespace(_assemblyNamespace)
			{
				attributeEvaluator = Ptr(new WfAttributeEvaluator(manager));
				Collect();
				for (vint i = 0; i < enumDecls.Count(); i++)
				{
					const auto& values = enumDecls.GetByIndex(i);
					SortDeclsByName(const_cast<List<Ptr<WfEnumDeclaration>>&>(values));
				}
				for (vint i = 0; i < structDecls.Count(); i++)
				{
					const auto& values = structDecls.GetByIndex(i);
					SortDeclsByName(const_cast<List<Ptr<WfStructDeclaration>>&>(values));
				}
				for (vint i = 0; i < classDecls.Count(); i++)
				{
					const auto& values = classDecls.GetByIndex(i);
					SortDeclsByName(const_cast<List<Ptr<WfClassDeclaration>>&>(values));
				}
				AssignClassDeclsToFiles();
			}

			WfCppConfig::~WfCppConfig()
			{
			}

			void WfCppConfig::WriteFunctionBody(stream::StreamWriter& writer, Ptr<WfExpression> expr, const WString& prefix, ITypeInfo* expectedType)
			{
				writer.WriteString(prefix);
				writer.WriteString(L"return ");
				GenerateExpression(this, writer, expr, expectedType);
				writer.WriteLine(L";");
			}

			void WfCppConfig::WriteFunctionBody(stream::StreamWriter& writer, Ptr<WfStatement> stat, const WString& prefix, ITypeInfo* expectedType)
			{
				GenerateStatement(this, Ptr(new FunctionRecord), writer, stat, prefix, WString::Unmanaged(L"\t"), expectedType);
			}

			WString WfCppConfig::CppNameToHeaderEnumStructName(const WString& fullName, const WString& type)
			{
				return L"__vwsn_" + type + L"s::" + ConvertFullName(fullName, L"_");
			}

			WString WfCppConfig::ConvertNameInternal(const WString& name, const WString& specialNameCategory, bool alwaysUseCategory)
			{
				if (name.Length() > 0 && name[0] == L'$')
				{
					return L"__vwsno_" + name.Sub(1, name.Length() - 1);
				}

				auto match = regexSpecialName.Match(name);
				if (match)
				{
					return specialNameCategory
						+ From(match->Groups()[specialName_category])
							.Select([](const RegexString& rs)
							{
								return rs.Value();
							})
							.Aggregate([](const WString& a, const WString& b)
							{
								return a + L"_" + b;
							})
						+ L"_" + match->Groups()[specialName_name][0].Value();
				}
				else if (alwaysUseCategory)
				{
					return specialNameCategory + name;
				}
				{
					return name;
				}
			}

			WString WfCppConfig::ConvertName(const WString& name)
			{
				return ConvertNameInternal(name, WString::Unmanaged(L"__vwsn_"), false);
			}

			WString WfCppConfig::ConvertName(const WString& name, const WString& specialNameCategory)
			{
				return ConvertNameInternal(name, specialNameCategory, true);
			}

			WString WfCppConfig::ConvertFullName(const WString& fullName, WString delimiter)
			{
				List<Ptr<RegexMatch>> matches;
				regexSplitName.Split(fullName, false, matches);
				return (fullName[0] == L':' ? delimiter : WString::Empty) + From(matches)
					.Select([this](Ptr<RegexMatch> match)
					{
						return ConvertName(match->Result().Value());
					})
					.Aggregate([&](const WString& a, const WString& b)
					{
						return a + delimiter + b;
					});
			}

			WString WfCppConfig::ConvertFunctionType(IMethodInfo* methodInfo, WString name)
			{
				WString type = ConvertType(methodInfo->GetReturn()) + name + L"(";
				vint count = methodInfo->GetParameterCount();
				for (vint i = 0; i < count; i++)
				{
					if (i > 0)
					{
						type += L", ";
					}
					type += ConvertArgumentType(methodInfo->GetParameter(i)->GetType());
				}
				type += L")";
				return type;
			}

			WString WfCppConfig::ConvertFunctionType(ITypeInfo* typeInfo)
			{
				if (typeInfo->GetDecorator() == ITypeInfo::SharedPtr)
				{
					return ConvertFunctionType(typeInfo->GetElementType());
				}
				CHECK_ERROR(typeInfo->GetDecorator() == ITypeInfo::Generic, L"WfCppConfig::ConvertFunctionType(ITypeInfo*)#Internal error: Wrong function type.");
				CHECK_ERROR(typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<IValueFunctionProxy>(), L"WfCppConfig::ConvertFunctionType(ITypeInfo*)#Internal error: Wrong function type.");

				WString type = ConvertType(typeInfo->GetGenericArgument(0)) + L"(";
				vint count = typeInfo->GetGenericArgumentCount();
				for (vint i = 1; i < count; i++)
				{
					if (i > 1) type += L", ";
					type += ConvertArgumentType(typeInfo->GetGenericArgument(i));
				}
				type += L")";
				return type;
			}

			bool WfCppConfig::IsSpecialGenericType(ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::SharedPtr:
					if (typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<IValueFunctionProxy>())
					{
						return true;
					}
					else if (typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>())
					{
						return true;
					}
					else
					{
						return false;
					}
				default:
					return false;
				}
			}

			WString WfCppConfig::ConvertType(ITypeDescriptor* typeInfo, WString delimiter)
			{
				return ConvertFullName(CppGetFullName(typeInfo), delimiter);
			}

			WString WfCppConfig::ConvertType(ITypeInfo* typeInfo, bool useHeaderEnumStructName)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					return ConvertType(typeInfo->GetElementType(), useHeaderEnumStructName) + L"*";
				case ITypeInfo::SharedPtr:
					if (typeInfo->GetElementType()->GetDecorator() == ITypeInfo::Generic)
					{
						if (typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<IValueFunctionProxy>())
						{
							return ConvertType(typeInfo->GetElementType(), useHeaderEnumStructName);
						}
						else if (typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>())
						{
							return ConvertType(typeInfo->GetElementType(), useHeaderEnumStructName);
						}
					}
					return L"::vl::Ptr<" + ConvertType(typeInfo->GetElementType(), useHeaderEnumStructName) + L">";
				case ITypeInfo::Nullable:
					return L"::vl::Nullable<" + ConvertType(typeInfo->GetElementType(), useHeaderEnumStructName) + L">";
				case ITypeInfo::Generic:
					if (typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<IValueFunctionProxy>())
					{
						return L"::vl::Func<" + ConvertFunctionType(typeInfo) + L">";
					}
					else if(typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>())
					{
						return L"::vl::collections::LazyList<" + ConvertType(typeInfo->GetGenericArgument(0), useHeaderEnumStructName) + L">";
					}
					else
					{
						return ConvertType(typeInfo->GetElementType(), useHeaderEnumStructName);
					}
				default:;
				}
				if (useHeaderEnumStructName)
				{
					switch (typeInfo->GetTypeDescriptor()->GetTypeDescriptorFlags())
					{
					case TypeDescriptorFlags::EnumType:
						if (tdDecls.Keys().Contains(typeInfo->GetTypeDescriptor()))
						{
							return L"::" + CppNameToHeaderEnumStructName(CppGetFullName(typeInfo->GetTypeDescriptor()), L"enum");
						}
						break;
					case TypeDescriptorFlags::Struct:
						if (tdDecls.Keys().Contains(typeInfo->GetTypeDescriptor()))
						{
							return L"::" + CppNameToHeaderEnumStructName(CppGetFullName(typeInfo->GetTypeDescriptor()), L"struct");
						}
						break;
					default:;
					}
					return ConvertType(typeInfo->GetTypeDescriptor());
				}
				else
				{
					return ConvertType(typeInfo->GetTypeDescriptor());
				}
			}

			WString WfCppConfig::ConvertArgumentType(ITypeInfo* typeInfo)
			{
				auto td = typeInfo->GetTypeDescriptor();
				bool constRef =
					td == description::GetTypeDescriptor<WString>() ||
					td == description::GetTypeDescriptor<Value>() ||
					(
						typeInfo->GetDecorator() == ITypeInfo::SharedPtr && typeInfo->GetElementType()->GetDecorator() == ITypeInfo::Generic &&
						(
							td == description::GetTypeDescriptor<IValueFunctionProxy>() ||
							td == description::GetTypeDescriptor<IValueEnumerable>()
							)
					);

				if (constRef)
				{
					return L"const " + ConvertType(typeInfo) + L"&";
				}
				else
				{
					return ConvertType(typeInfo);
				}
			}

			WString WfCppConfig::DefaultValue(ITypeInfo* typeInfo)
			{
				switch (typeInfo->GetDecorator())
				{
				case ITypeInfo::RawPtr:
					return L"nullptr";
				case ITypeInfo::SharedPtr:
					return L"";
				case ITypeInfo::Nullable:
					return L"";
				case ITypeInfo::Generic:
					return L"";
				default:;
				}
				auto td = typeInfo->GetTypeDescriptor();
				if ((td->GetTypeDescriptorFlags()&TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
				{
					return L"static_cast<" + ConvertType(typeInfo) + L">(0)";
				}
				if (td == description::GetTypeDescriptor<vint8_t>()) return L"0";
				if (td == description::GetTypeDescriptor<vint16_t>()) return L"0";
				if (td == description::GetTypeDescriptor<vint32_t>()) return L"0";
				if (td == description::GetTypeDescriptor<vint64_t>()) return L"0";
				if (td == description::GetTypeDescriptor<vuint8_t>()) return L"0";
				if (td == description::GetTypeDescriptor<vuint16_t>()) return L"0";
				if (td == description::GetTypeDescriptor<vuint32_t>()) return L"0";
				if (td == description::GetTypeDescriptor<vuint64_t>()) return L"0";
				if (td == description::GetTypeDescriptor<bool>()) return L"false";
				if (td == description::GetTypeDescriptor<float>()) return L"0.0f";
				if (td == description::GetTypeDescriptor<double>()) return L"0.0";
				return L"";
			}

			bool WfCppConfig::IsClassHasUserImplMethods(Ptr<WfClassDeclaration> decl, bool searchInternalClasses)
			{
				List<Ptr<WfDeclaration>> unprocessed;
				CopyFrom(unprocessed, decl->declarations);

				for (vint i = 0; i < unprocessed.Count(); i++)
				{
					auto memberDecl = unprocessed[i];
					if (auto cfe = memberDecl.Cast<WfVirtualCfeDeclaration>())
					{
						CopyFrom(unprocessed, cfe->expandedDeclarations, true);
					}
					else if (auto cse = memberDecl.Cast<WfVirtualCseDeclaration>())
					{
						CopyFrom(unprocessed, cse->expandedDeclarations, true);
					}
					else if (auto classDecl = memberDecl.Cast<WfClassDeclaration>())
					{
						if (searchInternalClasses)
						{
							CopyFrom(unprocessed, classDecl->declarations, true);
						}
					}
					else if (attributeEvaluator->GetAttribute(memberDecl->attributes, L"cpp", L"UserImpl"))
					{
						return true;
					}
				}
				return false;
			}

			vint WfCppConfig::CountClassNamespace(Ptr<WfClassDeclaration> decl)
			{
				vint result = 0;
				auto scope = manager->nodeScopes[decl.Obj()].Obj();
				while (scope)
				{
					if (scope->ownerNode.Cast<WfNamespaceDeclaration>())
					{
						result++;
					}
					scope = scope->parentScope.Obj();
				}
				return result;
			}

			void WfCppConfig::GetClassNamespace(Ptr<WfClassDeclaration> decl, collections::List<WString>& nss)
			{
				auto td = manager->declarationTypes[decl.Obj()].Obj();
				auto name = ConvertType(td);
				vint count = CountClassNamespace(decl);

				List<Ptr<RegexMatch>> matches;
				regexSplitName.Split(name, false, matches);

				CopyFrom(
					nss,
					From(matches)
						.Take(count)
						.Select([this](Ptr<RegexMatch> match)
						{
							return ConvertName(match->Result().Value());
						})
					);
			}

			WString WfCppConfig::GetClassBaseName(Ptr<WfClassDeclaration> decl)
			{
				auto td = manager->declarationTypes[decl.Obj()].Obj();
				auto name = ConvertType(td);
				vint count = CountClassNamespace(decl);

				List<Ptr<RegexMatch>> matches;
				regexSplitName.Split(name, false, matches);

				return From(matches)
					.Skip(count)
					.Select([this](Ptr<RegexMatch> match)
					{
						return ConvertName(match->Result().Value());
					})
					.Aggregate([](const WString& a, const WString& b)
					{
						return a + L"::" + b;
					});
			}

			WString WfCppConfig::WriteNamespace(stream::StreamWriter& writer, collections::List<WString>& nss, collections::List<WString>& nss2)
			{
				vint commonPrefix = 0;
				for (vint i = 0; i < nss.Count() && i < nss2.Count(); i++)
				{
					if (nss[i] == nss2[i])
					{
						commonPrefix++;
					}
					else
					{
						break;
					}
				}

				while (nss.Count() > commonPrefix)
				{
					for (vint i = 1; i < nss.Count(); i++)
					{
						writer.WriteChar(L'\t');
					}
					writer.WriteLine(L"}");
					nss.RemoveAt(nss.Count() - 1);
				}

				WString prefix;
				for (vint i = 0; i < nss.Count(); i++)
				{
					prefix += WString::FromChar(L'\t');
				}

				for (vint i = commonPrefix; i < nss2.Count(); i++)
				{
					writer.WriteString(prefix);
					writer.WriteString(L"namespace ");
					writer.WriteLine(nss2[i]);

					writer.WriteString(prefix);
					writer.WriteLine(L"{");

					nss.Add(nss2[i]);
					prefix += WString::FromChar(L'\t');
				}

				return prefix;
			}

			WString WfCppConfig::WriteNamespace(stream::StreamWriter& writer, const WString& fullName, collections::List<WString>& nss, WString& name)
			{
				List<Ptr<RegexMatch>> matches;
				regexSplitName.Split(fullName, false, matches);

				List<WString> nss2;
				CopyFrom(
					nss2,
					From(matches)
						.Select([this](Ptr<RegexMatch> match)
						{
							return ConvertName(match->Result().Value());
						})
					);

				name = nss2[nss2.Count() - 1];
				nss2.RemoveAt(nss2.Count() - 1);
				return WriteNamespace(writer, nss, nss2);
			}

			void WfCppConfig::WriteNamespaceEnd(stream::StreamWriter& writer, collections::List<WString>& nss)
			{
				while (nss.Count() > 0)
				{
					for (vint i = 1; i < nss.Count(); i++)
					{
						writer.WriteChar(L'\t');
					}
					writer.WriteLine(L"}");
					nss.RemoveAt(0);
				}
			}
		}
	}
}


/***********************************************************************
.\CPP\WFCPP_ASSIGNCLASSDECLSTOFILES.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace analyzer;
			using namespace collections;

#define ASSIGN_INDEX_KEY(INDEX_DECL, INDEX_KEY, STRING_KEY) \
			INDEX_DECL INDEX_KEY = globalDep.allTds.Keys().IndexOf(STRING_KEY); \
			CHECK_ERROR(INDEX_KEY != -1, L"WfCppConfig::AssignClassDeclsToFiles()#Internal error.") \

/***********************************************************************
WfCppConfig::GenerateGlobalDep
***********************************************************************/

			void WfCppConfig::ExpandClassDeclGroup(Ptr<WfClassDeclaration> parent, GlobalDep& globalDep)
			{
				vint index = classDecls.Keys().IndexOf(parent.Obj());
				if (index == -1) return;

				for (auto subDecl : classDecls.GetByIndex(index))
				{
					ExpandClassDeclGroup(subDecl, globalDep);
				}

				auto directChildren =
					From(classDecls.GetByIndex(index))
						.Select([&](Ptr<WfClassDeclaration> decl)
						{
							auto stringKey = manager->declarationTypes[decl.Obj()]->GetTypeName();
							ASSIGN_INDEX_KEY(auto, indexKey, stringKey);
							return indexKey;
						});

				auto indirectChildren =
					From(classDecls.GetByIndex(index))
						.Select([&](Ptr<WfClassDeclaration> subDecl)
						{
							auto stringKey = manager->declarationTypes[subDecl.Obj()]->GetTypeName();
							ASSIGN_INDEX_KEY(auto, indexKey, stringKey);
							return globalDep.expandedClassDecls.Keys().IndexOf(indexKey);
						})
						.Where([](vint index)
						{
							return index != -1;
						})
						.SelectMany([&](vint index)
						{
							return From(globalDep.expandedClassDecls.GetByIndex(index));
						});

				vint indexKey = -1;
				if (parent)
				{
					auto stringKey = manager->declarationTypes[parent.Obj()]->GetTypeName();
					ASSIGN_INDEX_KEY(, indexKey, stringKey);
				}
				for (auto subDecl : directChildren.Concat(indirectChildren))
				{
					globalDep.expandedClassDecls.Add(indexKey, subDecl);
				}
			}

			void WfCppConfig::GenerateClassDependencies(GlobalDep& globalDep)
			{
				for (auto [td, tdIndex] : indexed(globalDep.allTds.Values()))
				{
					vint count = td->GetBaseTypeDescriptorCount();
					for (vint i = 0; i < count; i++)
					{
						auto baseTd = td->GetBaseTypeDescriptor(i);
						vint baseTdIndex = globalDep.allTds.Keys().IndexOf(baseTd->GetTypeName());
						if (baseTdIndex != -1)
						{
							globalDep.dependencies.Add(tdIndex, baseTdIndex);
						}
					}
				}
			}

			void WfCppConfig::GenerateGlobalDep(GlobalDep& globalDep)
			{
				for (auto [td, index] : indexed(tdDecls.Keys()))
				{
					if (tdDecls.Values()[index].Cast<WfClassDeclaration>())
					{
						globalDep.allTds.Add(td->GetTypeName(), td);
					}
				}

				ExpandClassDeclGroup(nullptr, globalDep);
				GenerateClassDependencies(globalDep);
			}

/***********************************************************************
WfCppConfig::GenerateClassLevelDep
***********************************************************************/

			void WfCppConfig::CollectExpandedDepGroup(vint parentIndexKey, GlobalDep& globalDep, ClassLevelDep& classLevelDep)
			{
				const auto& items = globalDep.expandedClassDecls[parentIndexKey];
				for (auto subDecl : items)
				{
					vint index = globalDep.dependencies.Keys().IndexOf(subDecl);
					if (index != -1)
					{
						for (auto dep : globalDep.dependencies.GetByIndex(index))
						{
							if (items.Contains(dep))
							{
								classLevelDep.depGroup.Add(subDecl, dep);
							}
						}
					}
				}
			}

			void WfCppConfig::CollectExpandedSubClass(vint subDeclIndexKey, GlobalDep& globalDep, ClassLevelDep& classLevelDep)
			{
				classLevelDep.subClass.Add(subDeclIndexKey, subDeclIndexKey);

				vint index = globalDep.expandedClassDecls.Keys().IndexOf(subDeclIndexKey);
				if (index != -1)
				{
					for (auto expandDecl : globalDep.expandedClassDecls.GetByIndex(index))
					{
						classLevelDep.subClass.Add(expandDecl, subDeclIndexKey);
					}
				}
			}

			void WfCppConfig::GenerateClassLevelDep(Ptr<WfClassDeclaration> parent, GlobalDep& globalDep, ClassLevelDep& classLevelDep)
			{
				classLevelDep.parentClass = parent;
				if (parent)
				{
					auto parentStringKey = manager->declarationTypes[parent.Obj()]->GetTypeName();
					ASSIGN_INDEX_KEY(, classLevelDep.parentIndexKey, parentStringKey);
				}
				const auto& items = globalDep.expandedClassDecls[classLevelDep.parentIndexKey];

				// for any specified class (or top level if nullptr)
				// find all direct and indirect internal classes
				// copy their dependencies, and generate sub classes by grouping them using the second level of classes
				CollectExpandedDepGroup(classLevelDep.parentIndexKey, globalDep, classLevelDep);
				for (auto subDecl : classDecls.Get(parent.Obj()))
				{
					auto subDeclStringKey = manager->declarationTypes[subDecl.Obj()]->GetTypeName();
					ASSIGN_INDEX_KEY(auto, subDeclIndexKey, subDeclStringKey);
					CollectExpandedSubClass(subDeclIndexKey, globalDep, classLevelDep);
				}
			}

/***********************************************************************
WfCppConfig::Collect
***********************************************************************/

			void WfCppConfig::SortClassDecls(GlobalDep& globalDep)
			{
				// sort top level classes and all internal classes inside any classes
				for (vint i = classDecls.Count() - 1; i >= 0; i--)
				{
					// for any specified class (or top level if nullptr)
					// find all direct and indirect internal classes
					// copy their dependencies, and generate sub classes by grouping them using the second level of classes
					auto parent = classDecls.Keys()[i];
					ClassLevelDep classLevelDep;
					GenerateClassLevelDep(parent, globalDep, classLevelDep);

					// sort them
					PartialOrderingProcessor pop;
					const auto& items = globalDep.expandedClassDecls[classLevelDep.parentIndexKey];
					pop.InitWithSubClass(items, classLevelDep.depGroup, classLevelDep.subClass);
					pop.Sort();

					// using the partial ordering result to sort the corresponding value list in classDecls
					{
						auto& values = const_cast<List<Ptr<WfClassDeclaration>>&>(classDecls.GetByIndex(i));
						for (vint j = 0; j < pop.components.Count(); j++)
						{
							auto& component = pop.components[j];

							// check error
							if (component.nodeCount > 1)
							{
								List<ITypeDescriptor*> tds;
								for (vint k = 0; k < component.nodeCount; k++)
								{
									auto& node = pop.nodes[component.firstNode[k]];
									auto indexKey = classLevelDep.subClass[items[node.firstSubClassItem[0]]];
									tds.Add(globalDep.allTds.Values()[indexKey]);
								}

								SortLambda<ITypeDescriptor*>(&tds[0], tds.Count(), [](ITypeDescriptor* a, ITypeDescriptor* b)
								{
									return a->GetTypeName() <=> b->GetTypeName();
								});
								manager->errors.Add(WfErrors::CppUnableToDecideClassOrder(tdDecls[tds[0]].Cast<WfClassDeclaration>().Obj(), tds));
							}

							auto& node = pop.nodes[component.firstNode[0]];
							auto subDeclIndexKey = classLevelDep.subClass[items[node.firstSubClassItem[0]]];
							auto subDecl = tdDecls[globalDep.allTds.Values()[subDeclIndexKey]].Cast<WfClassDeclaration>();
							values[j] = subDecl;
						}
					}

					if (!parent && manager->errors.Count() == 0)
					{
						for (vint i = 0; i < classLevelDep.subClass.Count(); i++)
						{
							vint index = classLevelDep.subClass.Values()[i];
							if (!globalDep.topLevelClasses.Contains(index))
							{
								globalDep.topLevelClasses.Add(index);
							}
						}

						for (vint i = 0; i < pop.nodes.Count(); i++)
						{
							auto& keyNode = pop.nodes[i];
							vint keyIndex = classLevelDep.subClass[items[keyNode.firstSubClassItem[0]]];
							for (vint j = 0; j < keyNode.ins->Count(); j++)
							{
								auto& valueNode = pop.nodes[keyNode.ins->Get(j)];
								vint valueIndex = classLevelDep.subClass[items[valueNode.firstSubClassItem[0]]];
								if (!globalDep.topLevelClassDep.Contains(keyIndex, valueIndex))
								{
									globalDep.topLevelClassDep.Add(keyIndex, valueIndex);
								}
							}
						}
					}
				}
			}

			void WfCppConfig::GenerateFileClassMaps(GlobalDep& globalDep)
			{
				if (classDecls.Keys().Contains(nullptr))
				{
					PartialOrderingProcessor popSubClass;
					Array<vint> customFirstItems;		// popSubClass.nodes's index
					Array<vint> nonCustomFirstItems;	// popSubClass.nodes's index
					Array<bool> isCustomItems;			// popSubClass.nodes's index to boolean (true means custom item)
					Group<vint, vint> subClassDepGroup;	// popSubClass.nodes's index to index
					{
						// generate sub class using @cpp:File
						// globalDep.allTds.Keys()'s index to file name
						Dictionary<vint, WString> subClass;
						for (vint i = 0; i < customFilesClasses.Count(); i++)
						{
							WString key = customFilesClasses.Keys()[i];
							if (key != L"")
							{
								for (auto decl : customFilesClasses.GetByIndex(i))
								{
									auto stringKey = manager->declarationTypes[decl.Obj()]->GetTypeName();
									ASSIGN_INDEX_KEY(auto, indexKey, stringKey);
									subClass.Add(indexKey, key);
								}
							}
						}

						// check if all components contains either all classes of the same @cpp:File or a single non-@cpp:File class
						popSubClass.InitWithSubClass(globalDep.topLevelClasses, globalDep.topLevelClassDep, subClass);
						popSubClass.Sort();

						for (vint i = 0; i < popSubClass.components.Count(); i++)
						{
							auto& component = popSubClass.components[i];

							// check error
							if (component.nodeCount > 1)
							{
								List<ITypeDescriptor*> tds;
								for (vint j = 0; j < component.nodeCount; j++)
								{
									auto& node = popSubClass.nodes[component.firstNode[j]];
									for (vint k = 0; k < node.subClassItemCount; k++)
									{
										auto indexKey = globalDep.topLevelClasses[node.firstSubClassItem[k]];
										tds.Add(globalDep.allTds.Values()[indexKey]);
									}
								}

								SortLambda<ITypeDescriptor*>(&tds[0], tds.Count(), [](ITypeDescriptor* a, ITypeDescriptor* b)
								{
									return a->GetTypeName() <=> b->GetTypeName();
								});
								manager->errors.Add(WfErrors::CppUnableToSeparateCustomFile(tdDecls[tds[0]].Cast<WfClassDeclaration>().Obj(), tds));
							}
						}

						if (manager->errors.Count() != 0)
						{
							return;
						}

						// generate two item list, one have all @cpp:File classes put in front, one have all non-@cpp:File classes put in front
						// popSubClass.nodes's index
						{
							List<vint> customItems;
							List<vint> nonCustomItems;

							// categorize popSubClass.nodes's index to customItems and nonCustomItems
							for (vint i = 0; i < popSubClass.nodes.Count(); i++)
							{
								auto& node = popSubClass.nodes[i];
								if (subClass.Keys().Contains(globalDep.topLevelClasses[node.firstSubClassItem[0]]))
								{
									customItems.Add(i);
								}
								else
								{
									nonCustomItems.Add(i);
								}
							}

							// sort items using allTds.Keys()'s index
							auto SortNodes = [&](List<vint>& items)
							{
								if (items.Count() > 0)
								{
									Sort<vint>(&items[0], items.Count(), [&](vint a, vint b)
									{
										auto& nodeA = popSubClass.nodes[a];
										auto& nodeB = popSubClass.nodes[b];
										vint indexA = From(nodeA.firstSubClassItem, nodeA.firstSubClassItem + nodeA.subClassItemCount)
											.Select([&](vint index) {return globalDep.topLevelClasses[index]; })
											.Min();
										vint indexB = From(nodeB.firstSubClassItem, nodeB.firstSubClassItem + nodeB.subClassItemCount)
											.Select([&](vint index) {return globalDep.topLevelClasses[index]; })
											.Min();
										return indexA <=> indexB;
									});
								}
							};
							SortNodes(customItems);
							SortNodes(nonCustomItems);

							// prepare customFirstItems, nonCustomFirstItems and isCustomItems
							isCustomItems.Resize(customItems.Count() + nonCustomItems.Count());
							for (vint i = 0; i < customItems.Count(); i++)
							{
								isCustomItems[customItems[i]] = true;
							}
							for (vint i = 0; i < nonCustomItems.Count(); i++)
							{
								isCustomItems[nonCustomItems[i]] = false;
							}

							CopyFrom(customFirstItems, customItems);
							CopyFrom(nonCustomFirstItems, nonCustomItems);

							CopyFrom(nonCustomFirstItems, customItems, true);
							CopyFrom(customFirstItems, nonCustomItems, true);
						}
					}

					// copy popSubClass's sub class dependencies to subClassDepGroup
					for (vint i = 0; i < popSubClass.nodes.Count(); i++)
					{
						auto& node = popSubClass.nodes[i];
						for (vint j = 0; j < node.ins->Count(); j++)
						{
							subClassDepGroup.Add(i, node.ins->Get(j));
						}
					}

					// sort using inputs of two orders
					PartialOrderingProcessor popCustomFirst;
					popCustomFirst.InitWithGroup(customFirstItems, subClassDepGroup);
					popCustomFirst.Sort();

					PartialOrderingProcessor popNonCustomFirst;
					popNonCustomFirst.InitWithGroup(nonCustomFirstItems, subClassDepGroup);
					popNonCustomFirst.Sort();

					CHECK_ERROR(popCustomFirst.components.Count() == customFirstItems.Count(), L"WfCppConfig::AssignClassDeclsToFiles()#Internal error: Unexpected circle dependency found, this should have been caught by code above.");
					CHECK_ERROR(popNonCustomFirst.components.Count() == nonCustomFirstItems.Count(), L"WfCppConfig::AssignClassDeclsToFiles()#Future error: Unexpected circle dependency found, this should have been caught by code above.");
					CHECK_ERROR(popCustomFirst.components.Count() == popNonCustomFirst.components.Count(), L"WfCppConfig::AssignClassDeclsToFiles()#Future error: Unexpected circle dependency found, this should have been caught by code above.");

					// translate popCustomFirst's sorting result
					// popSubClass.nodes's index
					Array<vint> customFirstOrder(popCustomFirst.components.Count());
					for (vint i = 0; i < popCustomFirst.components.Count(); i++)
					{
						auto& component = popCustomFirst.components[i];
						customFirstOrder[i] = customFirstItems[component.firstNode[0]];
					}

					// translate popNonCustomFirst's sorting result
					// popSubClass.nodes's index
					Array<vint> nonCustomFirstOrder(popNonCustomFirst.components.Count());
					for (vint i = 0; i < popNonCustomFirst.components.Count(); i++)
					{
						auto& component = popNonCustomFirst.components[i];
						nonCustomFirstOrder[i] = nonCustomFirstItems[component.firstNode[0]];
					}

					// dispatch non-@cpp:File classes to non-@cpp:File headers
					vint currentHeaderIndex = 0;
					vint nonCustomFirstOrderPicked = 0;
					vint customFirstOrderPicked = 0;
					Array<bool> visited(customFirstOrder.Count());
					for (vint i = 0; i < visited.Count(); i++)
					{
						visited[i] = false;
					}

					auto pickItems = [&](Array<vint>& order, vint& picked, bool customItem)
					{
						while (picked < order.Count())
						{
							vint item = order[picked];
							if (visited[item])
							{
								picked++;
							}
							else if (isCustomItems[item] == customItem)
							{
								visited[item] = true;
								picked++;

								if(!customItem)
								{
									auto& node = popSubClass.nodes[item];
									for (vint i = 0; i < node.subClassItemCount; i++)
									{
										auto indexKey = globalDep.topLevelClasses[node.firstSubClassItem[i]];
										auto td = globalDep.allTds.Values()[indexKey];
										headerFilesClasses.Add(currentHeaderIndex, tdDecls[td].Cast<WfClassDeclaration>());
									}
								}
							}
							else
							{
								break;
							}
						}
					};

					while (nonCustomFirstOrderPicked < nonCustomFirstOrder.Count() || customFirstOrderPicked < customFirstOrder.Count())
					{
						pickItems(nonCustomFirstOrder, nonCustomFirstOrderPicked, false);
						pickItems(customFirstOrder, customFirstOrderPicked, false);

						pickItems(nonCustomFirstOrder, nonCustomFirstOrderPicked, true);
						pickItems(customFirstOrder, customFirstOrderPicked, true);

						currentHeaderIndex++;
					}

					// calculate header includes
					// globalDep.allTds.keys()'s index to header index
					Dictionary<vint, vint> headers;

					auto addToHeaders = [&](const List<Ptr<WfClassDeclaration>>& decls, vint headerIndex)
					{
						for (auto decl : decls)
						{
							auto stringKey = manager->declarationTypes[decl.Obj()]->GetTypeName();
							ASSIGN_INDEX_KEY(auto, indexKey, stringKey);
							headers.Add(indexKey, headerIndex);
						}
					};

					auto calculateIncludes = [&](const List<Ptr<WfClassDeclaration>>& decls, SortedList<vint>& includes)
					{
						for (auto decl : decls)
						{
							auto stringKey = manager->declarationTypes[decl.Obj()]->GetTypeName();
							ASSIGN_INDEX_KEY(auto, indexKey, stringKey);

							vint index = globalDep.topLevelClassDep.Keys().IndexOf(indexKey);
							if (index != -1)
							{
								const auto& values = globalDep.topLevelClassDep.GetByIndex(index);
								for (vint i = 0; i < values.Count(); i++)
								{
									vint header = headers[values[i]];
									if (header != 0 && !includes.Contains(header))
									{
										includes.Add(header);
									}
								}
							}
						}
					};

					for (vint i = 0; i < customFilesClasses.Count(); i++)
					{
						if (customFilesClasses.Keys()[i] != L"")
						{
							addToHeaders(customFilesClasses.GetByIndex(i), i);
						}
					}

					for (vint i = 0; i < headerFilesClasses.Count(); i++)
					{
						addToHeaders(headerFilesClasses.GetByIndex(i), -headerFilesClasses.Keys()[i]);
					}

					for (vint i = 0; i < customFilesClasses.Count(); i++)
					{
						if (customFilesClasses.Keys()[i] != L"")
						{
							SortedList<vint> includes;
							calculateIncludes(customFilesClasses.GetByIndex(i), includes);
							for (vint j = 0; j < includes.Count(); j++)
							{
								headerIncludes.Add(i, includes[j]);
							}
						}
					}

					for (vint i = 0; i < headerFilesClasses.Count(); i++)
					{
						if (headerFilesClasses.Keys()[i] != 0)
						{
							SortedList<vint> includes;
							calculateIncludes(headerFilesClasses.GetByIndex(i), includes);
							for (vint j = 0; j < includes.Count(); j++)
							{
								headerIncludes.Add(-headerFilesClasses.Keys()[i], includes[j]);
							}
						}
					}
				}
			}

			void WfCppConfig::SortFileClassMaps(GlobalDep& globalDep)
			{
				// sort customFilesClasses and headerFilesClasses according to classDecls[nullptr]
				if (classDecls.Keys().Contains(nullptr))
				{
					List<Ptr<WfClassDeclaration>> ordered;
					CopyFrom(ordered, classDecls[nullptr]);

					for (vint i = 0; i < customFilesClasses.Count(); i++)
					{
						auto& values = const_cast<List<Ptr<WfClassDeclaration>>&>(customFilesClasses.GetByIndex(i));
						Sort<Ptr<WfClassDeclaration>>(&values[0], values.Count(), [&](Ptr<WfClassDeclaration> a, Ptr<WfClassDeclaration> b)
						{
							vint aIndex = ordered.IndexOf(a.Obj());
							vint bIndex = ordered.IndexOf(b.Obj());
							return aIndex <=> bIndex;
						});
					}

					for (vint i = 0; i < headerFilesClasses.Count(); i++)
					{
						auto& values = const_cast<List<Ptr<WfClassDeclaration>>&>(headerFilesClasses.GetByIndex(i));
						Sort<Ptr<WfClassDeclaration>>(&values[0], values.Count(), [&](Ptr<WfClassDeclaration> a, Ptr<WfClassDeclaration> b)
						{
							vint aIndex = ordered.IndexOf(a.Obj());
							vint bIndex = ordered.IndexOf(b.Obj());
							return aIndex <=> bIndex;
						});
					}
				}
			}

			void WfCppConfig::AssignClassDeclsToFiles()
			{
				GlobalDep globalDep;
				GenerateGlobalDep(globalDep);

				if (manager->errors.Count() == 0) SortClassDecls(globalDep);
				if (manager->errors.Count() == 0) GenerateFileClassMaps(globalDep);
				if (manager->errors.Count() == 0) SortFileClassMaps(globalDep);
			}

#undef ASSIGN_INDEX_KEY
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_CLASS.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace analyzer;

			bool IsVirtual(WfCppConfig* config, WfFunctionDeclaration* node)
			{
				vint index = config->manager->declarationMemberInfos.Keys().IndexOf(node);
				if (index != -1)
				{
					auto methodInfo = dynamic_cast<IMethodInfo*>(config->manager->declarationMemberInfos.Values()[index].Obj());
					if (methodInfo->IsStatic())
					{
						return false;
					}
					auto td = methodInfo->GetOwnerTypeDescriptor();
					return td->GetTypeDescriptorFlags() == TypeDescriptorFlags::Interface;
				}
				return false;
			}

/***********************************************************************
WfGenerateClassMemberDeclVisitor
***********************************************************************/

			class WfGenerateClassMemberDeclVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCppConfig*				config;
				stream::StreamWriter&		writer;
				WString						className;
				WString						prefix;
				bool						forClassExpr;

				WfGenerateClassMemberDeclVisitor(WfCppConfig* _config, stream::StreamWriter& _writer, const WString& _className, const WString& _prefix, bool _forClassExpr)
					:config(_config)
					, writer(_writer)
					, className(_className)
					, prefix(_prefix)
					, forClassExpr(_forClassExpr)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					bool isVirtual = IsVirtual(config, node);

					writer.WriteString(prefix);
					if (isVirtual)
					{
						writer.WriteString(L"virtual ");
					}
					else if (node->functionKind == WfFunctionKind::Static)
					{
						writer.WriteString(L"static ");
					}
					config->WriteFunctionHeader(writer, Ptr(node), config->ConvertName(node->name.value), true);
					if (isVirtual)
					{
						writer.WriteString(L" = 0");
					}
					else if (node->functionKind == WfFunctionKind::Override)
					{
						writer.WriteString(L" override");
					}
					writer.WriteLine(L";");
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = config->manager->nodeScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					auto typeInfo = symbol->typeInfo;
					writer.WriteString(prefix + config->ConvertType(typeInfo.Obj()) + L" " + config->ConvertName(node->name.value));
					if (forClassExpr)
					{
						auto defaultValue = config->DefaultValue(typeInfo.Obj());
						if (defaultValue != L"")
						{
							writer.WriteString(L" = ");
							writer.WriteString(defaultValue);
						}
					}
					writer.WriteLine(L";");
				}

				void Visit(WfEventDeclaration* node)override
				{
					auto eventInfo = dynamic_cast<IEventInfo*>(config->manager->declarationMemberInfos[node].Obj());
					auto typeInfo = eventInfo->GetHandlerType()->GetElementType();
					writer.WriteString(prefix);

					writer.WriteString(L"::vl::Event<void(");
					vint count = typeInfo->GetGenericArgumentCount();
					for (vint i = 1; i < count; i++)
					{
						if (i > 1) writer.WriteString(L", ");
						writer.WriteString(config->ConvertType(typeInfo->GetGenericArgument(i)));
					}
					writer.WriteLine(L")> " + config->ConvertName(node->name.value) + L";");
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					auto methodInfo = dynamic_cast<IMethodInfo*>(config->manager->declarationMemberInfos[node].Obj());
					writer.WriteString(prefix);
					config->WriteFunctionHeader(writer, methodInfo, className, false);
					writer.WriteLine(L";");
				}

				void Visit(WfDestructorDeclaration* node)override
				{
					writer.WriteLine(prefix + L"~" + className + L"();");
				}

				void Visit(WfClassDeclaration* node)override
				{
				}

				void Visit(WfEnumDeclaration* node)override
				{
				}

				void Visit(WfStructDeclaration* node)override
				{
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			class WfGenerateClassMemberInitVisitor : public empty_visitor::DeclarationVisitor
			{
			public:
				WfCppConfig * config;
				stream::StreamWriter&		writer;
				WString						prefix;
				vint&						callIndex;

				WfGenerateClassMemberInitVisitor(WfCppConfig* _config, stream::StreamWriter& _writer, const WString& _prefix, vint& _callIndex)
					:config(_config)
					, writer(_writer)
					, prefix(_prefix)
					, callIndex(_callIndex)
				{
				}

				void WriteVariableHeader(WfVariableDeclaration* node)
				{
					writer.WriteString(prefix);
					if (callIndex++ == 0)
					{
						writer.WriteString(L"\t: ");
					}
					else
					{
						writer.WriteString(L"\t, ");
					}
					writer.WriteString(config->ConvertName(node->name.value));
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = config->manager->nodeScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					auto typeInfo = symbol->typeInfo;
					if (node->expression)
					{
						WriteVariableHeader(node);
						writer.WriteString(L"(");
						GenerateExpression(config, writer, node->expression, typeInfo.Obj());
						writer.WriteLine(L")");
					}
					else
					{
						auto defaultValue = config->DefaultValue(typeInfo.Obj());
						if (defaultValue != L"")
						{
							WriteVariableHeader(node);
							writer.WriteString(L"(");
							writer.WriteString(defaultValue);
							writer.WriteLine(L")");
						}
					}
				}

				void Dispatch(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Dispatch(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			void GenerateClassMemberDecl(WfCppConfig* config, stream::StreamWriter& writer, const WString& className, Ptr<WfDeclaration> memberDecl, const WString& prefix, bool forClassExpr)
			{
				WfGenerateClassMemberDeclVisitor visitor(config, writer, className, prefix, forClassExpr);
				memberDecl->Accept(&visitor);
			}

/***********************************************************************
WfGenerateClassMemberImplVisitor
***********************************************************************/

			class WfGenerateClassMemberImplVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCppConfig*				config;
				stream::StreamWriter&		writer;
				WfClassDeclaration*			classDef;
				WString						classBaseName;
				WString						className;
				WString						classFullName;
				WString						prefix;
				bool						printableMember = false;

				WfGenerateClassMemberImplVisitor(WfCppConfig* _config, stream::StreamWriter& _writer, WfClassDeclaration* _classDef, const WString& _classBaseName, const WString& _className, const WString& _classFullName, const WString& _prefix)
					:config(_config)
					, writer(_writer)
					, classDef(_classDef)
					, classBaseName(_classBaseName)
					, className(_className)
					, classFullName(_classFullName)
					, prefix(_prefix)
				{
				}

				void WriteNotImplemented(const WString& classFullName)
				{
					writer.WriteString(prefix);
					writer.WriteLine(L"{/* USER_CONTENT_BEGIN(" + classFullName + L") */");
					writer.WriteString(prefix);
					writer.WriteLine(L"\tthrow ::vl::Exception(L\"You should implement this function.\");");
					writer.WriteString(prefix);
					writer.WriteLine(L"}/* USER_CONTENT_END() */");
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (!IsVirtual(config, node))
					{
						printableMember = true;

						writer.WriteString(prefix);
						auto returnType = config->WriteFunctionHeader(writer, Ptr(node), classBaseName + L"::" + config->ConvertName(node->name.value), true);
						writer.WriteLine(L"");

						bool userImpl = config->attributeEvaluator->GetAttribute(node->attributes, L"cpp", L"UserImpl");
						if (userImpl)
						{
							WriteNotImplemented(classFullName);
						}
						else
						{
							config->WriteFunctionBody(writer, node->statement, prefix, returnType);
						}
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					auto scope = config->manager->nodeScopes[node].Obj();
					printableMember = true;
					auto methodInfo = dynamic_cast<IMethodInfo*>(config->manager->declarationMemberInfos[node].Obj());

					List<WString> arguments;
					for (auto argument : node->arguments)
					{
						arguments.Add(config->ConvertName(argument->name.value));
					}

					writer.WriteString(prefix);
					config->WriteFunctionHeader(writer, methodInfo, arguments, classBaseName + L"::" + className, false);
					writer.WriteLine(L"");

					vint callIndex = 0;
					for (auto call : node->baseConstructorCalls)
					{
						auto callType = CreateTypeInfoFromType(scope, call->type, false);
						auto callCtor = config->manager->baseConstructorCallResolvings[{node, callType->GetTypeDescriptor()}].value;

						writer.WriteString(prefix);
						if (callIndex++ == 0)
						{
							writer.WriteString(L"\t: ");
						}
						else
						{
							writer.WriteString(L"\t, ");
						}

						writer.WriteString(config->ConvertType(callType->GetTypeDescriptor()));
						writer.WriteString(L"(");
						for (auto [argument, argumentIndex] : indexed(call->arguments))
						{
							if (argumentIndex) writer.WriteString(L", ");
							GenerateExpression(config, writer, argument, callCtor->GetParameter(argumentIndex)->GetType());
						}
						writer.WriteLine(L")");
					}

					if (classDef)
					{
						WfGenerateClassMemberInitVisitor visitor(config, writer, prefix, callIndex);
						for (auto member : classDef->declarations)
						{
							member->Accept(&visitor);
						}
					}

					bool userImpl = config->attributeEvaluator->GetAttribute(node->attributes, L"cpp", L"UserImpl");
					if (userImpl)
					{
						WriteNotImplemented(classFullName);
					}
					else
					{
						config->WriteFunctionBody(writer, node->statement, prefix, nullptr);
					}
				}

				void Visit(WfDestructorDeclaration* node)override
				{
					printableMember = true;

					writer.WriteLine(prefix + classBaseName + L"::~" + className + L"()");

					bool userImpl = config->attributeEvaluator->GetAttribute(node->attributes, L"cpp", L"UserImpl");
					if (userImpl)
					{
						WriteNotImplemented(classFullName);
					}
					else
					{
						config->WriteFunctionBody(writer, node->statement, prefix, nullptr);
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
				}

				void Visit(WfEnumDeclaration* node)override
				{
				}

				void Visit(WfStructDeclaration* node)override
				{
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			bool GenerateClassMemberImpl(WfCppConfig* config, stream::StreamWriter& writer, WfClassDeclaration* classDef, const WString& classBaseName, const WString& className, const WString& classFullName, Ptr<WfDeclaration> memberDecl, const WString& prefix)
			{
				WfGenerateClassMemberImplVisitor visitor(config, writer, classDef, classBaseName, className, classFullName, prefix);
				memberDecl->Accept(&visitor);
				return visitor.printableMember;
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_COLLECT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace regex;
			using namespace reflection::description;
			using namespace analyzer;

/***********************************************************************
CollectModule
***********************************************************************/

			class WfCollectModuleVisitor : public traverse_visitor::AstVisitor
			{
			public:
				WfCppConfig*							config;
				Ptr<WfClassDeclaration>					surroundingClassDecl = nullptr;
				vint									skipCounter = 0;

				WfCollectModuleVisitor(WfCppConfig* _config)
					:config(_config)
				{
				}

				WString GetScopePostfix(WfLexicalScope* scope)
				{
					WString name;
					while (scope)
					{
						if (auto decl = scope->ownerNode.Cast<WfDeclaration>())
						{
							name = config->ConvertName(decl->name.value) + L"_" + name;
						}
						scope = scope->parentScope.Obj();
					}
					return name;
				}

				void Traverse(WfOrderedLambdaExpression* node)override
				{
					WString prefix = L"__vwsno" + itow(config->lambdaExprs.Count() + 1) + L"_" + config->assemblyName + L"_";
					WString postfix = GetScopePostfix(config->manager->nodeScopes[node].Obj());
					WString name = prefix + postfix;

					config->lambdaExprs.Add(Ptr(node), name);
					config->classClosures.Add(surroundingClassDecl, Ptr(node));
				}

				void Traverse(WfFunctionExpression* node)override
				{
					WString prefix = L"__vwsnf" + itow(config->lambdaExprs.Count() + 1) + L"_" + config->assemblyName + L"_";
					WString postfix = GetScopePostfix(config->manager->nodeScopes[node].Obj());
					WString name = prefix + postfix;

					config->lambdaExprs.Add(Ptr(node), name);
					config->classClosures.Add(surroundingClassDecl, Ptr(node));
				}

				void Traverse(WfNewInterfaceExpression* node)override
				{
					WString prefix = L"__vwsnc" + itow(config->classExprs.Count() + 1) + L"_" + config->assemblyName + L"_";
					WString postfix = GetScopePostfix(config->manager->nodeScopes[node].Obj());

					auto result = config->manager->expressionResolvings[node];
					auto td = result.constructorInfo->GetOwnerTypeDescriptor();
					WString name = prefix + postfix + config->ConvertType(td, L"_");

					config->classExprs.Add(Ptr(node), name);
					config->classClosures.Add(surroundingClassDecl, Ptr(node));
				}

				void Traverse(WfFunctionDeclaration* node)override
				{
					if (skipCounter == 1)
					{
						config->funcDecls.Add(Ptr(node));
					}
				}

				void Traverse(WfVariableDeclaration* node)override
				{
					if (skipCounter == 1)
					{
						config->varDecls.Add(Ptr(node));
					}
				}

				void Traverse(WfStaticInitDeclaration* node)override
				{
					config->staticInitDecls.Add(Ptr(node));
				}

				void Visit(WfClassDeclaration* node)override
				{
					config->classDecls.Add(surroundingClassDecl, Ptr(node));
					config->tdDecls.Add(config->manager->declarationTypes[node].Obj(), Ptr(node));

					if (!surroundingClassDecl)
					{
						WString file;
						if (auto att = config->attributeEvaluator->GetAttribute(node->attributes, L"cpp", L"File"))
						{
							auto attValue = config->attributeEvaluator->GetAttributeValue(att);
							CHECK_ERROR(attValue.type == runtime::WfInsType::String, L"Unexpected value in attribute: @cpp.File.");
							file = attValue.stringValue;
						}
						config->customFilesClasses.Add(file, Ptr(node));
					}

					auto oldSurroundingClassDecl = surroundingClassDecl;
					surroundingClassDecl = Ptr(node);
					skipCounter++;
					traverse_visitor::AstVisitor::Visit(node);
					skipCounter--;
					surroundingClassDecl = oldSurroundingClassDecl;
				}

				void Traverse(WfEnumDeclaration* node)override
				{
					config->enumDecls.Add(surroundingClassDecl, Ptr(node));
					config->tdDecls.Add(config->manager->declarationTypes[node].Obj(), Ptr(node));
				}

				void Traverse(WfStructDeclaration* node)override
				{
					config->structDecls.Add(surroundingClassDecl, Ptr(node));
					config->tdDecls.Add(config->manager->declarationTypes[node].Obj(), Ptr(node));
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					skipCounter++;
					traverse_visitor::AstVisitor::Visit(node);
					skipCounter--;
				}

				void Visit(WfVariableDeclaration* node)override
				{
					skipCounter++;
					traverse_visitor::AstVisitor::Visit(node);
					skipCounter--;
				}
			};

			void CollectModule(WfCppConfig* config, Ptr<WfModule> module)
			{
				WfCollectModuleVisitor(config).InspectInto(module.Obj());
			}

/***********************************************************************
WfCppConfig::CollectClosureInfo
***********************************************************************/

			class WfCppCollectClassExprInfoVisitor : public empty_visitor::DeclarationVisitor
			{
			public:
				WfCppConfig*							config;
				vint									variableCount = 0;
				Ptr<analyzer::WfLexicalCapture>			capture;

				WfCppCollectClassExprInfoVisitor(WfCppConfig* _config)
					:config(_config)
				{
				}

				void Visit(WfVariableDeclaration* node)override
				{
					variableCount++;
				}

				void Dispatch(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Dispatch(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Execute(WfNewInterfaceExpression* node)
				{
					capture = config->manager->lambdaCaptures[node];
					for (auto memberDecl : node->declarations)
					{
						memberDecl->Accept(this);
					}
				}
			};

			Ptr<WfCppConfig::ClosureInfo> WfCppConfig::CollectClosureInfo(Ptr<WfExpression> closure)
			{
				using SymbolPair = Pair<WString, Ptr<analyzer::WfLexicalSymbol>>;

				auto info = Ptr(new ClosureInfo);
				WfLexicalScope* scope = nullptr;

				if (auto ordered = closure.Cast<WfOrderedLambdaExpression>())
				{
					// stable symbol order by sorting them by name
					CopyFrom(
						info->symbols,
						From(manager->lambdaCaptures[ordered.Obj()]->symbols)
							.Select([](Ptr<WfLexicalSymbol> symbol)
							{
								return SymbolPair(symbol->name, symbol);
							})
						);
					scope = manager->nodeScopes[ordered.Obj()].Obj();
				}
				else if (auto funcExpr = closure.Cast<WfFunctionExpression>())
				{
					// stable symbol order by sorting them by name
					CopyFrom(
						info->symbols,
						From(manager->lambdaCaptures[funcExpr->function.Obj()]->symbols)
							.Select([](Ptr<WfLexicalSymbol> symbol)
							{
								return SymbolPair(symbol->name, symbol);
							})
						);
					scope = manager->nodeScopes[funcExpr->function.Obj()].Obj();
				}
				else if (auto classExpr = closure.Cast<WfNewInterfaceExpression>())
				{
					WfCppCollectClassExprInfoVisitor visitor(this);
					visitor.Execute(classExpr.Obj());

					if (visitor.capture)
					{
						// stable symbol order by sorting them by name
						CopyFrom(
							info->symbols,
							From(visitor.capture->symbols)
								.Skip(visitor.variableCount)
								.Select([](Ptr<WfLexicalSymbol> symbol)
								{
									return SymbolPair(symbol->name, symbol);
								})
							);

						CopyFrom(
							info->ctorArgumentSymbols,
							From(visitor.capture->ctorArgumentSymbols)
								.Select([](Ptr<WfLexicalSymbol> symbol)
								{
									return SymbolPair(symbol->name, symbol);
								})
							);
					}

					scope = manager->nodeScopes[classExpr.Obj()].Obj();
				}

				Ptr<WfLexicalFunctionConfig> methodConfig;
				while (scope)
				{
					if (scope->typeOfThisExpr)
					{
						if (methodConfig)
						{
							info->thisTypes.Add(scope->typeOfThisExpr);
							if (!methodConfig->parentThisAccessable)
							{
								break;
							}
							methodConfig = nullptr;
						}
					}

					if (scope->functionConfig)
					{
						if (scope->functionConfig->thisAccessable)
						{
							methodConfig = scope->functionConfig;
						}
					}
					scope = scope->parentScope.Obj();
				}

				return info;
			}

/***********************************************************************
WfCppConfig::Collect
***********************************************************************/

			void WfCppConfig::Collect()
			{
				for (auto module : manager->GetModules())
				{
					CollectModule(this, module);
				}

				for (auto lambda : lambdaExprs.Keys())
				{
					auto closureInfo = CollectClosureInfo(lambda);
					closureInfo->lambdaClassName = lambdaExprs[lambda.Obj()];
					closureInfos.Add(lambda, closureInfo);
				}

				for (auto classExpr : classExprs.Keys())
				{
					auto closureInfo = CollectClosureInfo(classExpr);
					closureInfo->lambdaClassName = classExprs[classExpr.Obj()];
					closureInfos.Add(classExpr, closureInfo);
				}
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_EXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace regex;
			using namespace stream;
			using namespace reflection;
			using namespace reflection::description;
			using namespace analyzer;

/***********************************************************************
Expression Helpers
***********************************************************************/

			template<typename T>
			void WriteBoxValue(WfCppConfig* config, stream::StreamWriter& writer, ITypeInfo* type, const T& writeExpression)
			{
				writer.WriteString(L"::vl::__vwsn::Box(");
				writeExpression();
				writer.WriteString(L")");
			}

			template<typename T>
			void WriteUnboxValue(WfCppConfig* config, stream::StreamWriter& writer, ITypeInfo* type, const T& writeExpression)
			{
				writer.WriteString(L"::vl::__vwsn::Unbox<");
				writer.WriteString(config->ConvertType(type));
				writer.WriteString(L">(");
				writeExpression();
				writer.WriteString(L")");
			}

			template<typename T>
			void WriteUnboxWeakValue(WfCppConfig* config, stream::StreamWriter& writer, ITypeInfo* type, const T& writeExpression)
			{
				writer.WriteString(L"::vl::__vwsn::UnboxWeak<");
				writer.WriteString(config->ConvertType(type));
				writer.WriteString(L">(");
				writeExpression();
				writer.WriteString(L")");
			}

			template<typename T>
			void ConvertValueType(WfCppConfig* config, stream::StreamWriter& writer, ITypeDescriptor* fromTd, ITypeDescriptor* toTd, const T& writeExpression)
			{
				if (fromTd == toTd)
				{
					writeExpression();
				}
				else if (fromTd == description::GetTypeDescriptor<WString>())
				{
					writer.WriteString(L"::vl::__vwsn::Parse<");
					writer.WriteString(config->ConvertType(toTd));
					writer.WriteString(L">(");
					writeExpression();
					writer.WriteString(L")");
				}
				else if (toTd == description::GetTypeDescriptor<WString>())
				{
					writer.WriteString(L"::vl::__vwsn::ToString(");
					writeExpression();
					writer.WriteString(L")");
				}
				else
				{
					writer.WriteString(L"static_cast<");
					writer.WriteString(config->ConvertType(toTd));
					writer.WriteString(L">(");
					writeExpression();
					writer.WriteString(L")");
				}
			}

			void ConvertType(WfCppConfig* config, stream::StreamWriter& writer, ITypeInfo* fromType, ITypeInfo* toType, const Func<void()>& writeExpression, bool strongCast)
			{
				if (fromType->GetTypeDescriptor()->GetTypeDescriptorFlags() == TypeDescriptorFlags::Object)
				{
					if (strongCast)
					{
						WriteUnboxValue(config, writer, toType, writeExpression);
					}
					else
					{
						WriteUnboxWeakValue(config, writer, toType, writeExpression);
					}
					return;
				}
				else if (toType->GetTypeDescriptor()->GetTypeDescriptorFlags() == TypeDescriptorFlags::Object)
				{
					WriteBoxValue(config, writer, fromType, writeExpression);
					return;
				}
				else
				{
					auto tdVe = description::GetTypeDescriptor<IValueEnumerable>();
					if (toType->GetTypeDescriptor() == tdVe)
					{
						if (toType->GetElementType()->GetDecorator() == ITypeInfo::Generic)
						{
							if ((fromType->GetTypeDescriptor() == tdVe && fromType->GetElementType()->GetDecorator() != ITypeInfo::Generic)
								|| fromType->GetTypeDescriptor()->CanConvertTo(description::GetTypeDescriptor<IValueReadonlyList>())
								|| fromType->GetTypeDescriptor()->CanConvertTo(description::GetTypeDescriptor<IValueReadonlyDictionary>())
								)
							{
								writer.WriteString(L"::vl::reflection::description::GetLazyList<");
								writer.WriteString(config->ConvertType(toType->GetElementType()->GetGenericArgument(0)));
								writer.WriteString(L">(");
								writeExpression();
								writer.WriteString(L")");
								return;
							}
						}
						else
						{
							if ((fromType->GetTypeDescriptor() == tdVe && fromType->GetElementType()->GetDecorator() == ITypeInfo::Generic)
								|| fromType->GetHint() == TypeInfoHint::NativeCollectionReference
								)
							{
								writer.WriteString(L"::vl::__vwsn::UnboxCollection<");
								writer.WriteString(config->ConvertType(tdVe));
								writer.WriteString(L">(");
								writeExpression();
								writer.WriteString(L")");
								return;
							}
						}
					}

					switch (fromType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						{
							switch (toType->GetDecorator())
							{
							case ITypeInfo::RawPtr:
								if (strongCast) writer.WriteString(L"::vl::__vwsn::Ensure(");
								if (fromType->GetTypeDescriptor()->CanConvertTo(toType->GetTypeDescriptor()))
								{
									writer.WriteString(L"static_cast<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L"*>(");
									writeExpression();
									writer.WriteString(L")");
								}
								else
								{
									writer.WriteString(L"::vl::__vwsn::RawPtrCast<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L">(");
									writeExpression();
									writer.WriteString(L")");
								}
								if (strongCast) writer.WriteString(L")");
								return;
							case ITypeInfo::SharedPtr:
								if (strongCast) writer.WriteString(L"::vl::__vwsn::Ensure(");
								if (fromType->GetTypeDescriptor()->CanConvertTo(toType->GetTypeDescriptor()))
								{
									writer.WriteString(L"::vl::Ptr<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L">(");
									writeExpression();
									writer.WriteString(L")");
								}
								else
								{
									writer.WriteString(L"::vl::__vwsn::SharedPtrCast<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L">(");
									writeExpression();
									writer.WriteString(L")");
								}
								if (strongCast) writer.WriteString(L")");
								return;
							default:;
							}
						}
						break;
					case ITypeInfo::SharedPtr:
						{
							switch (toType->GetDecorator())
							{
							case ITypeInfo::RawPtr:
								if (strongCast) writer.WriteString(L"::vl::__vwsn::Ensure(");
								if (fromType->GetTypeDescriptor()->CanConvertTo(toType->GetTypeDescriptor()))
								{
									writer.WriteString(L"static_cast<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L"*>(");
									writeExpression();
									writer.WriteString(L".Obj())");
								}
								else
								{
									writer.WriteString(L"::vl::__vwsn::RawPtrCast<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L">(");
									writeExpression();
									writer.WriteString(L".Obj())");
								}
								if (strongCast) writer.WriteString(L")");
								return;
							case ITypeInfo::SharedPtr:
								if (strongCast) writer.WriteString(L"::vl::__vwsn::Ensure(");
								if (fromType->GetTypeDescriptor()->CanConvertTo(toType->GetTypeDescriptor()))
								{
									writer.WriteString(L"::vl::Ptr<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L">(");
									writeExpression();
									writer.WriteString(L")");
								}
								else
								{
									writer.WriteString(L"::vl::__vwsn::SharedPtrCast<");
									writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
									writer.WriteString(L">(");
									writeExpression();
									writer.WriteString(L".Obj())");
								}
								if (strongCast) writer.WriteString(L")");
								return;
							default:;
							}
						}
						break;
					case ITypeInfo::Nullable:
						{
							switch (toType->GetDecorator())
							{
							case ITypeInfo::Nullable:
								if (strongCast) writer.WriteString(L"::vl::__vwsn::Ensure(");
								writer.WriteString(L"::vl::__vwsn::NullableCast<");
								writer.WriteString(config->ConvertType(toType->GetTypeDescriptor()));
								writer.WriteString(L">(");
								writeExpression();
								writer.WriteString(L")");
								if (strongCast) writer.WriteString(L")");
								return;
							case ITypeInfo::TypeDescriptor:
								ConvertValueType(config, writer, fromType->GetTypeDescriptor(), toType->GetTypeDescriptor(), [&]()
								{
									writeExpression();
									writer.WriteString(L".Value()");
								});
								return;
							default:;
							}
						}
						break;
					case ITypeInfo::TypeDescriptor:
						{
							switch (toType->GetDecorator())
							{
							case ITypeInfo::Nullable:
								writer.WriteString(config->ConvertType(toType));
								writer.WriteString(L"(");
								ConvertValueType(config, writer, fromType->GetTypeDescriptor(), toType->GetTypeDescriptor(), writeExpression);
								writer.WriteString(L")");
								return;
							case ITypeInfo::TypeDescriptor:
								ConvertValueType(config, writer, fromType->GetTypeDescriptor(), toType->GetTypeDescriptor(), writeExpression);
								return;
							default:;
							}
						}
						break;
					default:;
					}
				}
				writer.WriteString(L"/* NOT EXISTS: convert (");
				writer.WriteString(config->ConvertType(fromType));
				writer.WriteString(L") to (");
				writer.WriteString(config->ConvertType(toType));
				writer.WriteString(L") */ __vwsn_not_exists__(");
				writeExpression();
				writer.WriteString(L")");
			}

/***********************************************************************
WfGenerateExpressionVisitor
***********************************************************************/

			class WfGenerateExpressionVisitor
				: public Object
				, public WfExpression::IVisitor
			{
			public:
				WfCppConfig*				config;
				stream::StreamWriter&		writer;
				bool						useReturnValue;

				WfGenerateExpressionVisitor(WfCppConfig* _config, stream::StreamWriter& _writer, bool _useReturnValue)
					:config(_config)
					, writer(_writer)
					, useReturnValue(_useReturnValue)
				{
				}

				bool NeedConvertType(ITypeInfo* fromType, ITypeInfo*& toType)
				{
					if (toType == nullptr)
					{
						toType = fromType;
						return false;
					}
					if (IsSameType(fromType, toType))
					{
						return false;
					}
					else
					{
						return true;
					}
				}

				template<typename T>
				void WriteBoxValue(ITypeInfo* type, const T& writeExpression)
				{
					cppcodegen::WriteBoxValue(config, writer, type, writeExpression);
				}

				template<typename T>
				void WriteUnboxValue(ITypeInfo* type, const T& writeExpression)
				{
					cppcodegen::WriteUnboxValue(config, writer, type, writeExpression);
				}

				template<typename T>
				void WriteUnboxWeakValue(ITypeInfo* type, const T& writeExpression)
				{
					cppcodegen::WriteUnboxWeakValue(config, writer, type, writeExpression);
				}

				void ConvertMultipleTypes(ITypeInfo** types, vint typesLength, Func<void()> writeExpression)
				{
					if (typesLength == 1)
					{
						writeExpression();
					}
					else if (NeedConvertType(types[0], types[1]))
					{
						ConvertMultipleTypes(types + 1, typesLength - 1, [&]()
						{
							auto fromType = types[0];
							auto toType = types[1];
							ConvertType(config, writer, fromType, toType, writeExpression, false);
						});
					}
					else
					{
						return ConvertMultipleTypes(types + 1, typesLength - 1, writeExpression);
					}
				}

				void Call(Ptr<WfExpression> node, ITypeInfo* expectedType = nullptr, bool useReturnValue = true)
				{
					GenerateExpression(config, writer, node, expectedType, useReturnValue);
				}

				Ptr<WfCppConfig::ClosureInfo> GetClosureInfo(WfExpression* node, Ptr<WfLexicalSymbol> testCtorArgumentSymbol = nullptr)
				{
					Ptr<WfCppConfig::ClosureInfo> closureInfo;
					auto scope = config->manager->nodeScopes[node].Obj();

					if (dynamic_cast<WfOrderedLambdaExpression*>(node))
					{
						scope = scope->parentScope.Obj();
					}

					while (scope)
					{
						if (scope->functionConfig && scope->functionConfig->lambda)
						{
							auto source = scope->ownerNodeSource ? scope->ownerNodeSource : scope->ownerNode.Obj();
							if (auto ordered = dynamic_cast<WfOrderedLambdaExpression*>(source))
							{
								closureInfo = config->closureInfos[ordered];
								break;
							}
							else if (auto funcExpr = dynamic_cast<WfFunctionExpression*>(source))
							{
								closureInfo = config->closureInfos[funcExpr];
								break;
							}
							else if (auto classExpr = dynamic_cast<WfNewInterfaceExpression*>(source))
							{
								closureInfo = config->closureInfos[classExpr];
								break;
							}
						}
						else if (auto classExpr = scope->ownerNode.Cast<WfNewInterfaceExpression>())
						{
							auto info = config->closureInfos[classExpr.Obj()];
							if (info->ctorArgumentSymbols.Values().Contains(testCtorArgumentSymbol.Obj()))
							{
								closureInfo = info;
								break;
							}
						}
						scope = scope->parentScope.Obj();
					}

					return closureInfo;
				}

				void WriteNotExists(ITypeDescriptor* typeDescriptor)
				{
					writer.WriteString(L"/* NOT EXISTS: type(");
					writer.WriteString(typeDescriptor->GetTypeName());
					writer.WriteString(L") */ __vwsn_not_exists__");
				}

				void WriteNotExists(IMethodInfo* methodInfo)
				{
					writer.WriteString(L"/* NOT EXISTS: method(");
					writer.WriteString(methodInfo->GetName());
					writer.WriteString(L") of type (");
					writer.WriteString(methodInfo->GetOwnerTypeDescriptor()->GetTypeName());
					writer.WriteString(L") */ __vwsn_not_exists__");
				}

				void WriteNotExists(IPropertyInfo* propertyInfo)
				{
					writer.WriteString(L"/* NOT EXISTS: property(");
					writer.WriteString(propertyInfo->GetName());
					writer.WriteString(L") of type (");
					writer.WriteString(propertyInfo->GetOwnerTypeDescriptor()->GetTypeName());
					writer.WriteString(L") */ __vwsn_not_exists__");
				}

				void WriteNotExists(IEventInfo* eventInfo)
				{
					writer.WriteString(L"/* NOT EXISTS: event(");
					writer.WriteString(eventInfo->GetName());
					writer.WriteString(L") of type (");
					writer.WriteString(eventInfo->GetOwnerTypeDescriptor()->GetTypeName());
					writer.WriteString(L") */ __vwsn_not_exists__");
				}

				template<typename T>
				void WriteTemplate(const WString& templateValue, const T& callback)
				{
					List<Ptr<RegexMatch>> matches;
					config->regexTemplate.Cut(templateValue, false, matches);
					for (auto match : matches)
					{
						WString item = match->Result().Value();
						if (match->Success())
						{
							if (!callback(item))
							{
								writer.WriteString(L"/* NOT EXISTS: ");
								writer.WriteString(item);
								writer.WriteString(L" */ __vwsn_not_exists__");
							}
						}
						else
						{
							writer.WriteString(item);
						}
					}
				}

				void VisitThisExpression(WfExpression* node, ITypeDescriptor* td)
				{
					if (auto closureInfo = GetClosureInfo(node))
					{
						for (auto [thisType, index] : indexed(closureInfo->thisTypes))
						{
							if (thisType->CanConvertTo(td))
							{
								writer.WriteString(L"__vwsnthis_");
								writer.WriteString(itow(index));
								return;
							}
						}
					}
					writer.WriteString(L"this");
				}

				void VisitSymbol(WfExpression* node, Ptr<WfLexicalSymbol> symbol, bool forLambdaArgument)
				{
					if (auto varDecl = symbol->creatorNode.Cast<WfVariableDeclaration>())
					{
						auto ownerNode = symbol->ownerScope->ownerNode;
						if (ownerNode.Cast<WfNamespaceDeclaration>() || ownerNode.Cast<WfModule>())
						{
							writer.WriteString(L"GLOBAL_NAME ");
							writer.WriteString(config->ConvertName(symbol->name));
							return;
						}
						else if(auto closureInfo = GetClosureInfo(node, (forLambdaArgument ? nullptr : symbol)))
						{
							if (closureInfo->symbols.Values().Contains(symbol.Obj()))
							{
								writer.WriteString(L"this->");
								writer.WriteString(config->ConvertName(symbol->name));
								return;
							}
							else if (closureInfo->ctorArgumentSymbols.Values().Contains(symbol.Obj()))
							{
								writer.WriteString(L"__vwsnctor_");
								writer.WriteString(config->ConvertName(symbol->name));
								return;
							}
						}
						writer.WriteString(config->ConvertName(symbol->name));
						return;
					}
					else if (auto funcDecl = symbol->creatorNode.Cast<WfFunctionDeclaration>())
					{
						auto ownerNode = symbol->ownerScope->ownerNode;
						if (ownerNode.Cast<WfNamespaceDeclaration>() || ownerNode.Cast<WfModule>())
						{
							writer.WriteString(config->ConvertType(symbol->typeInfo.Obj()));
							writer.WriteString(L"(GLOBAL_OBJ, &GLOBAL_SYMBOL ");
							writer.WriteString(config->ConvertName(symbol->name));
							writer.WriteString(L")");
							return;
						}
						else if (auto classExpr = ownerNode.Cast<WfNewInterfaceExpression>())
						{
							writer.WriteString(config->ConvertType(symbol->typeInfo.Obj()));
							writer.WriteString(L"(this, &");
							writer.WriteString(config->classExprs[classExpr.Obj()]);
							writer.WriteString(L"::");
							writer.WriteString(config->ConvertName(symbol->name));
							writer.WriteString(L")");
							return;
						}
						else if (symbol->ownerScope->functionConfig && symbol->ownerScope->functionConfig->lambda && symbol->name == funcDecl->name.value)
						{
							auto scope = config->manager->nodeScopes[funcDecl.Obj()];
							auto closureInfo = config->closureInfos[dynamic_cast<WfFunctionExpression*>(scope->ownerNodeSource)];

							writer.WriteString(L"vl::Func(::");
							writer.WriteString(config->assemblyNamespace);
							writer.WriteString(L"::");
							writer.WriteString(closureInfo->lambdaClassName);
							writer.WriteString(L"(");

							for (auto [symbolName, index] : indexed(closureInfo->symbols.Keys()))
							{
								if (index > 0)
								{
									writer.WriteString(L", ");
								}
								writer.WriteString(config->ConvertName(symbol->name));
							}

							for (auto [thisType, index] : indexed(closureInfo->thisTypes))
							{
								if (index > 0 || closureInfo->symbols.Count() > 0)
								{
									writer.WriteString(L", ");
								}
								writer.WriteString(L" __vwsnctorthis_" + itow(index));
							}

							writer.WriteString(L"))");
							return;
						}
					}
					writer.WriteString(config->ConvertName(symbol->name));
				}

				enum class CommaPosition
				{
					Left,
					Right,
					No,
				};

				bool IsCppRefGenericType(ITypeInfo* type)
				{
					switch (type->GetHint())
					{
					case TypeInfoHint::Array:
					case TypeInfoHint::List:
					case TypeInfoHint::SortedList:
					case TypeInfoHint::ObservableList:
					case TypeInfoHint::Dictionary:
						return true;
					default:
						return false;
					}
				}

				template<typename TReturnValue>
				void WriteReturnValue(ITypeInfo* type, const TReturnValue& returnValueCallback, bool castReturnValue)
				{
					if (castReturnValue)
					{
						if (IsCppRefGenericType(type) || type->GetHint() == TypeInfoHint::NativeCollectionReference)
						{
							writer.WriteString(L"::vl::__vwsn::UnboxCollection<");
							writer.WriteString(config->ConvertType(type->GetTypeDescriptor()));
							writer.WriteString(L">(");
							returnValueCallback();
							writer.WriteString(L")");
							return;
						}
					}
					returnValueCallback();
				}

				template<typename TType, typename TInvoke, typename TArgument, typename TInfo>
				void WriteInvokeTemplate(vint count, ITypeInfo* returnType, const TType& typeCallback, const TInvoke& invokeCallback, const TArgument& argumentCallback, TInfo* info, bool castReturnValue)
				{
					auto unboxedArgumentCallback = [&](vint index)
					{
						auto type = typeCallback(index);
						if (IsCppRefGenericType(type))
						{
							writer.WriteString(L"::vl::reflection::description::UnboxParameter<");
							{
								switch (type->GetHint())
								{
								case TypeInfoHint::Array:
									writer.WriteString(L"::vl::collections::Array<");
									break;
								case TypeInfoHint::List:
									writer.WriteString(L"::vl::collections::List<");
									break;
								case TypeInfoHint::SortedList:
									writer.WriteString(L"::vl::collections::SortedList<");
									break;
								case TypeInfoHint::ObservableList:
									writer.WriteString(L"::vl::collections::ObservableList<");
									break;
								case TypeInfoHint::Dictionary:
									writer.WriteString(L"::vl::collections::Dictionary<");
									break;
								default:;
								}

								vint count = type->GetElementType()->GetGenericArgumentCount();
								for (vint i = 0; i < count; i++)
								{
									if (i > 0) writer.WriteString(L", ");
									writer.WriteString(config->ConvertType(type->GetElementType()->GetGenericArgument(i)));
								}
							}
							writer.WriteString(L">>(::vl::__vwsn::Box(");
							argumentCallback(info, index);
							writer.WriteString(L")).Ref()");
						}
						else
						{
							argumentCallback(info, index);
						}
					};
					WriteReturnValue(returnType, [&]() { invokeCallback(unboxedArgumentCallback); }, castReturnValue);
				}

				template<typename TThis, typename TArgument>
				void WriteMethodTemplate(const WString& templateValue, IMethodInfo* methodInfo, const TThis& thisCallback, const TArgument& argumentCallback, bool castReturnValue)
				{
					WriteInvokeTemplate(methodInfo->GetParameterCount(), methodInfo->GetReturn(), [&](vint index) { return methodInfo->GetParameter(index)->GetType(); },
						[&](auto&& unboxedArgumentCallback)
						{
							WriteTemplate(templateValue, [&](const WString& item)
							{
								auto cp = CommaPosition::No;
								vint count = methodInfo->GetParameterCount();

								if (item == L"$Type")
								{
									writer.WriteString(config->ConvertType(methodInfo->GetOwnerTypeDescriptor()));
									return true;
								}
								else if (item == L"$Func")
								{
									writer.WriteString(config->ConvertFunctionType(methodInfo));
									return true;
								}
								else if (item == L"$Name")
								{
									writer.WriteString(config->ConvertName(methodInfo->GetName()));
									return true;
								}
								else if (item == L"$This")
								{
									if (!methodInfo->IsStatic())
									{
										return thisCallback(methodInfo);
									}
								}
								else if (item == L"$Arguments")
								{
									if (count == 0)
									{
										return true;
									}
								}
								else if (item == L", $Arguments")
								{
									if (count == 0)
									{
										return true;
									}
									cp = CommaPosition::Left;
								}
								else if (item == L"$Arguments, ")
								{
									if (count == 0)
									{
										return true;
									}
									cp = CommaPosition::Right;
								}
								else
								{
									return false;
								}

								if (count > 0)
								{
									if (cp == CommaPosition::Left) writer.WriteString(L", ");
									for (vint i = 0; i < count; i++)
									{
										if (i > 0) writer.WriteString(L", ");
										unboxedArgumentCallback(i);
									}
									if (cp == CommaPosition::Right) writer.WriteString(L", ");
								}
								return true;
							});
						}, argumentCallback, methodInfo, castReturnValue);
				}

				template<typename TThis>
				void WritePropertyTemplate(const WString& templateValue, IPropertyInfo* propertyInfo, const TThis& thisCallback, bool castReturnValue)
				{
					WriteReturnValue(propertyInfo->GetReturn(),
						[&]()
						{
							WriteTemplate(templateValue, [&](const WString& item)
							{
								if (item == L"$Type")
								{
									writer.WriteString(config->ConvertType(propertyInfo->GetOwnerTypeDescriptor()));
									return true;
								}
								else if (item == L"$Name")
								{
									writer.WriteString(config->ConvertName(propertyInfo->GetName()));
									return true;
								}
								else if (item == L"$This")
								{
									return thisCallback(propertyInfo);
								}
								return false;
							});
						}, castReturnValue);
				}

				template<typename TThis, typename THandler, typename TArgument>
				void WriteEventTemplate(const WString& templateValue, IEventInfo* eventInfo, const TThis& thisCallback, const THandler& handlerCallback, const TArgument& argumentCallback)
				{
					auto handlerType = eventInfo->GetHandlerType()->GetElementType();
					WriteInvokeTemplate(handlerType->GetGenericArgumentCount() - 1, handlerType->GetGenericArgument(0), [&](vint index) { return handlerType->GetGenericArgument(index + 1); },
						[&](auto&& unboxedArgumentCallback)
						{
							WriteTemplate(templateValue, [&](const WString& item)
							{
								auto cp = CommaPosition::No;
								vint count = eventInfo->GetHandlerType()->GetElementType()->GetGenericArgumentCount() - 1;

								if (item == L"$Name")
								{
									writer.WriteString(config->ConvertName(eventInfo->GetName()));
									return true;
								}
								else if (item == L"$This")
								{
									return thisCallback(eventInfo);
								}
								else if (item == L"$Handler")
								{
									return handlerCallback(eventInfo);
								}
								else if (item == L"$Arguments")
								{
									if (count == 0)
									{
										return true;
									}
								}
								else if (item == L", $Arguments")
								{
									if (count == 0)
									{
										return true;
									}
									cp = CommaPosition::Left;
								}
								else if (item == L"$Arguments, ")
								{
									if (count == 0)
									{
										return true;
									}
									cp = CommaPosition::Right;
								}
								else
								{
									return false;
								}

								if (count > 0)
								{
									if (cp == CommaPosition::Left) writer.WriteString(L", ");
									for (vint i = 0; i < count; i++)
									{
										if (i > 0) writer.WriteString(L", ");
										unboxedArgumentCallback(i);
									}
									if (cp == CommaPosition::Right) writer.WriteString(L", ");
								}
								return true;
							});
						}, argumentCallback, eventInfo, false);
				}

				template<typename TMethodThis, typename TPropertyThis>
				bool WriteReferenceTemplate(ResolveExpressionResult& result, const TMethodThis& methodThis, const TPropertyThis& propertyThis, bool castReturnValue)
				{
					if (result.methodInfo)
					{
						if (CppExists(result.methodInfo))
						{
							auto methodInfo = result.methodInfo;
							WriteMethodTemplate(CppGetClosureTemplate(methodInfo), methodInfo, methodThis, [&](IMethodInfo*, vint){}, castReturnValue);
						}
						else
						{
							WriteNotExists(result.methodInfo);
						}
						return true;
					}
					else if (result.propertyInfo)
					{
						if (CppExists(result.propertyInfo))
						{
							if (result.propertyInfo->GetCpp() == nullptr && result.propertyInfo->GetGetter() != nullptr)
							{
								auto methodInfo = result.propertyInfo->GetGetter();
								WriteMethodTemplate(CppGetInvokeTemplate(methodInfo), methodInfo, methodThis, [&](IMethodInfo*, vint){}, castReturnValue);
							}
							else
							{
								auto templateValue = CppGetReferenceTemplate(result.propertyInfo);
								auto propertyInfo = result.propertyInfo;
								WritePropertyTemplate(CppGetReferenceTemplate(propertyInfo), propertyInfo, propertyThis, castReturnValue);
							}
						}
						else
						{
							WriteNotExists(result.propertyInfo);
						}
						return true;
					}
					else
					{
						return false;
					}
				}

				void VisitReferenceExpression(WfExpression* node, const WString& name)
				{
					auto result = config->manager->expressionResolvings[node];
					bool success = WriteReferenceTemplate(result,
						[&](IMethodInfo* methodInfo)
						{
							VisitThisExpression(node, methodInfo->GetOwnerTypeDescriptor());
							return true;
						},
						[&](IPropertyInfo* propertyInfo)
						{
							auto isRef = (propertyInfo->GetOwnerTypeDescriptor()->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined;
							VisitThisExpression(node, propertyInfo->GetOwnerTypeDescriptor());
							return true;
						}, useReturnValue);

					if (!success)
					{
						if (result.symbol)
						{
							VisitSymbol(node, result.symbol, false);
						}
						else
						{
							if ((result.type->GetTypeDescriptor()->GetTypeDescriptorFlags() & TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
							{
								auto enumType = result.type->GetTypeDescriptor()->GetEnumType();
								Ptr<ITypeInfo> enumValueType;
								if (result.type->GetDecorator() == ITypeInfo::TypeDescriptor)
								{
									enumValueType = result.type;
								}
								else
								{
									enumValueType = Ptr(new TypeDescriptorTypeInfo(result.type->GetTypeDescriptor(), TypeInfoHint::Normal));
								}
								vint index = enumType->IndexOfItem(name);
								if (index != -1)
								{
									ITypeInfo* types[] = { enumValueType.Obj(),result.type.Obj() };
									ConvertMultipleTypes(types, (sizeof(types) / sizeof(*types)), [=, this]()
									{
										writer.WriteString(config->ConvertType(result.type->GetTypeDescriptor()));
										writer.WriteString(L"::");
										writer.WriteString(name);
									});
									return;
								}
							}
							CHECK_FAIL(L"WfGenerateExpressionVisitor::VisitReferenceExpression(WfExpression*, const WString&)#Internal error, cannot find any record of this expression.");
						}
					}
				}
				
				void WriteClosureArguments(Ptr<WfCppConfig::ClosureInfo> closureInfo, WfExpression* node)
				{
					vint index = 0;

					for (auto symbol : From(closureInfo->symbols.Values()).Union(closureInfo->ctorArgumentSymbols.Values()))
					{
						if (index++ > 0)
						{
							writer.WriteString(L", ");
						}
						VisitSymbol(node, symbol, true);
					}

					for (auto thisType : closureInfo->thisTypes)
					{
						if (index++ > 0)
						{
							writer.WriteString(L", ");
						}
						VisitThisExpression(node, thisType);
					}
				}

				void Visit(WfThisExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					VisitThisExpression(node, result.type->GetTypeDescriptor());
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfReferenceExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					writer.WriteString(L"vl::Func(::");
					writer.WriteString(config->assemblyNamespace);
					writer.WriteString(L"::");
					writer.WriteString(config->lambdaExprs[node]);
					writer.WriteString(L"(");

					auto closureInfo = config->closureInfos[node];
					WriteClosureArguments(closureInfo, node);

					writer.WriteString(L"))");
				}

				void Visit(WfMemberExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					auto parentResult = config->manager->expressionResolvings[node->parent.Obj()];
					WriteReferenceTemplate(result,
						[&](IMethodInfo* methodInfo)
						{
							writer.WriteString(L"::vl::__vwsn::This(");
							Call(node->parent);
							if (parentResult.type->GetDecorator() == ITypeInfo::SharedPtr)
							{
								writer.WriteString(L".Obj()");
							}
							writer.WriteString(L")");
							return true;
						},
						[&](IPropertyInfo* propertyInfo)
						{
							auto isRef = (propertyInfo->GetOwnerTypeDescriptor()->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined;
							if (isRef) writer.WriteString(L"::vl::__vwsn::This(");
							Call(node->parent);
							if (parentResult.type->GetDecorator() == ITypeInfo::SharedPtr)
							{
								writer.WriteString(L".Obj()");
							}
							else if (parentResult.type->GetDecorator() == ITypeInfo::Nullable)
							{
								writer.WriteString(L".Value()");
							}
							if (isRef) writer.WriteString(L")");
							return true;
						}, useReturnValue);
				}

				void Visit(WfChildExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfLiteralExpression* node)override
				{
					switch (node->value)
					{
					case WfLiteralValue::Null:
						{
							auto result = config->manager->expressionResolvings[node];
							switch (result.type->GetDecorator())
							{
							case ITypeInfo::Nullable:
							case ITypeInfo::SharedPtr:
								writer.WriteString(config->ConvertType(result.type.Obj()));
								writer.WriteString(L"()");
								break;
							case ITypeInfo::TypeDescriptor:
								writer.WriteString(L"::vl::reflection::description::Value()");
								break;
							default:
								writer.WriteString(L"static_cast<");
								writer.WriteString(config->ConvertType(result.type.Obj()));
								writer.WriteString(L">(nullptr)");
							}
						}
						break;
					case WfLiteralValue::True:
						writer.WriteString(L"true");
						break;
					case WfLiteralValue::False:
						writer.WriteString(L"false");
						break;
					default:;
					}
				}

				void Visit(WfFloatingExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					auto td = result.type->GetTypeDescriptor();

					writer.WriteString(L"static_cast<");
					writer.WriteString(config->ConvertType(td));
					writer.WriteString(L">(");
					if (td == description::GetTypeDescriptor<float>())
					{
						writer.WriteString(node->value.value + L"f");
					}
					else
					{
						writer.WriteString(node->value.value);
					}
					writer.WriteString(L")");
				}

				void Visit(WfIntegerExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					auto td = result.type->GetTypeDescriptor();

					writer.WriteString(L"static_cast<");
					writer.WriteString(config->ConvertType(td));
					writer.WriteString(L">(");
					if (td == description::GetTypeDescriptor<vuint32_t>())
					{
						writer.WriteString(node->value.value + L"U");
					}
					else if (td == description::GetTypeDescriptor<vint64_t>())
					{
						writer.WriteString(node->value.value + L"L");
					}
					else if (td == description::GetTypeDescriptor<vuint64_t>())
					{
						writer.WriteString(node->value.value + L"UL");
					}
					else
					{
						writer.WriteString(node->value.value);
					}
					writer.WriteString(L")");
				}

				void Visit(WfStringExpression* node)override
				{
					writer.WriteString(L"::vl::WString::Unmanaged(L\"");
					for (vint i = 0; i < node->value.value.Length(); i++)
					{
						auto c = node->value.value[i];
						switch (c)
						{
						case L'\\': writer.WriteString(L"\\\\"); break;
						case L'\'': writer.WriteString(L"\\\'"); break;
						case L'\"': writer.WriteString(L"\\\""); break;
						case L'\r': writer.WriteString(L"\\r"); break;
						case L'\n': writer.WriteString(L"\\n"); break;
						case L'\t': writer.WriteString(L"\\t"); break;
						default: writer.WriteChar(c);
						}
					}
					writer.WriteString(L"\")");
				}

				void Visit(WfUnaryExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					switch (node->op)
					{
					case WfUnaryOperator::Positive:
						writer.WriteString(L"(+ ");
						Call(node->operand, result.type.Obj());
						writer.WriteString(L")");
						break;
					case WfUnaryOperator::Negative:
						writer.WriteString(L"(- ");
						Call(node->operand, result.type.Obj());
						writer.WriteString(L")");
						break;
					case WfUnaryOperator::Not:
						{
							if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<bool>())
							{
								writer.WriteString(L"(! ");
							}
							else
							{
								if (BinaryNeedConvert(result.type->GetTypeDescriptor()))
								{
									writer.WriteString(L"static_cast<");
									writer.WriteString(config->ConvertType(result.type->GetTypeDescriptor()));
									writer.WriteString(L">");
								}
								writer.WriteString(L"(~ ");
							}
							Call(node->operand, result.type.Obj());
							writer.WriteString(L")");
						}
						break;
					default:;
					}
				}

				void VisitBinaryExpression(WfBinaryExpression* node, const wchar_t* op, ITypeDescriptor* resultType, ITypeInfo* operandType)
				{
					if (resultType)
					{
						writer.WriteString(L"static_cast<");
						writer.WriteString(config->ConvertType(resultType));
						writer.WriteString(L">");
					}
					writer.WriteString(L"(");
					Call(node->first, operandType);
					writer.WriteString(L" ");
					writer.WriteString(op);
					writer.WriteString(L" ");
					Call(node->second, operandType);
					writer.WriteString(L")");
				}

				bool BinaryNeedConvert(ITypeDescriptor* type)
				{
					return type == description::GetTypeDescriptor<vint8_t>()
						|| type == description::GetTypeDescriptor<vint16_t>()
						|| type == description::GetTypeDescriptor<vuint8_t>()
						|| type == description::GetTypeDescriptor<vuint16_t>()
						;
				}

				void Visit(WfBinaryExpression* node)override
				{
					if (node->op == WfBinaryOperator::Assign)
					{
						auto result = config->manager->expressionResolvings[node->first.Obj()];
						if (result.propertyInfo)
						{
							auto propInfo = result.propertyInfo;
							auto member = node->first.Cast<WfMemberExpression>();

							if (CppExists(propInfo))
							{
								if (propInfo->GetCpp() == nullptr && propInfo->GetSetter() != nullptr)
								{
									WriteMethodTemplate(CppGetInvokeTemplate(propInfo->GetSetter()), propInfo->GetSetter(),
										[&](IMethodInfo*)
										{
											if (member)
											{
												writer.WriteString(L"::vl::__vwsn::This(");
												Call(member->parent);
												auto parentResult = config->manager->expressionResolvings[member->parent.Obj()];
												if (parentResult.type->GetDecorator() == ITypeInfo::SharedPtr)
												{
													writer.WriteString(L".Obj()");
												}
												writer.WriteString(L")");
											}
											else
											{
												VisitThisExpression(node->first.Obj(), propInfo->GetOwnerTypeDescriptor());
											}
											return true;
										},
										[&](IMethodInfo*, vint index)
										{
											Call(node->second);
										}, useReturnValue);
								}
								else
								{
									writer.WriteString(L"(");
									WritePropertyTemplate(CppGetReferenceTemplate(propInfo), propInfo,
										[&](IPropertyInfo*)
										{
											if (member)
											{
												writer.WriteString(L"::vl::__vwsn::This(");
												Call(member->parent);
												auto parentResult = config->manager->expressionResolvings[member->parent.Obj()];
												if (parentResult.type->GetDecorator() == ITypeInfo::SharedPtr)
												{
													writer.WriteString(L".Obj()");
												}
												writer.WriteString(L")");
											}
											else
											{
												VisitThisExpression(node->first.Obj(), propInfo->GetOwnerTypeDescriptor());
											}
											return true;
										}, true);
									writer.WriteString(L" = ");
									Call(node->second, propInfo->GetReturn());
									writer.WriteString(L")");
								}
							}
							else
							{
								WriteNotExists(propInfo);
							}
						}
						else if (auto binary = node->first.Cast<WfBinaryExpression>())
						{
							auto containerType = config->manager->expressionResolvings[binary->first.Obj()].type.Obj();
							if (IsCppRefGenericType(containerType))
							{
								Call(binary->first, nullptr, false);
								writer.WriteString(L".Set(");
								Call(binary->second);
								writer.WriteString(L", ");
								Call(node->second);
								writer.WriteString(L")");
							}
							else
							{
								auto keyType = config->manager->expressionResolvings[binary->second.Obj()].type.Obj();
								auto valueType = config->manager->expressionResolvings[node->second.Obj()].type.Obj();
								writer.WriteString(L"::vl::__vwsn::This(");
								Call(binary->first);
								writer.WriteString(L".Obj())->Set(");
								if (containerType->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
								{
									WriteBoxValue(keyType, [&]() {Call(binary->second); });
								}
								else
								{
									Call(binary->second);
								}
								writer.WriteString(L", ");
								WriteBoxValue(valueType, [&]() {Call(node->second); });
								writer.WriteString(L")");
							}
						}
						else
						{
							VisitBinaryExpression(node, L"=", nullptr, nullptr);
						}
					}
					else if (node->op == WfBinaryOperator::Index)
					{
						auto containerType = config->manager->expressionResolvings[node->first.Obj()].type.Obj();
						if (IsCppRefGenericType(containerType))
						{
							Call(node->first, nullptr, false);
							writer.WriteString(L"[");
							Call(node->second);
							writer.WriteString(L"]");
						}
						else
						{
							auto keyType = config->manager->expressionResolvings[node->second.Obj()].type.Obj();
							auto valueType = config->manager->expressionResolvings[node].type.Obj();
							WriteUnboxValue(valueType, [&]()
							{
								writer.WriteString(L"::vl::__vwsn::This(");
								Call(node->first);
								writer.WriteString(L".Obj())->Get(");
								if (containerType->GetTypeDescriptor()->CanConvertTo(description::GetTypeDescriptor<IValueReadonlyDictionary>()))
								{
									WriteBoxValue(keyType, [&]() {Call(node->second); });
								}
								else
								{
									Call(node->second);
								}
								writer.WriteString(L")");
							});
						}
					}
					else if (node->op == WfBinaryOperator::FlagAnd)
					{
						auto type = config->manager->expressionResolvings[node].type;
						if (type->GetTypeDescriptor() == description::GetTypeDescriptor<WString>())
						{
							VisitBinaryExpression(node, L"+", nullptr, type.Obj());
						}
						else
						{
							VisitBinaryExpression(node, L"&", nullptr, nullptr);
						}
					}
					else if (node->op == WfBinaryOperator::FlagOr)
					{
						VisitBinaryExpression(node, L"|", nullptr, nullptr);
					}
					else if (node->op == WfBinaryOperator::FailedThen)
					{
						auto firstResult = config->manager->expressionResolvings[node->first.Obj()];
						auto secondResult = config->manager->expressionResolvings[node->second.Obj()];
						auto mergedType = GetMergedType(firstResult.type, secondResult.type);

						writer.WriteString(L"[&](){ try{ return ");
						Call(node->first, mergedType.Obj());
						writer.WriteString(L"; } catch(...){ return ");
						Call(node->second, mergedType.Obj());
						writer.WriteString(L"; } }()");
					}
					else
					{
						auto result = config->manager->expressionResolvings[node];
						auto firstResult = config->manager->expressionResolvings[node->first.Obj()];
						auto secondResult = config->manager->expressionResolvings[node->second.Obj()];
						auto mergedType = GetMergedType(firstResult.type, secondResult.type);

						switch (node->op)
						{
						case WfBinaryOperator::Exp:
							writer.WriteString(L"static_cast<");
							writer.WriteString(config->ConvertType(result.type->GetTypeDescriptor()));
							writer.WriteString(L">(pow(static_cast<double>(");
							Call(node->first);
							writer.WriteString(L"), static_cast<double>(");
							Call(node->second);
							writer.WriteString(L")))");
							return;
						case WfBinaryOperator::Add:
						case WfBinaryOperator::Sub:
						case WfBinaryOperator::Mul:
						case WfBinaryOperator::Div:
						case WfBinaryOperator::Mod:
						case WfBinaryOperator::Shl:
						case WfBinaryOperator::Shr:
							{
								const wchar_t* op = nullptr;
								switch (node->op)
								{
								case WfBinaryOperator::Add: op = L"+"; break;
								case WfBinaryOperator::Sub: op = L"-"; break;
								case WfBinaryOperator::Mul: op = L"*"; break;
								case WfBinaryOperator::Div: op = L"/"; break;
								case WfBinaryOperator::Mod: op = L"%"; break;
								case WfBinaryOperator::Shl: op = L"<<"; break;
								case WfBinaryOperator::Shr: op = L">>"; break;
								default:;
								}
								VisitBinaryExpression(node, op, (BinaryNeedConvert(result.type->GetTypeDescriptor()) ? result.type->GetTypeDescriptor() : nullptr), result.type.Obj());
							}
							return;
						case WfBinaryOperator::EQ:
						case WfBinaryOperator::NE:
							{
								if (firstResult.type->GetDecorator() == ITypeInfo::RawPtr || firstResult.type->GetDecorator() == ITypeInfo::SharedPtr)
								{
									auto td = mergedType->GetTypeDescriptor();
									auto tdFirst = firstResult.type->GetTypeDescriptor();
									auto tdSecond = secondResult.type->GetTypeDescriptor();
									auto dFirst = firstResult.type->GetDecorator();
									auto dSecond = secondResult.type->GetDecorator();

									writer.WriteString(L"(");

									if (td != tdFirst)
									{
										writer.WriteString(L"static_cast<");
										writer.WriteString(config->ConvertType(tdFirst));
										writer.WriteString(L"*>(");
									}
									Call(node->first);
									if (dFirst == ITypeInfo::SharedPtr)
									{
										writer.WriteString(L".Obj()");
									}
									if (td != tdFirst)
									{
										writer.WriteString(L")");
									}

									if (node->op == WfBinaryOperator::EQ)
									{
										writer.WriteString(L" == ");
									}
									else
									{
										writer.WriteString(L" != ");
									}

									if (td != tdSecond)
									{
										writer.WriteString(L"static_cast<");
										writer.WriteString(config->ConvertType(tdSecond));
										writer.WriteString(L"*>(");
									}
									Call(node->second);
									if (dSecond == ITypeInfo::SharedPtr)
									{
										writer.WriteString(L".Obj()");
									}
									if (td != tdSecond)
									{
										writer.WriteString(L")");
									}

									writer.WriteString(L")");
									return;
								}
							}
						case WfBinaryOperator::LT:
						case WfBinaryOperator::GT:
						case WfBinaryOperator::LE:
						case WfBinaryOperator::GE:
							{
								const wchar_t* op = nullptr;
								switch (node->op)
								{
								case WfBinaryOperator::LT: op = L"<"; break;
								case WfBinaryOperator::GT: op = L">"; break;
								case WfBinaryOperator::LE: op = L"<="; break;
								case WfBinaryOperator::GE: op = L">="; break;
								case WfBinaryOperator::EQ: op = L"=="; break;
								case WfBinaryOperator::NE: op = L"!="; break;
								default:;
								}
								VisitBinaryExpression(node, op, nullptr, mergedType.Obj());
							}
							return;
						case WfBinaryOperator::Xor:
						case WfBinaryOperator::And:
						case WfBinaryOperator::Or:
							{
								auto td = result.type->GetTypeDescriptor();
								const wchar_t* op = nullptr;
								if (td == description::GetTypeDescriptor<bool>())
								{
									switch (node->op)
									{
									case WfBinaryOperator::Xor: op = L"^"; break;
									case WfBinaryOperator::And: op = L"&&"; break;
									case WfBinaryOperator::Or: op = L"||"; break;
									default:;
									}
									if (node->op != WfBinaryOperator::Xor)
									{
										td = nullptr;
									}
								}
								else
								{
									switch (node->op)
									{
									case WfBinaryOperator::Xor: op = L"^"; break;
									case WfBinaryOperator::And: op = L"&"; break;
									case WfBinaryOperator::Or: op = L"|"; break;
									default:;
									}
									if (!BinaryNeedConvert(td))
									{
										td = nullptr;
									}
								}
								VisitBinaryExpression(node, op, td, result.type.Obj());
							}
							return;
						default:;
						}
					}
				}

				void Visit(WfLetExpression* node)override
				{
					auto scope = config->manager->nodeScopes[node];
					writer.WriteString(L"[&](");
					for (auto [letVar, index] : indexed(node->variables))
					{
						if (index > 0)
						{
							writer.WriteString(L", ");
						}
						writer.WriteString(L"auto ");
						writer.WriteString(config->ConvertName(letVar->name.value));
					}
					writer.WriteString(L"){ return ");
					Call(node->expression);
					writer.WriteString(L"; }(");
					for (auto [letVar, index] : indexed(node->variables))
					{
						if (index > 0)
						{
							writer.WriteString(L", ");
						}
						auto symbol = scope->symbols[letVar->name.value][0];
						Call(letVar->value, symbol->typeInfo.Obj());
					}
					writer.WriteString(L")");
				}

				void Visit(WfIfExpression* node)override
				{
					auto firstResult = config->manager->expressionResolvings[node->trueBranch.Obj()];
					auto secondResult = config->manager->expressionResolvings[node->falseBranch.Obj()];
					auto mergedType = GetMergedType(firstResult.type, secondResult.type);

					writer.WriteString(L"(");
					Call(node->condition);
					writer.WriteString(L" ? ");
					Call(node->trueBranch, mergedType.Obj());
					writer.WriteString(L" : ");
					Call(node->falseBranch, mergedType.Obj());
					writer.WriteString(L")");
				}

				void Visit(WfRangeExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					auto elementType = result.type->GetElementType()->GetGenericArgument(0);

					writer.WriteString(L"::vl::__vwsn::Range(");
					Call(node->begin, elementType);
					if (node->beginBoundary == WfRangeBoundary::Exclusive)
					{
						writer.WriteString(L" + 1");
					}
					writer.WriteString(L", ");
					Call(node->end, elementType);
					if (node->endBoundary == WfRangeBoundary::Inclusive)
					{
						writer.WriteString(L" + 1");
					}
					writer.WriteString(L")");
				}

				void Visit(WfSetTestingExpression* node)override
				{
					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						auto resultElement = config->manager->expressionResolvings[node->element.Obj()];
						auto resultBegin = config->manager->expressionResolvings[range->begin.Obj()];
						auto resultEnd = config->manager->expressionResolvings[range->end.Obj()];

						writer.WriteString(L"[&](auto __vwsn_1){ return ");
						if (node->test == WfSetTesting::NotIn)
						{
							writer.WriteString(L"!");
						}
						writer.WriteString(L"(");

						Call(range->begin);
						writer.WriteString(range->beginBoundary == WfRangeBoundary::Inclusive ? L" <= " : L" < ");
						writer.WriteString(L" __vwsn_1 && __vwsn_1");
						writer.WriteString(range->endBoundary == WfRangeBoundary::Inclusive ? L" <= " : L" < ");
						Call(range->end);

						writer.WriteString(L"); }(");
						Call(node->element, resultElement.type.Obj());
						writer.WriteString(L")");
					}
					else
					{
						auto result = config->manager->expressionResolvings[node->collection.Obj()];
						auto elementType = result.type->GetElementType()->GetGenericArgument(0);

						if (node->test == WfSetTesting::NotIn)
						{
							writer.WriteString(L"(! ");
						}

						writer.WriteString(L"::vl::__vwsn::InSet(");
						Call(node->element, elementType);
						writer.WriteString(L", ");
						Call(node->collection);
						writer.WriteString(L")");

						if (node->test == WfSetTesting::NotIn)
						{
							writer.WriteString(L")");
						}
					}
				}

				void Visit(WfConstructorExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					auto td = result.type->GetTypeDescriptor();
					if (node->arguments.Count() == 0)
					{
						if ((td->GetTypeDescriptorFlags() & TypeDescriptorFlags::StructType) != TypeDescriptorFlags::Undefined)
						{
							writer.WriteString(config->ConvertType(result.type.Obj()) + L"{}");
						}
						else
						{
							writer.WriteString(config->ConvertType(td) + L"::Create()");
						}
					}
					else
					{
						if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueArray>())
						{
							auto elementType = result.type->GetElementType()->GetGenericArgument(0);
							writer.WriteString(L"(::vl::__vwsn::CreateArray().Resize(");
							writer.WriteString(itow(node->arguments.Count()));
							writer.WriteString(L")");

							for (auto&& [argument, index] : indexed(node->arguments))
							{
								writer.WriteString(L".Set(");
								writer.WriteString(itow(index));
								writer.WriteString(L", ");
								Call(argument->key);
								writer.WriteString(L")");
							}

							writer.WriteString(L").list");
						}
						else if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
						{
							auto elementType = result.type->GetElementType()->GetGenericArgument(0);
							writer.WriteString(L"(::vl::__vwsn::CreateList()");

							for (auto argument : node->arguments)
							{
								writer.WriteString(L".Add(");
								Call(argument->key);
								writer.WriteString(L")");
							}

							writer.WriteString(L").list");
						}
						else if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueObservableList>())
						{
							auto elementType = result.type->GetElementType()->GetGenericArgument(0);
							writer.WriteString(L"(::vl::__vwsn::CreateObservableList()");

							for (auto argument : node->arguments)
							{
								writer.WriteString(L".Add(");
								Call(argument->key);
								writer.WriteString(L")");
							}

							writer.WriteString(L").list");
						}
						else if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueDictionary>())
						{
							auto keyType = result.type->GetElementType()->GetGenericArgument(0);
							auto valueType = result.type->GetElementType()->GetGenericArgument(1);
							writer.WriteString(L"(::vl::__vwsn::CreateDictionary()");

							for (auto argument : node->arguments)
							{
								writer.WriteString(L".Add(");
								Call(argument->key);
								writer.WriteString(L", ");
								Call(argument->value);
								writer.WriteString(L")");
							}

							writer.WriteString(L").dictionary");
						}
						else
						{
							writer.WriteString(L"[&](){ ");
							writer.WriteString(config->ConvertType(td));
							writer.WriteString(L" __vwsn_temp__;");

							for (auto argument : node->arguments)
							{
								writer.WriteString(L" __vwsn_temp__.");
								writer.WriteString(argument->key.Cast<WfReferenceExpression>()->name.value);
								writer.WriteString(L" = ");
								Call(argument->value);
								writer.WriteString(L";");
							}

							writer.WriteString(L" return __vwsn_temp__; }()");
						}
					}
				}

				void Visit(WfInferExpression* node)override
				{
					Call(node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					auto scope = config->manager->nodeScopes[node].Obj();
					auto typeInfo = CreateTypeInfoFromType(scope, node->type);
					bool strongCast = node->strategy == WfTypeCastingStrategy::Strong;
					auto result = config->manager->expressionResolvings[node->expression.Obj()];
					ConvertType(config, writer, result.type.Obj(), typeInfo.Obj(), [&]() {Call(node->expression); }, strongCast);
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node->expression.Obj()];
					Ptr<ITypeInfo> type;
					if (node->type)
					{
						auto scope = config->manager->nodeScopes[node].Obj();
						type = CreateTypeInfoFromType(scope, node->type);
					}

					switch (result.type->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						{
							switch (node->test)
							{
							case WfTypeTesting::IsNull:
								writer.WriteString(L"(");
								Call(node->expression);
								writer.WriteString(L" == nullptr)");
								break;
							case WfTypeTesting::IsNotNull:
								writer.WriteString(L"(");
								Call(node->expression);
								writer.WriteString(L" != nullptr)");
								break;
							case WfTypeTesting::IsType:
							case WfTypeTesting::IsNotType:
								if (type->GetDecorator() != ITypeInfo::RawPtr)
								{
									writer.WriteString(node->test == WfTypeTesting::IsType ? L"false" : L"true");
								}
								else
								{
									writer.WriteString(L"(::vl::__vwsn::RawPtrCast<");
									writer.WriteString(config->ConvertType(type->GetTypeDescriptor()));
									writer.WriteString(L">(");
									Call(node->expression);
									writer.WriteString(L") ");
									writer.WriteString(node->test == WfTypeTesting::IsType ? L"!=" : L"==");
									writer.WriteString(L" nullptr)");
								}
								break;
							default:;
							}
						}
						break;
					case ITypeInfo::SharedPtr:
						{
							if (result.type->GetElementType()->GetDecorator() == ITypeInfo::Generic)
							{
								auto toCode = [&]()
								{
									return GenerateToStream([&](StreamWriter& writer)
									{
										WfPrint(Ptr(node), WString::Empty, writer);
									});
								};

								if (config->IsSpecialGenericType(result.type.Obj()))
								{
									writer.WriteString(L"/* NOT SUPPORTS: testing against non-reference generic type: ");
									writer.WriteString(toCode());
									writer.WriteString(L" */ __vwsn_not_exists__");
									return;
								}
							}
							switch (node->test)
							{
							case WfTypeTesting::IsNull:
								writer.WriteString(L"(! static_cast<bool>(");
								Call(node->expression);
								writer.WriteString(L"))");
								break;
							case WfTypeTesting::IsNotNull:
								writer.WriteString(L"static_cast<bool>(");
								Call(node->expression);
								writer.WriteString(L")");
								break;
							case WfTypeTesting::IsType:
							case WfTypeTesting::IsNotType:
								if (type->GetDecorator() != ITypeInfo::SharedPtr)
								{
									writer.WriteString(node->test == WfTypeTesting::IsType ? L"false" : L"true");
								}
								else
								{
									writer.WriteString(L"(::vl::__vwsn::RawPtrCast<");
									writer.WriteString(config->ConvertType(type->GetTypeDescriptor()));
									writer.WriteString(L">(");
									Call(node->expression);
									writer.WriteString(L".Obj()) ");
									writer.WriteString(node->test == WfTypeTesting::IsType ? L"!=" : L"==");
									writer.WriteString(L" nullptr)");
								}
								break;
							default:;
							}
						}
						break;
					case ITypeInfo::Nullable:
						{
							switch (node->test)
							{
							case WfTypeTesting::IsNull:
								writer.WriteString(L"(! static_cast<bool>(");
								Call(node->expression);
								writer.WriteString(L"))");
								break;
							case WfTypeTesting::IsNotNull:
								writer.WriteString(L"static_cast<bool>(");
								Call(node->expression);
								writer.WriteString(L")");
								break;
							case WfTypeTesting::IsType:
								if (type->GetTypeDescriptor() == result.type->GetTypeDescriptor())
								{
									writer.WriteString(L"static_cast<bool>(");
									Call(node->expression);
									writer.WriteString(L")");
								}
								else
								{
									writer.WriteString(L"false");
								}
								break;
							case WfTypeTesting::IsNotType:
								if (type->GetTypeDescriptor() == result.type->GetTypeDescriptor())
								{
									writer.WriteString(L"false");
								}
								else
								{
									writer.WriteString(L"true");
								}
								break;
							default:;
							}
						}
						break;
					case ITypeInfo::TypeDescriptor:
						{
							if (result.type->GetTypeDescriptor()->GetTypeDescriptorFlags() == TypeDescriptorFlags::Object)
							{
								switch (node->test)
								{
								case WfTypeTesting::IsNull:
									Call(node->expression);
									writer.WriteString(L".IsNull()");
									break;
								case WfTypeTesting::IsNotNull:
									writer.WriteString(L"(! ");
									Call(node->expression);
									writer.WriteString(L".IsNull())");
									break;
								case WfTypeTesting::IsType:
								case WfTypeTesting::IsNotType:
									if ((type->GetTypeDescriptor()->GetTypeDescriptorFlags() & TypeDescriptorFlags::ReferenceType) != TypeDescriptorFlags::Undefined)
									{
										writer.WriteString(L"[&](){ auto __vwsn_temp__ = ");
										Call(node->expression);
										writer.WriteString(L"; return ");
										if ((type->GetDecorator() == ITypeInfo::RawPtr) == (node->test == WfTypeTesting::IsType))
										{
											writer.WriteString(L"!");
										}
										writer.WriteString(L"__vwsn_temp__.GetSharedPtr() ");
										writer.WriteString(node->test == WfTypeTesting::IsType ? L"&&" : L"||");
										writer.WriteString(L" ::vl::__vwsn::RawPtrCast<");
										writer.WriteString(config->ConvertType(type->GetTypeDescriptor()));
										writer.WriteString(L">(__vwsn_temp__.GetRawPtr()) ");
										writer.WriteString(node->test == WfTypeTesting::IsType ? L"!=" : L"==");
										writer.WriteString(L" nullptr; }()");
									}
									else
									{
										writer.WriteString(L"(dynamic_cast<::vl::reflection::description::IValueType::TypedBox<");
										writer.WriteString(config->ConvertType(type->GetTypeDescriptor()));
										writer.WriteString(L">*>(");
										Call(node->expression);
										writer.WriteString(L".GetBoxedValue().Obj()) ");
										writer.WriteString(node->test == WfTypeTesting::IsType ? L"!=" : L"==");
										writer.WriteString(L" nullptr)");
									}
									break;
								default:;
								}
							}
							else if ((type->GetTypeDescriptor() == result.type->GetTypeDescriptor()) == (node->test == WfTypeTesting::IsType))
							{
								writer.WriteString(L"true");
							}
							else
							{
								writer.WriteString(L"false");
							}
						}
						break;
					default:;
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					writer.WriteString(L"/* NOT SUPPORTS: typeof() */ __vwsn_not_exists__");
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					writer.WriteString(L"/* NOT SUPPORTS: type() */ __vwsn_not_exists__");
				}

				void Visit(WfAttachEventExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node->event.Obj()];
					if (CppExists(result.eventInfo))
					{
						WriteEventTemplate(CppGetAttachTemplate(result.eventInfo), result.eventInfo,
							[&](IEventInfo*)
							{
								writer.WriteString(L"::vl::__vwsn::This(");
								if (auto member = node->event.Cast<WfMemberExpression>())
								{
									Call(member->parent);
									auto parentResult = config->manager->expressionResolvings[member->parent.Obj()];
									if (parentResult.type->GetDecorator() == ITypeInfo::SharedPtr)
									{
										writer.WriteString(L".Obj()");
									}
								}
								else
								{
									VisitThisExpression(node, result.eventInfo->GetOwnerTypeDescriptor());
								}
								writer.WriteString(L")");
								return true;
							},
							[&](IEventInfo*)
							{
								Call(node->function);
								return true;
							},
							[&](IEventInfo*, vint) {});
					}
					else
					{
						WriteNotExists(result.eventInfo);
					}
				}

				void Visit(WfDetachEventExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node->event.Obj()];
					if (CppExists(result.eventInfo))
					{
						WriteEventTemplate(CppGetDetachTemplate(result.eventInfo), result.eventInfo,
							[&](IEventInfo* eventInfo)
							{
								writer.WriteString(L"::vl::__vwsn::This(");
								if (auto member = node->event.Cast<WfMemberExpression>())
								{
									Call(member->parent);
									auto parentResult = config->manager->expressionResolvings[member->parent.Obj()];
									if (parentResult.type->GetDecorator() == ITypeInfo::SharedPtr)
									{
										writer.WriteString(L".Obj()");
									}
								}
								else
								{
									VisitThisExpression(node, eventInfo->GetOwnerTypeDescriptor());
								}
								writer.WriteString(L")");
								return true;
							},
							[&](IEventInfo*)
							{
								Call(node->handler);
								return true;
							},
							[&](IEventInfo*, vint) {});
					}
					else
					{
						WriteNotExists(result.eventInfo);
					}
				}

				void Visit(WfObserveExpression* node)override
				{
				}

				void Visit(WfCallExpression* node)override
				{
					auto thisCallback = [&](ITypeDescriptor* td)
					{
						if (auto member = node->function.Cast<WfMemberExpression>())
						{
							writer.WriteString(L"::vl::__vwsn::This(");
							Call(member->parent);
							auto parentResult = config->manager->expressionResolvings[member->parent.Obj()];
							if (parentResult.type->GetDecorator() == ITypeInfo::SharedPtr)
							{
								writer.WriteString(L".Obj()");
							}
							writer.WriteString(L")");
						}
						else
						{
							VisitThisExpression(node, td);
						}
						return true;
					};

					auto argumentCallback = [&](IMethodInfo* methodInfo, ITypeInfo* typeInfo, vint index)
					{
						auto type = methodInfo
							? methodInfo->GetParameter(index)->GetType()
							: typeInfo->GetElementType()->GetGenericArgument(index + 1)
							;
						Call(node->arguments[index], type);
					};

					auto result = config->manager->expressionResolvings[node->function.Obj()];
					if (result.methodInfo)
					{
						WriteMethodTemplate(CppGetInvokeTemplate(result.methodInfo), result.methodInfo,
							[&](IMethodInfo* methodInfo) { return thisCallback(methodInfo->GetOwnerTypeDescriptor()); },
							[&](IMethodInfo* methodInfo, vint index) { return argumentCallback(methodInfo, nullptr, index); },
							useReturnValue);
						return;
					}
					else if (result.eventInfo)
					{
						WriteEventTemplate(CppGetInvokeTemplate(result.eventInfo), result.eventInfo,
							[&](IEventInfo* eventInfo) { return thisCallback(eventInfo->GetOwnerTypeDescriptor()); },
							[&](IEventInfo*) { return false; },
							[&](IEventInfo* eventInfo, vint index) { return argumentCallback(nullptr, eventInfo->GetHandlerType(), index); }
							);
						return;
					}
					else if (result.symbol)
					{
						if (auto funcDecl = result.symbol->creatorNode.Cast<WfFunctionDeclaration>())
						{
							if (result.symbol->ownerScope->ownerNode.Cast<WfNewInterfaceExpression>())
							{
								writer.WriteString(L"this->");
								writer.WriteString(config->ConvertName(result.symbol->name));
							}
							else if (result.symbol->ownerScope->functionConfig && result.symbol->ownerScope->functionConfig->lambda && result.symbol->name == funcDecl->name.value)
							{
								writer.WriteString(L"(*this)");
							}
							else
							{
								writer.WriteString(L"GLOBAL_NAME ");
								writer.WriteString(config->ConvertName(result.symbol->name));
							}
							writer.WriteString(L"(");
							for (vint i = 0; i < node->arguments.Count(); i++)
							{
								if (i > 0) writer.WriteString(L", ");
								argumentCallback(nullptr, result.symbol->typeInfo.Obj(), i);
							}
							writer.WriteString(L")");
							return;
						}
					}
					Call(node->function);
					writer.WriteString(L"(");
					for (vint i = 0; i < node->arguments.Count(); i++)
					{
						if (i > 0) writer.WriteString(L", ");
						argumentCallback(nullptr, result.type.Obj(), i);
					}
					writer.WriteString(L")");
				}

				void Visit(WfFunctionExpression* node)override
				{
					writer.WriteString(L"vl::Func(::");
					writer.WriteString(config->assemblyNamespace);
					writer.WriteString(L"::");
					writer.WriteString(config->lambdaExprs[node]);
					writer.WriteString(L"(");

					auto closureInfo = config->closureInfos[node];
					WriteClosureArguments(closureInfo, node);

					writer.WriteString(L"))");
				}

				void Visit(WfNewClassExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					auto ctor = result.constructorInfo;

					if (ctor->GetReturn()->GetDecorator() == ITypeInfo::SharedPtr)
					{
						writer.WriteString(L"::vl::Ptr<");
						writer.WriteString(config->ConvertType(ctor->GetReturn()->GetTypeDescriptor()));
						writer.WriteString(L">(");
					}

					WriteMethodTemplate(CppGetInvokeTemplate(ctor), ctor, [&](IMethodInfo*) { return false; },
						[&](IMethodInfo*, vint index)
						{
							Call(node->arguments[index]);
						}, useReturnValue);

					if (ctor->GetReturn()->GetDecorator() == ITypeInfo::SharedPtr)
					{
						writer.WriteString(L")");
					}
				}

				void Visit(WfNewInterfaceExpression* node)override
				{
					auto result = config->manager->expressionResolvings[node];
					auto ctor = result.constructorInfo;

					if (ctor->GetReturn()->GetDecorator() == ITypeInfo::SharedPtr)
					{
						writer.WriteString(L"::vl::Ptr<");
						writer.WriteString(config->ConvertType(ctor->GetReturn()->GetTypeDescriptor()));
						writer.WriteString(L">(");
					}
					else
					{
						writer.WriteString(L"static_cast<");
						writer.WriteString(config->ConvertType(ctor->GetReturn()->GetTypeDescriptor()));
						writer.WriteString(L"*>(");
					}

					writer.WriteString(L"new ::");
					writer.WriteString(config->assemblyNamespace);
					writer.WriteString(L"::");
					writer.WriteString(config->classExprs[node]);
					writer.WriteString(L"(");

					auto closureInfo = config->closureInfos[node];
					WriteClosureArguments(closureInfo, node);

					writer.WriteString(L"))");
				}

				void Visit(WfVirtualCfeExpression* node)override
				{
					Call(node->expandedExpression);
				}

				void Visit(WfVirtualCseExpression* node)override
				{
					Call(node->expandedExpression);
				}
			};

			void GenerateExpression(WfCppConfig* config, stream::StreamWriter& writer, Ptr<WfExpression> node, reflection::description::ITypeInfo* expectedType, bool useReturnValue)
			{
				WfGenerateExpressionVisitor visitor(config, writer, useReturnValue);
				if (useReturnValue)
				{
					auto result = config->manager->expressionResolvings[node.Obj()];
					ITypeInfo* types[] = { result.type.Obj(), result.expectedType.Obj(), expectedType };
					visitor.ConvertMultipleTypes(types, sizeof(types) / sizeof(*types), [&]()
					{
						node->Accept(&visitor);
					});
				}
				else
				{
					node->Accept(&visitor);
				}
			}
		}
	}
}


/***********************************************************************
.\CPP\WFCPP_FILE.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;

			void WfCppConfig::WritePushCompileOptions(stream::StreamWriter& writer)
			{
				writer.WriteLine(L"#if defined( _MSC_VER)");
				writer.WriteLine(L"#pragma warning(push)");
				writer.WriteLine(L"#pragma warning(disable:4250)");
				writer.WriteLine(L"#elif defined(__clang__)");
				writer.WriteLine(L"#pragma clang diagnostic push");
				writer.WriteLine(L"#pragma clang diagnostic ignored \"-Wparentheses-equality\"");
				writer.WriteLine(L"#elif defined(__GNUC__)");
				writer.WriteLine(L"#pragma GCC diagnostic push");
				writer.WriteLine(L"#endif");
			}

			void WfCppConfig::WritePopCompileOptions(stream::StreamWriter& writer)
			{
				writer.WriteLine(L"#if defined( _MSC_VER)");
				writer.WriteLine(L"#pragma warning(pop)");
				writer.WriteLine(L"#elif defined(__clang__)");
				writer.WriteLine(L"#pragma clang diagnostic pop");
				writer.WriteLine(L"#elif defined(__GNUC__)");
				writer.WriteLine(L"#pragma GCC diagnostic pop");
				writer.WriteLine(L"#endif");
			}
			
			void WfCppConfig::WriteCpp_PushMacros(stream::StreamWriter& writer)
			{
				writer.WriteString(L"#define GLOBAL_SYMBOL ");
				writer.WriteString(L"::");
				writer.WriteString(assemblyNamespace);
				writer.WriteString(L"::");
				writer.WriteString(assemblyName);
				writer.WriteLine(L"::");

				writer.WriteString(L"#define GLOBAL_NAME ");
				writer.WriteString(L"::");
				writer.WriteString(assemblyNamespace);
				writer.WriteString(L"::");
				writer.WriteString(assemblyName);
				writer.WriteLine(L"::Instance().");

				writer.WriteString(L"#define GLOBAL_OBJ ");
				writer.WriteString(L"&::");
				writer.WriteString(assemblyNamespace);
				writer.WriteString(L"::");
				writer.WriteString(assemblyName);
				writer.WriteLine(L"::Instance()");
			}

			void WfCppConfig::WriteCpp_PopMacros(stream::StreamWriter& writer)
			{
				writer.WriteLine(L"#undef GLOBAL_SYMBOL");
				writer.WriteLine(L"#undef GLOBAL_NAME");
				writer.WriteLine(L"#undef GLOBAL_OBJ");
			}

			void WfCppConfig::WriteHeader(stream::StreamWriter& writer, bool multiFile)
			{
				WritePushCompileOptions(writer);
				writer.WriteLine(L"");

				{
					Dictionary<WString, Ptr<WfExpression>> reversedLambdaExprs;
					Dictionary<WString, Ptr<WfNewInterfaceExpression>> reversedClassExprs;
					SortClosure(reversedLambdaExprs, reversedClassExprs);
					
					if (reversedLambdaExprs.Count() + reversedClassExprs.Count() > 0)
					{
						writer.WriteString(L"namespace ");
						writer.WriteLine(assemblyNamespace);
						writer.WriteLine(L"{");

						for (auto expr : reversedLambdaExprs.Values())
						{
							WriteHeader_ClosurePreDecl(writer, expr);
						}

						for (auto expr : reversedClassExprs.Values())
						{
							WriteHeader_ClosurePreDecl(writer, expr);
						}

						writer.WriteLine(L"}");
						writer.WriteLine(L"");
					}
				}

				List<WString> nss;

				if (enumDecls.Count() > 0)
				{
					WriteHeader_MainHeaderEnums(writer, nss);
					if (enumDecls.Keys().Contains(nullptr))
					{
						for (auto decl : enumDecls[nullptr])
						{
							WriteHeader_Enum(writer, decl, nss, false);
						}
						writer.WriteLine(L"");
					}
				}

				if (structDecls.Count() > 0)
				{
					WriteHeader_MainHeaderStructs(writer, nss);
					if (structDecls.Keys().Contains(nullptr))
					{
						for (auto decl : structDecls[nullptr])
						{
							WriteHeader_Struct(writer, decl, nss, false);
						}
						writer.WriteLine(L"");
					}
				}

				if (classDecls.Keys().Contains(nullptr))
				{
					for (auto decl : classDecls[nullptr])
					{
						WriteHeader_ClassPreDecl(writer, decl, nss);
					}
					writer.WriteLine(L"");
					if (multiFile)
					{
						vint index = headerFilesClasses.Keys().IndexOf(0);
						if (index != -1)
						{
							for (auto decl : headerFilesClasses.GetByIndex(index))
							{
								WriteHeader_Class(writer, decl, nss);
								writer.WriteLine(L"");
							}
						}
					}
					else
					{
						for (auto decl : classDecls[nullptr])
						{
							WriteHeader_Class(writer, decl, nss);
							writer.WriteLine(L"");
						}
					}
				}
				WriteNamespaceEnd(writer, nss);

				WriteHeader_Global(writer);

				writer.WriteLine(L"");
				WritePopCompileOptions(writer);
			}

			void WfCppConfig::WriteNonCustomSubHeader(stream::StreamWriter& writer, vint fileIndex)
			{
				WritePushCompileOptions(writer);
				writer.WriteLine(L"");
				List<WString> nss;

				if (classDecls.Keys().Contains(nullptr))
				{
					vint index = headerFilesClasses.Keys().IndexOf(fileIndex);
					if (index != -1)
					{
						for (auto decl : headerFilesClasses.GetByIndex(index))
						{
							WriteHeader_Class(writer, decl, nss);
							writer.WriteLine(L"");
						}
					}
				}
				WriteNamespaceEnd(writer, nss);

				writer.WriteLine(L"");
				WritePopCompileOptions(writer);
			}

			void WfCppConfig::WriteCpp(stream::StreamWriter& writer, bool multiFile)
			{
				WritePushCompileOptions(writer);
				writer.WriteLine(L"");
				WriteCpp_PushMacros(writer);

				writer.WriteLine(L"");
				WriteCpp_Global(writer);
				writer.WriteLine(L"");

				if (classDecls.Keys().Contains(nullptr))
				{
					List<WString> nss;

					if (multiFile)
					{
						vint index = customFilesClasses.Keys().IndexOf(L"");
						if (index != -1)
						{
							for (auto decl : customFilesClasses.GetByIndex(index))
							{
								WriteCpp_Class(writer, decl, nss);
							}
						}
					}
					else
					{
						for (auto decl : classDecls[nullptr])
						{
							WriteCpp_Class(writer, decl, nss);
						}
					}

					WriteNamespaceEnd(writer, nss);
				}

				WriteCpp_PopMacros(writer);

				writer.WriteLine(L"");
				WritePopCompileOptions(writer);
			}

			void WfCppConfig::WriteSubHeader(stream::StreamWriter& writer, const WString& fileName)
			{
				WritePushCompileOptions(writer);
				writer.WriteLine(L"");
				List<WString> nss;

				for (auto decl : customFilesClasses.Get(fileName))
				{
					WriteHeader_Class(writer, decl, nss);
					writer.WriteLine(L"");
				}

				WriteNamespaceEnd(writer, nss);
				WritePopCompileOptions(writer);
			}

			void WfCppConfig::WriteSubCpp(stream::StreamWriter& writer, const WString& fileName)
			{
				WritePushCompileOptions(writer);
				writer.WriteLine(L"");
				WriteCpp_PushMacros(writer);
				writer.WriteLine(L"");

				if (From(customFilesClasses.Get(fileName))
					.Any([=, this](Ptr<WfClassDeclaration> decl)
					{
						return IsClassHasUserImplMethods(decl, true);
					}))
				{
					writer.WriteLine(L"/* USER_CONTENT_BEGIN(custom global declarations) */");
					writer.WriteLine(L"/* USER_CONTENT_END() */");
					writer.WriteLine(L"");
				}

				List<WString> nss;

				for (auto decl : customFilesClasses.Get(fileName))
				{
					WriteCpp_Class(writer, decl, nss);
				}

				WriteNamespaceEnd(writer, nss);
				WriteCpp_PopMacros(writer);
				writer.WriteLine(L"");
				WritePopCompileOptions(writer);
			}

			void WfCppConfig::WriteReflectionHeader(stream::StreamWriter& writer, bool multiFile)
			{
				WritePushCompileOptions(writer);
				if (manager->declarationTypes.Count() > 0)
				{
					writer.WriteLine(L"");
					WriteHeader_Reflection(writer);
					writer.WriteLine(L"");
				}
				WritePopCompileOptions(writer);
			}

			void WfCppConfig::WriteReflectionCpp(stream::StreamWriter& writer, bool multiFile)
			{
				WritePushCompileOptions(writer);
				if (manager->declarationTypes.Count() > 0)
				{
					writer.WriteLine(L"");
					WriteCpp_Reflection(writer);
					writer.WriteLine(L"");
				}
				WritePopCompileOptions(writer);
			}
		}
	}
}


/***********************************************************************
.\CPP\WFCPP_GENERATECPPFILES.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace stream;

/***********************************************************************
WfCppInput
***********************************************************************/

			WfCppInput::WfCppInput(const WString& _assemblyName)
			{
				headerGuardPrefix = L"VCZH_WORKFLOW_COMPILER_GENERATED_";
				assemblyName = _assemblyName;
				assemblyNamespace = L"vl_workflow_global";
				includeFileName = _assemblyName + L"Includes";
				reflectionFileName = assemblyName + L"Reflection";
				defaultFileName = _assemblyName;
			}

/***********************************************************************
GenerateCppFiles
***********************************************************************/

			void GenerateCppComment(StreamWriter& writer, const WString& comment)
			{
				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"!!!!!! DO NOT MODIFY !!!!!!");
				writer.WriteLine(L"");
				writer.WriteLine(comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"This file is generated by Workflow compiler");
				writer.WriteLine(L"https://github.com/vczh-libraries");
				writer.WriteLine(L"***********************************************************************/");
			}

			void WriteReflectionInclude(bool reflection, Ptr<WfCppInput> input, stream::StreamWriter& writer)
			{
				if (reflection || input->reflectionIncludes.Count() > 0)
				{
					writer.WriteLine(L"/* CodePack:BeginIgnore() */");
					writer.WriteLine(L"#ifndef VCZH_DEBUG_NO_REFLECTION");
					if (reflection)
					{
						writer.WriteLine(L"/* CodePack:ConditionOff(VCZH_DEBUG_NO_REFLECTION, " + input->reflectionFileName + L".h) */");
						writer.WriteLine(L"#include \"" + input->reflectionFileName + L".h\"");
					}
					else
					{
						for (auto include : input->reflectionIncludes)
						{
							writer.WriteLine(L"/* CodePack:ConditionOff(VCZH_DEBUG_NO_REFLECTION, " + include + L") */");
							writer.WriteLine(L"#include \"" + include + L"\"");
						}
					}
					writer.WriteLine(L"#endif");
					writer.WriteLine(L"/* CodePack:EndIgnore() */");
				}
			}

			void WriteDependedInclude(Ptr<WfCppInput> input, WfCppConfig& config, vint headerIndex, stream::StreamWriter& writer)
			{
				vint index = config.headerIncludes.Keys().IndexOf(headerIndex);
				if (index != -1)
				{
					const auto& headers = config.headerIncludes.GetByIndex(index);
					for (auto header : headers)
					{
						if (header == 0)
						{
							writer.WriteLine(L"#include \"" + input->defaultFileName + L".h\"");
						}
						else if (header > 0)
						{
							writer.WriteLine(L"#include \"" + config.customFilesClasses.Keys()[header] + L".h\"");
						}
						else
						{
							writer.WriteLine(L"#include \"" + input->defaultFileName + itow(-header) + L".h\"");
						}
					}
				}
			}

			void WriteHeader(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#ifndef " + input->headerGuardPrefix + wupper(input->defaultFileName));
				writer.WriteLine(L"#define " + input->headerGuardPrefix + wupper(input->defaultFileName));
				writer.WriteLine(L"");
				for (auto include : input->normalIncludes)
				{
					writer.WriteLine(L"#include \"" + include + L"\"");
				}
				writer.WriteLine(L"");
				config.WriteHeader(writer, multiFile);
				writer.WriteLine(L"");
				writer.WriteLine(L"#endif");
			}

			void WriteNonCustomSubHeader(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, vint fileIndex, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#ifndef " + input->headerGuardPrefix + wupper(input->defaultFileName) + L"_DP" + itow(fileIndex));
				writer.WriteLine(L"#define " + input->headerGuardPrefix + wupper(input->defaultFileName) + L"_DP" + itow(fileIndex));
				writer.WriteLine(L"");
				writer.WriteLine(L"#include \"" + input->defaultFileName + L".h\"");
				WriteDependedInclude(input, config, -fileIndex, writer);
				writer.WriteLine(L"");
				config.WriteNonCustomSubHeader(writer, fileIndex);
				writer.WriteLine(L"");
				writer.WriteLine(L"#endif");
			}

			void WriteCpp(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#include \"" + output->entryFileName + L".h\"");
				WriteReflectionInclude(reflection, input, writer);
				writer.WriteLine(L"");
				config.WriteCpp(writer, multiFile);
			}

			void WriteReflectionHeader(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#ifndef " + input->headerGuardPrefix + wupper(input->reflectionFileName));
				writer.WriteLine(L"#define " + input->headerGuardPrefix + wupper(input->reflectionFileName));
				writer.WriteLine(L"");
				writer.WriteLine(L"#include \"" + output->entryFileName + L".h\"");
				if (input->reflectionIncludes.Count() > 0)
				{
					writer.WriteLine(L"#ifndef VCZH_DEBUG_NO_REFLECTION");
					for (auto include : input->reflectionIncludes)
					{
						writer.WriteLine(L"#include \"" + include + L"\"");
					}
					writer.WriteLine(L"#endif");
				}
				writer.WriteLine(L"");
				config.WriteReflectionHeader(writer, multiFile);
				writer.WriteLine(L"");
				writer.WriteLine(L"#endif");
			}

			void WriteReflectionCpp(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#include \"" + input->reflectionFileName + L".h\"");
				writer.WriteLine(L"");
				config.WriteReflectionCpp(writer, multiFile);
			}

			void WriteIncludesHeader(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#ifndef " + input->headerGuardPrefix + wupper(input->includeFileName));
				writer.WriteLine(L"#define " + input->headerGuardPrefix + wupper(input->includeFileName));
				writer.WriteLine(L"");

				writer.WriteLine(L"#include \"" + input->defaultFileName + L".h\"");
				for (auto fileName : config.customFilesClasses.Keys())
				{
					if (fileName != L"")
					{
						writer.WriteLine(L"#include \"" + fileName + L".h\"");
					}
				}
				for (auto fileIndex : config.headerFilesClasses.Keys())
				{
					if (fileIndex != 0)
					{
						writer.WriteLine(L"#include \"" + input->defaultFileName + itow(fileIndex) + L".h\"");
					}
				}

				writer.WriteLine(L"");
				writer.WriteLine(L"#endif");
			}

			void WriteSubHeader(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, const WString& fileName, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#ifndef " + input->headerGuardPrefix + wupper(fileName));
				writer.WriteLine(L"#define " + input->headerGuardPrefix + wupper(fileName));
				writer.WriteLine(L"");
				writer.WriteLine(L"#include \"" + input->defaultFileName + L".h\"");
				WriteDependedInclude(input, config, config.customFilesClasses.Keys().IndexOf(fileName), writer);
				writer.WriteLine(L"");
				config.WriteSubHeader(writer, fileName);
				writer.WriteLine(L"");
				writer.WriteLine(L"#endif");
			}

			void WriteSubCpp(Ptr<WfCppInput> input, Ptr<WfCppOutput> output, WfCppConfig& config, bool multiFile, bool reflection, const WString& fileName, stream::StreamWriter& writer)
			{
				GenerateCppComment(writer, input->comment);
				writer.WriteLine(L"");
				writer.WriteLine(L"#include \"" + input->includeFileName + L".h\"");
				WriteReflectionInclude(reflection, input, writer);
				writer.WriteLine(L"");
				config.WriteSubCpp(writer, fileName);
			}

			Ptr<WfCppOutput> GenerateCppFiles(Ptr<WfCppInput> input, analyzer::WfLexicalScopeManager* manager)
			{
				WfCppConfig config(manager, input->assemblyName, input->assemblyNamespace);
				if (manager->errors.Count() > 0)
				{
					return nullptr;
				}

				auto output = Ptr(new WfCppOutput);
				if (config.manager->declarationTypes.Count() > 0)
				{
					output->containsReflectionInfo = true;
				}

				bool multiFile = false;
				switch (input->multiFile)
				{
				case WfCppFileSwitch::Enabled:
					multiFile = true;
					break;
				case WfCppFileSwitch::Disabled:
					multiFile = false;
					break;
				default:
					multiFile = config.customFilesClasses.Count() > 1;
				}

				bool reflection = false;
				switch (input->reflection)
				{
				case WfCppFileSwitch::Enabled:
					reflection = true;
					break;
				case WfCppFileSwitch::Disabled:
					reflection = false;
					break;
				default:
					reflection = config.manager->declarationTypes.Count() > 0;
				}

				output->multiFile = multiFile;
				output->reflection = reflection;

				if (multiFile)
				{
					output->entryFileName = input->includeFileName;
				}
				else
				{
					output->entryFileName = input->defaultFileName;
				}

				output->cppFiles.Add(input->defaultFileName + L".h", GenerateToStream([&](StreamWriter& writer)
				{
					WriteHeader(input, output, config, multiFile, reflection, writer);
				}));
				for (auto fileIndex : config.headerFilesClasses.Keys())
				{
					if (fileIndex != 0)
					{
						output->cppFiles.Add(input->defaultFileName + itow(fileIndex) + L".h", GenerateToStream([&](StreamWriter& writer)
						{
							WriteNonCustomSubHeader(input, output, config, multiFile, reflection, fileIndex, writer);
						}));
					}
				}

				output->cppFiles.Add(input->defaultFileName + L".cpp", GenerateToStream([&](StreamWriter& writer)
				{
					WriteCpp(input, output, config, multiFile, reflection, writer);
				}));

				if (reflection)
				{
					output->cppFiles.Add(input->reflectionFileName + L".h", GenerateToStream([&](StreamWriter& writer)
					{
						WriteReflectionHeader(input, output, config, multiFile, reflection, writer);
					}));

					output->cppFiles.Add(input->reflectionFileName + L".cpp", GenerateToStream([&](StreamWriter& writer)
					{
						WriteReflectionCpp(input, output, config, multiFile, reflection, writer);
					}));
				}

				if (multiFile)
				{
					output->cppFiles.Add(input->includeFileName + L".h", GenerateToStream([&](StreamWriter& writer)
					{
						WriteIncludesHeader(input, output, config, multiFile, reflection, writer);
					}));

					for (auto fileName : config.customFilesClasses.Keys())
					{
						if (fileName != L"")
						{
							output->cppFiles.Add(fileName + L".h", GenerateToStream([&](StreamWriter& writer)
							{
								WriteSubHeader(input, output, config, multiFile, reflection, fileName, writer);
							}));

							output->cppFiles.Add(fileName + L".cpp", GenerateToStream([&](StreamWriter& writer)
							{
								WriteSubCpp(input, output, config, multiFile, reflection, fileName, writer);
							}));
						}
					}
				}

				return output;
			}
		}
	}
}


/***********************************************************************
.\CPP\WFCPP_STATEMENT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace analyzer;

			class WfGenerateStatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfCppConfig*				config;
				Ptr<FunctionRecord>			functionRecord;
				stream::StreamWriter&		writer;
				WString						prefixBlock;
				WString						prefix;
				ITypeInfo*					returnType;

				WfGenerateStatementVisitor(WfCppConfig* _config, Ptr<FunctionRecord> _functionRecord, stream::StreamWriter& _writer, const WString& _prefixBlock, const WString& _prefix, ITypeInfo* _returnType)
					:config(_config)
					, functionRecord(_functionRecord)
					, writer(_writer)
					, prefixBlock(_prefixBlock)
					, prefix(_prefix)
					, returnType(_returnType)
				{
				}

				void Call(Ptr<WfStatement> node, WString prefixDelta = WString::Unmanaged(L"\t"))
				{
					GenerateStatement(config, functionRecord, writer, node, prefix, prefixDelta, returnType);
				}

				void Visit(WfBreakStatement* node)override
				{
					writer.WriteString(prefix);
					writer.WriteLine(L"break;");
				}

				void Visit(WfContinueStatement* node)override
				{
					writer.WriteString(prefix);
					writer.WriteLine(L"continue;");
				}

				void Visit(WfReturnStatement* node)override
				{
					writer.WriteString(prefix);
					if (node->expression)
					{
						writer.WriteString(L"return ");
						GenerateExpression(config, writer, node->expression, returnType);
						writer.WriteLine(L";");
					}
					else
					{
						writer.WriteLine(L"return;");
					}
				}

				void Visit(WfDeleteStatement* node)override
				{
					writer.WriteString(prefix);
					writer.WriteString(L"::vl::__vwsn::This(");
					GenerateExpression(config, writer, node->expression, nullptr);
					writer.WriteLine(L")->Dispose(true);");
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						writer.WriteString(prefix);
						writer.WriteString(L"throw ::vl::Exception(");

						auto result = config->manager->expressionResolvings[node->expression.Obj()];
						bool throwString = result.type->GetTypeDescriptor() == description::GetTypeDescriptor<WString>();
						if (!throwString)
						{
							writer.WriteString(L"::vl::__vwsn::This(");
						}
						GenerateExpression(config, writer, node->expression, result.type.Obj());
						if (!throwString)
						{
							writer.WriteString(L".Obj())->GetMessage()");
						}

						writer.WriteLine(L");");
					}
					else
					{
						writer.WriteString(prefix);
						writer.WriteLine(L"throw;");
					}
				}

				void Visit(WfIfStatement* node)override
				{
					writer.WriteString(prefix);
					while (node)
					{
						writer.WriteString(L"if (");
						if (node->type)
						{
							auto result = config->manager->expressionResolvings[node->expression.Obj()];
							auto scope = config->manager->nodeScopes[node].Obj();
							auto typeInfo = CreateTypeInfoFromType(scope, node->type);
							writer.WriteString(L"auto ");
							writer.WriteString(config->ConvertName(node->name.value));
							writer.WriteString(L" = ");
							ConvertType(config, writer, result.type.Obj(), typeInfo.Obj(), [&]() {GenerateExpression(config, writer, node->expression, nullptr); }, false);
						}
						else
						{
							GenerateExpression(config, writer, node->expression, TypeInfoRetriver<bool>::CreateTypeInfo().Obj());
						}
						writer.WriteLine(L")");
						Call(node->trueBranch);
						if (node->falseBranch)
						{
							writer.WriteString(prefix);
							if (auto ifStat = node->falseBranch.Cast<WfIfStatement>())
							{
								writer.WriteString(L"else ");
								node = ifStat.Obj();
								continue;
							}
							else
							{
								writer.WriteLine(L"else");
								Call(node->falseBranch);
							}
						}
						break;
					}
				}

				void Visit(WfWhileStatement* node)override
				{
					writer.WriteString(prefix);
					writer.WriteString(L"while (");
					GenerateExpression(config, writer, node->condition, TypeInfoRetriver<bool>::CreateTypeInfo().Obj());
					writer.WriteLine(L")");
					Call(node->statement);
				}

				void Visit(WfTryStatement* node)override
				{
					auto exName = L"__vwsne_" + itow(functionRecord->exprCounter++);

					WString tryPrefix = prefix;
					if (node->finallyStatement)
					{
						auto blockName = L"__vwsnb_" + itow(functionRecord->blockCounter++);
						tryPrefix += L"\t";

						writer.WriteString(prefix);
						writer.WriteLine(L"{");

						writer.WriteString(tryPrefix);
						writer.WriteString(L"auto ");
						writer.WriteString(blockName);
						writer.WriteLine(L" = [&]()");
						GenerateStatement(config, functionRecord, writer, node->finallyStatement, tryPrefix, WString::Unmanaged(L"\t"), returnType);
						writer.WriteString(tryPrefix);
						writer.WriteLine(L";");

						writer.WriteString(tryPrefix);
						writer.WriteString(L"::vl::__vwsn::RunOnExit<::std::remove_cvref_t<decltype(");
						writer.WriteString(blockName);
						writer.WriteString(L")>> ");
						writer.WriteString(blockName);
						writer.WriteString(L"_dtor(&");
						writer.WriteString(blockName);
						writer.WriteLine(L");");
					}
					WString bodyPrefix = tryPrefix + L"\t";

					writer.WriteString(tryPrefix);
					writer.WriteLine(L"try");
					writer.WriteString(tryPrefix);
					writer.WriteLine(L"{");
					GenerateStatement(config, functionRecord, writer, node->protectedStatement, bodyPrefix, WString::Unmanaged(L"\t"), returnType);
					writer.WriteString(tryPrefix);
					writer.WriteLine(L"}");

					writer.WriteString(tryPrefix);
					writer.WriteString(L"catch(const ::vl::Exception&");
					if (node->catchStatement)
					{
						writer.WriteString(L" ");
						writer.WriteString(exName);
					}
					writer.WriteLine(L")");
					writer.WriteString(tryPrefix);
					writer.WriteLine(L"{");
					if (node->catchStatement)
					{
						writer.WriteString(bodyPrefix);
						writer.WriteString(L"auto ");
						writer.WriteString(config->ConvertName(node->name.value));
						writer.WriteString(L" = ::vl::reflection::description::IValueException::Create(");
						writer.WriteString(exName);
						writer.WriteLine(L".Message());");
						GenerateStatement(config, functionRecord, writer, node->catchStatement, bodyPrefix, WString::Unmanaged(L"\t"), returnType);
					}
					writer.WriteString(tryPrefix);
					writer.WriteLine(L"}");

					if (node->finallyStatement)
					{
						writer.WriteString(prefix);
						writer.WriteLine(L"}");
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					writer.WriteString(prefixBlock);
					writer.WriteLine(L"{");

					auto oldPrefix = prefix;
					if (node->endLabel.value != L"")
					{
						auto name = config->ConvertName(node->endLabel.value, L"__vwsnl_" + itow(functionRecord->labelCounter++) + L"_");
						functionRecord->labelNames.Add(node->endLabel.value, name);
						writer.WriteString(prefixBlock);
						writer.WriteLine(L"\t{");
						prefix += L"\t";
					}

					for (auto statement : node->statements)
					{
						statement = SearchUntilNonVirtualStatement(statement);

						if (statement.Cast<WfBlockStatement>())
						{
							Call(statement);
						}
						else
						{
							Call(statement, WString::Empty);
						}
					}

					if (node->endLabel.value != L"")
					{
						prefix = oldPrefix;
						writer.WriteString(prefixBlock);
						writer.WriteLine(L"\t}");
						writer.WriteString(prefixBlock);
						writer.WriteString(L"\t");
						writer.WriteString(functionRecord->labelNames[node->endLabel.value]);
						writer.WriteLine(L":;");
						functionRecord->labelNames.Remove(node->endLabel.value);
					}
					writer.WriteString(prefixBlock);
					writer.WriteLine(L"}");
				}

				void Visit(WfGotoStatement* node)override
				{
					writer.WriteString(prefix);
					writer.WriteString(L"goto ");
					writer.WriteString(functionRecord->labelNames[node->label.value]);
					writer.WriteLine(L";");
				}

				void Visit(WfExpressionStatement* node)override
				{
					writer.WriteString(prefix);
					GenerateExpression(config, writer, node->expression, nullptr, false);
					writer.WriteLine(L";");
				}

				void Visit(WfVariableStatement* node)override
				{
					auto scope = config->manager->nodeScopes[node->variable.Obj()];
					auto symbol = scope->symbols[node->variable->name.value][0].Obj();

					writer.WriteString(prefix);
					if (node->variable->expression)
					{
						writer.WriteString(L"auto");
					}
					else
					{
						writer.WriteString(config->ConvertType(symbol->typeInfo.Obj()));
					}
					writer.WriteString(L" ");
					writer.WriteString(config->ConvertName(node->variable->name.value));

					if (node->variable->expression)
					{
						writer.WriteString(L" = ");
						GenerateExpression(config, writer, node->variable->expression, symbol->typeInfo.Obj());
					}
					writer.WriteLine(L";");
				}

				void Visit(WfVirtualCseStatement* node)override
				{
					node->expandedStatement->Accept(this);
				}

				void Visit(WfCoroutineStatement* node)override
				{
					CHECK_FAIL(L"WfGenerateStatementVisitor::Visit(WfCoroutineStatement*)#Internal error, All coroutine statements do not generate C++ code.");
				}

				void Visit(WfStateMachineStatement* node)override
				{
					CHECK_FAIL(L"WfGenerateStatementVisitor::Visit(WfStateMachineStatement*)#Internal error, All state machine statements do not generate C++ code.");
				}
			};

			void GenerateStatement(WfCppConfig* config, Ptr<FunctionRecord> functionRecord, stream::StreamWriter& writer, Ptr<WfStatement> node, const WString& prefix, const WString& prefixDelta, reflection::description::ITypeInfo* returnType)
			{
				WfGenerateStatementVisitor visitor(config, functionRecord, writer, prefix, prefix + prefixDelta, returnType);
				node->Accept(&visitor);
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_WRITECLASS.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

			void WfCppConfig::WriteHeader_ClassPreDecl(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, const WString& name, const WString& prefix)
			{
				writer.WriteLine(prefix + L"class " + name + L";");
			}

			void WfCppConfig::WriteHeader_ClassPreDecl(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss)
			{
				auto td = manager->declarationTypes[decl.Obj()].Obj();
				WString name;
				auto prefix = WriteNamespace(writer, CppGetFullName(td), nss, name);
				WriteHeader_ClassPreDecl(writer, decl, name, prefix);
			}

			class WriteHeader_Class_FindClassDeclVisitor
				: public empty_visitor::DeclarationVisitor
			{
			public:
				List<Ptr<WfClassDeclaration>>&		unprocessed;

				WriteHeader_Class_FindClassDeclVisitor(List<Ptr<WfClassDeclaration>>& _unprocessed)
					:unprocessed(_unprocessed)
				{
				}

				void Dispatch(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Dispatch(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfClassDeclaration* node)override
				{
					unprocessed.Add(Ptr(node));
				}
			};

			void WfCppConfig::WriteHeader_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, const WString& name, const WString& prefix)
			{
				auto td = manager->declarationTypes[decl.Obj()].Obj();

				writer.WriteString(prefix + L"class " + name + L" : ");
				switch (decl->kind)
				{
				case WfClassKind::Class:
					{
						vint count = td->GetBaseTypeDescriptorCount();
						bool hasClassBase = Range<vint>(0, count)
							.Any([=](vint index)
							{
								auto baseTd = td->GetBaseTypeDescriptor(index);
								return baseTd->GetTypeDescriptorFlags() == TypeDescriptorFlags::Class
									&& baseTd != description::GetTypeDescriptor<DescriptableObject>();
							});

						if (!hasClassBase)
						{
							writer.WriteString(L"public ::vl::Object, ");
						}
						for (vint i = 0; i < count; i++)
						{
							auto baseTd = td->GetBaseTypeDescriptor(i);
							switch (baseTd->GetTypeDescriptorFlags())
							{
							case TypeDescriptorFlags::Class:
								if (baseTd != description::GetTypeDescriptor<DescriptableObject>())
								{
									writer.WriteString(L"public " + ConvertType(baseTd) + L", ");
								}
								break;
							case TypeDescriptorFlags::Interface:
								writer.WriteString(L"public virtual " + ConvertType(baseTd) + L", ");
								break;
							default:;
							}
						}
					}
					break;
				case WfClassKind::Interface:
					{
						vint count = td->GetBaseTypeDescriptorCount();
						for (vint i = 0; i < count; i++)
						{
							writer.WriteString(L"public virtual " + ConvertType(td->GetBaseTypeDescriptor(i)) + L", ");
						}
					}
					break;
				default:;
				}
				writer.WriteLine(L"public ::vl::reflection::Description<" + name + L">");
				writer.WriteLine(prefix + L"{");

				{
					List<Ptr<WfClassDeclaration>> unprocessed;
					unprocessed.Add(decl);

					for (auto attribute : attributeEvaluator->GetAttributes(decl->attributes, L"cpp", L"Friend"))
					{
						auto attValue = attributeEvaluator->GetAttributeValue(attribute);
						CHECK_ERROR(attValue.type == runtime::WfInsType::Unknown && attValue.typeDescriptor != nullptr, L"Unexpected value in attribute: @cpp.Friend.");
						auto td = attValue.typeDescriptor;

						auto scopeName = manager->typeNames[td];
						if (scopeName->declarations.Count() == 0)
						{
							writer.WriteLine(prefix + L"\tfriend class " + ConvertType(td) + L";");
						}
						else
						{
							auto friendDecl = scopeName->declarations[0].Cast<WfClassDeclaration>();
							unprocessed.Add(friendDecl);
						}
					}

					auto declTypeName = ConvertType(manager->declarationTypes[decl.Obj()].Obj());
					for (vint i = 0; i < unprocessed.Count(); i++)
					{
						auto current = unprocessed[i];
						if (current != decl)
						{
							auto currentTypeName = ConvertType(manager->declarationTypes[current.Obj()].Obj());

							bool isInternalClass = false;
							if (currentTypeName.Length() > declTypeName.Length() + 2)
							{
								if (currentTypeName.Left(declTypeName.Length() + 2) == declTypeName + L"::")
								{
									isInternalClass = true;
								}
							}
							if (!isInternalClass)
							{
								writer.WriteLine(prefix + L"\tfriend class " + currentTypeName + L";");
							}
						}

						vint index = classClosures.Keys().IndexOf(current.Obj());
						if (index != -1)
						{
							SortedList<WString> closureNames;
							CopyFrom(
								closureNames,
								From(classClosures.GetByIndex(index))
								.Select([&](Ptr<WfExpression> closure)
								{
									return (closure.Cast<WfNewInterfaceExpression>() ? L"class ::" : L"struct ::") +
										assemblyNamespace +
										L"::" +
										closureInfos[closure.Obj()]->lambdaClassName;
								})
							);
							for (auto closureName : closureNames)
							{
								writer.WriteLine(prefix + L"\tfriend " + closureName + L";");
							}
						}

						WriteHeader_Class_FindClassDeclVisitor visitor(unprocessed);
						for (auto memberDecl : current->declarations)
						{
							memberDecl->Accept(&visitor);
						}
					}
				}
				writer.WriteLine(L"#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA");
				writer.WriteLine(prefix + L"\tfriend struct ::vl::reflection::description::CustomTypeDescriptorSelector<" + name + L">;");
				writer.WriteLine(L"#endif");

				const vint PRIVATE = 0;
				const vint PROTECTED = 1;
				const vint PUBLIC = 2;
				vint accessor = -1;

				{
					vint index = enumDecls.Keys().IndexOf(decl.Obj());
					if (index != -1)
					{
						if (accessor != PUBLIC)
						{
							accessor = PUBLIC;
							writer.WriteLine(prefix + L"public:");
						}
						for (auto decl : enumDecls.GetByIndex(index))
						{
							WriteHeader_Enum(writer, decl, ConvertName(decl->name.value), prefix + L"\t", false);
							writer.WriteLine(L"");
						}
					}
				}

				{
					vint index = structDecls.Keys().IndexOf(decl.Obj());
					if (index != -1)
					{
						if (accessor != PUBLIC)
						{
							accessor = PUBLIC;
							writer.WriteLine(prefix + L"public:");
						}
						for (auto decl : structDecls.GetByIndex(index))
						{
							WriteHeader_Struct(writer, decl, ConvertName(decl->name.value), prefix + L"\t", false);
							writer.WriteLine(L"");
						}
					}
				}

				{
					vint index = classDecls.Keys().IndexOf(decl.Obj());
					if (index != -1)
					{
						if (accessor != PUBLIC)
						{
							accessor = PUBLIC;
							writer.WriteLine(prefix + L"public:");
						}
						for (auto decl : classDecls.GetByIndex(index))
						{
							WriteHeader_ClassPreDecl(writer, decl, ConvertName(decl->name.value), prefix + L"\t");
						}
						writer.WriteLine(L"");
						for (auto decl : classDecls.GetByIndex(index))
						{
							WriteHeader_Class(writer, decl, ConvertName(decl->name.value), prefix + L"\t");
						}
					}
				}

				for (auto memberDecl : decl->declarations)
				{
					vint memberAccessor = PUBLIC;
					if (attributeEvaluator->GetAttribute(memberDecl->attributes, L"cpp", L"Private"))
					{
						memberAccessor = PRIVATE;
					}
					else if (attributeEvaluator->GetAttribute(memberDecl->attributes, L"cpp", L"Protected"))
					{
						memberAccessor = PROTECTED;
					}

					if (accessor != memberAccessor)
					{
						accessor = memberAccessor;
						switch (accessor)
						{
						case PRIVATE:
							writer.WriteLine(prefix + L"private:");
							break;
						case PROTECTED:
							writer.WriteLine(prefix + L"protected:");
							break;
						case PUBLIC:
							writer.WriteLine(prefix + L"public:");
							break;
						}
					}
					GenerateClassMemberDecl(this, writer, ConvertName(decl->name.value), memberDecl, prefix + L"\t", false);
				}

				if (IsClassHasUserImplMethods(decl, false))
				{
					auto td = manager->declarationTypes[decl.Obj()].Obj();
					auto classFullName = CppGetFullName(td);
					writer.WriteLine(L"");
					writer.WriteLine(prefix + L"/* USER_CONTENT_BEGIN(custom members of " + classFullName + L") */");
					writer.WriteLine(prefix + L"/* USER_CONTENT_END() */");
				}

				writer.WriteLine(prefix + L"};");
			}

			WString WfCppConfig::WriteHeader_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss)
			{
				auto td = manager->declarationTypes[decl.Obj()].Obj();
				WString name;
				auto prefix = WriteNamespace(writer, CppGetFullName(td), nss, name);
				WriteHeader_Class(writer, decl, name, prefix);
				return prefix;
			}

			bool WfCppConfig::WriteCpp_ClassMember(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, Ptr<WfDeclaration> memberDecl, collections::List<WString>& nss)
			{
				List<WString> nss2;
				GetClassNamespace(decl, nss2);
				auto prefix = WriteNamespace(writer, nss, nss2);

				auto td = manager->declarationTypes[decl.Obj()].Obj();
				auto classFullName = CppGetFullName(td);
				return GenerateClassMemberImpl(this, writer, decl.Obj(), GetClassBaseName(decl), ConvertName(decl->name.value), classFullName, memberDecl, prefix);
			}

			void WfCppConfig::WriteCpp_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss)
			{
				List<Ptr<WfClassDeclaration>> classes;
				classes.Add(decl);
				vint processed = 0;
				while (processed < classes.Count())
				{
					auto current = classes[processed++];

					writer.WriteLine(L"/***********************************************************************");
					writer.WriteLine(L"Class (" + CppGetFullName(manager->declarationTypes[current.Obj()].Obj()) + L")");
					writer.WriteLine(L"***********************************************************************/");
					writer.WriteLine(L"");

					for (auto memberDecl : current->declarations)
					{
						if (WriteCpp_ClassMember(writer, current, memberDecl, nss))
						{
							writer.WriteLine(L"");
						}
					}

					vint index = classDecls.Keys().IndexOf(current.Obj());
					if (index != -1)
					{
						CopyFrom(classes, classDecls.GetByIndex(index), true);
					}
				}
			}
		}
	}
}


/***********************************************************************
.\CPP\WFCPP_WRITEENUM.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;

			void WfCppConfig::WriteHeader_Enum(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, const WString& name, const WString& prefix, bool mainHeaderDefinition)
			{
				if (mainHeaderDefinition)
				{
					writer.WriteLine(prefix + L"enum class " + name + L" : vl::vuint64_t");
					writer.WriteLine(prefix + L"{");
					for (auto item : decl->items)
					{
						switch (item->kind)
						{
						case WfEnumItemKind::Constant:
							writer.WriteLine(prefix + L"\t" + ConvertName(item->name.value) + L" = " + item->number.value + L"UL,");
							break;
						case WfEnumItemKind::Intersection:
							writer.WriteString(prefix + L"\t" + ConvertName(item->name.value) + L" = ");
							for (auto [enumInt, index] : indexed(item->intersections))
							{
								if (index > 0)
								{
									writer.WriteString(L" | ");
								}
								writer.WriteString(ConvertName(enumInt->name.value));
							}
							writer.WriteLine(L",");
							break;
						default:;
						}
					}
					writer.WriteLine(prefix + L"};");
				}
				else
				{
					auto td = manager->declarationTypes[decl.Obj()].Obj();
					writer.WriteString(prefix);
					writer.WriteString(L"using ");
					writer.WriteString(name);
					writer.WriteString(L" = ::");
					writer.WriteString(CppNameToHeaderEnumStructName(CppGetFullName(td), L"enum"));
					writer.WriteLine(L";");
				}
			}

			void WfCppConfig::WriteHeader_EnumOp(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, const WString& name, const WString& prefix)
			{
				const wchar_t* ops[] = { L"&", L"|" };
				for (auto op : ops)
				{
					writer.WriteString(prefix);
					writer.WriteString(L"inline ");
					writer.WriteString(name);
					writer.WriteString(L" operator");
					writer.WriteString(op);
					writer.WriteString(L" (");
					writer.WriteString(name);
					writer.WriteString(L" a, ");
					writer.WriteString(name);
					writer.WriteString(L" b) { return static_cast<");
					writer.WriteString(name);
					writer.WriteString(L">(static_cast<::vl::vuint64_t>(a) ");
					writer.WriteString(op);
					writer.WriteLine(L" static_cast<::vl::vuint64_t>(b)); }");
				}
			}

			void WfCppConfig::WriteHeader_Enum(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, collections::List<WString>& nss, bool mainHeaderDefinition)
			{
				auto td = manager->declarationTypes[decl.Obj()].Obj();
				if (mainHeaderDefinition)
				{
					WString name;
					auto prefix = WriteNamespace(writer, CppNameToHeaderEnumStructName(CppGetFullName(td), L"enum"), nss, name);
					WriteHeader_Enum(writer, decl, name, prefix, true);
					WriteHeader_EnumOp(writer, decl, name, prefix);
				}
				else
				{
					WString name;
					auto prefix = WriteNamespace(writer, CppGetFullName(td), nss, name);
					writer.WriteString(prefix);
					writer.WriteString(L"using ");
					writer.WriteString(name);
					writer.WriteString(L" = ::");
					writer.WriteString(CppNameToHeaderEnumStructName(CppGetFullName(td), L"enum"));
					writer.WriteLine(L";");
				}
			}

			void WfCppConfig::WriteHeader_MainHeaderEnums(stream::StreamWriter& writer, collections::List<WString>& nss)
			{
				List<Ptr<WfEnumDeclaration>> allEnums;
				CopyFrom(allEnums, Range<vint>(0, enumDecls.Count()).SelectMany([&](vint index) {return From(enumDecls.GetByIndex(index)); }));
				SortDeclsByName(allEnums);

				for (auto decl : allEnums)
				{
					WriteHeader_Enum(writer, decl, nss, true);
					writer.WriteLine(L"");
				}
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_WRITEFUNCTIONHEADER.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace reflection::description;

			ITypeInfo* WfCppConfig::WriteFunctionHeader(stream::StreamWriter& writer, ITypeInfo* typeInfo, collections::List<WString>& arguments, const WString& name, bool writeReturnType)
			{
				ITypeInfo* returnType = nullptr;
				if (writeReturnType)
				{
					returnType = typeInfo->GetElementType()->GetGenericArgument(0);
					writer.WriteString(ConvertType(returnType));
					writer.WriteChar(L' ');
				}

				writer.WriteString(name);
				writer.WriteString(L"(");
				for (vint i = 0; i < arguments.Count(); i++)
				{
					if (i > 0)
					{
						writer.WriteString(L", ");
					}
					writer.WriteString(ConvertArgumentType(typeInfo->GetElementType()->GetGenericArgument(i + 1)));
					writer.WriteChar(L' ');
					writer.WriteString(ConvertName(arguments[i]));
				}
				writer.WriteString(L")");

				return returnType;
			}

			ITypeInfo* WfCppConfig::WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfOrderedLambdaExpression> ordered, const WString& name, bool writeReturnType)
			{
				auto result = manager->expressionResolvings[ordered.Obj()];
				auto typeInfo = result.type.Obj();

				auto scope = manager->nodeScopes[ordered.Obj()].Obj();
				List<WString> arguments;
				CopyFrom(
					arguments,
					Range<vint>(0, scope->symbols.Count())
						.Select([scope](vint index)
						{
							return scope->symbols.GetByIndex(index)[0]->name;
						})
						.OrderBySelf()
					);

				return WriteFunctionHeader(writer, typeInfo, arguments, name, writeReturnType);
			}

			ITypeInfo* WfCppConfig::WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfFunctionExpression> funcExpr, const WString& name, bool writeReturnType)
			{
				auto result = manager->expressionResolvings[funcExpr.Obj()];
				auto typeInfo = result.type.Obj();

				List<WString> arguments;
				CopyFrom(
					arguments,
					From(funcExpr->function->arguments)
						.Select([](Ptr<WfFunctionArgument> argument)
						{
							return argument->name.value;
						})
					);
				return WriteFunctionHeader(writer, typeInfo, arguments, name, writeReturnType);
			}

			ITypeInfo* WfCppConfig::WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfFunctionDeclaration> decl, const WString& name, bool writeReturnType)
			{
				vint index1 = manager->declarationMemberInfos.Keys().IndexOf(decl.Obj());
				vint index2 = manager->interfaceMethodImpls.Keys().IndexOf(decl.Obj());
				auto methodInfo =
					index1 != -1 ? dynamic_cast<IMethodInfo*>(manager->declarationMemberInfos.Values()[index1].Obj()) :
					index2 != -1 ? manager->interfaceMethodImpls.Values()[index2] :
					nullptr;

				List<WString> arguments;
				CopyFrom(
					arguments,
					From(decl->arguments)
						.Select([](Ptr<WfFunctionArgument> argument)
						{
							return argument->name.value;
						})
					);

				if (methodInfo)
				{
					return WriteFunctionHeader(writer, methodInfo, arguments, name, writeReturnType);
				}
				else
				{
					auto scope = manager->nodeScopes[decl.Obj()].Obj();
					auto symbol = manager->GetDeclarationSymbol(scope, decl.Obj());
					auto typeInfo = symbol->typeInfo.Obj();

					return WriteFunctionHeader(writer, typeInfo, arguments, name, writeReturnType);
				}
			}

			ITypeInfo* WfCppConfig::WriteFunctionHeader(stream::StreamWriter& writer, IMethodInfo* methodInfo, collections::List<WString>& arguments, const WString& name, bool writeReturnType)
			{
				ITypeInfo* returnType = nullptr;
				if (writeReturnType)
				{
					returnType = methodInfo->GetReturn();
					writer.WriteString(ConvertType(returnType));
					writer.WriteChar(L' ');
				}
				writer.WriteString(name);
				writer.WriteString(L"(");
				vint count = methodInfo->GetParameterCount();
				for (vint i = 0; i < count; i++)
				{
					if (i > 0)
					{
						writer.WriteString(L", ");
					}
					writer.WriteString(ConvertArgumentType(methodInfo->GetParameter(i)->GetType()));
					writer.WriteChar(L' ');
					if (arguments.Count() == 0)
					{
						writer.WriteString(ConvertName(methodInfo->GetParameter(i)->GetName()));
					}
					else
					{
						writer.WriteString(ConvertName(arguments[i]));
					}
				}
				writer.WriteString(L")");
				return returnType;
			}

			ITypeInfo* WfCppConfig::WriteFunctionHeader(stream::StreamWriter& writer, IMethodInfo* methodInfo, const WString& name, bool writeReturnType)
			{
				List<WString> arguments;
				return WriteFunctionHeader(writer, methodInfo, arguments, name, writeReturnType);
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_WRITEGLOBAL.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

			void WfCppConfig::SortClosure(Dictionary<WString, Ptr<WfExpression>>& reversedLambdaExprs, Dictionary<WString, Ptr<WfNewInterfaceExpression>>& reversedClassExprs)
			{
				CopyFrom(
					reversedLambdaExprs,
					From(lambdaExprs)
						.Select([](Pair<Ptr<WfExpression>, WString> pair)
						{
							return Pair<WString, Ptr<WfExpression>>(pair.value, pair.key);
						})
					);

				CopyFrom(
					reversedClassExprs,
					From(classExprs)
						.Select([](Pair<Ptr<WfNewInterfaceExpression>, WString> pair)
						{
							return Pair<WString, Ptr<WfNewInterfaceExpression>>(pair.value, pair.key);
						})
					);
			}

			void WfCppConfig::WriteHeader_Global(stream::StreamWriter& writer)
			{
				Dictionary<WString, Ptr<WfExpression>> reversedLambdaExprs;
				Dictionary<WString, Ptr<WfNewInterfaceExpression>> reversedClassExprs;
				SortClosure(reversedLambdaExprs, reversedClassExprs);

				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"Global Variables and Functions");
				writer.WriteLine(L"***********************************************************************/");
				writer.WriteLine(L"");
				writer.WriteLine(L"namespace " + assemblyNamespace);
				writer.WriteLine(L"{");
				writer.WriteLine(L"\tclass " + assemblyName);
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\tpublic:");
				if (varDecls.Count() > 0)
				{
					writer.WriteLine(L"");
					for (auto decl : varDecls)
					{
						auto scope = manager->nodeScopes[decl.Obj()].Obj();
						auto symbol = scope->symbols[decl->name.value][0];
						auto typeInfo = symbol->typeInfo;
						writer.WriteString(L"\t\t" + ConvertType(typeInfo.Obj()) + L" " + ConvertName(decl->name.value));
						auto defaultValue = DefaultValue(typeInfo.Obj());
						if (defaultValue != L"")
						{
							writer.WriteString(L" = ");
							writer.WriteString(defaultValue);
						}
						writer.WriteLine(L";");
					}
				}
				if (funcDecls.Count() > 0)
				{
					writer.WriteLine(L"");
					for (auto decl : funcDecls)
					{
						writer.WriteString(L"\t\t");
						WriteFunctionHeader(writer, decl, ConvertName(decl->name.value), true);
						writer.WriteLine(L";");
					}
				}
				writer.WriteLine(L"");
				writer.WriteLine(L"\t\tstatic " + assemblyName + L"& Instance();");
				writer.WriteLine(L"\t};");

				if (reversedLambdaExprs.Count() + reversedClassExprs.Count() > 0)
				{
					writer.WriteLine(L"");
					writer.WriteLine(L"/***********************************************************************");
					writer.WriteLine(L"Closures");
					writer.WriteLine(L"***********************************************************************/");

					for (auto expr : reversedLambdaExprs.Values())
					{
						writer.WriteLine(L"");
						WriteHeader_LambdaExprDecl(writer, expr);
					}

					for (auto expr : reversedClassExprs.Values())
					{
						writer.WriteLine(L"");
						WriteHeader_ClassExprDecl(writer, expr);
					}
				}

				writer.WriteLine(L"}");
			}

			void WfCppConfig::WriteCpp_Global(stream::StreamWriter& writer)
			{
				Dictionary<WString, Ptr<WfExpression>> reversedLambdaExprs;
				Dictionary<WString, Ptr<WfNewInterfaceExpression>> reversedClassExprs;
				SortClosure(reversedLambdaExprs, reversedClassExprs);

				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"Global Variables");
				writer.WriteLine(L"***********************************************************************/");
				writer.WriteLine(L"");

				WString storageName = assemblyNamespace + L"_" + assemblyName;
				writer.WriteLine(L"BEGIN_GLOBAL_STORAGE_CLASS(" + storageName + L")");
				writer.WriteLine(L"\t" + assemblyNamespace + L"::" + assemblyName + L" instance;");
				writer.WriteLine(L"\tINITIALIZE_GLOBAL_STORAGE_CLASS");
				if (varDecls.Count() > 0)
				{
					writer.WriteLine(L"");
					for (auto decl : varDecls)
					{
						auto scope = manager->nodeScopes[decl.Obj()].Obj();
						auto symbol = scope->symbols[decl->name.value][0];
						auto typeInfo = symbol->typeInfo;
						if (decl->expression)
						{
							writer.WriteString(L"\t\tinstance." + ConvertName(decl->name.value) + L" = ");
							GenerateExpression(this, writer, decl->expression, typeInfo.Obj());
							writer.WriteLine(L";");
						}
					}
				}
				if (staticInitDecls.Count() > 0)
				{
					auto voidType = description::TypeInfoRetriver<void>::CreateTypeInfo();
					for (auto staticInitDecl : staticInitDecls)
					{
						writer.WriteLine(L"");
						writer.WriteLine(L"\t\t([]()");
						GenerateStatement(this, Ptr(new FunctionRecord), writer, staticInitDecl->statement, L"\t\t", WString::Unmanaged(L"\t"), voidType.Obj());
						writer.WriteLine(L"\t\t)();");
					}
				}
				writer.WriteLine(L"\tFINALIZE_GLOBAL_STORAGE_CLASS");
				if (varDecls.Count() > 0)
				{
					writer.WriteLine(L"");
					for (auto decl : varDecls)
					{
						auto scope = manager->nodeScopes[decl.Obj()].Obj();
						auto symbol = scope->symbols[decl->name.value][0];
						auto typeInfo = symbol->typeInfo;
						switch (typeInfo->GetDecorator())
						{
						case ITypeInfo::RawPtr:
						case ITypeInfo::SharedPtr:
							writer.WriteLine(L"\t\tinstance." + ConvertName(decl->name.value) + L" = nullptr;");
							break;
						case ITypeInfo::Nullable:
							writer.WriteString(L"\t\tinstance." + ConvertName(decl->name.value) + L" = ");
							ConvertType(typeInfo.Obj());
							writer.WriteLine(L"();");
							break;
						default:
							if (typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<WString>())
							{
								writer.WriteLine(L"\t\tinstance." + ConvertName(decl->name.value) + L" = ::vl::WString::Empty;");
							}
							else if (typeInfo->GetTypeDescriptor() == description::GetTypeDescriptor<Value>())
							{
								writer.WriteLine(L"\t\tinstance." + ConvertName(decl->name.value) + L" = ::vl::reflection::description::Value();");
							}
						}
					}
				}
				writer.WriteLine(L"END_GLOBAL_STORAGE_CLASS(" + storageName + L")");
				writer.WriteLine(L"");

				writer.WriteString(L"namespace ");
				writer.WriteLine(assemblyNamespace);
				writer.WriteLine(L"{");

				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"Global Functions");
				writer.WriteLine(L"***********************************************************************/");

				for (auto decl : funcDecls)
				{
					writer.WriteLine(L"");
					writer.WriteString(L"\t");
					auto returnType = WriteFunctionHeader(writer, decl, assemblyName + L"::" + ConvertName(decl->name.value), true);
					writer.WriteLine(L"");
					WriteFunctionBody(writer, decl->statement, L"\t", returnType);
				}

				writer.WriteLine(L"");
				writer.WriteLine(L"\t" + assemblyName + L"& " + assemblyName + L"::Instance()");
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\t\treturn Get" + storageName + L"().instance;");
				writer.WriteLine(L"\t}");

				if (reversedLambdaExprs.Count() + reversedClassExprs.Count() > 0)
				{
					writer.WriteLine(L"");
					writer.WriteLine(L"/***********************************************************************");
					writer.WriteLine(L"Closures");
					writer.WriteLine(L"***********************************************************************/");

					for (auto expr : reversedLambdaExprs.Values())
					{
						writer.WriteLine(L"");
						writer.WriteLine(L"\t//-------------------------------------------------------------------");
						writer.WriteLine(L"");
						WriteCpp_LambdaExprImpl(writer, expr);
					}

					if (reversedClassExprs.Count() > 0)
					{
						writer.WriteLine(L"");
						for (auto expr : reversedClassExprs.Values())
						{
							writer.WriteLine(L"\t//-------------------------------------------------------------------");
							writer.WriteLine(L"");
							WriteCpp_ClassExprImpl(writer, expr);
						}
					}
				}

				writer.WriteLine(L"}");
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_WRITELAMBDA.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace analyzer;
			using namespace reflection;
			using namespace reflection::description;

/***********************************************************************
WfCppConfig::WriteCpp
***********************************************************************/

			void WfCppConfig::WriteHeader_ClosurePreDecl(stream::StreamWriter& writer, Ptr<WfExpression> closure)
			{
				auto info = closureInfos[closure.Obj()];
				writer.WriteString(L"\t");
				if (closure.Cast<WfNewInterfaceExpression>())
				{
					writer.WriteString(L"class ");
				}
				else
				{
					writer.WriteString(L"struct ");
				}
				writer.WriteString(info->lambdaClassName);
				writer.WriteLine(L";");
			}

			void WfCppConfig::WriteHeader_LambdaExprDecl(stream::StreamWriter& writer, Ptr<WfExpression> lambda)
			{
				if (auto ordered = lambda.Cast<WfOrderedLambdaExpression>())
				{
					auto name = lambdaExprs[lambda.Obj()];
					writer.WriteLine(L"\tstruct " + name);
					writer.WriteLine(L"\t{");

					if (WriteCpp_ClosureMembers(writer, lambda))
					{
						writer.WriteLine(L"");
					}
					writer.WriteString(L"\t\t");
					WriteCpp_ClosureCtor(writer, lambda, name);
					writer.WriteLine(L";");
					writer.WriteLine(L"");

					writer.WriteString(L"\t\t");
					WriteFunctionHeader(writer, ordered, L"operator()", true);
					writer.WriteLine(L" const;");
					writer.WriteLine(L"\t};");
				}
				else if (auto funcExpr = lambda.Cast<WfFunctionExpression>())
				{
					auto name = lambdaExprs[lambda.Obj()];
					writer.WriteLine(L"\tstruct " + name);
					writer.WriteLine(L"\t{");

					if (WriteCpp_ClosureMembers(writer, lambda))
					{
						writer.WriteLine(L"");
					}
					writer.WriteString(L"\t\t");
					WriteCpp_ClosureCtor(writer, lambda, name);
					writer.WriteLine(L";");
					writer.WriteLine(L"");

					writer.WriteString(L"\t\t");
					WriteFunctionHeader(writer, funcExpr, L"operator()", true);
					writer.WriteLine(L" const;");
					writer.WriteLine(L"\t};");
				}
			}

			void WfCppConfig::WriteHeader_ClassExprDecl(stream::StreamWriter& writer, Ptr<WfNewInterfaceExpression> lambda)
			{
				auto result = manager->expressionResolvings[lambda.Obj()];
				auto td = result.constructorInfo->GetOwnerTypeDescriptor();
				auto name = classExprs[lambda.Obj()];
				writer.WriteLine(L"\tclass " + name + L" : public ::vl::Object, public virtual " + ConvertType(td));
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\tpublic:");

				if (WriteCpp_ClosureMembers(writer, lambda))
				{
					writer.WriteLine(L"");
				}
				writer.WriteString(L"\t\t");
				WriteCpp_ClosureCtor(writer, lambda, name);
				writer.WriteLine(L";");
				writer.WriteLine(L"");

				for (auto memberDecl : lambda->declarations)
				{
					GenerateClassMemberDecl(this, writer, name, memberDecl, L"\t\t", true);
				}
				writer.WriteLine(L"\t};");
			}

			bool WfCppConfig::WriteCpp_ClosureMembers(stream::StreamWriter& writer, Ptr<WfExpression> closure)
			{
				auto info = closureInfos[closure.Obj()];

				for (auto symbol : info->symbols.Values())
				{
					writer.WriteString(L"\t\t");
					writer.WriteString(ConvertType(symbol->typeInfo.Obj()));
					writer.WriteString(L" ");
					writer.WriteString(ConvertName(symbol->name));
					writer.WriteLine(L";");
				}

				for (auto [thisType, index] : indexed(info->thisTypes))
				{
					auto typeInfo = Ptr(new RawPtrTypeInfo(Ptr(new TypeDescriptorTypeInfo(thisType, TypeInfoHint::Normal))));

					writer.WriteString(L"\t\t");
					writer.WriteString(ConvertType(typeInfo.Obj()));
					writer.WriteString(L" ");
					writer.WriteString(L"__vwsnthis_" + itow(index));
					writer.WriteLine(L";");
				}

				return info->symbols.Count() + info->thisTypes.Count() > 0;
			}

			void WfCppConfig::WriteCpp_ClosureCtor(stream::StreamWriter& writer, Ptr<WfExpression> closure, const WString& name)
			{
				auto info = closureInfos[closure.Obj()];

				writer.WriteString(name);
				writer.WriteString(L"(");

				vint argumentIndex = 0;

				for (auto [symbol, index] : indexed(From(info->symbols.Values()).Concat(info->ctorArgumentSymbols.Values())))
				{
					if (argumentIndex++ > 0)
					{
						writer.WriteString(L", ");
					}
					writer.WriteString(ConvertType(symbol->typeInfo.Obj()));
					writer.WriteString(L" __vwsnctor_");
					writer.WriteString(ConvertName(symbol->name));
				}

				for (auto [thisType, index] : indexed(info->thisTypes))
				{
					auto typeInfo = Ptr(new RawPtrTypeInfo(Ptr(new TypeDescriptorTypeInfo(thisType, TypeInfoHint::Normal))));

					if (argumentIndex++ > 0)
					{
						writer.WriteString(L", ");
					}
					writer.WriteString(ConvertType(typeInfo.Obj()));
					writer.WriteString(L" __vwsnctorthis_" + itow(index));
				}

				writer.WriteString(L")");
			}

			void WfCppConfig::WriteCpp_ClosureCtorInitList(stream::StreamWriter& writer, Ptr<WfExpression> closure)
			{
				auto info = closureInfos[closure.Obj()];

				for (auto [symbol, index] : indexed(info->symbols.Values()))
				{
					if (index > 0)
					{
						writer.WriteString(L"\t\t, ");
					}
					else
					{
						writer.WriteString(L"\t\t:");
					}
					writer.WriteString(ConvertName(symbol->name));
					writer.WriteString(L"(__vwsnctor_");
					writer.WriteString(ConvertName(symbol->name));
					writer.WriteLine(L")");
				}

				for (auto [thisType, index] : indexed(info->thisTypes))
				{
					if (index > 0 || info->symbols.Count() > 0)
					{
						writer.WriteString(L"\t\t, ");
					}
					else
					{
						writer.WriteString(L"\t\t:");
					}
					writer.WriteString(L"__vwsnthis_" + itow(index));
					writer.WriteString(L"(::vl::__vwsn::This(__vwsnctorthis_" + itow(index));
					writer.WriteLine(L"))");
				}
			}

			void WfCppConfig::WriteCpp_LambdaExprImpl(stream::StreamWriter& writer, Ptr<WfExpression> lambda)
			{
				if (auto ordered = lambda.Cast<WfOrderedLambdaExpression>())
				{
					auto name = lambdaExprs[lambda.Obj()];

					writer.WriteString(L"\t");
					WriteCpp_ClosureCtor(writer, lambda, name + L"::" + name);
					writer.WriteLine(L"");
					WriteCpp_ClosureCtorInitList(writer, lambda);
					writer.WriteLine(L"\t{");
					writer.WriteLine(L"\t}");
					writer.WriteLine(L"");

					writer.WriteString(L"\t");
					auto returnType = WriteFunctionHeader(writer, ordered, name + L"::operator()", true);
					writer.WriteLine(L" const");
					writer.WriteLine(L"\t{");
					WriteFunctionBody(writer, ordered->body, L"\t\t", returnType);
					writer.WriteLine(L"\t}");
				}
				else if (auto funcExpr = lambda.Cast<WfFunctionExpression>())
				{
					auto name = lambdaExprs[lambda.Obj()];

					writer.WriteString(L"\t");
					WriteCpp_ClosureCtor(writer, lambda, name + L"::" + name);
					writer.WriteLine(L"");
					WriteCpp_ClosureCtorInitList(writer, lambda);
					writer.WriteLine(L"\t{");
					writer.WriteLine(L"\t}");
					writer.WriteLine(L"");

					writer.WriteString(L"\t");
					auto returnType = WriteFunctionHeader(writer, funcExpr, name + L"::operator()", true);
					writer.WriteLine(L" const");
					WriteFunctionBody(writer, funcExpr->function->statement, L"\t", returnType);
				}
			}

			class WriteCpp_ClassExprImpl_InitFieldVisitor
				: public empty_visitor::DeclarationVisitor
			{
			public:
				WfCppConfig*						config;
				stream::StreamWriter&				writer;

				WriteCpp_ClassExprImpl_InitFieldVisitor(WfCppConfig* _config, stream::StreamWriter& _writer)
					:config(_config)
					, writer(_writer)
				{
				}

				void Dispatch(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Dispatch(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
					if (node->expression)
					{
						auto scope = config->manager->nodeScopes[node].Obj();
						auto symbol = scope->symbols[node->name.value][0];
						auto typeInfo = symbol->typeInfo;
						writer.WriteString(L"\t\tthis->");
						writer.WriteString(config->ConvertName(node->name.value));
						writer.WriteString(L" = ");
						GenerateExpression(config, writer, node->expression, typeInfo.Obj());
						writer.WriteLine(L";");
					}
				}
			};

			void WfCppConfig::WriteCpp_ClassExprImpl(stream::StreamWriter& writer, Ptr<WfNewInterfaceExpression> lambda)
			{
				auto name = classExprs[lambda.Obj()];

				writer.WriteString(L"\t");
				WriteCpp_ClosureCtor(writer, lambda, name + L"::" + name);
				writer.WriteLine(L"");
				WriteCpp_ClosureCtorInitList(writer, lambda);
				writer.WriteLine(L"\t{");

				{
					WriteCpp_ClassExprImpl_InitFieldVisitor visitor(this, writer);
					for (auto memberDecl : lambda->declarations)
					{
						memberDecl->Accept(&visitor);
					}
				}

				writer.WriteLine(L"\t}");
				writer.WriteLine(L"");

				WString classFullName = L"::" + assemblyNamespace + L"::" + name;
				for (auto memberDecl : lambda->declarations)
				{
					if (GenerateClassMemberImpl(this, writer, nullptr, name, name, classFullName, memberDecl, L"\t"))
					{
						writer.WriteLine(L"");
					}
				}
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_WRITEREFLECTION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;

			void LoadTypes(WfCppConfig* config, List<ITypeDescriptor*>& tds)
			{
				CopyFrom(
					tds,
					From(config->manager->declarationTypes.Values())
						.OrderByKey([](auto&& a)
						{
							return a->GetTypeName();
						})
						.Select([](Ptr<ITypeDescriptor> td)
						{
							return td.Obj();
						})
					);
			}

			void WfCppConfig::WriteHeader_Reflection(stream::StreamWriter& writer)
			{
				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"Reflection");
				writer.WriteLine(L"***********************************************************************/");
				writer.WriteLine(L"");
				List<ITypeDescriptor*> tds;
				LoadTypes(this, tds);

				writer.WriteLine(L"namespace vl");
				writer.WriteLine(L"{");
				writer.WriteLine(L"\tnamespace reflection");
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\t\tnamespace description");
				writer.WriteLine(L"\t\t{");
				writer.WriteLine(L"#ifndef VCZH_DEBUG_NO_REFLECTION");

				for (auto td : tds)
				{
					writer.WriteString(L"\t\t\tDECL_TYPE_INFO(");
					writer.WriteString(ConvertType(td));
					writer.WriteLine(L")");
				}

				List<ITypeDescriptor*> tdInterfaces;
				CopyFrom(
					tdInterfaces,
					From(tds)
						.Where([](ITypeDescriptor* td)
						{
							return td->GetTypeDescriptorFlags() == TypeDescriptorFlags::Interface;
						})
					);
				{
					vint processed = 0;
					while (processed < tdInterfaces.Count())
					{
						vint count = tdInterfaces.Count();
						for (vint i = processed; i < count; i++)
						{
							auto td = tdInterfaces[i];
							if (Range<vint>(0, td->GetBaseTypeDescriptorCount())
								.All([&](vint baseIndex)
								{
									return tdInterfaces.IndexOf(td->GetBaseTypeDescriptor(baseIndex)) < processed;
								}))
							{
								tdInterfaces.RemoveAt(i);
								tdInterfaces.Insert(processed++, td);
							}
						}
					}
				}

				if (tdInterfaces.Count() > 0)
				{
					writer.WriteLine(L"");
					writer.WriteLine(L"#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA");
					for (auto td : tdInterfaces)
					{
						List<ITypeDescriptor*> baseTds;
						CopyFrom(
							baseTds,
							Range<vint>(0, td->GetBaseTypeDescriptorCount())
								.Select([&](vint index)
								{
									return td->GetBaseTypeDescriptor(index);
								})
								.Where([&](ITypeDescriptor* baseTd)
								{
									return baseTd->GetTypeDescriptorFlags() != TypeDescriptorFlags::IDescriptable;
								})
							);

						writer.WriteLine(L"");
						if (baseTds.Count() > 0)
						{
							writer.WriteString(L"\t\t\tBEGIN_INTERFACE_PROXY_SHAREDPTR(");
							writer.WriteString(ConvertType(td));
							for (auto baseTd : baseTds)
							{
								writer.WriteString(L", ");
								writer.WriteString(ConvertType(baseTd));
							}
							writer.WriteLine(L")");
						}
						else
						{
							writer.WriteString(L"\t\t\tBEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(");
							writer.WriteString(ConvertType(td));
							writer.WriteLine(L")");
						}

						vint methodGroupCount = td->GetMethodGroupCount();
						for (vint i = 0; i < methodGroupCount; i++)
						{
							auto methodGroup = td->GetMethodGroup(i);
							vint methodCount = methodGroup->GetMethodCount();
							for (vint j = 0; j < methodCount; j++)
							{
								auto methodInfo = methodGroup->GetMethod(j);
								if (!methodInfo->IsStatic())
								{
									writer.WriteString(L"\t\t\t\t");
									WriteFunctionHeader(writer, methodInfo, ConvertName(methodInfo->GetName()), true);
									writer.WriteLine(L" override");
									writer.WriteLine(L"\t\t\t\t{");

									if (methodInfo->GetReturn()->GetTypeDescriptor() == description::GetTypeDescriptor<void>())
									{
										writer.WriteString(L"\t\t\t\t\tINVOKE_INTERFACE_PROXY");
									}
									else
									{
										writer.WriteString(L"\t\t\t\t\tINVOKEGET_INTERFACE_PROXY");
									}

									if (methodInfo->GetParameterCount() > 0)
									{
										writer.WriteString(L"(");
										writer.WriteString(ConvertName(methodInfo->GetName()));
										vint parameterCount = methodInfo->GetParameterCount();
										for (vint k = 0; k < parameterCount; k++)
										{
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(methodInfo->GetParameter(k)->GetName()));
										}
										writer.WriteLine(L");");
									}
									else
									{
										writer.WriteString(L"_NOPARAMS(");
										writer.WriteString(ConvertName(methodInfo->GetName()));
										writer.WriteLine(L");");
									}

									writer.WriteLine(L"\t\t\t\t}");
								}
							}
						}

						writer.WriteString(L"\t\t\tEND_INTERFACE_PROXY(");
						writer.WriteString(ConvertType(td));
						writer.WriteLine(L")");
					}
					writer.WriteLine(L"#endif");
				}

				writer.WriteLine(L"#endif");
				writer.WriteLine(L"");

				writer.WriteString(L"\t\t\textern bool Load");
				writer.WriteString(assemblyName);
				writer.WriteLine(L"Types();");
				writer.WriteLine(L"\t\t}");
				writer.WriteLine(L"\t}");
				writer.WriteLine(L"}");
			}

			void WfCppConfig::WriteCpp_Reflection(stream::StreamWriter& writer)
			{
				writer.WriteLine(L"/***********************************************************************");
				writer.WriteLine(L"Reflection");
				writer.WriteLine(L"***********************************************************************/");
				writer.WriteLine(L"");
				List<ITypeDescriptor*> tds;
				LoadTypes(this, tds);

				writer.WriteLine(L"namespace vl");
				writer.WriteLine(L"{");
				writer.WriteLine(L"\tnamespace reflection");
				writer.WriteLine(L"\t{");
				writer.WriteLine(L"\t\tnamespace description");
				writer.WriteLine(L"\t\t{");
				writer.WriteLine(L"#ifndef VCZH_DEBUG_NO_REFLECTION");

				for (auto td : tds)
				{
					writer.WriteString(L"\t\t\tIMPL_CPP_TYPE_INFO(");
					WString type = ConvertType(td);
					if (type.Length() > 2 && type.Sub(0, 2) == L"::")
					{
						type = type.Sub(2, type.Length() - 2);
					}
					writer.WriteString(type);
					writer.WriteLine(L")");
				}
				writer.WriteLine(L"");

				writer.WriteLine(L"#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA");
				writer.WriteLine(L"#define _ ,");
				for (auto td : tds)
				{
					switch (td->GetTypeDescriptorFlags())
					{
					case TypeDescriptorFlags::NormalEnum:
					case TypeDescriptorFlags::FlagEnum:
						{
							writer.WriteString(L"\t\t\tBEGIN_ENUM_ITEM");
							if (td->GetTypeDescriptorFlags() == TypeDescriptorFlags::FlagEnum)
							{
								writer.WriteString(L"_MERGABLE");
							}
							writer.WriteString(L"(");
							writer.WriteString(ConvertType(td));
							writer.WriteLine(L")");

							auto enumType = td->GetEnumType();
							vint count = enumType->GetItemCount();
							for (vint i = 0; i < count; i++)
							{
								writer.WriteString(L"\t\t\t\tENUM_CLASS_ITEM(");
								writer.WriteString(ConvertName(enumType->GetItemName(i)));
								writer.WriteLine(L")");
							}

							writer.WriteString(L"\t\t\tEND_ENUM_ITEM(");
							writer.WriteString(ConvertType(td));
							writer.WriteLine(L")");
						}
						break;
					case TypeDescriptorFlags::Struct:
						{
							writer.WriteString(L"\t\t\tBEGIN_STRUCT_MEMBER(");
							writer.WriteString(ConvertType(td));
							writer.WriteLine(L")");

							vint count = td->GetPropertyCount();
							for (vint i = 0; i < count; i++)
							{
								writer.WriteString(L"\t\t\t\tSTRUCT_MEMBER(");
								writer.WriteString(ConvertName(td->GetProperty(i)->GetName()));
								writer.WriteLine(L")");
							}

							writer.WriteString(L"\t\t\tEND_STRUCT_MEMBER(");
							writer.WriteString(ConvertType(td));
							writer.WriteLine(L")");
						}
						break;
					case TypeDescriptorFlags::Interface:
					case TypeDescriptorFlags::Class:
						{
							if (td->GetTypeDescriptorFlags() == TypeDescriptorFlags::Interface)
							{
								writer.WriteString(L"\t\t\tBEGIN_INTERFACE_MEMBER(");
							}
							else
							{
								writer.WriteString(L"\t\t\tBEGIN_CLASS_MEMBER(");
							}
							writer.WriteString(ConvertType(td));
							writer.WriteLine(L")");

							vint baseCount = td->GetBaseTypeDescriptorCount();
							for (vint i = 0; i < baseCount; i++)
							{
								writer.WriteString(L"\t\t\t\tCLASS_MEMBER_BASE(");
								writer.WriteString(ConvertType(td->GetBaseTypeDescriptor(i)));
								writer.WriteLine(L")");
							}

							if (td->GetTypeDescriptorFlags() == TypeDescriptorFlags::Class)
							{
								auto methodGroup = td->GetConstructorGroup();
								vint methodCount = methodGroup->GetMethodCount();
								for (vint j = 0; j < methodCount; j++)
								{
									auto methodInfo = methodGroup->GetMethod(j);
									vint parameterCount = methodInfo->GetParameterCount();

									writer.WriteString(L"\t\t\t\tCLASS_MEMBER_CONSTRUCTOR(");
									writer.WriteString(ConvertType(methodInfo->GetReturn()));
									writer.WriteString(L"(");
									for (vint k = 0; k < parameterCount; k++)
									{
										if (k > 0)
										{
											writer.WriteString(L", ");
										}
										writer.WriteString(ConvertArgumentType(methodInfo->GetParameter(k)->GetType()));
									}
									writer.WriteString(L")");

									if (parameterCount > 0)
									{
										writer.WriteString(L", {");
										for (vint k = 0; k < parameterCount; k++)
										{
											if (k > 0)
											{
												writer.WriteString(L" _");
											}
											writer.WriteString(L" L\"");
											writer.WriteString(ConvertName(methodInfo->GetParameter(k)->GetName()));
											writer.WriteString(L"\"");
										}
										writer.WriteLine(L" })");
									}
									else
									{
										writer.WriteLine(L", NO_PARAMETER)");
									}
								}
							}

							vint methodGroupCount = td->GetMethodGroupCount();
							for (vint i = 0; i < methodGroupCount; i++)
							{
								auto methodGroup = td->GetMethodGroup(i);
								vint methodCount = methodGroup->GetMethodCount();
								for (vint j = 0; j < methodCount; j++)
								{
									auto methodInfo = methodGroup->GetMethod(j);
									if (methodInfo->IsStatic())
									{
										writer.WriteString(L"\t\t\t\tCLASS_MEMBER_STATIC_METHOD");
									}
									else
									{
										writer.WriteString(L"\t\t\t\tCLASS_MEMBER_METHOD");
									}
									if (methodCount > 1)
									{
										writer.WriteString(L"_OVERLOAD");
									}
									writer.WriteString(L"(");
									writer.WriteString(ConvertName(methodInfo->GetName()));

									vint parameterCount = methodInfo->GetParameterCount();
									if (parameterCount > 0)
									{
										writer.WriteString(L", {");
										for (vint k = 0; k < parameterCount; k++)
										{
											if (k > 0)
											{
												writer.WriteString(L" _");
											}
											writer.WriteString(L" L\"");
											writer.WriteString(ConvertName(methodInfo->GetParameter(k)->GetName()));
											writer.WriteString(L"\"");
										}
										writer.WriteString(L" }");
									}
									else
									{
										writer.WriteString(L", NO_PARAMETER");
									}
									if (methodCount > 1)
									{
										writer.WriteString(L", ");
										auto typeDecorator = methodInfo->IsStatic() ? WString::Unmanaged(L"(*)") : L"(" + ConvertType(td) + L"::*)";
										writer.WriteString(ConvertFunctionType(methodInfo, typeDecorator));
									}
									writer.WriteLine(L")");
								}
							}

							vint eventCount = td->GetEventCount();
							for (vint i = 0; i < eventCount; i++)
							{
								auto eventInfo = td->GetEvent(i);
								writer.WriteString(L"\t\t\t\tCLASS_MEMBER_EVENT(");
								writer.WriteString(ConvertName(eventInfo->GetName()));
								writer.WriteLine(L")");
							}

							vint propertyCount = td->GetPropertyCount();
							for (vint i = 0; i < propertyCount; i++)
							{
								auto propertyInfo = td->GetProperty(i);
								if (auto getter = propertyInfo->GetGetter())
								{
									if (auto eventInfo = propertyInfo->GetValueChangedEvent())
									{
										if (auto setter = propertyInfo->GetSetter())
										{
											writer.WriteString(L"\t\t\t\tCLASS_MEMBER_PROPERTY_EVENT(");
											writer.WriteString(ConvertName(propertyInfo->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(getter->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(setter->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(eventInfo->GetName()));
											writer.WriteLine(L")");
										}
										else
										{
											writer.WriteString(L"\t\t\t\tCLASS_MEMBER_PROPERTY_EVENT_READONLY(");
											writer.WriteString(ConvertName(propertyInfo->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(getter->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(eventInfo->GetName()));
											writer.WriteLine(L")");
										}
									}
									else
									{
										if (auto setter = propertyInfo->GetSetter())
										{
											writer.WriteString(L"\t\t\t\tCLASS_MEMBER_PROPERTY(");
											writer.WriteString(ConvertName(propertyInfo->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(getter->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(setter->GetName()));
											writer.WriteLine(L")");
										}
										else
										{
											writer.WriteString(L"\t\t\t\tCLASS_MEMBER_PROPERTY_READONLY(");
											writer.WriteString(ConvertName(propertyInfo->GetName()));
											writer.WriteString(L", ");
											writer.WriteString(ConvertName(getter->GetName()));
											writer.WriteLine(L")");
										}
									}
								}
								else
								{
									writer.WriteString(L"\t\t\t\tCLASS_MEMBER_FIELD(");
									writer.WriteString(ConvertName(propertyInfo->GetName()));
									writer.WriteLine(L")");
								}
							}

							if (td->GetTypeDescriptorFlags() == TypeDescriptorFlags::Interface)
							{
								writer.WriteString(L"\t\t\tEND_INTERFACE_MEMBER(");
							}
							else
							{
								writer.WriteString(L"\t\t\tEND_CLASS_MEMBER(");
							}
							writer.WriteString(ConvertType(td));
							writer.WriteLine(L")");
						}
						break;
					default:;
					}
					writer.WriteLine(L"");
				}
				writer.WriteLine(L"#undef _");

				writer.WriteString(L"\t\t\tclass ");
				writer.WriteString(assemblyName);
				writer.WriteLine(L"TypeLoader : public Object, public ITypeLoader");
				writer.WriteLine(L"\t\t\t{");
				writer.WriteLine(L"\t\t\tpublic:");
				writer.WriteLine(L"\t\t\t\tvoid Load(ITypeManager* manager)");
				writer.WriteLine(L"\t\t\t\t{");

				for (auto td : tds)
				{
					writer.WriteString(L"\t\t\t\t\tADD_TYPE_INFO(");
					writer.WriteString(ConvertType(td));
					writer.WriteLine(L")");
				}
				writer.WriteLine(L"\t\t\t\t}");
				writer.WriteLine(L"");
				writer.WriteLine(L"\t\t\t\tvoid Unload(ITypeManager* manager)");
				writer.WriteLine(L"\t\t\t\t{");
				writer.WriteLine(L"\t\t\t\t}");
				writer.WriteLine(L"\t\t\t};");

				writer.WriteLine(L"#endif");
				writer.WriteLine(L"#endif");
				writer.WriteLine(L"");

				writer.WriteString(L"\t\t\tbool Load");
				writer.WriteString(assemblyName);
				writer.WriteLine(L"Types()");
				writer.WriteLine(L"\t\t\t{");
				writer.WriteLine(L"#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA");
				writer.WriteLine(L"\t\t\t\tif (auto manager = GetGlobalTypeManager())");
				writer.WriteLine(L"\t\t\t\t{");
				writer.WriteString(L"\t\t\t\t\treturn manager->AddTypeLoader(Ptr(new ");
				writer.WriteString(assemblyName);
				writer.WriteLine(L"TypeLoader));");
				writer.WriteLine(L"\t\t\t\t}");
				writer.WriteLine(L"#endif");
				writer.WriteLine(L"\t\t\t\treturn false;");
				writer.WriteLine(L"\t\t\t}");

				writer.WriteLine(L"\t\t}");
				writer.WriteLine(L"\t}");
				writer.WriteLine(L"}");
			}
		}
	}
}

/***********************************************************************
.\CPP\WFCPP_WRITESTRUCT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;

			void WfCppConfig::WriteHeader_Struct(stream::StreamWriter& writer, Ptr<WfStructDeclaration> decl, const WString& name, const WString& prefix, bool mainHeaderDefinition)
			{
				if (mainHeaderDefinition)
				{
					auto td = manager->declarationTypes[decl.Obj()].Obj();
					writer.WriteLine(prefix + L"struct " + name);
					writer.WriteLine(prefix + L"{");
					for (auto member : decl->members)
					{
						auto prop = td->GetPropertyByName(member->name.value, false);
						auto defaultValue = DefaultValue(prop->GetReturn());
						if (defaultValue != L"")
						{
							defaultValue = L" = " + defaultValue;
						}
						writer.WriteLine(prefix + L"\t" + ConvertType(prop->GetReturn(), true) + L" " + ConvertName(member->name.value) + defaultValue + L";");
					}

					if (decl->members.Count() > 0)
					{
						writer.WriteLine(L"");
					}
					writer.WriteLine(prefix + L"\tauto operator<=>(const " + name + L"&) const = default;");
					writer.WriteLine(prefix + L"};");
				}
				else
				{
					auto td = manager->declarationTypes[decl.Obj()].Obj();
					writer.WriteString(prefix);
					writer.WriteString(L"using ");
					writer.WriteString(name);
					writer.WriteString(L" = ::");
					writer.WriteString(CppNameToHeaderEnumStructName(CppGetFullName(td), L"struct"));
					writer.WriteLine(L";");
				}
			}

			void WfCppConfig::WriteHeader_Struct(stream::StreamWriter& writer, Ptr<WfStructDeclaration> decl, collections::List<WString>& nss, bool mainHeaderDefinition)
			{
				auto td = manager->declarationTypes[decl.Obj()].Obj();
				if (mainHeaderDefinition)
				{
					WString name;
					auto prefix = WriteNamespace(writer, CppNameToHeaderEnumStructName(CppGetFullName(td), L"struct"), nss, name);
					WriteHeader_Struct(writer, decl, name, prefix, true);
				}
				else
				{
					WString name;
					auto prefix = WriteNamespace(writer, CppGetFullName(td), nss, name);
					writer.WriteString(prefix);
					writer.WriteString(L"using ");
					writer.WriteString(name);
					writer.WriteString(L" = ::");
					writer.WriteString(CppNameToHeaderEnumStructName(CppGetFullName(td), L"struct"));
					writer.WriteLine(L";");
				}
			}

			void WfCppConfig::WriteHeader_MainHeaderStructs(stream::StreamWriter& writer, collections::List<WString>& nss)
			{
				List<Ptr<WfStructDeclaration>> allStructs;
				CopyFrom(allStructs, Range<vint>(0, structDecls.Count()).SelectMany([&](vint index) {return From(structDecls.GetByIndex(index)); }));
				SortDeclsByName(allStructs);

				Group<Ptr<WfStructDeclaration>, Ptr<WfStructDeclaration>> depGroup;
				for (auto decl : allStructs)
				{
					auto td = manager->declarationTypes[decl.Obj()].Obj();
					vint count = td->GetPropertyCount();
					for (vint i = 0; i < count; i++)
					{
						auto propType = td->GetProperty(i)->GetReturn();
						if (propType->GetDecorator() == ITypeInfo::TypeDescriptor)
						{
							auto propTd = propType->GetTypeDescriptor();
							vint index = tdDecls.Keys().IndexOf(propTd);
							if (index != -1)
							{
								depGroup.Add(decl, tdDecls.Values()[index].Cast<WfStructDeclaration>());
							}
						}
					}
				}

				PartialOrderingProcessor pop;
				pop.InitWithGroup(allStructs, depGroup);
				pop.Sort();

				for (vint i = 0; i < pop.components.Count(); i++)
				{
					auto& component = pop.components[i];
					CHECK_ERROR(component.nodeCount == 1, L"WfCppConfig::WriteHeader_MainHeaderStructs(StreamWriter&, List<WString>&)#Internal error: Unexpected circle dependency found, which should be cought by the Workflow semantic analyzer.");
					auto decl = allStructs[component.firstNode[0]];
					WriteHeader_Struct(writer, decl, nss, true);
					writer.WriteLine(L"");
				}
			}
		}
	}
}

/***********************************************************************
.\CPP\WFMERGECPP.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			using namespace collections;
			using namespace stream;
			using namespace regex;

/***********************************************************************
MergeCpp
***********************************************************************/

			WString RemoveSpacePrefix(const WString& s)
			{
				for (vint i = 0; i < s.Length(); i++)
				{
					if (s[i] != L' '&&s[i] != L'\t')
					{
						return s.Sub(i, s.Length() - i);
					}
				}
				return WString::Empty;
			}

			const vint NORMAL = 0;
			const vint WAIT_HEADER = 1;
			const vint WAIT_OPEN = 2;
			const vint WAIT_CLOSE = 3;
			const vint USER_CONTENT = 4;
			const vint UNUSED_USER_CONTENT = 5;

			template<typename TCallback>
			void ProcessCppContent(const WString& code, const TCallback& callback)
			{
				Regex regexUserContentBegin(L"/.*?(?/{)?///* USER_CONTENT_BEGIN/((<name>[^)]*?)/) /*//");
				vint _name = regexUserContentBegin.CaptureNames().IndexOf(L"name");

				vint state = NORMAL;
				vint counter = 0;
				WString previousContent;

				StringReader reader(code);
				while (!reader.IsEnd())
				{
					auto line = reader.ReadLine();
					if (reader.IsEnd() && line == L"")
					{
						break;
					}

					if (line == L"// UNUSED_USER_CONTENT:")
					{
						state = UNUSED_USER_CONTENT;
					}

					if (state == UNUSED_USER_CONTENT)
					{
						callback(state, state, line, line);
					}
					else
					{
						auto content = RemoveSpacePrefix(line);
						auto previousState = state;
						switch (state)
						{
						case NORMAL:
							if (auto match = regexUserContentBegin.MatchHead(content))
							{
								content = L"USERIMPL(/* " + match->Groups()[_name][0].Value() + L" */)";
								if (match->Captures().Count() > 0)
								{
									content += previousContent;
								}
								state = USER_CONTENT;
							}
							else if (INVLOC.StartsWith(content, L"USERIMPL(",Locale::None))
							{
								state = WAIT_HEADER;
							}
							break;
						case WAIT_HEADER:
							state = WAIT_OPEN;
							break;
						case WAIT_OPEN:
							if (INVLOC.StartsWith(content, L"{", Locale::None))
							{
								state = WAIT_CLOSE;
							}
							break;
						case WAIT_CLOSE:
							if (INVLOC.StartsWith(content, L"{", Locale::None))
							{
								counter++;
							}
							else if (INVLOC.StartsWith(content, L"}", Locale::None))
							{
								if (counter == 0)
								{
									state = NORMAL;
								}
								else
								{
									counter--;
								}
							}
							break;
						case USER_CONTENT:
							if (INVLOC.EndsWith(content, L"/* USER_CONTENT_END() */", Locale::None))
							{
								state = NORMAL;
							}
							break;
						}
						callback(previousState, state, line, content);
					}
					previousContent = RemoveSpacePrefix(line);
				}
			}

			template<typename TCallback>
			void SplitCppContent(const WString& code, Dictionary<WString, WString>& userContents, Dictionary<WString, WString>& userContentsFull, const TCallback& callback)
			{
				WString name;
				WString userImpl;
				WString userImplFull;
				ProcessCppContent(code, [&](vint previousState, vint state, const WString& line, const WString& content)
				{
					if (state == UNUSED_USER_CONTENT)
					{
						callback(line);
					}
					else
					{
						switch (previousState)
						{
						case NORMAL:
							switch (state)
							{
							case WAIT_HEADER:
							case USER_CONTENT:
								name = content;
								userImpl = L"";
								userImplFull = L"";
								break;
							}
							break;
						case WAIT_HEADER:
							name += content;
							break;
						case WAIT_CLOSE:
						case USER_CONTENT:
							switch (state)
							{
							case WAIT_CLOSE:
							case USER_CONTENT:
								userImpl += line + L"\r\n";
								break;
							case NORMAL:
								userImplFull += L"//" + line + L"\r\n";
								userContents.Add(name, userImpl);
								userContentsFull.Add(name, userImplFull);
								name = L"";
								break;
							}
							break;
						}

						if (name != L"")
						{
							userImplFull += L"//" + line + L"\r\n";
						}
					}
				});
			}

			MergeCppMultiPlatformException::MergeCppMultiPlatformException(vint _row32, vint _column32, vint _row64, vint _column64)
				:Exception(L"The difference at "
					L"x86 file(row:" + itow(_row32 + 1) + L", column:" + itow(_column32 + 1) + L") and "
					L"x64 file(row:" + itow(_row64 + 1) + L", column:" + itow(_column64 + 1) + L") are not "
					L"\"vint32_t\" and \"vint64_t\", "
					L"\"vuint32_t\" and \"vuint64_t\", "
					L"\"<number>\" and \"<number>L\", "
					L"\"<number>\" and \"<number>UL\".")
				, row32(_row32)
				, column32(_column32)
				, row64(_row64)
				, column64(_column64)
			{
			}

			void CountRowAndColumn(const wchar_t* start, const wchar_t* reading, vint& row, vint& column)
			{
				row = 0;
				column = 0;
				while (start < reading)
				{
					if (*start++ == L'\n')
					{
						row++;
						column = 0;
					}
					else
					{
						column++;
					}
				}
			}


			WString MergeCppMultiPlatform(const WString& code32, const WString& code64)
			{
				static wchar_t stringCast32[] = L"static_cast<::vl::vint32_t>(";
				const vint lengthCast32 = sizeof(stringCast32) / sizeof(*stringCast32) - 1;

				static wchar_t stringCast64[] = L"static_cast<::vl::vint64_t>(";
				const vint lengthCast64 = sizeof(stringCast64) / sizeof(*stringCast64) - 1;

				return GenerateToStream([&](StreamWriter& writer)
				{
					const wchar_t* reading32 = code32.Buffer();
					const wchar_t* reading64 = code64.Buffer();
					const wchar_t* start32 = reading32;
					const wchar_t* start64 = reading64;
					while (true)
					{
						vint length = 0;
						while (reading32[length] && reading64[length])
						{
							if (reading32[length] == reading64[length])
							{
								length++;
							}
							else
							{
								break;
							}
						}

						writer.WriteString(reading32, length);
						reading32 += length;
						reading64 += length;

						if (*reading32 == 0 && *reading64 == 0)
						{
							break;
						}

#define IS_DIGIT(C) (L'0' <= C && C <= L'9')

						if (reading32[0] == L'3' && reading32[1] == L'2' && reading64[0] == L'6' && reading64[1] == L'4')
						{
							if (length >= 4)
							{
								if (wcsncmp(reading32 - 4, L"vint32_t", 8) == 0 && wcsncmp(reading64 - 4, L"vint64_t", 8) == 0)
								{
									reading32 += 4;
									reading64 += 4;
									goto NEXT_ROUND;
								}
							}
							if (length >= 5)
							{
								if (wcsncmp(reading32 - 5, L"vuint32_t", 9) == 0 && wcsncmp(reading64 - 5, L"vuint64_t", 9) == 0)
								{
									reading32 += 4;
									reading64 += 4;
									goto NEXT_ROUND;
								}
							}
						}
						else if (reading64[0] == L'L')
						{
							if (reading32[0] == reading64[1] && length >= 1)
							{
								if (IS_DIGIT(reading32[-1]) && !IS_DIGIT(reading32[0]))
								{
									if (IS_DIGIT(reading64[-1]) && !IS_DIGIT(reading64[1]))
									{
										reading64 += 1;
										goto NEXT_ROUND;
									}
								}
							}
						}
						else if (reading64[0] == L'U' && reading64[1] == L'L')
						{
							if (reading32[0] == reading64[2] && length >= 1)
							{
								if (IS_DIGIT(reading32[-1]) && !IS_DIGIT(reading32[0]))
								{
									if (IS_DIGIT(reading64[-1]) && !IS_DIGIT(reading64[2]))
									{
										reading64 += 2;
										goto NEXT_ROUND;
									}
								}
							}
						}
						else if (wcsncmp(reading32, stringCast32, lengthCast32) == 0 && IS_DIGIT(reading32[lengthCast32]) && IS_DIGIT(reading64[0]))
						{
							reading32 += lengthCast32;
							vint digitCount = 0;
							while (IS_DIGIT(reading32[digitCount])) digitCount++;
							if (wcsncmp(reading32, reading64, digitCount) == 0 && reading64[digitCount] == L'L' && reading32[digitCount] == L')')
							{
								writer.WriteString(L"static_cast<::vl::vint>(");
								writer.WriteString(WString::CopyFrom(reading32, digitCount));
								writer.WriteChar(L')');
								reading64 += digitCount + 1;
								reading32 += digitCount + 1;
								goto NEXT_ROUND;
							}
						}
						else if (wcsncmp(reading64, stringCast64, lengthCast64) == 0 && IS_DIGIT(reading64[lengthCast64]) && IS_DIGIT(reading32[0]))
						{
							reading64 += lengthCast64;
							vint digitCount = 0;
							while (IS_DIGIT(reading64[digitCount])) digitCount++;
							if (wcsncmp(reading64, reading32, digitCount) == 0 && reading64[digitCount] == L'L' && reading64[digitCount + 1] == L')')
							{
								writer.WriteString(L"static_cast<::vl::vint>(");
								writer.WriteString(WString::CopyFrom(reading64, digitCount));
								writer.WriteChar(L')');
								reading64 += digitCount + 2;
								reading32 += digitCount;
								goto NEXT_ROUND;
							}
						}

						{
							vint row32 = 0;
							vint column32 = 0;
							vint row64 = 0;
							vint column64 = 0;
							CountRowAndColumn(start32, reading32, row32, column32);
							CountRowAndColumn(start64, reading64, row64, column64);
							throw MergeCppMultiPlatformException(row32, column32, row64, column64);
						}
					NEXT_ROUND:;
#undef IS_DIGIT
					}
				});
			}

			WString MergeCppFileContent(const WString& dst, const WString& src)
			{
				Dictionary<WString, WString> userContents, userContentsFull;
				WString unusedUserContent = GenerateToStream([&](StreamWriter& writer)
				{
					SplitCppContent(dst, userContents, userContentsFull, [&](const WString& line)
					{
						writer.WriteLine(line);
					});
				});

				WString processedUnusedUserContent = GenerateToStream([&](StreamWriter& writer)
				{
					StringReader reader(unusedUserContent);
					while (!reader.IsEnd())
					{
						auto line = reader.ReadLine();
						if (line != L"// UNUSED_USER_CONTENT:")
						{
							if (INVLOC.StartsWith(line, L"//", Locale::None))
							{
								line = line.Right(line.Length() - 2);
							}
							writer.WriteLine(line);
						}
					}
				});

				SplitCppContent(processedUnusedUserContent, userContents, userContentsFull, [&](const WString& line) {});
				
				return GenerateToStream([&](StreamWriter& writer)
				{
					WString name;
					WString userImpl;
					ProcessCppContent(src, [&](vint previousState, vint state, const WString& line, const WString& content)
					{
						switch (previousState)
						{
						case NORMAL:
							switch (state)
							{
							case WAIT_HEADER:
							case USER_CONTENT:
								name = content;
								userImpl = L"";
								break;
							}
							break;
						case WAIT_HEADER:
							name += content;
							break;
						case WAIT_CLOSE:
						case USER_CONTENT:
							switch (state)
							{
							case WAIT_CLOSE:
							case USER_CONTENT:
								userImpl += line + L"\r\n";
								return;
							case NORMAL:
								{
									vint index = userContents.Keys().IndexOf(name);
									if (index == -1)
									{
										writer.WriteString(userImpl);
									}
									else
									{
										writer.WriteString(userContents.Values()[index]);
										userContentsFull.Remove(name);
									}
								}
								break;
							}
							break;
						}
						writer.WriteLine(line);
					});

					if (userContentsFull.Count() > 0)
					{
						writer.WriteLine(L"// UNUSED_USER_CONTENT:");
						for (auto content : userContentsFull.Values())
						{
							writer.WriteString(content);
						}
					}
				});
			}
		}
	}
}


/***********************************************************************
.\EMITTER\WFEMITTER.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace emitter
		{
			using namespace reflection::description;
			using namespace analyzer;
			using namespace runtime;

/***********************************************************************
WfAttributeEvaluator
***********************************************************************/

			WfAttributeEvaluator::WfAttributeEvaluator(analyzer::WfLexicalScopeManager* _manager)
				:manager(_manager)
			{
			}

			Ptr<WfAttribute> WfAttributeEvaluator::GetAttribute(collections::List<Ptr<WfAttribute>>& atts, const WString& category, const WString& name)
			{
				return From(GetAttributes(atts, category, name)).First(nullptr);
			}

			collections::LazyList<Ptr<WfAttribute>> WfAttributeEvaluator::GetAttributes(collections::List<Ptr<WfAttribute>>& atts, const WString& category, const WString& name)
			{
				return From(atts)
					.Where([=](Ptr<WfAttribute> att)
					{
						return att->category.value == category && att->name.value == name;
					});
			}

			runtime::WfRuntimeValue WfAttributeEvaluator::GetAttributeValue(Ptr<WfAttribute> att)
			{
				if (!att->value)
				{
					return {};
				}

				{
					vint index = attributeValues.Keys().IndexOf(att.Obj());
					if (index != -1)
					{
						return attributeValues.Values()[index];
					}
				}

				auto attributeAssembly = Ptr(new WfAssembly);
				WfCodegenContext context(attributeAssembly, manager);
				auto typeInfo = manager->attributes[{att->category.value, att->name.value}];
				GenerateExpressionInstructions(context, att->value, typeInfo);

				CHECK_ERROR(attributeAssembly->instructions.Count() == 1, L"WfAttributeEvaluator::GetAttributeValue(Ptr<WfAttribute>)#Internal error, attribute argument generates unexpected instructions.");
				auto& ins = attributeAssembly->instructions[0];
				CHECK_ERROR(ins.code == WfInsCode::LoadValue, L"WfAttributeEvaluator::GetAttributeValue(Ptr<WfAttribute>)#Internal error, attribute argument generates unexpected instructions.");
				attributeValues.Add(att, ins.valueParameter);
				return ins.valueParameter;
			}

/***********************************************************************
WfCodegenFunctionContext
***********************************************************************/

			WfCodegenFunctionContext::WfCodegenFunctionContext()
			{
				scopeContextStack.Add(Ptr(new WfCodegenScopeContext));
			}

			Ptr<WfCodegenScopeContext> WfCodegenFunctionContext::GetCurrentScopeContext()
			{
				return scopeContextStack[scopeContextStack.Count() - 1];
			}

			Ptr<WfCodegenScopeContext> WfCodegenFunctionContext::GetCurrentScopeContext(WfCodegenScopeType type, const WString& name)
			{
				for (vint i = scopeContextStack.Count() - 1; i >= 0; i--)
				{
					auto context = scopeContextStack[i];
					if (context->type == type)
					{
						if (name == L"" || context->name == name)
						{
							return context;
						}
					}
				}
				return 0;
			}

			Ptr<WfCodegenScopeContext> WfCodegenFunctionContext::PushScopeContext(WfCodegenScopeType type, const WString& name)
			{
				auto context = Ptr(new WfCodegenScopeContext);
				context->type = type;
				context->name = name;
				scopeContextStack.Add(context);
				return context;
			}

			void WfCodegenFunctionContext::PopScopeContext()
			{
				scopeContextStack.RemoveAt(scopeContextStack.Count() - 1);
			}

/***********************************************************************
WfCodegenContext
***********************************************************************/

			WfCodegenContext::WfCodegenContext(Ptr<runtime::WfAssembly> _assembly, analyzer::WfLexicalScopeManager* _manager)
				:assembly(_assembly)
				, manager(_manager)
			{
			}

			vint WfCodegenContext::AddInstruction(glr::ParsingAstBase* node, const runtime::WfInstruction& ins)
			{
				auto index = assembly->instructions.Add(ins);
				if (assembly->insBeforeCodegen && assembly->insAfterCodegen)
				{
					if (node)
					{
						assembly->insBeforeCodegen->instructionCodeMapping.Add(nodePositionsBeforeCodegen[node]);
						assembly->insAfterCodegen->instructionCodeMapping.Add(nodePositionsAfterCodegen[node]);
					}
					else
					{
						glr::ParsingTextRange range;
						assembly->insBeforeCodegen->instructionCodeMapping.Add(range);
						assembly->insAfterCodegen->instructionCodeMapping.Add(range);
					}
				}
				return index;
			}

			void WfCodegenContext::AddExitInstruction(glr::ParsingAstBase* node, const runtime::WfInstruction& ins)
			{
				auto context = functionContext->GetCurrentScopeContext();
				context->exitInstructions.Add(ins);
				context->instructionCodeMappingBeforeCodegen.Add(nodePositionsBeforeCodegen[node]);
				context->instructionCodeMappingAfterCodegen.Add(nodePositionsAfterCodegen[node]);
			}

			void WfCodegenContext::ApplyExitInstructions(Ptr<WfCodegenScopeContext> scopeContext)
			{
				if (scopeContext->exitInstructions.Count() > 0)
				{
					CopyFrom(assembly->instructions, scopeContext->exitInstructions, true);
					CopyFrom(assembly->insBeforeCodegen->instructionCodeMapping, scopeContext->instructionCodeMappingBeforeCodegen, true);
					CopyFrom(assembly->insAfterCodegen->instructionCodeMapping, scopeContext->instructionCodeMappingAfterCodegen, true);
				}
			}

			vint WfCodegenContext::GetThisStackCount(analyzer::WfLexicalScope* scope)
			{
				vint count = 0;
				Ptr<WfLexicalFunctionConfig> firstConfig, methodConfig;
				while (scope)
				{
					if (scope->typeOfThisExpr)
					{
						if (methodConfig)
						{
							count++;
							if (!methodConfig->parentThisAccessable)
							{
								break;
							}
							methodConfig = nullptr;
						}
					}

					if (scope->functionConfig)
					{
						if (!firstConfig)
						{
							vint index = thisStackCounts.Keys().IndexOf(scope->functionConfig.Obj());
							if (index == -1)
							{
								firstConfig = scope->functionConfig;
							}
							else
							{
								return thisStackCounts.Values()[index];
							}
						}
						if (scope->functionConfig->thisAccessable)
						{
							methodConfig = scope->functionConfig;
						}
					}
					scope = scope->parentScope.Obj();
				}

				if (firstConfig)
				{
					thisStackCounts.Add(firstConfig, count);
				}
				return count;
			}
		}
	}
}

/***********************************************************************
.\EMITTER\WFEMITTER_ASSEMBLY.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace emitter
		{
			using namespace glr;
			using namespace reflection::description;
			using namespace analyzer;
			using namespace runtime;
			using namespace typeimpl;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)
#define FILL_LABEL_TO_INS(LABEL, INS) context.assembly->instructions[LABEL].indexParameter = INS
#define FILL_LABEL_TO_CURRENT(LABEL) FILL_LABEL_TO_INS(LABEL, context.assembly->instructions.Count())

/***********************************************************************
GenerateTypeCastInstructions
***********************************************************************/

			void GenerateTypeCastInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, bool strongCast, WfExpression* node)
			{
				if (expectedType->GetTypeDescriptor() != GetTypeDescriptor<Value>())
				{
					vint fillElseIndex = -1;
					vint fillEndIndex = -1;

					if (expectedType->GetDecorator() == ITypeInfo::Nullable)
					{
						INSTRUCTION(Ins::Duplicate(0));
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::CompareReference());
						fillElseIndex = INSTRUCTION(Ins::JumpIf(-1));
					}

					if (strongCast)
					{
						switch (expectedType->GetDecorator())
						{
						case ITypeInfo::RawPtr:
							INSTRUCTION(Ins::ConvertToType(Value::RawPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::SharedPtr:
							INSTRUCTION(Ins::ConvertToType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::Nullable:
						case ITypeInfo::TypeDescriptor:
						case ITypeInfo::Generic:
							INSTRUCTION(Ins::ConvertToType(Value::BoxedValue, expectedType->GetTypeDescriptor()));
							break;
						}
					}
					else
					{
						switch (expectedType->GetDecorator())
						{
						case ITypeInfo::RawPtr:
							INSTRUCTION(Ins::TryConvertToType(Value::RawPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::SharedPtr:
							INSTRUCTION(Ins::TryConvertToType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
							break;
						case ITypeInfo::Nullable:
						case ITypeInfo::TypeDescriptor:
						case ITypeInfo::Generic:
							INSTRUCTION(Ins::TryConvertToType(Value::BoxedValue, expectedType->GetTypeDescriptor()));
							break;
						}
					}

					if (fillElseIndex != -1)
					{
						fillEndIndex = INSTRUCTION(Ins::Jump(-1));
						FILL_LABEL_TO_CURRENT(fillElseIndex);
						INSTRUCTION(Ins::LoadValue({}));
						FILL_LABEL_TO_CURRENT(fillEndIndex);
					}
				}
			}

/***********************************************************************
GetInstructionTypeArgument
***********************************************************************/

			void GenerateTypeTestingInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, WfExpression* node)
			{
				if (expectedType->GetTypeDescriptor() != GetTypeDescriptor<Value>())
				{
					switch (expectedType->GetDecorator())
					{
					case ITypeInfo::RawPtr:
						INSTRUCTION(Ins::TestType(Value::RawPtr, expectedType->GetTypeDescriptor()));
						break;
					case ITypeInfo::SharedPtr:
						INSTRUCTION(Ins::TestType(Value::SharedPtr, expectedType->GetTypeDescriptor()));
						break;
					case ITypeInfo::Nullable:
					case ITypeInfo::TypeDescriptor:
					case ITypeInfo::Generic:
						INSTRUCTION(Ins::TestType(Value::BoxedValue, expectedType->GetTypeDescriptor()));
						break;
					}
				}
				else
				{
					INSTRUCTION(Ins::Pop());
					INSTRUCTION(Ins::LoadValue({ true }));
				}
			}

/***********************************************************************
GetInstructionTypeArgument
***********************************************************************/

			runtime::WfInsType GetInstructionTypeArgument(Ptr<reflection::description::ITypeInfo> expectedType)
			{
				auto td = expectedType->GetTypeDescriptor();
				if (td == GetTypeDescriptor<bool>()) return WfInsType::Bool;
				if (td == GetTypeDescriptor<vint8_t>()) return WfInsType::I1;
				if (td == GetTypeDescriptor<vint16_t>()) return WfInsType::I2;
				if (td == GetTypeDescriptor<vint32_t>()) return WfInsType::I4;
				if (td == GetTypeDescriptor<vint64_t>()) return WfInsType::I8;
				if (td == GetTypeDescriptor<vuint8_t>()) return WfInsType::U1;
				if (td == GetTypeDescriptor<vuint16_t>()) return WfInsType::U2;
				if (td == GetTypeDescriptor<vuint32_t>()) return WfInsType::U4;
				if (td == GetTypeDescriptor<vuint64_t>()) return WfInsType::U8;
				if (td == GetTypeDescriptor<float>()) return WfInsType::F4;
				if (td == GetTypeDescriptor<double>()) return WfInsType::F8;
				if (td == GetTypeDescriptor<WString>()) return WfInsType::String;
				return WfInsType::Unknown;
			}

/***********************************************************************
GenerateAssembly
***********************************************************************/

#define EXECUTE_CALLBACK(EXPR) if (callback) callback->EXPR

			Ptr<runtime::WfAssembly> GenerateAssembly(analyzer::WfLexicalScopeManager* manager, IWfCompilerCallback* callback)
			{
				EXECUTE_CALLBACK(OnGenerateMetadata());
				auto assembly = Ptr(new WfAssembly);
				assembly->insBeforeCodegen = Ptr(new WfInstructionDebugInfo);
				assembly->insAfterCodegen = Ptr(new WfInstructionDebugInfo);
				
				WfCodegenContext context(assembly, manager);
				for (auto [module, index] : indexed(manager->GetModules()))
				{
					auto codeBeforeCodegen = manager->GetModuleCodes()[index];

					auto recorderBefore = Ptr(new ParsingGeneratedLocationRecorder(context.nodePositionsBeforeCodegen));
					auto recorderAfter = Ptr(new ParsingGeneratedLocationRecorder(context.nodePositionsAfterCodegen));
					auto recorderOriginal = Ptr(new ParsingOriginalLocationRecorder(recorderBefore));
					auto recorderMultiple = Ptr(new ParsingMultiplePrintNodeRecorder);
					recorderMultiple->AddRecorder(recorderOriginal);
					recorderMultiple->AddRecorder(recorderAfter);

					stream::MemoryStream memoryStream;
					{
						stream::StreamWriter streamWriter(memoryStream);
						ParsingWriter parsingWriter(streamWriter, recorderMultiple, index);
						WfPrint(module, L"", parsingWriter);
					}

					memoryStream.SeekFromBegin(0);
					auto codeAfterCodegen = stream::StreamReader(memoryStream).ReadToEnd();

					assembly->insBeforeCodegen->moduleCodes.Add(codeBeforeCodegen);
					assembly->insAfterCodegen->moduleCodes.Add(codeAfterCodegen);
				}

				if (manager->declarationTypes.Count() > 0)
				{
					assembly->typeImpl = Ptr(new WfTypeImpl);
					for (auto td : manager->declarationTypes.Values())
					{
						if (auto tdClass = td.Cast<WfClass>())
						{
							assembly->typeImpl->classes.Add(tdClass);
						}
						else if (auto tdInterface = td.Cast<WfInterface>())
						{
							assembly->typeImpl->interfaces.Add(tdInterface);
						}
						else if (auto tdStruct = td.Cast<WfStruct>())
						{
							assembly->typeImpl->structs.Add(tdStruct);
						}
						else if (auto tdEnum = td.Cast<WfEnum>())
						{
							assembly->typeImpl->enums.Add(tdEnum);
						}
					}
				}

				for (auto module : manager->GetModules())
				{
					for (auto decl : module->declarations)
					{
						GenerateGlobalDeclarationMetadata(context, decl.Obj());
					}
				}

				{
					auto meta = Ptr(new WfAssemblyFunction);
					meta->name = L"<initialize>";
					vint functionIndex = assembly->functions.Add(meta);
					assembly->functionByName.Add(meta->name, functionIndex);

					auto functionContext = Ptr(new WfCodegenFunctionContext);
					functionContext->function = meta;
					context.functionContext = functionContext;
					
					meta->firstInstruction = assembly->instructions.Count();
					for (auto module : manager->GetModules())
					{
						for (auto decl : module->declarations)
						{
							GenerateInitializeInstructions(context, decl);
						}
					}

					// define node for INSTRUCTION
					glr::ParsingAstBase* node = nullptr;
					INSTRUCTION(Ins::LoadValue({}));
					INSTRUCTION(Ins::Return());

					meta->lastInstruction = assembly->instructions.Count() - 1;

					context.functionContext = 0;
					GenerateClosureInstructions(context, functionContext);
				}

				for (auto module : manager->GetModules())
				{
					EXECUTE_CALLBACK(OnGenerateCode(module));
					for (auto decl : module->declarations)
					{
						GenerateDeclarationInstructions(context, decl.Obj());
					}
				}

				EXECUTE_CALLBACK(OnGenerateDebugInfo());
				assembly->Initialize();
				return assembly;
			}

#undef EXECUTE_CALLBACK
#undef FILL_LABEL_TO_CURRENT
#undef FILL_LABEL_TO_INS
#undef INSTRUCTION

/***********************************************************************
Compile
***********************************************************************/

			Ptr<runtime::WfAssembly> Compile(analyzer::WfLexicalScopeManager* manager, collections::List<WString>& moduleCodes, collections::List<glr::ParsingError>& errors)
			{
				manager->Clear(true, true);
				for (auto code : moduleCodes)
				{
					manager->AddModule(code);
				}

				if (manager->errors.Count() > 0)
				{
					CopyFrom(errors, manager->errors);
					return 0;
				}

				manager->Rebuild(true);
				if (manager->errors.Count() > 0)
				{
					CopyFrom(errors, manager->errors);
					return 0;
				}

				return GenerateAssembly(manager);
			}

			Ptr<runtime::WfAssembly> Compile(workflow::Parser& workflowParser, analyzer::WfCpuArchitecture cpuArchitecture, collections::List<WString>& moduleCodes, collections::List<glr::ParsingError>& errors)
			{
				WfLexicalScopeManager manager(workflowParser, cpuArchitecture);
				return Compile(&manager, moduleCodes, errors);
			}
		}
	}
}

/***********************************************************************
.\EMITTER\WFEMITTER_DECLARATION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace emitter
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace analyzer;
			using namespace runtime;
			using namespace typeimpl;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)

/***********************************************************************
GenerateInstructions(Initialize)
***********************************************************************/

			class GenerateInitializeInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateInitializeInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					for (auto decl : node->declarations)
					{
						GenerateInitializeInstructions(context, decl);
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
				}

				void Visit(WfVariableDeclaration* node)override
				{
					auto scope = context.manager->nodeScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					vint variableIndex = context.globalVariables[symbol.Obj()];
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::StoreGlobalVar(variableIndex));
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
					GenerateStatementInstructions(context, node->statement);
				}

				void Visit(WfConstructorDeclaration* node)override
				{
				}

				void Visit(WfDestructorDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
				}

				void Visit(WfEnumDeclaration* node)override
				{
				}

				void Visit(WfStructDeclaration* node)override
				{
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			void GenerateInitializeInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration)
			{
				GenerateInitializeInstructionsVisitor visitor(context);
				declaration->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Declaration)
***********************************************************************/

			Ptr<WfCodegenFunctionContext> GenerateFunctionInstructions_Prolog(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, glr::ParsingAstBase* node)
			{
				auto functionContext = Ptr(new WfCodegenFunctionContext);
				functionContext->function = meta;
				context.functionContext = functionContext;
				{
					for (auto [argumentSymbol, index] : indexed(argumentSymbols))
					{
						functionContext->arguments.Add(argumentSymbol.Obj(), index);
					}
					for (auto [capturedSymbol, index] : indexed(capturedSymbols))
					{
						functionContext->capturedVariables.Add(capturedSymbol.Obj(), index);
					}
				}
				if (recursiveLambdaSymbol)
				{
					vint variableIndex = meta->argumentNames.Count() + meta->localVariableNames.Add(L"<recursive-lambda>" + recursiveLambdaSymbol->name);
					functionContext->localVariables.Add(recursiveLambdaSymbol.Obj(), variableIndex);
				}
					
				meta->firstInstruction = context.assembly->instructions.Count();
				if (recursiveLambdaSymbol)
				{
					INSTRUCTION(Ins::LoadClosureContext());
					INSTRUCTION(Ins::LoadFunction(context.assembly->functions.IndexOf(meta.Obj())));
					INSTRUCTION(Ins::CreateClosure());
					INSTRUCTION(Ins::StoreLocalVar(functionContext->localVariables[recursiveLambdaSymbol.Obj()]));
				}
				return functionContext;
			}

			void GenerateFunctionInstructions_Epilog(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, Ptr<WfCodegenFunctionContext> functionContext, glr::ParsingAstBase* node)
			{
				INSTRUCTION(Ins::LoadValue({}));
				INSTRUCTION(Ins::Return());
				meta->lastInstruction = context.assembly->instructions.Count() - 1;
				context.functionContext = 0;

				GenerateClosureInstructions(context, functionContext);
			}

			void GenerateFunctionInstructions(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, Ptr<WfStatement> statementBody, glr::ParsingAstBase* node)
			{
				auto functionContext = GenerateFunctionInstructions_Prolog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, node);
				GenerateStatementInstructions(context, statementBody);
				GenerateFunctionInstructions_Epilog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, functionContext, node);
			}

			void GenerateFunctionInstructions(WfCodegenContext& context, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<ITypeInfo> returnType, Ptr<WfLexicalSymbol> recursiveLambdaSymbol, const List<Ptr<WfLexicalSymbol>>& argumentSymbols, const List<Ptr<WfLexicalSymbol>>& capturedSymbols, Ptr<WfExpression> expressionBody, glr::ParsingAstBase* node)
			{
				auto functionContext = GenerateFunctionInstructions_Prolog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, node);
				GenerateExpressionInstructions(context, expressionBody);
				INSTRUCTION(Ins::Return());
				GenerateFunctionInstructions_Epilog(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, functionContext, node);
			}

			void GenerateFunctionDeclarationInstructions(WfCodegenContext& context, WfFunctionDeclaration* node, WfLexicalScope* scope, Ptr<WfAssemblyFunction> meta, Ptr<WfLexicalSymbol> recursiveLambdaSymbol)
			{
				List<Ptr<WfLexicalSymbol>> argumentSymbols, capturedSymbols;
				{
					for (auto argument : node->arguments)
					{
						auto symbol = scope->symbols[argument->name.value][0];
						argumentSymbols.Add(symbol);
					}

					vint index = context.manager->lambdaCaptures.Keys().IndexOf(node);
					if (index != -1)
					{
						auto capture = context.manager->lambdaCaptures.Values()[index];
						for (auto symbol : capture->symbols)
						{
							capturedSymbols.Add(symbol);
						}
					}
				}

				auto returnType = CreateTypeInfoFromType(scope, node->returnType);
				GenerateFunctionInstructions(context, scope, meta, returnType, recursiveLambdaSymbol, argumentSymbols, capturedSymbols, node->statement, node);
			}

			class GenerateClassMemberInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;
				WfClassDeclaration*						classDecl;

				GenerateClassMemberInstructionsVisitor(WfCodegenContext& _context, WfClassDeclaration* _classDecl)
					:context(_context)
					, classDecl(_classDecl)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (node->functionKind == WfFunctionKind::Static)
					{
						GenerateDeclarationInstructions(context, node);
					}
					else if (classDecl->kind == WfClassKind::Class)
					{
						GenerateDeclarationInstructions(context, node);
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				class InitializeFieldVisitor
					: public empty_visitor::DeclarationVisitor
				{
				public:
					WfCodegenContext&					context;

					InitializeFieldVisitor(WfCodegenContext& _context)
						:context(_context)
					{
					}

					void Dispatch(WfVirtualCfeDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							decl->Accept(this);
						}
					}

					void Dispatch(WfVirtualCseDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							decl->Accept(this);
						}
					}

					void Visit(WfVariableDeclaration* node)override
					{
						auto info = context.manager->declarationMemberInfos[node].Cast<WfField>().Obj();
						GenerateExpressionInstructions(context, node->expression);
						INSTRUCTION(Ins::LoadCapturedVar(0));
						INSTRUCTION(Ins::SetProperty(info));
					}
				};

				void Visit(WfConstructorDeclaration* node)override
				{
					auto meta = context.assembly->functions[context.constructors[node]];
					auto functionContext = Ptr(new WfCodegenFunctionContext);
					functionContext->function = meta;
					context.functionContext = functionContext;
					meta->firstInstruction = context.assembly->instructions.Count();
					
					auto scope = context.manager->nodeScopes[node].Obj();
					{
						for (auto [argument, index] : indexed(node->arguments))
						{
							auto symbol = scope->symbols[argument->name.value][0];
							functionContext->arguments.Add(symbol.Obj(), index);
						}
					}

					if (classDecl->baseTypes.Count() > 0)
					{
						auto td = scope->parentScope->typeOfThisExpr;
						vint count = td->GetBaseTypeDescriptorCount();
						for (vint i = 0; i < count; i++)
						{
							auto baseTd = td->GetBaseTypeDescriptor(i);
							auto ctor = context.manager->baseConstructorCallResolvings[{node, baseTd}];
							if (ctor.key)
							{
								for (auto argument : ctor.key->arguments)
								{
									GenerateExpressionInstructions(context, argument);
								}
								INSTRUCTION(Ins::LoadCapturedVar(0));
								INSTRUCTION(Ins::InvokeBaseCtor(ctor.value, ctor.key->arguments.Count()));
							}
							else
							{
								INSTRUCTION(Ins::LoadCapturedVar(0));
								INSTRUCTION(Ins::InvokeBaseCtor(ctor.value, 0));
							}
							INSTRUCTION(Ins::Pop());
						}
					}

					{
						InitializeFieldVisitor visitor(context);
						for (auto memberDecl : classDecl->declarations)
						{
							memberDecl->Accept(&visitor);
						}
					}
					GenerateStatementInstructions(context, node->statement);

					INSTRUCTION(Ins::LoadValue({}));
					INSTRUCTION(Ins::Return());
					meta->lastInstruction = context.assembly->instructions.Count() - 1;
					context.functionContext = 0;
					GenerateClosureInstructions(context, functionContext);
				}
				
				void Visit(WfDestructorDeclaration* node)override
				{
					auto meta = context.assembly->functions[context.destructors[node]];
					auto functionContext = Ptr(new WfCodegenFunctionContext);
					functionContext->function = meta;
					context.functionContext = functionContext;
					meta->firstInstruction = context.assembly->instructions.Count();
					
					auto scope = context.manager->nodeScopes[node].Obj();
					GenerateStatementInstructions(context, node->statement);

					INSTRUCTION(Ins::LoadValue({}));
					INSTRUCTION(Ins::Return());
					meta->lastInstruction = context.assembly->instructions.Count() - 1;
					context.functionContext = 0;
					GenerateClosureInstructions(context, functionContext);
				}

				void Visit(WfClassDeclaration* node)override
				{
					GenerateDeclarationInstructions(context, node);
				}

				void Visit(WfEnumDeclaration* node)override
				{
				}

				void Visit(WfStructDeclaration* node)override
				{
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			class GenerateDeclarationInstructionsVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateDeclarationInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					for (auto decl : node->declarations)
					{
						GenerateDeclarationInstructions(context, decl.Obj());
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto scope = context.manager->nodeScopes[node].Obj();
					auto symbol = context.manager->GetDeclarationSymbol(scope, node);
					auto meta = context.assembly->functions[context.globalFunctions[symbol.Obj()]];
					GenerateFunctionDeclarationInstructions(context, node, scope, meta, 0);
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
				}

				void Visit(WfDestructorDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					for (auto memberDecl : node->declarations)
					{
						GenerateClassMemberInstructionsVisitor visitor(context, node);
						memberDecl->Accept(&visitor);
					}
				}

				void Visit(WfEnumDeclaration* node)override
				{
				}

				void Visit(WfStructDeclaration* node)override
				{
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			void GenerateDeclarationInstructions(WfCodegenContext& context, WfDeclaration* declaration)
			{
				GenerateDeclarationInstructionsVisitor visitor(context);
				declaration->Accept(&visitor);
			}

/***********************************************************************
GenerateInstructions(Closure)
***********************************************************************/

			void GenerateClosureInstructions_Function(WfCodegenContext& context, vint functionIndex, WfFunctionDeclaration* node, bool createInterface)
			{
				auto scope = context.manager->nodeScopes[node].Obj();
				auto meta = context.assembly->functions[functionIndex];
				GenerateFunctionDeclarationMetadata(context, node, meta);
				Ptr<WfLexicalSymbol> recursiveLambdaSymbol;
				if (!createInterface && node->name.value != L"")
				{
					recursiveLambdaSymbol = scope->symbols[node->name.value][0];
				}
				GenerateFunctionDeclarationInstructions(context, node, scope, meta, recursiveLambdaSymbol);
			}

			void GenerateClosureInstructions_Ordered(WfCodegenContext& context, vint functionIndex, WfOrderedLambdaExpression* node)
			{
				auto scope = context.manager->nodeScopes[node].Obj();
				List<Ptr<WfLexicalSymbol>> argumentSymbols, capturedSymbols;
				CopyFrom(
					argumentSymbols,
					Range<vint>(0, scope->symbols.Count())
						.Select([scope](vint index)->Ptr<WfLexicalSymbol>{return scope->symbols.GetByIndex(index)[0];})
						.OrderBy([](Ptr<WfLexicalSymbol> a, Ptr<WfLexicalSymbol> b)
						{
							vint aId = wtoi(a->name.Sub(1, a->name.Length() - 1));
							vint bId = wtoi(b->name.Sub(1, a->name.Length() - 1));
							return aId <=> bId;
						})
					);

				auto meta = context.assembly->functions[functionIndex];
				for (auto symbol : argumentSymbols)
				{
					meta->argumentNames.Add(symbol->name);
				}
				{
					auto capture = context.manager->lambdaCaptures.Get(node);
					for (auto symbol : capture->symbols)
					{
						meta->capturedVariableNames.Add(L"<captured>" + symbol->name);
						capturedSymbols.Add(symbol);
					}

					vint count = context.GetThisStackCount(scope);
					for (vint i = 0; i < count; i++)
					{
						meta->capturedVariableNames.Add(L"<captured-this>" + itow(i));
					}
				}

				auto result = context.manager->expressionResolvings[node];
				auto returnType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
				GenerateFunctionInstructions(context, scope, meta, returnType, 0, argumentSymbols, capturedSymbols, node->body, node);
			}

			void GenerateClosureInstructions(WfCodegenContext& context, Ptr<WfCodegenFunctionContext> functionContext)
			{
				for (vint i = 0; i < functionContext->closuresToCodegen.Count(); i++)
				{
					vint functionIndex = functionContext->closuresToCodegen.Keys()[i];
					auto closure = functionContext->closuresToCodegen.Values()[i];
					
					if (closure.functionExpression)
					{
						GenerateClosureInstructions_Function(context, functionIndex, closure.functionExpression->function.Obj(), false);
					}
					else if (closure.orderedLambdaExpression)
					{
						GenerateClosureInstructions_Ordered(context, functionIndex, closure.orderedLambdaExpression);
					}
					else if (closure.functionDeclaration)
					{
						GenerateClosureInstructions_Function(context, functionIndex, closure.functionDeclaration, true);
					}
				}
			}

#undef INSTRUCTION
		}
	}
}

/***********************************************************************
.\EMITTER\WFEMITTER_EXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace emitter
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace analyzer;
			using namespace runtime;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)
#define FILL_LABEL_TO_INS(LABEL, INS) context.assembly->instructions[LABEL].indexParameter = INS
#define FILL_LABEL_TO_CURRENT(LABEL) FILL_LABEL_TO_INS(LABEL, context.assembly->instructions.Count())

/***********************************************************************
GenerateInstructions(Expression)
***********************************************************************/

			class GenerateExpressionInstructionsVisitor
				: public Object
				, public WfExpression::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateExpressionInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				static void GenerateLoadSymbolInstructions(WfCodegenContext& context, WfLexicalSymbol* symbol, glr::ParsingAstBase* node)
				{
					vint index = -1;
					if ((index = context.globalFunctions.Keys().IndexOf(symbol)) != -1)
					{
						vint functionIndex = context.globalFunctions.Values()[index];
						INSTRUCTION(Ins::CreateClosureContext(0));
						INSTRUCTION(Ins::LoadFunction(functionIndex));
						INSTRUCTION(Ins::CreateClosure());
					}
					else if ((index = context.globalVariables.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.globalVariables.Values()[index];
						INSTRUCTION(Ins::LoadGlobalVar(variableIndex));
					}
					else if ((index = context.functionContext->capturedVariables.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.functionContext->capturedVariables.Values()[index];
						INSTRUCTION(Ins::LoadCapturedVar(variableIndex));
					}
					else if ((index = context.functionContext->localVariables.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.functionContext->localVariables.Values()[index];
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
					}
					else if ((index = context.functionContext->arguments.Keys().IndexOf(symbol)) != -1)
					{
						vint variableIndex = context.functionContext->arguments.Values()[index];
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
					}
					else if ((index = context.closureFunctions.Keys().IndexOf(symbol)) != -1)
					{
						vint functionIndex = context.closureFunctions.Values()[index];
						INSTRUCTION(Ins::LoadClosureContext());
						INSTRUCTION(Ins::LoadFunction(functionIndex));
						INSTRUCTION(Ins::CreateClosure());
					}
					else
					{
						CHECK_FAIL(L"GenerateExpressionInstructionsVisitor::GenerateLoadSymbolInstructions(WfCodegenContext&, WfLexicalSymbol*, ParsingTreeCustomBase*)#Internal error, cannot find any record of this symbol.");
					}
				}

				static vint PushCapturedThisValues(WfCodegenContext& context, WfLexicalScope* lambdaScopeParent, glr::ParsingAstBase* node)
				{
					auto scope = lambdaScopeParent;
					while (scope)
					{
						if (scope->functionConfig)
						{
							vint parentThisCount = context.GetThisStackCount(scope);
							if (scope->functionConfig->lambda)
							{
								auto capture = context.manager->lambdaCaptures[scope->ownerNode.Obj()];
								vint captureCount = capture->symbols.Count();
								for (vint i = 0; i < parentThisCount; i++)
								{
									INSTRUCTION(Ins::LoadCapturedVar(captureCount + i));
								}
							}
							else if (parentThisCount > 0)
							{
								CHECK_ERROR(parentThisCount == 1, L"GenerateExpressionInstructionsVisitor::PushCapturedThisValues(WfCodegenContext&, WfLexicalScope*, ParsingTreeCustomBase*)#Internal error, wrong parentThisCount value.");
								INSTRUCTION(Ins::LoadCapturedVar(0));
							}
							return parentThisCount;
						}
						scope = scope->parentScope.Obj();
					}
					return 0;
				}

				static vint AddClosure(WfCodegenContext& context, WfCodegenLambdaContext lc, const Func<WString(vint)>& getName)
				{
					auto meta = Ptr(new WfAssemblyFunction);
					vint functionIndex = context.assembly->functions.Add(meta);
					meta->name = getName(functionIndex);
					context.assembly->functionByName.Add(meta->name, functionIndex);
					context.functionContext->closuresToCodegen.Add(functionIndex, lc);
					return functionIndex;
				}

				void VisitReferenceExpression(WfExpression* node, const WString& name)
				{
					auto result = context.manager->expressionResolvings[node];
					if (result.symbol)
					{
						GenerateLoadSymbolInstructions(context, result.symbol.Obj(), node);
					}
					else if (result.methodInfo)
					{
						if (result.methodInfo->IsStatic())
						{
							INSTRUCTION(Ins::LoadValue({}));
						}
						else
						{
							VisitThisExpression(node, result.methodInfo->GetOwnerTypeDescriptor());
						}
						INSTRUCTION(Ins::LoadMethodClosure(result.methodInfo));
					}
					else if (result.propertyInfo)
					{
						if (auto getter = result.propertyInfo->GetGetter())
						{
							VisitThisExpression(node, getter->GetOwnerTypeDescriptor());
							INSTRUCTION(Ins::InvokeMethod(getter, 0));
						}
						else
						{
							VisitThisExpression(node, result.propertyInfo->GetOwnerTypeDescriptor());
							INSTRUCTION(Ins::GetProperty(result.propertyInfo));
						}
					}
					else
					{
						if ((result.type->GetTypeDescriptor()->GetTypeDescriptorFlags() & TypeDescriptorFlags::EnumType) != TypeDescriptorFlags::Undefined)
						{
							auto td = result.type->GetTypeDescriptor();
							auto enumType = td->GetEnumType();
							vint index = enumType->IndexOfItem(name);
							if (index != -1)
							{
								auto intValue = enumType->GetItemValue(index);
								INSTRUCTION(Ins::LoadValue({ intValue, td }));
								return;
							}
						}
						CHECK_FAIL(L"GenerateExpressionInstructionsVisitor::VisitReferenceExpression(WfExpression*, const WString&)#Internal error, cannot find any record of this expression.");
					}
				}

				void VisitThisExpression(WfExpression* node, ITypeDescriptor* td)
				{
					auto scope = context.manager->nodeScopes[node].Obj();
					vint count = context.GetThisStackCount(scope);
					vint offset = 0;

					Ptr<WfLexicalCapture> capture;
					Ptr<WfLexicalFunctionConfig> lastConfig;
					while (scope)
					{
						if (scope->typeOfThisExpr)
						{
							if (scope->typeOfThisExpr->CanConvertTo(td))
							{
								if (capture)
								{
									INSTRUCTION(Ins::LoadCapturedVar(capture->symbols.Count() + count - offset - 1));
								}
								else
								{
									INSTRUCTION(Ins::LoadCapturedVar(0));
								}
								return;
							}
							else
							{
								offset++;
							}

							if (lastConfig)
							{
								if (!lastConfig->parentThisAccessable)
								{
									break;
								}
							}
						}

						if (scope->functionConfig)
						{
							lastConfig = scope->functionConfig;
							if (!capture)
							{
								vint index = context.manager->lambdaCaptures.Keys().IndexOf(scope->ownerNode.Obj());
								if (index != -1)
								{
									capture = context.manager->lambdaCaptures.Values()[index];
								}
							}
						}

						scope = scope->parentScope.Obj();
					}
					CHECK_FAIL(L"GenerateExpressionInstructionsVisitor::VisitThisExpression(WfExpression*, ITypeDescriptor*)#Internal error, cannot find any record of the this value.");
				}

				void Visit(WfThisExpression* node)override
				{
					auto scope = context.manager->nodeScopes[node].Obj();
					while (scope)
					{
						if (scope->functionConfig)
						{
							if (scope->functionConfig->thisAccessable)
							{
								if (scope->functionConfig->lambda)
								{
									auto capture = context.manager->lambdaCaptures[scope->ownerNode.Obj()];
									auto count = context.GetThisStackCount(scope);
									INSTRUCTION(Ins::LoadCapturedVar(capture->symbols.Count() + count - 1));
								}
								else
								{
									INSTRUCTION(Ins::LoadCapturedVar(0));
								}
								return;
							}
							CHECK_FAIL(L"GenerateExpressionInstructionsVisitor::Visit(WfThisExpression*)#Internal error, this expression is illegal here.");
						}
						scope = scope->parentScope.Obj();
					}
					CHECK_FAIL(L"GenerateExpressionInstructionsVisitor::Visit(WfThisExpression*)#Internal error, this expression is illegal here.");
				}

				void Visit(WfTopQualifiedExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfReferenceExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfOrderedNameExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfOrderedLambdaExpression* node)override
				{
					auto scope = context.manager->nodeScopes[node].Obj();

					WfCodegenLambdaContext lc;
					lc.orderedLambdaExpression = node;
					auto functionIndex = AddClosure(context, lc, [=, this](vint index)
					{
						return L"<lambda:(" + itow(index) + L")> in " + context.functionContext->function->name;
					});

					auto capture = context.manager->lambdaCaptures.Get(node);
					for (auto symbol : capture->symbols)
					{
						GenerateLoadSymbolInstructions(context, symbol.Obj(), node);
					}
					vint thisCount = PushCapturedThisValues(context, scope->parentScope.Obj(), node);
					INSTRUCTION(Ins::CreateClosureContext(capture->symbols.Count() + thisCount));
					INSTRUCTION(Ins::LoadFunction(functionIndex));
					INSTRUCTION(Ins::CreateClosure());
				}

				void Visit(WfMemberExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					if (result.propertyInfo)
					{
						GenerateExpressionInstructions(context, node->parent);
						if (result.propertyInfo->GetGetter())
						{
							INSTRUCTION(Ins::InvokeMethod(result.propertyInfo->GetGetter(), 0));
						}
						else
						{
							INSTRUCTION(Ins::GetProperty(result.propertyInfo));
						}
					}
					else
					{
						GenerateExpressionInstructions(context, node->parent);
						INSTRUCTION(Ins::LoadMethodClosure(result.methodInfo));
					}
				}

				void Visit(WfChildExpression* node)override
				{
					VisitReferenceExpression(node, node->name.value);
				}

				void Visit(WfLiteralExpression* node)override
				{
					switch (node->value)
					{
					case WfLiteralValue::Null:
						INSTRUCTION(Ins::LoadValue({}));
						break;
					case WfLiteralValue::True:
						INSTRUCTION(Ins::LoadValue({ true }));
						break;
					case WfLiteralValue::False:
						INSTRUCTION(Ins::LoadValue({ false }));
						break;
					default:;
					}
				}

#define INSTRUCTION_LOAD_VALUE(TYPE) if (td == description::GetTypeDescriptor<TYPE>()) { INSTRUCTION(Ins::LoadValue({ UnboxValue<TYPE>(output) })); return; }

				void Visit(WfFloatingExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					auto td = result.type->GetTypeDescriptor();
					Value output;
					td->GetSerializableType()->Deserialize(node->value.value, output);
					INSTRUCTION_LOAD_VALUE(float);
					INSTRUCTION_LOAD_VALUE(double);
					CHECK_FAIL(L"Unrecognized value in WfFloatingExpression!");
				}

				void Visit(WfIntegerExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					auto td = result.type->GetTypeDescriptor();
					Value output;
					td->GetSerializableType()->Deserialize(node->value.value, output);
					INSTRUCTION_LOAD_VALUE(vint8_t);
					INSTRUCTION_LOAD_VALUE(vint16_t);
					INSTRUCTION_LOAD_VALUE(vint32_t);
					INSTRUCTION_LOAD_VALUE(vint64_t);
					INSTRUCTION_LOAD_VALUE(vuint8_t);
					INSTRUCTION_LOAD_VALUE(vuint16_t);
					INSTRUCTION_LOAD_VALUE(vuint32_t);
					INSTRUCTION_LOAD_VALUE(vuint64_t);
					INSTRUCTION_LOAD_VALUE(float);
					INSTRUCTION_LOAD_VALUE(double);
					CHECK_FAIL(L"Unrecognized value in WfIntegerExpression!");
				}

#undef INSTRUCTION_LOAD_VALUE

				void Visit(WfStringExpression* node)override
				{
					INSTRUCTION(Ins::LoadValue({ node->value.value }));
				}

				void Visit(WfUnaryExpression* node)override
				{
					auto type = GenerateExpressionInstructions(context, node->operand);
					switch (node->op)
					{
					case WfUnaryOperator::Not:
						INSTRUCTION(Ins::OpNot(GetInstructionTypeArgument(type)));
						break;
					case WfUnaryOperator::Positive:
						INSTRUCTION(Ins::OpPositive(GetInstructionTypeArgument(type)));
						break;
					case WfUnaryOperator::Negative:
						INSTRUCTION(Ins::OpNegative(GetInstructionTypeArgument(type)));
						break;
					default:;
					}
				}

				void Visit(WfBinaryExpression* node)override
				{
					if (node->op == WfBinaryOperator::Assign)
					{
						if (auto binary = node->first.Cast<WfBinaryExpression>())
						{
							auto result = context.manager->expressionResolvings[binary->first.Obj()];
							auto containerType = result.expectedType ? result.expectedType : result.type;
							auto methodInfo = containerType->GetTypeDescriptor()->GetMethodGroupByName(L"Set", true)->GetMethod(0);
							GenerateExpressionInstructions(context, binary->second);
							INSTRUCTION(Ins::Duplicate(0));
							GenerateExpressionInstructions(context, node->second);
							GenerateExpressionInstructions(context, binary->first);
							INSTRUCTION(Ins::InvokeMethod(methodInfo, 2));
							INSTRUCTION(Ins::Pop());
						}
						else if (auto member = node->first.Cast<WfMemberExpression>())
						{
							auto result = context.manager->expressionResolvings[member.Obj()];
							if (auto methodInfo = result.propertyInfo->GetSetter())
							{
								GenerateExpressionInstructions(context, node->second);
								INSTRUCTION(Ins::Duplicate(0));
								GenerateExpressionInstructions(context, member->parent);
								INSTRUCTION(Ins::InvokeMethod(methodInfo, 1));
								INSTRUCTION(Ins::Pop());
							}
							else
							{
								GenerateExpressionInstructions(context, node->second);
								INSTRUCTION(Ins::Duplicate(0));
								GenerateExpressionInstructions(context, member->parent);
								INSTRUCTION(Ins::SetProperty(result.propertyInfo));
							}
						}
						else
						{
							GenerateExpressionInstructions(context, node->second);
							INSTRUCTION(Ins::Duplicate(0));
							auto result = context.manager->expressionResolvings[node->first.Obj()];
							vint index = -1;
							if ((index = context.globalVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
							{
								vint variableIndex = context.globalVariables.Values()[index];
								INSTRUCTION(Ins::StoreGlobalVar(variableIndex));
							}
							else if ((index = context.functionContext->localVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
							{
								vint variableIndex = context.functionContext->localVariables.Values()[index];
								INSTRUCTION(Ins::StoreLocalVar(variableIndex));
							}
							else if ((index = context.functionContext->capturedVariables.Keys().IndexOf(result.symbol.Obj())) != -1)
							{
								vint variableIndex = context.functionContext->capturedVariables.Values()[index];
								INSTRUCTION(Ins::StoreCapturedVar(variableIndex));
							}
							else if (result.propertyInfo)
							{
								if (auto setter = result.propertyInfo->GetSetter())
								{
									VisitThisExpression(node, setter->GetOwnerTypeDescriptor());
									INSTRUCTION(Ins::InvokeMethod(setter, 1));
									INSTRUCTION(Ins::Pop());
								}
								else
								{
									VisitThisExpression(node, result.propertyInfo->GetOwnerTypeDescriptor());
									INSTRUCTION(Ins::SetProperty(result.propertyInfo));
								}
							}
							else
							{
								CHECK_FAIL(L"GenerateExpressionInstructionsVisitor::Visit(WfBinaryExpression*)#Internal error, cannot find any record of this assignable symbol.");
							}
						}
					}
					else if (node->op == WfBinaryOperator::Index)
					{
						auto result = context.manager->expressionResolvings[node->first.Obj()];
						auto containerType = result.expectedType ? result.expectedType : result.type;
						auto methodInfo = containerType->GetTypeDescriptor()->GetMethodGroupByName(L"Get", true)->GetMethod(0);
						GenerateExpressionInstructions(context, node->second);
						GenerateExpressionInstructions(context, node->first);
						INSTRUCTION(Ins::InvokeMethod(methodInfo, 1));
					}
					else if (node->op == WfBinaryOperator::FlagAnd)
					{
						auto type = context.manager->expressionResolvings[node].type;
						if (type->GetTypeDescriptor() == description::GetTypeDescriptor<WString>())
						{
							GenerateExpressionInstructions(context, node->first, type);
							GenerateExpressionInstructions(context, node->second, type);
							INSTRUCTION(Ins::OpConcat());
						}
						else
						{
							GenerateExpressionInstructions(context, node->first, type);
							INSTRUCTION(Ins::ConvertToType(Value::BoxedValue, description::GetTypeDescriptor<vuint64_t>()));
							GenerateExpressionInstructions(context, node->second, type);
							INSTRUCTION(Ins::ConvertToType(Value::BoxedValue, description::GetTypeDescriptor<vuint64_t>()));
							INSTRUCTION(Ins::OpAnd(WfInsType::U8));
							INSTRUCTION(Ins::ConvertToType(Value::BoxedValue, type->GetTypeDescriptor()));
						}
					}
					else if (node->op == WfBinaryOperator::FlagOr)
					{
						auto type = context.manager->expressionResolvings[node].type;
						GenerateExpressionInstructions(context, node->first, type);
						INSTRUCTION(Ins::ConvertToType(Value::BoxedValue, description::GetTypeDescriptor<vuint64_t>()));
						GenerateExpressionInstructions(context, node->second, type);
						INSTRUCTION(Ins::ConvertToType(Value::BoxedValue, description::GetTypeDescriptor<vuint64_t>()));
						INSTRUCTION(Ins::OpOr(WfInsType::U8));
						INSTRUCTION(Ins::ConvertToType(Value::BoxedValue, type->GetTypeDescriptor()));
					}
					else if (node->op == WfBinaryOperator::FailedThen)
					{
						auto result = context.manager->expressionResolvings[node];
						vint trapInstruction = INSTRUCTION(Ins::InstallTry(-1));
						GenerateExpressionInstructions(context, node->first, result.type);
						INSTRUCTION(Ins::UninstallTry(1));
						vint finishInstruction = INSTRUCTION(Ins::Jump(-1));

						FILL_LABEL_TO_CURRENT(trapInstruction);
						GenerateExpressionInstructions(context, node->second, result.type);

						FILL_LABEL_TO_CURRENT(finishInstruction);
					}
					else
					{
						Ptr<ITypeInfo> mergedType;
						switch (node->op)
						{
						case WfBinaryOperator::Exp:
						case WfBinaryOperator::Add:
						case WfBinaryOperator::Sub:
						case WfBinaryOperator::Mul:
						case WfBinaryOperator::Div:
						case WfBinaryOperator::Mod:
						case WfBinaryOperator::Shl:
						case WfBinaryOperator::Shr:
							{
								auto result = context.manager->expressionResolvings[node];
								mergedType = result.type;
							}
							break;
						default:
							{
								auto firstResult = context.manager->expressionResolvings[node->first.Obj()];
								auto secondResult = context.manager->expressionResolvings[node->second.Obj()];
								auto firstType = firstResult.expectedType ? firstResult.expectedType : firstResult.type;
								auto secondType = secondResult.expectedType ? secondResult.expectedType : secondResult.type;
								mergedType = GetMergedType(firstType, secondType);

								if (node->op == WfBinaryOperator::EQ || node->op == WfBinaryOperator::NE)
								{
									if (mergedType->GetDecorator() == ITypeInfo::RawPtr || mergedType->GetDecorator() == ITypeInfo::SharedPtr)
									{
										GenerateExpressionInstructions(context, node->first);
										GenerateExpressionInstructions(context, node->second);
										INSTRUCTION(Ins::CompareReference());
										if (node->op == WfBinaryOperator::NE)
										{
											INSTRUCTION(Ins::OpNot(WfInsType::Bool));
										}
									}
									else
									{
										Ptr<ITypeInfo> mergedToStringType;
										if (mergedType->GetDecorator() == ITypeInfo::TypeDescriptor && mergedType->GetTypeDescriptor() == description::GetTypeDescriptor<WString>())
										{
											mergedToStringType = mergedType;
										}

										GenerateExpressionInstructions(context, node->first, mergedToStringType);
										GenerateExpressionInstructions(context, node->second, mergedToStringType);
										INSTRUCTION(Ins::CompareValue());
										if (node->op == WfBinaryOperator::NE)
										{
											INSTRUCTION(Ins::OpNot(WfInsType::Bool));
										}
									}
									return;
								}
							}
						}

						GenerateExpressionInstructions(context, node->first, mergedType);
						GenerateExpressionInstructions(context, node->second, mergedType);

						switch (node->op)
						{
						case WfBinaryOperator::Exp:
							INSTRUCTION(Ins::OpExp(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Add:
							INSTRUCTION(Ins::OpAdd(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Sub:
							INSTRUCTION(Ins::OpSub(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Mul:
							INSTRUCTION(Ins::OpMul(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Div:
							INSTRUCTION(Ins::OpDiv(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Mod:
							INSTRUCTION(Ins::OpMod(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Shl:
							INSTRUCTION(Ins::OpShl(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Shr:
							INSTRUCTION(Ins::OpShr(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::LT:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpLT());
							break;
						case WfBinaryOperator::GT:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpGT());
							break;
						case WfBinaryOperator::LE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpLE());
							break;
						case WfBinaryOperator::GE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpGE());
							break;
						case WfBinaryOperator::EQ:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpEQ());
							break;
						case WfBinaryOperator::NE:
							INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(mergedType)));
							INSTRUCTION(Ins::OpNE());
							break;
						case WfBinaryOperator::Xor:
							INSTRUCTION(Ins::OpXor(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::And:
							INSTRUCTION(Ins::OpAnd(GetInstructionTypeArgument(mergedType)));
							break;
						case WfBinaryOperator::Or:
							INSTRUCTION(Ins::OpOr(GetInstructionTypeArgument(mergedType)));
							break;
						default:;
						}
					}
				}

				void Visit(WfLetExpression* node)override
				{
					auto scope = context.manager->nodeScopes[node].Obj();
					Array<vint> variableIndices(node->variables.Count());
					auto function = context.functionContext->function;
					for (auto [var, index] : indexed(node->variables))
					{
						auto symbol = scope->symbols[var->name.value][0];
						vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<let>" + var->name.value);
						context.functionContext->localVariables.Add(symbol.Obj(), variableIndex);
						variableIndices[index] = variableIndex;

						GenerateExpressionInstructions(context, var->value);
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
					}
					GenerateExpressionInstructions(context, node->expression);
					for (auto [var, index] : indexed(node->variables))
					{
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::StoreLocalVar(variableIndices[index]));
					}
				}

				void Visit(WfIfExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					GenerateExpressionInstructions(context, node->condition);
					vint fillTrueIndex = INSTRUCTION(Ins::JumpIf(-1));
					GenerateExpressionInstructions(context, node->falseBranch, result.type);
					vint fillEndIndex = INSTRUCTION(Ins::Jump(-1));
					FILL_LABEL_TO_CURRENT(fillTrueIndex);
					GenerateExpressionInstructions(context, node->trueBranch, result.type);
					FILL_LABEL_TO_CURRENT(fillEndIndex);
				}

				void Visit(WfRangeExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					auto elementType = Ptr(result.type->GetElementType()->GetGenericArgument(0));
					auto type = GetInstructionTypeArgument(elementType);

					WfRuntimeValue one;
					switch (context.manager->cpuArchitecture)
					{
					case WfCpuArchitecture::x86:
						one = {(vint32_t)1};
						break;
					case WfCpuArchitecture::x64:
						one = { (vint64_t)1 };
						break;
					default:
						one = { (vint)1 };
						break;
					}
					
					GenerateExpressionInstructions(context, node->begin, elementType);
					if (node->beginBoundary == WfRangeBoundary::Exclusive)
					{
						INSTRUCTION(Ins::LoadValue(one));
						INSTRUCTION(Ins::OpAdd(type));
					}
					
					GenerateExpressionInstructions(context, node->end, elementType);
					if (node->endBoundary == WfRangeBoundary::Exclusive)
					{
						INSTRUCTION(Ins::LoadValue(one));
						INSTRUCTION(Ins::OpSub(type));
					}

					INSTRUCTION(Ins::CreateRange(type));
				}

				void Visit(WfSetTestingExpression* node)override
				{
					if (auto range = node->collection.Cast<WfRangeExpression>())
					{
						auto resultElement = context.manager->expressionResolvings[node->element.Obj()];
						auto resultBegin = context.manager->expressionResolvings[range->begin.Obj()];
						auto resultEnd = context.manager->expressionResolvings[range->end.Obj()];
						auto typeElement = resultElement.expectedType ? resultElement.expectedType : resultElement.type;
						auto typeBegin = resultBegin.expectedType ? resultBegin.expectedType : resultBegin.type;
						auto typeEnd = resultEnd.expectedType ? resultEnd.expectedType : resultEnd.type;
						auto typeLeft = GetMergedType(typeElement, typeBegin);
						auto typeRight = GetMergedType(typeElement, typeEnd);

						auto function = context.functionContext->function;
						vint index = function->argumentNames.Count() + function->localVariableNames.Add(L"<anonymous-range-test>");
						GenerateExpressionInstructions(context, node->element);
						INSTRUCTION(Ins::StoreLocalVar(index));
						
						INSTRUCTION(Ins::LoadLocalVar(index));
						if (!IsSameType(typeElement.Obj(), typeLeft.Obj()))
						{
							GenerateTypeCastInstructions(context, typeLeft, true, node);
						}
						GenerateExpressionInstructions(context, range->begin, typeLeft);
						INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(typeLeft)));
						if (range->beginBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::OpGT());
						}
						else
						{
							INSTRUCTION(Ins::OpGE());
						}

						INSTRUCTION(Ins::LoadLocalVar(index));
						if (!IsSameType(typeElement.Obj(), typeRight.Obj()))
						{
							GenerateTypeCastInstructions(context, typeRight, true, node);
						}
						GenerateExpressionInstructions(context, range->end, typeRight);
						INSTRUCTION(Ins::CompareLiteral(GetInstructionTypeArgument(typeRight)));
						if (range->endBoundary == WfRangeBoundary::Exclusive)
						{
							INSTRUCTION(Ins::OpLT());
						}
						else
						{
							INSTRUCTION(Ins::OpLE());
						}

						INSTRUCTION(Ins::OpAnd(WfInsType::Bool));
						if (node->test == WfSetTesting::NotIn)
						{
							INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						}
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::StoreLocalVar(index));
					}
					else
					{
						auto result = context.manager->expressionResolvings[node->collection.Obj()];
						auto type = result.expectedType ? result.expectedType : result.type;

						GenerateExpressionInstructions(context, node->element);
						GenerateExpressionInstructions(context, node->collection);

						auto tdList = description::GetTypeDescriptor<IValueReadonlyList>();
						if (result.type->GetTypeDescriptor()->CanConvertTo(tdList))
						{
							auto method = tdList->GetMethodGroupByName(L"Contains", true)->GetMethod(0);
							INSTRUCTION(Ins::InvokeMethod(method, 1));
						}
						else
						{
							INSTRUCTION(Ins::TestElementInSet());
						}

						if (node->test == WfSetTesting::NotIn)
						{
							INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						}
					}
				}

				void Visit(WfConstructorExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];

					if (result.type->GetTypeDescriptor()->GetTypeDescriptorFlags() == TypeDescriptorFlags::Struct)
					{
						auto td = result.type->GetTypeDescriptor();
						INSTRUCTION(Ins::CreateStruct(Value::BoxedValue, td));

						for (auto argument : node->arguments)
						{
							auto prop = td->GetPropertyByName(argument->key.Cast<WfReferenceExpression>()->name.value, true);
							GenerateExpressionInstructions(context, argument->value, CopyTypeInfo(prop->GetReturn()));
							INSTRUCTION(Ins::UpdateProperty(prop));
						}
					}
					else if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueEnumerable>()
						|| result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueReadonlyList>()
						|| result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueArray>())
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						for (auto argument : From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
						}
						INSTRUCTION(Ins::NewArray(node->arguments.Count()));
					}
					else if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueList>())
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						for (auto argument : From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
						}
						INSTRUCTION(Ins::NewList(node->arguments.Count()));
					}
					else if (result.type->GetTypeDescriptor() == description::GetTypeDescriptor<IValueObservableList>())
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						for (auto argument : From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
						}
						INSTRUCTION(Ins::NewObservableList(node->arguments.Count()));
					}
					else
					{
						Ptr<ITypeInfo> keyType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(0));
						Ptr<ITypeInfo> valueType = CopyTypeInfo(result.type->GetElementType()->GetGenericArgument(1));
						for (auto argument : From(node->arguments).Reverse())
						{
							GenerateExpressionInstructions(context, argument->key, keyType);
							GenerateExpressionInstructions(context, argument->value, valueType);
						}
						INSTRUCTION(Ins::NewDictionary(node->arguments.Count() * 2));
					}
				}

				void Visit(WfInferExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
				}

				void Visit(WfTypeCastingExpression* node)override
				{
					if (node->strategy == WfTypeCastingStrategy::Strong)
					{
						auto result = context.manager->expressionResolvings[node];
						GenerateExpressionInstructions(context, node->expression, result.type);
					}
					else
					{
						auto scope = context.manager->nodeScopes[node].Obj();
						auto type = CreateTypeInfoFromType(scope, node->type);
						GenerateExpressionInstructions(context, node->expression);
						GenerateTypeCastInstructions(context, type, false, node);
					}
				}

				void Visit(WfTypeTestingExpression* node)override
				{
					switch (node->test)
					{
					case WfTypeTesting::IsNull:
						GenerateExpressionInstructions(context, node->expression);
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::CompareReference());
						break;
					case WfTypeTesting::IsNotNull:
						GenerateExpressionInstructions(context, node->expression);
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::CompareReference());
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						break;
					case WfTypeTesting::IsType:
						{
							auto scope = context.manager->nodeScopes[node].Obj();
							auto type = CreateTypeInfoFromType(scope, node->type);
							GenerateExpressionInstructions(context, node->expression);
							GenerateTypeTestingInstructions(context, type, node);
						}
						break;
					case WfTypeTesting::IsNotType:
						{
							auto scope = context.manager->nodeScopes[node].Obj();
							auto type = CreateTypeInfoFromType(scope, node->type);
							GenerateExpressionInstructions(context, node->expression);
							GenerateTypeTestingInstructions(context, type, node);
							INSTRUCTION(Ins::OpNot(WfInsType::Bool));
						}
						break;
					default:;
					}
				}

				void Visit(WfTypeOfTypeExpression* node)override
				{
					auto scope = context.manager->nodeScopes[node].Obj();
					auto type = CreateTypeInfoFromType(scope, node->type, false);
					INSTRUCTION(Ins::LoadValue({ type->GetTypeDescriptor() }));
				}

				void Visit(WfTypeOfExpressionExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::GetType());
				}

				void Visit(WfAttachEventExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node->event.Obj()];
					if (auto member = node->event.Cast<WfMemberExpression>())
					{
						GenerateExpressionInstructions(context, member->parent);
					}
					else
					{
						VisitThisExpression(node, result.eventInfo->GetOwnerTypeDescriptor());
					}
					GenerateExpressionInstructions(context, node->function);
					INSTRUCTION(Ins::AttachEvent(result.eventInfo));
				}

				void Visit(WfDetachEventExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node->event.Obj()];
					if (auto member = node->event.Cast<WfMemberExpression>())
					{
						GenerateExpressionInstructions(context, member->parent);
					}
					else
					{
						VisitThisExpression(node, result.eventInfo->GetOwnerTypeDescriptor());
					}
					GenerateExpressionInstructions(context, node->handler);
					INSTRUCTION(Ins::DetachEvent(result.eventInfo));
				}

				void Visit(WfObserveExpression* node)override
				{
				}

				void Visit(WfCallExpression* node)override
				{
					for (auto argument : node->arguments)
					{
						GenerateExpressionInstructions(context, argument);
					}

					auto result = context.manager->expressionResolvings[node->function.Obj()];
					if (result.methodInfo)
					{
						if (result.methodInfo->IsStatic())
						{
							INSTRUCTION(Ins::LoadValue({}));
						}
						else if (auto member = node->function.Cast<WfMemberExpression>())
						{
							GenerateExpressionInstructions(context, member->parent);
						}
						else
						{
							VisitThisExpression(node, result.methodInfo->GetOwnerTypeDescriptor());
						}

						INSTRUCTION(Ins::InvokeMethod(result.methodInfo, node->arguments.Count()));
						return;
					}
					else if (result.eventInfo)
					{
						if(auto member = node->function.Cast<WfMemberExpression>())
						{
							GenerateExpressionInstructions(context, member->parent);
						}
						else
						{
							VisitThisExpression(node, result.eventInfo->GetOwnerTypeDescriptor());
						}
						INSTRUCTION(Ins::InvokeEvent(result.eventInfo, node->arguments.Count()));
						return;
					}
					else if (result.symbol)
					{
						if (result.symbol->creatorNode.Cast<WfFunctionDeclaration>())
						{
							if (result.symbol->ownerScope->ownerNode.Cast<WfNewInterfaceExpression>())
							{
								vint functionIndex = context.closureFunctions[result.symbol.Obj()];
								INSTRUCTION(Ins::InvokeWithContext(functionIndex, node->arguments.Count()));
								return;
							}
							else
							{
								vint index = context.globalFunctions.Keys().IndexOf(result.symbol.Obj());
								if (index != -1)
								{
									vint functionIndex = context.globalFunctions.Values()[index];
									INSTRUCTION(Ins::Invoke(functionIndex, node->arguments.Count()));
									return;
								}
							}
						}
					}

					GenerateExpressionInstructions(context, node->function);
					INSTRUCTION(Ins::InvokeProxy(node->arguments.Count()));
				}

				static void VisitFunction(WfCodegenContext& context, WfFunctionDeclaration* node, WfCodegenLambdaContext lc, const Func<WString(vint)>& getName)
				{
					auto scope = context.manager->nodeScopes[node].Obj();
					bool inNewInterfaceExpr = scope->parentScope && scope->parentScope->ownerNode.Cast<WfNewInterfaceExpression>();
					auto functionIndex = AddClosure(context, lc, getName);

					if (inNewInterfaceExpr)
					{
						INSTRUCTION(Ins::LoadFunction(functionIndex));
					}
					else
					{
						auto capture = context.manager->lambdaCaptures.Get(node);
						for (auto symbol : capture->symbols)
						{
							GenerateLoadSymbolInstructions(context, symbol.Obj(), node);
						}
						vint thisCount = PushCapturedThisValues(context, scope->parentScope.Obj(), node);
						INSTRUCTION(Ins::CreateClosureContext(capture->symbols.Count() + thisCount));
						INSTRUCTION(Ins::LoadFunction(functionIndex));
						INSTRUCTION(Ins::CreateClosure());
					}
				}

				void Visit(WfFunctionExpression* node)override
				{
					WfCodegenLambdaContext lc;
					lc.functionExpression = node;
					VisitFunction(context, node->function.Obj(), lc, [=, this](vint index)
					{
						return L"<lambda:" + node->function->name.value + L"(" + itow(index) + L")> in " + context.functionContext->function->name;
					});
				}

				class NewInterfaceExpressionVisitor : public empty_visitor::DeclarationVisitor
				{
				public:
					WfCodegenContext&						context;
					vint									variableCount = 0;
					List<Ptr<WfLexicalSymbol>>				variableSymbols;
					List<Ptr<WfFunctionDeclaration>>		closureFunctions;
					List<Ptr<WfFunctionDeclaration>>		overrideFunctions;
					WfFunctionDeclaration*					firstFunction = nullptr;

					NewInterfaceExpressionVisitor(WfCodegenContext& _context)
						:context(_context)
					{
					}

					void Dispatch(WfVirtualCfeDeclaration* node)override
					{
						for (auto decl : node->expandedDeclarations)
						{
							decl->Accept(this);
						}
					}

					void Dispatch(WfVirtualCseDeclaration* node)override
					{
						CHECK_FAIL(L"NewInterfaceExpressionVisitor::Visit(WfVirtualCseDeclaration*)#Internal error, Temporary not supported.");
					}

					void Visit(WfFunctionDeclaration* node)override
					{
						if (!firstFunction)
						{
							firstFunction = node;
						}

						if (node->functionKind == WfFunctionKind::Normal)
						{
							closureFunctions.Add(Ptr(node));
						}
						else
						{
							overrideFunctions.Add(Ptr(node));
						}
					}

					void Visit(WfVariableDeclaration* node)override
					{
						variableCount++;
					}

					void Execute(WfNewInterfaceExpression* node)
					{
						for (auto memberDecl : node->declarations)
						{
							memberDecl->Accept(this);
						}

						if (firstFunction != nullptr && variableCount > 0)
						{
							auto capture = context.manager->lambdaCaptures.Get(firstFunction);
							CopyFrom(variableSymbols, From(capture->symbols).Take(variableCount));
						}
					}
				};

				void Visit(WfNewClassExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					for (auto argument : node->arguments)
					{
						GenerateExpressionInstructions(context, argument);
					}
					INSTRUCTION(Ins::LoadValue({}));
					INSTRUCTION(Ins::InvokeMethod(result.constructorInfo, node->arguments.Count()));
				}

				void Visit(WfNewInterfaceExpression* node)override
				{
					auto result = context.manager->expressionResolvings[node];
					NewInterfaceExpressionVisitor declVisitor(context);
					declVisitor.Execute(node);

					if (declVisitor.firstFunction != nullptr)
					{
						for (vint i = 0; i < declVisitor.variableCount; i++)
						{
							auto var = declVisitor.variableSymbols[i]->creatorNode.Cast<WfVariableDeclaration>();
							GenerateExpressionInstructions(context, var->expression);
						}

						auto capture = context.manager->lambdaCaptures.Get(declVisitor.firstFunction);
						for (vint i = declVisitor.variableCount; i < capture->symbols.Count(); i++)
						{
							GenerateLoadSymbolInstructions(context, capture->symbols[i].Obj(), node);
						}
						auto scope = context.manager->nodeScopes[node].Obj();
						vint thisCount = PushCapturedThisValues(context, scope, node);
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::CreateClosureContext(capture->symbols.Count() + thisCount + 1));

						for (auto func : declVisitor.closureFunctions)
						{
							WfCodegenLambdaContext lc;
							lc.functionDeclaration = func.Obj();
							auto functionIndex = AddClosure(context, lc, [=, this](vint index)
							{
								return L"<method:" + func->name.value + L"<" + result.type->GetTypeDescriptor()->GetTypeName() + L">(" + itow(index) + L")> in " + context.functionContext->function->name;
							});

							auto scope = context.manager->nodeScopes[func.Obj()].Obj();
							auto symbol = context.manager->GetDeclarationSymbol(scope, func.Obj());
							context.closureFunctions.Add(symbol.Obj(), functionIndex);
						}

						for (auto func : declVisitor.overrideFunctions)
						{
							auto methodInfo = context.manager->interfaceMethodImpls[func.Obj()];
							INSTRUCTION(Ins::LoadMethodInfo(methodInfo));
							WfCodegenLambdaContext lc;
							lc.functionDeclaration = func.Obj();
							VisitFunction(context, func.Obj(), lc, [=, this, &declVisitor](vint index)
							{
								return L"<method:" + func->name.value + L"<" + result.type->GetTypeDescriptor()->GetTypeName() + L">(" + itow(index + declVisitor.closureFunctions.Count()) + L")> in " + context.functionContext->function->name;
							});
						}
					}
					else
					{
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::CreateClosureContext(1));
					}
					INSTRUCTION(Ins::CreateInterface(result.constructorInfo, declVisitor.overrideFunctions.Count() * 2));
				}

				void Visit(WfVirtualCfeExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expandedExpression);
				}

				void Visit(WfVirtualCseExpression* node)override
				{
					GenerateExpressionInstructions(context, node->expandedExpression);
				}
			};

#undef FILL_LABEL_TO_CURRENT
#undef FILL_LABEL_TO_INS
#undef INSTRUCTION

			Ptr<reflection::description::ITypeInfo> GenerateExpressionInstructions(WfCodegenContext& context, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType)
			{
				GenerateExpressionInstructionsVisitor visitor(context);
				expression->Accept(&visitor);

				auto result = context.manager->expressionResolvings[expression.Obj()];
				auto type = result.type;

				if (result.expectedType && !IsSameType(type.Obj(), result.expectedType.Obj()))
				{
					type = result.expectedType;
					GenerateTypeCastInstructions(context, type, true, expression.Obj());
				}

				if (expectedType && !IsSameType(type.Obj(), expectedType.Obj()))
				{
					type = expectedType;
					GenerateTypeCastInstructions(context, type, true, expression.Obj());
				}

				return type;
			}
		}
	}
}


/***********************************************************************
.\EMITTER\WFEMITTER_METADATA.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace emitter
		{
			using namespace collections;
			using namespace reflection::description;
			using namespace analyzer;
			using namespace runtime;
			using namespace typeimpl;

/***********************************************************************
GenerateGlobalDeclarationMetadata
***********************************************************************/

			void GenerateFunctionDeclarationMetadata(WfCodegenContext& context, WfFunctionDeclaration* node, Ptr<WfAssemblyFunction> meta)
			{
				for (auto argument : node->arguments)
				{
					meta->argumentNames.Add(argument->name.value);
				}
				{
					vint index = context.manager->lambdaCaptures.Keys().IndexOf(node);
					if (index != -1)
					{
						auto capture = context.manager->lambdaCaptures.Values()[index];
						for (auto symbol : capture->symbols)
						{
							meta->capturedVariableNames.Add(L"<captured>" + symbol->name);
						}
					}

					auto scope = context.manager->nodeScopes[node];
					vint count = context.GetThisStackCount(scope.Obj());
					for (vint i = 0; i < count; i++)
					{
						meta->capturedVariableNames.Add(L"<captured-this>" + itow(i));
					}
				}
			}

			class GenerateGlobalClassMemberMetadataVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;
				WString									namePrefix;
				WfClassDeclaration*						classDecl;

				GenerateGlobalClassMemberMetadataVisitor(WfCodegenContext& _context, const WString& _namePrefix, WfClassDeclaration* _classDecl)
					:context(_context)
					, namePrefix(_namePrefix)
					, classDecl(_classDecl)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					if (node->functionKind == WfFunctionKind::Static)
					{
						GenerateGlobalDeclarationMetadata(context, node, namePrefix);
						auto scope = context.manager->nodeScopes[node].Obj();
						auto symbol = context.manager->GetDeclarationSymbol(scope, node);
						auto index = context.globalFunctions[symbol.Obj()];
						auto info = context.manager->declarationMemberInfos[node].Cast<WfStaticMethod>();
						info->functionIndex = index;
					}
					else if (classDecl->kind == WfClassKind::Class)
					{
						GenerateGlobalDeclarationMetadata(context, node, namePrefix);
						auto scope = context.manager->nodeScopes[node].Obj();
						auto symbol = context.manager->GetDeclarationSymbol(scope, node);
						auto index = context.globalFunctions[symbol.Obj()];
						auto info = context.manager->declarationMemberInfos[node].Cast<WfClassMethod>();
						info->functionIndex = index;
					}
				}

				void Visit(WfVariableDeclaration* node)override
				{
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
					auto meta = Ptr(new WfAssemblyFunction);
					meta->name = namePrefix + L"#ctor";
					for (auto argument : node->arguments)
					{
						meta->argumentNames.Add(argument->name.value);
					}
					meta->capturedVariableNames.Add(L"<captured-this>0");

					vint index = context.assembly->functions.Add(meta);
					context.assembly->functionByName.Add(meta->name, index);
					context.constructors.Add(node, index);

					auto info = context.manager->declarationMemberInfos[node].Cast<WfClassConstructor>();
					info->functionIndex = index;
				}

				void Visit(WfDestructorDeclaration* node)override
				{
					auto meta = Ptr(new WfAssemblyFunction);
					meta->name = namePrefix + L"#dtor";
					meta->capturedVariableNames.Add(L"<captured-this>0");

					vint index = context.assembly->functions.Add(meta);
					context.assembly->functionByName.Add(meta->name, index);
					context.destructors.Add(node, index);

					auto info = context.manager->declarationTypes[classDecl].Cast<WfClass>();
					info->destructorFunctionIndex = index;
				}

				void Visit(WfClassDeclaration* node)override
				{
					GenerateGlobalDeclarationMetadata(context, node, namePrefix);
				}

				void Visit(WfEnumDeclaration* node)override
				{
				}

				void Visit(WfStructDeclaration* node)override
				{
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			class GenerateGlobalDeclarationMetadataVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:
				WfCodegenContext&						context;
				WString									namePrefix;

				GenerateGlobalDeclarationMetadataVisitor(WfCodegenContext& _context, const WString& _namePrefix)
					:context(_context)
					, namePrefix(_namePrefix)
				{
				}

				void Visit(WfNamespaceDeclaration* node)override
				{
					for (auto decl : node->declarations)
					{
						GenerateGlobalDeclarationMetadata(context, decl.Obj(), namePrefix + node->name.value + L"::");
					}
				}

				void Visit(WfFunctionDeclaration* node)override
				{
					auto meta = Ptr(new WfAssemblyFunction);
					meta->name = namePrefix + node->name.value;
					GenerateFunctionDeclarationMetadata(context, node, meta);

					vint index = context.assembly->functions.Add(meta);
					context.assembly->functionByName.Add(meta->name, index);

					auto scope = context.manager->nodeScopes[node].Obj();
					auto symbol = context.manager->GetDeclarationSymbol(scope, node);
					context.globalFunctions.Add(symbol.Obj(), index);
				}

				void Visit(WfVariableDeclaration* node)override
				{
					vint index = context.assembly->variableNames.Add(namePrefix + node->name.value);

					auto scope = context.manager->nodeScopes[node].Obj();
					auto symbol = scope->symbols[node->name.value][0];
					context.globalVariables.Add(symbol.Obj(), index);
				}

				void Visit(WfEventDeclaration* node)override
				{
				}

				void Visit(WfPropertyDeclaration* node)override
				{
				}

				void Visit(WfStaticInitDeclaration* node)override
				{
				}

				void Visit(WfConstructorDeclaration* node)override
				{
				}

				void Visit(WfDestructorDeclaration* node)override
				{
				}

				void Visit(WfClassDeclaration* node)override
				{
					for (auto memberDecl : node->declarations)
					{
						GenerateGlobalClassMemberMetadataVisitor visitor(context, namePrefix + node->name.value + L"::", node);
						memberDecl->Accept(&visitor);
					}
				}

				void Visit(WfEnumDeclaration* node)override
				{
				}

				void Visit(WfStructDeclaration* node)override
				{
				}

				void Visit(WfVirtualCfeDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}

				void Visit(WfVirtualCseDeclaration* node)override
				{
					for (auto decl : node->expandedDeclarations)
					{
						decl->Accept(this);
					}
				}
			};

			void GenerateGlobalDeclarationMetadata(WfCodegenContext& context, WfDeclaration* declaration, const WString& namePrefix)
			{
				GenerateGlobalDeclarationMetadataVisitor visitor(context, namePrefix);
				declaration->Accept(&visitor);
			}
		}
	}
}

/***********************************************************************
.\EMITTER\WFEMITTER_STATEMENT.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		namespace emitter
		{
			using namespace collections;
			using namespace reflection;
			using namespace reflection::description;
			using namespace analyzer;
			using namespace runtime;

			typedef WfInstruction Ins;

#define INSTRUCTION(X) context.AddInstruction(node, X)
#define FILL_LABEL_TO_INS(LABEL, INS) context.assembly->instructions[LABEL].indexParameter = INS
#define FILL_LABEL_TO_CURRENT(LABEL) FILL_LABEL_TO_INS(LABEL, context.assembly->instructions.Count())
#define EXIT_CODE(X) context.AddExitInstruction(node, X)

/***********************************************************************
GenerateInstructions(Statement)
***********************************************************************/

			class GenerateStatementInstructionsVisitor : public Object, public WfStatement::IVisitor
			{
			public:
				WfCodegenContext&						context;

				GenerateStatementInstructionsVisitor(WfCodegenContext& _context)
					:context(_context)
				{
				}

				void ApplyExitCode(Ptr<WfCodegenScopeContext> scopeContext)
				{
					context.ApplyExitInstructions(scopeContext);
					if (scopeContext->exitStatement)
					{
						GenerateStatementInstructions(context, scopeContext->exitStatement);
					}
				}

				void ApplyCurrentScopeExitCode()
				{
					auto scopeContext = context.functionContext->GetCurrentScopeContext();
					ApplyExitCode(scopeContext);
				}

				void InlineScopeExitCode(WfCodegenScopeType untilScopeType, bool exclusive, const WString& name = WString::Empty)
				{
					vint index = context.functionContext->scopeContextStack.Count() - 1;
					while (index >= 0)
					{
						auto scopeContext = context.functionContext->scopeContextStack[index];
						bool found = false;
						if (scopeContext->type == untilScopeType)
						{
							if (name == L"" || scopeContext->name == name)
							{
								found = true;
							}
						}

						if (exclusive && found) break;
						ApplyExitCode(scopeContext);
						if (!exclusive && found) break;
						index--;
					}
				}

				void Visit(WfBreakStatement* node)override
				{
					InlineScopeExitCode(WfCodegenScopeType::Loop, false);
					context.functionContext->GetCurrentScopeContext(WfCodegenScopeType::Loop)->breakInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
				}

				void Visit(WfContinueStatement* node)override
				{
					InlineScopeExitCode(WfCodegenScopeType::Loop, true);
					context.functionContext->GetCurrentScopeContext(WfCodegenScopeType::Loop)->continueInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
				}

				void Visit(WfReturnStatement* node)override
				{
					InlineScopeExitCode(WfCodegenScopeType::Function, false);
					if (node->expression)
					{
						GenerateExpressionInstructions(context, node->expression);
					}
					else
					{
						INSTRUCTION(Ins::LoadValue({}));
					}
					INSTRUCTION(Ins::Return());
				}

				void Visit(WfDeleteStatement* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::DeleteRawPtr());
				}

				void Visit(WfRaiseExceptionStatement* node)override
				{
					if (node->expression)
					{
						GenerateExpressionInstructions(context, node->expression);
					}
					else
					{
						auto scope = context.manager->nodeScopes[node];
						while (scope)
						{
							if (auto tryCatch = scope->ownerNode.Cast<WfTryStatement>())
							{
								if (tryCatch->name.value != L"")
								{
									auto symbol = scope->symbols[tryCatch->name.value][0].Obj();
									vint index = context.functionContext->localVariables[symbol];
									INSTRUCTION(Ins::LoadLocalVar(index));
									break;
								}
							}
							scope = scope->parentScope;
						}
					}
					INSTRUCTION(Ins::RaiseException());
				}

				void Visit(WfIfStatement* node)override
				{
					vint variableIndex = -1;

					GenerateExpressionInstructions(context, node->expression);
					if (node->name.value != L"")
					{
						auto scope = context.manager->nodeScopes[node];
						auto symbol = scope->symbols[node->name.value][0];
						auto function = context.functionContext->function;
						variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<if>" + node->name.value);
						context.functionContext->localVariables.Add(symbol.Obj(), variableIndex);

						GenerateTypeCastInstructions(context, symbol->typeInfo, false, node->expression.Obj());
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
						INSTRUCTION(Ins::LoadLocalVar(variableIndex));
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::CompareReference());
					}
					else
					{
						INSTRUCTION(Ins::OpNot(WfInsType::Bool));
					}
					vint fillElseIndex = INSTRUCTION(Ins::JumpIf(-1));

					GenerateStatementInstructions(context, node->trueBranch);
					if (variableIndex != -1)
					{
						INSTRUCTION(Ins::LoadValue({}));
						INSTRUCTION(Ins::StoreLocalVar(variableIndex));
					}
					vint fillEndIndex = INSTRUCTION(Ins::Jump(-1));
					FILL_LABEL_TO_CURRENT(fillElseIndex);

					if (node->falseBranch)
					{
						GenerateStatementInstructions(context, node->falseBranch);
					}
					FILL_LABEL_TO_CURRENT(fillEndIndex);
				}

				void Visit(WfWhileStatement* node)override
				{
					vint continueLabelIndex = -1;
					vint breakLabelIndex = -1;
					vint loopLabelIndex = -1;
					auto loopContext = context.functionContext->PushScopeContext(WfCodegenScopeType::Loop);

					loopLabelIndex = context.assembly->instructions.Count();
					continueLabelIndex = context.assembly->instructions.Count();
					GenerateExpressionInstructions(context, node->condition);
					INSTRUCTION(Ins::OpNot(WfInsType::Bool));
					loopContext->breakInstructions.Add(INSTRUCTION(Ins::JumpIf(-1)));
					GenerateStatementInstructions(context, node->statement);
					INSTRUCTION(Ins::Jump(loopLabelIndex));
					breakLabelIndex = context.assembly->instructions.Count();

					for (auto index : loopContext->continueInstructions)
					{
						FILL_LABEL_TO_INS(index, continueLabelIndex);
					}
					for (auto index : loopContext->breakInstructions)
					{
						FILL_LABEL_TO_INS(index, breakLabelIndex);
					}
					context.functionContext->PopScopeContext();
				}

				Pair<vint, vint> GenerateTryProtected(WfStatement* node, Ptr<WfStatement> protectedStatement, Ptr<WfStatement> finallyStatement)
				{
					auto catchContext = context.functionContext->PushScopeContext(WfCodegenScopeType::TryCatch);
					EXIT_CODE(Ins::UninstallTry(0));
					catchContext->exitStatement = finallyStatement;

					vint trap = INSTRUCTION(Ins::InstallTry(-1));
					GenerateStatementInstructions(context, protectedStatement);
					context.functionContext->PopScopeContext();
					INSTRUCTION(Ins::UninstallTry(0));
					vint finish = INSTRUCTION(Ins::Jump(-1));

					return{ trap,finish };
				}

				vint GenerateExceptionVariable(WfTryStatement* node)
				{
					WfLexicalSymbol* exceptionSymbol = nullptr;
					WString exceptionName;
					if (node->catchStatement)
					{
						auto scope = context.manager->nodeScopes[node].Obj();
						exceptionSymbol = scope->symbols[node->name.value][0].Obj();
						exceptionName = L"<catch>" + node->name.value;
					}
					else
					{
						exceptionName = L"<try-finally-exception>";
					}

					auto function = context.functionContext->function;
					vint variableIndex = function->argumentNames.Count() + function->localVariableNames.Add(L"<catch>" + node->name.value);
					if (exceptionSymbol)
					{
						context.functionContext->localVariables.Add(exceptionSymbol, variableIndex);
					}

					return variableIndex;
				}

				void GenerateTrap(WfTryStatement* node, vint variableIndex, Pair<vint, vint> trap)
				{
					FILL_LABEL_TO_CURRENT(trap.key);
					INSTRUCTION(Ins::LoadException());
					INSTRUCTION(Ins::StoreLocalVar(variableIndex));
				}

				void GenerateFinallyAndRaise(WfTryStatement* node, vint variableIndex)
				{
					GenerateStatementInstructions(context, node->finallyStatement);
					INSTRUCTION(Ins::LoadLocalVar(variableIndex));
					INSTRUCTION(Ins::RaiseException());
				}

				void Visit(WfTryStatement* node)override
				{
					// try
					auto trap1 = GenerateTryProtected(node, node->protectedStatement, node->finallyStatement);
					Pair<vint, vint> trap2 = { -1,-1 };
					auto variableIndex = GenerateExceptionVariable(node);

					// catch
					{
						GenerateTrap(node, variableIndex, trap1);
						if (node->catchStatement)
						{
							if (node->finallyStatement)
							{
								trap2 = GenerateTryProtected(node, node->catchStatement, node->finallyStatement);
								GenerateTrap(node, variableIndex, trap2);
								GenerateFinallyAndRaise(node, variableIndex);
							}
							else
							{
								GenerateStatementInstructions(context, node->catchStatement);
							}
						}
						else
						{
							GenerateFinallyAndRaise(node, variableIndex);
						}
					}

					// finally
					FILL_LABEL_TO_CURRENT(trap1.value);
					if (trap2.value != -1)
					{
						FILL_LABEL_TO_CURRENT(trap2.value);
					}
					if (node->finallyStatement)
					{
						GenerateStatementInstructions(context, node->finallyStatement);
					}
				}

				void Visit(WfBlockStatement* node)override
				{
					Ptr<WfCodegenScopeContext> blockContext;
					if (node->endLabel.value != L"")
					{
						blockContext = context.functionContext->PushScopeContext(WfCodegenScopeType::Block, node->endLabel.value);
					}

					for (auto statement : node->statements)
					{
						GenerateStatementInstructions(context, statement);
					}

					if (blockContext)
					{
						vint breakLabelIndex = context.assembly->instructions.Count();
						for (auto index : blockContext->breakInstructions)
						{
							FILL_LABEL_TO_INS(index, breakLabelIndex);
						}
						context.functionContext->PopScopeContext();
					}
				}

				void Visit(WfGotoStatement* node)override
				{
					InlineScopeExitCode(WfCodegenScopeType::Block, false, node->label.value);
					context.functionContext->GetCurrentScopeContext(WfCodegenScopeType::Block, node->label.value)->breakInstructions.Add(INSTRUCTION(Ins::Jump(-1)));
				}

				void Visit(WfExpressionStatement* node)override
				{
					GenerateExpressionInstructions(context, node->expression);
					INSTRUCTION(Ins::Pop());
				}

				void Visit(WfVariableStatement* node)override
				{
					auto manager = context.manager;
					auto scope = manager->nodeScopes[node->variable.Obj()];
					auto symbol = scope->symbols[node->variable->name.value][0].Obj();
					auto function = context.functionContext->function;
					vint index = function->argumentNames.Count() + function->localVariableNames.Add(node->variable->name.value);
					context.functionContext->localVariables.Add(symbol, index);

					GenerateExpressionInstructions(context, node->variable->expression);
					INSTRUCTION(Ins::StoreLocalVar(index));
				}

				void Visit(WfVirtualCseStatement* node)override
				{
					GenerateStatementInstructions(context, node->expandedStatement);
				}

				void Visit(WfCoroutineStatement* node)override
				{
					CHECK_FAIL(L"GenerateStatementInstructionsVisitor::Visit(WfCoroutineStatement*)#Internal error, All coroutine statements do not emit instructions.");
				}

				void Visit(WfStateMachineStatement* node)override
				{
					CHECK_FAIL(L"GenerateStatementInstructionsVisitor::Visit(WfStateMachineStatement*)#Internal error, All state machine statements do not emit instructions.");
				}
			};

#undef EXIT_CODE
#undef FILL_LABEL_TO_CURRENT
#undef FILL_LABEL_TO_INS
#undef INSTRUCTION

			void GenerateStatementInstructions(WfCodegenContext& context, Ptr<WfStatement> statement)
			{
				GenerateStatementInstructionsVisitor visitor(context);
				statement->Accept(&visitor);
			}
		}
	}
}

/***********************************************************************
.\PARSER\WFEXPRESSION.CPP
***********************************************************************/

namespace vl
{
	namespace workflow
	{
		using namespace stream;
		using namespace collections;
		using namespace glr;

/***********************************************************************
Unescaping Functions
***********************************************************************/

		void UnescapeStringInternal(glr::ParsingToken& value, bool formatString)
		{
			value.value = GenerateToStream([&](StreamWriter& writer)
			{
				WString input = formatString ? value.value.Sub(2, value.value.Length() - 3) : value.value.Sub(1, value.value.Length() - 2);
				const wchar_t* reading = input.Buffer();

				while (wchar_t c = *reading++)
				{
					if (c == L'\\')
					{
						switch (wchar_t e = *reading++)
						{
						case L'r':
							writer.WriteChar('\r');
							break;
						case L'n':
							writer.WriteChar('\n');
							break;
						case L't':
							writer.WriteChar('\t');
							break;
						default:
							writer.WriteChar(e);
						}
					}
					else
					{
						writer.WriteChar(c);
					}
				}
			});
		}

		void UnescapeFormatString(glr::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			UnescapeStringInternal(value, true);
		}

		void UnescapeString(glr::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens)
		{
			UnescapeStringInternal(value, false);
		}

		void EscapeString(const WString& text, ParsingWriter& writer)
		{
			writer.WriteChar(L'\"');
			const wchar_t* reading = text.Buffer();
			while (wchar_t c = *reading++)
			{
				switch (c)
				{
				case '\r':
					writer.WriteString(L"\\r");
					break;
				case '\n':
					writer.WriteString(L"\\n");
					break;
				case '\t':
					writer.WriteString(L"\\t");
					break;
				case '\"':
					writer.WriteString(L"\\\"");
					break;
				case '\\':
					writer.WriteString(L"\\\\");
					break;
				default:
					writer.WriteChar(c);
				}
			}
			writer.WriteChar(L'\"');
		}

/***********************************************************************
WorkflowUnescapeVisitor
***********************************************************************/

		class WorkflowUnescapeVisitor : public traverse_visitor::AstVisitor
		{
		protected:
			List<regex::RegexToken>&			tokens;

			void Traverse(WfStringExpression* node) override
			{
				UnescapeString(node->value, tokens);
			}

			void Traverse(WfFormatExpression* node) override
			{
				UnescapeFormatString(node->value, tokens);
			}
		public:
			WorkflowUnescapeVisitor(List<regex::RegexToken>& _tokens)
				:tokens(_tokens)
			{
			}
		};

/***********************************************************************
Parsing
***********************************************************************/

		Ptr<WfType> ParseType(const WString& input, const Parser& parser, vint codeIndex)
		{
			List<regex::RegexToken> tokens;
			parser.Tokenize(input, tokens, codeIndex);
			auto ast = parser.Parse_Type(tokens, codeIndex);
			WorkflowUnescapeVisitor(tokens).InspectInto(ast.Obj());
			return ast;
		}

		Ptr<WfExpression> ParseExpression(const WString& input, const Parser& parser, vint codeIndex)
		{
			List<regex::RegexToken> tokens;
			parser.Tokenize(input, tokens, codeIndex);
			auto ast = parser.Parse_Expression(tokens, codeIndex);
			WorkflowUnescapeVisitor(tokens).InspectInto(ast.Obj());
			return ast;
		}

		Ptr<WfStatement> ParseStatement(const WString& input, const Parser& parser, vint codeIndex)
		{
			List<regex::RegexToken> tokens;
			parser.Tokenize(input, tokens, codeIndex);
			auto ast = parser.Parse_Statement(tokens, codeIndex);
			WorkflowUnescapeVisitor(tokens).InspectInto(ast.Obj());
			return ast;
		}

		Ptr<WfCoProviderStatement> ParseCoProviderStatement(const WString& input, const Parser& parser, vint codeIndex)
		{
			List<regex::RegexToken> tokens;
			parser.Tokenize(input, tokens, codeIndex);
			auto ast = parser.Parse_CoProvider(tokens, codeIndex);
			WorkflowUnescapeVisitor(tokens).InspectInto(ast.Obj());
			return ast;
		}

		Ptr<WfDeclaration> ParseDeclaration(const WString& input, const Parser& parser, vint codeIndex)
		{
			List<regex::RegexToken> tokens;
			parser.Tokenize(input, tokens, codeIndex);
			auto ast = parser.Parse_Declaration(tokens, codeIndex);
			WorkflowUnescapeVisitor(tokens).InspectInto(ast.Obj());
			return ast;
		}

		Ptr<WfModule> ParseModule(const WString& input, const Parser& parser, vint codeIndex)
		{
			List<regex::RegexToken> tokens;
			parser.Tokenize(input, tokens, codeIndex);
			auto ast = parser.Parse_Module(tokens, codeIndex);
			WorkflowUnescapeVisitor(tokens).InspectInto(ast.Obj());
			return ast;
		}

/***********************************************************************
Print (Type)
***********************************************************************/

		class PrintTypeVisitor : public Object, public WfType::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintTypeVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfPredefinedType* node)override
			{
				writer.BeforePrint(node);
				switch (node->name)
				{
				case WfPredefinedTypeName::Void:
					writer.WriteString(L"void");
					break;
				case WfPredefinedTypeName::Object:
					writer.WriteString(L"object");
					break;
				case WfPredefinedTypeName::Interface:
					writer.WriteString(L"interface");
					break;
				case WfPredefinedTypeName::Int:
					writer.WriteString(L"int");
					break;
				case WfPredefinedTypeName::UInt:
					writer.WriteString(L"uint");
					break;
				case WfPredefinedTypeName::Float:
					writer.WriteString(L"float");
					break;
				case WfPredefinedTypeName::Double:
					writer.WriteString(L"double");
					break;
				case WfPredefinedTypeName::String:
					writer.WriteString(L"string");
					break;
				case WfPredefinedTypeName::Char:
					writer.WriteString(L"char");
					break;
				case WfPredefinedTypeName::Bool:
					writer.WriteString(L"bool");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfTopQualifiedType* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"::" + node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfReferenceType* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfRawPointerType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"*");
				writer.AfterPrint(node);
			}

			void Visit(WfSharedPointerType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"^");
				writer.AfterPrint(node);
			}

			void Visit(WfNullableType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"?");
				writer.AfterPrint(node);
			}

			void Visit(WfEnumerableType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"{}");
				writer.AfterPrint(node);
			}

			void Visit(WfMapType* node)override
			{
				writer.BeforePrint(node);
				switch (node->writability)
				{
				case WfMapWritability::Readonly:
					writer.WriteString(L"const ");
					break;
				case WfMapWritability::Writable:
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				WfPrint(node->value, indent, writer);
				writer.WriteString(L"[");
				if (node->key)
				{
					WfPrint(node->key, indent, writer);
				}
				writer.WriteString(L"]");
				writer.AfterPrint(node);
			}

			void Visit(WfObservableListType* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"observe ");
				WfPrint(node->element, indent, writer);
				writer.WriteString(L"[]");
				writer.AfterPrint(node);
			}

			void Visit(WfFunctionType* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"(func ");
				writer.WriteString(L"(");
				for (auto [type, index] : indexed(node->arguments))
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					WfPrint(type, indent, writer);
				}
				writer.WriteString(L")");

				writer.WriteString(L" : (");
				WfPrint(node->result, indent, writer);
				writer.WriteString(L"))");
				writer.AfterPrint(node);
			}

			void Visit(WfChildType* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L"::");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Expression)
***********************************************************************/

		class PrintExpressionVisitor
			: public Object
			, public WfExpression::IVisitor
			, public WfVirtualCfeExpression::IVisitor
			, public WfVirtualCseExpression::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintExpressionVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfThisExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"this");
				writer.AfterPrint(node);
			}

			void Visit(WfTopQualifiedExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"::");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfReferenceExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfOrderedNameExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfOrderedLambdaExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"[");
				WfPrint(node->body, indent, writer);
				writer.WriteString(L"]");
				writer.AfterPrint(node);
			}

			void Visit(WfMemberExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L".");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfChildExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L"::");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}

			void Visit(WfLiteralExpression* node)override
			{
				writer.BeforePrint(node);
				switch (node->value)
				{
				case WfLiteralValue::Null:
					writer.WriteString(L"null");
					break;
				case WfLiteralValue::True:
					writer.WriteString(L"true");
					break;
				case WfLiteralValue::False:
					writer.WriteString(L"false");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfFloatingExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->value.value);
				writer.AfterPrint(node);
			}

			void Visit(WfIntegerExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(node->value.value);
				writer.AfterPrint(node);
			}

			void Visit(WfStringExpression* node)override
			{
				writer.BeforePrint(node);
				EscapeString(node->value.value, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfUnaryExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"(");
				switch (node->op)
				{
				case WfUnaryOperator::Positive:
					writer.WriteString(L"+");
					break;
				case WfUnaryOperator::Negative:
					writer.WriteString(L"-");
					break;
				case WfUnaryOperator::Not:
					writer.WriteString(L"!");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				WfPrint(node->operand, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfBinaryExpression* node)override
			{
				writer.BeforePrint(node);
				if (node->op == WfBinaryOperator::Index)
				{
					WfPrint(node->first, indent, writer);
					writer.WriteString(L"[");
					WfPrint(node->second, indent, writer);
					writer.WriteString(L"]");
				}
				else
				{
					writer.WriteString(L"(");
					WfPrint(node->first, indent, writer);
					switch (node->op)
					{
					case WfBinaryOperator::Assign:
						writer.WriteString(L" = ");
						break;
					case WfBinaryOperator::FlagAnd:
						writer.WriteString(L" & ");
						break;
					case WfBinaryOperator::FlagOr:
						writer.WriteString(L" | ");
						break;
					case WfBinaryOperator::FailedThen:
						writer.WriteString(L" ?? ");
						break;
					case WfBinaryOperator::Exp:
						writer.WriteString(L" ^ ");
						break;
					case WfBinaryOperator::Add:
						writer.WriteString(L" + ");
						break;
					case WfBinaryOperator::Sub:
						writer.WriteString(L" - ");
						break;
					case WfBinaryOperator::Mul:
						writer.WriteString(L" * ");
						break;
					case WfBinaryOperator::Div:
						writer.WriteString(L" / ");
						break;
					case WfBinaryOperator::Mod:
						writer.WriteString(L" % ");
						break;
					case WfBinaryOperator::Shl:
						writer.WriteString(L" shl ");
						break;
					case WfBinaryOperator::Shr:
						writer.WriteString(L" shr ");
						break;
					case WfBinaryOperator::LT:
						writer.WriteString(L" < ");
						break;
					case WfBinaryOperator::GT:
						writer.WriteString(L" > ");
						break;
					case WfBinaryOperator::LE:
						writer.WriteString(L" <= ");
						break;
					case WfBinaryOperator::GE:
						writer.WriteString(L" >= ");
						break;
					case WfBinaryOperator::EQ:
						writer.WriteString(L" == ");
						break;
					case WfBinaryOperator::NE:
						writer.WriteString(L" != ");
						break;
					case WfBinaryOperator::Xor:
						writer.WriteString(L" xor ");
						break;
					case WfBinaryOperator::And:
						writer.WriteString(L" and ");
						break;
					case WfBinaryOperator::Or:
						writer.WriteString(L" or ");
						break;
					default:
						CHECK_FAIL(L"Internal error: Unknown value.");
					}
					WfPrint(node->second, indent, writer);
					writer.WriteString(L")");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfLetExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"let ");
				for (auto [var, index] : indexed(node->variables))
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					writer.BeforePrint(var.Obj());
					writer.WriteString(var->name.value);
					writer.WriteString(L" = ");
					WfPrint(var->value, indent, writer);
					writer.AfterPrint(var.Obj());
				}
				writer.WriteString(L" in (");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfIfExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->condition, indent, writer);
				writer.WriteString(L" ? ");
				WfPrint(node->trueBranch, indent, writer);
				writer.WriteString(L" : ");
				WfPrint(node->falseBranch, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfRangeExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"range ");
				switch (node->beginBoundary)
				{
				case WfRangeBoundary::Exclusive:
					writer.WriteString(L"(");
					break;
				case WfRangeBoundary::Inclusive:
					writer.WriteString(L"[");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				WfPrint(node->begin, indent, writer);
				writer.WriteString(L", ");
				WfPrint(node->end, indent, writer);
				switch (node->beginBoundary)
				{
				case WfRangeBoundary::Exclusive:
					writer.WriteString(L")");
					break;
				case WfRangeBoundary::Inclusive:
					writer.WriteString(L"]");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfSetTestingExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->element, indent, writer);
				switch (node->test)
				{
				case WfSetTesting::In:
					writer.WriteString(L" in ");
					break;
				case WfSetTesting::NotIn:
					writer.WriteString(L" not in ");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				WfPrint(node->collection, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfConstructorExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"{");
				for (auto [argument, index] : indexed(node->arguments))
				{
					if (index > 0)
					{
						writer.WriteString(L" ");
					}
					WfPrint(argument->key, indent, writer);
					if (argument->value)
					{
						writer.WriteString(L" : ");
						WfPrint(argument->value, indent, writer);
					}
					writer.WriteString(L";");
				}
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfInferExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L" of (");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfTypeCastingExpression* node)override
			{
				writer.BeforePrint(node);
				switch (node->strategy)
				{
				case WfTypeCastingStrategy::Strong:
					writer.WriteString(L"(cast (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L") ");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L")");
					break;
				case WfTypeCastingStrategy::Weak:
					writer.WriteString(L"(");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L" as (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L"))");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfTypeTestingExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->expression, indent, writer);
				switch (node->test)
				{
				case WfTypeTesting::IsType:
					writer.WriteString(L" is (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L")");
					break;
				case WfTypeTesting::IsNotType:
					writer.WriteString(L" is not (");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L")");
					break;
				case WfTypeTesting::IsNull:
					writer.WriteString(L" is null");
					break;
				case WfTypeTesting::IsNotNull:
					writer.WriteString(L" is not null");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfTypeOfTypeExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"typeof(");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfTypeOfExpressionExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"type(");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfAttachEventExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"attach(");
				WfPrint(node->event, indent, writer);
				writer.WriteString(L", ");
				WfPrint(node->function, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfDetachEventExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"detach(");
				WfPrint(node->event, indent, writer);
				writer.WriteString(L", ");
				WfPrint(node->handler, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfObserveExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->parent, indent, writer);
				writer.WriteString(L".observe");
				switch (node->observeType)
				{
				case WfObserveType::ExtendedObserve:
					writer.WriteString(L" as ");
					writer.WriteString(node->name.value);
					break;
				case WfObserveType::SimpleObserve:
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.WriteString(L"(");
				WfPrint(node->expression, indent, writer);
				if (node->events.Count() > 0)
				{
					writer.WriteString(L" on ");
					for (auto [argument, index] : indexed(node->events))
					{
						if (index > 0)
						{
							writer.WriteString(L", ");
						}
						WfPrint(argument, indent, writer);
					}
				}
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfCallExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->function, indent, writer);
				writer.WriteString(L"(");
				for (auto [argument, index] : indexed(node->arguments))
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					WfPrint(argument, indent, writer);
				}
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfFunctionExpression* node)override
			{
				writer.BeforePrint(node);
				WfPrint(Ptr<WfDeclaration>(node->function), indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfNewClassExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"new (");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");

				writer.WriteString(L"(");
				for (auto [argument, index] : indexed(node->arguments))
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					WfPrint(argument, indent, writer);
				}
				writer.WriteString(L")");

				writer.AfterPrint(node);
			}

			void Visit(WfNewInterfaceExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"new (");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");

				writer.WriteLine(L"");
				writer.WriteString(indent);
				writer.WriteLine(L"{");
				for (auto [decl, index] : indexed(node->declarations))
				{
					if (index > 0)
					{
						writer.WriteLine(L"");
					}

					writer.WriteString(indent + L"    ");
					WfPrint(decl, indent + L"    ", writer);
					writer.WriteLine(L"");
				}
				writer.WriteString(indent);
				writer.WriteString(L"}");

				writer.AfterPrint(node);
			}

			void Visit(WfVirtualCfeExpression* node)override
			{
				if (node->expandedExpression)
				{
					writer.BeforePrint(node);
					WfPrint(node->expandedExpression, indent, writer);
					writer.AfterPrint(node);
				}
				else
				{
					node->Accept((WfVirtualCfeExpression::IVisitor*)this);
				}
			}

			void Visit(WfFormatExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"$");
				EscapeString(node->value.value, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfVirtualCseExpression* node)override
			{
				if (node->expandedExpression)
				{
					writer.BeforePrint(node);
					WfPrint(node->expandedExpression, indent, writer);
					writer.AfterPrint(node);
				}
				else
				{
					node->Accept((WfVirtualCseExpression::IVisitor*)this);
				}
			}

			void Visit(WfBindExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"bind(");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfNewCoroutineExpression* node)override
			{
				writer.BeforePrint(node);
				if (node->name.value == L"")
				{
					writer.WriteLine(L"$coroutine");
				}
				else
				{
					writer.WriteString(L"$coroutine(");
					writer.WriteString(node->name.value);
					writer.WriteLine(L")");
				}
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfMixinCastExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"new (");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L")");

				writer.WriteString(L"(using ");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L")");
				writer.AfterPrint(node);
			}

			void Visit(WfExpectedTypeCastExpression* node)override
			{
				writer.BeforePrint(node);
				switch (node->strategy)
				{
				case WfTypeCastingStrategy::Strong:
					writer.WriteString(L"(cast * ");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L")");
					break;
				case WfTypeCastingStrategy::Weak:
					writer.WriteString(L"(");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L" as *)");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfCoOperatorExpression* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"$.");
				writer.WriteString(node->name.value);
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Statement)
***********************************************************************/

		class PrintStatementVisitor
			: public Object
			, public WfStatement::IVisitor
			, public WfVirtualCseStatement::IVisitor
			, public WfCoroutineStatement::IVisitor
			, public WfStateMachineStatement::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintStatementVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfBreakStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"break;");
				writer.AfterPrint(node);
			}

			void Visit(WfContinueStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"continue;");
				writer.AfterPrint(node);
			}

			void Visit(WfReturnStatement* node)override
			{
				writer.BeforePrint(node);
				if (node->expression)
				{
					writer.WriteString(L"return ");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L";");
				}
				else
				{
					writer.WriteString(L"return;");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfDeleteStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"delete ");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L";");
				writer.AfterPrint(node);
			}

			void Visit(WfRaiseExceptionStatement* node)override
			{
				writer.BeforePrint(node);
				if (node->expression)
				{
					writer.WriteString(L"raise ");
					WfPrint(node->expression, indent, writer);
					writer.WriteString(L";");
				}
				else
				{
					writer.WriteString(L"raise;");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfIfStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"if (");
				if (node->type)
				{
					writer.WriteString(L"var ");
					writer.WriteString(node->name.value);
					writer.WriteString(L" : ");
					WfPrint(node->type, indent, writer);
					writer.WriteString(L" = ");
				}
				WfPrint(node->expression, indent, writer);
				writer.WriteLine(L")");

				writer.WriteString(indent);
				WfPrint(node->trueBranch, indent, writer);
				if (node->falseBranch)
				{
					writer.WriteLine(L"");
					writer.WriteString(indent);
					if (node->falseBranch.Cast<WfIfStatement>())
					{
						writer.WriteString(L"else ");
						WfPrint(node->falseBranch, indent, writer);
					}
					else
					{
						writer.WriteLine(L"else");
						writer.WriteString(indent);
						WfPrint(node->falseBranch, indent, writer);
					}
				}
				writer.AfterPrint(node);
			}

			void Visit(WfWhileStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"while (");
				WfPrint(node->condition, indent, writer);
				writer.WriteLine(L")");
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfTryStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"try");
				writer.WriteString(indent);
				WfPrint(node->protectedStatement, indent, writer);

				if (node->catchStatement)
				{
					writer.WriteLine(L"");
					writer.WriteString(indent);
					writer.WriteString(L"catch (");
					writer.WriteString(node->name.value);
					writer.WriteLine(L")");
					writer.WriteString(indent);
					WfPrint(node->catchStatement, indent, writer);
				}

				if (node->finallyStatement)
				{
					writer.WriteLine(L"");
					writer.WriteString(indent);
					writer.WriteLine(L"finally");
					writer.WriteString(indent);
					WfPrint(node->finallyStatement, indent, writer);
				}
				writer.AfterPrint(node);
			}

			void Visit(WfBlockStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"{");
				for (auto statement : node->statements)
				{
					writer.WriteString(indent + L"    ");
					WfPrint(statement, indent + L"    ", writer);
					writer.WriteLine(L"");
				}

				if (node->endLabel.value != L"")
				{
					writer.WriteString(indent + L"    ");
					writer.WriteString(node->endLabel.value);
					writer.WriteLine(L":;");
				}
				writer.WriteString(indent);
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfGotoStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"goto ");
				writer.WriteString(node->label.value);
				writer.WriteString(L";");
				writer.AfterPrint(node);
			}

			void Visit(WfExpressionStatement* node)override
			{
				writer.BeforePrint(node);
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L";");
				writer.AfterPrint(node);
			}

			void Visit(WfVariableStatement* node)override
			{
				writer.BeforePrint(node);
				WfPrint(Ptr<WfDeclaration>(node->variable), indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfVirtualCseStatement* node)override
			{
				if (node->expandedStatement)
				{
					writer.BeforePrint(node);
					WfPrint(node->expandedStatement, indent, writer);
					writer.AfterPrint(node);
				}
				else
				{
					node->Accept((WfVirtualCseStatement::IVisitor*)this);
				}
			}

			void Visit(WfSwitchStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"switch (");
				WfPrint(node->expression, indent, writer);
				writer.WriteLine(L")");

				writer.WriteString(indent);
				writer.WriteLine(L"{");

				for (auto switchCase : node->caseBranches)
				{
					writer.BeforePrint(switchCase.Obj());
					writer.WriteString(indent);
					writer.WriteString(L"    case ");
					WfPrint(switchCase->expression, indent, writer);
					writer.WriteLine(L":");
					writer.WriteString(indent + L"    ");
					WfPrint(switchCase->statement, indent + L"    ", writer);
					writer.AfterPrint(switchCase.Obj());
					writer.WriteLine(L"");
				}
				if (node->defaultBranch)
				{
					writer.WriteString(indent);
					writer.WriteLine(L"    default:");
					writer.WriteString(indent + L"    ");
					WfPrint(node->defaultBranch, indent + L"    ", writer);
					writer.WriteLine(L"");
				}

				writer.WriteString(indent);
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfForEachStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"for (");
				writer.WriteString(node->name.value);
				writer.WriteString(L" in ");
				switch (node->direction)
				{
				case WfForEachDirection::Reversed:
					writer.WriteString(L"reversed ");
					break;
				case WfForEachDirection::Normal:
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				WfPrint(node->collection, indent, writer);
				writer.WriteLine(L")");
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfCoProviderStatement* node)override
			{
				writer.BeforePrint(node);
				if (node->name.value == L"")
				{
					writer.WriteString(L"$");
				}
				else
				{
					writer.WriteString(node->name.value);
					writer.WriteString(L" ");
				}
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfCoroutineStatement* node)override
			{
				node->Accept((WfCoroutineStatement::IVisitor*)this);
			}

			void Visit(WfCoPauseStatement* node)override
			{
				writer.BeforePrint(node);
				if (node->statement)
				{
					writer.WriteLine(L"$pause");
					writer.WriteString(indent);
					WfPrint(node->statement, indent, writer);
				}
				else
				{
					writer.WriteString(L"$pause;");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfCoOperatorStatement* node)override
			{
				if (node->varName.value != L"")
				{
					writer.WriteString(L"var ");
					writer.WriteString(node->varName.value);
					writer.WriteString(L" = ");
				}
				writer.WriteString(node->opName.value);

				for (auto [argument, index] : indexed(node->arguments))
				{
					writer.WriteString(index == 0 ? L" " : L", ");
					WfPrint(argument, indent, writer);
				}
				writer.WriteString(L";");
			}

			void Visit(WfStateMachineStatement* node)override
			{
				node->Accept((WfStateMachineStatement::IVisitor*)this);
			}

			void Visit(WfStateSwitchStatement* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"switch (");
				switch (node->type)
				{
				case WfStateSwitchType::Default:
					writer.WriteLine(L"raise)");
					break;
				case WfStateSwitchType::Pass:
					writer.WriteLine(L"continue)");
					break;
				case WfStateSwitchType::PassAndReturn:
					writer.WriteLine(L"continue, return)");
					break;
				case WfStateSwitchType::Ignore:
					writer.WriteLine(L")");
					break;
				case WfStateSwitchType::IgnoreAndReturn:
					writer.WriteLine(L"return)");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}

				writer.WriteString(indent);
				writer.WriteLine(L"{");

				for (auto switchCase : node->caseBranches)
				{
					writer.BeforePrint(switchCase.Obj());
					writer.WriteString(indent);
					writer.WriteString(L"    case ");
					writer.WriteString(switchCase->name.value);
					writer.WriteString(L"(");
					for (auto [argument, index] : indexed(switchCase->arguments))
					{
						if (index != 0) writer.WriteString(L", ");
						writer.BeforePrint(argument.Obj());
						writer.WriteString(argument->name.value);
						writer.AfterPrint(argument.Obj());
					}
					writer.WriteLine(L"):");
					writer.WriteString(indent + L"    ");
					WfPrint(switchCase->statement, indent + L"    ", writer);
					writer.AfterPrint(switchCase.Obj());
					writer.WriteLine(L"");
				}

				writer.WriteString(indent);
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfStateInvokeStatement* node)override
			{
				writer.BeforePrint(node);
				switch (node->type)
				{
				case WfStateInvokeType::Goto:
					writer.WriteString(L"$goto_state ");
					break;
				case WfStateInvokeType::Push:
					writer.WriteString(L"push_state ");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}

				writer.WriteString(node->name.value);
				writer.WriteString(L"(");
				for (auto [argument, index] : indexed(node->arguments))
				{
					if (index != 0) writer.WriteString(L", ");
					WfPrint(argument, indent, writer);
				}
				writer.WriteString(L");");
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Declaration)
***********************************************************************/

		class PrintDeclarationVisitor
			: public Object
			, public WfDeclaration::IVisitor
			, public WfVirtualCfeDeclaration::IVisitor
			, public WfVirtualCseDeclaration::IVisitor
		{
		public:
			WString								indent;
			ParsingWriter&						writer;

			PrintDeclarationVisitor(const WString& _indent, ParsingWriter& _writer)
				:indent(_indent), writer(_writer)
			{
			}

			void Visit(WfNamespaceDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"namespace " + node->name.value);
				writer.WriteString(indent);
				writer.WriteLine(L"{");
				for (auto [decl, index] : indexed(node->declarations))
				{
					if (index != 0)
					{
						writer.WriteLine(L"");
					}
					writer.WriteString(indent + L"    ");
					WfPrint(decl, indent + L"    ", writer);
					writer.WriteLine(L"");
				}
				writer.WriteString(indent);
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfFunctionDeclaration* node)override
			{
				switch (node->functionKind)
				{
				case WfFunctionKind::Normal:
					break;
				case WfFunctionKind::Static:
					writer.WriteString(L"static ");
					break;
				case WfFunctionKind::Override:
					writer.WriteString(L"override ");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}

				writer.BeforePrint(node);
				writer.WriteString(L"func ");
				switch (node->anonymity)
				{
				case WfFunctionAnonymity::Named:
					writer.WriteString(node->name.value);
					break;
				case WfFunctionAnonymity::Anonymous:
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}

				writer.WriteString(L"(");
				for (auto [argument, index] : indexed(node->arguments))
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					writer.BeforePrint(argument.Obj());
					for (auto attribute : argument->attributes)
					{
						WfPrint(attribute, indent, writer);
						writer.WriteString(L" ");
					}
					writer.WriteString(argument->name.value);
					writer.WriteString(L" : ");
					WfPrint(argument->type, indent, writer);
					writer.AfterPrint(argument.Obj());
				}
				writer.WriteString(L")");

				writer.WriteString(L" : (");
				WfPrint(node->returnType, indent, writer);
				writer.WriteString(L")");
				if (node->statement)
				{
					writer.WriteLine(L"");

					writer.WriteString(indent);
					WfPrint(node->statement, indent, writer);
				}
				else
				{
					writer.WriteString(L";");
				}
				writer.AfterPrint(node);
			}

			void Visit(WfVariableDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"var ");
				writer.WriteString(node->name.value);
				if (node->type)
				{
					writer.WriteString(L" : ");
					WfPrint(node->type, indent, writer);
				}
				writer.WriteString(L" = ");
				WfPrint(node->expression, indent, writer);
				writer.WriteString(L";");
				writer.AfterPrint(node);
			}

			void Visit(WfEventDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"event ");
				writer.WriteString(node->name.value);
				writer.WriteString(L"(");
				for (auto [type, index] : indexed(node->arguments))
				{
					if (index != 0)
					{
						writer.WriteString(L", ");
					}
					WfPrint(type, indent, writer);
				}
				writer.WriteString(L");");
				writer.AfterPrint(node);
			}

			void Visit(WfPropertyDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"prop ");
				writer.WriteString(node->name.value);
				writer.WriteString(L" : ");
				WfPrint(node->type, indent, writer);
				writer.WriteString(L"{");
				writer.WriteString(node->getter.value);
				if (node->setter.value != L"")
				{
					writer.WriteString(L", ");
					writer.WriteString(node->setter.value);
				}
				if (node->valueChangedEvent.value != L"")
				{
					writer.WriteString(L" : ");
					writer.WriteString(node->valueChangedEvent.value);
				}
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfStaticInitDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"static");
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfConstructorDeclaration* node)override
			{
				writer.BeforePrint(node);
				switch (node->constructorType)
				{
				case WfConstructorType::RawPtr:
					writer.WriteString(L"new* ");
					break;
				case WfConstructorType::SharedPtr:
					writer.WriteString(L"new ");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				
				writer.WriteString(L"(");
				for (auto [argument, index] : indexed(node->arguments))
				{
					if (index > 0)
					{
						writer.WriteString(L", ");
					}
					writer.BeforePrint(argument.Obj());
					writer.WriteString(argument->name.value);
					writer.WriteString(L" : ");
					WfPrint(argument->type, indent, writer);
					writer.AfterPrint(argument.Obj());
				}
				writer.WriteString(L")");
				for (auto [call, callIndex] : indexed(node->baseConstructorCalls))
				{
					writer.WriteLine(L"");
					writer.WriteString(indent + L"    ");
					if (callIndex == 0)
					{
						writer.WriteString(L":");
					}
					else
					{
						writer.WriteString(L",");
					}
					writer.BeforePrint(call.Obj());
					WfPrint(call->type, indent + L"    ", writer);
					writer.WriteString(L"(");
					for (auto [argument, argumentIndex] : indexed(call->arguments))
					{
						if (argumentIndex != 0)
						{
							writer.WriteString(L", ");
						}
						WfPrint(argument, indent + L"    ", writer);
					}
					writer.WriteString(L")");
					writer.AfterPrint(call.Obj());
				}

				writer.WriteLine(L"");
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfDestructorDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"delete");
				writer.WriteString(indent);
				WfPrint(node->statement, indent, writer);
				writer.AfterPrint(node);
			}

			void Visit(WfClassDeclaration* node)override
			{
				writer.BeforePrint(node);
				switch (node->kind)
				{
				case WfClassKind::Class:
					writer.WriteString(L"class ");
					break;
				case WfClassKind::Interface:
					writer.WriteString(L"interface ");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.WriteString(node->name.value);
				switch (node->kind)
				{
				case WfClassKind::Class:
					switch (node->constructorType)
					{
					case WfConstructorType::Undefined:
						break;
					default:
						CHECK_FAIL(L"Internal error: Unknown value.");
					}
					break;
				case WfClassKind::Interface:
					switch (node->constructorType)
					{
					case WfConstructorType::RawPtr:
						writer.WriteString(L"*");
					case WfConstructorType::SharedPtr:
						break;
					default:
						CHECK_FAIL(L"Internal error: Unknown value.");
					}
					break;
				default:;
				}

				for (auto [type, index] : indexed(node->baseTypes))
				{
					if (index == 0)
					{
						writer.WriteString(L" : ");
					}
					else
					{
						writer.WriteString(L", ");
					}
					WfPrint(type, indent, writer);
				}

				writer.WriteLine(L"");
				writer.WriteLine(indent + L"{");

				for (auto [decl, index] : indexed(node->declarations))
				{
					if (index > 0)
					{
						writer.WriteLine(L"");
					}

					writer.WriteString(indent + L"    ");
					WfPrint(decl, indent + L"    ", writer);
					writer.WriteLine(L"");
				}

				writer.WriteString(indent + L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfEnumDeclaration* node)override
			{
				writer.BeforePrint(node);
				switch (node->kind)
				{
				case WfEnumKind::Normal:
					writer.WriteString(L"enum ");
					break;
				case WfEnumKind::Flag:
					writer.WriteString(L"flagenum ");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.WriteLine(node->name.value);
				writer.WriteLine(indent + L"{");

				auto newIndent = indent + L"    ";
				for (auto item : node->items)
				{
					writer.BeforePrint(item.Obj());
					for (auto attribute : item->attributes)
					{
						writer.WriteString(newIndent);
						WfPrint(attribute, newIndent, writer);
						writer.WriteLine(L"");
					}
					writer.WriteString(newIndent);
					writer.WriteString(item->name.value);
					writer.WriteString(L" = ");
					switch (item->kind)
					{
					case WfEnumItemKind::Constant:
						writer.WriteString(item->number.value);
						break;
					case WfEnumItemKind::Intersection:
						for (auto [itemInt, index] : indexed(item->intersections))
						{
							if (index != 0)writer.WriteString(L" | ");
							writer.WriteString(itemInt->name.value);
						}
						break;
					default:
						CHECK_FAIL(L"Internal error: Unknown value.");
					}
					writer.AfterPrint(item.Obj());
					writer.WriteLine(L",");
				}

				writer.WriteString(indent + L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfStructDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"struct ");
				writer.WriteLine(node->name.value);
				writer.WriteLine(indent + L"{");

				auto newIndent = indent + L"    ";
				for (auto member : node->members)
				{
					writer.BeforePrint(member.Obj());
					for (auto attribute : member->attributes)
					{
						writer.WriteString(newIndent);
						WfPrint(attribute, newIndent, writer);
						writer.WriteLine(L"");
					}
					writer.WriteString(newIndent);
					writer.WriteString(member->name.value);
					writer.WriteString(L" : ");
					WfPrint(member->type, newIndent, writer);
					writer.WriteLine(L";");
					writer.AfterPrint(member.Obj());
				}

				writer.WriteString(indent + L"}");
				writer.AfterPrint(node);
			}

			void PrintExpandedDeclarations(List<Ptr<WfDeclaration>>& decls)
			{
				for (auto [decl, index] : indexed(decls))
				{
					if (index > 0)
					{
						writer.WriteLine(L"");
						writer.WriteString(indent);
					}
					WfPrint(decl, indent, writer);
					if (index < decls.Count() - 1)
					{
						writer.WriteLine(L"");
					}
				}
			}

			void Visit(WfVirtualCfeDeclaration* node)override
			{
				if (node->expandedDeclarations.Count() > 0)
				{
					writer.BeforePrint(node);
					PrintExpandedDeclarations(node->expandedDeclarations);
					writer.AfterPrint(node);
				}
				else
				{
					node->Accept(static_cast<WfVirtualCfeDeclaration::IVisitor*>(this));
				}
			}

			void Visit(WfAutoPropertyDeclaration* node)override
			{
				switch (node->functionKind)
				{
				case WfFunctionKind::Normal:
					break;
				case WfFunctionKind::Static:
					writer.WriteString(L"static ");
					break;
				case WfFunctionKind::Override:
					writer.WriteString(L"override ");
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}

				writer.BeforePrint(node);
				writer.WriteString(L"prop ");
				writer.WriteString(node->name.value);
				writer.WriteString(L" : ");
				WfPrint(node->type, indent, writer);
				if (node->expression)
				{
					writer.WriteString(L" = ");
					WfPrint(node->expression, indent, writer);
				}
				writer.WriteString(L" {");
				switch (node->configConst)
				{
				case WfAPConst::Readonly:
					switch (node->configObserve)
					{
					case WfAPObserve::NotObservable:
						writer.WriteString(L"const, not observe");
						break;
					case WfAPObserve::Observable:
						writer.WriteString(L"const");
						break;
					default:
						CHECK_FAIL(L"Internal error: Unknown value.");
					}
					break;
				case WfAPConst::Writable:
					switch (node->configObserve)
					{
					case WfAPObserve::NotObservable:
						writer.WriteString(L"not observe");
						break;
					case WfAPObserve::Observable:
						break;
					default:
						CHECK_FAIL(L"Internal error: Unknown value.");
					}
					break;
				default:
					CHECK_FAIL(L"Internal error: Unknown value.");
				}
				writer.WriteString(L"}");
				writer.AfterPrint(node);
			}

			void Visit(WfCastResultInterfaceDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteString(L"$interface ");
				writer.WriteString(node->name.value);
				writer.WriteString(L" : ");
				WfPrint(node->baseType, indent, writer);
				writer.WriteString(L"<");
				WfPrint(node->elementType, indent, writer);
				writer.WriteString(L">;");
				writer.AfterPrint(node);
			}

			void Visit(WfVirtualCseDeclaration* node)override
			{
				if (node->expandedDeclarations.Count() > 0)
				{
					writer.BeforePrint(node);
					PrintExpandedDeclarations(node->expandedDeclarations);
					writer.AfterPrint(node);
				}
				else
				{
					node->Accept(static_cast<WfVirtualCseDeclaration::IVisitor*>(this));
				}
			}

			void Visit(WfStateMachineDeclaration* node)override
			{
				writer.BeforePrint(node);
				writer.WriteLine(L"$state_machine");
				writer.WriteLine(indent + L"{");

				for (auto [input, index] : indexed(node->inputs))
				{
					if (index != 0) writer.WriteLine(L"");

					writer.BeforePrint(input.Obj());
					writer.WriteString(indent + L"    $state_input ");
					writer.WriteString(input->name.value);
					writer.WriteString(L"(");
					for (auto [argument, index] : indexed(input->arguments))
					{
						if (index > 0)
						{
							writer.WriteString(L", ");
						}
						writer.BeforePrint(argument.Obj());
						writer.WriteString(argument->name.value);
						writer.WriteString(L" : ");
						WfPrint(argument->type, indent, writer);
						writer.AfterPrint(argument.Obj());
					}
					writer.WriteLine(L");");
					writer.AfterPrint(input.Obj());
				}

				for (auto [state, index] : indexed(node->states))
				{
					if (index != 0 || node->inputs.Count() > 0) writer.WriteLine(L"");

					writer.BeforePrint(state.Obj());
					writer.WriteString(indent + L"    $state ");
					if (state->name.value == L"")
					{
						writer.WriteString(L"default");
					}
					else
					{
						writer.WriteString(state->name.value);
					}
					writer.WriteString(L"(");
					for (auto [argument, index] : indexed(state->arguments))
					{
						if (index > 0)
						{
							writer.WriteString(L", ");
						}
						writer.BeforePrint(argument.Obj());
						writer.WriteString(argument->name.value);
						writer.WriteString(L" : ");
						WfPrint(argument->type, indent, writer);
						writer.AfterPrint(argument.Obj());
					}
					writer.WriteLine(L")");
					writer.WriteString(indent + L"    ");
					WfPrint(state->statement, indent + L"    ", writer);
					writer.AfterPrint(state.Obj());
					writer.WriteLine(L"");
				}

				writer.WriteString(indent + L"}");
				writer.AfterPrint(node);
			}
		};

/***********************************************************************
Print (Module)
***********************************************************************/

		void WfPrint(Ptr<WfAttribute> node, const WString& indent, glr::ParsingWriter& writer)
		{
			writer.BeforePrint(node.Obj());
			writer.WriteString(L"@");
			writer.WriteString(node->category.value);
			writer.WriteString(L":");
			writer.WriteString(node->name.value);
			if (node->value)
			{
				writer.WriteString(L"(");
				WfPrint(node->value, indent, writer);
				writer.WriteString(L")");
			}
			writer.AfterPrint(node.Obj());
		}

		void WfPrint(Ptr<WfType> node, const WString& indent, glr::ParsingWriter& writer)
		{
			PrintTypeVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfExpression> node, const WString& indent, glr::ParsingWriter& writer)
		{
			PrintExpressionVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfStatement> node, const WString& indent, glr::ParsingWriter& writer)
		{
			PrintStatementVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfDeclaration> node, const WString& indent, glr::ParsingWriter& writer)
		{
			for (auto attribute : node->attributes)
			{
				WfPrint(attribute, indent, writer);
				writer.WriteLine(L"");
				writer.WriteString(indent);
			}

			PrintDeclarationVisitor visitor(indent, writer);
			node->Accept(&visitor);
		}

		void WfPrint(Ptr<WfModule> node, const WString& indent, glr::ParsingWriter& writer)
		{
			writer.WriteString(indent);
			switch (node->moduleType)
			{
			case WfModuleType::Module:
				writer.WriteLine(L"module " + node->name.value + L";");
				break;
			case WfModuleType::Unit:
				writer.WriteLine(L"unit " + node->name.value + L";");
				break;
			default:
				CHECK_FAIL(L"Internal error: Unknown value.");
			}

			for (auto path : node->paths)
			{
				writer.WriteString(indent);
				writer.WriteString(L"using ");
				for (auto [item, index] : indexed(path->items))
				{
					if (index > 0)
					{
						writer.WriteString(L"::");
					}
					for (auto fragment : item->fragments)
					{
						if (auto name = fragment.Cast<WfModuleUsingNameFragment>())
						{
							writer.WriteString(name->name.value);
						}
						else
						{
							writer.WriteString(L"*");
						}
					}
				}
				writer.WriteLine(L";");
			}

			for (auto decl : node->declarations)
			{
				writer.WriteLine(L"");
				writer.WriteString(indent);
				WfPrint(decl, indent, writer);
				writer.WriteLine(L"");
			}
		}

/***********************************************************************
Print (Module)
***********************************************************************/

		void WfPrint(Ptr<WfAttribute> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfType> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfExpression> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfStatement> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfDeclaration> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}

		void WfPrint(Ptr<WfModule> node, const WString& indent, stream::TextWriter& writer)
		{
			ParsingWriter parsingWriter(writer);
			WfPrint(node, indent, parsingWriter);
		}
	}
}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow
{
/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

	void WfPredefinedType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfTopQualifiedType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfReferenceType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfRawPointerType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfSharedPointerType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfNullableType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfEnumerableType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfMapType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfObservableListType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfFunctionType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfChildType::Accept(WfType::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfNamespaceDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfFunctionDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfVariableDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfEventDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfPropertyDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfStaticInitDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfConstructorDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfDestructorDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfClassDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfEnumDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfStructDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfVirtualCfeDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfAutoPropertyDeclaration::Accept(WfVirtualCfeDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfCastResultInterfaceDeclaration::Accept(WfVirtualCfeDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfVirtualCseDeclaration::Accept(WfDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfStateMachineDeclaration::Accept(WfVirtualCseDeclaration::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfBreakStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfContinueStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfReturnStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfDeleteStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfRaiseExceptionStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfIfStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfWhileStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfTryStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfBlockStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfGotoStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfVariableStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfExpressionStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfVirtualCseStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfForEachStatement::Accept(WfVirtualCseStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfSwitchStatement::Accept(WfVirtualCseStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfCoProviderStatement::Accept(WfVirtualCseStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfCoroutineStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfCoPauseStatement::Accept(WfCoroutineStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfCoOperatorStatement::Accept(WfCoroutineStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfStateMachineStatement::Accept(WfStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfStateSwitchStatement::Accept(WfStateMachineStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfStateInvokeStatement::Accept(WfStateMachineStatement::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfThisExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfTopQualifiedExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfReferenceExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfOrderedNameExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfOrderedLambdaExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfMemberExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfChildExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfLiteralExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfFloatingExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfIntegerExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfStringExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfUnaryExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfBinaryExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfLetExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfIfExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfRangeExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfSetTestingExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfConstructorExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfInferExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfTypeCastingExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfTypeTestingExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfTypeOfTypeExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfTypeOfExpressionExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfAttachEventExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfDetachEventExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfObserveExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfCallExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfFunctionExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfNewClassExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfNewInterfaceExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfVirtualCfeExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfFormatExpression::Accept(WfVirtualCfeExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfVirtualCseExpression::Accept(WfExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfBindExpression::Accept(WfVirtualCseExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfNewCoroutineExpression::Accept(WfVirtualCseExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfMixinCastExpression::Accept(WfVirtualCseExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfExpectedTypeCastExpression::Accept(WfVirtualCseExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfCoOperatorExpression::Accept(WfVirtualCseExpression::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfModuleUsingNameFragment::Accept(WfModuleUsingFragment::IVisitor* visitor)
	{
		visitor->Visit(this);
	}

	void WfModuleUsingWildCardFragment::Accept(WfModuleUsingFragment::IVisitor* visitor)
	{
		visitor->Visit(this);
	}
}
namespace vl::reflection::description
{
#ifndef VCZH_DEBUG_NO_REFLECTION

	IMPL_TYPE_INFO_RENAME(vl::workflow::WfType, system::workflow::WfType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfType::IVisitor, system::workflow::WfType::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfExpression, system::workflow::WfExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfExpression::IVisitor, system::workflow::WfExpression::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStatement, system::workflow::WfStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStatement::IVisitor, system::workflow::WfStatement::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfAttribute, system::workflow::WfAttribute)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfDeclaration, system::workflow::WfDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfDeclaration::IVisitor, system::workflow::WfDeclaration::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionKind, system::workflow::WfFunctionKind)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfPredefinedTypeName, system::workflow::WfPredefinedTypeName)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfPredefinedType, system::workflow::WfPredefinedType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTopQualifiedType, system::workflow::WfTopQualifiedType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfReferenceType, system::workflow::WfReferenceType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfRawPointerType, system::workflow::WfRawPointerType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfSharedPointerType, system::workflow::WfSharedPointerType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfNullableType, system::workflow::WfNullableType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfEnumerableType, system::workflow::WfEnumerableType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfMapWritability, system::workflow::WfMapWritability)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfMapType, system::workflow::WfMapType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfObservableListType, system::workflow::WfObservableListType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionType, system::workflow::WfFunctionType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfChildType, system::workflow::WfChildType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfNamespaceDeclaration, system::workflow::WfNamespaceDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionArgument, system::workflow::WfFunctionArgument)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionAnonymity, system::workflow::WfFunctionAnonymity)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionDeclaration, system::workflow::WfFunctionDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVariableDeclaration, system::workflow::WfVariableDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfEventDeclaration, system::workflow::WfEventDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfPropertyDeclaration, system::workflow::WfPropertyDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStaticInitDeclaration, system::workflow::WfStaticInitDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfClassKind, system::workflow::WfClassKind)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfConstructorType, system::workflow::WfConstructorType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfBaseConstructorCall, system::workflow::WfBaseConstructorCall)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfConstructorDeclaration, system::workflow::WfConstructorDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfDestructorDeclaration, system::workflow::WfDestructorDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfClassDeclaration, system::workflow::WfClassDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfEnumKind, system::workflow::WfEnumKind)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfEnumItemKind, system::workflow::WfEnumItemKind)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfEnumItemIntersection, system::workflow::WfEnumItemIntersection)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfEnumItem, system::workflow::WfEnumItem)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfEnumDeclaration, system::workflow::WfEnumDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStructMember, system::workflow::WfStructMember)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStructDeclaration, system::workflow::WfStructDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCfeDeclaration, system::workflow::WfVirtualCfeDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCfeDeclaration::IVisitor, system::workflow::WfVirtualCfeDeclaration::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfAPConst, system::workflow::WfAPConst)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfAPObserve, system::workflow::WfAPObserve)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfAutoPropertyDeclaration, system::workflow::WfAutoPropertyDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCastResultInterfaceDeclaration, system::workflow::WfCastResultInterfaceDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCseDeclaration, system::workflow::WfVirtualCseDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCseDeclaration::IVisitor, system::workflow::WfVirtualCseDeclaration::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateInput, system::workflow::WfStateInput)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateDeclaration, system::workflow::WfStateDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateMachineDeclaration, system::workflow::WfStateMachineDeclaration)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfBreakStatement, system::workflow::WfBreakStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfContinueStatement, system::workflow::WfContinueStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfReturnStatement, system::workflow::WfReturnStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfDeleteStatement, system::workflow::WfDeleteStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfRaiseExceptionStatement, system::workflow::WfRaiseExceptionStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfIfStatement, system::workflow::WfIfStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfWhileStatement, system::workflow::WfWhileStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTryStatement, system::workflow::WfTryStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfBlockStatement, system::workflow::WfBlockStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfGotoStatement, system::workflow::WfGotoStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVariableStatement, system::workflow::WfVariableStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfExpressionStatement, system::workflow::WfExpressionStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCseStatement, system::workflow::WfVirtualCseStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCseStatement::IVisitor, system::workflow::WfVirtualCseStatement::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfForEachDirection, system::workflow::WfForEachDirection)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfForEachStatement, system::workflow::WfForEachStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfSwitchCase, system::workflow::WfSwitchCase)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfSwitchStatement, system::workflow::WfSwitchStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCoProviderStatement, system::workflow::WfCoProviderStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCoroutineStatement, system::workflow::WfCoroutineStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCoroutineStatement::IVisitor, system::workflow::WfCoroutineStatement::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCoPauseStatement, system::workflow::WfCoPauseStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCoOperatorStatement, system::workflow::WfCoOperatorStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateSwitchType, system::workflow::WfStateSwitchType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateInvokeType, system::workflow::WfStateInvokeType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateMachineStatement, system::workflow::WfStateMachineStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateMachineStatement::IVisitor, system::workflow::WfStateMachineStatement::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateSwitchArgument, system::workflow::WfStateSwitchArgument)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateSwitchCase, system::workflow::WfStateSwitchCase)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateSwitchStatement, system::workflow::WfStateSwitchStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStateInvokeStatement, system::workflow::WfStateInvokeStatement)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfThisExpression, system::workflow::WfThisExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTopQualifiedExpression, system::workflow::WfTopQualifiedExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfReferenceExpression, system::workflow::WfReferenceExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfOrderedNameExpression, system::workflow::WfOrderedNameExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfOrderedLambdaExpression, system::workflow::WfOrderedLambdaExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfMemberExpression, system::workflow::WfMemberExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfChildExpression, system::workflow::WfChildExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfLiteralValue, system::workflow::WfLiteralValue)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfLiteralExpression, system::workflow::WfLiteralExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFloatingExpression, system::workflow::WfFloatingExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfIntegerExpression, system::workflow::WfIntegerExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfStringExpression, system::workflow::WfStringExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfUnaryOperator, system::workflow::WfUnaryOperator)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfUnaryExpression, system::workflow::WfUnaryExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfBinaryOperator, system::workflow::WfBinaryOperator)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfBinaryExpression, system::workflow::WfBinaryExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfLetVariable, system::workflow::WfLetVariable)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfLetExpression, system::workflow::WfLetExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfIfExpression, system::workflow::WfIfExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfRangeBoundary, system::workflow::WfRangeBoundary)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfRangeExpression, system::workflow::WfRangeExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfSetTesting, system::workflow::WfSetTesting)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfSetTestingExpression, system::workflow::WfSetTestingExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfConstructorArgument, system::workflow::WfConstructorArgument)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfConstructorExpression, system::workflow::WfConstructorExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfInferExpression, system::workflow::WfInferExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeCastingStrategy, system::workflow::WfTypeCastingStrategy)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeCastingExpression, system::workflow::WfTypeCastingExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeTesting, system::workflow::WfTypeTesting)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeTestingExpression, system::workflow::WfTypeTestingExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeOfTypeExpression, system::workflow::WfTypeOfTypeExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfTypeOfExpressionExpression, system::workflow::WfTypeOfExpressionExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfAttachEventExpression, system::workflow::WfAttachEventExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfDetachEventExpression, system::workflow::WfDetachEventExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfObserveType, system::workflow::WfObserveType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfObserveExpression, system::workflow::WfObserveExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCallExpression, system::workflow::WfCallExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFunctionExpression, system::workflow::WfFunctionExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfNewClassExpression, system::workflow::WfNewClassExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfNewInterfaceExpression, system::workflow::WfNewInterfaceExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCfeExpression, system::workflow::WfVirtualCfeExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCfeExpression::IVisitor, system::workflow::WfVirtualCfeExpression::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfFormatExpression, system::workflow::WfFormatExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCseExpression, system::workflow::WfVirtualCseExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfVirtualCseExpression::IVisitor, system::workflow::WfVirtualCseExpression::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfBindExpression, system::workflow::WfBindExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfNewCoroutineExpression, system::workflow::WfNewCoroutineExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfMixinCastExpression, system::workflow::WfMixinCastExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfExpectedTypeCastExpression, system::workflow::WfExpectedTypeCastExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfCoOperatorExpression, system::workflow::WfCoOperatorExpression)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingFragment, system::workflow::WfModuleUsingFragment)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingFragment::IVisitor, system::workflow::WfModuleUsingFragment::IVisitor)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingNameFragment, system::workflow::WfModuleUsingNameFragment)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingWildCardFragment, system::workflow::WfModuleUsingWildCardFragment)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingItem, system::workflow::WfModuleUsingItem)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleUsingPath, system::workflow::WfModuleUsingPath)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModuleType, system::workflow::WfModuleType)
	IMPL_TYPE_INFO_RENAME(vl::workflow::WfModule, system::workflow::WfModule)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

	BEGIN_CLASS_MEMBER(vl::workflow::WfType)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

	END_CLASS_MEMBER(vl::workflow::WfType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfExpression)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

	END_CLASS_MEMBER(vl::workflow::WfExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStatement)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

	END_CLASS_MEMBER(vl::workflow::WfStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfAttribute)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfAttribute>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(category)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfAttribute)

	BEGIN_CLASS_MEMBER(vl::workflow::WfDeclaration)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_FIELD(attributes)
		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfDeclaration)

	BEGIN_ENUM_ITEM(vl::workflow::WfFunctionKind)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfFunctionKind)
		ENUM_NAMESPACE_ITEM(Static)
		ENUM_NAMESPACE_ITEM(Override)
		ENUM_NAMESPACE_ITEM(Normal)
	END_ENUM_ITEM(vl::workflow::WfFunctionKind)

	BEGIN_ENUM_ITEM(vl::workflow::WfPredefinedTypeName)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfPredefinedTypeName)
		ENUM_NAMESPACE_ITEM(Void)
		ENUM_NAMESPACE_ITEM(Object)
		ENUM_NAMESPACE_ITEM(Interface)
		ENUM_NAMESPACE_ITEM(Int)
		ENUM_NAMESPACE_ITEM(UInt)
		ENUM_NAMESPACE_ITEM(Float)
		ENUM_NAMESPACE_ITEM(Double)
		ENUM_NAMESPACE_ITEM(String)
		ENUM_NAMESPACE_ITEM(Char)
		ENUM_NAMESPACE_ITEM(Bool)
	END_ENUM_ITEM(vl::workflow::WfPredefinedTypeName)

	BEGIN_CLASS_MEMBER(vl::workflow::WfPredefinedType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfPredefinedType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfPredefinedType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfTopQualifiedType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfTopQualifiedType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfTopQualifiedType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfReferenceType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfReferenceType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfReferenceType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfRawPointerType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfRawPointerType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(element)
	END_CLASS_MEMBER(vl::workflow::WfRawPointerType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfSharedPointerType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfSharedPointerType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(element)
	END_CLASS_MEMBER(vl::workflow::WfSharedPointerType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfNullableType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfNullableType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(element)
	END_CLASS_MEMBER(vl::workflow::WfNullableType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfEnumerableType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfEnumerableType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(element)
	END_CLASS_MEMBER(vl::workflow::WfEnumerableType)

	BEGIN_ENUM_ITEM(vl::workflow::WfMapWritability)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfMapWritability)
		ENUM_NAMESPACE_ITEM(Readonly)
		ENUM_NAMESPACE_ITEM(Writable)
	END_ENUM_ITEM(vl::workflow::WfMapWritability)

	BEGIN_CLASS_MEMBER(vl::workflow::WfMapType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfMapType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(writability)
		CLASS_MEMBER_FIELD(key)
		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfMapType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfObservableListType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfObservableListType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(element)
	END_CLASS_MEMBER(vl::workflow::WfObservableListType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfFunctionType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfFunctionType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(result)
		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfFunctionType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfChildType)
		CLASS_MEMBER_BASE(vl::workflow::WfType)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfChildType>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(parent)
		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfChildType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfNamespaceDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfNamespaceDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(declarations)
	END_CLASS_MEMBER(vl::workflow::WfNamespaceDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfFunctionArgument)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfFunctionArgument>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(attributes)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(type)
	END_CLASS_MEMBER(vl::workflow::WfFunctionArgument)

	BEGIN_ENUM_ITEM(vl::workflow::WfFunctionAnonymity)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfFunctionAnonymity)
		ENUM_NAMESPACE_ITEM(Named)
		ENUM_NAMESPACE_ITEM(Anonymous)
	END_ENUM_ITEM(vl::workflow::WfFunctionAnonymity)

	BEGIN_CLASS_MEMBER(vl::workflow::WfFunctionDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfFunctionDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(functionKind)
		CLASS_MEMBER_FIELD(anonymity)
		CLASS_MEMBER_FIELD(arguments)
		CLASS_MEMBER_FIELD(returnType)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfFunctionDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfVariableDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfVariableDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfVariableDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfEventDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfEventDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfEventDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfPropertyDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfPropertyDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(getter)
		CLASS_MEMBER_FIELD(setter)
		CLASS_MEMBER_FIELD(valueChangedEvent)
	END_CLASS_MEMBER(vl::workflow::WfPropertyDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStaticInitDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStaticInitDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfStaticInitDeclaration)

	BEGIN_ENUM_ITEM(vl::workflow::WfClassKind)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfClassKind)
		ENUM_NAMESPACE_ITEM(Class)
		ENUM_NAMESPACE_ITEM(Interface)
	END_ENUM_ITEM(vl::workflow::WfClassKind)

	BEGIN_ENUM_ITEM(vl::workflow::WfConstructorType)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfConstructorType)
		ENUM_NAMESPACE_ITEM(Undefined)
		ENUM_NAMESPACE_ITEM(SharedPtr)
		ENUM_NAMESPACE_ITEM(RawPtr)
	END_ENUM_ITEM(vl::workflow::WfConstructorType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfBaseConstructorCall)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfBaseConstructorCall>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfBaseConstructorCall)

	BEGIN_CLASS_MEMBER(vl::workflow::WfConstructorDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfConstructorDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(constructorType)
		CLASS_MEMBER_FIELD(baseConstructorCalls)
		CLASS_MEMBER_FIELD(arguments)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfConstructorDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfDestructorDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfDestructorDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfDestructorDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfClassDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfClassDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(kind)
		CLASS_MEMBER_FIELD(constructorType)
		CLASS_MEMBER_FIELD(baseTypes)
		CLASS_MEMBER_FIELD(declarations)
	END_CLASS_MEMBER(vl::workflow::WfClassDeclaration)

	BEGIN_ENUM_ITEM(vl::workflow::WfEnumKind)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfEnumKind)
		ENUM_NAMESPACE_ITEM(Normal)
		ENUM_NAMESPACE_ITEM(Flag)
	END_ENUM_ITEM(vl::workflow::WfEnumKind)

	BEGIN_ENUM_ITEM(vl::workflow::WfEnumItemKind)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfEnumItemKind)
		ENUM_NAMESPACE_ITEM(Constant)
		ENUM_NAMESPACE_ITEM(Intersection)
	END_ENUM_ITEM(vl::workflow::WfEnumItemKind)

	BEGIN_CLASS_MEMBER(vl::workflow::WfEnumItemIntersection)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfEnumItemIntersection>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfEnumItemIntersection)

	BEGIN_CLASS_MEMBER(vl::workflow::WfEnumItem)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfEnumItem>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(attributes)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(kind)
		CLASS_MEMBER_FIELD(number)
		CLASS_MEMBER_FIELD(intersections)
	END_CLASS_MEMBER(vl::workflow::WfEnumItem)

	BEGIN_CLASS_MEMBER(vl::workflow::WfEnumDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfEnumDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(kind)
		CLASS_MEMBER_FIELD(items)
	END_CLASS_MEMBER(vl::workflow::WfEnumDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStructMember)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStructMember>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(attributes)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(type)
	END_CLASS_MEMBER(vl::workflow::WfStructMember)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStructDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStructDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(members)
	END_CLASS_MEMBER(vl::workflow::WfStructDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfVirtualCfeDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_FIELD(expandedDeclarations)
	END_CLASS_MEMBER(vl::workflow::WfVirtualCfeDeclaration)

	BEGIN_ENUM_ITEM(vl::workflow::WfAPConst)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfAPConst)
		ENUM_NAMESPACE_ITEM(Readonly)
		ENUM_NAMESPACE_ITEM(Writable)
	END_ENUM_ITEM(vl::workflow::WfAPConst)

	BEGIN_ENUM_ITEM(vl::workflow::WfAPObserve)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfAPObserve)
		ENUM_NAMESPACE_ITEM(Observable)
		ENUM_NAMESPACE_ITEM(NotObservable)
	END_ENUM_ITEM(vl::workflow::WfAPObserve)

	BEGIN_CLASS_MEMBER(vl::workflow::WfAutoPropertyDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCfeDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfAutoPropertyDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(functionKind)
		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(configConst)
		CLASS_MEMBER_FIELD(configObserve)
		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfAutoPropertyDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfCastResultInterfaceDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCfeDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfCastResultInterfaceDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(baseType)
		CLASS_MEMBER_FIELD(elementType)
	END_CLASS_MEMBER(vl::workflow::WfCastResultInterfaceDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfVirtualCseDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfDeclaration)

		CLASS_MEMBER_FIELD(expandedDeclarations)
	END_CLASS_MEMBER(vl::workflow::WfVirtualCseDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateInput)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStateInput>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfStateInput)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateDeclaration)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStateDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(arguments)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfStateDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateMachineDeclaration)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseDeclaration)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStateMachineDeclaration>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(inputs)
		CLASS_MEMBER_FIELD(states)
	END_CLASS_MEMBER(vl::workflow::WfStateMachineDeclaration)

	BEGIN_CLASS_MEMBER(vl::workflow::WfBreakStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfBreakStatement>(), NO_PARAMETER)

	END_CLASS_MEMBER(vl::workflow::WfBreakStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfContinueStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfContinueStatement>(), NO_PARAMETER)

	END_CLASS_MEMBER(vl::workflow::WfContinueStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfReturnStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfReturnStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfReturnStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfDeleteStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfDeleteStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfDeleteStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfRaiseExceptionStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfRaiseExceptionStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfRaiseExceptionStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfIfStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfIfStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(expression)
		CLASS_MEMBER_FIELD(trueBranch)
		CLASS_MEMBER_FIELD(falseBranch)
	END_CLASS_MEMBER(vl::workflow::WfIfStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfWhileStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfWhileStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(condition)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfWhileStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfTryStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfTryStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(protectedStatement)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(catchStatement)
		CLASS_MEMBER_FIELD(finallyStatement)
	END_CLASS_MEMBER(vl::workflow::WfTryStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfBlockStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfBlockStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(statements)
		CLASS_MEMBER_FIELD(endLabel)
	END_CLASS_MEMBER(vl::workflow::WfBlockStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfGotoStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfGotoStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(label)
	END_CLASS_MEMBER(vl::workflow::WfGotoStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfVariableStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfVariableStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(variable)
	END_CLASS_MEMBER(vl::workflow::WfVariableStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfExpressionStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfExpressionStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfExpressionStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfVirtualCseStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

		CLASS_MEMBER_FIELD(expandedStatement)
	END_CLASS_MEMBER(vl::workflow::WfVirtualCseStatement)

	BEGIN_ENUM_ITEM(vl::workflow::WfForEachDirection)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfForEachDirection)
		ENUM_NAMESPACE_ITEM(Normal)
		ENUM_NAMESPACE_ITEM(Reversed)
	END_ENUM_ITEM(vl::workflow::WfForEachDirection)

	BEGIN_CLASS_MEMBER(vl::workflow::WfForEachStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfForEachStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(direction)
		CLASS_MEMBER_FIELD(collection)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfForEachStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfSwitchCase)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfSwitchCase>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfSwitchCase)

	BEGIN_CLASS_MEMBER(vl::workflow::WfSwitchStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfSwitchStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
		CLASS_MEMBER_FIELD(caseBranches)
		CLASS_MEMBER_FIELD(defaultBranch)
	END_CLASS_MEMBER(vl::workflow::WfSwitchStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfCoProviderStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfCoProviderStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfCoProviderStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfCoroutineStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

	END_CLASS_MEMBER(vl::workflow::WfCoroutineStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfCoPauseStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfCoroutineStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfCoPauseStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfCoPauseStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfCoOperatorStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfCoroutineStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfCoOperatorStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(varName)
		CLASS_MEMBER_FIELD(opName)
		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfCoOperatorStatement)

	BEGIN_ENUM_ITEM(vl::workflow::WfStateSwitchType)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfStateSwitchType)
		ENUM_NAMESPACE_ITEM(Default)
		ENUM_NAMESPACE_ITEM(Pass)
		ENUM_NAMESPACE_ITEM(PassAndReturn)
		ENUM_NAMESPACE_ITEM(Ignore)
		ENUM_NAMESPACE_ITEM(IgnoreAndReturn)
	END_ENUM_ITEM(vl::workflow::WfStateSwitchType)

	BEGIN_ENUM_ITEM(vl::workflow::WfStateInvokeType)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfStateInvokeType)
		ENUM_NAMESPACE_ITEM(Goto)
		ENUM_NAMESPACE_ITEM(Push)
	END_ENUM_ITEM(vl::workflow::WfStateInvokeType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateMachineStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStatement)

	END_CLASS_MEMBER(vl::workflow::WfStateMachineStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateSwitchArgument)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStateSwitchArgument>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfStateSwitchArgument)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateSwitchCase)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStateSwitchCase>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(arguments)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfStateSwitchCase)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateSwitchStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStateMachineStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStateSwitchStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(caseBranches)
	END_CLASS_MEMBER(vl::workflow::WfStateSwitchStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStateInvokeStatement)
		CLASS_MEMBER_BASE(vl::workflow::WfStateMachineStatement)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStateInvokeStatement>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfStateInvokeStatement)

	BEGIN_CLASS_MEMBER(vl::workflow::WfThisExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfThisExpression>(), NO_PARAMETER)

	END_CLASS_MEMBER(vl::workflow::WfThisExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfTopQualifiedExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfTopQualifiedExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfTopQualifiedExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfReferenceExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfReferenceExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfReferenceExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfOrderedNameExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfOrderedNameExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfOrderedNameExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfOrderedLambdaExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfOrderedLambdaExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(body)
	END_CLASS_MEMBER(vl::workflow::WfOrderedLambdaExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfMemberExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfMemberExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(parent)
		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfMemberExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfChildExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfChildExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(parent)
		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfChildExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfLiteralValue)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfLiteralValue)
		ENUM_NAMESPACE_ITEM(Null)
		ENUM_NAMESPACE_ITEM(True)
		ENUM_NAMESPACE_ITEM(False)
	END_ENUM_ITEM(vl::workflow::WfLiteralValue)

	BEGIN_CLASS_MEMBER(vl::workflow::WfLiteralExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfLiteralExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfLiteralExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfFloatingExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfFloatingExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfFloatingExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfIntegerExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfIntegerExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfIntegerExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfStringExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfStringExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfStringExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfUnaryOperator)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfUnaryOperator)
		ENUM_NAMESPACE_ITEM(Positive)
		ENUM_NAMESPACE_ITEM(Negative)
		ENUM_NAMESPACE_ITEM(Not)
	END_ENUM_ITEM(vl::workflow::WfUnaryOperator)

	BEGIN_CLASS_MEMBER(vl::workflow::WfUnaryExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfUnaryExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(op)
		CLASS_MEMBER_FIELD(operand)
	END_CLASS_MEMBER(vl::workflow::WfUnaryExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfBinaryOperator)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfBinaryOperator)
		ENUM_NAMESPACE_ITEM(Assign)
		ENUM_NAMESPACE_ITEM(Index)
		ENUM_NAMESPACE_ITEM(FlagAnd)
		ENUM_NAMESPACE_ITEM(FlagOr)
		ENUM_NAMESPACE_ITEM(FailedThen)
		ENUM_NAMESPACE_ITEM(Exp)
		ENUM_NAMESPACE_ITEM(Add)
		ENUM_NAMESPACE_ITEM(Sub)
		ENUM_NAMESPACE_ITEM(Mul)
		ENUM_NAMESPACE_ITEM(Div)
		ENUM_NAMESPACE_ITEM(Mod)
		ENUM_NAMESPACE_ITEM(Shl)
		ENUM_NAMESPACE_ITEM(Shr)
		ENUM_NAMESPACE_ITEM(LT)
		ENUM_NAMESPACE_ITEM(GT)
		ENUM_NAMESPACE_ITEM(LE)
		ENUM_NAMESPACE_ITEM(GE)
		ENUM_NAMESPACE_ITEM(EQ)
		ENUM_NAMESPACE_ITEM(NE)
		ENUM_NAMESPACE_ITEM(Xor)
		ENUM_NAMESPACE_ITEM(And)
		ENUM_NAMESPACE_ITEM(Or)
	END_ENUM_ITEM(vl::workflow::WfBinaryOperator)

	BEGIN_CLASS_MEMBER(vl::workflow::WfBinaryExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfBinaryExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(op)
		CLASS_MEMBER_FIELD(first)
		CLASS_MEMBER_FIELD(second)
	END_CLASS_MEMBER(vl::workflow::WfBinaryExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfLetVariable)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfLetVariable>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfLetVariable)

	BEGIN_CLASS_MEMBER(vl::workflow::WfLetExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfLetExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(variables)
		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfLetExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfIfExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfIfExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(condition)
		CLASS_MEMBER_FIELD(trueBranch)
		CLASS_MEMBER_FIELD(falseBranch)
	END_CLASS_MEMBER(vl::workflow::WfIfExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfRangeBoundary)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfRangeBoundary)
		ENUM_NAMESPACE_ITEM(Inclusive)
		ENUM_NAMESPACE_ITEM(Exclusive)
	END_ENUM_ITEM(vl::workflow::WfRangeBoundary)

	BEGIN_CLASS_MEMBER(vl::workflow::WfRangeExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfRangeExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(begin)
		CLASS_MEMBER_FIELD(beginBoundary)
		CLASS_MEMBER_FIELD(end)
		CLASS_MEMBER_FIELD(endBoundary)
	END_CLASS_MEMBER(vl::workflow::WfRangeExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfSetTesting)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfSetTesting)
		ENUM_NAMESPACE_ITEM(In)
		ENUM_NAMESPACE_ITEM(NotIn)
	END_ENUM_ITEM(vl::workflow::WfSetTesting)

	BEGIN_CLASS_MEMBER(vl::workflow::WfSetTestingExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfSetTestingExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(test)
		CLASS_MEMBER_FIELD(element)
		CLASS_MEMBER_FIELD(collection)
	END_CLASS_MEMBER(vl::workflow::WfSetTestingExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfConstructorArgument)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfConstructorArgument>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(key)
		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfConstructorArgument)

	BEGIN_CLASS_MEMBER(vl::workflow::WfConstructorExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfConstructorExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfConstructorExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfInferExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfInferExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
		CLASS_MEMBER_FIELD(type)
	END_CLASS_MEMBER(vl::workflow::WfInferExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfTypeCastingStrategy)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfTypeCastingStrategy)
		ENUM_NAMESPACE_ITEM(Strong)
		ENUM_NAMESPACE_ITEM(Weak)
	END_ENUM_ITEM(vl::workflow::WfTypeCastingStrategy)

	BEGIN_CLASS_MEMBER(vl::workflow::WfTypeCastingExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfTypeCastingExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(strategy)
		CLASS_MEMBER_FIELD(expression)
		CLASS_MEMBER_FIELD(type)
	END_CLASS_MEMBER(vl::workflow::WfTypeCastingExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfTypeTesting)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfTypeTesting)
		ENUM_NAMESPACE_ITEM(IsType)
		ENUM_NAMESPACE_ITEM(IsNotType)
		ENUM_NAMESPACE_ITEM(IsNull)
		ENUM_NAMESPACE_ITEM(IsNotNull)
	END_ENUM_ITEM(vl::workflow::WfTypeTesting)

	BEGIN_CLASS_MEMBER(vl::workflow::WfTypeTestingExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfTypeTestingExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(test)
		CLASS_MEMBER_FIELD(expression)
		CLASS_MEMBER_FIELD(type)
	END_CLASS_MEMBER(vl::workflow::WfTypeTestingExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfTypeOfTypeExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfTypeOfTypeExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
	END_CLASS_MEMBER(vl::workflow::WfTypeOfTypeExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfTypeOfExpressionExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfTypeOfExpressionExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfTypeOfExpressionExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfAttachEventExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfAttachEventExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(event)
		CLASS_MEMBER_FIELD(function)
	END_CLASS_MEMBER(vl::workflow::WfAttachEventExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfDetachEventExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfDetachEventExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(event)
		CLASS_MEMBER_FIELD(handler)
	END_CLASS_MEMBER(vl::workflow::WfDetachEventExpression)

	BEGIN_ENUM_ITEM(vl::workflow::WfObserveType)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfObserveType)
		ENUM_NAMESPACE_ITEM(SimpleObserve)
		ENUM_NAMESPACE_ITEM(ExtendedObserve)
	END_ENUM_ITEM(vl::workflow::WfObserveType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfObserveExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfObserveExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(parent)
		CLASS_MEMBER_FIELD(observeType)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(expression)
		CLASS_MEMBER_FIELD(events)
	END_CLASS_MEMBER(vl::workflow::WfObserveExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfCallExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfCallExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(function)
		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfCallExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfFunctionExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfFunctionExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(function)
	END_CLASS_MEMBER(vl::workflow::WfFunctionExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfNewClassExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfNewClassExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(arguments)
	END_CLASS_MEMBER(vl::workflow::WfNewClassExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfNewInterfaceExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfNewInterfaceExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(declarations)
	END_CLASS_MEMBER(vl::workflow::WfNewInterfaceExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfVirtualCfeExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_FIELD(expandedExpression)
	END_CLASS_MEMBER(vl::workflow::WfVirtualCfeExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfFormatExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCfeExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfFormatExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(value)
	END_CLASS_MEMBER(vl::workflow::WfFormatExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfVirtualCseExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfExpression)

		CLASS_MEMBER_FIELD(expandedExpression)
	END_CLASS_MEMBER(vl::workflow::WfVirtualCseExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfBindExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfBindExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfBindExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfNewCoroutineExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfNewCoroutineExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(statement)
	END_CLASS_MEMBER(vl::workflow::WfNewCoroutineExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfMixinCastExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfMixinCastExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(type)
		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfMixinCastExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfExpectedTypeCastExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfExpectedTypeCastExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(strategy)
		CLASS_MEMBER_FIELD(expression)
	END_CLASS_MEMBER(vl::workflow::WfExpectedTypeCastExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfCoOperatorExpression)
		CLASS_MEMBER_BASE(vl::workflow::WfVirtualCseExpression)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfCoOperatorExpression>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfCoOperatorExpression)

	BEGIN_CLASS_MEMBER(vl::workflow::WfModuleUsingFragment)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

	END_CLASS_MEMBER(vl::workflow::WfModuleUsingFragment)

	BEGIN_CLASS_MEMBER(vl::workflow::WfModuleUsingNameFragment)
		CLASS_MEMBER_BASE(vl::workflow::WfModuleUsingFragment)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfModuleUsingNameFragment>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(name)
	END_CLASS_MEMBER(vl::workflow::WfModuleUsingNameFragment)

	BEGIN_CLASS_MEMBER(vl::workflow::WfModuleUsingWildCardFragment)
		CLASS_MEMBER_BASE(vl::workflow::WfModuleUsingFragment)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfModuleUsingWildCardFragment>(), NO_PARAMETER)

	END_CLASS_MEMBER(vl::workflow::WfModuleUsingWildCardFragment)

	BEGIN_CLASS_MEMBER(vl::workflow::WfModuleUsingItem)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfModuleUsingItem>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(fragments)
	END_CLASS_MEMBER(vl::workflow::WfModuleUsingItem)

	BEGIN_CLASS_MEMBER(vl::workflow::WfModuleUsingPath)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfModuleUsingPath>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(items)
	END_CLASS_MEMBER(vl::workflow::WfModuleUsingPath)

	BEGIN_ENUM_ITEM(vl::workflow::WfModuleType)
		ENUM_ITEM_NAMESPACE(vl::workflow::WfModuleType)
		ENUM_NAMESPACE_ITEM(Module)
		ENUM_NAMESPACE_ITEM(Unit)
	END_ENUM_ITEM(vl::workflow::WfModuleType)

	BEGIN_CLASS_MEMBER(vl::workflow::WfModule)
		CLASS_MEMBER_BASE(vl::glr::ParsingAstBase)

		CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<vl::workflow::WfModule>(), NO_PARAMETER)

		CLASS_MEMBER_FIELD(moduleType)
		CLASS_MEMBER_FIELD(name)
		CLASS_MEMBER_FIELD(paths)
		CLASS_MEMBER_FIELD(declarations)
	END_CLASS_MEMBER(vl::workflow::WfModule)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfType::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfPredefinedType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfTopQualifiedType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfReferenceType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfRawPointerType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfSharedPointerType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfNullableType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfEnumerableType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfMapType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfObservableListType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfFunctionType* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfType::IVisitor::*)(vl::workflow::WfChildType* node))
	END_INTERFACE_MEMBER(vl::workflow::WfType)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfExpression::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfThisExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfTopQualifiedExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfReferenceExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfOrderedNameExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfOrderedLambdaExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfMemberExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfChildExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfLiteralExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfFloatingExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfIntegerExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfStringExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfUnaryExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfBinaryExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfLetExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfIfExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfRangeExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfSetTestingExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfConstructorExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfInferExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfTypeCastingExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfTypeTestingExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfTypeOfTypeExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfTypeOfExpressionExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfAttachEventExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfDetachEventExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfObserveExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfCallExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfFunctionExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfNewClassExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfNewInterfaceExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfVirtualCfeExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfExpression::IVisitor::*)(vl::workflow::WfVirtualCseExpression* node))
	END_INTERFACE_MEMBER(vl::workflow::WfExpression)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfStatement::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfBreakStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfContinueStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfReturnStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfDeleteStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfRaiseExceptionStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfIfStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfWhileStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfTryStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfBlockStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfGotoStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfVariableStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfExpressionStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfVirtualCseStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfCoroutineStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStatement::IVisitor::*)(vl::workflow::WfStateMachineStatement* node))
	END_INTERFACE_MEMBER(vl::workflow::WfStatement)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfDeclaration::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfNamespaceDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfFunctionDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfVariableDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfEventDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfPropertyDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfStaticInitDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfConstructorDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfDestructorDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfClassDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfEnumDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfStructDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfVirtualCfeDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfDeclaration::IVisitor::*)(vl::workflow::WfVirtualCseDeclaration* node))
	END_INTERFACE_MEMBER(vl::workflow::WfDeclaration)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCfeDeclaration::IVisitor::*)(vl::workflow::WfAutoPropertyDeclaration* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCfeDeclaration::IVisitor::*)(vl::workflow::WfCastResultInterfaceDeclaration* node))
	END_INTERFACE_MEMBER(vl::workflow::WfVirtualCfeDeclaration)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfVirtualCseDeclaration::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseDeclaration::IVisitor::*)(vl::workflow::WfStateMachineDeclaration* node))
	END_INTERFACE_MEMBER(vl::workflow::WfVirtualCseDeclaration)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfVirtualCseStatement::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseStatement::IVisitor::*)(vl::workflow::WfForEachStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseStatement::IVisitor::*)(vl::workflow::WfSwitchStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseStatement::IVisitor::*)(vl::workflow::WfCoProviderStatement* node))
	END_INTERFACE_MEMBER(vl::workflow::WfVirtualCseStatement)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfCoroutineStatement::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfCoroutineStatement::IVisitor::*)(vl::workflow::WfCoPauseStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfCoroutineStatement::IVisitor::*)(vl::workflow::WfCoOperatorStatement* node))
	END_INTERFACE_MEMBER(vl::workflow::WfCoroutineStatement)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfStateMachineStatement::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStateMachineStatement::IVisitor::*)(vl::workflow::WfStateSwitchStatement* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfStateMachineStatement::IVisitor::*)(vl::workflow::WfStateInvokeStatement* node))
	END_INTERFACE_MEMBER(vl::workflow::WfStateMachineStatement)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfVirtualCfeExpression::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCfeExpression::IVisitor::*)(vl::workflow::WfFormatExpression* node))
	END_INTERFACE_MEMBER(vl::workflow::WfVirtualCfeExpression)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfVirtualCseExpression::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseExpression::IVisitor::*)(vl::workflow::WfBindExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseExpression::IVisitor::*)(vl::workflow::WfNewCoroutineExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseExpression::IVisitor::*)(vl::workflow::WfMixinCastExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseExpression::IVisitor::*)(vl::workflow::WfExpectedTypeCastExpression* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfVirtualCseExpression::IVisitor::*)(vl::workflow::WfCoOperatorExpression* node))
	END_INTERFACE_MEMBER(vl::workflow::WfVirtualCseExpression)

	BEGIN_INTERFACE_MEMBER(vl::workflow::WfModuleUsingFragment::IVisitor)
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfModuleUsingFragment::IVisitor::*)(vl::workflow::WfModuleUsingNameFragment* node))
		CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(vl::workflow::WfModuleUsingFragment::IVisitor::*)(vl::workflow::WfModuleUsingWildCardFragment* node))
	END_INTERFACE_MEMBER(vl::workflow::WfModuleUsingFragment)

#endif

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
	class WorkflowAstTypeLoader : public vl::Object, public ITypeLoader
	{
	public:
		void Load(ITypeManager* manager)
		{
			ADD_TYPE_INFO(vl::workflow::WfType)
			ADD_TYPE_INFO(vl::workflow::WfType::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfExpression)
			ADD_TYPE_INFO(vl::workflow::WfExpression::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfStatement)
			ADD_TYPE_INFO(vl::workflow::WfStatement::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfAttribute)
			ADD_TYPE_INFO(vl::workflow::WfDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfDeclaration::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfFunctionKind)
			ADD_TYPE_INFO(vl::workflow::WfPredefinedTypeName)
			ADD_TYPE_INFO(vl::workflow::WfPredefinedType)
			ADD_TYPE_INFO(vl::workflow::WfTopQualifiedType)
			ADD_TYPE_INFO(vl::workflow::WfReferenceType)
			ADD_TYPE_INFO(vl::workflow::WfRawPointerType)
			ADD_TYPE_INFO(vl::workflow::WfSharedPointerType)
			ADD_TYPE_INFO(vl::workflow::WfNullableType)
			ADD_TYPE_INFO(vl::workflow::WfEnumerableType)
			ADD_TYPE_INFO(vl::workflow::WfMapWritability)
			ADD_TYPE_INFO(vl::workflow::WfMapType)
			ADD_TYPE_INFO(vl::workflow::WfObservableListType)
			ADD_TYPE_INFO(vl::workflow::WfFunctionType)
			ADD_TYPE_INFO(vl::workflow::WfChildType)
			ADD_TYPE_INFO(vl::workflow::WfNamespaceDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfFunctionArgument)
			ADD_TYPE_INFO(vl::workflow::WfFunctionAnonymity)
			ADD_TYPE_INFO(vl::workflow::WfFunctionDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfVariableDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfEventDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfPropertyDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfStaticInitDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfClassKind)
			ADD_TYPE_INFO(vl::workflow::WfConstructorType)
			ADD_TYPE_INFO(vl::workflow::WfBaseConstructorCall)
			ADD_TYPE_INFO(vl::workflow::WfConstructorDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfDestructorDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfClassDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfEnumKind)
			ADD_TYPE_INFO(vl::workflow::WfEnumItemKind)
			ADD_TYPE_INFO(vl::workflow::WfEnumItemIntersection)
			ADD_TYPE_INFO(vl::workflow::WfEnumItem)
			ADD_TYPE_INFO(vl::workflow::WfEnumDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfStructMember)
			ADD_TYPE_INFO(vl::workflow::WfStructDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfAPConst)
			ADD_TYPE_INFO(vl::workflow::WfAPObserve)
			ADD_TYPE_INFO(vl::workflow::WfAutoPropertyDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfCastResultInterfaceDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfStateInput)
			ADD_TYPE_INFO(vl::workflow::WfStateDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfStateMachineDeclaration)
			ADD_TYPE_INFO(vl::workflow::WfBreakStatement)
			ADD_TYPE_INFO(vl::workflow::WfContinueStatement)
			ADD_TYPE_INFO(vl::workflow::WfReturnStatement)
			ADD_TYPE_INFO(vl::workflow::WfDeleteStatement)
			ADD_TYPE_INFO(vl::workflow::WfRaiseExceptionStatement)
			ADD_TYPE_INFO(vl::workflow::WfIfStatement)
			ADD_TYPE_INFO(vl::workflow::WfWhileStatement)
			ADD_TYPE_INFO(vl::workflow::WfTryStatement)
			ADD_TYPE_INFO(vl::workflow::WfBlockStatement)
			ADD_TYPE_INFO(vl::workflow::WfGotoStatement)
			ADD_TYPE_INFO(vl::workflow::WfVariableStatement)
			ADD_TYPE_INFO(vl::workflow::WfExpressionStatement)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCseStatement)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCseStatement::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfForEachDirection)
			ADD_TYPE_INFO(vl::workflow::WfForEachStatement)
			ADD_TYPE_INFO(vl::workflow::WfSwitchCase)
			ADD_TYPE_INFO(vl::workflow::WfSwitchStatement)
			ADD_TYPE_INFO(vl::workflow::WfCoProviderStatement)
			ADD_TYPE_INFO(vl::workflow::WfCoroutineStatement)
			ADD_TYPE_INFO(vl::workflow::WfCoroutineStatement::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfCoPauseStatement)
			ADD_TYPE_INFO(vl::workflow::WfCoOperatorStatement)
			ADD_TYPE_INFO(vl::workflow::WfStateSwitchType)
			ADD_TYPE_INFO(vl::workflow::WfStateInvokeType)
			ADD_TYPE_INFO(vl::workflow::WfStateMachineStatement)
			ADD_TYPE_INFO(vl::workflow::WfStateMachineStatement::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfStateSwitchArgument)
			ADD_TYPE_INFO(vl::workflow::WfStateSwitchCase)
			ADD_TYPE_INFO(vl::workflow::WfStateSwitchStatement)
			ADD_TYPE_INFO(vl::workflow::WfStateInvokeStatement)
			ADD_TYPE_INFO(vl::workflow::WfThisExpression)
			ADD_TYPE_INFO(vl::workflow::WfTopQualifiedExpression)
			ADD_TYPE_INFO(vl::workflow::WfReferenceExpression)
			ADD_TYPE_INFO(vl::workflow::WfOrderedNameExpression)
			ADD_TYPE_INFO(vl::workflow::WfOrderedLambdaExpression)
			ADD_TYPE_INFO(vl::workflow::WfMemberExpression)
			ADD_TYPE_INFO(vl::workflow::WfChildExpression)
			ADD_TYPE_INFO(vl::workflow::WfLiteralValue)
			ADD_TYPE_INFO(vl::workflow::WfLiteralExpression)
			ADD_TYPE_INFO(vl::workflow::WfFloatingExpression)
			ADD_TYPE_INFO(vl::workflow::WfIntegerExpression)
			ADD_TYPE_INFO(vl::workflow::WfStringExpression)
			ADD_TYPE_INFO(vl::workflow::WfUnaryOperator)
			ADD_TYPE_INFO(vl::workflow::WfUnaryExpression)
			ADD_TYPE_INFO(vl::workflow::WfBinaryOperator)
			ADD_TYPE_INFO(vl::workflow::WfBinaryExpression)
			ADD_TYPE_INFO(vl::workflow::WfLetVariable)
			ADD_TYPE_INFO(vl::workflow::WfLetExpression)
			ADD_TYPE_INFO(vl::workflow::WfIfExpression)
			ADD_TYPE_INFO(vl::workflow::WfRangeBoundary)
			ADD_TYPE_INFO(vl::workflow::WfRangeExpression)
			ADD_TYPE_INFO(vl::workflow::WfSetTesting)
			ADD_TYPE_INFO(vl::workflow::WfSetTestingExpression)
			ADD_TYPE_INFO(vl::workflow::WfConstructorArgument)
			ADD_TYPE_INFO(vl::workflow::WfConstructorExpression)
			ADD_TYPE_INFO(vl::workflow::WfInferExpression)
			ADD_TYPE_INFO(vl::workflow::WfTypeCastingStrategy)
			ADD_TYPE_INFO(vl::workflow::WfTypeCastingExpression)
			ADD_TYPE_INFO(vl::workflow::WfTypeTesting)
			ADD_TYPE_INFO(vl::workflow::WfTypeTestingExpression)
			ADD_TYPE_INFO(vl::workflow::WfTypeOfTypeExpression)
			ADD_TYPE_INFO(vl::workflow::WfTypeOfExpressionExpression)
			ADD_TYPE_INFO(vl::workflow::WfAttachEventExpression)
			ADD_TYPE_INFO(vl::workflow::WfDetachEventExpression)
			ADD_TYPE_INFO(vl::workflow::WfObserveType)
			ADD_TYPE_INFO(vl::workflow::WfObserveExpression)
			ADD_TYPE_INFO(vl::workflow::WfCallExpression)
			ADD_TYPE_INFO(vl::workflow::WfFunctionExpression)
			ADD_TYPE_INFO(vl::workflow::WfNewClassExpression)
			ADD_TYPE_INFO(vl::workflow::WfNewInterfaceExpression)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCfeExpression)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCfeExpression::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfFormatExpression)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCseExpression)
			ADD_TYPE_INFO(vl::workflow::WfVirtualCseExpression::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfBindExpression)
			ADD_TYPE_INFO(vl::workflow::WfNewCoroutineExpression)
			ADD_TYPE_INFO(vl::workflow::WfMixinCastExpression)
			ADD_TYPE_INFO(vl::workflow::WfExpectedTypeCastExpression)
			ADD_TYPE_INFO(vl::workflow::WfCoOperatorExpression)
			ADD_TYPE_INFO(vl::workflow::WfModuleUsingFragment)
			ADD_TYPE_INFO(vl::workflow::WfModuleUsingFragment::IVisitor)
			ADD_TYPE_INFO(vl::workflow::WfModuleUsingNameFragment)
			ADD_TYPE_INFO(vl::workflow::WfModuleUsingWildCardFragment)
			ADD_TYPE_INFO(vl::workflow::WfModuleUsingItem)
			ADD_TYPE_INFO(vl::workflow::WfModuleUsingPath)
			ADD_TYPE_INFO(vl::workflow::WfModuleType)
			ADD_TYPE_INFO(vl::workflow::WfModule)
		}

		void Unload(ITypeManager* manager)
		{
		}
	};
#endif
#endif

	bool WorkflowAstLoadTypes()
	{
#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA
		if (auto manager = GetGlobalTypeManager())
		{
			auto loader = Ptr(new WorkflowAstTypeLoader);
			return manager->AddTypeLoader(loader);
		}
#endif
		return false;
	}
}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_BUILDER.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow::builder
{

/***********************************************************************
MakeAttachEventExpression
***********************************************************************/

	MakeAttachEventExpression& MakeAttachEventExpression::event(const vl::Ptr<WfExpression>& value)
	{
		node->event = value;
		return *this;
	}

	MakeAttachEventExpression& MakeAttachEventExpression::function(const vl::Ptr<WfExpression>& value)
	{
		node->function = value;
		return *this;
	}

/***********************************************************************
MakeAttribute
***********************************************************************/

	MakeAttribute& MakeAttribute::category(const vl::WString& value)
	{
		node->category.value = value;
		return *this;
	}

	MakeAttribute& MakeAttribute::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeAttribute& MakeAttribute::value(const vl::Ptr<WfExpression>& value)
	{
		node->value = value;
		return *this;
	}

/***********************************************************************
MakeAutoPropertyDeclaration
***********************************************************************/

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::configConst(WfAPConst value)
	{
		node->configConst = value;
		return *this;
	}

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::configObserve(WfAPObserve value)
	{
		node->configObserve = value;
		return *this;
	}

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::functionKind(WfFunctionKind value)
	{
		node->functionKind = value;
		return *this;
	}

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::expandedDeclarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->expandedDeclarations.Add(value);
		return *this;
	}

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeAutoPropertyDeclaration& MakeAutoPropertyDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeBaseConstructorCall
***********************************************************************/

	MakeBaseConstructorCall& MakeBaseConstructorCall::arguments(const vl::Ptr<WfExpression>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeBaseConstructorCall& MakeBaseConstructorCall::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeBinaryExpression
***********************************************************************/

	MakeBinaryExpression& MakeBinaryExpression::first(const vl::Ptr<WfExpression>& value)
	{
		node->first = value;
		return *this;
	}

	MakeBinaryExpression& MakeBinaryExpression::op(WfBinaryOperator value)
	{
		node->op = value;
		return *this;
	}

	MakeBinaryExpression& MakeBinaryExpression::second(const vl::Ptr<WfExpression>& value)
	{
		node->second = value;
		return *this;
	}

/***********************************************************************
MakeBindExpression
***********************************************************************/

	MakeBindExpression& MakeBindExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeBindExpression& MakeBindExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeBlockStatement
***********************************************************************/

	MakeBlockStatement& MakeBlockStatement::endLabel(const vl::WString& value)
	{
		node->endLabel.value = value;
		return *this;
	}

	MakeBlockStatement& MakeBlockStatement::statements(const vl::Ptr<WfStatement>& value)
	{
		node->statements.Add(value);
		return *this;
	}

/***********************************************************************
MakeCallExpression
***********************************************************************/

	MakeCallExpression& MakeCallExpression::arguments(const vl::Ptr<WfExpression>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeCallExpression& MakeCallExpression::function(const vl::Ptr<WfExpression>& value)
	{
		node->function = value;
		return *this;
	}

/***********************************************************************
MakeCastResultInterfaceDeclaration
***********************************************************************/

	MakeCastResultInterfaceDeclaration& MakeCastResultInterfaceDeclaration::baseType(const vl::Ptr<WfType>& value)
	{
		node->baseType = value;
		return *this;
	}

	MakeCastResultInterfaceDeclaration& MakeCastResultInterfaceDeclaration::elementType(const vl::Ptr<WfType>& value)
	{
		node->elementType = value;
		return *this;
	}

	MakeCastResultInterfaceDeclaration& MakeCastResultInterfaceDeclaration::expandedDeclarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->expandedDeclarations.Add(value);
		return *this;
	}

	MakeCastResultInterfaceDeclaration& MakeCastResultInterfaceDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeCastResultInterfaceDeclaration& MakeCastResultInterfaceDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeChildExpression
***********************************************************************/

	MakeChildExpression& MakeChildExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeChildExpression& MakeChildExpression::parent(const vl::Ptr<WfExpression>& value)
	{
		node->parent = value;
		return *this;
	}

/***********************************************************************
MakeChildType
***********************************************************************/

	MakeChildType& MakeChildType::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeChildType& MakeChildType::parent(const vl::Ptr<WfType>& value)
	{
		node->parent = value;
		return *this;
	}

/***********************************************************************
MakeClassDeclaration
***********************************************************************/

	MakeClassDeclaration& MakeClassDeclaration::baseTypes(const vl::Ptr<WfType>& value)
	{
		node->baseTypes.Add(value);
		return *this;
	}

	MakeClassDeclaration& MakeClassDeclaration::constructorType(WfConstructorType value)
	{
		node->constructorType = value;
		return *this;
	}

	MakeClassDeclaration& MakeClassDeclaration::declarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->declarations.Add(value);
		return *this;
	}

	MakeClassDeclaration& MakeClassDeclaration::kind(WfClassKind value)
	{
		node->kind = value;
		return *this;
	}

	MakeClassDeclaration& MakeClassDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeClassDeclaration& MakeClassDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeCoOperatorExpression
***********************************************************************/

	MakeCoOperatorExpression& MakeCoOperatorExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeCoOperatorExpression& MakeCoOperatorExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeCoOperatorStatement
***********************************************************************/

	MakeCoOperatorStatement& MakeCoOperatorStatement::arguments(const vl::Ptr<WfExpression>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeCoOperatorStatement& MakeCoOperatorStatement::opName(const vl::WString& value)
	{
		node->opName.value = value;
		return *this;
	}

	MakeCoOperatorStatement& MakeCoOperatorStatement::varName(const vl::WString& value)
	{
		node->varName.value = value;
		return *this;
	}

/***********************************************************************
MakeCoPauseStatement
***********************************************************************/

	MakeCoPauseStatement& MakeCoPauseStatement::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

/***********************************************************************
MakeCoProviderStatement
***********************************************************************/

	MakeCoProviderStatement& MakeCoProviderStatement::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeCoProviderStatement& MakeCoProviderStatement::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

	MakeCoProviderStatement& MakeCoProviderStatement::expandedStatement(const vl::Ptr<WfStatement>& value)
	{
		node->expandedStatement = value;
		return *this;
	}

/***********************************************************************
MakeConstructorArgument
***********************************************************************/

	MakeConstructorArgument& MakeConstructorArgument::key(const vl::Ptr<WfExpression>& value)
	{
		node->key = value;
		return *this;
	}

	MakeConstructorArgument& MakeConstructorArgument::value(const vl::Ptr<WfExpression>& value)
	{
		node->value = value;
		return *this;
	}

/***********************************************************************
MakeConstructorDeclaration
***********************************************************************/

	MakeConstructorDeclaration& MakeConstructorDeclaration::arguments(const vl::Ptr<WfFunctionArgument>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeConstructorDeclaration& MakeConstructorDeclaration::baseConstructorCalls(const vl::Ptr<WfBaseConstructorCall>& value)
	{
		node->baseConstructorCalls.Add(value);
		return *this;
	}

	MakeConstructorDeclaration& MakeConstructorDeclaration::constructorType(WfConstructorType value)
	{
		node->constructorType = value;
		return *this;
	}

	MakeConstructorDeclaration& MakeConstructorDeclaration::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

	MakeConstructorDeclaration& MakeConstructorDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeConstructorDeclaration& MakeConstructorDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeConstructorExpression
***********************************************************************/

	MakeConstructorExpression& MakeConstructorExpression::arguments(const vl::Ptr<WfConstructorArgument>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

/***********************************************************************
MakeDeclaration
***********************************************************************/

	MakeDeclaration& MakeDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeDeclaration& MakeDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeDeleteStatement
***********************************************************************/

	MakeDeleteStatement& MakeDeleteStatement::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

/***********************************************************************
MakeDestructorDeclaration
***********************************************************************/

	MakeDestructorDeclaration& MakeDestructorDeclaration::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

	MakeDestructorDeclaration& MakeDestructorDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeDestructorDeclaration& MakeDestructorDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeDetachEventExpression
***********************************************************************/

	MakeDetachEventExpression& MakeDetachEventExpression::event(const vl::Ptr<WfExpression>& value)
	{
		node->event = value;
		return *this;
	}

	MakeDetachEventExpression& MakeDetachEventExpression::handler(const vl::Ptr<WfExpression>& value)
	{
		node->handler = value;
		return *this;
	}

/***********************************************************************
MakeEnumDeclaration
***********************************************************************/

	MakeEnumDeclaration& MakeEnumDeclaration::items(const vl::Ptr<WfEnumItem>& value)
	{
		node->items.Add(value);
		return *this;
	}

	MakeEnumDeclaration& MakeEnumDeclaration::kind(WfEnumKind value)
	{
		node->kind = value;
		return *this;
	}

	MakeEnumDeclaration& MakeEnumDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeEnumDeclaration& MakeEnumDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeEnumItem
***********************************************************************/

	MakeEnumItem& MakeEnumItem::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeEnumItem& MakeEnumItem::intersections(const vl::Ptr<WfEnumItemIntersection>& value)
	{
		node->intersections.Add(value);
		return *this;
	}

	MakeEnumItem& MakeEnumItem::kind(WfEnumItemKind value)
	{
		node->kind = value;
		return *this;
	}

	MakeEnumItem& MakeEnumItem::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeEnumItem& MakeEnumItem::number(const vl::WString& value)
	{
		node->number.value = value;
		return *this;
	}

/***********************************************************************
MakeEnumItemIntersection
***********************************************************************/

	MakeEnumItemIntersection& MakeEnumItemIntersection::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeEnumerableType
***********************************************************************/

	MakeEnumerableType& MakeEnumerableType::element(const vl::Ptr<WfType>& value)
	{
		node->element = value;
		return *this;
	}

/***********************************************************************
MakeEventDeclaration
***********************************************************************/

	MakeEventDeclaration& MakeEventDeclaration::arguments(const vl::Ptr<WfType>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeEventDeclaration& MakeEventDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeEventDeclaration& MakeEventDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeExpectedTypeCastExpression
***********************************************************************/

	MakeExpectedTypeCastExpression& MakeExpectedTypeCastExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeExpectedTypeCastExpression& MakeExpectedTypeCastExpression::strategy(WfTypeCastingStrategy value)
	{
		node->strategy = value;
		return *this;
	}

	MakeExpectedTypeCastExpression& MakeExpectedTypeCastExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeExpressionStatement
***********************************************************************/

	MakeExpressionStatement& MakeExpressionStatement::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

/***********************************************************************
MakeFloatingExpression
***********************************************************************/

	MakeFloatingExpression& MakeFloatingExpression::value(const vl::WString& value)
	{
		node->value.value = value;
		return *this;
	}

/***********************************************************************
MakeForEachStatement
***********************************************************************/

	MakeForEachStatement& MakeForEachStatement::collection(const vl::Ptr<WfExpression>& value)
	{
		node->collection = value;
		return *this;
	}

	MakeForEachStatement& MakeForEachStatement::direction(WfForEachDirection value)
	{
		node->direction = value;
		return *this;
	}

	MakeForEachStatement& MakeForEachStatement::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeForEachStatement& MakeForEachStatement::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

	MakeForEachStatement& MakeForEachStatement::expandedStatement(const vl::Ptr<WfStatement>& value)
	{
		node->expandedStatement = value;
		return *this;
	}

/***********************************************************************
MakeFormatExpression
***********************************************************************/

	MakeFormatExpression& MakeFormatExpression::value(const vl::WString& value)
	{
		node->value.value = value;
		return *this;
	}

	MakeFormatExpression& MakeFormatExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeFunctionArgument
***********************************************************************/

	MakeFunctionArgument& MakeFunctionArgument::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeFunctionArgument& MakeFunctionArgument::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeFunctionArgument& MakeFunctionArgument::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeFunctionDeclaration
***********************************************************************/

	MakeFunctionDeclaration& MakeFunctionDeclaration::anonymity(WfFunctionAnonymity value)
	{
		node->anonymity = value;
		return *this;
	}

	MakeFunctionDeclaration& MakeFunctionDeclaration::arguments(const vl::Ptr<WfFunctionArgument>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeFunctionDeclaration& MakeFunctionDeclaration::functionKind(WfFunctionKind value)
	{
		node->functionKind = value;
		return *this;
	}

	MakeFunctionDeclaration& MakeFunctionDeclaration::returnType(const vl::Ptr<WfType>& value)
	{
		node->returnType = value;
		return *this;
	}

	MakeFunctionDeclaration& MakeFunctionDeclaration::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

	MakeFunctionDeclaration& MakeFunctionDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeFunctionDeclaration& MakeFunctionDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeFunctionExpression
***********************************************************************/

	MakeFunctionExpression& MakeFunctionExpression::function(const vl::Ptr<WfFunctionDeclaration>& value)
	{
		node->function = value;
		return *this;
	}

/***********************************************************************
MakeFunctionType
***********************************************************************/

	MakeFunctionType& MakeFunctionType::arguments(const vl::Ptr<WfType>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeFunctionType& MakeFunctionType::result(const vl::Ptr<WfType>& value)
	{
		node->result = value;
		return *this;
	}

/***********************************************************************
MakeGotoStatement
***********************************************************************/

	MakeGotoStatement& MakeGotoStatement::label(const vl::WString& value)
	{
		node->label.value = value;
		return *this;
	}

/***********************************************************************
MakeIfExpression
***********************************************************************/

	MakeIfExpression& MakeIfExpression::condition(const vl::Ptr<WfExpression>& value)
	{
		node->condition = value;
		return *this;
	}

	MakeIfExpression& MakeIfExpression::falseBranch(const vl::Ptr<WfExpression>& value)
	{
		node->falseBranch = value;
		return *this;
	}

	MakeIfExpression& MakeIfExpression::trueBranch(const vl::Ptr<WfExpression>& value)
	{
		node->trueBranch = value;
		return *this;
	}

/***********************************************************************
MakeIfStatement
***********************************************************************/

	MakeIfStatement& MakeIfStatement::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeIfStatement& MakeIfStatement::falseBranch(const vl::Ptr<WfStatement>& value)
	{
		node->falseBranch = value;
		return *this;
	}

	MakeIfStatement& MakeIfStatement::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeIfStatement& MakeIfStatement::trueBranch(const vl::Ptr<WfStatement>& value)
	{
		node->trueBranch = value;
		return *this;
	}

	MakeIfStatement& MakeIfStatement::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeInferExpression
***********************************************************************/

	MakeInferExpression& MakeInferExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeInferExpression& MakeInferExpression::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeIntegerExpression
***********************************************************************/

	MakeIntegerExpression& MakeIntegerExpression::value(const vl::WString& value)
	{
		node->value.value = value;
		return *this;
	}

/***********************************************************************
MakeLetExpression
***********************************************************************/

	MakeLetExpression& MakeLetExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeLetExpression& MakeLetExpression::variables(const vl::Ptr<WfLetVariable>& value)
	{
		node->variables.Add(value);
		return *this;
	}

/***********************************************************************
MakeLetVariable
***********************************************************************/

	MakeLetVariable& MakeLetVariable::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeLetVariable& MakeLetVariable::value(const vl::Ptr<WfExpression>& value)
	{
		node->value = value;
		return *this;
	}

/***********************************************************************
MakeLiteralExpression
***********************************************************************/

	MakeLiteralExpression& MakeLiteralExpression::value(WfLiteralValue value)
	{
		node->value = value;
		return *this;
	}

/***********************************************************************
MakeMapType
***********************************************************************/

	MakeMapType& MakeMapType::key(const vl::Ptr<WfType>& value)
	{
		node->key = value;
		return *this;
	}

	MakeMapType& MakeMapType::value(const vl::Ptr<WfType>& value)
	{
		node->value = value;
		return *this;
	}

	MakeMapType& MakeMapType::writability(WfMapWritability value)
	{
		node->writability = value;
		return *this;
	}

/***********************************************************************
MakeMemberExpression
***********************************************************************/

	MakeMemberExpression& MakeMemberExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeMemberExpression& MakeMemberExpression::parent(const vl::Ptr<WfExpression>& value)
	{
		node->parent = value;
		return *this;
	}

/***********************************************************************
MakeMixinCastExpression
***********************************************************************/

	MakeMixinCastExpression& MakeMixinCastExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeMixinCastExpression& MakeMixinCastExpression::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

	MakeMixinCastExpression& MakeMixinCastExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeModule
***********************************************************************/

	MakeModule& MakeModule::declarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->declarations.Add(value);
		return *this;
	}

	MakeModule& MakeModule::moduleType(WfModuleType value)
	{
		node->moduleType = value;
		return *this;
	}

	MakeModule& MakeModule::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeModule& MakeModule::paths(const vl::Ptr<WfModuleUsingPath>& value)
	{
		node->paths.Add(value);
		return *this;
	}

/***********************************************************************
MakeModuleUsingItem
***********************************************************************/

	MakeModuleUsingItem& MakeModuleUsingItem::fragments(const vl::Ptr<WfModuleUsingFragment>& value)
	{
		node->fragments.Add(value);
		return *this;
	}

/***********************************************************************
MakeModuleUsingNameFragment
***********************************************************************/

	MakeModuleUsingNameFragment& MakeModuleUsingNameFragment::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeModuleUsingPath
***********************************************************************/

	MakeModuleUsingPath& MakeModuleUsingPath::items(const vl::Ptr<WfModuleUsingItem>& value)
	{
		node->items.Add(value);
		return *this;
	}

/***********************************************************************
MakeNamespaceDeclaration
***********************************************************************/

	MakeNamespaceDeclaration& MakeNamespaceDeclaration::declarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->declarations.Add(value);
		return *this;
	}

	MakeNamespaceDeclaration& MakeNamespaceDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeNamespaceDeclaration& MakeNamespaceDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeNewClassExpression
***********************************************************************/

	MakeNewClassExpression& MakeNewClassExpression::arguments(const vl::Ptr<WfExpression>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeNewClassExpression& MakeNewClassExpression::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeNewCoroutineExpression
***********************************************************************/

	MakeNewCoroutineExpression& MakeNewCoroutineExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeNewCoroutineExpression& MakeNewCoroutineExpression::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

	MakeNewCoroutineExpression& MakeNewCoroutineExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeNewInterfaceExpression
***********************************************************************/

	MakeNewInterfaceExpression& MakeNewInterfaceExpression::declarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->declarations.Add(value);
		return *this;
	}

	MakeNewInterfaceExpression& MakeNewInterfaceExpression::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeNullableType
***********************************************************************/

	MakeNullableType& MakeNullableType::element(const vl::Ptr<WfType>& value)
	{
		node->element = value;
		return *this;
	}

/***********************************************************************
MakeObservableListType
***********************************************************************/

	MakeObservableListType& MakeObservableListType::element(const vl::Ptr<WfType>& value)
	{
		node->element = value;
		return *this;
	}

/***********************************************************************
MakeObserveExpression
***********************************************************************/

	MakeObserveExpression& MakeObserveExpression::events(const vl::Ptr<WfExpression>& value)
	{
		node->events.Add(value);
		return *this;
	}

	MakeObserveExpression& MakeObserveExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeObserveExpression& MakeObserveExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeObserveExpression& MakeObserveExpression::observeType(WfObserveType value)
	{
		node->observeType = value;
		return *this;
	}

	MakeObserveExpression& MakeObserveExpression::parent(const vl::Ptr<WfExpression>& value)
	{
		node->parent = value;
		return *this;
	}

/***********************************************************************
MakeOrderedLambdaExpression
***********************************************************************/

	MakeOrderedLambdaExpression& MakeOrderedLambdaExpression::body(const vl::Ptr<WfExpression>& value)
	{
		node->body = value;
		return *this;
	}

/***********************************************************************
MakeOrderedNameExpression
***********************************************************************/

	MakeOrderedNameExpression& MakeOrderedNameExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakePredefinedType
***********************************************************************/

	MakePredefinedType& MakePredefinedType::name(WfPredefinedTypeName value)
	{
		node->name = value;
		return *this;
	}

/***********************************************************************
MakePropertyDeclaration
***********************************************************************/

	MakePropertyDeclaration& MakePropertyDeclaration::getter(const vl::WString& value)
	{
		node->getter.value = value;
		return *this;
	}

	MakePropertyDeclaration& MakePropertyDeclaration::setter(const vl::WString& value)
	{
		node->setter.value = value;
		return *this;
	}

	MakePropertyDeclaration& MakePropertyDeclaration::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

	MakePropertyDeclaration& MakePropertyDeclaration::valueChangedEvent(const vl::WString& value)
	{
		node->valueChangedEvent.value = value;
		return *this;
	}

	MakePropertyDeclaration& MakePropertyDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakePropertyDeclaration& MakePropertyDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeRaiseExceptionStatement
***********************************************************************/

	MakeRaiseExceptionStatement& MakeRaiseExceptionStatement::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

/***********************************************************************
MakeRangeExpression
***********************************************************************/

	MakeRangeExpression& MakeRangeExpression::begin(const vl::Ptr<WfExpression>& value)
	{
		node->begin = value;
		return *this;
	}

	MakeRangeExpression& MakeRangeExpression::beginBoundary(WfRangeBoundary value)
	{
		node->beginBoundary = value;
		return *this;
	}

	MakeRangeExpression& MakeRangeExpression::end(const vl::Ptr<WfExpression>& value)
	{
		node->end = value;
		return *this;
	}

	MakeRangeExpression& MakeRangeExpression::endBoundary(WfRangeBoundary value)
	{
		node->endBoundary = value;
		return *this;
	}

/***********************************************************************
MakeRawPointerType
***********************************************************************/

	MakeRawPointerType& MakeRawPointerType::element(const vl::Ptr<WfType>& value)
	{
		node->element = value;
		return *this;
	}

/***********************************************************************
MakeReferenceExpression
***********************************************************************/

	MakeReferenceExpression& MakeReferenceExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeReferenceType
***********************************************************************/

	MakeReferenceType& MakeReferenceType::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeReturnStatement
***********************************************************************/

	MakeReturnStatement& MakeReturnStatement::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

/***********************************************************************
MakeSetTestingExpression
***********************************************************************/

	MakeSetTestingExpression& MakeSetTestingExpression::collection(const vl::Ptr<WfExpression>& value)
	{
		node->collection = value;
		return *this;
	}

	MakeSetTestingExpression& MakeSetTestingExpression::element(const vl::Ptr<WfExpression>& value)
	{
		node->element = value;
		return *this;
	}

	MakeSetTestingExpression& MakeSetTestingExpression::test(WfSetTesting value)
	{
		node->test = value;
		return *this;
	}

/***********************************************************************
MakeSharedPointerType
***********************************************************************/

	MakeSharedPointerType& MakeSharedPointerType::element(const vl::Ptr<WfType>& value)
	{
		node->element = value;
		return *this;
	}

/***********************************************************************
MakeStateDeclaration
***********************************************************************/

	MakeStateDeclaration& MakeStateDeclaration::arguments(const vl::Ptr<WfFunctionArgument>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeStateDeclaration& MakeStateDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeStateDeclaration& MakeStateDeclaration::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

/***********************************************************************
MakeStateInput
***********************************************************************/

	MakeStateInput& MakeStateInput::arguments(const vl::Ptr<WfFunctionArgument>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeStateInput& MakeStateInput::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeStateInvokeStatement
***********************************************************************/

	MakeStateInvokeStatement& MakeStateInvokeStatement::arguments(const vl::Ptr<WfExpression>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeStateInvokeStatement& MakeStateInvokeStatement::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeStateInvokeStatement& MakeStateInvokeStatement::type(WfStateInvokeType value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeStateMachineDeclaration
***********************************************************************/

	MakeStateMachineDeclaration& MakeStateMachineDeclaration::inputs(const vl::Ptr<WfStateInput>& value)
	{
		node->inputs.Add(value);
		return *this;
	}

	MakeStateMachineDeclaration& MakeStateMachineDeclaration::states(const vl::Ptr<WfStateDeclaration>& value)
	{
		node->states.Add(value);
		return *this;
	}

	MakeStateMachineDeclaration& MakeStateMachineDeclaration::expandedDeclarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->expandedDeclarations.Add(value);
		return *this;
	}

	MakeStateMachineDeclaration& MakeStateMachineDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeStateMachineDeclaration& MakeStateMachineDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeStateSwitchArgument
***********************************************************************/

	MakeStateSwitchArgument& MakeStateSwitchArgument::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeStateSwitchCase
***********************************************************************/

	MakeStateSwitchCase& MakeStateSwitchCase::arguments(const vl::Ptr<WfStateSwitchArgument>& value)
	{
		node->arguments.Add(value);
		return *this;
	}

	MakeStateSwitchCase& MakeStateSwitchCase::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeStateSwitchCase& MakeStateSwitchCase::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

/***********************************************************************
MakeStateSwitchStatement
***********************************************************************/

	MakeStateSwitchStatement& MakeStateSwitchStatement::caseBranches(const vl::Ptr<WfStateSwitchCase>& value)
	{
		node->caseBranches.Add(value);
		return *this;
	}

	MakeStateSwitchStatement& MakeStateSwitchStatement::type(WfStateSwitchType value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeStaticInitDeclaration
***********************************************************************/

	MakeStaticInitDeclaration& MakeStaticInitDeclaration::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

	MakeStaticInitDeclaration& MakeStaticInitDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeStaticInitDeclaration& MakeStaticInitDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeStringExpression
***********************************************************************/

	MakeStringExpression& MakeStringExpression::value(const vl::WString& value)
	{
		node->value.value = value;
		return *this;
	}

/***********************************************************************
MakeStructDeclaration
***********************************************************************/

	MakeStructDeclaration& MakeStructDeclaration::members(const vl::Ptr<WfStructMember>& value)
	{
		node->members.Add(value);
		return *this;
	}

	MakeStructDeclaration& MakeStructDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeStructDeclaration& MakeStructDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeStructMember
***********************************************************************/

	MakeStructMember& MakeStructMember::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeStructMember& MakeStructMember::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeStructMember& MakeStructMember::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeSwitchCase
***********************************************************************/

	MakeSwitchCase& MakeSwitchCase::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeSwitchCase& MakeSwitchCase::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}

/***********************************************************************
MakeSwitchStatement
***********************************************************************/

	MakeSwitchStatement& MakeSwitchStatement::caseBranches(const vl::Ptr<WfSwitchCase>& value)
	{
		node->caseBranches.Add(value);
		return *this;
	}

	MakeSwitchStatement& MakeSwitchStatement::defaultBranch(const vl::Ptr<WfStatement>& value)
	{
		node->defaultBranch = value;
		return *this;
	}

	MakeSwitchStatement& MakeSwitchStatement::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeSwitchStatement& MakeSwitchStatement::expandedStatement(const vl::Ptr<WfStatement>& value)
	{
		node->expandedStatement = value;
		return *this;
	}

/***********************************************************************
MakeTopQualifiedExpression
***********************************************************************/

	MakeTopQualifiedExpression& MakeTopQualifiedExpression::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeTopQualifiedType
***********************************************************************/

	MakeTopQualifiedType& MakeTopQualifiedType::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeTryStatement
***********************************************************************/

	MakeTryStatement& MakeTryStatement::catchStatement(const vl::Ptr<WfStatement>& value)
	{
		node->catchStatement = value;
		return *this;
	}

	MakeTryStatement& MakeTryStatement::finallyStatement(const vl::Ptr<WfStatement>& value)
	{
		node->finallyStatement = value;
		return *this;
	}

	MakeTryStatement& MakeTryStatement::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

	MakeTryStatement& MakeTryStatement::protectedStatement(const vl::Ptr<WfStatement>& value)
	{
		node->protectedStatement = value;
		return *this;
	}

/***********************************************************************
MakeTypeCastingExpression
***********************************************************************/

	MakeTypeCastingExpression& MakeTypeCastingExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeTypeCastingExpression& MakeTypeCastingExpression::strategy(WfTypeCastingStrategy value)
	{
		node->strategy = value;
		return *this;
	}

	MakeTypeCastingExpression& MakeTypeCastingExpression::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeTypeOfExpressionExpression
***********************************************************************/

	MakeTypeOfExpressionExpression& MakeTypeOfExpressionExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

/***********************************************************************
MakeTypeOfTypeExpression
***********************************************************************/

	MakeTypeOfTypeExpression& MakeTypeOfTypeExpression::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeTypeTestingExpression
***********************************************************************/

	MakeTypeTestingExpression& MakeTypeTestingExpression::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeTypeTestingExpression& MakeTypeTestingExpression::test(WfTypeTesting value)
	{
		node->test = value;
		return *this;
	}

	MakeTypeTestingExpression& MakeTypeTestingExpression::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

/***********************************************************************
MakeUnaryExpression
***********************************************************************/

	MakeUnaryExpression& MakeUnaryExpression::op(WfUnaryOperator value)
	{
		node->op = value;
		return *this;
	}

	MakeUnaryExpression& MakeUnaryExpression::operand(const vl::Ptr<WfExpression>& value)
	{
		node->operand = value;
		return *this;
	}

/***********************************************************************
MakeVariableDeclaration
***********************************************************************/

	MakeVariableDeclaration& MakeVariableDeclaration::expression(const vl::Ptr<WfExpression>& value)
	{
		node->expression = value;
		return *this;
	}

	MakeVariableDeclaration& MakeVariableDeclaration::type(const vl::Ptr<WfType>& value)
	{
		node->type = value;
		return *this;
	}

	MakeVariableDeclaration& MakeVariableDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeVariableDeclaration& MakeVariableDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeVariableStatement
***********************************************************************/

	MakeVariableStatement& MakeVariableStatement::variable(const vl::Ptr<WfVariableDeclaration>& value)
	{
		node->variable = value;
		return *this;
	}

/***********************************************************************
MakeVirtualCfeDeclaration
***********************************************************************/

	MakeVirtualCfeDeclaration& MakeVirtualCfeDeclaration::expandedDeclarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->expandedDeclarations.Add(value);
		return *this;
	}

	MakeVirtualCfeDeclaration& MakeVirtualCfeDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeVirtualCfeDeclaration& MakeVirtualCfeDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeVirtualCfeExpression
***********************************************************************/

	MakeVirtualCfeExpression& MakeVirtualCfeExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeVirtualCseDeclaration
***********************************************************************/

	MakeVirtualCseDeclaration& MakeVirtualCseDeclaration::expandedDeclarations(const vl::Ptr<WfDeclaration>& value)
	{
		node->expandedDeclarations.Add(value);
		return *this;
	}

	MakeVirtualCseDeclaration& MakeVirtualCseDeclaration::attributes(const vl::Ptr<WfAttribute>& value)
	{
		node->attributes.Add(value);
		return *this;
	}

	MakeVirtualCseDeclaration& MakeVirtualCseDeclaration::name(const vl::WString& value)
	{
		node->name.value = value;
		return *this;
	}

/***********************************************************************
MakeVirtualCseExpression
***********************************************************************/

	MakeVirtualCseExpression& MakeVirtualCseExpression::expandedExpression(const vl::Ptr<WfExpression>& value)
	{
		node->expandedExpression = value;
		return *this;
	}

/***********************************************************************
MakeVirtualCseStatement
***********************************************************************/

	MakeVirtualCseStatement& MakeVirtualCseStatement::expandedStatement(const vl::Ptr<WfStatement>& value)
	{
		node->expandedStatement = value;
		return *this;
	}

/***********************************************************************
MakeWhileStatement
***********************************************************************/

	MakeWhileStatement& MakeWhileStatement::condition(const vl::Ptr<WfExpression>& value)
	{
		node->condition = value;
		return *this;
	}

	MakeWhileStatement& MakeWhileStatement::statement(const vl::Ptr<WfStatement>& value)
	{
		node->statement = value;
		return *this;
	}
}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_COPY.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow::copy_visitor
{
	void AstVisitor::CopyFields(WfAttachEventExpression* from, WfAttachEventExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->event = CopyNode(from->event.Obj());
		to->function = CopyNode(from->function.Obj());
	}

	void AstVisitor::CopyFields(WfAttribute* from, WfAttribute* to)
	{
		to->category = from->category;
		to->name = from->name;
		to->value = CopyNode(from->value.Obj());
	}

	void AstVisitor::CopyFields(WfAutoPropertyDeclaration* from, WfAutoPropertyDeclaration* to)
	{
		CopyFields(static_cast<WfVirtualCfeDeclaration*>(from), static_cast<WfVirtualCfeDeclaration*>(to));
		to->configConst = from->configConst;
		to->configObserve = from->configObserve;
		to->expression = CopyNode(from->expression.Obj());
		to->functionKind = from->functionKind;
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfBaseConstructorCall* from, WfBaseConstructorCall* to)
	{
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfBinaryExpression* from, WfBinaryExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->first = CopyNode(from->first.Obj());
		to->op = from->op;
		to->second = CopyNode(from->second.Obj());
	}

	void AstVisitor::CopyFields(WfBindExpression* from, WfBindExpression* to)
	{
		CopyFields(static_cast<WfVirtualCseExpression*>(from), static_cast<WfVirtualCseExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
	}

	void AstVisitor::CopyFields(WfBlockStatement* from, WfBlockStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->endLabel = from->endLabel;
		for (auto&& listItem : from->statements)
		{
			to->statements.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfBreakStatement* from, WfBreakStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
	}

	void AstVisitor::CopyFields(WfCallExpression* from, WfCallExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->function = CopyNode(from->function.Obj());
	}

	void AstVisitor::CopyFields(WfCastResultInterfaceDeclaration* from, WfCastResultInterfaceDeclaration* to)
	{
		CopyFields(static_cast<WfVirtualCfeDeclaration*>(from), static_cast<WfVirtualCfeDeclaration*>(to));
		to->baseType = CopyNode(from->baseType.Obj());
		to->elementType = CopyNode(from->elementType.Obj());
	}

	void AstVisitor::CopyFields(WfChildExpression* from, WfChildExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->name = from->name;
		to->parent = CopyNode(from->parent.Obj());
	}

	void AstVisitor::CopyFields(WfChildType* from, WfChildType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->name = from->name;
		to->parent = CopyNode(from->parent.Obj());
	}

	void AstVisitor::CopyFields(WfClassDeclaration* from, WfClassDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->baseTypes)
		{
			to->baseTypes.Add(CopyNode(listItem.Obj()));
		}
		to->constructorType = from->constructorType;
		for (auto&& listItem : from->declarations)
		{
			to->declarations.Add(CopyNode(listItem.Obj()));
		}
		to->kind = from->kind;
	}

	void AstVisitor::CopyFields(WfCoOperatorExpression* from, WfCoOperatorExpression* to)
	{
		CopyFields(static_cast<WfVirtualCseExpression*>(from), static_cast<WfVirtualCseExpression*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfCoOperatorStatement* from, WfCoOperatorStatement* to)
	{
		CopyFields(static_cast<WfCoroutineStatement*>(from), static_cast<WfCoroutineStatement*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->opName = from->opName;
		to->varName = from->varName;
	}

	void AstVisitor::CopyFields(WfCoPauseStatement* from, WfCoPauseStatement* to)
	{
		CopyFields(static_cast<WfCoroutineStatement*>(from), static_cast<WfCoroutineStatement*>(to));
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfCoProviderStatement* from, WfCoProviderStatement* to)
	{
		CopyFields(static_cast<WfVirtualCseStatement*>(from), static_cast<WfVirtualCseStatement*>(to));
		to->name = from->name;
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfConstructorArgument* from, WfConstructorArgument* to)
	{
		to->key = CopyNode(from->key.Obj());
		to->value = CopyNode(from->value.Obj());
	}

	void AstVisitor::CopyFields(WfConstructorDeclaration* from, WfConstructorDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		for (auto&& listItem : from->baseConstructorCalls)
		{
			to->baseConstructorCalls.Add(CopyNode(listItem.Obj()));
		}
		to->constructorType = from->constructorType;
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfConstructorExpression* from, WfConstructorExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfContinueStatement* from, WfContinueStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
	}

	void AstVisitor::CopyFields(WfCoroutineStatement* from, WfCoroutineStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
	}

	void AstVisitor::CopyFields(WfDeclaration* from, WfDeclaration* to)
	{
		for (auto&& listItem : from->attributes)
		{
			to->attributes.Add(CopyNode(listItem.Obj()));
		}
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfDeleteStatement* from, WfDeleteStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->expression = CopyNode(from->expression.Obj());
	}

	void AstVisitor::CopyFields(WfDestructorDeclaration* from, WfDestructorDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfDetachEventExpression* from, WfDetachEventExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->event = CopyNode(from->event.Obj());
		to->handler = CopyNode(from->handler.Obj());
	}

	void AstVisitor::CopyFields(WfEnumDeclaration* from, WfEnumDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->items)
		{
			to->items.Add(CopyNode(listItem.Obj()));
		}
		to->kind = from->kind;
	}

	void AstVisitor::CopyFields(WfEnumItem* from, WfEnumItem* to)
	{
		for (auto&& listItem : from->attributes)
		{
			to->attributes.Add(CopyNode(listItem.Obj()));
		}
		for (auto&& listItem : from->intersections)
		{
			to->intersections.Add(CopyNode(listItem.Obj()));
		}
		to->kind = from->kind;
		to->name = from->name;
		to->number = from->number;
	}

	void AstVisitor::CopyFields(WfEnumItemIntersection* from, WfEnumItemIntersection* to)
	{
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfEnumerableType* from, WfEnumerableType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->element = CopyNode(from->element.Obj());
	}

	void AstVisitor::CopyFields(WfEventDeclaration* from, WfEventDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfExpectedTypeCastExpression* from, WfExpectedTypeCastExpression* to)
	{
		CopyFields(static_cast<WfVirtualCseExpression*>(from), static_cast<WfVirtualCseExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
		to->strategy = from->strategy;
	}

	void AstVisitor::CopyFields(WfExpression* from, WfExpression* to)
	{
	}

	void AstVisitor::CopyFields(WfExpressionStatement* from, WfExpressionStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->expression = CopyNode(from->expression.Obj());
	}

	void AstVisitor::CopyFields(WfFloatingExpression* from, WfFloatingExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->value = from->value;
	}

	void AstVisitor::CopyFields(WfForEachStatement* from, WfForEachStatement* to)
	{
		CopyFields(static_cast<WfVirtualCseStatement*>(from), static_cast<WfVirtualCseStatement*>(to));
		to->collection = CopyNode(from->collection.Obj());
		to->direction = from->direction;
		to->name = from->name;
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfFormatExpression* from, WfFormatExpression* to)
	{
		CopyFields(static_cast<WfVirtualCfeExpression*>(from), static_cast<WfVirtualCfeExpression*>(to));
		to->value = from->value;
	}

	void AstVisitor::CopyFields(WfFunctionArgument* from, WfFunctionArgument* to)
	{
		for (auto&& listItem : from->attributes)
		{
			to->attributes.Add(CopyNode(listItem.Obj()));
		}
		to->name = from->name;
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfFunctionDeclaration* from, WfFunctionDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		to->anonymity = from->anonymity;
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->functionKind = from->functionKind;
		to->returnType = CopyNode(from->returnType.Obj());
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfFunctionExpression* from, WfFunctionExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->function = CopyNode(from->function.Obj());
	}

	void AstVisitor::CopyFields(WfFunctionType* from, WfFunctionType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->result = CopyNode(from->result.Obj());
	}

	void AstVisitor::CopyFields(WfGotoStatement* from, WfGotoStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->label = from->label;
	}

	void AstVisitor::CopyFields(WfIfExpression* from, WfIfExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->condition = CopyNode(from->condition.Obj());
		to->falseBranch = CopyNode(from->falseBranch.Obj());
		to->trueBranch = CopyNode(from->trueBranch.Obj());
	}

	void AstVisitor::CopyFields(WfIfStatement* from, WfIfStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->expression = CopyNode(from->expression.Obj());
		to->falseBranch = CopyNode(from->falseBranch.Obj());
		to->name = from->name;
		to->trueBranch = CopyNode(from->trueBranch.Obj());
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfInferExpression* from, WfInferExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfIntegerExpression* from, WfIntegerExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->value = from->value;
	}

	void AstVisitor::CopyFields(WfLetExpression* from, WfLetExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
		for (auto&& listItem : from->variables)
		{
			to->variables.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfLetVariable* from, WfLetVariable* to)
	{
		to->name = from->name;
		to->value = CopyNode(from->value.Obj());
	}

	void AstVisitor::CopyFields(WfLiteralExpression* from, WfLiteralExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->value = from->value;
	}

	void AstVisitor::CopyFields(WfMapType* from, WfMapType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->key = CopyNode(from->key.Obj());
		to->value = CopyNode(from->value.Obj());
		to->writability = from->writability;
	}

	void AstVisitor::CopyFields(WfMemberExpression* from, WfMemberExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->name = from->name;
		to->parent = CopyNode(from->parent.Obj());
	}

	void AstVisitor::CopyFields(WfMixinCastExpression* from, WfMixinCastExpression* to)
	{
		CopyFields(static_cast<WfVirtualCseExpression*>(from), static_cast<WfVirtualCseExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfModule* from, WfModule* to)
	{
		for (auto&& listItem : from->declarations)
		{
			to->declarations.Add(CopyNode(listItem.Obj()));
		}
		to->moduleType = from->moduleType;
		to->name = from->name;
		for (auto&& listItem : from->paths)
		{
			to->paths.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfModuleUsingFragment* from, WfModuleUsingFragment* to)
	{
	}

	void AstVisitor::CopyFields(WfModuleUsingItem* from, WfModuleUsingItem* to)
	{
		for (auto&& listItem : from->fragments)
		{
			to->fragments.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfModuleUsingNameFragment* from, WfModuleUsingNameFragment* to)
	{
		CopyFields(static_cast<WfModuleUsingFragment*>(from), static_cast<WfModuleUsingFragment*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfModuleUsingPath* from, WfModuleUsingPath* to)
	{
		for (auto&& listItem : from->items)
		{
			to->items.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfModuleUsingWildCardFragment* from, WfModuleUsingWildCardFragment* to)
	{
		CopyFields(static_cast<WfModuleUsingFragment*>(from), static_cast<WfModuleUsingFragment*>(to));
	}

	void AstVisitor::CopyFields(WfNamespaceDeclaration* from, WfNamespaceDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->declarations)
		{
			to->declarations.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfNewClassExpression* from, WfNewClassExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfNewCoroutineExpression* from, WfNewCoroutineExpression* to)
	{
		CopyFields(static_cast<WfVirtualCseExpression*>(from), static_cast<WfVirtualCseExpression*>(to));
		to->name = from->name;
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfNewInterfaceExpression* from, WfNewInterfaceExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		for (auto&& listItem : from->declarations)
		{
			to->declarations.Add(CopyNode(listItem.Obj()));
		}
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfNullableType* from, WfNullableType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->element = CopyNode(from->element.Obj());
	}

	void AstVisitor::CopyFields(WfObservableListType* from, WfObservableListType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->element = CopyNode(from->element.Obj());
	}

	void AstVisitor::CopyFields(WfObserveExpression* from, WfObserveExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		for (auto&& listItem : from->events)
		{
			to->events.Add(CopyNode(listItem.Obj()));
		}
		to->expression = CopyNode(from->expression.Obj());
		to->name = from->name;
		to->observeType = from->observeType;
		to->parent = CopyNode(from->parent.Obj());
	}

	void AstVisitor::CopyFields(WfOrderedLambdaExpression* from, WfOrderedLambdaExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->body = CopyNode(from->body.Obj());
	}

	void AstVisitor::CopyFields(WfOrderedNameExpression* from, WfOrderedNameExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfPredefinedType* from, WfPredefinedType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfPropertyDeclaration* from, WfPropertyDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		to->getter = from->getter;
		to->setter = from->setter;
		to->type = CopyNode(from->type.Obj());
		to->valueChangedEvent = from->valueChangedEvent;
	}

	void AstVisitor::CopyFields(WfRaiseExceptionStatement* from, WfRaiseExceptionStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->expression = CopyNode(from->expression.Obj());
	}

	void AstVisitor::CopyFields(WfRangeExpression* from, WfRangeExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->begin = CopyNode(from->begin.Obj());
		to->beginBoundary = from->beginBoundary;
		to->end = CopyNode(from->end.Obj());
		to->endBoundary = from->endBoundary;
	}

	void AstVisitor::CopyFields(WfRawPointerType* from, WfRawPointerType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->element = CopyNode(from->element.Obj());
	}

	void AstVisitor::CopyFields(WfReferenceExpression* from, WfReferenceExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfReferenceType* from, WfReferenceType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfReturnStatement* from, WfReturnStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->expression = CopyNode(from->expression.Obj());
	}

	void AstVisitor::CopyFields(WfSetTestingExpression* from, WfSetTestingExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->collection = CopyNode(from->collection.Obj());
		to->element = CopyNode(from->element.Obj());
		to->test = from->test;
	}

	void AstVisitor::CopyFields(WfSharedPointerType* from, WfSharedPointerType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->element = CopyNode(from->element.Obj());
	}

	void AstVisitor::CopyFields(WfStateDeclaration* from, WfStateDeclaration* to)
	{
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->name = from->name;
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfStateInput* from, WfStateInput* to)
	{
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfStateInvokeStatement* from, WfStateInvokeStatement* to)
	{
		CopyFields(static_cast<WfStateMachineStatement*>(from), static_cast<WfStateMachineStatement*>(to));
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->name = from->name;
		to->type = from->type;
	}

	void AstVisitor::CopyFields(WfStateMachineDeclaration* from, WfStateMachineDeclaration* to)
	{
		CopyFields(static_cast<WfVirtualCseDeclaration*>(from), static_cast<WfVirtualCseDeclaration*>(to));
		for (auto&& listItem : from->inputs)
		{
			to->inputs.Add(CopyNode(listItem.Obj()));
		}
		for (auto&& listItem : from->states)
		{
			to->states.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfStateMachineStatement* from, WfStateMachineStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
	}

	void AstVisitor::CopyFields(WfStateSwitchArgument* from, WfStateSwitchArgument* to)
	{
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfStateSwitchCase* from, WfStateSwitchCase* to)
	{
		for (auto&& listItem : from->arguments)
		{
			to->arguments.Add(CopyNode(listItem.Obj()));
		}
		to->name = from->name;
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfStateSwitchStatement* from, WfStateSwitchStatement* to)
	{
		CopyFields(static_cast<WfStateMachineStatement*>(from), static_cast<WfStateMachineStatement*>(to));
		for (auto&& listItem : from->caseBranches)
		{
			to->caseBranches.Add(CopyNode(listItem.Obj()));
		}
		to->type = from->type;
	}

	void AstVisitor::CopyFields(WfStatement* from, WfStatement* to)
	{
	}

	void AstVisitor::CopyFields(WfStaticInitDeclaration* from, WfStaticInitDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfStringExpression* from, WfStringExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->value = from->value;
	}

	void AstVisitor::CopyFields(WfStructDeclaration* from, WfStructDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->members)
		{
			to->members.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfStructMember* from, WfStructMember* to)
	{
		for (auto&& listItem : from->attributes)
		{
			to->attributes.Add(CopyNode(listItem.Obj()));
		}
		to->name = from->name;
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfSwitchCase* from, WfSwitchCase* to)
	{
		to->expression = CopyNode(from->expression.Obj());
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::CopyFields(WfSwitchStatement* from, WfSwitchStatement* to)
	{
		CopyFields(static_cast<WfVirtualCseStatement*>(from), static_cast<WfVirtualCseStatement*>(to));
		for (auto&& listItem : from->caseBranches)
		{
			to->caseBranches.Add(CopyNode(listItem.Obj()));
		}
		to->defaultBranch = CopyNode(from->defaultBranch.Obj());
		to->expression = CopyNode(from->expression.Obj());
	}

	void AstVisitor::CopyFields(WfThisExpression* from, WfThisExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
	}

	void AstVisitor::CopyFields(WfTopQualifiedExpression* from, WfTopQualifiedExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfTopQualifiedType* from, WfTopQualifiedType* to)
	{
		CopyFields(static_cast<WfType*>(from), static_cast<WfType*>(to));
		to->name = from->name;
	}

	void AstVisitor::CopyFields(WfTryStatement* from, WfTryStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->catchStatement = CopyNode(from->catchStatement.Obj());
		to->finallyStatement = CopyNode(from->finallyStatement.Obj());
		to->name = from->name;
		to->protectedStatement = CopyNode(from->protectedStatement.Obj());
	}

	void AstVisitor::CopyFields(WfType* from, WfType* to)
	{
	}

	void AstVisitor::CopyFields(WfTypeCastingExpression* from, WfTypeCastingExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
		to->strategy = from->strategy;
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfTypeOfExpressionExpression* from, WfTypeOfExpressionExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
	}

	void AstVisitor::CopyFields(WfTypeOfTypeExpression* from, WfTypeOfTypeExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfTypeTestingExpression* from, WfTypeTestingExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->expression = CopyNode(from->expression.Obj());
		to->test = from->test;
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfUnaryExpression* from, WfUnaryExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->op = from->op;
		to->operand = CopyNode(from->operand.Obj());
	}

	void AstVisitor::CopyFields(WfVariableDeclaration* from, WfVariableDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		to->expression = CopyNode(from->expression.Obj());
		to->type = CopyNode(from->type.Obj());
	}

	void AstVisitor::CopyFields(WfVariableStatement* from, WfVariableStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->variable = CopyNode(from->variable.Obj());
	}

	void AstVisitor::CopyFields(WfVirtualCfeDeclaration* from, WfVirtualCfeDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->expandedDeclarations)
		{
			to->expandedDeclarations.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfVirtualCfeExpression* from, WfVirtualCfeExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->expandedExpression = CopyNode(from->expandedExpression.Obj());
	}

	void AstVisitor::CopyFields(WfVirtualCseDeclaration* from, WfVirtualCseDeclaration* to)
	{
		CopyFields(static_cast<WfDeclaration*>(from), static_cast<WfDeclaration*>(to));
		for (auto&& listItem : from->expandedDeclarations)
		{
			to->expandedDeclarations.Add(CopyNode(listItem.Obj()));
		}
	}

	void AstVisitor::CopyFields(WfVirtualCseExpression* from, WfVirtualCseExpression* to)
	{
		CopyFields(static_cast<WfExpression*>(from), static_cast<WfExpression*>(to));
		to->expandedExpression = CopyNode(from->expandedExpression.Obj());
	}

	void AstVisitor::CopyFields(WfVirtualCseStatement* from, WfVirtualCseStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->expandedStatement = CopyNode(from->expandedStatement.Obj());
	}

	void AstVisitor::CopyFields(WfWhileStatement* from, WfWhileStatement* to)
	{
		CopyFields(static_cast<WfStatement*>(from), static_cast<WfStatement*>(to));
		to->condition = CopyNode(from->condition.Obj());
		to->statement = CopyNode(from->statement.Obj());
	}

	void AstVisitor::Visit(WfAttribute* node)
	{
		auto newNode = vl::Ptr(new WfAttribute);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfFunctionArgument* node)
	{
		auto newNode = vl::Ptr(new WfFunctionArgument);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfBaseConstructorCall* node)
	{
		auto newNode = vl::Ptr(new WfBaseConstructorCall);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfEnumItemIntersection* node)
	{
		auto newNode = vl::Ptr(new WfEnumItemIntersection);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfEnumItem* node)
	{
		auto newNode = vl::Ptr(new WfEnumItem);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStructMember* node)
	{
		auto newNode = vl::Ptr(new WfStructMember);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStateInput* node)
	{
		auto newNode = vl::Ptr(new WfStateInput);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStateDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfStateDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfSwitchCase* node)
	{
		auto newNode = vl::Ptr(new WfSwitchCase);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStateSwitchArgument* node)
	{
		auto newNode = vl::Ptr(new WfStateSwitchArgument);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStateSwitchCase* node)
	{
		auto newNode = vl::Ptr(new WfStateSwitchCase);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfLetVariable* node)
	{
		auto newNode = vl::Ptr(new WfLetVariable);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfConstructorArgument* node)
	{
		auto newNode = vl::Ptr(new WfConstructorArgument);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfModuleUsingItem* node)
	{
		auto newNode = vl::Ptr(new WfModuleUsingItem);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfModuleUsingPath* node)
	{
		auto newNode = vl::Ptr(new WfModuleUsingPath);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfModule* node)
	{
		auto newNode = vl::Ptr(new WfModule);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfPredefinedType* node)
	{
		auto newNode = vl::Ptr(new WfPredefinedType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfTopQualifiedType* node)
	{
		auto newNode = vl::Ptr(new WfTopQualifiedType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfReferenceType* node)
	{
		auto newNode = vl::Ptr(new WfReferenceType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfRawPointerType* node)
	{
		auto newNode = vl::Ptr(new WfRawPointerType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfSharedPointerType* node)
	{
		auto newNode = vl::Ptr(new WfSharedPointerType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfNullableType* node)
	{
		auto newNode = vl::Ptr(new WfNullableType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfEnumerableType* node)
	{
		auto newNode = vl::Ptr(new WfEnumerableType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfMapType* node)
	{
		auto newNode = vl::Ptr(new WfMapType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfObservableListType* node)
	{
		auto newNode = vl::Ptr(new WfObservableListType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfFunctionType* node)
	{
		auto newNode = vl::Ptr(new WfFunctionType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfChildType* node)
	{
		auto newNode = vl::Ptr(new WfChildType);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfThisExpression* node)
	{
		auto newNode = vl::Ptr(new WfThisExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfTopQualifiedExpression* node)
	{
		auto newNode = vl::Ptr(new WfTopQualifiedExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfReferenceExpression* node)
	{
		auto newNode = vl::Ptr(new WfReferenceExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfOrderedNameExpression* node)
	{
		auto newNode = vl::Ptr(new WfOrderedNameExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfOrderedLambdaExpression* node)
	{
		auto newNode = vl::Ptr(new WfOrderedLambdaExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfMemberExpression* node)
	{
		auto newNode = vl::Ptr(new WfMemberExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfChildExpression* node)
	{
		auto newNode = vl::Ptr(new WfChildExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfLiteralExpression* node)
	{
		auto newNode = vl::Ptr(new WfLiteralExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfFloatingExpression* node)
	{
		auto newNode = vl::Ptr(new WfFloatingExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfIntegerExpression* node)
	{
		auto newNode = vl::Ptr(new WfIntegerExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStringExpression* node)
	{
		auto newNode = vl::Ptr(new WfStringExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfUnaryExpression* node)
	{
		auto newNode = vl::Ptr(new WfUnaryExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfBinaryExpression* node)
	{
		auto newNode = vl::Ptr(new WfBinaryExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfLetExpression* node)
	{
		auto newNode = vl::Ptr(new WfLetExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfIfExpression* node)
	{
		auto newNode = vl::Ptr(new WfIfExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfRangeExpression* node)
	{
		auto newNode = vl::Ptr(new WfRangeExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfSetTestingExpression* node)
	{
		auto newNode = vl::Ptr(new WfSetTestingExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfConstructorExpression* node)
	{
		auto newNode = vl::Ptr(new WfConstructorExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfInferExpression* node)
	{
		auto newNode = vl::Ptr(new WfInferExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfTypeCastingExpression* node)
	{
		auto newNode = vl::Ptr(new WfTypeCastingExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfTypeTestingExpression* node)
	{
		auto newNode = vl::Ptr(new WfTypeTestingExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfTypeOfTypeExpression* node)
	{
		auto newNode = vl::Ptr(new WfTypeOfTypeExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfTypeOfExpressionExpression* node)
	{
		auto newNode = vl::Ptr(new WfTypeOfExpressionExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfAttachEventExpression* node)
	{
		auto newNode = vl::Ptr(new WfAttachEventExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfDetachEventExpression* node)
	{
		auto newNode = vl::Ptr(new WfDetachEventExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfObserveExpression* node)
	{
		auto newNode = vl::Ptr(new WfObserveExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfCallExpression* node)
	{
		auto newNode = vl::Ptr(new WfCallExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfFunctionExpression* node)
	{
		auto newNode = vl::Ptr(new WfFunctionExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfNewClassExpression* node)
	{
		auto newNode = vl::Ptr(new WfNewClassExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfNewInterfaceExpression* node)
	{
		auto newNode = vl::Ptr(new WfNewInterfaceExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfVirtualCfeExpression* node)
	{
		node->Accept(static_cast<WfVirtualCfeExpression::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfVirtualCseExpression* node)
	{
		node->Accept(static_cast<WfVirtualCseExpression::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfBreakStatement* node)
	{
		auto newNode = vl::Ptr(new WfBreakStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfContinueStatement* node)
	{
		auto newNode = vl::Ptr(new WfContinueStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfReturnStatement* node)
	{
		auto newNode = vl::Ptr(new WfReturnStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfDeleteStatement* node)
	{
		auto newNode = vl::Ptr(new WfDeleteStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfRaiseExceptionStatement* node)
	{
		auto newNode = vl::Ptr(new WfRaiseExceptionStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfIfStatement* node)
	{
		auto newNode = vl::Ptr(new WfIfStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfWhileStatement* node)
	{
		auto newNode = vl::Ptr(new WfWhileStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfTryStatement* node)
	{
		auto newNode = vl::Ptr(new WfTryStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfBlockStatement* node)
	{
		auto newNode = vl::Ptr(new WfBlockStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfGotoStatement* node)
	{
		auto newNode = vl::Ptr(new WfGotoStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfVariableStatement* node)
	{
		auto newNode = vl::Ptr(new WfVariableStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfExpressionStatement* node)
	{
		auto newNode = vl::Ptr(new WfExpressionStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfVirtualCseStatement* node)
	{
		node->Accept(static_cast<WfVirtualCseStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfCoroutineStatement* node)
	{
		node->Accept(static_cast<WfCoroutineStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfStateMachineStatement* node)
	{
		node->Accept(static_cast<WfStateMachineStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfNamespaceDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfNamespaceDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfFunctionDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfFunctionDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfVariableDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfVariableDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfEventDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfEventDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfPropertyDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfPropertyDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStaticInitDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfStaticInitDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfConstructorDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfConstructorDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfDestructorDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfDestructorDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfClassDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfClassDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfEnumDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfEnumDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStructDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfStructDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfVirtualCfeDeclaration* node)
	{
		node->Accept(static_cast<WfVirtualCfeDeclaration::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfVirtualCseDeclaration* node)
	{
		node->Accept(static_cast<WfVirtualCseDeclaration::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfAutoPropertyDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfAutoPropertyDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfCastResultInterfaceDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfCastResultInterfaceDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStateMachineDeclaration* node)
	{
		auto newNode = vl::Ptr(new WfStateMachineDeclaration);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfForEachStatement* node)
	{
		auto newNode = vl::Ptr(new WfForEachStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfSwitchStatement* node)
	{
		auto newNode = vl::Ptr(new WfSwitchStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfCoProviderStatement* node)
	{
		auto newNode = vl::Ptr(new WfCoProviderStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfCoPauseStatement* node)
	{
		auto newNode = vl::Ptr(new WfCoPauseStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfCoOperatorStatement* node)
	{
		auto newNode = vl::Ptr(new WfCoOperatorStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStateSwitchStatement* node)
	{
		auto newNode = vl::Ptr(new WfStateSwitchStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfStateInvokeStatement* node)
	{
		auto newNode = vl::Ptr(new WfStateInvokeStatement);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfFormatExpression* node)
	{
		auto newNode = vl::Ptr(new WfFormatExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfBindExpression* node)
	{
		auto newNode = vl::Ptr(new WfBindExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfNewCoroutineExpression* node)
	{
		auto newNode = vl::Ptr(new WfNewCoroutineExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfMixinCastExpression* node)
	{
		auto newNode = vl::Ptr(new WfMixinCastExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfExpectedTypeCastExpression* node)
	{
		auto newNode = vl::Ptr(new WfExpectedTypeCastExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfCoOperatorExpression* node)
	{
		auto newNode = vl::Ptr(new WfCoOperatorExpression);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfModuleUsingNameFragment* node)
	{
		auto newNode = vl::Ptr(new WfModuleUsingNameFragment);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	void AstVisitor::Visit(WfModuleUsingWildCardFragment* node)
	{
		auto newNode = vl::Ptr(new WfModuleUsingWildCardFragment);
		CopyFields(node, newNode.Obj());
		this->result = newNode;
	}

	vl::Ptr<WfType> AstVisitor::CopyNode(WfType* node)
	{
		if (!node) return nullptr;
		node->Accept(static_cast<WfType::IVisitor*>(this));
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfType>();
	}

	vl::Ptr<WfExpression> AstVisitor::CopyNode(WfExpression* node)
	{
		if (!node) return nullptr;
		node->Accept(static_cast<WfExpression::IVisitor*>(this));
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfExpression>();
	}

	vl::Ptr<WfStatement> AstVisitor::CopyNode(WfStatement* node)
	{
		if (!node) return nullptr;
		node->Accept(static_cast<WfStatement::IVisitor*>(this));
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfStatement>();
	}

	vl::Ptr<WfDeclaration> AstVisitor::CopyNode(WfDeclaration* node)
	{
		if (!node) return nullptr;
		node->Accept(static_cast<WfDeclaration::IVisitor*>(this));
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfDeclaration>();
	}

	vl::Ptr<WfModuleUsingFragment> AstVisitor::CopyNode(WfModuleUsingFragment* node)
	{
		if (!node) return nullptr;
		node->Accept(static_cast<WfModuleUsingFragment::IVisitor*>(this));
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfModuleUsingFragment>();
	}

	vl::Ptr<WfAttribute> AstVisitor::CopyNode(WfAttribute* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfAttribute>();
	}

	vl::Ptr<WfFunctionArgument> AstVisitor::CopyNode(WfFunctionArgument* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfFunctionArgument>();
	}

	vl::Ptr<WfBaseConstructorCall> AstVisitor::CopyNode(WfBaseConstructorCall* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfBaseConstructorCall>();
	}

	vl::Ptr<WfEnumItemIntersection> AstVisitor::CopyNode(WfEnumItemIntersection* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfEnumItemIntersection>();
	}

	vl::Ptr<WfEnumItem> AstVisitor::CopyNode(WfEnumItem* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfEnumItem>();
	}

	vl::Ptr<WfStructMember> AstVisitor::CopyNode(WfStructMember* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfStructMember>();
	}

	vl::Ptr<WfStateInput> AstVisitor::CopyNode(WfStateInput* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfStateInput>();
	}

	vl::Ptr<WfStateDeclaration> AstVisitor::CopyNode(WfStateDeclaration* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfStateDeclaration>();
	}

	vl::Ptr<WfSwitchCase> AstVisitor::CopyNode(WfSwitchCase* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfSwitchCase>();
	}

	vl::Ptr<WfStateSwitchArgument> AstVisitor::CopyNode(WfStateSwitchArgument* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfStateSwitchArgument>();
	}

	vl::Ptr<WfStateSwitchCase> AstVisitor::CopyNode(WfStateSwitchCase* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfStateSwitchCase>();
	}

	vl::Ptr<WfLetVariable> AstVisitor::CopyNode(WfLetVariable* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfLetVariable>();
	}

	vl::Ptr<WfConstructorArgument> AstVisitor::CopyNode(WfConstructorArgument* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfConstructorArgument>();
	}

	vl::Ptr<WfModuleUsingItem> AstVisitor::CopyNode(WfModuleUsingItem* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfModuleUsingItem>();
	}

	vl::Ptr<WfModuleUsingPath> AstVisitor::CopyNode(WfModuleUsingPath* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfModuleUsingPath>();
	}

	vl::Ptr<WfModule> AstVisitor::CopyNode(WfModule* node)
	{
		if (!node) return nullptr;
		Visit(node);
		this->result->codeRange = node->codeRange;
		return this->result.Cast<WfModule>();
	}

	vl::Ptr<WfAttachEventExpression> AstVisitor::CopyNode(WfAttachEventExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfAttachEventExpression>();
	}

	vl::Ptr<WfAutoPropertyDeclaration> AstVisitor::CopyNode(WfAutoPropertyDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfAutoPropertyDeclaration>();
	}

	vl::Ptr<WfBinaryExpression> AstVisitor::CopyNode(WfBinaryExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfBinaryExpression>();
	}

	vl::Ptr<WfBindExpression> AstVisitor::CopyNode(WfBindExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfBindExpression>();
	}

	vl::Ptr<WfBlockStatement> AstVisitor::CopyNode(WfBlockStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfBlockStatement>();
	}

	vl::Ptr<WfBreakStatement> AstVisitor::CopyNode(WfBreakStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfBreakStatement>();
	}

	vl::Ptr<WfCallExpression> AstVisitor::CopyNode(WfCallExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfCallExpression>();
	}

	vl::Ptr<WfCastResultInterfaceDeclaration> AstVisitor::CopyNode(WfCastResultInterfaceDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfCastResultInterfaceDeclaration>();
	}

	vl::Ptr<WfChildExpression> AstVisitor::CopyNode(WfChildExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfChildExpression>();
	}

	vl::Ptr<WfChildType> AstVisitor::CopyNode(WfChildType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfChildType>();
	}

	vl::Ptr<WfClassDeclaration> AstVisitor::CopyNode(WfClassDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfClassDeclaration>();
	}

	vl::Ptr<WfCoOperatorExpression> AstVisitor::CopyNode(WfCoOperatorExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfCoOperatorExpression>();
	}

	vl::Ptr<WfCoOperatorStatement> AstVisitor::CopyNode(WfCoOperatorStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfCoOperatorStatement>();
	}

	vl::Ptr<WfCoPauseStatement> AstVisitor::CopyNode(WfCoPauseStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfCoPauseStatement>();
	}

	vl::Ptr<WfCoProviderStatement> AstVisitor::CopyNode(WfCoProviderStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfCoProviderStatement>();
	}

	vl::Ptr<WfConstructorDeclaration> AstVisitor::CopyNode(WfConstructorDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfConstructorDeclaration>();
	}

	vl::Ptr<WfConstructorExpression> AstVisitor::CopyNode(WfConstructorExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfConstructorExpression>();
	}

	vl::Ptr<WfContinueStatement> AstVisitor::CopyNode(WfContinueStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfContinueStatement>();
	}

	vl::Ptr<WfCoroutineStatement> AstVisitor::CopyNode(WfCoroutineStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfCoroutineStatement>();
	}

	vl::Ptr<WfDeleteStatement> AstVisitor::CopyNode(WfDeleteStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfDeleteStatement>();
	}

	vl::Ptr<WfDestructorDeclaration> AstVisitor::CopyNode(WfDestructorDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfDestructorDeclaration>();
	}

	vl::Ptr<WfDetachEventExpression> AstVisitor::CopyNode(WfDetachEventExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfDetachEventExpression>();
	}

	vl::Ptr<WfEnumDeclaration> AstVisitor::CopyNode(WfEnumDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfEnumDeclaration>();
	}

	vl::Ptr<WfEnumerableType> AstVisitor::CopyNode(WfEnumerableType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfEnumerableType>();
	}

	vl::Ptr<WfEventDeclaration> AstVisitor::CopyNode(WfEventDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfEventDeclaration>();
	}

	vl::Ptr<WfExpectedTypeCastExpression> AstVisitor::CopyNode(WfExpectedTypeCastExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfExpectedTypeCastExpression>();
	}

	vl::Ptr<WfExpressionStatement> AstVisitor::CopyNode(WfExpressionStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfExpressionStatement>();
	}

	vl::Ptr<WfFloatingExpression> AstVisitor::CopyNode(WfFloatingExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfFloatingExpression>();
	}

	vl::Ptr<WfForEachStatement> AstVisitor::CopyNode(WfForEachStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfForEachStatement>();
	}

	vl::Ptr<WfFormatExpression> AstVisitor::CopyNode(WfFormatExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfFormatExpression>();
	}

	vl::Ptr<WfFunctionDeclaration> AstVisitor::CopyNode(WfFunctionDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfFunctionDeclaration>();
	}

	vl::Ptr<WfFunctionExpression> AstVisitor::CopyNode(WfFunctionExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfFunctionExpression>();
	}

	vl::Ptr<WfFunctionType> AstVisitor::CopyNode(WfFunctionType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfFunctionType>();
	}

	vl::Ptr<WfGotoStatement> AstVisitor::CopyNode(WfGotoStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfGotoStatement>();
	}

	vl::Ptr<WfIfExpression> AstVisitor::CopyNode(WfIfExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfIfExpression>();
	}

	vl::Ptr<WfIfStatement> AstVisitor::CopyNode(WfIfStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfIfStatement>();
	}

	vl::Ptr<WfInferExpression> AstVisitor::CopyNode(WfInferExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfInferExpression>();
	}

	vl::Ptr<WfIntegerExpression> AstVisitor::CopyNode(WfIntegerExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfIntegerExpression>();
	}

	vl::Ptr<WfLetExpression> AstVisitor::CopyNode(WfLetExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfLetExpression>();
	}

	vl::Ptr<WfLiteralExpression> AstVisitor::CopyNode(WfLiteralExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfLiteralExpression>();
	}

	vl::Ptr<WfMapType> AstVisitor::CopyNode(WfMapType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfMapType>();
	}

	vl::Ptr<WfMemberExpression> AstVisitor::CopyNode(WfMemberExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfMemberExpression>();
	}

	vl::Ptr<WfMixinCastExpression> AstVisitor::CopyNode(WfMixinCastExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfMixinCastExpression>();
	}

	vl::Ptr<WfModuleUsingNameFragment> AstVisitor::CopyNode(WfModuleUsingNameFragment* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfModuleUsingFragment*>(node)).Cast<WfModuleUsingNameFragment>();
	}

	vl::Ptr<WfModuleUsingWildCardFragment> AstVisitor::CopyNode(WfModuleUsingWildCardFragment* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfModuleUsingFragment*>(node)).Cast<WfModuleUsingWildCardFragment>();
	}

	vl::Ptr<WfNamespaceDeclaration> AstVisitor::CopyNode(WfNamespaceDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfNamespaceDeclaration>();
	}

	vl::Ptr<WfNewClassExpression> AstVisitor::CopyNode(WfNewClassExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfNewClassExpression>();
	}

	vl::Ptr<WfNewCoroutineExpression> AstVisitor::CopyNode(WfNewCoroutineExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfNewCoroutineExpression>();
	}

	vl::Ptr<WfNewInterfaceExpression> AstVisitor::CopyNode(WfNewInterfaceExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfNewInterfaceExpression>();
	}

	vl::Ptr<WfNullableType> AstVisitor::CopyNode(WfNullableType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfNullableType>();
	}

	vl::Ptr<WfObservableListType> AstVisitor::CopyNode(WfObservableListType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfObservableListType>();
	}

	vl::Ptr<WfObserveExpression> AstVisitor::CopyNode(WfObserveExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfObserveExpression>();
	}

	vl::Ptr<WfOrderedLambdaExpression> AstVisitor::CopyNode(WfOrderedLambdaExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfOrderedLambdaExpression>();
	}

	vl::Ptr<WfOrderedNameExpression> AstVisitor::CopyNode(WfOrderedNameExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfOrderedNameExpression>();
	}

	vl::Ptr<WfPredefinedType> AstVisitor::CopyNode(WfPredefinedType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfPredefinedType>();
	}

	vl::Ptr<WfPropertyDeclaration> AstVisitor::CopyNode(WfPropertyDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfPropertyDeclaration>();
	}

	vl::Ptr<WfRaiseExceptionStatement> AstVisitor::CopyNode(WfRaiseExceptionStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfRaiseExceptionStatement>();
	}

	vl::Ptr<WfRangeExpression> AstVisitor::CopyNode(WfRangeExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfRangeExpression>();
	}

	vl::Ptr<WfRawPointerType> AstVisitor::CopyNode(WfRawPointerType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfRawPointerType>();
	}

	vl::Ptr<WfReferenceExpression> AstVisitor::CopyNode(WfReferenceExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfReferenceExpression>();
	}

	vl::Ptr<WfReferenceType> AstVisitor::CopyNode(WfReferenceType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfReferenceType>();
	}

	vl::Ptr<WfReturnStatement> AstVisitor::CopyNode(WfReturnStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfReturnStatement>();
	}

	vl::Ptr<WfSetTestingExpression> AstVisitor::CopyNode(WfSetTestingExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfSetTestingExpression>();
	}

	vl::Ptr<WfSharedPointerType> AstVisitor::CopyNode(WfSharedPointerType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfSharedPointerType>();
	}

	vl::Ptr<WfStateInvokeStatement> AstVisitor::CopyNode(WfStateInvokeStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfStateInvokeStatement>();
	}

	vl::Ptr<WfStateMachineDeclaration> AstVisitor::CopyNode(WfStateMachineDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfStateMachineDeclaration>();
	}

	vl::Ptr<WfStateMachineStatement> AstVisitor::CopyNode(WfStateMachineStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfStateMachineStatement>();
	}

	vl::Ptr<WfStateSwitchStatement> AstVisitor::CopyNode(WfStateSwitchStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfStateSwitchStatement>();
	}

	vl::Ptr<WfStaticInitDeclaration> AstVisitor::CopyNode(WfStaticInitDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfStaticInitDeclaration>();
	}

	vl::Ptr<WfStringExpression> AstVisitor::CopyNode(WfStringExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfStringExpression>();
	}

	vl::Ptr<WfStructDeclaration> AstVisitor::CopyNode(WfStructDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfStructDeclaration>();
	}

	vl::Ptr<WfSwitchStatement> AstVisitor::CopyNode(WfSwitchStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfSwitchStatement>();
	}

	vl::Ptr<WfThisExpression> AstVisitor::CopyNode(WfThisExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfThisExpression>();
	}

	vl::Ptr<WfTopQualifiedExpression> AstVisitor::CopyNode(WfTopQualifiedExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfTopQualifiedExpression>();
	}

	vl::Ptr<WfTopQualifiedType> AstVisitor::CopyNode(WfTopQualifiedType* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfType*>(node)).Cast<WfTopQualifiedType>();
	}

	vl::Ptr<WfTryStatement> AstVisitor::CopyNode(WfTryStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfTryStatement>();
	}

	vl::Ptr<WfTypeCastingExpression> AstVisitor::CopyNode(WfTypeCastingExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfTypeCastingExpression>();
	}

	vl::Ptr<WfTypeOfExpressionExpression> AstVisitor::CopyNode(WfTypeOfExpressionExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfTypeOfExpressionExpression>();
	}

	vl::Ptr<WfTypeOfTypeExpression> AstVisitor::CopyNode(WfTypeOfTypeExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfTypeOfTypeExpression>();
	}

	vl::Ptr<WfTypeTestingExpression> AstVisitor::CopyNode(WfTypeTestingExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfTypeTestingExpression>();
	}

	vl::Ptr<WfUnaryExpression> AstVisitor::CopyNode(WfUnaryExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfUnaryExpression>();
	}

	vl::Ptr<WfVariableDeclaration> AstVisitor::CopyNode(WfVariableDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfVariableDeclaration>();
	}

	vl::Ptr<WfVariableStatement> AstVisitor::CopyNode(WfVariableStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfVariableStatement>();
	}

	vl::Ptr<WfVirtualCfeDeclaration> AstVisitor::CopyNode(WfVirtualCfeDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfVirtualCfeDeclaration>();
	}

	vl::Ptr<WfVirtualCfeExpression> AstVisitor::CopyNode(WfVirtualCfeExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfVirtualCfeExpression>();
	}

	vl::Ptr<WfVirtualCseDeclaration> AstVisitor::CopyNode(WfVirtualCseDeclaration* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfDeclaration*>(node)).Cast<WfVirtualCseDeclaration>();
	}

	vl::Ptr<WfVirtualCseExpression> AstVisitor::CopyNode(WfVirtualCseExpression* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfExpression*>(node)).Cast<WfVirtualCseExpression>();
	}

	vl::Ptr<WfVirtualCseStatement> AstVisitor::CopyNode(WfVirtualCseStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfVirtualCseStatement>();
	}

	vl::Ptr<WfWhileStatement> AstVisitor::CopyNode(WfWhileStatement* node)
	{
		if (!node) return nullptr;
		return CopyNode(static_cast<WfStatement*>(node)).Cast<WfWhileStatement>();
	}

}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_EMPTY.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow::empty_visitor
{

/***********************************************************************
TypeVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void TypeVisitor::Visit(WfPredefinedType* node)
	{
	}

	void TypeVisitor::Visit(WfTopQualifiedType* node)
	{
	}

	void TypeVisitor::Visit(WfReferenceType* node)
	{
	}

	void TypeVisitor::Visit(WfRawPointerType* node)
	{
	}

	void TypeVisitor::Visit(WfSharedPointerType* node)
	{
	}

	void TypeVisitor::Visit(WfNullableType* node)
	{
	}

	void TypeVisitor::Visit(WfEnumerableType* node)
	{
	}

	void TypeVisitor::Visit(WfMapType* node)
	{
	}

	void TypeVisitor::Visit(WfObservableListType* node)
	{
	}

	void TypeVisitor::Visit(WfFunctionType* node)
	{
	}

	void TypeVisitor::Visit(WfChildType* node)
	{
	}

/***********************************************************************
ExpressionVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void ExpressionVisitor::Visit(WfThisExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfTopQualifiedExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfReferenceExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfOrderedNameExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfOrderedLambdaExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfMemberExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfChildExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfLiteralExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfFloatingExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfIntegerExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfStringExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfUnaryExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfBinaryExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfLetExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfIfExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfRangeExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfSetTestingExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfConstructorExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfInferExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfTypeCastingExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfTypeTestingExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfTypeOfTypeExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfTypeOfExpressionExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfAttachEventExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfDetachEventExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfObserveExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfCallExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfFunctionExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfNewClassExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfNewInterfaceExpression* node)
	{
	}

	void ExpressionVisitor::Visit(WfVirtualCfeExpression* node)
	{
		Dispatch(node);
	}

	void ExpressionVisitor::Visit(WfVirtualCseExpression* node)
	{
		Dispatch(node);
	}

/***********************************************************************
StatementVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void StatementVisitor::Visit(WfBreakStatement* node)
	{
	}

	void StatementVisitor::Visit(WfContinueStatement* node)
	{
	}

	void StatementVisitor::Visit(WfReturnStatement* node)
	{
	}

	void StatementVisitor::Visit(WfDeleteStatement* node)
	{
	}

	void StatementVisitor::Visit(WfRaiseExceptionStatement* node)
	{
	}

	void StatementVisitor::Visit(WfIfStatement* node)
	{
	}

	void StatementVisitor::Visit(WfWhileStatement* node)
	{
	}

	void StatementVisitor::Visit(WfTryStatement* node)
	{
	}

	void StatementVisitor::Visit(WfBlockStatement* node)
	{
	}

	void StatementVisitor::Visit(WfGotoStatement* node)
	{
	}

	void StatementVisitor::Visit(WfVariableStatement* node)
	{
	}

	void StatementVisitor::Visit(WfExpressionStatement* node)
	{
	}

	void StatementVisitor::Visit(WfVirtualCseStatement* node)
	{
		Dispatch(node);
	}

	void StatementVisitor::Visit(WfCoroutineStatement* node)
	{
		Dispatch(node);
	}

	void StatementVisitor::Visit(WfStateMachineStatement* node)
	{
		Dispatch(node);
	}

/***********************************************************************
DeclarationVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void DeclarationVisitor::Visit(WfNamespaceDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfFunctionDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfVariableDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfEventDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfPropertyDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfStaticInitDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfConstructorDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfDestructorDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfClassDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfEnumDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfStructDeclaration* node)
	{
	}

	void DeclarationVisitor::Visit(WfVirtualCfeDeclaration* node)
	{
		Dispatch(node);
	}

	void DeclarationVisitor::Visit(WfVirtualCseDeclaration* node)
	{
		Dispatch(node);
	}

/***********************************************************************
VirtualCfeDeclarationVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void VirtualCfeDeclarationVisitor::Visit(WfAutoPropertyDeclaration* node)
	{
	}

	void VirtualCfeDeclarationVisitor::Visit(WfCastResultInterfaceDeclaration* node)
	{
	}

/***********************************************************************
VirtualCseDeclarationVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void VirtualCseDeclarationVisitor::Visit(WfStateMachineDeclaration* node)
	{
	}

/***********************************************************************
VirtualCseStatementVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void VirtualCseStatementVisitor::Visit(WfForEachStatement* node)
	{
	}

	void VirtualCseStatementVisitor::Visit(WfSwitchStatement* node)
	{
	}

	void VirtualCseStatementVisitor::Visit(WfCoProviderStatement* node)
	{
	}

/***********************************************************************
CoroutineStatementVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void CoroutineStatementVisitor::Visit(WfCoPauseStatement* node)
	{
	}

	void CoroutineStatementVisitor::Visit(WfCoOperatorStatement* node)
	{
	}

/***********************************************************************
StateMachineStatementVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void StateMachineStatementVisitor::Visit(WfStateSwitchStatement* node)
	{
	}

	void StateMachineStatementVisitor::Visit(WfStateInvokeStatement* node)
	{
	}

/***********************************************************************
VirtualCfeExpressionVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void VirtualCfeExpressionVisitor::Visit(WfFormatExpression* node)
	{
	}

/***********************************************************************
VirtualCseExpressionVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void VirtualCseExpressionVisitor::Visit(WfBindExpression* node)
	{
	}

	void VirtualCseExpressionVisitor::Visit(WfNewCoroutineExpression* node)
	{
	}

	void VirtualCseExpressionVisitor::Visit(WfMixinCastExpression* node)
	{
	}

	void VirtualCseExpressionVisitor::Visit(WfExpectedTypeCastExpression* node)
	{
	}

	void VirtualCseExpressionVisitor::Visit(WfCoOperatorExpression* node)
	{
	}

/***********************************************************************
ModuleUsingFragmentVisitor
***********************************************************************/

	// Visitor Members -----------------------------------

	void ModuleUsingFragmentVisitor::Visit(WfModuleUsingNameFragment* node)
	{
	}

	void ModuleUsingFragmentVisitor::Visit(WfModuleUsingWildCardFragment* node)
	{
	}
}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_JSON.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow::json_visitor
{
	void AstVisitor::PrintFields(WfAttachEventExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"event"));
		Print(node->event.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"function"));
		Print(node->function.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfAttribute* node)
	{
		BeginField(vl::WString::Unmanaged(L"category"));
		WriteToken(node->category);
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"value"));
		Print(node->value.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfAutoPropertyDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"configConst"));
		switch (node->configConst)
		{
		case vl::workflow::WfAPConst::Readonly:
			WriteString(vl::WString::Unmanaged(L"Readonly"));
			break;
		case vl::workflow::WfAPConst::Writable:
			WriteString(vl::WString::Unmanaged(L"Writable"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"configObserve"));
		switch (node->configObserve)
		{
		case vl::workflow::WfAPObserve::NotObservable:
			WriteString(vl::WString::Unmanaged(L"NotObservable"));
			break;
		case vl::workflow::WfAPObserve::Observable:
			WriteString(vl::WString::Unmanaged(L"Observable"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"functionKind"));
		switch (node->functionKind)
		{
		case vl::workflow::WfFunctionKind::Normal:
			WriteString(vl::WString::Unmanaged(L"Normal"));
			break;
		case vl::workflow::WfFunctionKind::Override:
			WriteString(vl::WString::Unmanaged(L"Override"));
			break;
		case vl::workflow::WfFunctionKind::Static:
			WriteString(vl::WString::Unmanaged(L"Static"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfBaseConstructorCall* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfBinaryExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"first"));
		Print(node->first.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"op"));
		switch (node->op)
		{
		case vl::workflow::WfBinaryOperator::Add:
			WriteString(vl::WString::Unmanaged(L"Add"));
			break;
		case vl::workflow::WfBinaryOperator::And:
			WriteString(vl::WString::Unmanaged(L"And"));
			break;
		case vl::workflow::WfBinaryOperator::Assign:
			WriteString(vl::WString::Unmanaged(L"Assign"));
			break;
		case vl::workflow::WfBinaryOperator::Div:
			WriteString(vl::WString::Unmanaged(L"Div"));
			break;
		case vl::workflow::WfBinaryOperator::EQ:
			WriteString(vl::WString::Unmanaged(L"EQ"));
			break;
		case vl::workflow::WfBinaryOperator::Exp:
			WriteString(vl::WString::Unmanaged(L"Exp"));
			break;
		case vl::workflow::WfBinaryOperator::FailedThen:
			WriteString(vl::WString::Unmanaged(L"FailedThen"));
			break;
		case vl::workflow::WfBinaryOperator::FlagAnd:
			WriteString(vl::WString::Unmanaged(L"FlagAnd"));
			break;
		case vl::workflow::WfBinaryOperator::FlagOr:
			WriteString(vl::WString::Unmanaged(L"FlagOr"));
			break;
		case vl::workflow::WfBinaryOperator::GE:
			WriteString(vl::WString::Unmanaged(L"GE"));
			break;
		case vl::workflow::WfBinaryOperator::GT:
			WriteString(vl::WString::Unmanaged(L"GT"));
			break;
		case vl::workflow::WfBinaryOperator::Index:
			WriteString(vl::WString::Unmanaged(L"Index"));
			break;
		case vl::workflow::WfBinaryOperator::LE:
			WriteString(vl::WString::Unmanaged(L"LE"));
			break;
		case vl::workflow::WfBinaryOperator::LT:
			WriteString(vl::WString::Unmanaged(L"LT"));
			break;
		case vl::workflow::WfBinaryOperator::Mod:
			WriteString(vl::WString::Unmanaged(L"Mod"));
			break;
		case vl::workflow::WfBinaryOperator::Mul:
			WriteString(vl::WString::Unmanaged(L"Mul"));
			break;
		case vl::workflow::WfBinaryOperator::NE:
			WriteString(vl::WString::Unmanaged(L"NE"));
			break;
		case vl::workflow::WfBinaryOperator::Or:
			WriteString(vl::WString::Unmanaged(L"Or"));
			break;
		case vl::workflow::WfBinaryOperator::Shl:
			WriteString(vl::WString::Unmanaged(L"Shl"));
			break;
		case vl::workflow::WfBinaryOperator::Shr:
			WriteString(vl::WString::Unmanaged(L"Shr"));
			break;
		case vl::workflow::WfBinaryOperator::Sub:
			WriteString(vl::WString::Unmanaged(L"Sub"));
			break;
		case vl::workflow::WfBinaryOperator::Xor:
			WriteString(vl::WString::Unmanaged(L"Xor"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"second"));
		Print(node->second.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfBindExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfBlockStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"endLabel"));
		WriteToken(node->endLabel);
		EndField();
		BeginField(vl::WString::Unmanaged(L"statements"));
		BeginArray();
		for (auto&& listItem : node->statements)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfBreakStatement* node)
	{
	}
	void AstVisitor::PrintFields(WfCallExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"function"));
		Print(node->function.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfCastResultInterfaceDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"baseType"));
		Print(node->baseType.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"elementType"));
		Print(node->elementType.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfChildExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"parent"));
		Print(node->parent.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfChildType* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"parent"));
		Print(node->parent.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfClassDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"baseTypes"));
		BeginArray();
		for (auto&& listItem : node->baseTypes)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"constructorType"));
		switch (node->constructorType)
		{
		case vl::workflow::WfConstructorType::RawPtr:
			WriteString(vl::WString::Unmanaged(L"RawPtr"));
			break;
		case vl::workflow::WfConstructorType::SharedPtr:
			WriteString(vl::WString::Unmanaged(L"SharedPtr"));
			break;
		case vl::workflow::WfConstructorType::Undefined:
			WriteString(vl::WString::Unmanaged(L"Undefined"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"declarations"));
		BeginArray();
		for (auto&& listItem : node->declarations)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"kind"));
		switch (node->kind)
		{
		case vl::workflow::WfClassKind::Class:
			WriteString(vl::WString::Unmanaged(L"Class"));
			break;
		case vl::workflow::WfClassKind::Interface:
			WriteString(vl::WString::Unmanaged(L"Interface"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfCoOperatorExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfCoOperatorStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"opName"));
		WriteToken(node->opName);
		EndField();
		BeginField(vl::WString::Unmanaged(L"varName"));
		WriteToken(node->varName);
		EndField();
	}
	void AstVisitor::PrintFields(WfCoPauseStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfCoProviderStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfConstructorArgument* node)
	{
		BeginField(vl::WString::Unmanaged(L"key"));
		Print(node->key.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"value"));
		Print(node->value.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfConstructorDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"baseConstructorCalls"));
		BeginArray();
		for (auto&& listItem : node->baseConstructorCalls)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"constructorType"));
		switch (node->constructorType)
		{
		case vl::workflow::WfConstructorType::RawPtr:
			WriteString(vl::WString::Unmanaged(L"RawPtr"));
			break;
		case vl::workflow::WfConstructorType::SharedPtr:
			WriteString(vl::WString::Unmanaged(L"SharedPtr"));
			break;
		case vl::workflow::WfConstructorType::Undefined:
			WriteString(vl::WString::Unmanaged(L"Undefined"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfConstructorExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfContinueStatement* node)
	{
	}
	void AstVisitor::PrintFields(WfCoroutineStatement* node)
	{
	}
	void AstVisitor::PrintFields(WfDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"attributes"));
		BeginArray();
		for (auto&& listItem : node->attributes)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfDeleteStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfDestructorDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfDetachEventExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"event"));
		Print(node->event.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"handler"));
		Print(node->handler.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfEnumDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"items"));
		BeginArray();
		for (auto&& listItem : node->items)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"kind"));
		switch (node->kind)
		{
		case vl::workflow::WfEnumKind::Flag:
			WriteString(vl::WString::Unmanaged(L"Flag"));
			break;
		case vl::workflow::WfEnumKind::Normal:
			WriteString(vl::WString::Unmanaged(L"Normal"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfEnumItem* node)
	{
		BeginField(vl::WString::Unmanaged(L"attributes"));
		BeginArray();
		for (auto&& listItem : node->attributes)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"intersections"));
		BeginArray();
		for (auto&& listItem : node->intersections)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"kind"));
		switch (node->kind)
		{
		case vl::workflow::WfEnumItemKind::Constant:
			WriteString(vl::WString::Unmanaged(L"Constant"));
			break;
		case vl::workflow::WfEnumItemKind::Intersection:
			WriteString(vl::WString::Unmanaged(L"Intersection"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"number"));
		WriteToken(node->number);
		EndField();
	}
	void AstVisitor::PrintFields(WfEnumItemIntersection* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfEnumerableType* node)
	{
		BeginField(vl::WString::Unmanaged(L"element"));
		Print(node->element.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfEventDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfExpectedTypeCastExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"strategy"));
		switch (node->strategy)
		{
		case vl::workflow::WfTypeCastingStrategy::Strong:
			WriteString(vl::WString::Unmanaged(L"Strong"));
			break;
		case vl::workflow::WfTypeCastingStrategy::Weak:
			WriteString(vl::WString::Unmanaged(L"Weak"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfExpression* node)
	{
	}
	void AstVisitor::PrintFields(WfExpressionStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfFloatingExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"value"));
		WriteToken(node->value);
		EndField();
	}
	void AstVisitor::PrintFields(WfForEachStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"collection"));
		Print(node->collection.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"direction"));
		switch (node->direction)
		{
		case vl::workflow::WfForEachDirection::Normal:
			WriteString(vl::WString::Unmanaged(L"Normal"));
			break;
		case vl::workflow::WfForEachDirection::Reversed:
			WriteString(vl::WString::Unmanaged(L"Reversed"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfFormatExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"value"));
		WriteToken(node->value);
		EndField();
	}
	void AstVisitor::PrintFields(WfFunctionArgument* node)
	{
		BeginField(vl::WString::Unmanaged(L"attributes"));
		BeginArray();
		for (auto&& listItem : node->attributes)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfFunctionDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"anonymity"));
		switch (node->anonymity)
		{
		case vl::workflow::WfFunctionAnonymity::Anonymous:
			WriteString(vl::WString::Unmanaged(L"Anonymous"));
			break;
		case vl::workflow::WfFunctionAnonymity::Named:
			WriteString(vl::WString::Unmanaged(L"Named"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"functionKind"));
		switch (node->functionKind)
		{
		case vl::workflow::WfFunctionKind::Normal:
			WriteString(vl::WString::Unmanaged(L"Normal"));
			break;
		case vl::workflow::WfFunctionKind::Override:
			WriteString(vl::WString::Unmanaged(L"Override"));
			break;
		case vl::workflow::WfFunctionKind::Static:
			WriteString(vl::WString::Unmanaged(L"Static"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"returnType"));
		Print(node->returnType.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfFunctionExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"function"));
		Print(node->function.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfFunctionType* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"result"));
		Print(node->result.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfGotoStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"label"));
		WriteToken(node->label);
		EndField();
	}
	void AstVisitor::PrintFields(WfIfExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"condition"));
		Print(node->condition.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"falseBranch"));
		Print(node->falseBranch.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"trueBranch"));
		Print(node->trueBranch.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfIfStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"falseBranch"));
		Print(node->falseBranch.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"trueBranch"));
		Print(node->trueBranch.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfInferExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfIntegerExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"value"));
		WriteToken(node->value);
		EndField();
	}
	void AstVisitor::PrintFields(WfLetExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"variables"));
		BeginArray();
		for (auto&& listItem : node->variables)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfLetVariable* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"value"));
		Print(node->value.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfLiteralExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"value"));
		switch (node->value)
		{
		case vl::workflow::WfLiteralValue::False:
			WriteString(vl::WString::Unmanaged(L"False"));
			break;
		case vl::workflow::WfLiteralValue::Null:
			WriteString(vl::WString::Unmanaged(L"Null"));
			break;
		case vl::workflow::WfLiteralValue::True:
			WriteString(vl::WString::Unmanaged(L"True"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfMapType* node)
	{
		BeginField(vl::WString::Unmanaged(L"key"));
		Print(node->key.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"value"));
		Print(node->value.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"writability"));
		switch (node->writability)
		{
		case vl::workflow::WfMapWritability::Readonly:
			WriteString(vl::WString::Unmanaged(L"Readonly"));
			break;
		case vl::workflow::WfMapWritability::Writable:
			WriteString(vl::WString::Unmanaged(L"Writable"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfMemberExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"parent"));
		Print(node->parent.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfMixinCastExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfModule* node)
	{
		BeginField(vl::WString::Unmanaged(L"declarations"));
		BeginArray();
		for (auto&& listItem : node->declarations)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"moduleType"));
		switch (node->moduleType)
		{
		case vl::workflow::WfModuleType::Module:
			WriteString(vl::WString::Unmanaged(L"Module"));
			break;
		case vl::workflow::WfModuleType::Unit:
			WriteString(vl::WString::Unmanaged(L"Unit"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"paths"));
		BeginArray();
		for (auto&& listItem : node->paths)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfModuleUsingFragment* node)
	{
	}
	void AstVisitor::PrintFields(WfModuleUsingItem* node)
	{
		BeginField(vl::WString::Unmanaged(L"fragments"));
		BeginArray();
		for (auto&& listItem : node->fragments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfModuleUsingNameFragment* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfModuleUsingPath* node)
	{
		BeginField(vl::WString::Unmanaged(L"items"));
		BeginArray();
		for (auto&& listItem : node->items)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfModuleUsingWildCardFragment* node)
	{
	}
	void AstVisitor::PrintFields(WfNamespaceDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"declarations"));
		BeginArray();
		for (auto&& listItem : node->declarations)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfNewClassExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfNewCoroutineExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfNewInterfaceExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"declarations"));
		BeginArray();
		for (auto&& listItem : node->declarations)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfNullableType* node)
	{
		BeginField(vl::WString::Unmanaged(L"element"));
		Print(node->element.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfObservableListType* node)
	{
		BeginField(vl::WString::Unmanaged(L"element"));
		Print(node->element.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfObserveExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"events"));
		BeginArray();
		for (auto&& listItem : node->events)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"observeType"));
		switch (node->observeType)
		{
		case vl::workflow::WfObserveType::ExtendedObserve:
			WriteString(vl::WString::Unmanaged(L"ExtendedObserve"));
			break;
		case vl::workflow::WfObserveType::SimpleObserve:
			WriteString(vl::WString::Unmanaged(L"SimpleObserve"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"parent"));
		Print(node->parent.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfOrderedLambdaExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"body"));
		Print(node->body.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfOrderedNameExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfPredefinedType* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		switch (node->name)
		{
		case vl::workflow::WfPredefinedTypeName::Bool:
			WriteString(vl::WString::Unmanaged(L"Bool"));
			break;
		case vl::workflow::WfPredefinedTypeName::Char:
			WriteString(vl::WString::Unmanaged(L"Char"));
			break;
		case vl::workflow::WfPredefinedTypeName::Double:
			WriteString(vl::WString::Unmanaged(L"Double"));
			break;
		case vl::workflow::WfPredefinedTypeName::Float:
			WriteString(vl::WString::Unmanaged(L"Float"));
			break;
		case vl::workflow::WfPredefinedTypeName::Int:
			WriteString(vl::WString::Unmanaged(L"Int"));
			break;
		case vl::workflow::WfPredefinedTypeName::Interface:
			WriteString(vl::WString::Unmanaged(L"Interface"));
			break;
		case vl::workflow::WfPredefinedTypeName::Object:
			WriteString(vl::WString::Unmanaged(L"Object"));
			break;
		case vl::workflow::WfPredefinedTypeName::String:
			WriteString(vl::WString::Unmanaged(L"String"));
			break;
		case vl::workflow::WfPredefinedTypeName::UInt:
			WriteString(vl::WString::Unmanaged(L"UInt"));
			break;
		case vl::workflow::WfPredefinedTypeName::Void:
			WriteString(vl::WString::Unmanaged(L"Void"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfPropertyDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"getter"));
		WriteToken(node->getter);
		EndField();
		BeginField(vl::WString::Unmanaged(L"setter"));
		WriteToken(node->setter);
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"valueChangedEvent"));
		WriteToken(node->valueChangedEvent);
		EndField();
	}
	void AstVisitor::PrintFields(WfRaiseExceptionStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfRangeExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"begin"));
		Print(node->begin.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"beginBoundary"));
		switch (node->beginBoundary)
		{
		case vl::workflow::WfRangeBoundary::Exclusive:
			WriteString(vl::WString::Unmanaged(L"Exclusive"));
			break;
		case vl::workflow::WfRangeBoundary::Inclusive:
			WriteString(vl::WString::Unmanaged(L"Inclusive"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"end"));
		Print(node->end.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"endBoundary"));
		switch (node->endBoundary)
		{
		case vl::workflow::WfRangeBoundary::Exclusive:
			WriteString(vl::WString::Unmanaged(L"Exclusive"));
			break;
		case vl::workflow::WfRangeBoundary::Inclusive:
			WriteString(vl::WString::Unmanaged(L"Inclusive"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfRawPointerType* node)
	{
		BeginField(vl::WString::Unmanaged(L"element"));
		Print(node->element.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfReferenceExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfReferenceType* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfReturnStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfSetTestingExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"collection"));
		Print(node->collection.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"element"));
		Print(node->element.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"test"));
		switch (node->test)
		{
		case vl::workflow::WfSetTesting::In:
			WriteString(vl::WString::Unmanaged(L"In"));
			break;
		case vl::workflow::WfSetTesting::NotIn:
			WriteString(vl::WString::Unmanaged(L"NotIn"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfSharedPointerType* node)
	{
		BeginField(vl::WString::Unmanaged(L"element"));
		Print(node->element.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfStateDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfStateInput* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfStateInvokeStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		switch (node->type)
		{
		case vl::workflow::WfStateInvokeType::Goto:
			WriteString(vl::WString::Unmanaged(L"Goto"));
			break;
		case vl::workflow::WfStateInvokeType::Push:
			WriteString(vl::WString::Unmanaged(L"Push"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfStateMachineDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"inputs"));
		BeginArray();
		for (auto&& listItem : node->inputs)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"states"));
		BeginArray();
		for (auto&& listItem : node->states)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfStateMachineStatement* node)
	{
	}
	void AstVisitor::PrintFields(WfStateSwitchArgument* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfStateSwitchCase* node)
	{
		BeginField(vl::WString::Unmanaged(L"arguments"));
		BeginArray();
		for (auto&& listItem : node->arguments)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfStateSwitchStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"caseBranches"));
		BeginArray();
		for (auto&& listItem : node->caseBranches)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		switch (node->type)
		{
		case vl::workflow::WfStateSwitchType::Default:
			WriteString(vl::WString::Unmanaged(L"Default"));
			break;
		case vl::workflow::WfStateSwitchType::Ignore:
			WriteString(vl::WString::Unmanaged(L"Ignore"));
			break;
		case vl::workflow::WfStateSwitchType::IgnoreAndReturn:
			WriteString(vl::WString::Unmanaged(L"IgnoreAndReturn"));
			break;
		case vl::workflow::WfStateSwitchType::Pass:
			WriteString(vl::WString::Unmanaged(L"Pass"));
			break;
		case vl::workflow::WfStateSwitchType::PassAndReturn:
			WriteString(vl::WString::Unmanaged(L"PassAndReturn"));
			break;
		default:
			WriteNull();
		}
		EndField();
	}
	void AstVisitor::PrintFields(WfStatement* node)
	{
	}
	void AstVisitor::PrintFields(WfStaticInitDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfStringExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"value"));
		WriteToken(node->value);
		EndField();
	}
	void AstVisitor::PrintFields(WfStructDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"members"));
		BeginArray();
		for (auto&& listItem : node->members)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfStructMember* node)
	{
		BeginField(vl::WString::Unmanaged(L"attributes"));
		BeginArray();
		for (auto&& listItem : node->attributes)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfSwitchCase* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfSwitchStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"caseBranches"));
		BeginArray();
		for (auto&& listItem : node->caseBranches)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
		BeginField(vl::WString::Unmanaged(L"defaultBranch"));
		Print(node->defaultBranch.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfThisExpression* node)
	{
	}
	void AstVisitor::PrintFields(WfTopQualifiedExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfTopQualifiedType* node)
	{
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
	}
	void AstVisitor::PrintFields(WfTryStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"catchStatement"));
		Print(node->catchStatement.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"finallyStatement"));
		Print(node->finallyStatement.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"name"));
		WriteToken(node->name);
		EndField();
		BeginField(vl::WString::Unmanaged(L"protectedStatement"));
		Print(node->protectedStatement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfType* node)
	{
	}
	void AstVisitor::PrintFields(WfTypeCastingExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"strategy"));
		switch (node->strategy)
		{
		case vl::workflow::WfTypeCastingStrategy::Strong:
			WriteString(vl::WString::Unmanaged(L"Strong"));
			break;
		case vl::workflow::WfTypeCastingStrategy::Weak:
			WriteString(vl::WString::Unmanaged(L"Weak"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfTypeOfExpressionExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfTypeOfTypeExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfTypeTestingExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"test"));
		switch (node->test)
		{
		case vl::workflow::WfTypeTesting::IsNotNull:
			WriteString(vl::WString::Unmanaged(L"IsNotNull"));
			break;
		case vl::workflow::WfTypeTesting::IsNotType:
			WriteString(vl::WString::Unmanaged(L"IsNotType"));
			break;
		case vl::workflow::WfTypeTesting::IsNull:
			WriteString(vl::WString::Unmanaged(L"IsNull"));
			break;
		case vl::workflow::WfTypeTesting::IsType:
			WriteString(vl::WString::Unmanaged(L"IsType"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfUnaryExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"op"));
		switch (node->op)
		{
		case vl::workflow::WfUnaryOperator::Negative:
			WriteString(vl::WString::Unmanaged(L"Negative"));
			break;
		case vl::workflow::WfUnaryOperator::Not:
			WriteString(vl::WString::Unmanaged(L"Not"));
			break;
		case vl::workflow::WfUnaryOperator::Positive:
			WriteString(vl::WString::Unmanaged(L"Positive"));
			break;
		default:
			WriteNull();
		}
		EndField();
		BeginField(vl::WString::Unmanaged(L"operand"));
		Print(node->operand.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfVariableDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"expression"));
		Print(node->expression.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"type"));
		Print(node->type.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfVariableStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"variable"));
		Print(node->variable.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfVirtualCfeDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"expandedDeclarations"));
		BeginArray();
		for (auto&& listItem : node->expandedDeclarations)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfVirtualCfeExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expandedExpression"));
		Print(node->expandedExpression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfVirtualCseDeclaration* node)
	{
		BeginField(vl::WString::Unmanaged(L"expandedDeclarations"));
		BeginArray();
		for (auto&& listItem : node->expandedDeclarations)
		{
			BeginArrayItem();
			Print(listItem.Obj());
			EndArrayItem();
		}
		EndArray();
		EndField();
	}
	void AstVisitor::PrintFields(WfVirtualCseExpression* node)
	{
		BeginField(vl::WString::Unmanaged(L"expandedExpression"));
		Print(node->expandedExpression.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfVirtualCseStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"expandedStatement"));
		Print(node->expandedStatement.Obj());
		EndField();
	}
	void AstVisitor::PrintFields(WfWhileStatement* node)
	{
		BeginField(vl::WString::Unmanaged(L"condition"));
		Print(node->condition.Obj());
		EndField();
		BeginField(vl::WString::Unmanaged(L"statement"));
		Print(node->statement.Obj());
		EndField();
	}

	void AstVisitor::Visit(WfPredefinedType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"PredefinedType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfPredefinedType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfTopQualifiedType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"TopQualifiedType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfTopQualifiedType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfReferenceType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ReferenceType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfReferenceType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfRawPointerType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"RawPointerType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfRawPointerType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfSharedPointerType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"SharedPointerType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfSharedPointerType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfNullableType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"NullableType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfNullableType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfEnumerableType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"EnumerableType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfEnumerableType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfMapType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"MapType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfMapType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfObservableListType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ObservableListType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfObservableListType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfFunctionType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"FunctionType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfFunctionType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfChildType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ChildType"), node);
		PrintFields(static_cast<WfType*>(node));
		PrintFields(static_cast<WfChildType*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfThisExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ThisExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfThisExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfTopQualifiedExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"TopQualifiedExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfTopQualifiedExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfReferenceExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ReferenceExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfReferenceExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfOrderedNameExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"OrderedNameExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfOrderedNameExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfOrderedLambdaExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"OrderedLambdaExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfOrderedLambdaExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfMemberExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"MemberExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfMemberExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfChildExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ChildExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfChildExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfLiteralExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"LiteralExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfLiteralExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfFloatingExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"FloatingExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfFloatingExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfIntegerExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"IntegerExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfIntegerExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfStringExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StringExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfStringExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfUnaryExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"UnaryExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfUnaryExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfBinaryExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"BinaryExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfBinaryExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfLetExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"LetExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfLetExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfIfExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"IfExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfIfExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfRangeExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"RangeExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfRangeExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfSetTestingExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"SetTestingExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfSetTestingExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfConstructorExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ConstructorExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfConstructorExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfInferExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"InferExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfInferExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfTypeCastingExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"TypeCastingExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfTypeCastingExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfTypeTestingExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"TypeTestingExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfTypeTestingExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfTypeOfTypeExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"TypeOfTypeExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfTypeOfTypeExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfTypeOfExpressionExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"TypeOfExpressionExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfTypeOfExpressionExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfAttachEventExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"AttachEventExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfAttachEventExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfDetachEventExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"DetachEventExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfDetachEventExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfObserveExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ObserveExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfObserveExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfCallExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"CallExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfCallExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfFunctionExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"FunctionExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfFunctionExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfNewClassExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"NewClassExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfNewClassExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfNewInterfaceExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"NewInterfaceExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfNewInterfaceExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfVirtualCfeExpression* node)
	{
		node->Accept(static_cast<WfVirtualCfeExpression::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfVirtualCseExpression* node)
	{
		node->Accept(static_cast<WfVirtualCseExpression::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfBreakStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"BreakStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfBreakStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfContinueStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ContinueStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfContinueStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfReturnStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ReturnStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfReturnStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfDeleteStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"DeleteStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfDeleteStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfRaiseExceptionStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"RaiseExceptionStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfRaiseExceptionStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfIfStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"IfStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfIfStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfWhileStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"WhileStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfWhileStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfTryStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"TryStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfTryStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfBlockStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"BlockStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfBlockStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfGotoStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"GotoStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfGotoStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfVariableStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"VariableStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfVariableStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfExpressionStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ExpressionStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfExpressionStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfVirtualCseStatement* node)
	{
		node->Accept(static_cast<WfVirtualCseStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfCoroutineStatement* node)
	{
		node->Accept(static_cast<WfCoroutineStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfStateMachineStatement* node)
	{
		node->Accept(static_cast<WfStateMachineStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfNamespaceDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"NamespaceDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfNamespaceDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfFunctionDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"FunctionDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfFunctionDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfVariableDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"VariableDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfVariableDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfEventDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"EventDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfEventDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfPropertyDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"PropertyDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfPropertyDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfStaticInitDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StaticInitDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfStaticInitDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfConstructorDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ConstructorDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfConstructorDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfDestructorDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"DestructorDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfDestructorDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfClassDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ClassDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfClassDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfEnumDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"EnumDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfEnumDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfStructDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StructDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfStructDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfVirtualCfeDeclaration* node)
	{
		node->Accept(static_cast<WfVirtualCfeDeclaration::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfVirtualCseDeclaration* node)
	{
		node->Accept(static_cast<WfVirtualCseDeclaration::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfAutoPropertyDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"AutoPropertyDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfVirtualCfeDeclaration*>(node));
		PrintFields(static_cast<WfAutoPropertyDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfCastResultInterfaceDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"CastResultInterfaceDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfVirtualCfeDeclaration*>(node));
		PrintFields(static_cast<WfCastResultInterfaceDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfStateMachineDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StateMachineDeclaration"), node);
		PrintFields(static_cast<WfDeclaration*>(node));
		PrintFields(static_cast<WfVirtualCseDeclaration*>(node));
		PrintFields(static_cast<WfStateMachineDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfForEachStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ForEachStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfVirtualCseStatement*>(node));
		PrintFields(static_cast<WfForEachStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfSwitchStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"SwitchStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfVirtualCseStatement*>(node));
		PrintFields(static_cast<WfSwitchStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfCoProviderStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"CoProviderStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfVirtualCseStatement*>(node));
		PrintFields(static_cast<WfCoProviderStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfCoPauseStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"CoPauseStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfCoroutineStatement*>(node));
		PrintFields(static_cast<WfCoPauseStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfCoOperatorStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"CoOperatorStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfCoroutineStatement*>(node));
		PrintFields(static_cast<WfCoOperatorStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfStateSwitchStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StateSwitchStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfStateMachineStatement*>(node));
		PrintFields(static_cast<WfStateSwitchStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfStateInvokeStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StateInvokeStatement"), node);
		PrintFields(static_cast<WfStatement*>(node));
		PrintFields(static_cast<WfStateMachineStatement*>(node));
		PrintFields(static_cast<WfStateInvokeStatement*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfFormatExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"FormatExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfVirtualCfeExpression*>(node));
		PrintFields(static_cast<WfFormatExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfBindExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"BindExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfVirtualCseExpression*>(node));
		PrintFields(static_cast<WfBindExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfNewCoroutineExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"NewCoroutineExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfVirtualCseExpression*>(node));
		PrintFields(static_cast<WfNewCoroutineExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfMixinCastExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"MixinCastExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfVirtualCseExpression*>(node));
		PrintFields(static_cast<WfMixinCastExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfExpectedTypeCastExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ExpectedTypeCastExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfVirtualCseExpression*>(node));
		PrintFields(static_cast<WfExpectedTypeCastExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfCoOperatorExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"CoOperatorExpression"), node);
		PrintFields(static_cast<WfExpression*>(node));
		PrintFields(static_cast<WfVirtualCseExpression*>(node));
		PrintFields(static_cast<WfCoOperatorExpression*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfModuleUsingNameFragment* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ModuleUsingNameFragment"), node);
		PrintFields(static_cast<WfModuleUsingFragment*>(node));
		PrintFields(static_cast<WfModuleUsingNameFragment*>(node));
		EndObject();
	}

	void AstVisitor::Visit(WfModuleUsingWildCardFragment* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ModuleUsingWildCardFragment"), node);
		PrintFields(static_cast<WfModuleUsingFragment*>(node));
		PrintFields(static_cast<WfModuleUsingWildCardFragment*>(node));
		EndObject();
	}

	AstVisitor::AstVisitor(vl::stream::StreamWriter& _writer)
		: vl::glr::JsonVisitorBase(_writer)
	{
	}

	void AstVisitor::Print(WfType* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		node->Accept(static_cast<WfType::IVisitor*>(this));
	}

	void AstVisitor::Print(WfExpression* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		node->Accept(static_cast<WfExpression::IVisitor*>(this));
	}

	void AstVisitor::Print(WfStatement* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		node->Accept(static_cast<WfStatement::IVisitor*>(this));
	}

	void AstVisitor::Print(WfDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		node->Accept(static_cast<WfDeclaration::IVisitor*>(this));
	}

	void AstVisitor::Print(WfModuleUsingFragment* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		node->Accept(static_cast<WfModuleUsingFragment::IVisitor*>(this));
	}

	void AstVisitor::Print(WfAttribute* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"Attribute"), node);
		PrintFields(static_cast<WfAttribute*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfFunctionArgument* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"FunctionArgument"), node);
		PrintFields(static_cast<WfFunctionArgument*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfBaseConstructorCall* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"BaseConstructorCall"), node);
		PrintFields(static_cast<WfBaseConstructorCall*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfEnumItemIntersection* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"EnumItemIntersection"), node);
		PrintFields(static_cast<WfEnumItemIntersection*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfEnumItem* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"EnumItem"), node);
		PrintFields(static_cast<WfEnumItem*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfStructMember* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StructMember"), node);
		PrintFields(static_cast<WfStructMember*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfStateInput* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StateInput"), node);
		PrintFields(static_cast<WfStateInput*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfStateDeclaration* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StateDeclaration"), node);
		PrintFields(static_cast<WfStateDeclaration*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfSwitchCase* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"SwitchCase"), node);
		PrintFields(static_cast<WfSwitchCase*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfStateSwitchArgument* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StateSwitchArgument"), node);
		PrintFields(static_cast<WfStateSwitchArgument*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfStateSwitchCase* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"StateSwitchCase"), node);
		PrintFields(static_cast<WfStateSwitchCase*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfLetVariable* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"LetVariable"), node);
		PrintFields(static_cast<WfLetVariable*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfConstructorArgument* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ConstructorArgument"), node);
		PrintFields(static_cast<WfConstructorArgument*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfModuleUsingItem* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ModuleUsingItem"), node);
		PrintFields(static_cast<WfModuleUsingItem*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfModuleUsingPath* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"ModuleUsingPath"), node);
		PrintFields(static_cast<WfModuleUsingPath*>(node));
		EndObject();
	}

	void AstVisitor::Print(WfModule* node)
	{
		if (!node)
		{
			WriteNull();
			return;
		}
		BeginObject();
		WriteType(vl::WString::Unmanaged(L"Module"), node);
		PrintFields(static_cast<WfModule*>(node));
		EndObject();
	}

}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_TRAVERSE.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow::traverse_visitor
{
	void AstVisitor::Traverse(vl::glr::ParsingToken& token) {}
	void AstVisitor::Traverse(vl::glr::ParsingAstBase* node) {}
	void AstVisitor::Traverse(WfAttachEventExpression* node) {}
	void AstVisitor::Traverse(WfAttribute* node) {}
	void AstVisitor::Traverse(WfAutoPropertyDeclaration* node) {}
	void AstVisitor::Traverse(WfBaseConstructorCall* node) {}
	void AstVisitor::Traverse(WfBinaryExpression* node) {}
	void AstVisitor::Traverse(WfBindExpression* node) {}
	void AstVisitor::Traverse(WfBlockStatement* node) {}
	void AstVisitor::Traverse(WfBreakStatement* node) {}
	void AstVisitor::Traverse(WfCallExpression* node) {}
	void AstVisitor::Traverse(WfCastResultInterfaceDeclaration* node) {}
	void AstVisitor::Traverse(WfChildExpression* node) {}
	void AstVisitor::Traverse(WfChildType* node) {}
	void AstVisitor::Traverse(WfClassDeclaration* node) {}
	void AstVisitor::Traverse(WfCoOperatorExpression* node) {}
	void AstVisitor::Traverse(WfCoOperatorStatement* node) {}
	void AstVisitor::Traverse(WfCoPauseStatement* node) {}
	void AstVisitor::Traverse(WfCoProviderStatement* node) {}
	void AstVisitor::Traverse(WfConstructorArgument* node) {}
	void AstVisitor::Traverse(WfConstructorDeclaration* node) {}
	void AstVisitor::Traverse(WfConstructorExpression* node) {}
	void AstVisitor::Traverse(WfContinueStatement* node) {}
	void AstVisitor::Traverse(WfCoroutineStatement* node) {}
	void AstVisitor::Traverse(WfDeclaration* node) {}
	void AstVisitor::Traverse(WfDeleteStatement* node) {}
	void AstVisitor::Traverse(WfDestructorDeclaration* node) {}
	void AstVisitor::Traverse(WfDetachEventExpression* node) {}
	void AstVisitor::Traverse(WfEnumDeclaration* node) {}
	void AstVisitor::Traverse(WfEnumItem* node) {}
	void AstVisitor::Traverse(WfEnumItemIntersection* node) {}
	void AstVisitor::Traverse(WfEnumerableType* node) {}
	void AstVisitor::Traverse(WfEventDeclaration* node) {}
	void AstVisitor::Traverse(WfExpectedTypeCastExpression* node) {}
	void AstVisitor::Traverse(WfExpression* node) {}
	void AstVisitor::Traverse(WfExpressionStatement* node) {}
	void AstVisitor::Traverse(WfFloatingExpression* node) {}
	void AstVisitor::Traverse(WfForEachStatement* node) {}
	void AstVisitor::Traverse(WfFormatExpression* node) {}
	void AstVisitor::Traverse(WfFunctionArgument* node) {}
	void AstVisitor::Traverse(WfFunctionDeclaration* node) {}
	void AstVisitor::Traverse(WfFunctionExpression* node) {}
	void AstVisitor::Traverse(WfFunctionType* node) {}
	void AstVisitor::Traverse(WfGotoStatement* node) {}
	void AstVisitor::Traverse(WfIfExpression* node) {}
	void AstVisitor::Traverse(WfIfStatement* node) {}
	void AstVisitor::Traverse(WfInferExpression* node) {}
	void AstVisitor::Traverse(WfIntegerExpression* node) {}
	void AstVisitor::Traverse(WfLetExpression* node) {}
	void AstVisitor::Traverse(WfLetVariable* node) {}
	void AstVisitor::Traverse(WfLiteralExpression* node) {}
	void AstVisitor::Traverse(WfMapType* node) {}
	void AstVisitor::Traverse(WfMemberExpression* node) {}
	void AstVisitor::Traverse(WfMixinCastExpression* node) {}
	void AstVisitor::Traverse(WfModule* node) {}
	void AstVisitor::Traverse(WfModuleUsingFragment* node) {}
	void AstVisitor::Traverse(WfModuleUsingItem* node) {}
	void AstVisitor::Traverse(WfModuleUsingNameFragment* node) {}
	void AstVisitor::Traverse(WfModuleUsingPath* node) {}
	void AstVisitor::Traverse(WfModuleUsingWildCardFragment* node) {}
	void AstVisitor::Traverse(WfNamespaceDeclaration* node) {}
	void AstVisitor::Traverse(WfNewClassExpression* node) {}
	void AstVisitor::Traverse(WfNewCoroutineExpression* node) {}
	void AstVisitor::Traverse(WfNewInterfaceExpression* node) {}
	void AstVisitor::Traverse(WfNullableType* node) {}
	void AstVisitor::Traverse(WfObservableListType* node) {}
	void AstVisitor::Traverse(WfObserveExpression* node) {}
	void AstVisitor::Traverse(WfOrderedLambdaExpression* node) {}
	void AstVisitor::Traverse(WfOrderedNameExpression* node) {}
	void AstVisitor::Traverse(WfPredefinedType* node) {}
	void AstVisitor::Traverse(WfPropertyDeclaration* node) {}
	void AstVisitor::Traverse(WfRaiseExceptionStatement* node) {}
	void AstVisitor::Traverse(WfRangeExpression* node) {}
	void AstVisitor::Traverse(WfRawPointerType* node) {}
	void AstVisitor::Traverse(WfReferenceExpression* node) {}
	void AstVisitor::Traverse(WfReferenceType* node) {}
	void AstVisitor::Traverse(WfReturnStatement* node) {}
	void AstVisitor::Traverse(WfSetTestingExpression* node) {}
	void AstVisitor::Traverse(WfSharedPointerType* node) {}
	void AstVisitor::Traverse(WfStateDeclaration* node) {}
	void AstVisitor::Traverse(WfStateInput* node) {}
	void AstVisitor::Traverse(WfStateInvokeStatement* node) {}
	void AstVisitor::Traverse(WfStateMachineDeclaration* node) {}
	void AstVisitor::Traverse(WfStateMachineStatement* node) {}
	void AstVisitor::Traverse(WfStateSwitchArgument* node) {}
	void AstVisitor::Traverse(WfStateSwitchCase* node) {}
	void AstVisitor::Traverse(WfStateSwitchStatement* node) {}
	void AstVisitor::Traverse(WfStatement* node) {}
	void AstVisitor::Traverse(WfStaticInitDeclaration* node) {}
	void AstVisitor::Traverse(WfStringExpression* node) {}
	void AstVisitor::Traverse(WfStructDeclaration* node) {}
	void AstVisitor::Traverse(WfStructMember* node) {}
	void AstVisitor::Traverse(WfSwitchCase* node) {}
	void AstVisitor::Traverse(WfSwitchStatement* node) {}
	void AstVisitor::Traverse(WfThisExpression* node) {}
	void AstVisitor::Traverse(WfTopQualifiedExpression* node) {}
	void AstVisitor::Traverse(WfTopQualifiedType* node) {}
	void AstVisitor::Traverse(WfTryStatement* node) {}
	void AstVisitor::Traverse(WfType* node) {}
	void AstVisitor::Traverse(WfTypeCastingExpression* node) {}
	void AstVisitor::Traverse(WfTypeOfExpressionExpression* node) {}
	void AstVisitor::Traverse(WfTypeOfTypeExpression* node) {}
	void AstVisitor::Traverse(WfTypeTestingExpression* node) {}
	void AstVisitor::Traverse(WfUnaryExpression* node) {}
	void AstVisitor::Traverse(WfVariableDeclaration* node) {}
	void AstVisitor::Traverse(WfVariableStatement* node) {}
	void AstVisitor::Traverse(WfVirtualCfeDeclaration* node) {}
	void AstVisitor::Traverse(WfVirtualCfeExpression* node) {}
	void AstVisitor::Traverse(WfVirtualCseDeclaration* node) {}
	void AstVisitor::Traverse(WfVirtualCseExpression* node) {}
	void AstVisitor::Traverse(WfVirtualCseStatement* node) {}
	void AstVisitor::Traverse(WfWhileStatement* node) {}

	void AstVisitor::Finishing(vl::glr::ParsingAstBase* node) {}
	void AstVisitor::Finishing(WfAttachEventExpression* node) {}
	void AstVisitor::Finishing(WfAttribute* node) {}
	void AstVisitor::Finishing(WfAutoPropertyDeclaration* node) {}
	void AstVisitor::Finishing(WfBaseConstructorCall* node) {}
	void AstVisitor::Finishing(WfBinaryExpression* node) {}
	void AstVisitor::Finishing(WfBindExpression* node) {}
	void AstVisitor::Finishing(WfBlockStatement* node) {}
	void AstVisitor::Finishing(WfBreakStatement* node) {}
	void AstVisitor::Finishing(WfCallExpression* node) {}
	void AstVisitor::Finishing(WfCastResultInterfaceDeclaration* node) {}
	void AstVisitor::Finishing(WfChildExpression* node) {}
	void AstVisitor::Finishing(WfChildType* node) {}
	void AstVisitor::Finishing(WfClassDeclaration* node) {}
	void AstVisitor::Finishing(WfCoOperatorExpression* node) {}
	void AstVisitor::Finishing(WfCoOperatorStatement* node) {}
	void AstVisitor::Finishing(WfCoPauseStatement* node) {}
	void AstVisitor::Finishing(WfCoProviderStatement* node) {}
	void AstVisitor::Finishing(WfConstructorArgument* node) {}
	void AstVisitor::Finishing(WfConstructorDeclaration* node) {}
	void AstVisitor::Finishing(WfConstructorExpression* node) {}
	void AstVisitor::Finishing(WfContinueStatement* node) {}
	void AstVisitor::Finishing(WfCoroutineStatement* node) {}
	void AstVisitor::Finishing(WfDeclaration* node) {}
	void AstVisitor::Finishing(WfDeleteStatement* node) {}
	void AstVisitor::Finishing(WfDestructorDeclaration* node) {}
	void AstVisitor::Finishing(WfDetachEventExpression* node) {}
	void AstVisitor::Finishing(WfEnumDeclaration* node) {}
	void AstVisitor::Finishing(WfEnumItem* node) {}
	void AstVisitor::Finishing(WfEnumItemIntersection* node) {}
	void AstVisitor::Finishing(WfEnumerableType* node) {}
	void AstVisitor::Finishing(WfEventDeclaration* node) {}
	void AstVisitor::Finishing(WfExpectedTypeCastExpression* node) {}
	void AstVisitor::Finishing(WfExpression* node) {}
	void AstVisitor::Finishing(WfExpressionStatement* node) {}
	void AstVisitor::Finishing(WfFloatingExpression* node) {}
	void AstVisitor::Finishing(WfForEachStatement* node) {}
	void AstVisitor::Finishing(WfFormatExpression* node) {}
	void AstVisitor::Finishing(WfFunctionArgument* node) {}
	void AstVisitor::Finishing(WfFunctionDeclaration* node) {}
	void AstVisitor::Finishing(WfFunctionExpression* node) {}
	void AstVisitor::Finishing(WfFunctionType* node) {}
	void AstVisitor::Finishing(WfGotoStatement* node) {}
	void AstVisitor::Finishing(WfIfExpression* node) {}
	void AstVisitor::Finishing(WfIfStatement* node) {}
	void AstVisitor::Finishing(WfInferExpression* node) {}
	void AstVisitor::Finishing(WfIntegerExpression* node) {}
	void AstVisitor::Finishing(WfLetExpression* node) {}
	void AstVisitor::Finishing(WfLetVariable* node) {}
	void AstVisitor::Finishing(WfLiteralExpression* node) {}
	void AstVisitor::Finishing(WfMapType* node) {}
	void AstVisitor::Finishing(WfMemberExpression* node) {}
	void AstVisitor::Finishing(WfMixinCastExpression* node) {}
	void AstVisitor::Finishing(WfModule* node) {}
	void AstVisitor::Finishing(WfModuleUsingFragment* node) {}
	void AstVisitor::Finishing(WfModuleUsingItem* node) {}
	void AstVisitor::Finishing(WfModuleUsingNameFragment* node) {}
	void AstVisitor::Finishing(WfModuleUsingPath* node) {}
	void AstVisitor::Finishing(WfModuleUsingWildCardFragment* node) {}
	void AstVisitor::Finishing(WfNamespaceDeclaration* node) {}
	void AstVisitor::Finishing(WfNewClassExpression* node) {}
	void AstVisitor::Finishing(WfNewCoroutineExpression* node) {}
	void AstVisitor::Finishing(WfNewInterfaceExpression* node) {}
	void AstVisitor::Finishing(WfNullableType* node) {}
	void AstVisitor::Finishing(WfObservableListType* node) {}
	void AstVisitor::Finishing(WfObserveExpression* node) {}
	void AstVisitor::Finishing(WfOrderedLambdaExpression* node) {}
	void AstVisitor::Finishing(WfOrderedNameExpression* node) {}
	void AstVisitor::Finishing(WfPredefinedType* node) {}
	void AstVisitor::Finishing(WfPropertyDeclaration* node) {}
	void AstVisitor::Finishing(WfRaiseExceptionStatement* node) {}
	void AstVisitor::Finishing(WfRangeExpression* node) {}
	void AstVisitor::Finishing(WfRawPointerType* node) {}
	void AstVisitor::Finishing(WfReferenceExpression* node) {}
	void AstVisitor::Finishing(WfReferenceType* node) {}
	void AstVisitor::Finishing(WfReturnStatement* node) {}
	void AstVisitor::Finishing(WfSetTestingExpression* node) {}
	void AstVisitor::Finishing(WfSharedPointerType* node) {}
	void AstVisitor::Finishing(WfStateDeclaration* node) {}
	void AstVisitor::Finishing(WfStateInput* node) {}
	void AstVisitor::Finishing(WfStateInvokeStatement* node) {}
	void AstVisitor::Finishing(WfStateMachineDeclaration* node) {}
	void AstVisitor::Finishing(WfStateMachineStatement* node) {}
	void AstVisitor::Finishing(WfStateSwitchArgument* node) {}
	void AstVisitor::Finishing(WfStateSwitchCase* node) {}
	void AstVisitor::Finishing(WfStateSwitchStatement* node) {}
	void AstVisitor::Finishing(WfStatement* node) {}
	void AstVisitor::Finishing(WfStaticInitDeclaration* node) {}
	void AstVisitor::Finishing(WfStringExpression* node) {}
	void AstVisitor::Finishing(WfStructDeclaration* node) {}
	void AstVisitor::Finishing(WfStructMember* node) {}
	void AstVisitor::Finishing(WfSwitchCase* node) {}
	void AstVisitor::Finishing(WfSwitchStatement* node) {}
	void AstVisitor::Finishing(WfThisExpression* node) {}
	void AstVisitor::Finishing(WfTopQualifiedExpression* node) {}
	void AstVisitor::Finishing(WfTopQualifiedType* node) {}
	void AstVisitor::Finishing(WfTryStatement* node) {}
	void AstVisitor::Finishing(WfType* node) {}
	void AstVisitor::Finishing(WfTypeCastingExpression* node) {}
	void AstVisitor::Finishing(WfTypeOfExpressionExpression* node) {}
	void AstVisitor::Finishing(WfTypeOfTypeExpression* node) {}
	void AstVisitor::Finishing(WfTypeTestingExpression* node) {}
	void AstVisitor::Finishing(WfUnaryExpression* node) {}
	void AstVisitor::Finishing(WfVariableDeclaration* node) {}
	void AstVisitor::Finishing(WfVariableStatement* node) {}
	void AstVisitor::Finishing(WfVirtualCfeDeclaration* node) {}
	void AstVisitor::Finishing(WfVirtualCfeExpression* node) {}
	void AstVisitor::Finishing(WfVirtualCseDeclaration* node) {}
	void AstVisitor::Finishing(WfVirtualCseExpression* node) {}
	void AstVisitor::Finishing(WfVirtualCseStatement* node) {}
	void AstVisitor::Finishing(WfWhileStatement* node) {}

	void AstVisitor::Visit(WfPredefinedType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfPredefinedType*>(node));
		Finishing(static_cast<WfPredefinedType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfTopQualifiedType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfTopQualifiedType*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfTopQualifiedType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfReferenceType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfReferenceType*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfReferenceType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfRawPointerType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfRawPointerType*>(node));
		InspectInto(node->element.Obj());
		Finishing(static_cast<WfRawPointerType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfSharedPointerType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfSharedPointerType*>(node));
		InspectInto(node->element.Obj());
		Finishing(static_cast<WfSharedPointerType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfNullableType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfNullableType*>(node));
		InspectInto(node->element.Obj());
		Finishing(static_cast<WfNullableType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfEnumerableType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfEnumerableType*>(node));
		InspectInto(node->element.Obj());
		Finishing(static_cast<WfEnumerableType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfMapType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfMapType*>(node));
		InspectInto(node->key.Obj());
		InspectInto(node->value.Obj());
		Finishing(static_cast<WfMapType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfObservableListType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfObservableListType*>(node));
		InspectInto(node->element.Obj());
		Finishing(static_cast<WfObservableListType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfFunctionType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfFunctionType*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->result.Obj());
		Finishing(static_cast<WfFunctionType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfChildType* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfType*>(node));
		Traverse(static_cast<WfChildType*>(node));
		Traverse(node->name);
		InspectInto(node->parent.Obj());
		Finishing(static_cast<WfChildType*>(node));
		Finishing(static_cast<WfType*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfThisExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfThisExpression*>(node));
		Finishing(static_cast<WfThisExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfTopQualifiedExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfTopQualifiedExpression*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfTopQualifiedExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfReferenceExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfReferenceExpression*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfReferenceExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfOrderedNameExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfOrderedNameExpression*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfOrderedNameExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfOrderedLambdaExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfOrderedLambdaExpression*>(node));
		InspectInto(node->body.Obj());
		Finishing(static_cast<WfOrderedLambdaExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfMemberExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfMemberExpression*>(node));
		Traverse(node->name);
		InspectInto(node->parent.Obj());
		Finishing(static_cast<WfMemberExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfChildExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfChildExpression*>(node));
		Traverse(node->name);
		InspectInto(node->parent.Obj());
		Finishing(static_cast<WfChildExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfLiteralExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfLiteralExpression*>(node));
		Finishing(static_cast<WfLiteralExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfFloatingExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfFloatingExpression*>(node));
		Traverse(node->value);
		Finishing(static_cast<WfFloatingExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfIntegerExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfIntegerExpression*>(node));
		Traverse(node->value);
		Finishing(static_cast<WfIntegerExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfStringExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfStringExpression*>(node));
		Traverse(node->value);
		Finishing(static_cast<WfStringExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfUnaryExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfUnaryExpression*>(node));
		InspectInto(node->operand.Obj());
		Finishing(static_cast<WfUnaryExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfBinaryExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfBinaryExpression*>(node));
		InspectInto(node->first.Obj());
		InspectInto(node->second.Obj());
		Finishing(static_cast<WfBinaryExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfLetExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfLetExpression*>(node));
		InspectInto(node->expression.Obj());
		for (auto&& listItem : node->variables)
		{
			InspectInto(listItem.Obj());
		}
		Finishing(static_cast<WfLetExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfIfExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfIfExpression*>(node));
		InspectInto(node->condition.Obj());
		InspectInto(node->falseBranch.Obj());
		InspectInto(node->trueBranch.Obj());
		Finishing(static_cast<WfIfExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfRangeExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfRangeExpression*>(node));
		InspectInto(node->begin.Obj());
		InspectInto(node->end.Obj());
		Finishing(static_cast<WfRangeExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfSetTestingExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfSetTestingExpression*>(node));
		InspectInto(node->collection.Obj());
		InspectInto(node->element.Obj());
		Finishing(static_cast<WfSetTestingExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfConstructorExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfConstructorExpression*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		Finishing(static_cast<WfConstructorExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfInferExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfInferExpression*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfInferExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfTypeCastingExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfTypeCastingExpression*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfTypeCastingExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfTypeTestingExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfTypeTestingExpression*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfTypeTestingExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfTypeOfTypeExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfTypeOfTypeExpression*>(node));
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfTypeOfTypeExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfTypeOfExpressionExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfTypeOfExpressionExpression*>(node));
		InspectInto(node->expression.Obj());
		Finishing(static_cast<WfTypeOfExpressionExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfAttachEventExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfAttachEventExpression*>(node));
		InspectInto(node->event.Obj());
		InspectInto(node->function.Obj());
		Finishing(static_cast<WfAttachEventExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfDetachEventExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfDetachEventExpression*>(node));
		InspectInto(node->event.Obj());
		InspectInto(node->handler.Obj());
		Finishing(static_cast<WfDetachEventExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfObserveExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfObserveExpression*>(node));
		for (auto&& listItem : node->events)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->expression.Obj());
		Traverse(node->name);
		InspectInto(node->parent.Obj());
		Finishing(static_cast<WfObserveExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfCallExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfCallExpression*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->function.Obj());
		Finishing(static_cast<WfCallExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfFunctionExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfFunctionExpression*>(node));
		InspectInto(node->function.Obj());
		Finishing(static_cast<WfFunctionExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfNewClassExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfNewClassExpression*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfNewClassExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfNewInterfaceExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfNewInterfaceExpression*>(node));
		for (auto&& listItem : node->declarations)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfNewInterfaceExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfVirtualCfeExpression* node)
	{
		node->Accept(static_cast<WfVirtualCfeExpression::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfVirtualCseExpression* node)
	{
		node->Accept(static_cast<WfVirtualCseExpression::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfBreakStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfBreakStatement*>(node));
		Finishing(static_cast<WfBreakStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfContinueStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfContinueStatement*>(node));
		Finishing(static_cast<WfContinueStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfReturnStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfReturnStatement*>(node));
		InspectInto(node->expression.Obj());
		Finishing(static_cast<WfReturnStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfDeleteStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfDeleteStatement*>(node));
		InspectInto(node->expression.Obj());
		Finishing(static_cast<WfDeleteStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfRaiseExceptionStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfRaiseExceptionStatement*>(node));
		InspectInto(node->expression.Obj());
		Finishing(static_cast<WfRaiseExceptionStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfIfStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfIfStatement*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->falseBranch.Obj());
		Traverse(node->name);
		InspectInto(node->trueBranch.Obj());
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfIfStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfWhileStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfWhileStatement*>(node));
		InspectInto(node->condition.Obj());
		InspectInto(node->statement.Obj());
		Finishing(static_cast<WfWhileStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfTryStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfTryStatement*>(node));
		InspectInto(node->catchStatement.Obj());
		InspectInto(node->finallyStatement.Obj());
		Traverse(node->name);
		InspectInto(node->protectedStatement.Obj());
		Finishing(static_cast<WfTryStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfBlockStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfBlockStatement*>(node));
		Traverse(node->endLabel);
		for (auto&& listItem : node->statements)
		{
			InspectInto(listItem.Obj());
		}
		Finishing(static_cast<WfBlockStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfGotoStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfGotoStatement*>(node));
		Traverse(node->label);
		Finishing(static_cast<WfGotoStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfVariableStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfVariableStatement*>(node));
		InspectInto(node->variable.Obj());
		Finishing(static_cast<WfVariableStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfExpressionStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfExpressionStatement*>(node));
		InspectInto(node->expression.Obj());
		Finishing(static_cast<WfExpressionStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfVirtualCseStatement* node)
	{
		node->Accept(static_cast<WfVirtualCseStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfCoroutineStatement* node)
	{
		node->Accept(static_cast<WfCoroutineStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfStateMachineStatement* node)
	{
		node->Accept(static_cast<WfStateMachineStatement::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfNamespaceDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfNamespaceDeclaration*>(node));
		for (auto&& listItem : node->declarations)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfNamespaceDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfFunctionDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfFunctionDeclaration*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->returnType.Obj());
		InspectInto(node->statement.Obj());
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfFunctionDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfVariableDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfVariableDeclaration*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->type.Obj());
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfVariableDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfEventDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfEventDeclaration*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfEventDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfPropertyDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfPropertyDeclaration*>(node));
		Traverse(node->getter);
		Traverse(node->setter);
		InspectInto(node->type.Obj());
		Traverse(node->valueChangedEvent);
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfPropertyDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfStaticInitDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfStaticInitDeclaration*>(node));
		InspectInto(node->statement.Obj());
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfStaticInitDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfConstructorDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfConstructorDeclaration*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->baseConstructorCalls)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->statement.Obj());
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfConstructorDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfDestructorDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfDestructorDeclaration*>(node));
		InspectInto(node->statement.Obj());
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfDestructorDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfClassDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfClassDeclaration*>(node));
		for (auto&& listItem : node->baseTypes)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->declarations)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfClassDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfEnumDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfEnumDeclaration*>(node));
		for (auto&& listItem : node->items)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfEnumDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfStructDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfStructDeclaration*>(node));
		for (auto&& listItem : node->members)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfStructDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfVirtualCfeDeclaration* node)
	{
		node->Accept(static_cast<WfVirtualCfeDeclaration::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfVirtualCseDeclaration* node)
	{
		node->Accept(static_cast<WfVirtualCseDeclaration::IVisitor*>(this));
	}

	void AstVisitor::Visit(WfAutoPropertyDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfVirtualCfeDeclaration*>(node));
		Traverse(static_cast<WfAutoPropertyDeclaration*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->type.Obj());
		for (auto&& listItem : node->expandedDeclarations)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfAutoPropertyDeclaration*>(node));
		Finishing(static_cast<WfVirtualCfeDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfCastResultInterfaceDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfVirtualCfeDeclaration*>(node));
		Traverse(static_cast<WfCastResultInterfaceDeclaration*>(node));
		InspectInto(node->baseType.Obj());
		InspectInto(node->elementType.Obj());
		for (auto&& listItem : node->expandedDeclarations)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfCastResultInterfaceDeclaration*>(node));
		Finishing(static_cast<WfVirtualCfeDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfStateMachineDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfDeclaration*>(node));
		Traverse(static_cast<WfVirtualCseDeclaration*>(node));
		Traverse(static_cast<WfStateMachineDeclaration*>(node));
		for (auto&& listItem : node->inputs)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->states)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->expandedDeclarations)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfStateMachineDeclaration*>(node));
		Finishing(static_cast<WfVirtualCseDeclaration*>(node));
		Finishing(static_cast<WfDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfForEachStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfVirtualCseStatement*>(node));
		Traverse(static_cast<WfForEachStatement*>(node));
		InspectInto(node->collection.Obj());
		Traverse(node->name);
		InspectInto(node->statement.Obj());
		InspectInto(node->expandedStatement.Obj());
		Finishing(static_cast<WfForEachStatement*>(node));
		Finishing(static_cast<WfVirtualCseStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfSwitchStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfVirtualCseStatement*>(node));
		Traverse(static_cast<WfSwitchStatement*>(node));
		for (auto&& listItem : node->caseBranches)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->defaultBranch.Obj());
		InspectInto(node->expression.Obj());
		InspectInto(node->expandedStatement.Obj());
		Finishing(static_cast<WfSwitchStatement*>(node));
		Finishing(static_cast<WfVirtualCseStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfCoProviderStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfVirtualCseStatement*>(node));
		Traverse(static_cast<WfCoProviderStatement*>(node));
		Traverse(node->name);
		InspectInto(node->statement.Obj());
		InspectInto(node->expandedStatement.Obj());
		Finishing(static_cast<WfCoProviderStatement*>(node));
		Finishing(static_cast<WfVirtualCseStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfCoPauseStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfCoroutineStatement*>(node));
		Traverse(static_cast<WfCoPauseStatement*>(node));
		InspectInto(node->statement.Obj());
		Finishing(static_cast<WfCoPauseStatement*>(node));
		Finishing(static_cast<WfCoroutineStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfCoOperatorStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfCoroutineStatement*>(node));
		Traverse(static_cast<WfCoOperatorStatement*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->opName);
		Traverse(node->varName);
		Finishing(static_cast<WfCoOperatorStatement*>(node));
		Finishing(static_cast<WfCoroutineStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfStateSwitchStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfStateMachineStatement*>(node));
		Traverse(static_cast<WfStateSwitchStatement*>(node));
		for (auto&& listItem : node->caseBranches)
		{
			InspectInto(listItem.Obj());
		}
		Finishing(static_cast<WfStateSwitchStatement*>(node));
		Finishing(static_cast<WfStateMachineStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfStateInvokeStatement* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStatement*>(node));
		Traverse(static_cast<WfStateMachineStatement*>(node));
		Traverse(static_cast<WfStateInvokeStatement*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfStateInvokeStatement*>(node));
		Finishing(static_cast<WfStateMachineStatement*>(node));
		Finishing(static_cast<WfStatement*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfFormatExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfVirtualCfeExpression*>(node));
		Traverse(static_cast<WfFormatExpression*>(node));
		Traverse(node->value);
		InspectInto(node->expandedExpression.Obj());
		Finishing(static_cast<WfFormatExpression*>(node));
		Finishing(static_cast<WfVirtualCfeExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfBindExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfVirtualCseExpression*>(node));
		Traverse(static_cast<WfBindExpression*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->expandedExpression.Obj());
		Finishing(static_cast<WfBindExpression*>(node));
		Finishing(static_cast<WfVirtualCseExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfNewCoroutineExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfVirtualCseExpression*>(node));
		Traverse(static_cast<WfNewCoroutineExpression*>(node));
		Traverse(node->name);
		InspectInto(node->statement.Obj());
		InspectInto(node->expandedExpression.Obj());
		Finishing(static_cast<WfNewCoroutineExpression*>(node));
		Finishing(static_cast<WfVirtualCseExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfMixinCastExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfVirtualCseExpression*>(node));
		Traverse(static_cast<WfMixinCastExpression*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->type.Obj());
		InspectInto(node->expandedExpression.Obj());
		Finishing(static_cast<WfMixinCastExpression*>(node));
		Finishing(static_cast<WfVirtualCseExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfExpectedTypeCastExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfVirtualCseExpression*>(node));
		Traverse(static_cast<WfExpectedTypeCastExpression*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->expandedExpression.Obj());
		Finishing(static_cast<WfExpectedTypeCastExpression*>(node));
		Finishing(static_cast<WfVirtualCseExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfCoOperatorExpression* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfExpression*>(node));
		Traverse(static_cast<WfVirtualCseExpression*>(node));
		Traverse(static_cast<WfCoOperatorExpression*>(node));
		Traverse(node->name);
		InspectInto(node->expandedExpression.Obj());
		Finishing(static_cast<WfCoOperatorExpression*>(node));
		Finishing(static_cast<WfVirtualCseExpression*>(node));
		Finishing(static_cast<WfExpression*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfModuleUsingNameFragment* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfModuleUsingFragment*>(node));
		Traverse(static_cast<WfModuleUsingNameFragment*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfModuleUsingNameFragment*>(node));
		Finishing(static_cast<WfModuleUsingFragment*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::Visit(WfModuleUsingWildCardFragment* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfModuleUsingFragment*>(node));
		Traverse(static_cast<WfModuleUsingWildCardFragment*>(node));
		Finishing(static_cast<WfModuleUsingWildCardFragment*>(node));
		Finishing(static_cast<WfModuleUsingFragment*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfType* node)
	{
		if (!node) return;
		node->Accept(static_cast<WfType::IVisitor*>(this));
	}

	void AstVisitor::InspectInto(WfExpression* node)
	{
		if (!node) return;
		node->Accept(static_cast<WfExpression::IVisitor*>(this));
	}

	void AstVisitor::InspectInto(WfStatement* node)
	{
		if (!node) return;
		node->Accept(static_cast<WfStatement::IVisitor*>(this));
	}

	void AstVisitor::InspectInto(WfDeclaration* node)
	{
		if (!node) return;
		node->Accept(static_cast<WfDeclaration::IVisitor*>(this));
	}

	void AstVisitor::InspectInto(WfModuleUsingFragment* node)
	{
		if (!node) return;
		node->Accept(static_cast<WfModuleUsingFragment::IVisitor*>(this));
	}

	void AstVisitor::InspectInto(WfAttribute* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfAttribute*>(node));
		Traverse(node->category);
		Traverse(node->name);
		InspectInto(node->value.Obj());
		Finishing(static_cast<WfAttribute*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfFunctionArgument* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfFunctionArgument*>(node));
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfFunctionArgument*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfBaseConstructorCall* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfBaseConstructorCall*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfBaseConstructorCall*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfEnumItemIntersection* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfEnumItemIntersection*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfEnumItemIntersection*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfEnumItem* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfEnumItem*>(node));
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		for (auto&& listItem : node->intersections)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Traverse(node->number);
		Finishing(static_cast<WfEnumItem*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfStructMember* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStructMember*>(node));
		for (auto&& listItem : node->attributes)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		InspectInto(node->type.Obj());
		Finishing(static_cast<WfStructMember*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfStateInput* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStateInput*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		Finishing(static_cast<WfStateInput*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfStateDeclaration* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStateDeclaration*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		InspectInto(node->statement.Obj());
		Finishing(static_cast<WfStateDeclaration*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfSwitchCase* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfSwitchCase*>(node));
		InspectInto(node->expression.Obj());
		InspectInto(node->statement.Obj());
		Finishing(static_cast<WfSwitchCase*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfStateSwitchArgument* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStateSwitchArgument*>(node));
		Traverse(node->name);
		Finishing(static_cast<WfStateSwitchArgument*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfStateSwitchCase* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfStateSwitchCase*>(node));
		for (auto&& listItem : node->arguments)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		InspectInto(node->statement.Obj());
		Finishing(static_cast<WfStateSwitchCase*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfLetVariable* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfLetVariable*>(node));
		Traverse(node->name);
		InspectInto(node->value.Obj());
		Finishing(static_cast<WfLetVariable*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfConstructorArgument* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfConstructorArgument*>(node));
		InspectInto(node->key.Obj());
		InspectInto(node->value.Obj());
		Finishing(static_cast<WfConstructorArgument*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfModuleUsingItem* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfModuleUsingItem*>(node));
		for (auto&& listItem : node->fragments)
		{
			InspectInto(listItem.Obj());
		}
		Finishing(static_cast<WfModuleUsingItem*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfModuleUsingPath* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfModuleUsingPath*>(node));
		for (auto&& listItem : node->items)
		{
			InspectInto(listItem.Obj());
		}
		Finishing(static_cast<WfModuleUsingPath*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

	void AstVisitor::InspectInto(WfModule* node)
	{
		if (!node) return;
		Traverse(static_cast<vl::glr::ParsingAstBase*>(node));
		Traverse(static_cast<WfModule*>(node));
		for (auto&& listItem : node->declarations)
		{
			InspectInto(listItem.Obj());
		}
		Traverse(node->name);
		for (auto&& listItem : node->paths)
		{
			InspectInto(listItem.Obj());
		}
		Finishing(static_cast<WfModule*>(node));
		Finishing(static_cast<vl::glr::ParsingAstBase*>(node));
	}

}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOWPARSER.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Workflow
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow
{
	void WorkflowParserData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 151080; // 2617385 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 40;
		static const vl::vint dataSolidRows = 590;
		static const vl::vint dataRows = 591;
		static const char* compressed[] = {
			"\x00\x00\x10\x00\xBB\x5D\x00\x00\x73\x00\x01\x82\x80\x0A\x23\x82\x81\x82\x06\x89\x82\x92\x1A\x87\x1A\x84\x1E\x0A\xFF\x52\x93\x84\x8D\x8A\x8B\x89\x51\x0A\x9C\x6A\x8A\x72\x84\x78\x85\xFC\x0A\x8B\x01\x09\x84\x08\x92\x83\x29\x27\x83\x8F\x1A\x92\x81\x1B\x96\x01\xBB\x30\x80\x01\x23\x99\x25\x99\x4F\x33\x92\x33\x98\x2B\x98\x31\x99\x64\x33\x97\x9F\x72\x3B\x9B\x43\x99\x93\x33\x98\x53\x96\x53\x99\x55\x99\xB4\x33\x88\x73\x90\x7B\x99\x7D\x99\x03\x02\x09\x8A\x0A\xAE\x83\x09\xAE\x03\x9A\x20\xA2\x83\xA0\x13\xB1\x80\x43\xC3\xA4\x07\xB0\x04\x1C\xB7\x22\x6C\xCE\x2C\xBB\x2C\xB7\x2C\xB7\xA1\x67\x6C\xB4\x37\xB7\x88\x3C\xBE\x8B\x94\x7F\x95\x97\x4C\xB6\x4C\xB6\x54\x6C\xB6\x6C\xBD\x52\xC1\xB7\x88\x62\x6C\xDF\x6C\xA9\x7C\xB0\x7C\xB6\x7E\x6C\x80\x03\x09\x84\x03\xCE\x83\xA1\x0B\x1E\xC3\x83\x49\x30\x9B\xA0\x85\x00\x27\xD1\x97\x88\xD2\xD5\x84\xD7\x9F\xAC\xEB\xD6\x8D\xD2\xDB\xD6\xDB\xB1\xB4\xF3\xD5\x85\xDA\xDF\xDA\xDF\xB9\xBC\xFB\xD4\x8D\xDA\xE3\xDE\xE3\xC1\xC4\xC3\xF3\x88\xD0\xD7\x99\xD4\xB8\x83\xB0\xD2\xE1\xEC\xB1\xEA\xB4\xD7\xD0\xC0\xF4",
			"\xEB\xEE\xE9\xEF\x80\xCF\xCF\xD3\xFE\xE8\xE3\x81\xCD\xE7\xA2\x83\x8F\xE4\x0A\x87\xE5\x03\xF6\x0A\x86\x30\xE9\x87\x03\xFA\x82\x04\xF6\x83\x89\x19\xF2\x82\x04\xFF\x80\x0B\x3F\x70\x00\x03\x02\xA3\x78\x77\x77\xDA\x65\x74\x7A\x72\xC7\x4C\x89\x70\x73\xCB\x52\x45\x72\x83\xDC\x4A\x87\x82\x85\x09\x94\x8B\x80\x84\x0D\x9C\x8F\x82\x84\x11\xBF\x33\x86\x87\x15\x9A\x87\x86\x89\x00\x0D\x05\x81\x76\x06\x99\x84\x8A\x40\x0E\x2B\x88\x81\x8B\x34\xAC\x86\x8F\x8C\x37\x98\x85\x8C\x8E\x3C\xBA\x89\x8C\x8A\x3B\xBE\x8D\x8C\x90\x3F\xAF\x87\x8A\x91\x2E\xA0\x8D\x86\x92\x1F\xA2\x81\x8B\x88\x4C\xA5\x88\x91\x90\x44\x83\x93\x95\x91\x51\x9B\x89\x97\x91\x5B\x89\x9E\x93\x92\x5F\x8D\x90\x95\x98\x52\x9D\x94\x97\x95\x56\x9D\x9F\x02\x8C\x42\xAD\x95\x96\x9B\x68\xB0\x96\x98\x96\x64\x9A\x95\x9C\x97\x77\x9E\x93\x9B\x9E\x4F\xBD\x90\x98\x9F\x7F\xBE\x92\x9A\xA0\x65\xB9\x97\x9B\x9C\x69\x86\xA4\x9C\xA0\x83\x81\xAE\xA1\xA3\x90\x85\xAC\xA2\xA4\x84\xB6\x93\xA6\xA5\x95\xB8\x97\xA6\xA6\x99\xBA\x9D\xA7\xA1\x8A\x89\xAB\xA6\xA7\x8F\x94\xA5\xA8\xA6\xA7\x9C\xA9\xA8\xA9",
			"\x91\xA8\xAD\xAA\xAA\xAF\xAC\xA6\xA9\xAC\xA0\xA3\xA5\xAF\xA7\x8B\xB8\xA2\xAA\xAE\x72\xA1\xAD\xAE\xAD\xB9\xAB\xA7\xAE\xB0\xC1\xB4\xA5\xB3\xAC\xC8\xAE\xA9\xB0\xAC\xCB\xB2\xAA\xB3\xB3\xCC\x90\xBE\xB1\xB4\xD4\x93\xB6\xB7\xB0\xC6\xBB\xA4\xB2\xB6\xD9\xBF\xAC\xAF\x9B\xE0\xB1\x91\xB8\xA2\xDE\x9B\xB5\xB9\xB7\xE3\xBE\xA9\xB8\xB0\xDC\x8D\xB8\xB6\xBB\xC7\x92\xBF\xBA\xBC\xF1\x95\xB3\xBE\xBD\xF5\x97\xB9\xBF\xBD\xFA\xAD\xB4\xBE\xBF\xF8\x80\xCD\xBF\xB9\xF0\x82\xCC\xBF\xC1\xFB\x89\xC6\xC2\xC2\x04\xFF\xBD\xC1\xC0\x0F\xC3\xCB\xBB\xB7\xE2\x95\xC4\xBB\xC4\xE6\x98\xC8\xBA\xC5\xEA\x9C\xCC\xB9\xC4\x08\xCB\xC2\xC8\xC8\xF9\x90\x0C\x9A\xC6\x05\xE4\xC2\xC1\x04\x02\x92\x01\x7C\xC5\x17\xDE\xC0\xCD\xC7\x31\xF5\xC4\xCF\xCD\x1F\xE8\xCE\xC2\xCE\x10\xFC\xC2\xC6\xCC\x19\xC0\xDB\xC6\xCD\x39\xC2\xD9\xCA\xCF\x21\xEA\xCA\xD0\xD2\x0C\xCC\xD3\xCA\xD3\x4B\xC6\xDB\xCE\xD4\x3D\xD4\xDF\xCC\xD1\x33\xC5\xD8\xD5\xD0\x5B\xC3\xD8\xCD\xD6\x60\xDC\xDF\xD6\xD8\x5A\xE3\xDE\xD5\xD9\x68\xE1\xD7\xDA\xDA\x47\xD6\xD9\xD0\xD4\x70\xEE\xDD\xD2\xDC\x08\x98\x02\x81\x06\x2F",
			"\xE4\xDC\xDB\xD4\x5D\xED\xDD\xDC\xDF\x66\xFE\xD1\xE0\xE0\x69\xFA\xD6\xE3\xDA\x87\xC2\xE5\xE0\xE2\x8C\xCA\xEB\xDD\xD5\x7F\xD0\xE3\xE2\xE4\x8B\xCE\xE9\xE0\xE1\x8F\xD7\xD3\xE6\xE6\x95\xD8\xE7\xE4\xE5\x99\xEF\xD4\xDD\xD4\x91\xDC\xE1\xEB\xDC\xA5\xE2\xE9\xE8\xEA\x9B\xEA\xED\xE8\xEB\x9D\xE0\xEF\xE6\xE9\xB3\xED\x8F\x06\x80\x20\x39\xDD\xE2\xE7\xBB\xF2\xED\xEC\xED\xBF\xEE\xE1\xEC\xF0\x96\xC1\xF0\xEF\xE9\x4F\xE3\xE1\xDF\xEA\xC9\xCC\xF4\xEB\xEB\xCD\xD0\xFF\xF3\xF0\xC2\xC8\xF3\xF6\xF5\xCB\xD2\xF9\xF4\xF5\xC7\xF5\xED\xF6\xF1\xD1\xDC\xF1\xF8\xF6\xCA\xE5\xFE\xF3\xF6\xE4\xE7\xF6\xFA\xF6\xEB\xE2\xF7\xF6\xF7\xE3\xF0\xFF\xF8\xF8\xF3\xC3\x46\x0B\xC9\xED\xE9\xFC\xF9\x97\x27\x38\xF5\xE8\x0A\x02\x49\x06\x80\x2A\x02\x41\x15\x02\x44\x05\x02\x4D\x06\x80\x2E\x02\x41\x17\x02\x40\x06\x02\x51\x06\x80\x0C\x29\x20\xF1\x1F\x7D\x78\x18\x9C\x75\x06\xBE\x7B\x82\xE2\x52\x5B\x06\xFE\x7B\x7D\x9E\x34\x01\x84\xF7\x68\x7A\x7E\x27\x94\x7D\x0A\x9D\x85\x7A\x14\xB9\x7E\x85\xEA\x71\x86\x08\xA6\x8F\x84\x15\x96\x6D\x06\x25\x9A\x7C\x0D\xB2\x8B\x87\x19\xBA\x87",
			"\x87\x30\x9E\x87\xAA\x36\x09\x87\x20\xA3\x56\x21\x15\x99\x70\x0E\x45\x81\x57\x1C\x02\x42\x07\x02\x5B\x06\x80\x10\x29\x89\x84\x3D\x02\x40\x3E\x02\x43\x0F\x02\x40\x08\x01\x41\x0A\x40\x42\x02\x43\x10\x4C\x8C\x85\x0B\x9A\x87\x8C\x1C\x88\x8E\x07\xE9\x81\x20\x22\x24\x8A\x8D\x45\x0F\x8C\x1B\xEB\x84\x8F\x16\xB6\x84\x87\x40\x97\x8E\x10\xFA\x8D\x87\x3E\xB9\x8D\x8C\xF1\x7C\x8D\xA7\x46\x02\x8F\x3A\xA6\x8B\x8E\x76\x80\x91\xFD\x6A\x89\x90\x46\x87\x96\x90\x81\x8D\x5B\x11\x05\x9D\x90\x44\x8F\x95\x92\x90\x8B\x92\x25\x91\x9E\x90\x4E\x9B\x92\x93\x99\x8B\x85\x27\xA0\x98\x93\x52\x97\x97\x94\x9E\x81\x95\x0D\x8A\x92\x95\x4F\xAD\x92\x95\x78\x86\x8B\x1F\xA3\x9F\x94\x4C\x88\x0A\x40\x49\x1A\x74\x2B\xAB\x94\x96\x5E\xAE\x96\x97\xB0\x9B\x8F\x2E\xB1\x92\x90\x59\x86\x9D\x98\xC8\x83\x9A\x30\xBD\x94\x98\x65\xBE\x8F\x98\xCE\x93\x97\x2F\xCD\x9C\x99\x65\x93\x9E\x9A\xC1\x8F\x99\x32\xD5\x9A\x9B\x68\x90\x9C\x9B\xD2\x99\x99\x38\xA6\x99\x94\x72\xA4\x90\x95\xE7\x85\x9C\x3A\xBE\x6F\x08\x4A\xAB\x98\x98\xE6\x95\x97\x3B\xD4\x97\x9B\x6E\xA0\x9F\x9B\xF5\x83",
			"\x9F\x3C\xD8\x91\x9E\x78\xBB\x9E\x9E\xF9\x98\x9E\x38\x82\xAD\x9E\x7A\x83\xA3\x9B\x01\xA8\xA3\x41\xDE\x96\x20\x28\x02\x41\x23\x09\x32\x3C\x41\xFF\x9A\x9E\x75\x96\xA1\x9D\x18\xB2\x9F\x45\x9A\xA9\xA2\x7F\x9B\xA6\xA3\x1D\xA6\xA1\x41\xFC\x94\xA3\x89\x9F\xA2\xA4\x25\xAA\xA3\x48\x80\xAB\xA1\x7B\xAA\xA1\xA5\x0C\xB1\xA6\x4B\xB2\xA9\xA0\x9A\xB4\x8F\x0A\x02\x58\x0A\x2E\xB3\xAC\xA7\x9A\xBD\xA5\xA5\x3E\xA1\xA8\x50\xC3\xAB\xA5\x8A\xA1\xA4\xA4\x27\xA8\xAB\x51\xAC\xA5\xA8\x93\x8B\xAE\xA8\x1C\xB1\xA8\x48\xD2\xA8\xA5\xA4\x8C\xA8\xA6\x3F\xAD\xAB\x4B\xD6\xA0\xAB\xA9\x9E\xAD\xAA\x4F\xAE\xA8\x55\xCA\xAE\x66\x2F\x2E\x9C\xAB\x02\xBF\x0A\x80\x60\x05\x91\x30\x02\x42\x0C\x02\x43\x0E\x80\x64\x02\x41\x32\x02\x46\x0C\x02\x47\x0E\x80\x68\x02\x41\x34\x02\x42\x0D\x02\x4B\x0F\x59\xE1\xAB\xAA\xC2\xB6\xA0\x93\x6C\x03\xB2\xCF\x6D\x0A\xB1\xAF\xA4\xAE\xB1\x57\xA8\xAD\x61\xE3\xA1\xB2\xC3\x99\xA8\xAB\x42\xBC\x5E\x1B\x0D\xB0\xAC\xCA\x9D\xAD\xB3\x90\xBF\xB3\x63\xA5\x7F\x0C\xCE\xA3\xB7\xB4\xA8\x30\x0E\x69\xA8\x31\x0E\x01\x72\x0A\x40\x00\x35\x8A\x41\x74",
			"\x02\x41\x3A\x02\x46\x0E\x02\x57\x0E\x80\x78\x02\x41\x3C\x02\x42\x0F\x02\x5B\x0F\x6A\xA2\xB5\xB2\xCF\xA2\xAE\x6A\x7C\x03\xBB\xAA\x7D\x0A\xB9\xC9\xA1\xB7\xB8\xA0\xB1\xB8\x6A\xC4\xB4\xBA\xE8\x93\xBE\xBA\x2C\xBE\x0D\x73\x87\xB8\xB2\xA2\x9D\xBA\xAB\xDC\xA9\x97\x1F\x5B\xB7\xB3\x54\x80\x14\xBC\x01\x21\x12\x80\x02\x12\x41\x41\x02\x44\x10\x02\x45\x12\x80\x06\x12\x41\x43\x02\x40\x11\x02\x49\x12\x80\x0A\x12\x41\x45\x28\xBE\xBB\x92\xA1\xBE\x65\xF3\x8C\x11\xFF\xAD\x45\x11\x06\xDF\xBA\x82\x81\xC5\xBD\x01\xC0\xC6\xC1\xE0\xAD\xC2\x71\xCE\xB5\x74\x47\x09\xC4\xC1\xD5\x4F\x12\x80\x10\x1B\xA7\xCC\x8B\xC0\xC2\x1F\xD3\xC2\x80\xA2\xC2\xC3\xE7\x94\xC7\xBA\x27\xC5\xBA\x89\xA3\xCB\xC5\x12\xD2\xBA\xC5\x2F\xD5\xB9\x8A\xB2\xCC\xC5\x18\xD8\xBC\xC6\x2E\xC8\xC5\x8D\xBA\xC9\xC6\x18\xFC\xC6\xC3\x18\xCF\xC0\x8A\x16\x17\xC2\x10\xC1\xC9\xC2\x40\xC6\xCA\x92\xA4\xC9\xC8\x26\xC2\xCD\xC5\x4D\xD0\xCB\x93\xB6\xC3\xC7\x1B\xD6\xCD\xCA\x58\xDB\xC6\x8F\xDB\xC8\xC7\x28\xD4\xCA\xCB\x5D\xD3\xCB\x8F\xC3\xA7\x13\x22\xCE\xC8\x13\x66\xD2\xC8\x92\xE2\xCC\xCB\x2B",
			"\xE0\xCE\xCD\x3D\xC1\xCF\x9A\xF3\xC1\xC4\x35\xF5\xCF\xCB\x71\xD0\xCE\x97\xE3\xC4\xCF\x23\xF7\xCC\xCF\x7F\xCD\xCD\x96\xF9\xC3\xD1\x6A\x59\x11\xCD\x78\xDB\xCE\xA0\xEF\xC5\xD0\x36\xF2\xC9\xD0\x8F\xDE\xCE\xA4\xCB\xC6\xCF\x49\xCE\xCD\xCF\x94\xC9\xD2\xA3\xFA\xCB\xD3\x58\x5A\x12\x40\x9B\x1D\xC1\xA7\x8C\xD4\xD4\x42\xE5\xD2\xD1\x91\xD9\xD0\xA0\x96\xD5\xD2\x55\xCB\xD6\xD4\xB0\xC8\xD4\xA7\x98\xD7\xD2\x48\xF3\xD6\xD6\x8D\xD4\xD5\xAB\xB5\xDC\xD4\x4D\xE1\x12\x40\xA2\x02\xD6\xAE\x9A\xD3\xD9\x55\xEE\xD1\xD5\xBC\xC7\xDB\xAD\xBD\xD6\xD9\x64\xCE\xDB\xD7\xD0\xC4\xD8\xAE\xA7\xD3\xD5\x58\xD5\xDA\xD6\xB9\xD3\xDA\xB5\xC5\xDF\xD5\x39\xA8\x12\x40\xA9\x02\xDA\xB6\xD8\xD4\xDA\x6E\xC8\xD9\xDA\xCD\xC8\xDD\xB7\xD7\xDC\xDC\x73\xCB\xDA\xD9\xD9\xCC\xDB\xBA\xEE\xD1\xDE\x78\xE5\xDB\xDC\xED\xD8\xDC\xBD\xF7\xD2\xDF\x73\xD2\xDD\xDF\xAB\x4F\x14\xA2\xE9\xD5\x74\x58\x3F\xB9\x16\x02\x52\x16\x80\x33\x12\x40\x5A\x02\x45\x16\x02\x56\x16\x80\x37\x12\x40\x5C\x02\x41\x17\x02\x5A\x16\x80\x3B\x13\xE1\x79\xFA\xDF\xE3\x08\x5C\x15\xC7\x8A\x2D\x17\x91\xEF\xDF\xD9",
			"\xFF\xD6\xDF\xB6\xA0\xEA\xE4\x72\xEB\xE2\x60\xBE\x06\xE5\xA3\xBF\x12\x40\x60\x22\xD8\xE0\xF5\xC8\xE4\xC1\xBB\xEE\xE2\x9C\xFC\xDD\xE5\xF9\xDE\xE7\xCB\xC0\xEB\xDF\xA1\xFA\xE5\xE7\x44\xEC\xE7\xD1\xFE\xDC\xE6\xA6\xC8\xEB\xE9\x27\xEA\xDE\xD3\xD3\xE1\xEA\x83\x86\x1A\xE6\x3F\xF0\xE9\xCE\xD2\xE5\xEB\xA6\xDD\xEF\xE9\x5C\xFB\xE9\xCA\xDA\xE9\xEB\xB0\xE5\xEB\xEC\x66\xE6\xE9\xDA\xAE\xEC\xED\xA0\xC9\xEA\xE8\x6D\xED\x47\x31\x58\xEA\xEC\xB4\xF6\xEE\xEB\x62\xF8\xEF\xD9\xFA\xE5\xEE\xBE\xF1\xEA\xE9\x6B\xEE\xEC\xD9\xFD\xE0\xED\xBB\xC5\xF3\xCC\xC8\x02\x41\x32\x37\xEF\xED\xC6\xC3\xF7\xEF\x70\xE2\xF1\xE0\xC5\xE0\xF2\xC7\xD3\xF0\xF0\x86\xF4\xE9\xDE\x87\xFC\xF2\xCD\xFB\xED\xF3\x5F\xFE\xF0\xE1\xE1\x9F\x18\x01\x50\x1C\xF1\x8F\xF2\xF1\xE6\xA1\xFC\xF5\xCD\xE2\xF5\xF2\xA9\xF4\xF2\xEA\xFE\xE3\xF6\xD0\xEE\xF5\xF5\x9F\xEF\xF5\xED\xBA\xF2\xF7\xDE\xD8\xF0\x9B\xD6\x02\x43\x35\x28\xF7\xF3\xC8\xFE\xF6\xF8\xBF\xF6\xF5\xEE\xB8\xF3\xF4\xE6\xF0\xF5\xF8\x96\xEB\xF7\xED\xD3\xFB\xF8\xEA\xCD\xFE\xFA\xCF\xF2\xF9\xF5\xCD\x5D\x1A\x01\x5E\x1C\xF8\xDA\xF7\xFB",
			"\xF6\xE2\xF4\xFD\xEC\xF4\xF7\xF8\xD1\xE7\xFD\xF2\xBC\xFB\xFC\xE7\xFB\xF6\xFD\xE8\xF1\xF5\xFB\xD8\xFF\xFC\xFA\xD8\x94\x1C\x02\x45\x1C\xF8\xEA\xF8\xF9\xFE\xE9\xFA\xF9\xE5\x75\x7F\xE3\x76\x7E\x00\x84\x80\xEC\x7E\x7F\xF2\x78\x80\xD0\x79\x80\xFF\x77\x80\x0D\x80\x7F\xF3\x73\x80\x02\x81\x80\xF1\x7B\x80\x16\x81\x7E\x06\x80\x81\x0A\x88\x81\x13\x89\x81\xF6\x71\x81\x14\x80\x82\x1E\x82\x81\x15\x8C\x81\x98\x4B\x0E\x74\x7D\x76\xEC\x02\x20\xED\x0B\x7F\x05\x8D\x81\x30\x85\x82\xFC\x7F\x80\x1F\x8B\x81\x33\x8C\x80\x38\x87\x81\x37\x8A\x83\x2F\x82\x83\x3D\x82\x82\x31\x80\x84\x3E\x81\x4E\xF3\x02\x20\xF4\x0E\x82\x0E\x89\x83\x26\x82\x84\x4C\x86\x83\x3F\x8E\x84\x49\x8C\x83\x51\x8B\x84\x50\x8A\x81\x34\x84\x82\x4D\x87\x85\x21\x85\x85\x35\x8A\x85\x23\x8B\x85\x11\x3A\x0F\x29\x84\x47\xFB\x0F\x5F\x21\x12\x5B\x1D\x4D\x0F\x02\x2E\x0F\x05\x22\x20\x00\x03\x13\xE1\x10\x87\x0A\x12\x00\x72\x89\x10\x03\x05\x87\x06\x14\x00\x78\x83\x10\x05\x0B\x87\x02\x16\x00\x7E\x81\x10\x07\x01\x88\x41\x8C\x85\x58\x82\x30\x08\x04\x88\x98\x49\x00\x8A\x89\x85\x4A\x8B",
			"\x83\x54\x8E\x85\x85\x82\x89\x43\x8B\x15\x8D\x86\x88\x60\x8F\x88\x4F\x84\x89\xDD\x53\x12\x68\x89\x89\x52\x86\x85\x9A\x83\x85\x90\x85\x8A\x9B\x83\x8A\xA2\x81\x8A\x5D\x88\x8A\xAB\x8A\x8A\x87\x8E\x60\x0C\x04\x88\x0D\x03\x13\x12\x5D\x8A\x91\x8C\x8A\xAF\x88\x8B\xA0\x87\x8B\xAE\x8B\x8B\xA6\x84\x8A\xA7\x8D\x8B\x5F\x83\x8C\x93\x8A\x8B\xC4\x85\x89\xB6\x8F\x8B\xAB\x23\x01\x84\x86\x12\x11\x50\x8C\xD0\x89\x8A\xBC\x83\x8D\xCA\x89\x8C\xC1\x84\x8D\xD7\x85\x8D\xB9\x82\x8C\xC5\x8C\x8D\xC8\x8B\x8D\xD8\x81\x8D\xD6\x81\x4E\x1A\x04\x88\x1B\x04\x8B\xE2\x80\x8E\xDA\x8E\x8B\xD9\x8D\x8E\xE9\x8C\x8E\xEF\x87\x8C\x8E\x8E\x8D\xF3\x81\x8E\xD2\x8B\x8E\xF2\x88\x89\xF9\x8C\x89\xFA\x8D\x8D\xF6\x83\x8E\x9C\x61\x02\x97\x8C\x8F\x04\x96\x8C\xFE\x88\x8F\x07\x9E\x8E\xF7\x8A\x90\x00\x9D\x90\xEA\x8C\x90\x0F\x91\x8F\x30\x82\x02\x03\x96\x90\xDF\x80\x8F\x0B\x92\x91\x17\x9B\x8F\x16\x95\x8F\x08\x9B\x91\x09\x9A\x91\x1E\x90\x91\x18\x9E\x90\x25\x91\x91\x19\x99\x92\x8D\x63\x02\x15\x94\x8F\xFD\x80\x92\x30\x93\x92\x22\x9F\x92\x32\x9A\x92\x28\x96\x92\x1C\x9E\x92",
			"\x05\x9A\x93\x1D\x94\x93\x3E\x92\x89\x24\x0D\x92\xFF\x87\x93\x44\x97\x92\x46\x99\x93\x43\x97\x94\x21\x96\x93\x4A\x91\x93\x3F\x9D\x93\x3B\x99\x94\x48\x9F\x91\x35\x98\x93\x43\x55\x02\x42\x94\x95\x4F\x9C\x93\x5C\x92\x95\x4B\x96\x95\x4E\x91\x95\x5A\x92\x96\x24\x93\x95\x65\x9F\x95\x36\x56\x02\x59\x97\x96\x61\x90\x95\x6E\x9D\x95\x63\x9F\x96\x5E\x9D\x96\x70\x9C\x96\x55\x95\x94\x66\x93\x93\x64\x9A\x97\x72\x91\x97\x75\x9C\x97\x7F\x93\x3B\x27\x0B\x96\x80\x93\x97\x77\x9D\x94\x87\x99\x97\x4C\x9A\x98\x60\x99\x98\x68\x98\x98\x5B\x96\x98\x02\x38\x02\x84\x89\x12\xCF\x8B\x98\x8F\x9C\x98\x78\x99\x99\x9C\x94\x97\x92\x9B\x97\x98\x9E\x99\x7E\x9F\x99\x7D\x96\x97\x91\x93\x9A\xA8\x96\x9A\xA0\x9D\x98\xA7\x9A\x9A\x28\x2C\x12\x9F\x8A\x99\x90\x9B\x9A\x9B\x92\x9A\xAE\x91\x98\xAC\x94\x9B\xB3\x95\x9A\x85\x99\x9A\xBD\x97\x9B\xA4\x90\x4C\x30\x04\x98\xA1\x99\x1D\x31\x04\x9C\xB1\x22\x03\x84\x83\x03\x84\x84\x03\x84\x8F\x12\xB1\x90\x00\x36\x04\x88\x37\x04\x88\x38\x04\x88\x39\x04\x88\x3A\x04\x88\x32\x11\x9D\x3C\x08\x9C\xB5\x9E\x98\x6B\x6D\x03\xE0",
			"\x9A\x46\x3E\x05\x9E\xB2\x99\x9E\x9D\x92\x9E\xEC\x9D\x9A\x61\x6F\x03\xE8\x9B\x9E\xA9\x40\x04\x84\x85\x13\xD1\x96\x9B\xBF\x9A\x10\x42\x01\x9F\x98\x43\x04\xF1\x94\x04\xF1\x95\x04\xFC\x9D\x9E\xBA\x92\x54\x46\x04\x88\x47\x04\x88\x48\x04\x88\x37\x11\x9D\x4A\x04\x88\x4B\x01\x9F\x4C\x04\x88\x4D\x03\x13\x99\x18\x49\x39\x11\x9D\x50\x04\x88\x51\x04\x88\x3B\x11\x9D\x53\x03\xA0\x08\x24\x05\x84\x85\x05\x22\xA5\xA0\xF2\x98\xA2\x98\x46\x05\x84\x87\x05\x27\xAC\x9B\xB3\x3D\x13\xF7\x9F\x48\x59\x04\x88\x5A\x04\x88\x5B\x04\x88\x5C\x04\x88\x5D\x04\x88\x5E\x04\x88\x5F\x0F\xA2\xB8\x91\x9E\xEE\x95\x9C\x45\xA9\x9B\x30\xA8\xA4\x43\xAB\x9B\x4B\xAA\x9E\xF8\x96\xA4\x2A\xA4\xA0\x49\xAB\x99\x3F\x13\xA3\x47\xA4\xA4\x92\x81\x06\x42\xA1\x9C\x5C\xAE\x9B\x50\xA3\xA5\x4C\xAD\xA5\xC0\x9E\xA5\x4A\xA2\xA6\xF9\x9F\xA5\x4D\xA9\xA2\x28\x22\x06\x84\x83\x06\x5B\xA4\xA6\x9B\x91\x14\x56\xAE\x60\x65\x01\x9F\x66\x01\x9F\x67\x0F\xA6\x63\xAB\xA7\x99\x38\x06\x84\x85\x1A\xD1\x9A\x06\x84\x8B\x06\x84\x8C\x06\x84\x8D\x06\xF1\x9E\x06\x84\x8F\x06\x16\xA1\x4E\x71\x04",
			"\x88\x45\x11\x9D\x73\x04\x88\x74\x04\x88\x75\x0A\xA7\x0A\x16\x07\x84\x87\x07\x98\xA8\xA6\x66\xAE\xA9\xD8\x48\x07\x84\x89\x07\x9D\xA5\xA6\x9B\x3A\x07\xA5\xAD\x2C\x7B\x04\x88\x7C\x04\x88\x7D\x04\x88\x7E\x04\x88\x7F\x04\x88\x80\x04\x88\x81\x09\xAA\x02\x12\x08\xB8\xAE\xA4\x52\xA9\xA6\x4F\xA6\xAA\x7C\xA0\xAA\xC1\xA0\xAC\x67\xA4\xAC\xC2\xA5\xAC\x58\xA0\xA6\xBC\xA7\xA5\x61\xA0\xA7\xCD\xA3\xAC\xC9\xAE\xAB\xBD\xAF\xA9\xC6\xA5\xAD\xD1\xA4\xAD\xD7\xAE\xAC\xCB\xA8\xA2\x83\x0B\xAB\x6A\xA2\xAD\xCC\xAB\xAD\xCA\xAF\xAD\xD8\xAF\xAC\xC8\xA6\xAE\xC7\xA9\xAE\xD6\xA8\xAE\xEB\xA2\xAE\xE0\xA1\xA5\xA9\x44\x08\x84\x85\x08\xDE\xAF\xAB\x12\x86\x08\xF5\xA9\x2F\x47\x13\xA7\x28\x28\x08\xF1\x99\x08\xF9\xA1\xAE\xE4\xA8\x4D\x8A\x04\x88\x8B\x04\x88\x8C\x04\x88\x8D\x04\x88\x8E\x04\x88\x8F\x01\x9F\x90\x04\x88\x91\x0D\xA8\x02\x59\x14\xD1\x94\x09\x84\x85\x09\x84\x86\x09\x84\x87\x09\xDE\xAB\x14\xD1\x99\x09\x01\xB0\xAF\x24\xB3\xAE\x2D\x2A\x09\x84\x8B\x09\x23\xB6\xB2\xD9\x1C\x09\x2B\xB8\x24\x9D\x04\x88\x9E\x04\x88\x9F\x04\x88\xA0\x04\x88\xA1\x04\x88",
			"\xA2\x04\x88\xA3\x0E\xAD\xA4\x0F\xB2\xE5\xAE\xAE\x41\xB3\xB0\xD0\xAC\xAE\xD9\xA5\xB4\x42\xBA\xAD\x44\xB7\xAE\x49\xB8\xB4\x4B\xBA\xAE\x47\xBC\xB4\x9C\x95\x0A\x40\xBA\xB4\xF6\xA6\xB4\x58\xBD\xB4\x52\xB7\xB5\x5A\xB0\xB5\x59\xBF\xB4\xED\xA0\xB6\x51\xBE\xB5\x5D\xB1\xB6\x5C\xB2\xB6\x5F\xB7\xB6\x20\x9D\x14\xFC\xA9\xA6\xA7\x05\xB5\x4E\xBA\xB6\xD3\xA6\xB5\x73\xB3\x2A\xA8\x00\xB7\x0A\x1F\x14\x6D\xBC\x81\xAA\x08\xB7\x64\xB8\xB6\x65\xB3\xB6\x66\xB5\xB7\x5B\xB4\xB8\x7F\xB2\xB7\x02\xB8\xB8\x25\xBF\xAE\x2C\xB9\xB8\x86\xB3\xB8\x8E\xB1\xB9\x8B\xB3\xB4\x8A\xBD\xB8\x93\xB4\xB7\x92\xB6\xB9\x9A\xBC\xB8\x9C\xBC\x81\xAB\x0E\xB7\x8D\x6C\x0A\xA0\xB2\xB8\xA4\xB9\xB6\x8F\xB5\xBA\x81\xB6\xBA\x99\xBD\xB9\x98\xB7\xB9\x71\xB7\xBA\xAA\xBE\xBA\x85\xBB\xBA\x94\xB0\x84\xAD\x03\xBA\xB1\xBB\xB9\xB5\xB4\xBB\xAD\xBA\xBB\xBD\xBC\xBA\xAF\xBC\xBB\xC1\xB2\xBB\x87\xB0\xBB\xA9\xB7\xBC\x00\x0E\x0A\xF1\x9F\x0A\xB8\xB8\xBC\x95\xB0\xBC\xB3\xB4\xBC\x90\xB2\xBD\xA8\xB0\xB8\xD6\xBF\xBC\xBB\xB4\xBD\xB9\xB0\xBD\xC5\xB2\xBC\xD1\xBE\xBB\xC3\xB0\xBE\xDF\xBC\xBD\xD3",
			"\xB2\xBE\xDD\xB1\x31\xB0\x0D\xBC\xD7\xB6\xBC\xEB\xBE\xBD\x09\x11\x0B\xEA\xB8\xBD\xBF\xB9\xBD\xE6\xB5\xBE\xE4\xB5\xBD\xF2\xB1\xBE\xF7\xBB\xBD\x5E\x92\x0B\xF1\xBC\xBE\xF9\xB3\xBE\xF4\xBB\xBF\xCE\xB0\xC0\x06\xCE\xBE\xF6\xB3\xC0\x0A\xC3\xBF\x0C\xCA\xBF\x0B\xCE\xC0\x0D\xC2\xB5\xB3\x0F\xBF\x08\xC8\xBF\x07\xCA\xBD\x05\xC5\xC1\xFC\xB1\xC1\xE7\xB5\xBF\x16\xC1\x64\x51\x11\x9D\xB5\x04\xC1\x18\xC3\x54\xB6\x04\xC2\x28\x27\x0B\xF1\x98\x0B\xF1\x99\x0B\x28\xC4\xC0\xD6\xBA\x0B\x84\x8B\x0B\x84\x8C\x0B\x84\x8D\x0B\x84\x8E\x0B\x84\x8F\x0B\xF1\x90\x0C\x84\x81\x0C\x14\xBA\x50\xC3\x04\x88\xC4\x04\x88\xC5\x04\x88\xC6\x04\x88\xC7\x0E\xAD\x53\x11\x9D\xC9\x0F\xC2\x0F\xC2\xC0\x08\x9A\x0C\x84\x8B\x0C\x50\xCA\xB4\xCC\x0A\xBE\xCD\x04\x88\xCE\x04\x88\xCF\x04\x88\xD0\x04\x88\xD1\x04\x88\xD2\x04\x88\xD3\x0E\xAD\xD4\x07\xC5\x10\xCB\xC6\x52\xCC\xC6\x1D\xC0\xC3\x01\xCF\xC6\x51\xC2\xC7\x1C\xC9\xC0\x75\xCF\xC1\x25\xC1\xC7\x76\xCE\xC6\xBF\x35\x0D\x6A\xCD\xC6\x80\xC4\xC7\x7C\xC8\xC7\x1E\xCB\xC1\x83\xC6\xC8\x81\xCB\xC7\x89\xC4\xC8\x70\xC9\x1D\xD6\x0F",
			"\xC7\x82\xCB\xC8\x88\xC1\xC9\x94\xCA\xC8\x95\xCC\xC8\x73\xC6\xC9\x9A\xC8\xC9\x77\xC2\x2D\xD7\x00\xC9\x8D\x68\x0D\xDE\xA9\x0D\x84\x8A\x0D\x84\x8B\x0D\x84\x8C\x0D\x84\x8D\x0D\x84\x8E\x0D\x84\x8F\x0D\x84\x80\x0E\x84\x81\x0E\x84\x82\x0E\x84\x83\x0E\xA0\xCC\xC9\x67\x94\x0E\xEA\xB5\x0E\xB9\xC3\xC9\x9B\xC0\xCC\xBA\xC2\xC9\x01\x16\x0E\xBF\xCA\x9E\xE7\x04\x88\xE8\x07\xCC\xED\xB0\x4A\xE9\x0C\xCC\xEA\x01\x9F\xEB\x01\x9F\xEC\x0C\xCC\x7A\xCB\x99\xED\x04\x88\xEE\x04\x88\xEF\x04\x88\x55\x11\x9D\xF1\x04\x88\xF2\x01\x9F\xF3\x04\x88\xF4\x01\xC4\x36\x56\x0F\x84\x87\x0F\x84\x88\x0F\x84\x87\x15\xD1\x9A\x0F\xDE\xAB\x0F\x84\x8C\x0F\xD6\xC7\xC1\x85\xCD\x76\xFD\x04\x88\xFE\x07\xCF\x2F\x9A\xBE\x00\x0C\x16\xE1\x12\xD0\x73\x84\xD0\x76\x86\xD0\x79\x88\xD0\x7C\x8A\xD0\x7F\x8C\xD0\x73\x47\x00\x0E\xDD\xCC\xF9\xC2\xD1\x8D\xCA\xC1\x19\xC9\xC7\xF8\xC5\xD1\x18\xD6\xD1\x14\xD9\xC9\xC3\xC7\xC9\xC2\xC1\xD2\x17\xD6\x90\x08\x01\xD1\xD7\xC2\xD2\x1D\xDD\xC9\x23\xDA\xD1\x13\xD7\xD2\x2B\xDE\xD1\x28\xDE\xD2\x29\xD7\xC8\x2F\xDA\xD2\x33\xD4\xCC\x37\xD0\xD2",
			"\x35\xD4\xD3\x39\xD1\x2B\x09\x06\xD2\x19\xD0\xD3\x3B\xD8\xD3\x32\xD5\xD4\xF9\x2C\x15\x7B\xB6\xD3\x46\xDC\xD1\x4B\xDB\xD1\x4E\xDD\xD2\x41\xDA\xD4\x51\xDE\xB4\x0B\x00\xD4\x4C\xD3\xD5\x44\xD8\xD5\x3A\xDD\xD3\x1F\xD1\xCC\x43\xDB\xD5\x4D\xD0\xD5\x57\xD3\xD6\x4F\xDC\xD2\x81\x7C\x00\x56\xDE\x60\x0D\x09\xD6\x28\x2E\x00\x6C\xD8\x24\x0F\x0F\xD6\x42\xDC\xD5\x3F\x50\x01\x11\xD1\x01\x11\xD2\x01\x11\xDF\x15\xD1\x94\x01\x72\xD9\x27\x15\x01\xD1\x16\x0C\x16\x17\xAD\x5D\x18\x01\xD1\x19\x01\xD1\x62\x11\x9D\x1B\x0F\xD7\xA3\x2C\x01\x11\xDD\x01\x8E\xD9\xD5\x64\xD3\xAE\x1E\x01\xD1\x1F\x03\xD9\x60\xD9\x1D\x66\x19\xD4\xC3\x31\x02\x11\xD2\x02\x11\xD3\x02\x11\xDB\x16\xD1\x95\x02\x11\xD6\x02\x11\xD7\x02\x9A\xDE\xD5\x74\xDF\xD5\xAE\xD1\xD6\x66\xD3\xD7\xB2\xD4\xDB\x5A\xD1\xDB\xB7\xDD\xD5\xBA\xD1\xD3\xB9\xDC\xDB\x95\xD3\xDB\x52\xDF\xDB\xB6\xD2\xDC\xC1\xD5\xD6\xC3\xD6\xDC\x36\xD8\x02\xAD\xDB\x99\x29\x01\xD1\x2A\x0C\x16\x31\x2B\xD9\xC4\xDC\xD3\xB5\xD5\xDC\x62\xD8\xDC\xD4\xDD\xDB\xB0\xDB\xDB\xDB\xDE\xDB\xD8\xDA\x44\x11\xD9\x03\xCB\xDE\xDD\xA9",
			"\x7A\x03\xE3\xD2\x54\x3B\x07\xDE\x6D\x1A\xDE\x3D\x0A\xDE\xD5\xDC\xD3\x3E\x01\xD1\x3F\x01\xD1\x40\x01\xD1\x41\x01\xD1\x42\x01\xD1\x43\x0A\xDE\x44\x01\xD1\x70\x19\x10\x85\xD9\x4A\x47\x01\xD1\x48\x01\xD1\x49\x01\xD1\x4A\x01\xD1\x4B\x0E\xDE\xD9\x1C\x04\x11\xDD\x04\x0C\xE3\xDD\x94\xD2\x89\x72\x11\x9D\x4F\x01\xE1\xDF\xD9\x10\x50\x08\xE1\x3E\x31\x05\x11\xD2\x05\x11\xD3\x05\x11\xD4\x05\x11\xD5\x05\x11\xD6\x05\x11\xD7\x05\x1C\xE8\x24\x58\x01\xD1\x59\x00\xDD\x13\xE7\xDD\x32\xE0\xDC\xD9\xD2\xE1\xD2\xD9\xE1\xB8\xD6\xE3\x39\xE8\xE3\xDC\xDF\xDA\x3E\xEF\xDE\x12\x99\x17\x9E\xD1\xE3\x34\xE4\xE4\xC7\xD3\xE3\x47\xE5\xE4\x37\xE8\xE4\xD6\xDA\xE4\xBF\x38\x06\x11\xD9\x06\x2B\xE9\xE4\x1C\x8A\x06\x53\xE8\x4D\x6B\x0A\xDE\x6C\x0A\xDE\x6D\x07\xE5\x35\xE5\xC2\x6E\x01\xD1\x6F\x01\xD1\x70\x01\xD1\x71\x01\xD1\x72\x01\xD1\x73\x0A\xDE\x7B\x11\x9D\x75\x04\xD8\xE1\x47\x07\x11\xDE\x17\xD1\x99\x07\x11\xDA\x07\x11\xDB\x07\x5E\xEA\x10\x7C\x01\xD1\x7D\x0B\xE7\x4B\xEE\xE4\x12\x8E\x07\x11\xDF\x07\x80\xEE\xDA\x80\x07\xE8\xCD\x21\x08\x11\xD2\x08\x11\xD3",
			"\x08\x11\xD4\x08\x11\xD5\x08\x11\xD6\x08\x11\xD7\x08\x8A\xEF\x53\x88\x01\xD1\x89\x09\xE9\xDD\xDD\x76\x8A\x0E\xE9\x74\x4B\x08\xEA\xDC\x08\xEA\xDD\x08\xA2\xE0\xE4\x7F\xBE\x08\x11\xDF\x08\x11\xD0\x09\x11\xD1\x09\x11\xD2\x09\x11\xD3\x09\xEA\xD1\x18\xD1\x95\x09\x70\xE2\x50\x84\x11\x9D\x98\x01\xD1\x99\x01\xD1\x9A\x01\xD1\x9B\x02\xEA\x9C\x01\xD1\x9D\x09\xEA\xDA\xDF\xE3\xF8\x66\x18\xD1\x9F\x09\xCA\xEC\xD1\xA0\x01\xED\x18\x21\x0A\x11\xD2\x0A\x11\xD3\x0A\x11\xD4\x0A\x11\xD5\x0A\x11\xD6\x0A\x11\xD7\x0A\xA2\xE8\x18\xD1\x99\x0A\x30\xE1\xE8\x54\xED\xE4\xE9\xEF\xE5\x4C\xEC\xEE\x82\xE4\xDE\xEF\xEF\xE9\xCC\xEA\xE3\x3D\xEA\xEA\x3B\xED\xEE\x9D\x27\x0B\xD4\xE8\xEF\xE8\xEA\xEE\xFE\xEE\xEE\xEB\xE6\xE4\xFF\xE2\xF0\x00\xF3\xF0\xFD\xEB\x6E\xB8\x0B\xEF\xF1\xE3\xEF\x3C\xE0\xEF\x01\xF7\xF0\x04\xF1\xF1\x10\xF3\xF1\xF7\xEB\xF0\xF6\xEB\x99\xB9\x0A\xF0\x0F\xF5\xF1\x1B\xF5\xEF\xCB\xE7\xF1\x0E\xF6\xF0\x1C\xF2\xF2\x36\x5A\x0B\x11\xDB\x0B\x1A\xF4\xF2\x3F\x5C\x0B\x29\xF3\x2A\x8C\x13\xE4\x09\x1E\x0B\xEA\xDF\x0B\x2D\xF2\xF1\x56\x90\x0C\x11\xD1\x0C",
			"\x11\xD2\x0C\x11\xD3\x0C\x11\xD0\x19\xD1\x95\x0C\xEA\xD6\x0C\x11\xD7\x0C\xBB\xEA\x50\xC9\x01\xD1\xCA\x01\xD1\xCB\x01\xD1\xCC\x01\xD1\xCD\x02\xEA\xCE\x01\xD1\xCF\x05\xF3\x14\xFE\xF1\x41\x60\x0D\x11\xD1\x0D\x56\xF1\xB6\xD2\x0D\xF5\x03\x13\x0D\x11\xD4\x0D\x11\xD5\x0D\x11\xD6\x0D\x11\xD7\x0D\x11\xD8\x0D\x11\xD9\x0D\x60\xFA\x46\xDA\x01\xD1\xDB\x0F\xF6\xF2\xE8\x49\xDC\x04\xF7\xD6\x2D\x0D\xEA\xDE\x0D\xEA\xD2\x19\x30\xF3\xF2\x3C\xD0\x0E\x11\xD1\x0E\x11\xD2\x0E\x11\xD3\x0E\x11\xD4\x0E\x11\xD5\x0E\xEA\xD6\x0E\x11\xD7\x0E\x47\xF6\x53\x94\x11\x9D\xEA\x01\xD1\xEB\x01\xD1\xEC\x01\xD1\xED\x02\xEA\xEE\x01\xD1\xEF\x08\xF7\x20\xF5\xF7\xDD\x50\x0F\x11\xD1\x0F\xA0\xFE\x98\xF2\x08\xF7\xF3\x01\xD1\xF4\x01\xD1\xF5\x01\xD1\xF6\x01\xD1\xF7\x01\xD1\x96\x11\x9D\xF9\x02\xEA\xFA\x01\xD1\xFB\x07\xEE\x80\xF6\xF3\x58\xFD\xF0\xA2\xF4\xEF\x21\xF5\xF0\xC4\xFE\xFB\xC3\xF6\xFC\xC1\xF0\xFC\x0C\xFC\xEF\x8D\x69\x00\xE9\x10\x1E\xC8\xFB\xFC\x16\xFF\xF1\xD4\xF2\xFC\xC9\xFC\xFC\xBF\xF8\xFD\xC7\xF7\xF5\xD6\x6A\x00\xCF\xFF\x86\xD1\xF1\xFA\xD2\xFD\xF1\xDB",
			"\xFD\xFB\xDC\xF7\xFD\xD3\xF6\xFD\xE3\xFA\xF2\xE8\xF4\xFE\x00\x2F\xFD\x16\x4A\xFE\xE2\xF3\xFF\xD5\xFA\xFC\xF4\xF2\xFF\xF5\xFA\xFD\xC8\xBC\x00\xF0\xFA\x10\x0D\x0F\xFD\xD1\x6E\xFC\x42\x81\xEC\x79\xFE\x76\x7D\xFE\x65\x80\xFA\x7B\xFD\x45\x7F\xF3\x7A\x00\xE1\x7F\x01\x8E\x7F\x0D\x84\x01\xB7\x7E\x03\x88\xFF\x15\x80\x05\x97\x80\x09\x82\xFC\x5B\x01\xFE\x72\x01\x8F\x80\xFB\x74\x23\x1C\x04\x03\x83\x81\xF2\x74\x00\x9A\x35\x07\x02\x81\x25\x87\x03\x93\x81\x0C\x8E\x01\x8B\x83\x08\x8D\x7F\x2A\x85\x05\x8E\x80\x0B\x8C\x02\xB4\x80\x02\x97\x81\x10\x83\x05\xB8\x81\x3C\x1E\x01\x28\x80\x09\x9F\x81\x30\x83\x78\x1F\x00\x1F\x81\x04\xB3\x80\x06\x80\x26\x20\x04\x08\x91\x81\x17\x8B\x04\xA9\x82\x0B\x8E\x82\x46\x87\x95\x21\x00\x25\x82\x02\x4A\x82\x0E\x9C\x40\x23\x06\x0A\x9D\x2E\x12\x0A\x05\x88\x11\x09\x1D\x82\x18\x16\x04\x20\x83\x1A\x8A\xFC\x27\x02\x12\x88\x01\x4A\x81\x05\x0A\x82\x15\x0A\x04\xAB\x02\x12\x8C\x01\x63\x80\x49\x2D\x00\x25\x8E\x02\x5F\x7D\x80\x60\x25\x30\x02\x09\xB1\x00\x25\x82\x03\x4A\x83\x0C\x0A\x82\x34\x01\x0E\xA5\x1D\x1A\x0A",
			"\x04\xB6\x02\x20\x91\x81\x36\x86\x2B\x77\x00\x25\x88\x03\x07\x87\x13\x82\x08\x39\x06\x11\x99\x1C\x1D\x0A\x04\xBB\x02\x12\x9C\x01\x4A\x85\x07\x0A\x82\x1F\x0A\x04\xBF\x02\x12\x80\x02\x92\x83\x55\x01\x02\x25\x82\x04\x00\x81\x14\x9B\x81\x8F\x85\x08\x9D\x81\x44\x88\x08\xC7\x81\x0E\x92\x81\xAB\x86\x15\xAD\x84\x32\x84\x0B\xE9\x50\x14\x01\x85\x4C\x87\x0A\xB3\x84\x54\x87\x0A\xAF\x84\x2B\x89\x85\x4D\x80\x08\x81\x86\x55\x8D\x68\x51\x00\x2E\x90\x82\xB1\x85\x16\xBE\x84\x59\x80\x0C\xBA\x85\x33\x90\x85\x56\x4A\x0A\x0A\x83\x29\x07\x0C\xC2\x87\x9A\x34\x02\xD5\x82\xA8\x15\x03\x6C\x80\x00\x56\x00\x37\x97\x02\x4A\x80\x0B\x1C\x86\x67\x82\x91\x59\x02\x12\x9A\x02\x4A\x83\x0B\x0A\x82\x2E\x0A\x04\xDD\x02\x12\x9E\x02\xDC\x87\x0B\x0A\x82\x30\x06\x07\xE1\x26\x18\x0A\x82\x63\x02\x09\xA4\x02\x25\x85\x06\x4A\x82\x19\x03\x87\xD9\x0F\x0C\x0A\x82\x34\x00\x10\xBF\x85\x2F\x83\x33\x69\x02\x09\xAA\x03\x82\x8A\xFC\x6B\x00\x43\x9E\x19\x6C\x02\x09\xAD\x02\x25\x8E\x06\x4A\x83\x1B\x0A\x82\x70\x02\x09\xB1\x02\x25\x82\x07\x0F\x8A\x94\x33\x03\x4A\x84\x0E",
			"\x1E\x89\x65\x8E\x64\x75\x03\x48\x98\x26\x76\x04\x1B\xB7\x02\x6E\x88\x07\x27\x8B\x33\x82\x58\x79\x02\x09\xBA\x02\x25\x8B\x07\x4A\x80\x1F\x0A\x82\x7D\x02\x09\xBE\x02\x6E\x8F\x07\x4A\x80\x20\x15\x87\x02\x2A\x10\x0A\x83\x41\x0A\x04\x84\x06\x12\x85\x04\x4A\x86\x10\x2E\x88\x85\x07\x08\x4A\x80\x22\x0B\x8A\xC9\x84\x17\x82\x29\x44\x0A\x04\x8A\x04\x54\x8E\x6D\x8B\x07\x2A\x8D\x16\x46\x0A\x04\x8D\x06\x12\x8E\x04\x4A\x87\x11\x0A\x82\x48\x0A\x04\x91\x06\x12\x92\x04\x5A\x8A\x20\x13\x04\x25\x84\x09\x26\x85\x54\x84\x89\x52\x89\x17\x90\x86\x64\x82\x17\x86\x8B\x5B\x9B\x85\x70\x89\x2F\xB8\x8B\xBD\x8E\xB4\x22\x05\x5A\x8D\x3B\xA3\x07\x2F\x83\x87\xC1\x84\x0E\xF7\x8B\x4B\x8C\x86\x07\x8F\x30\x8A\x86\xBE\x89\x18\xD2\x58\x29\x02\x8C\xA5\x02\x30\xA6\x04\xC1\x85\x18\xCC\x83\x29\x00\x8A\x8D\x31\x15\x14\x8C\x20\x4A\x0A\x1B\x8C\x82\x0B\x05\x9E\x88\x31\x89\x08\x56\x0A\x04\xAD\x06\x12\x8E\x05\x4A\x87\x15\x0A\x82\x58\x08\x19\x83\x0A\x2C\x0A\x82\xB3\x07\xFB\x5F\x7E\x00\x06\x0B\x2D\x8E\xB4\x18\x05\xA1\x8B\xA2\x79\x05\xDC\x81\x17\xF4\x8A\x6F\x9F",
			"\x5A\xBA\x02\x30\xBB\x04\xC1\x8C\x0B\x3C\x8E\x5E\x80\x86\xBD\x06\x36\xAD\x3B\x5F\x06\x1C\x88\x48\x30\x0D\x8E\xA8\x09\x18\x10\x8F\xE8\x72\x0C\x4A\x83\x30\x0A\x82\xC4\x02\x09\x85\x06\x25\x86\x0C\x4A\x8C\x00\x08\x06\x4A\x81\x19\x32\x8C\x85\x0C\x0C\x5E\x8D\x8B\x0E\x06\xD3\x8F\x6F\x4F\x07\xF4\x81\xB6\x50\x06\x12\x91\x06\x6E\x8D\x2E\xA2\x8C\xF9\x8B\x18\x8A\x8D\x6F\x96\x86\x73\x88\x3F\xB6\x8A\xFA\x87\x1F\xD5\x17\x37\x0A\x82\xE0\x01\x3E\xBF\x8C\x62\x83\x20\x84\x8D\x7E\x84\x90\xFA\x8B\x3E\x85\x91\xCA\x8B\x20\x87\x90\x67\x4E\x07\x4A\x87\x1D\x2C\x8F\x06\x92\x30\x70\x07\x84\x92\x16\xF1\x04\x1B\xB2\x06\x6E\x83\x0F\x17\x90\x82\x8A\x4F\xF4\x02\x09\xB5\x06\x25\x86\x0F\x4A\x83\x3D\x0A\x82\xF8\x02\x09\xB9\x06\x6E\x8A\x0F\x4A\x83\x3E\x06\x8F\x8F\x25\x1F\x0A\x82\x7F\x06\x05\xCA\x80\x00\x0C\x0F\x06\x09\x3C\x38\x90\xF5\x09\x39\x02\x03\x8E\x82\x08\xE8\x0F\x47\x90\x7E\xC3\x8D\x18\x9C\x34\x01\x02\x92\xE0\x79\x21\x05\x00\x24\x91\xFF\x0A\x93\x1F\x4C\x92\xE1\x27\x00\x10\x93\x84\x08\x00\x53\x92\x41\x09\x00\x56\x93\x20\x0A\x01\x2C\x92\x10",
			"\x0B\x00\x97\x81\x08\x0C\x07\x4B\xA9\x10\x31\x92\x7B\x0E\x02\x98\x8F\x00\x64\x96\x41\xAB\x32\x08\x09\x26\xC1\x31\x04\x0D\x93\x18\x12\x02\x30\x92\x14\x13\x01\x73\x91\x7F\x9E\x71\x14\x02\x4C\x95\x00\x31\x96\x01\x62\x93\x05\x02\x93\x18\x02\x4C\x99\x00\x3B\x9D\x25\x1A\x02\x98\x9B\x00\x48\x97\x0E\xAF\x25\x0E\x02\x26\x9E\x02\x98\x9F\x00\x62\x90\x04\x22\x93\x10\x04\x28\x9B\x1E\x08\x02\x93\x23\x05\x52\xB6\x8F\xE3\x81\x66\x24\x02\x98\x85\x01\x9A\x91\xFA\x66\x01\x50\x92\x98\x62\x90\x0A\x02\x93\x29\x02\x4C\xAA\x00\x31\x9B\x02\x62\x90\x0B\x02\x93\x2D\x04\x54\xB1\x14\x17\x02\x26\xAF\x00\x92\x81\x80\x14\x96\x49\x9F\x90\x03\x9B\x1F\xB9\x95\x7D\x85\x92\xFC\x8C\x53\x84\x93\x61\x96\x10\x3D\x02\x98\x9E\x01\xB7\x90\x58\xBE\x95\x3B\x9C\x20\x89\x93\xAF\x84\x96\xCB\x92\x58\x81\x96\xC6\x80\x2D\xCE\x94\xB3\x98\x37\x4C\x02\x56\x9D\x21\x26\x0A\x2D\xD6\x96\xB4\x91\x96\xD4\x93\x5A\x9B\x95\x70\x90\x2E\xE3\x96\xB9\x8A\x96\xD2\x16\x09\x1D\x97\x5D\x9D\x2C\xEC\x96\x9A\x8F\x97\xBD\x96\x5B\xA4\x96\x79\x90\x0C\xCF\x02\x98\x90\x02\xEB\x94\x57\x8E",
			"\x31\x28\x09\x2F\x98\x26\x14\x19\x97\x53\x01\x5F\x94\x03\x7E\x90\x2F\xA8\x51\x15\x02\x93\x56\x02\x4C\x97\x02\x31\x98\x05\x62\x91\x16\x02\x93\x5A\x01\x5F\x9B\x02\x31\x9C\x05\x09\x95\x38\x3E\x02\x62\x97\x0B\x22\x92\x30\x02\x26\xE1\x02\x98\x82\x03\x04\x98\x41\x23\x02\x31\x94\x06\x21\x9A\xAE\x9A\x97\x4E\x35\x0C\x22\x92\x33\x06\x32\x89\x83\x19\x0D\x99\x56\x18\x0D\x22\x93\x34\x02\x26\xEA\x02\x98\x8B\x03\x62\x94\x0D\x22\x93\x36\x02\x26\xEE\x00\xCC\x9F\x96\xF4\x92\xF7\x2F\x03\x9F\x9B\x39\x70\x00\xD1\x87\x97\xD5\x96\x5D\xB1\x96\xA5\x97\x32\xED\x94\xCA\x8B\x78\x71\x02\x4C\xB2\x03\x64\x99\x34\xCF\x98\xD0\x8C\x9A\xCF\x92\x5C\xA8\x96\xAC\x97\x2D\xCB\x9A\xD5\x9F\x80\x80\x02\x4C\x81\x04\xAA\x9A\x35\xD5\x9A\xD3\x87\x9B\x05\x99\x6B\xA5\x97\xAD\x9F\x35\xC8\x99\xD9\x8E\x6D\x8F\x02\x4C\x90\x05\xA3\x9C\x36\xFC\x15\x24\x14\x9B\xB3\x1A\x12\x39\x97\x49\x09\x2F\x94\x04\xDE\x8F\x9B\x9B\x4D\x12\x22\x92\x4B\x02\x26\x97\x06\x98\x98\x04\x62\x91\x13\x22\x92\x4D\x09\x2F\x9B\x06\x98\x9C\x04\x16\x9A\xA0\x1E\x04\x31\x9F\x09\x62\x90\x28\x02\x93",
			"\xA1\x02\x4C\xA2\x05\xBF\x93\x10\x23\x06\x98\x84\x05\x9C\x99\x68\xA6\x9B\x7C\x15\x0A\x62\x92\x29\x01\x9D\xF2\x77\x14\x28\x9C\x6B\x18\x0A\x62\x91\x2A\x02\x93\xAA\x02\x4C\xAB\x04\x31\x9C\x0A\x62\x91\x2B\x02\x93\xAE\x03\x75\xAF\x04\x31\x90\x0B\x64\x9B\xDA\x83\x9D\x5E\x98\x6D\x81\x9F\xB4\x9D\x35\xCD\x98\xF1\x97\x9A\x6D\x9D\x6E\x87\x9F\x79\x9D\x76\x3E\x07\xEA\x82\x9E\xC6\x9B\x78\x92\x9F\xE8\x94\x3D\xEA\x9A\xE8\x80\x9C\xD7\x9F\x77\x8A\x29\x5F\x0F\x3C\xCB\x9E\xDB\x9A\x9E\xE0\x99\x7B\xA2\x9E\xAE\x98\x3C\xD0\x9E\xF5\x84\x46\xC0\x05\x7B\xBD\x47\x60\x0B\x3A\xC2\x06\x98\x83\x06\x62\x94\x18\x22\x93\x62\x02\x26\xC6\x06\x98\x87\x06\x62\x90\x19\x22\x93\x64\x02\x26\xCA\x06\x98\x8B\x06\x62\x94\x19\x2A\x9F\xEA\x9C\x8D\x4D\x07\x00\xA8\x11\xCE\x07\x80\x85\x9F\xF3\x99\x3C\xC0\x9D\xC4\x0F\x06\x0A\xA4\x03\x50\x06\x31\x91\x0D\x3E\x9F\xF8\x8D\xA0\xD8\x9C\x7C\x8C\x9E\x0C\xA1\x3E\x9A\xA3\xF7\x97\xA0\xE6\x9B\x81\xA2\xA1\xF2\x98\x6F\x5F\x05\x04\xBB\xA0\x21\xA4\x84\x93\x9E\x06\xA9\x42\xA8\xA2\xF7\x8A\x9E\x2B\xA3\x84\x9B\x1C\x70\x07\x42\x9F",
			"\xA2\x07\xB0\xA1\x04\xA2\x85\xB9\xA0\x17\xA1\x43\xF3\x69\x38\x02\x93\xE2\x05\x86\xB8\xA0\x14\x13\x0E\x42\xA3\xAA\x04\x07\xF9\x95\x1C\x22\x92\x73\x02\x26\xE7\x06\x11\xB9\xA0\x30\x40\x1D\x22\x93\x74\x02\x26\xEA\x06\x98\x8B\x07\x62\x94\x1D\x22\x93\x76\x09\x2F\xEE\x06\x98\x8F\x07\x91\x9A\xA1\x31\x06\x31\x92\x0F\x62\x93\x3C\x02\x93\xF4\x02\x4C\xB5\x07\xD5\x96\x0F\x62\x93\x3D\x0F\xA2\x1D\xA4\x83\x92\x16\x7C\x02\x26\xF9\x04\x1C\xBF\x5A\xFA\x07\x8E\x81\x09\x7D\x02\x26\xFC\x06\x98\x9D\x07\x62\x96\x1F\x24\x92\x31\x90\x00\x6F\x0D\x8E\x8D\x0F\x86\xA4\x47\xAE\x3E\x01\x09\x48\xC0\x92\x42\x03\x00\x8D\xA3\x48\x90\xA3\x35\x34\x00\x11\xA5\x92\x8D\x34\x05\x06\x92\x8D\x92\x14\x16\x00\x1A\xA6\x42\x07\x00\x9E\xA4\x4A\xA1\xA5\x49\xAC\xBE\x09\x03\x28\xBA\x92\xA7\xA5\x4B\xA9\xA4\x30\x9B\x4A\xA9\x11\x2B\xAE\x00\xAD\xA5\x45\x0F\x01\x56\xA0\x01\x16\xA6\xA2\x80\x26\x12\x05\x95\x93\x01\x56\xA4\x01\x2D\xA5\x05\x0D\xA5\x16\x01\x96\xB9\x17\x0B\x0D\x4A\x98\x02\x30\xBD\xA1\x3C\xA6\xC1\x19\x01\x56\xAA\x01\x47\xA7\xC9\x9B\x00\xCE\xA7\x95\x1C\x01",
			"\x56\xAD\x01\x2D\xA6\x07\x0D\xA5\x1F\x05\x95\xA0\x01\x56\xA1\x02\x2D\xA6\x08\x11\xA6\x81\x3B\x04\x2D\xA4\x12\x00\x4E\xBA\xA2\x93\x25\x01\xE5\xA3\xCC\x26\x01\x74\xA8\x1A\x27\x00\x3B\xAA\x08\x28\x07\x9D\x8E\xA1\x71\x59\x02\x2D\xA6\x0A\x0D\xA5\x2B\x05\x95\xAC\x01\x56\xAD\x02\x2D\xA6\x0B\x12\xA7\x06\x0F\x05\x2D\xA4\x18\x06\x4B\xE1\x26\x0C\x0D\xA5\x33\x05\x95\xB4\x01\x56\xA5\x03\x2D\xA6\x0D\x00\xA8\xCD\x17\x06\x2D\xA4\x1C\x00\x51\xA0\xA3\x0B\xB3\x1D\x39\x05\x95\xBA\x01\x8A\xAB\x2B\xBB\x00\x47\xB4\x23\x3C\x05\x95\xBD\x01\x56\xAE\x03\x2D\xA7\x0F\x0D\xA5\x40\x05\x95\x81\x03\x56\xA2\x04\x1F\xA9\x0B\xB6\xA1\xD6\x13\x08\x05\xA9\x79\xA2\x43\xB0\xAB\x4B\xA3\xA2\x35\xA8\xA7\xA6\xA7\x9C\xAB\x2A\x45\x01\x2B\xA6\x02\x96\xA0\x57\x96\xA8\x64\xA6\x53\x97\xA8\x29\xA4\xAA\x3A\xA9\x99\xAC\xA0\xA3\xA1\x47\xB7\xA8\x4D\xA3\x5A\x54\x06\xA5\x8C\xAB\xA1\xAB\x43\xC5\xA8\x52\xAF\xAA\x4A\xAC\xA7\xA1\x5B\x2A\x0D\x4A\xD6\x02\x54\xB7\xAA\xBF\x1F\x0A\x1F\xA8\x2C\x03\x53\xBF\x1E\x16\x1F\xA8\x5B\x05\x95\x9C\x03\x56\xAD\x05\x5F\xA9\x55\xB2\x48\x5E",
			"\x05\x95\x9F\x03\x56\xA0\x06\x2D\xA5\x18\x0D\xA5\x62\x05\x95\xA3\x03\x8F\xA4\x06\x2D\xA5\x19\x05\xAB\x36\x2F\x0C\x2D\xA4\x34\x0D\x4A\xE9\x01\x2B\xAA\x03\xAD\xA3\x0D\x2E\xAA\x14\x1C\x06\x2D\xA5\x1B\x0B\xAC\x5A\xAD\xA9\xB9\x16\x37\x0D\x4A\xEF\x00\x64\xB0\x80\x70\x07\xB2\x9B\x1D\x38\x0D\x4A\xF2\x01\x2B\xB3\x03\xAD\xA4\x0E\x2D\xA5\x3A\x0D\x4A\xF6\x01\x2B\xB7\x03\x9A\xA8\x35\x38\x03\x56\xA9\x07\x41\xA9\x52\xB6\xAA\x6F\xA8\xAB\xB0\xAD\xA5\xA0\x56\x92\xAD\x6D\xB4\xAA\x0C\xA7\x10\x2D\xA4\x44\x0E\x5A\xB2\xAF\x6B\xBF\xAD\xBE\xA9\xB8\x87\xAB\xD8\xA3\x5C\xB4\xAC\x71\xBD\x71\x96\x05\x95\x97\x05\xDE\xA5\x5C\x91\xAC\x6E\xAE\xAE\x37\xA2\xB8\xB6\xAD\xE3\xAF\x5C\xBB\xAA\x75\xB9\x13\xA5\x05\x95\xA6\x04\xE6\xA3\x5D\xC6\xAE\x77\xB0\xAE\x72\xA1\xBA\x8D\xAF\xEB\xA3\x5B\xE0\xAE\x53\xB1\x15\xB4\x05\x95\xB5\x04\xEE\xA5\x5D\xD9\xA8\x79\xA0\xAE\xE3\xAE\xBD\xB2\xAF\xF2\xAF\x5E\xD2\xAD\x7B\xA3\x1E\xC3\x05\x95\x84\x07\xD4\xA0\x5F\xCD\x15\x31\x1C\xAF\xB3\x1E\x18\x1F\xA9\x63\x0F\x51\xC8\x05\x2B\xA9\x06\x00\xB1\xBE\xAB\x36\x65\x0D\x4A\xCB\x05",
			"\x2B\xAC\x06\xAD\xA5\x19\x2D\xA4\x67\x0D\x4A\xCF\x07\x47\xB0\x06\xAD\xA1\x1A\x00\xAD\x9F\x23\x0D\x2D\xA4\x35\x0D\xA5\xD5\x05\x95\x96\x07\x56\xA7\x0D\x09\xB3\x40\x18\x06\xAD\xA1\x1B\x26\xB1\xFB\xAD\x5F\x82\x0A\x36\x0D\xA5\xDB\x03\xC5\xB2\x76\x6E\x02\x63\xF9\x79\x2B\xBE\x06\xAD\xA7\x1B\x2D\xA4\x70\x0D\x4A\xE1\x05\x2B\xA2\x07\xAD\xA3\x1C\x35\xB1\xF3\xAD\x5D\xC8\x10\x39\x03\xB2\xDD\x2D\x1C\x08\xB3\xDB\xA2\x5E\xC5\xB1\x7D\xAA\xB0\x2D\xB5\xC9\xAC\xB0\x81\x26\x0E\x2D\xA7\x39\x0B\xB2\xD4\xAD\x5A\x28\x06\x2C\xBE\x33\x69\x07\x47\xAA\x07\x1F\xAB\x1D\x1C\xB2\xF3\xA8\x6F\x6C\x05\x2B\xAD\x07\xAD\xA6\x1D\x2D\xA5\x77\x0D\x4A\xF0\x05\x2B\xB1\x07\x1F\xAA\x1E\x2D\xA5\x79\x0B\x61\xC2\x29\x3D\x0D\xA5\xF6\x05\x95\xB7\x07\x56\xA8\x0F\x2D\xA5\x3E\x15\xB1\xFA\x05\x95\xBB\x07\x31\xBF\x64\xCE\xB1\x9E\x1C\x07\xAD\xA5\x1F\x04\xB4\x9B\x6E\x0F\x0B\xB5\x6B\x0D\xA5\x00\x05\x16\x4E\xA5\x0A\x22\x69\x92\xA6\x79\x15\xB4\x97\xA3\x20\x03\x00\x4C\xBB\x1E\x1C\xB6\x42\x05\x00\x9E\xB6\xBE\x92\xB2\xA1\x26\x00\x21\xB6\x55\x47\x00\xA6\xB6\xD0\xB4\xAF\xF9",
			"\xA1\x65\xE1\xAE\xAB\xA4\xB2\x53\xB7\x77\x08\x01\x54\xB2\x10\x09\x00\xA6\xA2\xAA\xA3\xB7\xD5\x93\xAB\x5C\xB0\x6B\xBC\xB7\xAE\xBA\xB5\x4C\xB0\xD8\x99\xB3\xA1\x27\x01\x34\xB5\x40\x18\x00\xC6\xB2\xD8\x8E\x33\x0C\x09\x6C\xEB\x32\x06\x0D\xB6\xD9\x0B\x03\x10\xB6\x04\x1C\x01\x53\xB7\xB0\xA7\x5B\x1D\x01\xD9\x9E\x01\x64\xBF\x01\x49\xB4\x08\x09\xB6\x21\x01\xD9\xA2\x00\x6B\xB8\x22\x23\x01\xB2\xA4\x01\x98\xB7\x96\x86\x28\x13\x09\x6C\xA7\x01\xB2\xA8\x01\xC9\xB1\x05\x09\xB6\x15\x04\x6E\xD6\x1B\x0A\x09\xB6\x2C\x05\xDE\x85\xB5\x58\xBD\x41\x2D\x01\xB2\xAE\x01\xFA\xB3\x83\xAF\x01\x80\xB3\x3C\x30\x01\xB2\xB1\x01\xC9\xB2\x06\x09\xB7\x19\x09\x6C\xB4\x01\xB2\xB5\x01\xC9\xB6\x06\x04\xB9\x56\xBD\x6B\xBE\x73\x0D\x13\xB8\xA2\xB2\xD9\xA4\xB2\x81\x18\x03\x18\xB8\x94\xB9\xB8\x15\xB9\xE4\x8B\x77\x1C\x09\x6C\xBA\x02\xC7\xAA\xB5\x99\x1B\x07\x27\xB9\x9F\x2C\x03\x2B\xB9\x40\x1D\x01\x2E\xB8\x00\x3E\x01\x98\xB2\x72\xFD\x47\x0F\x09\xB6\x40\x01\xD9\x81\x03\x64\xB2\x04\x49\xB7\x10\x09\xB6\x44\x01\xE6\x85\x03\x64\xB6\x04\x69\xB5\x38\x28\x02\xC9\xB1",
			"\x09\x09\xB6\x25\x09\x6C\xCB\x01\xB2\xAC\x02\x34\xB9\x3B\x0D\x03\x64\xBE\x04\x51\xB9\xB0\xB5\xB9\x18\x17\x09\x09\xB6\x28\x06\x75\xCA\x7D\x14\x1D\xBA\x3E\x1A\x0A\x09\xB7\x29\x09\x6C\xD4\x01\xB2\xB5\x02\xC9\xB6\x0A\x09\xB7\x2B\x09\x6C\xD8\x00\xD8\xBB\xB8\xD7\xB1\x3B\x19\x03\xB7\xBC\x81\x5A\x00\xDD\xAC\xB5\x20\xBF\xD7\x98\xBB\xEF\xAB\x6F\xBE\xB7\xD5\xAF\x24\x5B\x01\xD9\x9C\x03\xBB\xBB\x6A\xA3\x15\x17\x04\xBC\x99\x1E\x0B\x31\xB9\x2F\x01\x73\xE0\x00\xE2\xB9\xBB\x91\x39\x0C\x09\xB6\x31\x09\x6C\xE3\x01\xB2\xA4\x03\xC9\xB5\x0C\x09\xB6\x33\x01\x73\xE7\x01\xB2\xA8\x03\x46\xBA\xA0\x2A\x03\x64\xBB\x06\x49\xB4\x1B\x09\xB6\x6D\x01\xD9\xAE\x03\xC7\xB6\x10\x6F\x01\xB2\xB0\x03\xAC\xB8\xE5\x99\xB9\x38\x09\x6C\xF2\x01\xEC\xA8\x69\x73\x07\xF6\x95\x16\x3A\x09\x6C\xF5\x01\xB2\xB6\x03\xC9\xB7\x0E\x09\xB6\x3C\x09\x6C\xF9\x01\xB2\xBA\x03\xBA\xBA\xE3\xBD\xBA\x6B\x1B\x07\x49\xBF\x9A\x3C\x03\xCE\xBA\xEF\x92\xBF\xBF\xB4\x7D\xF1\xB9\xF5\xBC\xBB\x1F\x85\x0F\x09\xB6\x3F\x07\x6B\x94\xBB\xF4\xB6\xBE\xE0\xB8\xFB\x85\xBC\xEF\xB7\x7D\xF0\xBA\xF8",
			"\xA4\xBF\xE1\xBE\xFC\xAA\xBF\xE5\xBB\x77\xEB\xBC\xDE\xBF\xB8\xF0\xBC\xDA\x0C\x05\xE8\xBC\xD1\x0D\x05\xB2\xAE\x04\xF4\xB9\xFD\x9D\x13\x47\x09\x7F\xBE\x18\x24\x11\xB9\x91\x01\xE6\x92\x05\xFE\xBE\x7E\xEB\x37\x24\x09\xB6\x94\x01\xD9\x95\x05\x64\xB6\x09\x49\xB7\x25\x09\xB6\x98\x01\xE6\x99\x05\x64\xBA\x09\x21\xBE\x42\x3C\x04\xC9\xB5\x13\x09\xB6\x4F\x09\x6C\x9F\x05\xB2\xA0\x05\xC9\xB9\x14\x09\xB6\x51\x04\x80\xEC\xBF\xAF\xA3\x05\xC9\xB4\x14\x25\xC0\x9B\x65\x0A\x2B\xC0\x6A\x06\x05\xC9\xB7\x14\x09\xB6\x54\x09\x6C\xA9\x05\xB2\xAA\x05\xC9\xB3\x15\x09\xB6\x56\x0E\x82\xE8\xBF\xF9\xB8\x4C\xAD\x05\x07\xD0\xBC\xFD\xBB\x41\xAE\x06\x10\xD1\xBF\xFC\xB1\x09\xFE\xBB\x12\x6F\x0A\x49\xB4\x2C\x07\xC2\xB2\xBE\x20\x31\x04\x28\xC2\x2D\x32\x05\xCC\xB3\x05\x31\xBC\x16\x14\xC3\x25\xC9\x7A\x35\x05\xB2\xB6\x05\xC9\xB7\x16\x09\xB6\x5C\x09\x6C\xB9\x05\xB2\xBA\x05\x31\xBB\x17\x09\xB6\x5E\x06\x81\xB6\x2A\x2F\x09\xB6\xBF\x01\xD9\x80\x07\x64\xB1\x0C\x49\xB6\x30\x09\xBE\xC3\x01\xD9\x84\x07\x2D\xCA\x7C\xEF\xBF\x40\x05\x06\xC9\xB6\x18\x3C\xC3\xB3\x57",
			"\x0C\x7C\xC0\x32\x09\xB6\xC9\x01\xD9\x8A\x07\x64\xBB\x0C\x49\xB4\x33\x09\xB6\xCD\x01\xD9\x8E\x07\x41\xCF\x7D\x8C\xA3\x33\x14\xC4\xA9\x20\x1A\x18\xC4\x22\xC3\x7E\xC3\xC3\x0F\xC8\xC2\x5C\xC5\x00\xD1\x7F\x68\x09\x6C\xD2\x07\x26\xDF\xC4\x61\x7F\x14\xC8\x12\x6A\x01\x73\xD5\x05\xCC\xB6\x06\xAA\xC6\x04\xC1\x33\x6B\x09\x6C\xD8\x05\xB2\xB9\x06\xC9\xB2\x1B\x09\xB7\x6D\x09\x6C\xDC\x05\xCC\xBD\x06\xC9\xB6\x1B\x2D\xC3\x9F\x20\x0E\x49\xB5\x38\x09\xB6\xE2\x01\xD9\xA3\x07\x64\xB4\x0E\x49\xBD\x39\x09\xB6\xE6\x01\x16\xFE\xC3\x0B\xA7\x0E\x49\xB4\x3A\x12\xC6\x67\x49\x1D\x3C\xC2\x75\x09\x6C\xEB\x05\xB2\xAC\x07\xC9\xB5\x1D\x09\xB6\x77\x09\x6C\xEF\x05\xB2\xB0\x07\xD8\xC6\x07\xCB\x79\x78\x09\x8E\xB3\x1E\x3C\x0D\xC7\xA0\xC5\x0F\xDD\xC5\x78\xCD\x7E\xB2\xC4\x27\xDA\x3D\xF3\x01\xD9\xB4\x07\xEE\xBE\x89\xA2\xC5\x3F\xD6\xC7\xA8\xC2\x09\xF2\xC6\x75\xC0\x90\xFE\xC4\x3D\xD5\xC4\x0B\x7A\x00\x35\x0F\x43\xAF\x8F\xD3\xC5\x28\xC5\xC8\x10\xCE\x21\xC3\xC9\x86\xC3\x8F\xD1\xC3\x66\x43\x00\x0B\xCA\x91\x87\xC9\xF2\xB1\x91\x95\xCA\x40\xD5\xC7\x12\xC8\x24",
			"\xDE\xC9\x87\xC1\x92\x88\xC9\x47\xCA\x08\x04\x01\x23\xD3\xB5\x8D\xC7\x8F\x94\xC8\x41\xC5\xC9\x1C\xC8\x26\xED\xC8\x96\xC1\x90\xB9\xB5\x01\x0A\xC9\x96\xB7\x23\xE6\xC8\x99\xC5\x93\x93\xC8\x4D\xC6\xC8\x16\xCA\x27\xF1\xC9\x75\x36\x00\x38\xC9\xA6\xA2\xCA\x33\xC9\x28\xE4\xC9\x91\xCE\x93\xCA\xC9\x53\xC8\xCA\x3D\xCA\x24\xEF\xC8\xA6\xC2\x95\x82\x2B\x01\x06\xCA\x9B\xA1\x4D\x48\x00\xAC\xCA\x10\x09\x02\x51\xD8\xB5\x4F\xCB\x29\xD3\xCB\xB1\xCE\x92\xE5\xCB\x4F\xC7\xC9\x66\xCE\x29\xD5\xCB\xB3\xCC\x93\xC0\xC8\x54\xCE\xCB\x62\xC9\x2D\xEF\xCA\x0E\x47\x01\x5C\xCB\xDF\x58\x00\x76\xCE\x20\x19\x01\xAF\xC4\x96\xEC\xC8\x55\xDB\xC9\x7F\xCB\x28\xFD\xCA\xB5\xC0\x98\x83\xCE\xB4\x07\x01\x79\xCB\x20\x28\x01\xC4\xC3\x97\xD8\x25\x0A\x0C\xCC\x6D\x3A\x05\x10\xCC\x6B\x1B\x02\x13\xCD\x8B\x0C\x01\x96\xCD\x30\xD8\x4D\x16\x03\x99\xAE\x03\x64\xCF\x01\x93\xC8\x06\x13\xCD\x18\x03\x99\xB2\x01\x66\xC8\x10\x33\x03\x32\xF4\x00\xA3\xCA\x6E\xD8\x26\x0D\x13\xCC\x37\x03\x32\xF8\x01\xC9\xC9\x03\x13\xCE\x0E\x07\xCD\x11\x1B\x07\x13\xCC\x1E\x08\x9B\xD1\xCA\x66\xD1",
			"\x15\x3D\x03\x32\xFE\x01\xDE\xC7\x27\xBF\x00\x71\xC6\x28\x40\x03\x32\xC1\x03\xC9\xC2\x04\x13\xCF\x10\x13\xCC\x44\x03\x32\xC5\x03\xC9\xC6\x04\x47\xCF\xE6\x07\x02\x93\xC8\x09\x3C\xCA\xB9\xC1\x97\xFE\xCA\x61\xDD\xCE\x84\xCA\x30\xDC\xCF\xB0\xC4\x9E\xEB\xC9\x78\xD1\x18\x56\x06\x3A\xC1\xCD\xA4\xCD\x98\xEB\xCE\x6F\xC2\xCF\xDE\xCC\x01\x97\x03\xC9\xC8\x05\x5B\xCD\x7C\xD7\xCF\xE7\xCF\x3D\xEC\xCE\xF0\xCD\x9E\xDF\xCD\x79\xDF\xCD\xD4\x36\x0C\x2A\xCE\xFF\xC6\x9E\xFD\xCF\x78\xC5\xD0\xFC\xC9\x41\xFF\xCE\xF8\xC9\x9F\xF0\xCA\xB5\x07\x03\x03\xD7\x6F\x68\x03\x08\xD1\x2B\x69\x03\x64\xCA\x03\x93\xCB\x0D\x13\xCC\x36\x03\x99\xED\x03\x64\xCE\x03\x93\xCF\x0D\x13\xCC\x38\x03\x99\xF1\x03\x64\xD2\x03\x93\xCB\x0E\x14\xD1\x06\xDE\x95\x74\x03\x8A\xCA\x23\x75\x07\x45\xCA\xD0\x04\xDB\xA0\xCA\x7E\x1D\x12\xD1\x9C\x4F\x0E\x13\xCC\x3C\x06\x9F\xAC\xD1\x5B\xC8\xCB\xF8\xCE\x40\xC1\xD3\x19\xD0\xA0\xC2\xD1\x1C\xA6\x04\x93\xCF\x10\x3D\xD0\x23\xDC\xA4\xC4\xD0\x83\xCD\xD2\x35\xD2\x3F\xD2\xD2\x07\xD4\xA3\xD5\xD1\x91\xCE\xD2\xFB\xC8\x00\x15\x04\x1C\xD6\xA5",
			"\xCF\xD0\x96\xD3\xD2\x40\xD6\x47\xEE\xCF\xC0\x36\x09\x5C\xD2\x63\x57\x04\x66\xD0\x41\x18\x05\xC9\xC9\x09\x13\xCE\x26\x13\xCC\x9B\x03\x32\xDC\x05\xC9\xCD\x09\x13\xCE\x27\x13\xCC\x9F\x03\x32\xE0\x05\xC9\xC1\x0A\x13\xCE\x28\x09\xD3\x59\xD2\xF6\x23\x04\x40\xDE\x33\x24\x04\xA1\xD4\xD2\x57\xD1\x4A\xF0\x61\x52\x07\xA8\xDE\x4A\x29\x13\xCC\xA7\x03\x49\xDF\xD2\x44\xDE\xA5\x8A\xD5\x98\xD0\xD2\x5D\xD1\x50\xC9\xD4\xF1\x75\x0B\x13\xCE\x2D\x12\xD4\x96\xD7\x47\xE2\xD5\x31\xD7\xA9\x93\xD5\xA9\xC1\xD5\xA4\xD3\x54\xC4\xD1\x4D\xDC\xAA\xC1\xB4\x31\x0D\xD4\xAA\xD7\x40\xED\xD4\x4D\xD5\xA9\x99\xD4\x98\xD1\xD5\x43\xD6\xC7\x45\x06\x58\xD9\xAA\xBD\xD7\xAA\xD5\xD5\xB3\xD7\x56\xFE\xD4\x59\xD0\xAC\x82\x5A\x31\x1C\xD5\xBF\xD4\x56\xCA\xD6\x61\xD9\xAC\xCC\xD4\xB1\xD8\x10\xC7\x00\x59\xD8\x4C\x64\x02\xAD\x86\x09\x32\x13\xCC\xCA\x03\x32\xCB\x07\xC9\xCC\x0C\x13\xCD\x33\x13\xCC\xCE\x03\x32\xCF\x07\xC9\xC0\x0D\x13\xCD\x34\x13\xCC\xD2\x03\x32\xD3\x07\x6A\xD2\xA6\xE1\x30\x35\x0C\xD7\xD2\x15\x1A\x30\xD6\x53\xD8\xAB\xED\xD7\xDF\x56\x06\xF3\xD0\x06\x57",
			"\x07\xC9\xC8\x0D\x20\xD6\xAD\xD4\xD4\xCB\xD0\x60\xCE\xD7\x5C\xDF\xAF\xA7\xD5\xC1\xD5\xD7\x98\xD1\x5F\x26\x07\x7C\xD0\x92\x67\x05\xBE\xC8\x07\x93\xC9\x1D\x13\xCC\x75\x03\x99\xEB\x07\x64\xCC\x07\x93\xCD\x1D\x13\xCC\x77\x03\x99\xEF\x07\x64\xD0\x07\x93\xC9\x1E\x13\xCC\x79\x0C\xB0\xC1\xD6\x94\x33\x07\x25\xD8\x41\x34\x07\x94\xD1\xB0\x86\xDA\xC9\xDE\x4A\xF5\x04\x65\xE9\x3C\x7B\x03\x99\xF7\x06\xBF\xCF\xD9\x08\xDC\x5E\xC3\xD6\x82\xD8\xB3\xBB\xDA\xBD\xDC\xD9\xEA\x7D\x00\x38\x0E\x86\xC6\x10\x06\x03\xD0\xDA\xC8\x3F\xDD\x83\x07\x01\xA3\xDB\x92\xD4\x34\x02\x0C\xDA\x39\xCD\x5A\x09\x00\xA8\xD7\x94\xD5\x16\x02\x14\xDA\x59\xCE\x65\xFD\x47\x05\x08\xB5\x8A\x08\x03\x1D\xDA\x09\x0D\x01\x20\xDA\x83\x0E\x00\x63\xDB\x40\x0F\x00\x66\xDA\x20\x10\x01\xB4\xD5\x2D\x11\x00\xDB\xC0\x00\x12\x04\x6A\xED\xCD\xE1\x14\x01\x6F\xD9\x05\x0F\xDB\x16\x07\x6D\xD7\x01\xB7\xD8\x01\x6F\xD8\xBF\x19\x00\x6F\xDA\x03\x3E\xDB\x9E\xDD\x6A\x9B\x03\xDB\xDC\x00\x83\xDE\x6B\x9D\x01\xC4\xD0\x4A\x1E\x03\xDB\xDF\x00\x6F\xD8\x04\x2F\xDB\x10\x0F\xB6\xA2\x03\xDB\xC3\x01",
			"\x6F\xDC\x04\x0C\xDC\x9F\x15\x02\x6F\xDA\x09\x14\xDA\x60\xCF\x60\xFE\xD9\x84\xD5\xAC\xAD\xD9\xCE\xC8\xD5\xCD\xD2\x60\xCB\x78\x1A\x0F\xB6\xB5\x03\xE6\xCA\xDD\xA5\x1E\x06\x2F\xDC\x4D\x37\x03\x33\xDD\x9E\x18\x01\xB6\xD8\x35\x39\x01\xDC\xD9\xBA\x9C\x42\x0E\x0F\xDB\x3B\x07\x6D\xFC\x01\xB7\xDD\x03\x6F\xDA\x0F\x0F\xDB\x3F\x04\x77\xC9\x08\x20\x0F\xB6\xC1\x02\xDC\xC1\x27\x43\x07\x6D\xC4\x03\xB7\xD5\x04\x6F\xDA\x11\x0F\xDB\x47\x02\x79\xF1\x14\x24\x0F\xB6\xC9\x02\xF6\xC9\xDA\x02\xCA\x09\x2F\xDB\x25\x0F\xBD\xC2\x84\x13\x05\xDF\x73\x25\x09\x2F\xDA\x27\x0F\xB6\xCF\x03\xDB\xD0\x02\x6F\xD9\x0A\x2F\xDA\x29\x0F\xB6\xD3\x00\xFA\xC8\xDD\xCF\xD3\x60\xE0\xDE\xF5\x44\x05\x77\xDE\xE8\xDD\xDD\xA7\xDF\x7F\xF9\xDE\xD8\xD1\xC0\xDD\x2D\x15\x1E\xDF\x84\xDB\x80\xDA\xDA\xD3\xD3\xBA\xBA\xD8\x00\xED\xE0\xE4\xCE\x0A\x08\xE1\xD2\xDA\xBF\xA4\xDC\x03\xEF\xE0\x18\xE2\x81\xC5\xE0\x0A\xE2\x65\x57\x03\x04\xF7\xE0\x1A\xE0\x82\xC2\xE0\xA0\xD0\xC2\xA4\xE1\x05\xEE\xE0\x02\x28\x0B\x1F\xE1\x13\xE8\xBF\xA6\xE0\x01\xE2\xE1\x09\xE6\x85\xCB\xE0\x16\xED\x22\x59",
			"\x03\x0A\xEF\xE1\x19\xE2\x86\xDB\xE1\x12\xEB\xBF\xAD\xE1\x0F\xE3\xE1\x3D\x72\x0B\x37\xE1\x19\xE8\xC3\xA1\xE1\x0E\xFF\xE1\x31\xE0\x89\xDC\xE0\x22\xEC\xC4\xBB\xE0\x0B\xFB\x02\x43\xE6\x89\xC5\xE2\x1D\xE0\xC3\xCB\xE2\x14\xED\xE2\x55\xE4\x87\xFF\x28\x2E\x01\xC5\xD9\xE0\x0D\xE9\xE2\x16\xE7\x8B\xD6\xE2\x2F\xE3\xC5\xCA\xE2\x83\x3D\x02\x5D\xE7\x88\xE1\xE3\x32\xEB\xC6\xD8\xE2\x1A\xE8\xE1\x54\xE7\x8D\xC0\x00\x2F\x09\xC6\xC6\xE2\x1D\xF1\xE3\x77\xE6\x8C\xE2\xE2\x2D\xE0\xC7\xFA\xE0\x92\x1F\x02\x75\xE0\x8F\xC2\xE4\x3F\xEE\xC6\xF9\xE1\x1B\xF7\xE2\x88\xE4\x8C\xDD\x12\x30\x01\xC8\x84\xE5\x22\xF2\xE3\x40\xE7\x90\xCA\xE5\x47\xE6\xC8\xB9\xB5\x18\x0D\xE4\x92\xE0\x92\xE0\xE3\x3E\xE9\xC9\x95\xE6\x0F\xFD\xE4\x0A\x2A\x0C\x18\xE4\xA1\x23\x06\x23\xE7\x27\xFC\xE4\xA8\xE7\x94\xEA\xE5\x16\x14\x06\x6F\xD9\x19\x00\xDD\x9A\xE3\x8C\xF1\xE4\x3E\xEB\xCA\x9B\xE5\x2D\xF2\xE5\x9E\xE3\x0E\x2F\xDA\x3A\x00\xCB\x9E\xE5\x24\xE9\xE5\xBF\xE7\x96\xF4\xE5\x60\xE4\xCC\xB6\xE6\x20\x0F\xDB\x83\x05\x97\xC3\xE4\x50\xEE\xC8\x93\xE6\x33\xF3\xE5\x7B\xE1\x9A\xEC\xE2",
			"\x60\xE6\xCB\xEB\x31\x24\x06\xE5\xC5\xE0\x97\xCB\xE6\x6A\xEA\xCD\xCD\xE5\xAB\xB2\x04\x6F\xDB\x12\x18\xE7\x44\xD4\x09\x63\xE6\xC0\x15\x04\xF7\xDE\x12\x37\xDF\x4B\x06\xCE\xC3\xE7\x23\x38\x04\x6F\xD9\x13\x2F\xDA\x4D\x0F\xB6\x9B\x07\xDB\xDC\x04\x6F\xDD\x13\x37\xDE\x4F\x0F\xB6\x9F\x07\xF3\xC2\x28\xA1\x07\x6D\xE2\x05\xB7\xD3\x0A\x6F\xD8\x29\x0F\xDB\xA5\x06\x94\xE6\x05\xB7\xD7\x0A\x6D\xE6\x34\xE8\x9E\xA8\x07\x6D\xE9\x04\x87\xE0\xC3\x2A\x04\x45\xFD\x12\xAB\x07\x6D\xEC\x05\xB7\xDD\x0A\x6F\xDA\x2B\x0F\xDB\xAF\x07\x6D\xF0\x05\xB7\xD1\x0B\x17\xE8\x25\xF6\x4A\xB2\x06\xA4\xEF\x41\x59\x06\xCA\xB4\x07\xDB\xD5\x05\x6F\xDE\x16\x2F\xDB\x5B\x0F\xB6\xB8\x07\xDB\xD9\x05\x6F\xDA\x17\x2F\xDB\x5D\x0F\xB6\xBC\x07\xDB\xDD\x05\x6F\xDE\x17\x2A\xE8\x68\xE6\x35\x3F\x07\x50\xE9\x08\xC0\x07\xA8\xDB\xE6\x61\xEF\xD0\xE3\x31\x30\x0A\xEA\xDE\xE6\x97\xDD\x2E\x61\x07\xBF\xC3\x04\x54\xEC\xE6\x58\xEC\x9B\xEE\xE7\x6E\xE9\xD5\xE4\xCC\x31\x0F\xDB\xC5\x07\xAA\xCA\xD0\x63\x02\xD6\xD6\x17\x31\x17\xDF\xC8\x07\x7E\xC9\x07\xB2\xE9\xCD\x91\x1A\x32\x0F\xDB\xCB",
			"\x07\x6D\xCC\x07\xB7\xDD\x0C\x6F\xDA\x33\x0F\xDB\xCF\x07\x7E\xD0\x07\xB7\xD1\x0D\x7F\xE6\x42\x33\x06\x6F\xDC\x1A\x2F\xDB\x6A\x0F\xB6\xD6\x07\xDB\xD7\x06\xA6\xE0\x1B\x2F\xDB\x6C\x0C\xD6\xD5\xE4\xFB\x5A\x06\x6F\xDB\x1B\x0D\xEC\x81\x5C\x0D\x65\xE9\x37\x0F\xDB\xDE\x07\x6D\xDF\x07\xB7\xD0\x0E\x6F\xD9\x38\x0F\xDB\xE2\x07\x6D\xE3\x07\xC9\xEB\xD5\xA5\xED\x53\xEF\xE6\x52\xEC\xAB\xDA\xEB\xD3\xE4\xD4\x86\x28\x39\x0F\xDB\xE5\x04\xB4\xFD\xC8\x73\x02\xDB\xC8\x13\x39\x17\xDF\xE8\x07\x7E\xE9\x07\xDA\xE5\xC8\xBF\x1E\x3A\x0F\xDB\xEB\x07\x6D\xEC\x07\xB7\xDD\x0E\x6F\xDA\x3B\x0F\xDB\xEF\x07\x7E\xF0\x07\xB7\xD1\x0F\x7E\xEA\x4D\x33\x07\x6F\xDC\x1E\x2F\xDB\x7A\x0F\xB6\xF6\x07\xDB\xD7\x07\xA6\xE0\x1F\x2F\xDB\x7C\x0C\xDB\xA7\xE9\x8F\x7A\x07\x6F\xDB\x1F\x1D\xEF\xB3\x4C\x0F\x65\xE9\x3F\x0F\xDB\xFE\x06\x6F\xEF\xDA\x00\x0B\x1F\x44\xDA\x7A\x0D\xEF\x48\xDA\x20\x02\x00\xF8\xED\xB4\x82\x0B\x00\x14\xEF\x51\xDC\x8E\x04\x00\xFC\xE5\xB5\xCC\xEB\x34\xFE\xEF\xBD\xE9\xAA\xCB\xEB\xB6\xEC\xDA\xA9\xEE\x83\x25\x00\xFC\xEF\x39\x06\x01\x04\xFD\xDA\xF9\x13",
			"\x01\x0C\xF0\x9C\x30\x01\x10\xF0\x9F\x63\xE1\xCD\x16\x02\x15\xF0\x5D\xEA\xF6\x0B\x00\x0C\xF0\x26\x9C\xF1\x8A\x1E\xF0\x0E\x06\xC3\xCF\x00\x0F\xF0\x01\x1E\xF1\x8B\x11\x00\x1E\xF2\x02\x3C\xEF\xB9\xD9\x39\x14\x02\x87\xF5\x00\x1E\xF6\x02\x1E\xF1\x0B\x0E\xE1\x98\x02\x89\xF9\x17\x19\x06\xC3\xDA\x01\x1B\xFA\xDA\xE4\xCF\x06\x1E\xF0\x1C\x04\xC7\xE7\x99\x0E\x02\xE4\xAF\x26\x07\x1E\xF0\x1F\x06\xC3\xE0\x00\x0F\xF1\x02\x1E\xF2\x08\x1E\xF0\x23\x06\xC3\xE4\x01\x22\xF6\x35\x25\x00\x95\xE1\xF0\x19\xF6\xB1\xFD\xF0\x02\xFF\xDF\xDC\xF0\x96\xEB\xED\xC0\x26\x04\x1E\xF1\x13\x07\xE5\xDE\xEE\xB4\x08\x01\x65\xF4\xA5\x29\x01\x34\xFA\x10\x2A\x00\x9B\xE9\x08\x2B\x07\xCD\xC3\xF1\xEE\x2C\x02\x1E\xF1\x0B\x1E\xF0\x2E\x06\xC3\xEF\x00\x0F\xF0\x03\x1E\xF1\x0C\x12\xF3\x03\x0A\x06\x1E\xF1\x19\x0B\xE2\xE1\x25\x0D\x1E\xF0\x36\x06\xC3\xF7\x00\x0F\xF8\x03\x1E\xF1\x0E\x00\xF4\xD2\x12\x07\x1E\xF1\x1D\x00\xE9\xE0\xF3\xF2\xBC\x01\x1E\xF5\x07\x15\xF5\xC1\x8E\x03\x1B\xF4\xBF\x1F\x01\x1E\xF0\x08\x1E\xF1\x20\x0E\xE1\xC2\x02\x87\xE3\x02\x1E\xF4\x08\x1E\xF1\x22",
			"\x0E\xE9\xD9\x0E\x11\x0D\xF5\x5B\xF2\xCB\xE6\xED\x2E\xF2\xEB\x85\xF3\x9C\xF1\xF5\xB8\xF0\x43\x07\x02\x0F\xF8\x04\x30\xF4\x2D\xE9\x02\xBE\xF7\x95\x0A\x03\x4D\xFB\x04\x1B\xF4\x13\x01\xF6\xB4\xF1\xC8\x0D\x02\x0F\xFE\x04\x1E\xF3\x13\x1E\xF0\x50\x06\xC3\xD1\x02\x0F\xF2\x05\x1B\xF7\x14\x1E\xF0\x54\x05\xD0\xC2\x28\x2B\x0E\xE1\xD7\x02\x87\xF8\x02\x1E\xF1\x0B\x1E\xF0\x2D\x08\xEC\xDD\x13\x16\x1E\xF0\x5C\x05\xDC\xE6\xF3\x5C\xBD\x05\x1E\xF2\x17\x0A\xF7\x3C\x6F\x0B\x30\xF7\x4E\x10\x06\x1E\xF1\x18\x1E\xF0\x62\x06\xC3\xE3\x02\x0F\xF4\x06\x1E\xF1\x19\x1E\xF0\x66\x03\xDE\xC9\x09\x33\x02\xF0\xB7\xF7\xAC\xFF\xF2\x00\xF3\xDD\xC9\xF8\xD4\xE6\xF0\xB6\xF5\xB3\x08\x03\x1E\xF1\x0D\x05\xF9\x1E\xEA\x06\x13\xFA\x1A\x2B\x03\x9B\xF4\x0D\x1B\xF5\x36\x06\xF1\x96\xF7\x98\x2E\x03\x1E\xF7\x0D\x1E\xF0\x38\x0E\xE1\xF1\x02\x87\xF2\x03\x1E\xF3\x0E\x1B\xF4\x3A\x0E\xE1\xF5\x02\xB6\xEA\x28\x77\x06\xC3\xF8\x02\x0F\xF9\x07\x1E\xF2\x1E\x1E\xF0\x7B\x05\xE3\xC0\x00\x3E\x0E\xE1\xFD\x02\xCE\xFE\xF2\x1F\x86\x0F\x1E\xF1\x3F\x0F\xF3\xEC\x5C\x20\x05\xFA\x08\x11",
			"\x10\x1E\xF0\x41\x0E\xE1\x83\x06\x87\xE4\x04\x1E\xF5\x10\x1E\xF0\x43\x0E\xE1\x87\x06\xCE\xE8\x04\x48\xFF\xE0\xCA\xF8\xA0\xFC\xF0\x82\xF2\xD7\xF9\xF2\xB9\xF1\x01\x89\x05\xAC\xFE\xF0\xE0\xFA\xD6\xFD\xFA\x66\xFD\xEC\xDE\xF8\xB4\xFB\xF6\x9D\x16\x22\x04\xFB\xE0\xAB\x11\x30\xFA\xAF\x4C\x08\x3A\xF9\x23\x1E\xF0\x8E\x06\xC3\xCF\x04\x0F\xF0\x09\x1E\xF1\x24\x1E\xF0\x92\x06\xC3\xD3\x04\x0F\xF4\x09\x1E\xF1\x25\x1E\xF0\x96\x06\xC3\xD7\x05\xB9\xFB\xF5\xEF\xE4\xE3\xE8\x0D\x99\x07\xF1\xCD\xF0\xB6\xFB\xF0\x9D\x16\x26\x12\xFC\x7F\x5B\x13\x1E\xF0\x4E\x08\xF9\xF1\xC5\x27\x1D\xFC\xCD\x16\x13\x1B\xF5\x4F\x0B\xE9\xA0\x04\xE8\xE9\xFB\x56\x19\x14\x1E\xF0\x51\x0E\xE1\xA3\x06\x87\xE4\x05\x1E\xF5\x14\x1E\xF0\x53\x0B\xE9\xA7\x06\x87\xE8\x05\x2F\xFE\xA6\x2A\x04\x0F\xFB\x0A\x1E\xF0\x2B\x1E\xF0\xAD\x06\xC3\xEE\x04\x9D\xFF\x0A\x1E\xF0\x2C\x07\xFD\x6D\xFB\xAB\x71\x04\x0F\xF2\x0B\x48\xFE\xF5\x53\x05\xCE\xFC\x16\x1E\xF1\x5A\x0E\xE1\xB6\x06\x87\xF7\x05\x1E\xF0\x17\x1E\xF1\x5C\x0E\xE1\xBA\x06\xF3\xFC\xFA\x93\xF9\xFC\xC6\xF0\xB5\xF5\xF9\xE3\xFD\xB2",
			"\xF9\xD2\xBB\x06\xC3\xFC\x05\xEF\xFF\x6B\xBD\x04\xFB\xE8\x10\xBE\x03\xD3\xFF\x05\x4D\xF0\x0C\x6F\xFF\xD9\xFD\x14\xC1\x06\xC3\xC2\x06\x0F\xF3\x0C\x1E\xF0\x31\x1E\xF0\xC5\x02\x87\x76\x0C\x1B\x7A\xC7\x02\x87\x78\x0C\x39\x7E\x3F\x16\x32\x0E\xE1\x4B\x03\x1E\x78\x33\x0E\xE1\x4D\x03\x1E\x7A\x33\x0A\xF3\x4F\x03\x1E\x78\x34\x06\xFF\x64\x7F\x32\x35\x34\x0E\xE1\x52\x03\x17\x81\x9A\x23\x0D\x0E\x7F\xD4\x02\x87\x75\x0D\x1E\x78\xD6\x02\x87\x77\x0D\x1E\x78\xD8\x02\x87\x79\x0D\x1E\x78\xDA\x02\xCE\x7B\x0D\x1E\x78\xDC\x01\x07\x88\xF0\x60\x7F\xE6\x7F\x0C\x85\xEB\x67\x7F\x18\x83\x0D\x80\x01\x5D\x03\x32\x81\xE3\x71\xF6\x78\x80\x40\x82\x0D\x8F\x03\x82\x81\xF7\x7C\x66\x2E\x0D\x1E\x78\xDF\x01\x0F\x84\xF9\x74\x80\x0D\x7D\x10\x8E\x03\x85\x81\x4D\x80\x11\x83\xD1\x20\x03\x1E\x79\x38\x0A\x04\xAC\x4D\xE2\x03\x15\x89\x10\x23\x03\x9B\x78\x39\x0B\xE9\x65\x03\x5A\x81\x14\x89\x27\x26\x03\x1E\x7B\x39\x0E\xE1\x68\x03\x1E\x79\x3A\x0E\xE1\x6A\x03\x1E\x7B\x3A\x0B\xE9\x6C\x03\x1E\x79\x3B\x08\x00\x82\x15\xEF\x02\x87\x70\x0F\x1E\x78\xF1\x02\x87\x72\x0F",
			"\x1E\x78\xF3\x02\xCE\x74\x0F\x1E\x78\xF5\x01\x18\x8F\xF5\x48\x2F\xF6\x02\x87\x77\x0F\x02\x82\x4A\x24\x3E\x0E\xFC\x79\x03\x1E\x7A\x3E\x0E\xE1\x7B\x03\x1E\x78\x3F\x0E\xE1\x7D\x03\x1E\x7A\x3F\x06\xE2\x48\x82\xC9\x7E\x18\x8B\x04\xBA\x80\x4F\x81\x0E\x83\x04\x9D\x82\xFF\x74\x00\x0E\x1F\x2E\x77\x40\x4B\x28\x81\xDF\x59\x82\xCD\x0A\x00\x06\x0A\xB5\x77\x6D\x1F\x00\x0B\x0A\xB9\x77\x2D\x08\x01\x0F\x0A\xBD\x77\x2D\x09\x01\x03\x0B\x99\x6D\xA0\x80\x07\x26\x00\x37\x82\x9F\x50\x2F\x84\x25\x7E\x82\x57\x48\x30\x8A\x25\x42\x83\x5D\x48\x31\x85\x2D\x0C\x00\xC6\x81\x8A\x03\x0B\xAC\x78\xB3\x0F\x03\x09\x0C\x90\x00\xC9\x81\x04\x09\x0C\x92\x00\xC9\x83\x04\x09\x0C\xBC\x0B\x14\x01\x32\x85\x01\x17\x83\x9C\x80\x4C\x56\x01\x09\x83\x17\x00\x37\x8E\x35\x58\x00\xE2\x80\x28\x19\x01\x09\x83\x1A\x01\x32\x8B\x01\x09\x83\x1C\x01\x32\x8D\x01\x09\x83\x1E\x01\x32\x8F\x01\x25\x83\x3E\x0C\x08\x09\x0C\xA1\x00\xB3\x83\x6C\x4C\x04\x83\x82\xE5\x7E\x26\x82\xFE\x7E\x83\x35\x81\x2E\x8B\x41\x64\x00\xC9\x81\x09\x04\x0F\x8E\x81\xA8\x06\x09\x07\x10\x9A\x1A\x27\x03",
			"\x42\x89\x27\x28\x00\x0E\x84\x6A\x09\x02\x11\x84\xFF\x82\x4D\x1A\x02\x09\x83\x2B\x01\x32\x8C\x02\x09\x83\x2D\x01\x32\x8E\x02\x09\x83\x2F\x00\x45\x89\x10\x30\x00\xC9\x81\x0C\x0B\x0C\xA1\x13\x33\x01\x32\x84\x03\x09\x83\x35\x01\x32\x86\x03\x09\x83\x37\x02\x48\x81\x2B\x38\x00\xC9\x81\x0E\x02\x13\xBC\x83\x4E\x4E\x0E\x09\x0C\xBB\x00\x37\x86\x30\x4C\x03\x3D\x84\x73\x11\x0F\x09\x0C\xBE\x00\xC9\x83\x0F\x09\x0C\x80\x01\xC9\x81\x10\x09\x0C\x82\x01\xC9\x83\x10\x00\x14\x96\x0B\x44\x01\x32\x85\x04\x39\x83\x15\x84\xEA\x72\x05\x88\x84\x55\x84\x2A\x86\x15\x82\x84\x30\x54\x12\x09\x0C\x89\x01\x4F\x85\x30\x7A\x04\x21\x85\x8F\x13\x12\x0F\x14\x8C\x01\x4F\x85\x13\x04\x16\x9F\x82\x2C\x16\x13\x09\x0C\x8F\x01\xC9\x80\x14\x09\x0C\x91\x01\xC9\x82\x14\x09\x0C\x93\x01\x4F\x84\x15\x09\x0C\x95\x01\x27\x86\x40\x17\x05\x09\x83\x58\x01\x32\x89\x05\x09\x83\x5A\x01\x32\x8B\x05\x2B\x85\x18\x08\x17\x09\x0C\x9D\x01\x88\x86\x27\x87\x32\x5E\x01\xC9\x83\x17\x0D\x18\x8B\x3C\x60\x03\x64\x85\x3A\x21\x01\xC9\x82\x18\x09\x0C\xA3\x01\xC9\x80\x19\x09\x0C\xA5",
			"\x01\xC9\x82\x19\x09\x0C\xA7\x01\x96\x85\x9E\x08\x06\x09\x83\x69\x00\x55\x81\x10\x9B\x82\x6C\x85\x56\x8D\x0F\xB8\x84\xDD\x82\x6B\x81\xCC\x6C\x01\xA5\x84\x6B\x80\x05\xB0\x86\xAD\x87\x6A\x82\x1B\xB1\x86\xBA\x87\xEC\x0D\x06\x35\x86\xBB\x85\x6E\x80\x10\x83\x87\xB8\x87\x6D\x8B\x15\xB6\x86\xA9\x1E\x1B\x00\x1C\xBD\x86\xC4\x87\x71\x81\x1C\x86\x87\x5A\x85\x74\x8A\xCA\x6F\x01\xC9\x80\x1C\x0A\x1A\x8D\x87\xD2\x87\x3E\x8E\x1C\x8C\x87\xC5\x86\x63\x8E\x1D\xB7\x49\x73\x01\x32\x84\x07\x0B\x87\xB9\x69\x1D\x04\x1E\x9D\x10\x76\x03\x53\x87\x07\x0F\x85\x78\x03\x79\x8B\x1D\xBF\x0E\x79\x01\x32\x8A\x07\x09\x83\x7B\x01\x32\x8C\x07\x09\x83\x7D\x01\x32\x8E\x07\x0F\x85\x7F\x01\x32\x80\x08\x3D\x85\x0A\x16\x20\x09\x0C\x83\x02\xC9\x80\x21\x09\x0C\x85\x02\xC9\x82\x21\x0E\x1E\x81\x04\x87\x01\x32\x88\x08\x0B\x88\xAF\x86\x30\x49\x08\x09\x83\x8A\x00\x84\x82\xD3\x0B\x02\x16\x89\x76\x0C\x08\x09\x83\x8D\x01\x32\x8E\x08\x09\x83\x8F\x01\x32\x80\x09\x09\x83\x91\x01\x32\x82\x09\x19\x88\xC2\x85\x77\x88\x15\x9C\x87\xEF\x86\x8A\x87\x15\xAF\x88\xA7\x6F\x24",
			"\x09\x0C\x94\x02\x28\x89\x96\x65\x09\x35\x88\x3E\x0E\x25\x0F\x14\x97\x02\x4F\x84\x26\x08\x23\xAB\x88\xBF\x0D\x26\x09\x0C\x9A\x02\xC9\x83\x26\x09\x0C\x9C\x02\xC9\x81\x27\x09\x0C\x9E\x02\x4F\x87\x27\x09\x0C\xA0\x02\x00\x8A\x4D\x12\x0A\x09\x83\xA3\x01\x32\x84\x0A\x09\x83\xA5\x01\x32\x86\x0A\x10\x88\xA7\x01\x32\x88\x0A\x3F\x88\x30\x88\x4F\x39\x0A\x09\x83\xAA\x00\x98\x86\xD3\x2B\x02\x66\x88\x6A\x0C\x0A\x09\x83\xAD\x01\x32\x8E\x0A\x09\x83\xAF\x01\x32\x80\x0B\x09\x83\xB1\x01\x32\x82\x0B\x10\x88\xB3\x01\x32\x84\x0B\x33\x82\x48\x49\x84\x89\x1D\xBC\x86\xD8\x86\x9F\x82\x28\x9A\x87\x7F\x89\xB0\x58\x0B\x09\x83\xB9\x01\x9A\x8D\x6A\x7A\x02\x8A\x8B\xAA\x0B\x0B\x0F\x85\xBC\x03\x53\x8D\x0B\x0D\x8A\x81\x89\x8B\x0E\x0B\x09\x83\xBF\x01\x32\x80\x0C\x09\x83\xC1\x01\x32\x82\x0C\x09\x83\xC3\x03\x53\x84\x0C\x09\x83\xC5\x01\x94\x8F\x53\x07\x03\xC9\x80\x32\x09\x0C\x89\x03\xC9\x82\x32\x09\x0C\x8B\x03\x10\x88\x33\x09\x0C\x8D\x03\x94\x8A\x8B\x86\xD3\x0E\x03\xC9\x83\x33\x05\x2B\x9F\x2D\xD0\x03\xAE\x81\x10\x11\x03\xC9\x82\x34\x09\x0C\x93\x03",
			"\xC9\x80\x35\x09\x0C\x95\x03\xC9\x82\x35\x09\x0C\x97\x03\x10\x88\x36\x09\x0C\x99\x03\x7C\x8B\x73\x8F\x1D\xA1\x89\xD2\x88\x90\x86\x2B\x88\x87\xD6\x88\x4A\x3D\x0D\x09\x83\xDE\x02\xAF\x84\x9E\x5F\x03\xDE\x89\x8B\x00\x0E\x0F\x85\xE1\x03\x53\x82\x0E\x21\x8B\x80\x89\xB3\x03\x0E\x09\x83\xE4\x01\x32\x85\x0E\x09\x83\xE6\x01\x32\x87\x0E\x09\x83\xE8\x03\x53\x89\x0E\x09\x83\xEA\x02\xA9\x82\x54\x2C\x03\xC9\x81\x3B\x09\x0C\xAE\x03\xC9\x83\x3B\x09\x0C\xB0\x03\x10\x89\x3C\x09\x0C\xB2\x03\xE8\x89\x8A\x8F\xB5\x33\x03\xC9\x80\x3D\x09\x30\xA8\x28\xF5\x02\xB7\x86\x0F\x09\x83\xF7\x01\x32\x88\x0F\x09\x83\xF9\x01\x32\x8A\x0F\x09\x83\xFB\x01\x32\x8C\x0F\x10\x88\xFD\x01\x32\x8E\x0F\x11\x8B\x2C\x89\xA1\x80\x1D\x83\x8A\xE9\x89\x8B\x8A\x32\xA6\x8C\x09\x42\x00\x01\x20\x24\x82\x01\x07\x00\x0F\x32\xA7\x82\x28\x8C\x82\x04\x00\x33\x8C\xAC\x80\xBB\x15\x00\x38\x8C\xB0\x81\x76\x06\x00\x3C\x8C\xB4\x81\x76\x07\x00\x00\x8D\xB8\x80\xB6\x8A\x69\x08\x00\x44\x8D\x57\x69\x34\x9B\x05\x4B\x8E\x41\x0B\x00\x0D\x8D\x03\x04\x03\x00\x35\x82\x04\x0D\x03\xD4\x85",
			"\x2D\x0E\x00\x56\x8C\x00\x0F\x00\x00\x8D\xCC\x83\xEF\x01\x01\x19\x8D\x12\x01\xD6\x83\x01\x19\x8D\x14\x01\xD6\x85\x01\x19\x8D\xFC\x0A\x05\x09\x35\x97\x00\x68\x8D\xCA\x89\x6B\x58\x00\x59\x8D\x06\x0D\x36\x9E\x4D\x1A\x03\xDC\x80\x4A\x1B\x00\x59\x8C\x07\x09\x35\x9D\x00\x59\x8E\x07\x09\x35\x9F\x00\x59\x8C\x08\x09\x35\xA1\x00\x76\x8E\xCF\x02\x02\x19\x8D\x23\x00\xD0\x8D\x27\x84\x8A\x35\x8F\xC9\x8C\x38\x8F\x8E\x6E\x8D\xE3\x83\x2D\x9C\x85\x0A\x07\x09\x05\x38\x99\x8B\x2C\x8C\xE6\x82\x39\x9A\x8E\x90\x8E\xC2\x89\x39\xBF\x0F\x97\x8C\xB5\x85\x32\x9B\x8E\xA2\x8D\xA5\x81\x39\x9D\x8E\x8E\x8C\x10\x29\x02\x21\x8E\x94\x8F\xE8\x88\x3A\x93\x8E\x46\x8D\xEB\x86\x3A\x9E\x8E\xAE\x5A\x0A\x0C\x3A\xB1\x8E\xB8\x8D\xB5\x85\x3A\x97\x8B\xBA\x8E\xEC\x8D\xE3\x2B\x00\x59\x8C\x0B\x0A\x38\xBD\x8E\xB9\x8E\xEB\x87\x3A\x87\x8F\xB4\x8F\xEB\x8C\x39\xB8\x1B\x30\x01\xD6\x81\x03\x37\x8E\x72\x72\x0C\x00\x3D\x82\x14\x33\x03\xF4\x86\x10\x34\x00\xD6\x8F\x40\x05\x03\x19\x8F\x2B\x8F\x50\x16\x03\x19\x8D\x37\x01\xD6\x88\x03\x19\x8D\x39\x01\xD6\x8A\x03\x19\x8D\x3B",
			"\x00\xF7\x81\x10\x3C\x00\x59\x8D\x0F\x0C\x35\xA1\x13\x3F\x01\xD6\x80\x04\x19\x8D\x41\x01\xD6\x82\x04\x19\x8D\x43\x02\xFA\x80\x15\x99\x8D\x45\x02\xFE\x8A\x3C\x90\x40\x46\x01\xD6\x87\x04\x3E\x8F\xCB\x38\x12\x04\x40\x82\x0C\x49\x01\xD6\x8A\x04\x19\x8D\x4B\x01\xD6\x8C\x04\x19\x8D\x4D\x01\xD6\x8E\x04\x19\x8D\x4F\x03\x01\x99\x3A\x89\x8F\xC8\x8F\x05\x9A\x41\xB0\x8E\xC4\x8D\x07\x9F\xB7\x10\x01\x59\x8D\x14\x06\x41\xA4\x7F\x52\x03\x08\x90\x4C\x13\x01\xFA\x8C\x15\x0A\x3F\x95\x01\x26\x93\xEE\x8F\x53\x16\x01\x59\x8F\x15\x09\x35\x98\x01\x59\x8D\x16\x09\x35\x9A\x01\x59\x8F\x16\x0A\x3F\x9C\x01\x59\x8D\x17\x0F\x3E\xA9\x15\x59\x8C\x18\x09\x35\xA1\x01\x59\x8E\x18\x09\x35\xA3\x01\x2D\x91\x9E\x04\x06\x19\x8D\x65\x01\x12\x95\x3C\xAE\x36\x66\x01\xD6\x87\x06\x0E\x91\x38\x34\x1A\x04\x45\xAB\x0A\x69\x01\xD6\x8A\x06\x19\x8D\x6B\x01\xD6\x8C\x06\x19\x8D\x6D\x01\xD6\x8E\x06\x19\x8D\x6F\x03\x15\x96\x10\x30\x01\x59\x8D\x1C\x0F\x43\xB3\x8E\x1B\x93\xF2\x88\x41\xAF\x91\x6D\x92\x0B\x9F\x39\x8A\x2D\x73\x01\xD6\x84\x07\x26\x91\x3D\x71\x1D\x08\x47",
			"\xAA\x11\x76\x02\xFE\x87\x07\x3A\x8F\x78\x03\x1E\x93\x47\x83\x0F\x79\x01\xD6\x8A\x07\x19\x8D\x7B\x01\xD6\x8C\x07\x19\x8D\x7D\x01\xD6\x8E\x07\x3A\x8F\x7F\x01\xD6\x80\x08\x2B\x91\x36\x16\x20\x09\x35\x83\x02\x59\x8C\x21\x09\x35\x85\x02\x59\x8E\x21\x02\x48\x80\x00\x87\x01\xD6\x88\x08\x1F\x92\xFF\x8E\x4D\x39\x08\x19\x8D\x8A\x00\x29\x9C\xBE\x0B\x02\xAA\x90\x82\x0C\x08\x19\x8D\x8D\x01\xD6\x8E\x08\x19\x8D\x8F\x01\xD6\x80\x09\x19\x8D\x91\x01\xD6\x82\x09\x1F\x92\x93\x01\xD6\x84\x09\x14\x92\xDD\x8D\x29\x9F\x44\xBC\x8E\xC6\x8C\x1C\x9C\x41\x85\x93\x71\x92\xEF\x81\x4C\xB9\x0B\x96\x01\x2B\x99\x4C\x83\x93\xCB\x92\x31\x9E\x46\x8F\x93\x1E\x91\xA0\x87\x09\x0E\x93\xC7\x90\x1B\x99\x4D\x84\x93\xDA\x90\x92\x08\x09\x19\x8D\x99\x00\x30\x93\x48\x95\x93\xDC\x91\x39\x91\x4D\x94\x93\xC8\x93\x36\x96\x6D\x1B\x02\x59\x8C\x27\x08\x4D\x8E\x68\x9D\x03\x3B\x95\x3A\x1E\x02\xFA\x8F\x27\x0A\x3F\xA0\x02\xF2\x92\x32\x93\x47\x21\x02\x59\x8E\x28\x09\x35\xA3\x02\x59\x8C\x29\x09\x35\xA5\x02\x59\x8E\x29\x0A\x3F\xA7\x02\x59\x8C\x2A\x02\x4E\x83\x15\xAA\x01",
			"\xD6\x8B\x0A\x19\x8D\xAC\x01\xD6\x8D\x0A\x19\x8D\xAE\x03\x27\x9F\x0A\x19\x8D\xB0\x01\x3E\x90\x4D\x88\x2F\xB1\x01\xD6\x82\x0B\x1A\x94\x12\x30\x48\x99\x10\x34\x02\x59\x8D\x2D\x09\x35\xB6\x02\x59\x8F\x2D\x09\x35\xB8\x02\x59\x8D\x2E\x09\x35\xBA\x02\x22\x95\x37\x92\x47\xA4\x8E\xFA\x90\x4D\x9B\x51\xB6\x94\xE4\x93\xD7\x2B\x0B\x19\x8D\xBC\x01\x4C\x9E\x94\x7D\x02\x3E\x96\xB4\x0E\x0B\x3A\x8F\xBF\x02\xFE\x80\x0C\x01\x95\xE3\x93\xAA\x01\x0C\x19\x8D\xC2\x01\xD6\x83\x0C\x19\x8D\xC4\x01\xD6\x85\x0C\x19\x8D\xC6\x02\xFE\x87\x0C\x19\x8D\xC8\x03\x42\x98\x49\x0A\x03\x59\x8F\x32\x09\x35\x8C\x03\x59\x8D\x33\x09\x35\x8E\x03\x9F\x93\x33\x09\x35\x90\x03\x48\x94\x4E\x9F\xB7\x11\x03\x59\x8E\x34\x09\x56\xA7\x2D\xD3\x01\x5A\x94\x0D\x19\x8D\xD5\x01\xD6\x86\x0D\x19\x8D\xD7\x01\xD6\x88\x0D\x19\x8D\xD9\x01\xD6\x8A\x0D\x1F\x92\xDB\x01\xD6\x8C\x0D\x00\x8D\x98\x5A\x5A\x92\x53\xB5\x94\xC2\x91\x4E\x99\x54\x87\x96\x37\x94\x26\x12\x0E\x19\x8D\xE3\x03\x5B\x9F\x6B\x64\x03\x92\x94\x82\x05\x0E\x3A\x8F\xE6\x02\xFE\x87\x0E\x15\x96\xE8\x92\x41\x08\x0E\x19",
			"\x8D\xE9\x01\xD6\x8A\x0E\x19\x8D\xEB\x01\xD6\x8C\x0E\x19\x8D\xED\x02\xFE\x8E\x0E\x19\x8D\xEF\x02\x56\x9F\x48\x31\x03\x59\x8E\x3C\x09\x35\xB3\x03\x59\x8C\x3D\x09\x35\xB5\x03\x9F\x92\x3D\x09\x35\xB7\x03\x9C\x96\x3A\x98\xBC\x38\x03\x59\x8D\x3E\x0D\x5B\xA9\x29\xFA\x01\x5A\x9B\x0F\x19\x8D\xFC\x01\xD6\x8D\x0F\x19\x8D\xFE\x00\xDA\x89\x35\x83\x08\xD1\x25\x00\x04\x20\x30\x8C\x74\x12\x00\x03\x5D\xB4\x8C\x03\x03\x75\x9F\x87\x0A\x96\x86\x96\x39\x9B\x58\x9E\x97\xDD\x97\x39\x9E\x5B\xB0\x20\x09\x02\x76\x99\xDF\x4A\x00\xE6\x95\xD0\x84\x3B\x8B\x00\xE9\x95\xD1\x81\x4E\x0C\x00\xED\x95\xA7\x0D\x00\x31\x97\xAB\x0A\x03\x04\x5F\x8C\x96\xE1\x13\x03\x07\x5F\x83\x04\x10\x03\x7E\x92\x10\x11\x00\xFE\x95\x40\x02\x01\x01\x98\x00\x03\x04\x04\x60\x94\x00\x04\x99\x8B\x05\x01\x04\x98\x16\x01\x7A\x9D\x35\x9D\x10\x18\x00\x81\x99\x01\x04\x98\x1A\x00\x81\x9B\x01\x04\x98\x1C\x01\x82\x99\x2F\x1D\x00\x04\x9A\x07\x0A\x61\x92\x93\xC8\x4F\x07\x04\x60\xA0\x00\x1F\x9B\xC9\x41\x02\x25\x98\xAF\x12\x08\x04\x60\xA3\x00\x04\x98\x09\x04\x60\xA5\x00\x04\x9A\x09",
			"\x04\x60\xA7\x00\x04\x98\x0A\x08\x62\x96\x0D\x29\x00\x81\x9A\x02\x29\x97\x85\x95\x62\x99\x4E\x93\x93\xE3\x96\x8F\x98\x5F\xBF\x98\x33\x94\x26\x10\x03\x04\x98\x31\x03\x8D\x93\x53\xB2\x00\x4A\x9B\x98\x13\x03\x0D\x99\xA8\x04\x0D\x00\x65\x8A\x04\x35\x03\x94\x94\x64\xAE\x66\x04\x9B\x0D\x04\x60\xB8\x00\x04\x99\x0E\x04\x60\xBA\x00\x04\x9B\x0E\x06\x65\x86\x04\x3C\x00\x81\x9D\x03\x0E\x98\xF0\x8C\x81\x90\x04\x04\x98\x41\x00\x81\x92\x04\x04\x98\x43\x03\x98\x9D\x2C\x04\x01\x04\x99\x11\x02\x67\xA2\x97\x0B\x3E\x11\x04\x60\x87\x01\x77\x9B\xAE\x48\x04\x3D\x99\x74\x11\x12\x04\x60\x8A\x01\x04\x9B\x12\x04\x60\x8C\x01\x04\x99\x13\x04\x60\x8E\x01\x04\x9B\x13\x00\x68\xAD\x08\x50\x00\x81\x91\x05\x3C\x98\xDC\x96\x90\x90\x5E\x96\x9A\x78\x99\x91\x99\x41\x81\x99\x8F\x13\x15\x04\x60\x98\x01\x8F\x9A\x2D\x79\x05\x21\x9A\xA9\x12\x16\x00\x68\x9B\x01\x80\x98\x17\x04\x6A\x9D\x96\x1D\x11\x17\x04\x60\x9E\x01\x04\x9B\x17\x04\x60\xA0\x01\x04\x99\x18\x04\x60\xA2\x01\x80\x9B\x18\x04\x60\xA4\x01\x68\x9A\x40\x16\x06\x04\x98\x67\x00\x81\x98\x06\x04\x98",
			"\x69\x00\x81\x9A\x06\x2B\x9A\x28\x0B\x1A\x04\x60\xAC\x01\xC8\x98\x90\x9B\xF0\x2D\x01\x04\x9A\x1B\x0D\x6C\x90\x40\x6F\x03\xB4\x95\x34\x44\x98\x71\x00\x81\x92\x07\x04\x98\x73\x00\x81\x94\x07\x04\x98\x75\x00\x81\x96\x07\x16\x9B\xA8\x07\x1D\x04\x60\xB8\x01\x94\x9B\x95\x9D\x58\x9B\x9A\xCE\x9A\xA6\x90\x62\x88\x96\xEC\x98\x07\x2E\x07\x04\x98\x7F\x00\xB9\x9E\x9F\x40\x02\xF6\x9B\xEC\x01\x08\x00\x9A\x82\x00\xA0\x93\x08\x39\x9B\x43\x99\xAC\x04\x08\x04\x98\x85\x00\x81\x96\x08\x04\x98\x87\x00\x81\x98\x08\x04\x98\x89\x00\xA0\x9A\x08\x04\x98\x8B\x01\xAF\x9A\x50\x0D\x02\x04\x9A\x23\x04\x60\x8F\x02\x04\x98\x24\x04\x60\x91\x02\x00\x9F\x40\x02\x09\x04\x98\x93\x01\xC7\x99\x69\xB6\x34\x94\x00\x81\x95\x09\x22\x9C\xF2\x3A\x25\x08\x72\x96\x0B\x97\x00\x81\x98\x09\x04\x98\x99\x00\x81\x9A\x09\x04\x98\x9B\x00\x81\x9C\x09\x04\x98\x9D\x03\xCA\x9E\x09\x04\x98\x9F\x01\xBA\x91\x70\x97\x9A\xF1\x98\xBC\x9F\x6E\xAB\x9B\x43\x9D\xA5\x91\x39\xA5\x02\x2B\x9C\xA6\x9F\x5D\xA3\x9C\x44\x9C\xAB\x9C\x74\x86\x9D\x1C\x36\x29\x09\x74\x81\x9D\x4D\x9C\xA7\x95",
			"\x74\xAA\x9B\x50\x9E\xD3\x9B\x2B\x67\x02\x53\x9F\xD5\x9F\x73\x8F\x9D\x58\x9D\xD8\x9F\x75\x8B\x9D\x64\x9C\x00\x08\x0A\x1D\x9D\x5A\x9D\x78\x95\x76\x8A\x9D\x6A\x9D\xDB\x9C\x76\xB4\x68\xA9\x00\xDA\x96\x75\xA9\x9D\x6F\x9C\xD5\x99\x75\xB3\x9D\x78\x9F\x9D\x4A\x0A\x32\x9D\xED\x9A\xD0\x94\x77\xB6\x9D\x62\x9C\xD0\x9E\x75\x8D\x0B\xAB\x00\x81\x9C\x0A\x3E\x9C\x82\x9F\xDF\x93\x78\xA0\x9D\x63\x9E\xDB\x90\x78\x8D\x9E\xB2\x00\x81\x93\x0B\x3C\x9D\xA7\x68\x2D\x04\x79\x9B\x0E\xB5\x00\xA0\x96\x0B\x00\x9A\xB7\x03\xE5\x95\x75\x88\x09\xB8\x00\x81\x99\x0B\x04\x98\xBA\x00\x81\x9B\x0B\x04\x98\xBC\x00\x81\x9D\x0B\x00\x9A\xBE\x00\x81\x9F\x0B\x12\x9C\x36\x15\x30\x04\x60\x82\x03\x04\x9B\x30\x04\x60\x84\x03\x04\x99\x31\x0B\x72\x86\x03\x04\x9B\x31\x0E\x79\xB7\x9D\xDC\x20\x32\x04\x60\x89\x03\xBF\x9F\xDF\x2A\x0C\x05\x9F\x06\x07\x32\x04\x60\x8C\x03\x04\x99\x33\x04\x60\x8E\x03\x04\x9B\x33\x04\x60\x90\x03\x04\x99\x34\x08\x7C\x89\x9E\x79\x9E\xBB\x9A\x78\x9B\x9F\xD9\x9E\xDF\x9D\x7D\xAB\x1B\xD2\x00\x81\x93\x0D\x17\x9F\x02\x64\x35\x04\x7E\x95\x0B\xD5",
			"\x00\xA0\x96\x0D\x00\x9A\xD7\x03\xF9\x9E\x78\x88\x08\xD8\x00\x81\x99\x0D\x04\x98\xDA\x00\x81\x9B\x0D\x04\x98\xDC\x00\x81\x9D\x0D\x00\x9A\xDE\x00\x81\x9F\x0D\x30\x9E\x3F\x15\x38\x04\x60\xA2\x03\x04\x9B\x38\x04\x60\xA4\x03\x04\x99\x39\x0B\x72\xA6\x03\x04\x9B\x39\x0E\x7E\xB5\x9D\xFD\x20\x3A\x04\x60\xA9\x03\x0F\xA2\x63\x2A\x0E\x2E\x9F\xEB\x00\x81\x9C\x0E\x04\x98\xED\x00\x81\x9E\x0E\x04\x98\xEF\x00\x81\x90\x0F\x04\x98\xF1\x03\xCA\x92\x0F\x04\x98\xF3\x01\x05\xAB\x78\xAB\x9D\x8F\x9C\xF6\x9D\x77\x9F\x9E\xDA\x9F\xF7\x90\x7C\xB1\xA0\xE0\x54\x3D\x0A\x82\x9C\x9F\x2F\xA3\x0C\xAE\x7D\xB7\x49\xF5\x00\x81\x96\x0F\x37\xA0\x32\xA1\xE0\x9C\x78\xAE\xA0\x34\xA1\x11\xAB\x83\xB3\x94\xF7\x00\x81\x98\x0F\x00\xA1\xE0\x55\x3E\x0C\x84\x9D\x09\xFA\x00\xA0\x9B\x0F\x00\x9A\xFC\x03\x13\xA7\x84\xB9\x09\xFD\x00\x81\x9E\x0F\x09\x98\x04\x99\x8A\x01\x5D\xAA\x08\xD4\x96\x00\x00\x86\xB4\x8C\x2D\x0B\x00\x03\x86\xB9\x8C\x04\x03\x19\xA1\x10\x0F\x98\x6A\x12\x01\x0A\x86\xBD\x77\x07\x03\x1B\xAF\x1C\x08\x00\x72\xA1\x57\x65\x87\x9B\x05\x77\xA3\xEF\x0B\x00",
			"\x39\xA1\x51\x8C\x1F\xA3\x84\x82\x43\x0D\x02\x1F\xA1\x10\x0E\x00\x82\xA2\xAB\x5F\x00\x05\xA2\x98\x10\x04\x05\x88\x91\x00\x85\xA2\x04\x05\x88\x93\x00\x85\xA0\x05\x05\x88\x95\x00\x85\xA2\x05\x08\x88\xAD\xA0\x7F\xA0\x0B\xAB\x82\xAF\x9F\x38\xA2\x11\xA0\x83\xB4\x1E\x17\x01\x21\xA8\x01\x17\xA2\xB4\x8D\x06\x04\x8A\x8E\x18\x1A\x03\x29\xA8\x22\x1B\x00\xAA\xA0\x92\x0C\x01\x2D\xA2\x9E\xA1\x38\x1D\x01\x05\xA2\x1E\x01\x21\xAF\x01\x05\xA2\x20\x01\x21\xA1\x02\x05\xA2\x22\x00\x2C\xA9\x27\x23\x00\x85\xA0\x09\x0F\x86\xAC\xA1\x73\x12\x09\x05\x88\xA7\x00\x85\xA0\x0A\x05\x88\xA9\x00\x85\xA2\x0A\x0E\x8B\xA3\x0A\x2B\x01\x21\xAC\x02\x0F\xA3\x3A\xA2\xD3\x2D\x02\x05\xA2\x2E\x00\x35\xAC\x00\x6F\x00\xDA\xA3\xEF\x00\x03\x05\xA2\x31\x01\x21\xA2\x03\x05\xA2\x33\x01\x21\xA4\x03\x05\xA2\x35\x01\x21\xA6\x03\x1D\xA3\x11\x55\x21\xA8\x03\x2C\xA3\x99\xA0\x27\xA1\x84\x8D\x9E\x10\xA1\x27\xA7\x85\x9F\xA2\xF8\xA1\x35\xA1\xFD\x39\x00\xF0\xA2\x26\xA6\x8F\xB9\xA3\x42\xA1\xAE\x5A\x03\x05\xA2\x3B\x01\x3F\xA2\x8F\xB9\xA0\x01\xA7\x41\xA1\x8B\x89\xA4\xF5\xA3",
			"\x78\x9C\x03\x05\xA2\x3D\x02\x41\xA1\xCC\x7E\x00\x12\xA7\x23\x1F\x03\x06\xA4\x40\x02\x41\xA1\x04\x15\xA4\x9B\xA0\xBF\x02\x04\x05\xA2\x43\x01\x21\xA4\x04\x05\xA2\x45\x01\x21\xA6\x04\x05\xA2\x47\x02\x41\xA8\x04\x05\xA2\x49\x03\x30\xA1\x4E\x0B\x01\x85\xA0\x13\x05\x88\x8D\x01\x85\xA2\x13\x05\x88\x8F\x01\x1C\xA4\x86\x00\x05\x05\xA2\x51\x01\x4E\xA3\x8F\xBD\x38\x52\x01\x21\xA3\x05\x3E\xA4\x0B\x3C\x15\x04\x94\xA5\x0E\x55\x01\x21\xA6\x05\x05\xA2\x57\x01\x21\xA8\x05\x05\xA2\x59\x01\x21\xAA\x05\x05\xA2\x5B\x03\x51\xA7\x8F\xBA\xA3\x0C\xA4\x26\xAE\x8F\xBF\xA4\xF1\xA1\x43\xA8\x24\x1C\x01\x85\xA1\x17\x06\x95\x90\x70\x5E\x03\x58\xA9\x39\x1F\x01\x06\xA4\x18\x06\x90\xA1\x01\x66\xA5\x56\xA8\x20\x22\x01\x85\xA3\x18\x05\x88\xA4\x01\x85\xA1\x19\x05\x88\xA6\x01\x85\xA3\x19\x06\x90\xA8\x01\x85\xA1\x1A\x0E\x92\x82\x14\x6B\x01\x21\xAC\x06\x05\xA2\x6D\x01\x21\xAE\x06\x05\xA2\x6F\x01\x5B\xA7\x46\x85\xA2\x71\x02\x62\xA4\x84\xB6\x34\x72\x01\x21\xA3\x07\x0E\xA6\x28\x34\x1D\x04\x99\x95\x0B\x75\x01\x21\xA6\x07\x05\xA2\x77\x01\x21\xA8\x07\x05",
			"\xA2\x79\x01\x21\xAA\x07\x05\xA2\x7B\x03\x65\xAB\xF3\x45\xA2\x7D\x02\x69\xAE\x95\x8B\xA4\xF4\xA2\x56\xAA\x90\x97\xA5\x6E\xA7\x3F\xA8\x95\xAD\xA6\x1C\x36\x1F\x0A\x9A\xAE\xA6\xAB\xA4\x6C\xA4\x9B\xA5\x30\x7F\x01\x21\xA0\x08\x37\xA6\x1D\xA4\x6E\xA2\x9C\x81\xA7\xC4\xA6\x6C\xA1\x9B\x8C\x50\x81\x01\x21\xA2\x08\x00\xA7\x59\x6B\x20\x0C\x9C\xBE\x0C\x84\x02\x41\xA5\x08\x06\xA4\x86\x03\x73\xA8\x90\xB1\x0A\x87\x01\x21\xA8\x08\x05\xA2\x89\x01\x21\xAA\x08\x05\xA2\x8B\x01\x21\xAC\x08\x06\xA4\x8D\x01\x21\xAE\x08\x3F\xA5\x0A\x14\x24\x05\x88\x91\x02\x85\xA2\x24\x05\x88\x93\x02\x85\xA0\x25\x06\x9A\x95\x02\x85\xA2\x25\x06\x9D\xAC\xA6\xD5\x2F\x25\x05\x88\x98\x02\xF7\xA6\x4D\x39\x09\x3D\xA7\xA8\x06\x26\x05\x88\x9B\x02\x85\xA0\x27\x05\x88\x9D\x02\x85\xA2\x27\x05\x88\x9F\x02\x85\xA0\x28\x00\xA0\xB3\xA6\x8F\xA4\x40\xAB\x9B\x9C\xA5\x5B\xA7\x75\xA0\x5E\xA1\x02\x85\xA2\x28\x0F\xA0\x99\x5C\xA3\x03\x86\xA1\x2B\x24\x02\x06\xA5\x29\x06\x90\xA6\x02\x1E\xA9\x84\xAA\x10\x27\x02\x85\xA0\x2A\x05\x88\xA9\x02\x85\xA2\x2A\x05\x88\xAB\x02\x85\xA0\x2B",
			"\x06\x90\xAD\x02\x85\xA2\x2B\x08\x9E\xB6\x14\xB0\x01\x21\xA1\x0B\x05\xA2\xB2\x01\x21\xA3\x0B\x05\xA2\xB4\x02\x69\xA5\x0B\x05\xA2\xB6\x01\x89\xAD\x95\x80\x21\xB7\x01\x21\xA8\x0B\x06\xA9\xC8\x2D\x2E\x0C\xA4\x80\x00\xBA\x01\x21\xAB\x0B\x05\xA2\xBC\x01\x21\xAD\x0B\x05\xA2\xBE\x01\x21\xAF\x0B\x05\xA2\xC0\x02\x69\xA1\x0C\x05\xA2\xC2\x03\x93\xA9\x9B\x92\xA8\x26\xAB\x71\xA6\xA1\x87\xA9\xC5\xA4\x85\xAE\xE3\x03\x03\x62\xAB\x70\xA6\x9C\x93\xA8\x67\xA9\x85\xA8\x9F\x8A\x25\xC4\x01\x21\xA5\x0C\x2D\xA9\x69\xA9\x9C\xAF\x9A\xA4\xA9\x68\xAB\x9B\xA5\xA6\x8C\x41\xC6\x01\x21\xA7\x0C\x38\xA9\xC3\x58\x32\x04\xA8\xA8\x08\xC9\x02\x41\xAA\x0C\x06\xA4\xCB\x03\xA1\xAA\xA7\x8C\x03\x85\xA1\x33\x05\x88\x8E\x03\x85\xA3\x33\x05\x88\x90\x03\x85\xA1\x34\x06\x90\x92\x03\x85\xA3\x34\x07\xA3\xBF\x14\xD5\x01\x21\xA6\x0D\x05\xA2\xD7\x01\x21\xA8\x0D\x05\xA2\xD9\x02\x69\xAA\x0D\x05\xA2\xDB\x02\xA3\xA3\xA7\xAA\x27\xDC\x01\x21\xAD\x0D\x2E\xAA\x4A\x2E\x37\x0F\xA4\x9F\x03\x85\xA0\x38\x05\x88\xA1\x03\x85\xA2\x38\x05\x88\xA3\x03\x85\xA0\x39\x05\x88\xA5\x03",
			"\xA6\xA6\x39\x05\x88\xA7\x03\xB4\xA8\x9F\xA2\xA7\xBA\xA6\x7F\xA9\xB3\xAD\xA7\xAA\xA9\x63\xA8\x84\xAF\xAC\xBA\xA9\xD1\xAA\x99\xAF\xAA\xBB\xA9\x61\x18\x3A\x05\x88\xA9\x03\xC9\xA8\xDB\x4A\x0E\x1D\xAB\x09\x07\x3A\x06\x90\xAC\x03\x06\xA5\x3B\x00\xAE\x81\x8A\xEE\x01\x21\xAF\x0E\x05\xA2\xF0\x01\x21\xA1\x0F\x05\xA2\xF2\x01\x21\xA3\x0F\x06\xA4\xF4\x01\x21\xA5\x0F\x1F\xAA\x42\x17\x3D\x05\x88\xB8\x03\x85\xA1\x3E\x05\x88\xBA\x03\x85\xA3\x3E\x06\x9A\xBC\x03\x85\xA1\x3F\x07\xAE\x8E\xAB\xC4\x22\x3F\x08\x88\x87\xAC\x4A\x24\x00\x08\x6B\x6E\x97\xB3\x0D\x00\x0F\xB0\xB3\x21\x13\xAE\x1D\x25\xB1\xB9\x21\x17\xAC\x1F\x29\xB1\xBF\x21\x1B\xAE\x20\x2D\xB1\xB0\x20\x08\x03\xC7\xA9\x00\x1F\xAC\x8C\x8E\x02\x04\xB2\x9D\x22\x27\xAC\x82\x0C\x00\x29\xAC\x18\x09\x03\x0C\xB2\x90\xAB\x8F\x12\x03\x0F\xB1\x8F\x00\x1F\xAC\x04\x0F\xB1\x91\x00\x1F\xAE\x04\x0F\xB1\x93\x00\x2F\xAC\x92\x04\x01\x1F\xAC\x15\x00\xAE\x54\x8C\xB4\x11\x17\x03\xC7\xA8\x01\x1F\xAC\x19\x03\xC7\xAA\x01\x1F\xAC\x1B\x01\xCF\xA5\x3A\x1C\x00\x1F\xAD\x07\x0E\xB4\x8C\xAB\xC2\x42\x07\x0F",
			"\xB1\x9F\x00\x53\xAC\x30\x40\x02\x19\xAD\x99\x0D\x08\x0F\xB1\xA2\x00\x1F\xAF\x08\x0F\xB1\xA4\x00\x1F\xAD\x09\x0F\xB1\xA6\x00\x1F\xAF\x09\x0C\xB5\xAB\x0A\x28\x03\xDA\xA0\xA7\x97\xAB\xD5\xAB\xDB\xA4\xB5\x8B\xAB\xCA\xA8\xB6\xA3\x3A\xA9\x00\x6E\xAC\xC2\xA6\xB7\xB2\xAD\x75\xAD\xDC\xAA\xB7\xBE\xAD\x01\x22\x0A\x09\xB7\x93\xAB\x70\xAE\x9B\xA0\xB3\xB9\xA9\x85\xAE\xD7\x4B\x02\x1F\xAC\x2C\x03\xE0\xA2\x1D\xAD\x00\x8E\xAF\x50\x1E\x02\x11\xAE\x2F\x01\xE4\xA0\x03\x11\xAE\x80\xAD\xB5\x01\x03\x1F\xAC\x32\x03\xC7\xA3\x03\x1F\xAC\x34\x03\xC7\xA5\x03\x1F\xAC\x36\x01\xE4\xA7\x03\x1F\xAC\x38\x02\xD0\xA1\x4E\x3A\x00\x1F\xAF\x0E\x0F\xB1\xBC\x00\x1F\xAD\x0F\x0F\xB1\xBE\x00\x98\xAD\x76\x0F\x03\x1F\xAC\x40\x01\xED\xA8\xB8\xB6\x34\x41\x03\xC7\xA2\x04\x3A\xAE\xCA\x3F\x10\x00\xBC\xBE\x0C\x44\x03\xC7\xA5\x04\x1F\xAC\x46\x03\xC7\xA7\x04\x1F\xAC\x48\x03\xC7\xA9\x04\x1F\xAC\x4A\x03\xF0\xA8\x24\x0B\x01\x1F\xAC\x13\x02\xBD\x89\xAE\x7E\xA8\xE1\xA3\xB7\xBB\xAD\x7F\xAE\xE1\xA4\xAD\x9E\xAF\xD8\xAF\xE1\xA9\xBD\xB4\xAD\xD2\xA8\xF9\xA8\x99\x0D\x01\x1F",
			"\xAE\x13\x07\xBD\x8A\x7C\x4F\x03\xFA\xA3\x3C\x10\x01\x91\xAD\x14\x01\xB9\x92\x01\xEE\xAD\xF9\xA0\x00\x13\x01\x1F\xAC\x15\x0F\xB1\x95\x01\x1F\xAE\x15\x0F\xB1\x97\x01\x1F\xAC\x16\x01\xB9\x99\x01\x1F\xAE\x16\x0A\xBA\x82\x14\x5C\x03\xC7\xAD\x05\x1F\xAC\x5E\x03\xC7\xAF\x05\x1F\xAC\x60\x01\xFD\xA9\x10\x21\x01\x1F\xAE\x18\x02\xC1\xBC\xAD\x12\x27\x18\x0F\xB1\xA4\x01\x17\xB1\x8F\x35\x06\x1D\xB0\xD2\x0A\x19\x0F\xB1\xA7\x01\x1F\xAC\x1A\x0F\xB1\xA9\x01\x1F\xAE\x1A\x0F\xB1\xAB\x01\x1F\xAC\x1B\x00\xC2\x81\x04\x6D\x03\x0B\xBC\xBD\x9A\xAF\x7D\xAC\xF8\xAB\xBD\x99\xAE\x33\xB2\xF9\xAE\xDA\x2E\x01\x32\xB0\x0E\xBE\xC3\xB6\xB0\x35\xB3\xEE\xA1\xC4\xA8\x28\x6F\x03\xC7\xA0\x07\x3D\xB0\x89\x69\x1C\x08\xC4\x82\x0C\x72\x01\xE4\xA3\x07\x11\xAE\x74\x03\x12\xB3\xBE\x80\x00\x75\x03\xC7\xA6\x07\x1F\xAC\x77\x03\xC7\xA8\x07\x1F\xAC\x79\x03\xC7\xAA\x07\x11\xAE\x7B\x03\xC7\xAC\x07\x07\xB0\x0A\x16\x1F\x0F\xB1\xBF\x01\x1F\xAC\x20\x0F\xB1\x81\x02\x1F\xAE\x20\x02\xC3\x83\x02\x1F\xAC\x21\x02\xC5\xA2\xAF\xE3\x29\x21\x0F\xB1\x86\x02\x73\xB0\x0C\x37\x08",
			"\x39\xB1\x5D\x08\x22\x0F\xB1\x89\x02\x1F\xAE\x22\x0F\xB1\x8B\x02\x1F\xAC\x23\x0F\xB1\x8D\x02\x1F\xAE\x23\x0C\xC7\xB7\xB0\x40\xB2\xFD\xAF\xC3\x82\xB1\x8E\xB1\x23\xB8\x99\x0F\x02\x8B\xB3\x10\xB4\xC7\x9F\xAF\x90\xB2\xB5\xAC\xC8\x99\xB2\x18\xB2\x26\xB6\xC9\x98\xB2\x53\xB0\x48\x20\x09\x15\xB2\x91\xB0\x27\xBD\xBD\xA6\xB2\x34\xB1\x29\xB1\xCA\x92\xB2\x9D\xB1\xAE\x61\x09\x1F\xAC\x92\x00\x29\xB9\x71\x53\x02\xB2\xB1\xAC\x04\x09\x11\xAE\x95\x01\xE4\xA6\x09\x35\xB2\x7A\xAF\x25\x0F\xB1\x98\x02\x1F\xAD\x26\x0F\xB1\x9A\x02\x1F\xAF\x26\x0F\xB1\x9C\x02\x91\xAD\x27\x0F\xB1\x9E\x02\x64\xB2\x4D\x10\x0A\x1F\xAC\xA1\x03\xC7\xA2\x0A\x1F\xAC\xA3\x03\xC7\xA4\x0A\x32\xB0\xA5\x03\xC7\xA6\x0A\x3C\xB2\xA9\xB2\xFB\x17\x0A\x1F\xAC\xA8\x00\x37\xB8\xBC\x29\x02\xE2\xB0\x00\x0A\x0A\x1F\xAC\xAB\x03\xC7\xAC\x0A\x1F\xAC\xAD\x03\xC7\xAE\x0A\x1F\xAC\xAF\x03\xC7\xA0\x0B\x25\xB3\x8F\xB2\xF2\x31\x0B\x34\xB3\xAC\xB3\x29\xBB\xCA\xA8\xB2\x3A\xB1\x81\x42\x0B\x38\xB3\xFC\xB1\x0E\xB2\xD0\xB5\xB3\x97\xB1\xF8\xA0\xCA\x85\xB4\x12\x67\x2C\x00\xD0\xBB\xB3\x0C\xB4",
			"\x42\xBF\xC9\x86\xB4\x10\xB7\x26\xB3\x6C\x74\x02\x0B\xB6\x43\xBA\xCA\x96\xB4\x9E\xB3\x45\xB7\xD0\x9B\xB4\x11\xB7\x43\xB2\xD1\x98\xB4\xAD\xB2\x3E\xBE\x64\x35\x02\x1F\xAE\x2D\x05\xD1\xA0\x57\xB7\x03\x49\xBD\x25\x38\x02\x91\xAD\x2E\x0D\xCC\x82\x04\xBB\x03\xC7\xAC\x0B\x2A\xB4\xDB\xAD\x2F\x0F\xB1\xBE\x02\x1F\xAF\x2F\x0F\xB1\x80\x03\x1F\xAD\x30\x0F\xB1\x82\x03\x91\xAF\x30\x0F\xB1\x84\x03\x2F\xB6\x50\x16\x0C\x1F\xAC\xC7\x03\xC7\xA8\x0C\x1F\xAC\xC9\x03\xC7\xAA\x0C\x32\xB0\xCB\x03\xC7\xAC\x0C\x1F\xAC\xCD\x03\xC7\xAE\x0C\x05\xB5\x00\x00\x34\x0F\xB1\x91\x03\x1F\xAE\x34\x0F\xB1\x93\x03\x1F\xAC\x35\x0F\xB1\x95\x03\x91\xAE\x35\x02\xC3\x97\x03\x1F\xAC\x36\x01\xB9\x99\x03\x34\xB7\xBA\x1A\x0D\x1F\xAC\xDB\x01\x5B\xB9\x39\x1C\x03\x1F\xAD\x37\x0F\xB1\x9E\x03\x91\xAF\x37\x0F\xB1\xA0\x03\x91\xAD\x38\x0F\xB1\xA2\x03\x1F\xAF\x38\x08\xD5\xA5\x03\x1F\xAE\x39\x0F\xB1\xA7\x03\x1F\xAC\x3A\x0F\xB1\xA9\x03\x72\xB7\xAA\x0A\x0E\x1F\xAC\xEB\x01\x63\xB0\x45\x6C\x03\x92\xB7\x40\x0D\x0E\x11\xAE\xEE\x00\x56\xB0\x0F\x1F\xAC\xF1\x01\x65\xBD\x3D\xB2",
			"\x03\x1F\xAF\x3C\x0F\xB1\xB4\x03\x1F\xAD\x3D\x0F\xB1\xB6\x03\x1F\xAF\x3D\x01\xB9\xB8\x03\x1F\xAD\x3E\x08\xD5\x98\x12\xFB\x03\xC7\xAC\x0F\x1F\xAC\xFD\x03\xC7\xAE\x0F\x24\xAC\x32\xB2\xD6\x81\x5D\xAB\x09\x61\xA0\x6F\xB8\x5D\xBE\xB6\xF2\x77\xA7\x50\xDC\xB9\x77\x06\x03\x70\xB0\x87\x86\xB7\x73\xA0\x72\xBD\x95\x4A\xB7\x5B\x04\x73\xB1\x2B\x0B\x00\xCE\xB5\x07\x1C\x00\x11\xB7\x54\x8C\x75\xB7\x35\x96\xB7\x3E\x3B\x03\x08\xDD\x90\x00\xD8\xB4\x48\x21\x01\x18\xB7\x12\x00\x76\xB3\x01\x1D\xB7\xD9\x04\x05\x08\xDD\x95\x00\xE4\xB4\x82\x06\x01\x18\xB7\x17\x00\x76\xB8\x01\x06\xB7\x99\x06\x06\x08\xDD\x9B\x00\xD8\xB4\x07\x08\xDD\x9D\x00\xD8\xB6\x07\x09\xDE\x8D\xB4\xFF\x77\x07\x0B\xDF\xA0\xB4\x22\xB4\x47\xBF\xD1\x82\xB8\x10\x70\x08\x0F\xDF\x84\xB8\x1A\xB5\x47\xB9\xE0\x83\xB8\x0A\xB9\x46\xBE\xE0\x90\x51\x21\x03\x81\xBD\xE0\xA1\xB4\xDD\xB0\x85\xBD\xCF\x95\xB8\x01\xB8\x07\x22\x02\x12\xB8\x0C\xB9\x87\xBE\xD1\x9F\xB8\x0B\xB8\x88\xBF\xE0\xB1\x51\x23\x00\x87\xB2\xE2\x96\xB8\x02\xB4\x09\x06\xE2\xA1\xB8\x2C\xBB\x88\xB8\xE1\xAF\xB8\x17\xB9\x8C",
			"\xB3\xD0\xB9\xB3\xDD\x8D\x09\x0B\xE2\xAE\xB8\x32\xB8\x41\xB8\xE0\xB8\xB8\x33\xB9\x40\xB2\x7B\x26\x00\x37\xB8\x8A\xBA\xE3\x93\xB8\x19\xBA\x87\xBD\xE2\x82\xB9\x34\xB9\x8E\xB9\xE4\xBD\xB8\x53\xB3\x09\x01\xE4\x85\xB9\x27\xB8\x94\xB7\xE4\x92\xB9\x3C\xBB\x90\xB6\xE4\x95\xB9\xAE\xA4\x0A\x08\xDD\xA9\x00\x4F\xB9\x57\x7A\x02\x1D\xB9\x42\x17\x0A\x00\xE6\x80\x00\x2C\x03\x98\xBD\x02\x23\xB9\x56\xB8\x6A\x0E\x02\x18\xB7\x2F\x00\x76\xB0\x03\x18\xB7\x31\x00\x76\xB2\x03\x18\xB7\x33\x03\x98\xB4\x03\x18\xB7\x35\x00\x7C\xB1\x4E\x37\x00\xD8\xB4\x0E\x08\xDD\xB9\x00\xD8\xB6\x0E\x08\xDD\xBB\x00\x68\xB9\x76\x0C\x03\x18\xB7\x3D\x03\x98\xBE\x03\x05\xBA\x3E\xB8\xBE\x1F\x03\x18\xB7\x40\x00\xA3\xBA\xFC\x01\x01\x92\xBA\xCF\x02\x04\x18\xB7\x43\x00\x76\xB4\x04\x18\xB7\x45\x00\x76\xB6\x04\x18\xB7\x47\x00\x76\xB8\x04\x15\xBA\x3B\xB8\x92\xBD\xE8\xA7\xBA\xFC\xB4\x91\xBD\x3D\x89\x01\xA4\xBA\xAA\xBB\x2B\x4A\x01\xAD\xBA\xD2\x2B\x04\x31\xBA\xA8\x04\x13\x08\xDD\x8D\x01\xD8\xB6\x13\x08\xDD\x8F\x01\xD8\xB4\x14\x08\xDD\x91\x01\xD8\xB6\x14\x08\xDD\x93\x01",
			"\xD8\xB4\x15\x08\xDD\x95\x01\xD8\xB6\x15\x04\xEB\xB6\xAF\x57\x03\xB2\xBB\x2A\x18\x01\xCE\xBA\xA9\xB9\xEA\x9B\x50\x59\x01\xB4\xB1\xC4\x58\xB7\x5B\x02\xB5\xB0\xA5\x5C\x01\xDA\xBB\x1C\x1D\x05\x23\xB9\x5E\x03\x98\xBF\x05\x1D\xBB\x4C\xB8\x8A\x00\x06\x18\xB7\x61\x00\x76\xB2\x06\x18\xB7\x63\x00\x76\xB4\x06\x18\xB7\x65\x03\x98\xB6\x06\x18\xB7\x67\x02\x9E\xB2\x50\x29\x01\xD8\xB6\x1A\x08\xDD\xAB\x01\xD8\xB4\x1B\x08\xDD\xAD\x01\xE4\xBA\x1B\x08\xDD\xAF\x01\xE4\xB9\x9A\xBA\x7B\x30\x01\xD8\xB5\x1C\x05\xF0\xAC\x2F\x72\x03\xC2\xB8\x20\x33\x01\xD8\xB4\x1D\x08\xDD\xB5\x01\xD8\xB6\x1D\x08\xDD\xB7\x01\xD8\xB4\x1E\x08\xDD\xB9\x01\x0E\xBF\xB4\xB0\x0C\x7A\x01\x1D\xBC\x80\xB0\xE3\xA5\xBB\xA5\xB8\x95\xB2\xED\xA2\xBC\x42\x17\x1E\x01\xF2\xA5\xBC\x23\xBC\xE3\x8C\x07\x2B\xBC\xAE\xB8\xC9\xB3\xD7\x3D\x01\x30\xBF\x95\xB7\xF2\xAC\xBC\x4A\xB8\xAA\xB8\xF2\xB2\xBC\x63\x1A\x1F\x05\xF3\x91\xB9\x2D\xBF\x92\xB6\xF0\xBF\x2D\x7F\x03\xCF\xB3\xE5\x81\xBD\x3A\xBC\xCE\xB6\x2D\x00\x02\x46\xBC\x96\xB9\xF4\xB1\xBC\x43\xBF\xCD\xB0\xF5\x8F\x12\x81\x01\xD3\xB2",
			"\xF5\xB6\xBC\x26\xBD\xD6\xB8\xF4\x9E\xBC\x47\xBE\x50\x12\x08\x16\xBD\x5A\xBD\xCE\xBC\xF5\x8E\xBD\x63\xBF\xD5\xB0\xF4\x88\x2F\x83\x00\xD8\xBB\xF5\xBB\xBC\x51\xBD\xD8\xBC\xF3\xA7\xBD\x6F\xBD\xD7\xB1\xF7\xBC\xB8\x84\x02\xDA\xB1\x10\x05\x02\x76\xBF\xDC\xB6\xF6\xB2\xBD\x6D\xBF\xDA\xBA\xF4\xBD\xBD\x62\xBC\xDB\xB2\xF4\x83\xBE\x4F\xBC\xD6\xBE\xF7\x93\xBD\x9B\xA2\x21\x09\xF7\xA7\x2D\x87\x00\x76\xB8\x08\x0B\xBE\xBF\x59\x22\x00\xF9\x88\x08\x8A\x03\x98\xBB\x08\x23\xB9\x8C\x03\xE4\xB9\x76\x8D\x02\xD8\xB6\x23\x08\xDD\x8F\x02\xD8\xB4\x24\x08\xDD\x91\x02\xD8\xB6\x24\x03\xE6\x93\x02\xD8\xB4\x25\x06\xEF\x8A\x14\x96\x00\x76\xB7\x09\x18\xB7\x98\x00\x76\xB9\x09\x18\xB7\x9A\x00\xB9\xBB\x09\x18\xB7\x9C\x02\xE6\xB2\xF8\x91\x1E\x9D\x00\x76\xBE\x09\x3A\xBE\x69\x2B\x27\x09\xF7\xA0\x02\xD8\xB5\x28\x08\xDD\xA2\x02\xD8\xB7\x28\x08\xDD\xA4\x02\xD8\xB5\x29\x08\xDD\xA6\x02\xC0\xBC\xE2\xBA\xFC\x27\x02\xD1\xBE\xE1\xB1\xF8\xBF\xBD\x84\xBD\xD9\xB5\xBD\x28\x02\xD5\xBC\xDC\xB0\xF8\xBA\xBD\x6E\xBF\xF7\xB2\xFE\x99\xBF\xBB\xBF\xC9\x49\x0A\x1D\xBF\x7C",
			"\xBC\xF9\xB8\xFD\x85\xBE\xDE\xBD\x77\x1A\x0A\x18\xB7\xAB\x00\xFA\xB5\x35\x6C\x02\xF2\xBE\x41\x0D\x0A\x23\xB9\xAE\x03\x98\xBF\x0A\x35\xBF\xE0\x94\x2C\x08\xDD\xB1\x02\xD8\xB6\x2C\x08\xDD\xB3\x02\xD8\xB4\x2D\x08\xDD\xB5\x02\x63\xBA\x2D\x08\xDD\xB7\x02\xAB\xBE\x4D\x19\x0B\x18\xB7\xBA\x00\x76\xBB\x0B\x18\xB7\xBC\x00\x76\xBD\x0B\x24\xBB\xBE\x00\x76\xBF\x0B\x3C\xBF\x87\xBF\x98\x10\x0C\x18\xB7\xC1\x00\x07\xCA\x9E\x02\x03\x79\xBF\x30\x08\xDD\x84\x03\xD8\xB5\x31\x08\xDD\x86\x03\xD8\xB7\x31\x08\xDD\x88\x03\xD8\xB5\x32\x02\x02\xE0\xBF\x1D\xC1\xFB\xBC\xFE\xAE\x86\xCA\x03\x0C\xC3\xFE\xB7\xC0\x64\xBD\xF9\xBE\x03\xC8\x09\xCB\x01\x03\xC5\x03\xE9\xBF\x3C\xC3\xDE\xBD\x03\xE9\x29\xCD\x02\x0E\xCA\xFE\x92\xBF\x3F\xC0\x13\xCB\xFE\xA8\x28\xCE\x00\x76\xBF\x0C\x0A\xC1\x5E\x4C\x34\x03\x03\xD1\x03\x63\xBA\x34\x03\xE6\x93\x03\x54\xC3\xC9\x84\x0D\x18\xB7\xD5\x00\x76\xB6\x0D\x18\xB7\xD7\x00\x76\xB8\x0D\x18\xB7\xD9\x03\x98\xBA\x0D\x18\xB7\xDB\x02\x10\xC2\x54\x1D\x03\xD8\xB6\x37\x08\xDD\x9F\x03\xD8\xB4\x38\x08\xDD\xA1\x03\xE4\xBA\x38\x08\xDD",
			"\xA3\x03\x5D\xC1\x13\xC3\x66\x24\x03\xD8\xB5\x39\x0D\x07\xDC\x23\xE6\x01\xDE\xB7\x0E\x18\xB7\xE8\x00\x76\xB9\x0E\x18\xB7\xEA\x00\x76\xBB\x0E\x18\xB7\xEC\x00\x76\xBD\x0E\x03\xC2\x4E\xC0\x04\x4E\x0E\x14\xC2\xD6\xBC\x0D\xC5\x76\xAF\x03\xD8\xB4\x3C\x08\x09\xF6\xC0\xDA\xBF\x10\xCC\x00\x71\x03\x9F\xC0\x11\xC1\x0A\xCA\x68\xF2\x00\x76\xB3\x0F\x25\xC2\x47\xC1\x25\xC9\x09\xCE\x4D\xF4\x00\x2B\xC6\x04\xF3\xC2\xE1\xBF\x12\xCF\x0A\xF6\xC2\x94\x7D\x3D\x02\x0B\xF5\xC2\x45\xC0\x2F\xC7\x0A\xDA\xC2\x74\x12\x3D\x0B\x0B\xE2\xC2\xB4\xC0\x31\xCE\x0B\xFE\xC1\xA0\xC0\x32\xCE\x1A\xB7\x03\xC3\xC3\xF5\xBE\x0A\xC9\xC3\x4F\xC2\x32\xCD\x0A\xF7\xC2\x41\x18\x3E\x0D\x0C\xC0\xC3\x3B\xC3\x2F\xC9\x0D\xD2\xC3\xC5\xC2\x74\x89\x0F\x17\xC3\xDB\xC1\x34\xC2\x0E\xCF\xC3\xA6\xC0\x37\xC1\x47\x7A\x03\xE0\xC0\x2E\xC5\x0E\xE3\xC3\xD4\xC2\x36\xCA\x0E\xD3\xC3\xD0\xC0\x39\xC3\x3B\x3B\x03\xE9\xC1\x2F\xCD\xD5\x7C\x03\x63\xB9\x3F\x05\x0F\xEE\xC3\xF6\xC2\x33\xCD\x0E\xE6\xC3\xC6\xC1\x40\xC9\xB0\xBB\xC3\x00\xC6\x3F\xC1\x0F\xFF\xC3\xEC\xC3\x41\xC2\xC2\x44\xC4\x09\xC7",
			"\x3A\xC2\x0F\xDD\xC3\xD8\xC3\x3B\xC0\x11\xCC\x8E\x00\x02\xC9\x04\x5D\xAB\x19\x01\x02\x45\xC4\x86\x92\xC4\xC7\xC1\x43\xC0\x0F\xCE\xC4\x08\xC7\x43\xCD\x11\xE2\xC4\x02\xC5\x44\xC1\xD0\x82\x00\x1A\xC5\xCE\x81\x0E\xE4\xC4\x06\xC4\x48\xCA\x10\xEE\xC4\xAD\x5B\x00\x09\x12\xFD\x8C\x95\x68\x01\x03\x13\xFD\x77\x05\x03\x4D\xC0\xB1\x8B\x75\x06\x02\x4E\xCD\x29\x07\x00\x3E\xC7\xEC\x08\x00\x01\xC5\x3E\x34\x51\xC6\xE1\x46\xC5\x25\xC5\x8B\x0B\x00\x08\xC5\x60\x48\x53\xC9\x22\x0E\xC5\x0E\x02\x53\xCF\x00\x0E\xC5\x10\x02\x53\xC7\xE2\x4E\xC5\x12\x03\x4D\xC3\xB4\x98\x83\x4E\xC5\x05\x0E\x14\xD6\x00\x4E\xC7\x05\x0E\x14\xD8\x00\x56\xC4\x8E\x7E\x14\xDA\x00\x65\xC5\x3F\xC6\xBD\x1B\x00\x4E\xC4\x07\x09\x16\xC3\x79\x6F\xC6\x91\x7E\x14\xDF\x00\x4E\xC4\x08\x0E\x14\xE1\x00\x4E\xC6\x08\x0E\x14\xE3\x00\x4E\xC4\x09\x01\x17\xC1\x1E\x25\x02\x53\xC6\x02\x3F\xC5\x33\x97\x09\x04\x18\xE3\x19\x28\x03\x61\xC2\x11\x8A\xC6\x6D\x78\x63\xCF\x11\xF0\x79\x4E\xC4\x0B\x0E\x14\xED\x00\x4E\xC6\x0B\x0E\x14\xEF\x00\x4E\xC4\x0C\x0E\x18\xC6\x04\x31\x02\x53\xC2\x03\x1A",
			"\xC5\xE1\x10\x0D\x0E\x14\xF5\x00\x4E\xC6\x0D\x0E\x14\xF7\x00\x4E\xC4\x0E\x0B\x19\xCD\x0B\x39\x02\x53\xCA\x03\x2B\xC6\x49\xC4\x10\x2B\x03\x0E\xC5\x3C\x00\x6C\xCB\x2B\x7D\x00\xB6\xC4\x1D\x1E\x03\x0E\xC5\x3F\x02\x53\xC0\x04\x0E\xC5\x41\x02\x53\xC2\x04\x0E\xC5\x43\x02\x53\xC4\x04\x39\xC6\x2D\x09\x11\x08\x1C\xDC\xC4\xB1\xC6\x5A\xCB\x12\xE1\xC4\xD0\xC7\x4B\xCF\x18\xF1\x0A\x46\x02\x53\xC7\x04\x0B\xC7\xCE\xC4\x73\xCD\x12\xD3\xC7\x23\xC5\x74\xC1\xFD\x08\x01\xD8\xC4\x3F\xC2\x1E\xC5\xC4\x26\xC7\x78\xCE\x11\xD3\xC4\xDA\xC5\x79\xC4\x1E\xCF\xC7\xD2\xC6\x42\x19\x04\x0E\xC5\x4A\x01\x78\xCB\x1E\xE9\xC7\xEC\xC4\x4C\xCC\x1D\xCD\xC7\xE6\xC4\x4B\xCA\xCA\x4B\x01\xF2\xC7\x79\xCD\x1D\xED\xC7\xFF\xC6\x7D\xCA\x50\x0C\x01\xFD\xC6\x7E\xC5\x1F\xF7\xC7\xDB\xC4\x7A\xC9\x1D\xCB\xC8\xF9\xC4\xED\x1D\x04\x05\xC8\xDE\xC4\x82\xCA\x1E\xFE\xC7\xF8\xC7\x7C\xCC\x20\xD6\xC8\x0D\xC8\x80\xC5\x21\xD6\x0D\x4E\x00\x84\xCA\x21\xC9\xC8\x01\xCA\x84\xC7\x20\xCA\xC8\x19\xC9\xAB\x5F\x04\x1E\xC8\x02\xC9\x88\xC4\x22\xD8\xC8\x2C\xC8\x85\xCA\xA0\x50\x01\x28\xCA\x88",
			"\xC4\x1F\xF3\xC8\x17\xCA\x8B\xC3\x21\xC8\x7C\x51\x01\x8C\xCB\x22\xF6\xC8\x23\xCA\x8A\xCE\x23\xDB\xC8\x06\xC8\x8D\xC2\x89\x12\x01\x3A\xCB\x8F\xC0\x22\xC0\xC9\x11\xCB\x8E\xC1\x24\xF5\xC8\x4B\xC9\x89\xCC\x69\x13\x01\x45\xC8\x92\xCF\x21\xD6\x2F\x54\x01\x94\xC7\x24\xD7\xC9\x37\xC9\x92\xC6\x24\xD9\xC9\x53\xC9\x8F\xC2\x0C\x55\x01\x56\xC8\x97\xC9\x22\xD2\xC9\x63\xC9\xD9\x96\x05\x21\xC9\x5E\xC8\x96\xC9\x26\xE2\xC9\x32\xC8\x93\xCA\x25\xE4\xC9\xEE\x1F\x15\x08\x26\xC2\xC9\x2D\xC9\x93\xC5\x27\xEF\xC9\x6A\xC8\x10\x28\x05\x33\xC9\x41\x19\x16\x0C\x27\xCE\xC9\x4A\xC8\x9E\xCC\x26\xC1\xCA\x5D\xCA\x83\x4A\x05\x3F\xC9\x77\xC9\xA1\xC1\x64\x1B\x01\x4E\xC4\x17\x09\x1B\xDD\x01\x88\xC8\x8F\xC4\x27\xD2\xCA\x6A\xC6\x17\x01\x29\xF6\xC9\x94\xC8\xA0\xCB\x25\xEB\xC9\x9C\xCB\xA4\xC8\x29\xDF\xCA\x82\xC9\xA7\xC1\x64\x1F\x01\x97\xC9\xA8\xCE\x29\xE6\xCA\x6E\xCA\xA2\xCA\x29\xF0\xC9\x06\x04\x18\x05\x2A\xEA\xCA\x89\xC9\x99\xC3\x28\xDB\xCA\xA7\xC8\xAC\xC9\x29\xF1\xCA\x6D\xCB\x2F\xC1\x06\x2F\xCA\xB2\xCA\xA8\xCB\x2A\xF9\xC9\xA9\xC9\xAF\xC5\x2B\xC2\xCB",
			"\xC1\xC9\xAE\xC8\x2B\xC4\xCA\xC4\xCB\xAF\xCA\xCA\x62\x01\xBC\xCA\xB1\xCA\xF4\xA3\x01\xCD\xC8\xB2\xCE\x2C\xE0\xCA\xB6\xCA\x57\x24\x06\x11\xCB\xB4\xCA\xFA\x35\x06\x18\xCB\x3F\x16\x19\x0C\x2D\xC0\xCB\xCA\xCA\xAF\xC7\x2C\xD9\xCB\xE1\xCB\xB0\xC3\x2D\xE8\xCA\xE5\xC9\xB1\xC6\x10\x27\x01\xDF\xCB\xAC\xC2\x0C\x68\x01\xED\xC8\x26\x19\x06\x31\xCB\xE6\xCA\xB4\xC6\x2F\xE4\xCB\xE3\xC8\xAB\xC6\x53\x2A\x01\xF4\xCA\xBA\xC8\x2F\xF7\xCA\x00\xCC\xB5\xCA\x10\x2B\x01\xFD\xC9\xBA\xC6\x30\xF9\xCB\xE0\xC8\xC2\xCE\x2E\xC9\xCC\x0E\x68\x1B\x05\x30\xCA\xCC\xE2\xC9\xC0\xC8\x2E\xD0\xCC\xF5\xCA\xDE\xAD\x06\x0F\xCC\x12\xCD\xB5\xC3\x31\xD9\xCC\xC9\xC8\xC5\xCE\x2F\xFA\xCB\x20\xCC\xC3\xC0\x01\x6E\x01\x4E\xC7\x1B\x0E\x14\xF0\x01\x18\xCE\xC0\xC7\x2E\xDA\xCC\x2C\xCD\xC7\xCC\x31\xEB\xCC\x2E\xCE\xCA\xC7\x2F\xE1\xCC\x0B\xCD\xCD\xC2\x7B\x31\x01\x29\xCE\xD2\x22\x07\x0E\xC5\x73\x01\xCE\xC0\x53\x74\x01\x3E\xCE\x42\x05\x07\x39\xC6\x76\x01\x6E\xC7\x07\x0E\xC5\x78\x01\xD0\xCE\xC9\x79\x01\x4E\xC6\x1E\x0E\x14\xFB\x01\x4E\xC4\x1F\x0E\x14\xFD\x01\x4E\xC6\x1F\x09",
			"\x1B\xFF\x01\x4E\xC4\x20\x00\x1A\xC1\x45\x4E\xC7\x20\x0E\x14\xC4\x02\x4E\xC5\x21\x0E\x14\xC6\x02\x61\xCB\x21\x0E\x14\xC8\x02\x4A\xCF\xCC\xC3\x47\x09\x02\x4E\xC6\x22\x09\x36\xDB\x26\x8B\x01\xBB\xCC\x08\x0E\xC5\x8D\x02\x53\xCE\x08\x0E\xC5\x8F\x02\x53\xC0\x09\x0E\xC5\x91\x02\x53\xC2\x09\x2F\xCD\xD2\x0B\x24\x0E\x14\xD4\x02\x80\xCD\xAE\x55\x09\x05\xCE\x00\x02\x25\x09\x1B\xD7\x02\xB9\xC4\x26\x08\x38\xCC\x8E\x99\x02\x53\xCA\x09\x0E\xC5\x9B\x02\x53\xCC\x09\x0E\xC5\x9D\x02\x53\xCE\x09\x39\xC6\x9F\x02\x53\xC0\x0A\x1B\xCD\x0A\x16\x28\x0E\x14\xE3\x02\x4E\xC4\x29\x0E\x14\xE5\x02\x4E\xC6\x29\x01\x26\xE7\x02\x4E\xC4\x2A\x0F\x38\xD5\xCC\x6A\x11\x2A\x0E\x14\xEA\x02\xAF\xCD\x3F\x2B\x0A\x2D\xCB\xAC\x02\x53\xCD\x0A\x0E\xC5\xAE\x02\x53\xCF\x0A\x0E\xC5\xB0\x02\x53\xC1\x0B\x0E\xC5\xB2\x01\x98\xC3\x0B\x35\xCE\x07\xCF\xCB\xCA\x36\xF6\xCC\xB0\xCE\xC8\xCB\x31\xCB\x5F\xB4\x00\xF2\xCE\x31\xC9\xCF\x32\xCF\xBF\xC5\x3D\xF4\xCC\x20\x25\x2D\x02\x3D\xD6\x0D\xB6\x03\xF6\xC7\x3D\xCE\xCF\x2D\xCC\xCC\xC2\x3E\xCB\xCF\x6B\x1B\x2D\x0E\x3D\xCF\xCF\xE8",
			"\xCD\xF8\xC4\x3E\xCD\xCF\xCC\xCF\xC7\xC0\x3E\xF1\xCC\xE9\xCE\xFD\xA8\x0B\x27\xCF\x2F\x21\x2E\x0E\x14\xFA\x02\xF4\xCD\xF4\x3B\x0B\x08\xCE\xBC\x01\x6E\xCD\x0B\x39\xC6\xBE\x02\x53\xCF\x0B\x39\xCF\xE3\x64\x30\x0E\x14\xC1\x03\x4E\xC6\x30\x0E\x14\xC3\x03\x4E\xC4\x31\x0E\x14\xC5\x03\xB9\xC6\x31\x0E\x14\xC7\x03\xA0\xCE\x4D\x19\x0C\x0E\xC5\xCA\x02\x53\xCB\x0C\x0E\xC5\xCC\x02\x53\xCD\x0C\x21\xC9\xCE\x02\x53\xCF\x0C\x04\xD0\xEB\xCC\x82\x00\x0D\x0E\xC5\xD1\x00\x09\xD2\x81\x12\x03\xED\xCB\x34\x0E\x14\xD4\x03\x4E\xC5\x35\x0E\x14\xD6\x03\x4E\xC7\x35\x0E\x14\xD8\x03\x4E\xC5\x36\x0A\x42\xEE\x58\x4E\xC7\x36\x0B\x43\xFB\x4A\xDC\x00\xE2\xCD\x0D\x39\xC6\xDE\x01\x6E\xCF\x0D\x3F\xD0\x82\x88\x38\x0E\x14\xE1\x03\x4E\xC6\x38\x0E\x14\xE3\x03\x4E\xC4\x39\x0E\x14\xE5\x03\xB9\xC6\x39\x0E\x14\xE7\x03\x15\xD3\x4F\x19\x0E\x0E\xC5\xEA\x02\x53\xCB\x0E\x0E\xC5\xEC\x02\x53\xCD\x0E\x21\xC9\xEE\x02\x53\xCF\x0E\x08\xD1\x11\xCD\x97\x00\x0F\x0E\xC5\xF1\x00\x1A\xD8\x6F\x32\x03\xED\xCB\x3C\x0E\x14\xF4\x03\x4E\xC5\x3D\x0E\x14\xF6\x03\x4E\xC7\x3D\x0E\x14",
			"\xF8\x03\x4E\xC5\x3E\x01\x26\xFA\x03\x6E\xD2\xFB\xCD\x3E\xD4\xCF\xF1\xCF\xF8\xC6\x3D\xC5\xD2\xAE\x37\x3E\x01\x48\xC4\xD2\xEA\xCF\x21\xDD\x48\xD8\xCF\xEC\xCC\x26\x1C\x0F\x0B\xD2\x28\x09\x3F\x04\x49\xCA\xCF\x8E\xD0\xFC\xCF\x48\xEF\xCF\x86\xD2\x1A\x1E\x0F\x17\xD2\xDF\xCF\x20\xD3\x3D\xE3\xD2\x98\xD0\x24\xD5\x4E\x20\xD2\x88\xD1\x26\xDC\x00\x40\x00\x2C\x0F\x45\xC1\x49\xEF\xD2\x82\xD1\xC5\x51\x00\x2D\xD2\x1B\xC5\x2C\xD0\x4B\xE7\x8C\x02\x00\x2D\xDA\x12\xF7\xD2\xA4\xD1\xE9\x03\x00\x3A\xD2\x34\xC4\x23\xDA\x49\xC3\xD3\x9D\xD0\x27\xD5\x42\xC2\xD3\x9E\x70\x01\x00\x4C\xEA\x97\xC8\xD3\x31\xDD\x4B\xE9\xD2\xA6\xD1\xC4\x05\x00\x0B\xD3\x0A\x78\x35\xDE\x1A\x87\x00\xD6\xD1\x84\x79\x4D\xFE\x34\xCB\xD3\xD0\xAB\x00\x1B\xD3\xAA\xD2\x41\x0C\x00\x20\xD3\x54\x8C\x39\xD3\x88\xA6\xD3\x5A\x8C\x3A\xD0\x01\x28\xD3\x11\x00\x3A\xDD\x22\x12\x00\xE8\xD3\x04\x0D\x4D\xE1\x13\x15\x00\x3A\xD6\x01\x28\xD3\x17\x00\x3A\xD8\x01\x28\xD3\x19\x02\x3B\xD9\x2F\x1A\x00\xE8\xD3\x06\x08\x4E\xDC\x00\xE8\xD1\x07\x03\x4F\xC9\x04\x1F\x00\x3A\xD0\x02\x28\xD3\x21\x00",
			"\x3A\xD2\x02\x28\xD3\x23\x00\x3A\xD4\x02\x3E\xD3\x5E\x40\x45\xD1\x31\x26\x00\xE8\xD3\x09\x06\x51\xE8\x08\x28\x03\x46\xD0\xC3\x29\x00\xE8\xD2\x0A\x0E\x51\xDE\x25\x2B\x00\x3A\xDC\x02\x28\xD3\x2D\x03\x48\xD9\x27\x2E\x00\xE8\xD3\x0B\x0A\x52\xE8\x06\x30\x00\x3A\xD1\x03\x28\xD3\x32\x00\x3A\xD3\x03\x28\xD3\x34\x00\x3A\xD5\x03\x28\xD3\x36\x00\x3A\xD7\x03\x2F\xD4\xC4\xD2\x33\xD5\x4A\xC6\xD3\xE1\xD1\x51\xD7\x41\x78\x00\x40\xD5\x31\xD2\x4A\xC3\xD5\x4B\xD5\x28\xD9\x46\xD0\xD3\xA9\x71\x0E\x09\x54\xC2\xD5\x4E\xD4\x2F\xDC\x54\xCF\xD5\x2C\x16\x0E\x03\x55\xC6\xD5\x44\xD5\x34\xDF\x4C\xDB\xD2\x4D\xD4\x54\xD4\x9E\x7B\x00\x5B\xD6\x57\xD7\x55\xD6\xD5\x55\xD6\x2D\xD2\xB0\x3C\x00\xE8\xD1\x0F\x05\x56\xD2\x87\x3E\x03\x5B\xD3\x54\x3F\x00\x72\xD4\x10\x02\x57\xC1\x01\x72\xD7\xF7\xB2\x04\x28\xD3\x43\x00\x3A\xD4\x04\x28\xD3\x45\x00\x3A\xD6\x04\x28\xD3\x47\x02\x5C\xD8\x04\x28\xD3\x49\x03\x41\xDA\x50\x0B\x01\xE8\xD0\x13\x08\x4E\xCD\x01\xE8\xD2\x13\x08\x4E\xCF\x01\x79\xD5\x76\x00\x05\x28\xD3\x51\x01\x65\xDA\x56\xC0\x1D\x52\x00\x3A\xD3\x05\x1A",
			"\xD6\xCA\x3C\x15\x00\x5A\xFE\x0C\x55\x00\x3A\xD6\x05\x28\xD3\x57\x00\x3A\xD8\x05\x28\xD3\x59\x00\x3A\xDA\x05\x28\xD3\x5B\x03\x68\xDF\x95\xB2\xD6\x69\xD5\x33\xDC\x55\xE1\xD5\x60\xD4\x56\xD1\x54\xD5\x2F\x5D\x00\x6D\xD2\x56\xFA\xD6\x4A\xD4\x70\xD4\x55\xFF\xD6\x68\xD4\x71\xDB\x59\xDF\xD5\xBB\xD6\xB4\x0E\x05\x3E\xD6\x2F\x23\x17\x0C\x5C\xC9\xD7\x5D\xD5\x74\xD8\x5B\xD0\xD7\xD3\xD5\x70\xDB\xEC\x20\x01\xCF\xD6\x75\xD7\x5C\xE7\xD5\xDB\xD5\x6D\xD6\x90\x21\x01\xE8\xD2\x18\x09\x5D\xF9\x6A\x63\x02\x5C\xD4\x06\x23\xD7\x03\x05\x19\x02\x57\xE6\x01\x72\xD7\x19\x08\x5E\xE3\xBC\x68\x00\x3A\xD9\x06\x28\xD3\x6A\x00\x3A\xDB\x06\x28\xD3\x6C\x00\x3A\xDD\x06\x32\xD5\x6E\x00\x3A\xDF\x06\x0A\xD6\x36\x15\x1C\x08\x4E\xF2\x01\xE8\xD3\x1C\x08\x4E\xF4\x01\xE8\xD1\x1D\x0F\x5E\xC1\x04\x76\x00\x3A\xD7\x07\x0B\xD8\xD5\xD5\xA3\x18\x07\x28\xD3\x79\x00\x84\xD2\xD3\x3A\x01\x16\xD9\x76\x0B\x07\x28\xD3\x7C\x00\x3A\xDD\x07\x28\xD3\x7E\x00\x3A\xDF\x07\x28\xD3\x80\x00\x3A\xD1\x08\x19\xD8\xDD\xD4\x36\x12\x08\x28\xD8\xB6\xD6\x59\xDE\x5D\xDC\xD7\x2D\xD9\xB5",
			"\x03\x08\x2C\xD8\xC8\xD6\x76\xD1\x63\xD1\xD8\xB7\xD6\x70\xDB\x99\x04\x02\xE8\xD1\x21\x04\x63\xCE\x68\x86\x02\x5C\xD7\x08\x10\xD8\x88\x02\x5C\xD9\x08\x32\xD5\x8A\x03\x8F\xD1\xF3\x8B\x02\xE8\xD0\x23\x08\x4E\xCD\x02\xE8\xD2\x23\x08\x4E\xCF\x02\xE8\xD0\x24\x02\x57\xD1\x02\xE8\xD2\x24\x00\x60\xFF\x14\x94\x00\x3A\xD5\x09\x28\xD3\x96\x00\x3A\xD7\x09\x28\xD3\x98\x00\x84\xD9\x09\x28\xD3\x9A\x02\x92\xD6\x5C\xCE\x18\x9B\x00\x3A\xDC\x09\x2A\xD9\x4E\x2D\x27\x00\x67\xCA\x04\x9E\x00\x3A\xDF\x09\x28\xD3\xA0\x00\x3A\xD1\x0A\x28\xD3\xA2\x00\x3A\xD3\x0A\x28\xD3\xA4\x03\x9C\xD6\x63\xFE\x0C\xA5\x02\xA0\xD3\x5C\xF9\xD6\xC5\xD4\xA2\xD2\x48\xE6\x02\x86\xD9\x8E\xD9\x68\xD4\xD7\x3A\xDA\x8B\xDB\x66\xF5\xD8\x96\x45\xA3\xD2\x69\xCA\xDA\x37\xD9\xA4\xD9\xCA\x68\x02\x96\xDA\x74\xDA\x69\xF8\xD8\x97\xDA\xD4\x29\x0A\x28\xD3\xAA\x01\xA7\xD0\x6A\xDE\xDA\x8F\xDB\xA0\xD0\x63\xD4\xDA\x8E\xDA\xD7\x4B\x0A\x26\xDA\x9F\xD9\xC5\x5C\x0A\x30\xDA\xA9\xDB\xA1\xD0\x69\xF5\xDA\x4E\x65\x2B\x04\x6B\xE9\xD8\x98\xD8\xAB\xD1\x6A\xD8\x26\xAE\x03\xAE\xD9\x69\xF8\xDA",
			"\x23\xBF\x2B\x02\x6C\xFE\xDA\xA8\xD8\xAF\xD7\x6B\xFD\x78\xB0\x03\xB1\xDB\x6A\xCF\xDB\x2F\xD9\xB4\xD3\x69\xD0\xDB\xD3\xD9\xCC\xB1\x0B\x0E\xDB\xD2\xD9\xAF\xD4\x6D\xDA\xDB\xD9\xD8\x75\xD2\x0B\x18\xDB\xD5\xD9\xB8\xDC\x6D\xE2\xDB\xAE\x87\x2C\x08\x4E\xF4\x02\xE0\xD8\x4C\x55\x0B\x29\xDB\x0A\x06\x2D\x02\x57\xF7\x02\x72\xD4\x2E\x0C\x6E\xE3\x8E\xB9\x00\x3A\xDA\x0B\x28\xD3\xBB\x00\x3A\xDC\x0B\x28\xD3\xBD\x00\x3A\xDE\x0B\x32\xD5\xBF\x00\x3A\xD0\x0C\x1B\xD9\x42\x16\x30\x08\x4E\xC3\x03\xE8\xD0\x31\x08\x4E\xC5\x03\xE8\xD2\x31\x00\x61\xC7\x03\xE8\xD0\x32\x03\x6F\xF6\xDA\xAB\x09\x32\x08\x4E\xCA\x03\x13\xDF\x66\x2B\x0C\x26\xDA\xCC\x00\x3A\xDD\x0C\x28\xD3\xCE\x00\x3A\xDF\x0C\x28\xD3\xD0\x00\x3A\xD1\x0D\x28\xD3\xD2\x01\xC6\xDF\x6B\xF4\x1F\xD3\x02\xCA\xD9\x6C\xC3\xDB\xCA\xDA\xAA\xD8\xF0\x54\x03\x2E\xDF\xA9\xD6\x73\xF1\xDA\xC4\xDB\xCB\xD8\x6C\xF7\xDC\xB6\x71\x35\x05\x73\xF8\xDC\x31\xDC\xC5\xD2\x74\xED\xDA\xBF\xC2\x35\x0F\x73\xF9\xDC\x3C\xDD\xD0\xD4\x74\xCC\x50\xD7\x03\xD1\xDA\x74\xEB\xDC\x4B\xDF\xB6\xDB\x6C\xF0\xDC\x54\xDC\x8A\x08",
			"\x0D\x0E\xDD\x55\xDE\xD4\xD2\x73\xE4\xDB\x3C\xB9\x36\x08\x75\xFB\xDC\x40\xDD\xD6\xDD\x6D\xDB\xDD\x53\xCA\x36\x0F\x75\xDA\xDD\x43\xDC\xD4\xDA\x76\xFA\xDC\x68\xDF\x40\x0B\x0D\x27\xDD\x63\xDD\xDA\xDC\x76\xF1\xDD\x51\xDC\xDD\xD2\x2D\x1C\x03\x70\xDC\xD7\xD2\x77\xC9\xDD\x62\xDE\xDE\xD7\x5B\xDD\x03\x79\xDF\xB8\xD2\x78\xD3\xDD\x60\xDC\xD2\xD8\xC3\x9E\x03\x81\xDC\xE1\xDD\x76\xEB\xDD\x7C\xDD\xE1\xDF\x74\xF3\xDD\x7E\xDC\xE3\xD1\x76\xCE\xDE\x0E\x1B\x37\x09\x78\xE4\xDD\x8A\xDE\xDD\xD0\x79\xC3\xDE\x98\xDD\xE7\xDB\x77\xD3\xDE\x8B\xDF\xE6\xD9\x79\xE7\x6E\xE0\x03\xE5\xDF\x79\xC9\x6A\xE1\x00\x3A\xD2\x0E\x26\xDE\x75\xDD\xE4\xD2\x7A\xCA\xD5\xE3\x00\xEB\xD2\x79\xF6\x72\xE4\x02\xEC\xDF\x7A\xE7\xDE\x8F\xDD\xCD\xC5\x0E\x36\xDE\x74\x12\x39\x0C\x7B\xE0\xDE\x9A\xDD\xE3\xD1\x7A\xC2\xDF\xC1\xDC\xF0\xD9\x27\x27\x03\xBF\xDE\xE1\xDA\x7C\xF9\xDE\xC6\xDC\xE7\xD8\xE2\xA8\x03\xC9\xDC\x82\x09\x0E\x11\xDF\x7D\xDE\xF3\xDD\x7A\xD6\xDF\xB3\xDC\xED\x8A\x0E\x14\xDF\x94\xDD\xF7\xD3\x7C\xCD\xDF\xA3\xDC\xF6\xD7\x7B\xD7\xDF\xE1\xDE\x1C\x7B\x0E\x1C\xDF\xDF",
			"\xDF\xF2\xD5\x7D\xE5\xDF\x9E\xDC\xF9\xDD\x7E\xF4\xCC\xEC\x00\xFA\xD5\x7C\xEA\xDF\xDE\xDF\xFC\xDC\x7C\xE9\xC7\xED\x00\x3A\xDE\x0E\x32\xDF\xAE\xDC\xF1\xDD\x7F\xDF\xBF\xEF\x00\xFF\xD2\x7E\xEA\x72\xF0\x02\x00\xEC\x7E\xF8\xDE\xEB\xDE\x27\x71\x0F\x06\xE0\xEF\xDE\xBC\x32\x0F\x0C\xE0\x08\xE1\xFD\xDF\x7F\xF4\xDF\x30\x33\x3C\x00\x81\xEE\xDF\x11\xE1\xFA\xD7\x7F\xDB\xE0\x09\xE0\x44\xC4\x0F\x17\xE0\x02\x05\x3D\x00\x82\xE3\xDF\xD9\xDD\x07\xE8\x81\xE7\xE0\xDD\x8E\x3D\x03\x82\xFE\xDF\x03\xE0\xF8\xDD\x80\xEC\xE0\x07\xE0\x0A\xE4\x82\xF2\x3B\xF7\x03\x0A\xEE\x82\xCA\x14\xF8\x02\x0D\xE4\x81\xF6\xDF\x26\xE1\x09\xE2\x81\xC3\x0F\xF9\x02\x0E\xEC\x81\xFF\xE0\x31\xE2\x0F\xEA\x81\xFD\xE0\x33\xE0\x0C\xE3\x3B\x3A\x03\x42\xE0\x12\xEA\x84\xD9\xE0\x43\x2F\x3E\x06\x6A\xFC\x03\x4D\xE0\x11\xE3\x3A\xBD\x03\x55\xE3\x11\xE6\x85\xD0\xE1\x4A\x2E\x3F\x00\x6B\xD9\xE1\x43\x2C\xDC\x6F\xF7\x32\xE0\x4F\xE0\x19\xE7\x83\xE6\xE1\x3B\xE3\x04\xEC\xD1\x01\x00\x2E\x0E\x2B\xD3\x84\xDA\xE1\x70\xE3\x4C\x92\x00\x2D\xE1\xB5\xD0\x28\x13\x00\x34\xE1\xBB\xD3\x1B\xEC\x83",
			"\xE8\x08\x04\x00\x1E\xE1\x4C\xDB\xE1\x68\xE2\x1E\xEA\x86\xCE\xE1\x67\xE3\x4F\x15\x00\x3E\xE1\xCC\xD0\x20\xE6\x84\xFB\xE1\x71\xE3\x20\xEA\x88\xC9\xE1\x85\xE0\x24\xE9\x86\xED\xE0\x93\xE1\x11\xE2\x89\xC2\xE2\x94\xE1\x90\x16\x00\x08\xE2\x3B\xC5\x20\xE4\x88\xD5\xE2\x2F\xE1\x24\xE5\x33\xC7\x00\x9C\xE2\xD4\x28\x00\x25\xE2\xA1\xE1\x29\x58\x8A\xDC\xE1\x99\xE3\x27\xE8\x89\xFE\x67\x0A\x03\x2A\xE3\x10\x0B\x00\xB2\xE1\xF7\x8C\x00\x35\xE2\x6D\x1D\x03\x08\x8B\xD6\x0B\x0E\x03\x2E\xE2\x4B\x7E\xE2\xEC\xCC\x04\x0B\x8B\xD1\x00\xBB\xE2\x04\x0B\x8B\xD3\x00\xBB\xE0\x05\x0B\x8B\xD5\x00\xC0\xE2\x7A\xBB\x8B\xD7\x00\x88\xE3\x56\xC8\xE3\x7B\xE2\x1A\x03\x2E\xEB\x01\x3B\xE2\x1C\x03\x2E\xED\x01\x0D\xE3\x11\x0E\x07\x0B\x8B\xDF\x00\xDC\xE3\x23\xEC\x6E\x20\x00\xBB\xE1\x08\x01\x8E\xF7\x49\x22\x03\x39\xE6\x50\x23\x00\xBB\xE0\x09\x0B\x8B\xE5\x00\xBB\xE2\x09\x0B\x8B\xE7\x00\xBB\xE0\x0A\x0B\x8B\xE9\x00\xEA\xE3\xE6\x0A\x02\x39\xE3\xAD\xE2\x38\xE2\x8A\xFF\xE3\xA0\xE0\x2B\xE6\x89\xF0\x20\x2B\x00\x3F\xE3\x90\xC0\xE4\xAF\xE1\x2A\xE9\x90\xE1\x2D\x2C\x02",
			"\x41\xEA\x90\xEE\xE2\x10\xE6\x3F\xE1\x90\xDE\xE2\x12\xE7\x42\xE4\x91\xFF\x77\x2D\x02\x43\xE2\x90\xCF\xE4\x15\xE5\x44\xED\x88\xFD\xE3\x1F\xE7\x41\xE3\x91\xCB\xE2\x8E\xE1\x48\xE5\x35\x6E\x00\x1A\xE7\x45\xE3\x53\xAF\x00\x29\xE6\xB4\x00\x03\x2D\xE4\x9A\xAC\x4C\xE5\x86\xD2\x0B\x32\x01\x34\xE1\x66\x34\x00\x32\xE7\xD9\x25\x03\x39\xE4\xF9\x0A\x0D\x0C\x93\xC1\x5B\x37\x03\x2E\xE8\x03\x3B\xE2\x39\x03\x2E\xEA\x03\x3B\xE2\x3B\x02\x4D\xE6\x45\x3B\xE2\x3E\x00\x22\xE3\x1B\x41\x01\x4A\xE5\xAC\x03\x04\x3F\xE4\xCA\x3C\x11\x04\x95\xDD\xE4\x3B\xBD\x11\x07\x95\xC8\x09\x46\x03\x56\xED\x25\x07\x01\x5E\xE5\x49\xED\x25\x08\x01\x51\xE4\xB5\x1A\x04\x21\xE5\x67\x27\x12\x08\x96\xDD\x0A\x4C\x03\x5A\xE5\x35\x4D\x01\xBB\xE2\x13\x0B\x8B\xCF\x01\xBB\xE0\x14\x0B\x8B\xD1\x01\x65\xE6\x40\x03\x05\x3B\xE2\x54\x02\x53\xEA\x10\x17\x01\x79\xE5\xB5\x09\x05\x2E\xE5\xAE\x36\x16\x04\x98\xFD\x38\x5B\x03\x61\xE4\x92\xE0\xE4\x8C\xE1\x63\xE2\x96\xCF\xE6\x8C\xE4\xED\x1C\x05\x0A\xE6\x97\xE2\x47\xEE\x98\xD1\xE6\x98\xE7\x40\xED\x05\x14\xE6\x33\xE5\x65\xE8\x95\xC3",
			"\xDF\x5E\x00\x67\xE8\x90\xD6\xE6\x90\xE6\x48\xE6\x91\xCB\xE6\xA6\xE5\x96\x6F\x05\x22\xE6\x23\xE6\x67\xE6\x92\xCB\xCF\x60\x00\x6B\xE7\x9A\xED\x1D\x61\x02\x6C\xE2\x89\x22\x01\x9C\xE7\x18\x0B\x8B\xE4\x01\xBB\xE1\x19\x0B\x8B\xE6\x01\xBB\xE3\x19\x0B\x8B\xE8\x01\xBB\xE1\x1A\x0B\x8B\xEA\x01\xBB\xE3\x1A\x0B\x8B\xEC\x01\xBB\xE1\x1B\x06\x9B\xFB\xBC\x6E\x03\x73\xE8\x24\x2F\x01\xD2\xE7\x65\xE9\x9A\xFE\x0C\x70\x01\x75\xE4\x7B\x31\x01\xDA\xE5\x66\xEC\x91\xEF\xE6\x2A\xE5\x69\xEF\x9D\xF1\xBC\x72\x01\x77\xE7\x9D\xE0\xE7\xA8\xE7\x78\xE2\x9E\xDB\xE4\x06\x07\x1C\x06\x9E\xEA\xE7\xDE\xE4\x7B\xEB\x25\xF4\x01\xBB\xE1\x1D\x0F\x9E\xF2\xE7\xE9\xE4\x7E\xEE\x9A\xD6\xE7\xF0\xE5\x98\x16\x07\x37\xE7\xE1\xE5\x7C\xE1\xA0\xE7\xE7\xFC\xE7\x52\x77\x07\x00\xE8\xF9\xE7\x80\xED\x9F\xCB\xE8\xFA\xE5\x67\xEE\xA0\xE3\xE6\x6A\xA8\x1E\x08\xA0\xFB\xE7\x1B\x51\x1E\x0B\x8B\xFA\x01\x13\xEB\x83\xED\x9A\xDA\xE8\xB3\xE4\x87\xE4\x9A\xC2\xE8\x09\xE8\x4A\x3B\x07\x3B\xE2\x7C\x01\x86\xE0\xA1\xE8\xE7\x14\xE8\xDC\xBD\x07\x26\xE8\x1B\xE8\xE3\x8E\x07\x2C\xE8\x1D\xEB\x89",
			"\xE5\xA0\xFA\xAD\x7F\x00\x8C\xEF\xA1\xD9\x0E\x80\x02\x8D\xE9\x7A\x01\x02\x9C\xE6\x20\x0B\x8B\xC3\x02\xBB\xE0\x21\x0B\x8B\xC5\x02\xBB\xE2\x21\x0B\x8B\xC7\x02\xBB\xE0\x22\x0B\x8B\xC9\x02\xBB\xE2\x22\x0B\x8B\xCB\x02\xBB\xE0\x23\x0A\xA3\xFA\xA9\x8D\x01\x86\xEE\x08\x13\xE9\x33\xE9\x88\xE9\x61\x18\xE9\x63\x18\x24\x0C\xA5\xE0\xE8\x29\xE8\x81\xEB\x9E\xCA\xE8\x4B\x75\x24\x0F\xA5\xE2\xE9\x60\xEA\x87\xEF\x99\xD9\xE9\x61\xEB\xE8\x82\x09\x27\xE9\x09\x07\x24\x00\xA7\xCD\xE8\x32\xEB\x98\xE3\xF2\x94\x02\xBB\xE1\x25\x03\xA7\xE4\xE9\xD4\x1A\x25\x0B\xA7\xDA\xE9\x6A\xE8\x8A\xE1\xA8\xEC\xE9\xC0\xC3\x25\x0F\xA7\xF3\x11\x98\x03\xA1\xE3\xA8\xF6\xE9\x6D\xE8\x9D\xED\xA2\xD1\x8E\x99\x03\x2E\xEA\x09\x0A\xEA\x75\xE9\x9A\xE5\xA9\xFE\x67\x9B\x00\xA5\xEF\xA8\xFD\x78\x9C\x02\xA6\xE1\xA3\xDB\xEA\x37\xD8\x00\x00\x10\x00\x28\xC4\x00\x00\xFF\x00\x81\x80\x80\x04\x85\x80\x82\x81\x02\x86\x86\x88\x81\x82\x85\x82\x86\x03\x8E\x80\x10\x8F\x7A\x8B\x88\x88\x16\x94\x99\x98\x82\x8A\x8D\x8E\x8E\x0E\x9E\xA1\x80\x9A\x82\x91\x92\x92\x0B\xA8\x85\x9D\x42\x0E\x85",
			"\x01\x8F\x0C\x9B\xB1\x90\x98\x82\x99\x9A\x9A\x09\xB8\x8D\x9A\x91\x8B\x93\x98\x9F\x37\xC0\xB9\x82\xAB\x9C\xA1\x9F\x93\x3F\xC8\x81\xAA\xA3\xA4\xA5\xA2\xA7\x47\xA9\x89\xB2\xAB\xA4\xA9\xA6\xAB\x4F\xD8\x91\xAF\x8A\x97\x81\xAF\x8B\x53\xDC\xA1\xA4\x8E\x4D\x96\x85\x97\x46\x95\xBC\x8A\xB9\xB6\x9B\xAA\xB1\x55\xF0\xAF\xBE\xA3\xB0\xB1\xB8\x82\x9F\x66\x86\x88\xB0\xAC\xB5\xBE\x8B\xA0\x7A\x85\x9C\xB6\x81\x52\xC0\x82\x84\x85\xA2\x47\xC0\x01\xC4\x83\x51\x8C\x8E\xC0\x04\x51\xCA\x89\x53\xCA\x0E\xA6\x58\xCA\x87\x53\xCE\x82\x54\x9E\x85\xA9\x41\xD4\x82\x54\xD2\xBB\x73\xA8\xD9\xB2\xBB\xD4\xBB\xBA\xD5\x5B\xAE\xE9\xC6\x9A\xAE\xBD\xDA\xB7\xAD\xB0\xF6\xCC\xD1\xDA\xDC\xDD\xDE\xB4\xBC\xFB\xD2\xD9\xD9\xE0\x83\x55\xA7\xC6\xFE\xCB\xB6\x8C\x55\xE5\xAF\xCA\xD1\xD0\xF3\xE5\xBA\xE9\xEA\xEA\xAF\xD6\xD9\xF8\xE3\xDC\xED\xE2\xEF\xC0\xE0\xC3\xEB\xED\xB4\xE6\xF3\xF2\xE8\xFF\xA7\xEA\xF9\xF7\xDB\xF4\xF7\xED\xC2\xFF\xC3\xFA\xED\xEF\xEB\xFB\xDB\xF8\xF6\xEF\xDD\x57\xE6\xFD\xEF\xFF\x61\x71\x80\x7D\x5F\x6E\x2E\x7D\x7E\x08\xBB\x7A\x80\x80\x09\x8C\x8B\x82\x80",
			"\x0D\x90\x8F\x80\x81\x03\xB3\x76\x87\x7B\xF2\x58\x84\x72\x84\x0E\x9D\x8C\x87\x87\x14\x91\x81\x8B\x84\x17\xB1\x7B\x87\x88\x1E\xA8\x80\x89\x89\xEC\x6D\x80\x7E\x8B\x19\xA6\x84\x78\x8C\x27\xAC\x8F\x8B\x8D\x31\xB4\x83\x8C\x8E\x35\x9A\x8B\x8D\x8E\x3C\xBF\x8D\x8E\x8C\xF5\x69\x86\x8C\x90\x48\x83\x9A\x8D\x91\x2B\xBE\x8C\x92\x8A\x50\x87\x9A\x91\x90\x4F\x92\x92\x93\x95\x55\x8E\x92\x7A\x95\x59\x84\x9B\x96\x96\x15\xA0\x92\x88\x97\x5F\x9E\x91\x9A\x99\x63\xA2\x94\x8A\x8F\xAF\x07\x8B\x98\x9A\x6F\x8B\x95\x9A\x9C\x67\xB4\x99\x98\x9C\x46\xAA\x99\x9C\x9E\x4D\xBC\x91\x96\x9E\x7D\xB6\x91\x9C\x95\x73\x84\xA5\x9E\xA1\x77\x82\xAB\x9E\xA2\x81\x88\xA3\xA1\x92\x58\x85\xA0\xA5\x97\x8C\xBF\x9E\x9C\x99\x87\x93\xA2\xA7\x94\x9A\x99\xAC\xA7\xA7\x91\x9E\xA1\xA9\xA2\x8E\x8B\xA5\xA9\xA3\x9D\xA4\xA9\xAB\xA3\xA0\x94\xA7\xAA\xA5\x95\x98\xAA\xA9\xAB\x9B\xA3\xAC\xAA\xAD\xA6\xAB\xA9\xAC\xAD\xA2\xAE\xAA\xAC\xAA\xBC\xB3\xA8\xAC\xB0\xC3\xB0\xAF\xAA\xAC\xB7\xB0\x2E\x9B\xAE\xC5\x96\x41\x2F\xB2\xC4\xBE\xA1\xB3\xAD\xD2\x8D\xB0\xA2\xB1\xBF\x98\xB3\xB4\xB3\xD5",
			"\x9D\xB5\xAE\xB7\xBD\x9F\xB2\xB9\xB8\xE4\x82\xB0\xBA\xB9\xE3\xA8\xB5\xB8\xB5\xE9\xAC\xBB\xB8\xB7\xED\xB0\xBF\xB9\xB4\xF1\xB4\xB3\xBE\xB6\xD6\x97\xA2\x46\x2C\xA7\x73\x20\xB4\xBE\xE7\xAE\xBA\xBB\xC0\x02\xC5\xC2\xBC\xC1\x07\xC6\xC6\xBC\xC2\xC4\xB4\x2F\xBC\xB2\x09\xD1\xCB\xC2\xC2\x00\xF5\xB5\xC7\xBD\x10\xD3\xC2\xC7\xC5\x0C\xDC\xC4\xC5\xC6\x1E\xDB\xC0\xCB\xC8\xD7\xA4\xCA\xBF\xC9\xB1\xA5\xCA\xC8\xCA\xC7\xAB\xC9\xC8\xCB\xD9\xA6\xCF\xCB\xCC\x2D\xF0\xCB\xB6\xC6\x38\xE1\xC9\xCE\xCC\x35\xF4\xC1\xCE\xCB\x3D\xC1\xDF\xCE\xCD\xF9\xBE\xC7\xCE\xCE\x48\xD6\x95\x2F\xC3\x40\xC3\xDA\x8E\x2D\x4C\xC4\xD1\xC2\xC8\x4D\xC7\xDC\xCE\xD3\x42\xD6\xD5\xD5\xD1\x59\xDC\xD8\xD7\xD7\x5A\xD2\xD6\xC7\xD5\x61\xC6\xDE\xD5\xD9\x5D\xD3\xDB\xCF\xD6\x6A\xC9\xDC\xDB\xD8\x6F\xD8\xC1\xDD\xC7\x64\xE7\xD6\xDD\xDB\x75\xF8\xD3\xDF\xC7\x7B\xD4\xD2\xDA\xDC\x7F\xF4\xDD\xDD\x6F\xB7\x11\xD6\xDA\xDE\x81\xFC\xD9\xE2\xDF\x87\xF0\xDB\xE3\xDA\x8F\xEE\xD1\xE5\xDE\x8E\xCD\xE0\xE2\xE5\x82\xD3\xE3\xE2\xE4\x98\xCA\xED\xE4\xE3\x69\xD5\xE1\xEB\xE5\xA3\xD9\xEF\xE4\xE4\xA7\xDC",
			"\xE5\xEA\xE7\xAB\xE0\xE0\xDB\xDD\xA2\xEF\xE8\xE2\xD9\xB8\x06\xED\xE8\xEA\xB7\xEA\xE2\xED\xEC\x68\xFB\xE4\xEA\xEF\xA6\xF9\xE4\xE7\xEF\xBD\xC5\xF0\xEC\xF1\xC7\xC1\xF0\xF0\xEB\xCB\xEE\xE6\xF3\xEC\xC2\xDB\xE3\xF2\xF2\xCF\xF5\xA9\x2E\xED\xCD\xF8\xE9\xF6\xEE\xD5\xC8\xF0\xF7\xF6\xD3\xCC\xFD\xF4\xF5\xC9\xE9\x6A\x2C\xF6\xE3\xE2\xF5\xFA\xF3\xEB\xDA\xF9\xF8\xFB\xDF\xEF\xFE\xF9\xFB\xDC\xF4\xF1\xF8\xFC\xBC\xF6\xF2\xF7\xFE\x9A\xFD\xF9\xEB\xFD\xF3\x71\x7E\xFE\x7E\x71\x7A\x87\x3B\x10\x7D\x03\x9F\x7C\xFF\x0A\x84\x80\xF0\x4B\x85\x80\x0C\x91\x80\x04\xC1\x4C\x16\x04\x82\x87\x82\xF9\x78\x82\xF7\x19\x8C\x83\x0D\x9E\x84\x7C\x1A\x80\x85\x07\xA2\x8F\x82\xF5\x61\x86\x84\x23\x88\x85\x09\xF8\x7B\x85\x00\xA9\x84\x85\xAF\x3D\x16\x05\xAF\x8E\x85\x16\xB5\x7F\x84\x30\x8A\x84\x09\xBB\x8A\x87\x1E\xB9\x87\x87\x35\x9C\x84\x10\xB7\x84\x86\x22\xB6\x80\x80\xF5\x7E\x17\x0C\xC7\x8F\x80\x07\x8D\x82\x7E\x46\x82\x89\x10\xBE\x83\x8B\x21\x88\x8F\x8A\x4D\x90\x88\x16\xCF\x89\x81\x09\x8E\x8A\x82\x5F\x9E\x8A\x16\xD9\x8D\x8B\x30\xA6\x8B\x8C\x5C\x98\x85\x15\xEB",
			"\x81\x8A\x2A\xAD\x8E\x8A\x5B\x7F\x17\x12\xD2\x8F\x8C\x36\x9B\x88\x8C\x68\x98\x8D\x19\xF9\x82\x8D\x3D\xBE\x8A\x8D\x75\x81\x93\x1D\xFD\x80\x91\x41\xA7\x8F\x8F\x45\x86\x90\x1F\x87\x95\x90\x32\x8D\x91\x8D\x89\x8E\x91\x24\x90\x9C\x88\x4A\xB4\x8A\x91\x7E\x80\x1B\x1C\xEE\x88\x93\x47\xBA\x8E\x93\x84\x93\x93\x27\xA2\x91\x95\x4A\xA3\x96\x94\xA5\x97\x92\x24\xA8\x9C\x90\x52\xAD\x94\x95\x8B\x91\x94\x22\xB0\x93\x96\x55\x96\x94\x93\xAB\x96\x97\x29\xBA\x99\x94\x5C\xB7\x90\x8E\xBF\x96\x8D\x2E\xBE\x9B\x96\x62\xBD\x90\x98\xC5\x88\x9B\x31\xC2\x91\x98\x41\x83\x9A\x99\xAF\x9C\x95\x34\xC6\x93\x9A\x68\xB2\x90\x94\xD5\x8C\x99\x32\xDA\x9B\x98\x67\x8D\x9D\x93\xAE\x97\x99\x38\xB5\x94\x9A\x71\xB4\x90\x9B\xC6\x61\x1B\x26\xD6\x94\x9C\x76\xA8\x9D\x9D\xDC\x85\x22\x30\x6B\x94\x59\x61\x34\x9E\x9B\xDB\x98\x9D\x37\xE0\x97\x9D\x71\xAF\x9F\x9F\xFE\x81\xA1\x3F\x83\xA2\x9A\x73\x85\xA0\x9E\xFA\x99\x99\x42\x86\xA5\x9C\x84\xBC\x9F\xA0\x00\xA4\xA1\x43\x91\xA0\xA3\xAF\x04\x1F\x9E\x0F\xAA\x7D\x31\x18\xA2\x22\x63\x27\x37\x18\xA7\x28\x1B\x69\x49\x17\x34\x65",
			"\x27\x33\x19\xA7\x2C\x1B\x69\x4D\x17\x34\x67\x27\x37\x19\xA7\x30\x18\x47\xDF\x9F\x99\x78\x8C\xA4\x59\xD1\x13\xA6\x8E\x52\x1A\xA7\x7D\xB5\xA3\xA1\x0E\xBF\xA5\x46\xEE\x92\xA1\x8A\x92\xA4\x9D\xD3\x1D\xA6\x42\xC3\xA6\xA7\xA0\xB4\xA4\x68\xD4\x0A\xAB\x4D\xCD\xA4\xA3\x89\x85\xAE\xAA\x47\xB4\xAB\x55\xC4\xA9\xAA\xA0\x95\xAC\xAB\x46\xA1\xAC\x56\xE2\xA0\xAD\xB1\xA6\xAD\xAC\x68\xBA\xA9\x57\xD6\x45\x1B\xD3\x16\x1A\xAA\x4E\xB9\x9C\x53\xE3\x37\x1A\xB8\x95\x58\x1B\x08\x99\x18\x02\xDA\x16\xAF\xAD\xAA\xAC\xAC\x4D\xBB\x1B\x69\x5C\x17\x35\x6E\x27\x36\x1B\xA7\x3F\x1B\x69\x60\x18\x81\x70\x27\x32\x1C\x8C\x22\x00\x19\xE4\x17\x35\x72\x27\x36\x1C\xA7\x27\x1F\x69\x68\x10\xAF\x74\x27\x32\x1D\x7D\xAB\xAE\x50\xA3\xBF\xA8\xB9\xBE\x43\x1D\xA7\x2C\x1D\x68\x80\xB0\xA9\x76\x2B\xB1\x35\xEE\x07\x37\x3B\x27\x30\x1F\xD3\x31\x1F\x34\xF2\x07\x37\x3C\x27\x34\x1E\xB8\xB5\x1F\xB5\x69\xBE\xAA\x5F\xC2\xB2\xB5\xD2\xBE\xA6\xB8\x4B\xA4\xB6\x69\xC8\xB3\xAA\xE2\xAC\xB3\xAE\xD0\xAA\xBB\x71\xCB\xB4\xBB\xE9\x96\xB9\xB9\xCC\xB1\xAF\x75\xCD\xB1\xBB\xEC\x9F\xAF\xAF",
			"\x67\xA4\x5A\x3D\x40\xB0\xBD\xE0\x9D\xBD\xBA\xD8\xA8\xBC\x77\xD2\xB9\xBD\xED\x9A\xBD\xBD\xF0\xAB\xBE\x77\xC3\xB7\xBC\xF7\x9F\xBE\xB9\xE1\xB8\xBE\x79\xEC\xB2\xBE\xF5\xAF\xBD\xBF\xF6\xB4\xBC\x7F\xFF\xB4\xC1\xFB\xB5\xB9\xBE\x05\xC2\xC3\x7C\xC5\xBE\xBE\x03\xC3\xC7\x9D\xF7\x04\xBE\x7E\xE5\xB4\xC3\x09\xD6\xC7\xC0\x00\xC8\xC2\x83\x8B\xCF\xB9\x07\xCA\xC5\xC1\x1F\xC1\xC0\x83\xA2\xCD\xC2\x0E\xF9\xB8\xC3\x09\xC3\xC6\x86\xA1\xCB\xC4\x15\xD9\xC7\xC5\x29\xC5\xC4\x88\xAE\xC1\xC7\x13\xDE\xC4\xC6\x1B\xD3\xC6\x8C\xA4\xC6\xC6\x13\xFB\xBE\xC7\x15\xC8\xC5\x8E\xBC\xCF\xC6\x1D\xFD\xC6\xC8\x45\xC4\xC9\x6F\x78\x12\xC2\x21\xEC\xC0\xC6\x43\xCD\xC7\x6B\x79\x1D\xC9\x1B\xEF\x32\x1F\xA7\x3B\x1C\x02\xFC\x17\x35\x7E\x27\x36\x1F\xC9\x27\x34\x00\x13\x0E\x24\x89\x01\x04\xCC\x67\x32\x22\x00\x68\xCB\x2E\x89\x03\x04\xCD\x83\x32\x20\x01\x70\xC8\x30\x89\x05\x04\xCE\x8D\x32\x22\x01\x78\xC2\x33\x28\xD0\xCF\xC9\x04\xC7\x00\x9F\xE4\x88\x01\x41\xC0\xCF\xC2\x56\xC7\xCA\x92\x88\xD7\xD0\x27\xF8\xC1\x7F\x09\x06\xD0\x92\xC1\xC9\xD1\x24\xD2\xCD\xA1\x0A\x12\xD3",
			"\xA2\x98\x9B\x00\x4D\xEF\x74\x01\x9E\xC4\x21\x03\x21\xD0\x00\x07\x24\xD7\x01\xA4\xD0\x00\xA9\x91\x04\xD4\x09\x24\xD3\x02\xA4\xD4\x00\xA9\x95\x04\xD4\x0B\x24\xD6\xCF\x35\xD6\xD0\x8C\x97\x07\xD7\xFC\x58\x05\xD7\x8F\xC1\xDB\x8E\x97\xDA\xD7\x5C\xD4\xD5\xD1\x95\xC4\x59\x06\x40\xD3\xD8\xE3\x5A\x04\xD9\x8A\xC4\xDB\xB1\x93\xDC\xD0\x6A\xCE\xD5\xD9\xC6\xD5\xDB\xA6\xC9\xDA\xDA\x69\xDD\xDF\xCF\xC2\xD1\xD8\xB8\xD8\xD8\xD7\x72\xC0\xD6\xDC\xE1\xC5\xD8\xBA\xE4\xD0\xD1\x0D\x10\xDA\xDD\xE7\xD1\xDD\xBA\xD3\xDB\xDA\x64\xF6\xDE\xDA\xDC\xD7\xDA\xB8\xD9\xDA\xDE\x78\xF3\xDF\xDB\xFC\xD9\xDE\xC0\xF7\xD5\xDE\x7C\xD9\xBC\x03\xEF\xD4\xDC\xA4\x1D\x09\xE0\x80\xEB\xDB\xDF\x0F\xFE\xDC\xBB\xFF\xDD\xDE\x85\xE3\xD8\xE2\xF2\xD3\xE2\xC6\x98\xE4\xE3\x81\xC6\xE7\xE3\x05\xE1\xE6\xB7\x95\xE3\x3C\x0F\x0D\xE4\xE4\x28\xFE\xE2\xC8\x97\xE2\xE2\x8E\xDB\xE5\xE5\x30\xF6\xE1\xC0\x84\xE3\xE4\x95\xF5\xE4\xE6\x2C\xF2\xE5\xC4\xBA\xE9\xE2\x97\xFE\xE1\xE6\x0E\xFD\xE4\xD0\xA9\xE8\xE7\x99\xE0\xE7\xE6\x47\xF9\xE4\x50\x9F\x07\xE4\x9B\xCA\xEC\xE8\x49\xE6\xEB\xCA\xD2\xE8",
			"\xE9\xA9\xFB\xE1\xE8\x1D\xE5\xEB\xD5\xD0\xE6\xEA\xA1\xFC\xE1\xEB\x51\xFB\xEA\xD3\xD4\xEF\xE9\xB1\xE2\xEA\xEB\x5E\xF8\xEB\xCB\xDF\xEB\xEC\xB5\xFF\xE4\xED\x6F\xEE\xEF\xD0\xE6\xE9\xEC\xAE\xD5\xEF\xEE\x65\xE8\xEC\xD8\xDD\xEB\xEF\xD7\x60\x05\xE9\x7A\xED\xEE\xDD\xF9\xEE\xBF\x10\x00\xF1\xEC\xB5\x42\x07\xE1\xC1\x43\x04\x52\xE4\x04\xD4\x25\x04\xD6\x09\x24\xD7\x04\x52\xE8\x04\xD4\x29\x04\xD6\x0A\x24\xDB\x04\x52\xEC\x04\xD4\x2D\x0B\xF0\xDE\xE4\xE4\xF5\x6A\x6E\x02\xF4\xC6\x6F\x04\xEA\xA5\xF5\xEE\xBA\xFD\xEC\xF0\x7C\xE2\xF3\xD8\xB0\x0B\xF5\xB3\xC8\xF7\xF5\xAC\xF8\xF6\xED\xB1\xF1\xEF\xC1\xF9\xF2\xF6\x81\xFD\xF6\xEB\xC0\xF7\xF6\xE2\xFC\xF3\xEE\xC1\xE5\xD9\x0C\x35\xFD\xF5\xE4\xF0\xE8\xF9\xFE\xB2\x07\xEA\xB3\x0C\xF8\xE4\x74\x05\xFA\xC6\xE3\xF7\xEE\xDA\xFD\xF9\xE2\xC2\xFE\xF9\x72\xEF\xFA\xF8\xE1\xF4\xFC\xDF\xDB\xF8\xF6\xDC\xFA\xF5\xF7\xC7\xF3\xFC\xF3\xEB\xF9\xFD\xD9\xE8\xFE\xFC\xBF\xFF\xFA\xEF\xD0\xFC\xFD\xE5\xE3\xF9\xFD\xF8\xF6\x4B\x1A\x18\xFB\xFF\xF0\x70\x80\xF3\x7F\x4E\x36\x0F\x7F\xC5\x67\x03\x06\x8D\x7E\xFA\x77\x7F\x01\x8C",
			"\x80\x03\x8F\x7E\x0F\x8A\x7E\x12\x81\x7F\xF4\x7E\x80\x15\x8A\x80\xE0\x7E\x7E\x13\x82\x80\x17\x89\x7F\x19\x8B\x80\x18\x86\x7F\x21\x8C\x7F\x20\x8E\x81\x22\x86\x82\x24\x8F\x81\x2A\x81\x75\x38\x09\x80\x28\x8D\x80\x23\x80\x83\x2F\x83\x7F\x39\x0E\x82\x1A\x84\x81\xE7\x7D\x81\x37\x8C\x81\x39\x8D\x83\x10\x8A\x83\x25\x8B\x83\x16\x8E\x83\xB8\x7A\x03\x36\x81\x84\x48\x8B\x82\x29\x87\x82\x42\x81\x83\x11\x88\x83\x3F\x84\x84\x50\x8B\x81\x43\x81\x85\x56\x84\x85\x4E\x80\x84\x4A\x82\x83\x4D\x83\x83\xA4\x7B\x03\x47\x8B\x85\x4F\x8C\x83\x57\x83\x85\x66\x84\x86\x58\x8E\x85\x52\x88\x86\x67\x85\x85\x69\x8D\x85\x70\x89\x84\x4C\x82\x11\x3C\x01\x86\x73\x82\x86\x5A\x87\x87\x7A\x8B\x84\x7C\x8C\x85\x72\x8D\x87\x63\x8E\x86\x6D\x89\x85\x6B\x82\x88\x6C\x87\x88\x86\x89\x88\x84\x85\x86\x88\x8B\x88\x6F\x8F\x87\x7E\x88\x87\x85\x8E\x88\x14\x8D\x03\x76\x80\x88\x79\x88\x89\x93\x8A\x86\x8C\x8A\x88\x9C\x8F\x88\x92\x8D\x89\x94\x8D\x88\x9F\x83\x88\xA5\x84\x8A\x71\x81\x8A\xA0\x8B\x87\x91\x8C\x8A\x81\x83\x8A\x9E\x89\x8A\x0A\x1E\x03\x97\x8D\x8A\x9A\x82\x8A",
			"\xA7\x81\x8B\x90\x8F\x8A\xB9\x80\x8B\xBE\x8D\x8B\xC0\x82\x8B\xB7\x88\x3C\x3F\x05\x8B\xBC\x82\x8C\xB6\x89\x8C\xC7\x8B\x8B\x99\x8A\x8C\xCD\x8B\x8C\xAA\x86\x8A\xC8\x80\x8D\xAE\x8F\x8C\xD6\x8B\x89\xD3\x87\x8D\xB8\x88\x62\x40\x06\x8C\xD6\x81\x04\xDE\x82\x04\xA4\x63\x04\xA4\x64\x04\xA4\x65\x04\xA4\x66\x04\xA4\x67\x04\xA4\x68\x04\xA4\x69\x04\xA4\x6A\x04\xA4\x6B\x04\xA4\x6C\x04\xDE\x88\x8D\xCC\x82\x40\x4D\x07\x8F\x5F\x1E\x04\xFC\x8B\x8A\xC3\x82\x8D\xF9\x8B\x8D\x03\x98\x3C\x4F\x0F\x8F\x02\x91\x8D\xA8\x85\x90\x09\x95\x8D\xF8\x8A\x90\xBA\x80\x91\xBF\x89\x8D\x0F\x9E\x90\x04\x92\x91\xC1\x8C\x90\x0B\x92\x23\x50\x04\x6A\x51\x08\x90\x1B\x91\x75\x52\x00\x92\xCC\x23\x05\xAB\x74\x05\xAB\x75\x05\xA4\x66\x05\x24\x93\x91\x1A\x9C\x2C\x57\x04\x6A\x58\x04\x6A\x59\x04\x6A\x5A\x04\x6A\x5B\x04\x6A\x5C\x0B\x7A\x5D\x04\x6A\x5E\x08\x67\x92\x5C\x45\x60\x04\x6A\x61\x04\x6A\x62\x04\x6A\x63\x04\x6A\x64\x0E\x8D\x65\x04\x6A\x66\x0D\x92\x19\x98\x91\x14\x95\x2B\x67\x04\x6A\x68\x00\x95\x53\x95\x17\x69\x08\x95\x12\x1A\x06\xA4\x6B\x06\xA4\x6C\x06\xA4",
			"\x6D\x06\xA4\x6E\x06\xA4\x6F\x06\xA4\x60\x07\x5C\x92\x95\x2F\x9E\x92\x32\x21\x07\x6B\x9A\x47\x72\x01\x97\x01\x91\x92\x75\x91\x91\x16\x90\x90\xCE\x85\x91\x77\x9E\x96\x79\x9D\x90\x7D\x95\x3F\x73\x04\x6A\x74\x04\x97\x7B\x90\x68\x75\x06\x98\xA0\x26\x07\xAB\x77\x07\xAB\x78\x07\x8A\x9A\x8D\x7A\x96\x3C\x79\x04\x6A\x7A\x04\x6A\x7B\x04\x6A\x7C\x04\x6A\x7D\x04\x6A\x7E\x0B\x7A\x7F\x04\x6A\x80\x00\x94\x64\x42\x08\xA4\x63\x08\xA4\x64\x08\xA4\x65\x08\xA4\x66\x08\xDE\x87\x08\xA4\x68\x08\x91\x9C\x97\x87\x93\x99\x57\x29\x08\xA4\x6A\x08\xB3\x97\x91\x0A\x1B\x08\x91\x9C\x08\xA4\x6D\x08\xA4\x6E\x08\xA4\x6F\x08\xA4\x60\x09\xA4\x61\x09\xA4\x62\x09\xBB\x96\x9B\xB4\x94\x8D\x41\x23\x09\xCD\x94\x3E\x94\x03\x9D\x76\x95\x9B\x80\x98\x9D\xD7\x90\x9D\xDA\x98\x97\x81\x99\x95\xD9\x9C\x9D\xE2\x90\x00\x95\x06\x9D\xDE\x9D\x9D\x7E\x9F\x9D\x6D\x91\x95\x7F\x9B\x9D\x92\x91\x9E\xEF\x9E\x9E\xCF\x91\x9F\xE7\x93\x9E\xF3\x97\x9F\xBC\x9A\x9E\x6C\x92\x23\x96\x06\x9E\xE9\x98\x9E\xEC\x9A\x9F\xED\x95\x9F\xF4\x9F\x9F\xF6\x99\x9F\x00\xA0\x9E\xF2\x98\xA0\x07\xAE",
			"\x9C\x0C\xA5\xA0\x01\xA9\xA0\xEB\x96\x11\x97\x04\x9A\xFB\x93\xA0\x06\xA0\xA1\x0A\xA4\xA0\xF8\x9E\xA0\x1E\xA0\x9F\x1D\xA0\xA2\x0F\xA1\xA2\x0B\xAF\xA1\x25\xA2\xA2\x26\xAC\xA1\x23\xAB\xA2\x29\xA9\xA1\x24\xAA\xA2\x2D\xA1\xA1\x0D\xA4\x81\x99\x0E\x9F\x32\xAA\xA1\x13\xA9\xA3\x17\xA2\xA0\x3C\xA2\xA1\x3B\xAE\xA3\x18\xA7\xA3\x2F\xAE\xA2\x2C\xA8\xA2\xE4\x3A\x09\xA4\x6B\x09\x36\xAB\xA1\x44\xA1\xA3\x4C\xA2\xA4\x45\xA7\xA2\x52\xA0\xA3\x46\xAB\x6F\x9C\x0B\xA4\x3A\xA1\xA4\x4F\xAB\xA5\x63\x7D\x09\x58\xAF\xA3\x33\xA3\xA5\x4D\xA5\xA5\x54\xA2\xA6\x50\xAE\xA4\x59\xAE\x5E\x9E\x0F\xA5\x5A\xA9\xA6\x40\xAD\x35\x9F\x0C\xA6\x41\x20\x0A\x72\xAF\xA6\x76\xA1\xA6\x65\xA9\xA7\x63\xA6\xA6\x5C\xA0\xA6\x38\xAE\xA7\x43\xA7\xA6\x64\xA9\xA1\xA1\x05\xA7\xC6\x32\x0A\xAB\x73\x0A\xDE\x84\x0A\xA4\x65\x0A\xA4\x66\x0A\xA4\x67\x0A\xA4\x68\x0A\xA4\x69\x0A\xA4\x6A\x0A\xA4\x6B\x0A\xA4\x6C\x0A\xA4\x6D\x0A\xA4\x6E\x0A\x86\xAF\xA7\x6D\xAE\x10\xAF\x01\x99\xB0\x01\xAA\x81\xAD\xA7\xA3\xAB\xAA\x3D\xA0\x63\xB1\x08\xAA\x51\xAA\xA7\x82\xA9\x1A\xB2\x00\xAB\xB4\x43\x0B",
			"\xDE\x84\x0B\xA4\x65\x0B\xA4\x66\x0B\xA4\x67\x0B\xA4\x68\x0B\xA4\x69\x0B\xA4\x6A\x0B\xA4\x6B\x0B\xA4\x6C\x0B\xA4\x6D\x0B\xA4\x6E\x0B\xB6\xA3\xA8\x37\xAF\x0B\x91\x90\x0C\xCF\xAC\xA7\x6E\xA8\xA7\x7B\xA2\xAB\x28\x61\x0C\xD5\xAC\x3E\xC2\x0D\xAD\xD9\xA1\xAE\xB3\xAA\xAD\xD7\xA2\xAA\xAD\xA6\xAE\x77\xA8\xAE\xD8\xA3\xAE\xE2\xAA\xAA\xE7\xA9\xAA\xE5\xA0\xAF\x45\x73\x0C\x91\x94\x0C\xE0\xAC\xAE\xF8\xAE\xAE\xE9\xA2\xAF\xAC\xAB\xAF\xB1\xAD\xAE\xF1\xAF\xAF\xF9\xA1\xB0\x68\xA5\x74\xC5\x07\xAF\x56\x26\x0C\x08\xB4\xB0\xD0\xAA\xAF\xEB\xAE\xB0\xEA\xA1\xB1\xFC\xAF\xAE\x02\xB0\xB1\x13\xBE\xAF\x05\xBD\xAF\x04\x17\x0C\x0B\xB0\xA8\x15\xBC\xB0\xD6\xAE\xB1\x19\xB4\xB1\x23\xB8\xB1\x0D\xB0\xB2\x16\x88\x0C\x1D\xBA\xB1\x12\xBF\xB1\x22\xB7\xB2\x2F\xB1\xB2\x2C\xB7\xB1\x0F\xB8\xB2\x00\xB1\xB3\xE4\xA8\xB3\x37\xB3\xB3\x2E\xBC\xB3\x25\xB5\xB3\x3A\xB3\xB0\x41\xB6\x11\xC9\x0B\xB2\x24\xB0\xB3\x3E\xB8\xB4\x47\xB2\xB3\x4B\xB9\xB3\x49\xBC\xB4\x26\xB0\xB5\x40\xBF\xB4\x4E\xBD\xB4\x3B\xB6\xB5\x42\xB4\xB5\x57\xB1\xB5\x55\xBC\xB5\xC4\x2A\x0C\x46\xBE\xB5\x59",
			"\xB8\xB5\x16\xBD\xB3\x64\xB6\xB3\x63\xB2\xB6\x65\xBF\xB3\x57\x2B\x0C\x61\xB3\xB5\x67\xB3\xB4\x68\xBB\xB6\x4A\xBA\xB6\x73\xB7\xB7\x72\xB9\xB7\x5A\xB9\xB6\x70\xB6\xB7\x7A\xB1\xB7\x7B\xB8\x62\xCC\x0F\xB6\x2D\xBC\xB6\x34\xB5\xB8\x75\xBD\xB7\xC6\x3D\x0C\x84\xB7\xB8\x8E\xB6\xB6\x7E\xB1\xB8\x78\xB2\xB9\x7F\xB1\xB9\x80\xB7\xB9\x96\xB9\xB9\x8A\xB8\xB8\x52\xBC\xB9\x5D\xBB\xB9\x8F\xB6\xB8\x90\xB0\xBA\xA3\xBE\xB9\x5B\xB4\xBA\xA2\xB9\xBA\x89\xB6\xBA\x7C\xBE\x47\xCE\x0D\xB8\xA5\xB1\xBA\xD8\x6F\x0C\xB0\xB5\x17\xD0\x0B\x7A\xD1\x0E\x8D\xD2\x04\x6A\xD3\x04\x6A\xD4\x04\x6A\xD5\x04\x6A\xD6\x04\x6A\xD7\x04\x6A\xD8\x04\x6A\xD9\x04\x6A\xDA\x04\x6A\xDB\x04\x6A\xDC\x05\xBB\xAB\xB8\x6B\xDD\x01\x99\xDE\x00\xBD\x9D\xB2\xBB\xD7\xB1\xBB\x0F\xAF\x0D\xD6\xBF\xB9\xAC\xBE\x7B\xE0\x0D\xBD\xF3\x31\x0E\xDE\x82\x0E\xA4\x63\x0E\xA4\x64\x0E\xA4\x65\x0E\xA4\x66\x0E\xA4\x67\x0E\xA4\x68\x0E\xA4\x69\x0E\xA4\x6A\x0E\xA4\x6B\x0E\xA4\x6C\x0E\xE2\xBD\xBA\xB8\x6D\x0E\x91\x9E\x0E\xFB\xB4\xB7\xD9\xBA\xBA\x03\xC0\x9F\xEF\x01\xC0\x93\xB8\xB9\xA8\xB8\x6D\xF0\x0E",
			"\x8D\xF1\x0E\x8D\xF2\x08\xC0\x95\xBB\xB9\xF3\x06\xA1\xFE\x55\x0F\x12\xC6\x36\xF6\x01\x99\xF7\x09\xC1\x98\x88\x0F\xA4\x69\x0F\xA4\x6A\x0F\xA4\x6B\x0F\xA4\x6C\x0F\x16\xC6\x10\xFE\x07\x6B\x78\x63\x00\x6A\x64\x01\x0E\x11\x94\x3A\x24\x00\x30\xC9\x66\x44\x35\x00\x35\xCD\x66\x7E\xA6\x00\x39\xC1\x67\x13\xCF\xBD\x09\xCA\xB9\xA4\x77\x00\x3D\xC5\x67\x44\x38\x00\x45\xC9\x67\x44\x39\x00\x49\xCD\x67\xDA\xB4\xC0\xC5\x6A\x00\x49\xC2\xC3\xEE\x5C\x00\x4D\xC1\xC4\xA2\x67\xC5\x5C\x4E\x00\x5A\xC4\xB9\xFE\x5F\x00\x5D\xC6\x10\x10\x01\xC6\x05\x11\x01\x64\xC4\x10\x12\x07\xC6\x63\x63\xC5\x12\x15\x01\x6A\xC6\x01\x49\xCE\xC2\x0E\x19\x01\x6C\xC2\x23\x1B\x0A\xC6\xD5\x2C\x01\x78\xCF\xA0\x1D\x0B\xC7\x50\xC7\xBA\x40\xCF\xC3\xB8\x6E\x01\x7E\xC1\xBD\x4F\xC6\xC8\x7F\xCC\xBF\x87\xC5\xC0\x8C\xCE\xBD\xD8\xBE\xC8\x5F\x1F\x01\x85\xCD\xC8\x80\xCF\xC8\x95\xCB\xC8\x90\xC9\xC8\x02\xC9\xC9\x88\xCD\xC9\x94\xCA\xC8\x9A\xC8\xC5\x81\xCE\xC5\x41\x20\x02\x93\xCC\x3E\x21\x07\xCA\x97\xC1\xCA\x82\xC8\xC9\xAB\xCE\xC9\x9C\xCF\xC9\x9B\xCF\xCA\xB2\xC2\xCA\x96\xC0\x54",
			"\x22\x0A\xCA\x00\x73\x02\xBA\xC3\xCB\xA0\xC0\xCB\xB4\xC1\xCB\xC2\xC1\xCC\xC4\xCF\xCB\xB5\xCD\xCA\xAC\xC4\xCA\x87\x44\x02\xBD\xC3\x76\x25\x0D\xCC\x0E\x16\x02\xD0\xCA\x23\x27\x0A\xC6\x28\x0A\xC6\x29\x0A\xC6\x2A\x0A\xC6\x2B\x0A\xC6\x2C\x0A\xC6\x2D\x0A\xC6\x2E\x0A\xC6\x2F\x0A\xC6\x30\x0A\xC6\x31\x03\xCD\x0A\xC3\xCA\x41\x22\x03\xEA\xCF\x3A\x33\x0F\xCE\x0B\xC7\xCC\xCA\xC3\xCF\xC3\xC0\x54\x34\x02\xCF\xEC\xC2\xC4\xB7\xC6\x11\x35\x0A\xCF\xF3\x96\x03\x00\xDF\x15\x37\x0A\xC6\x38\x0A\xC6\x39\x0A\xC6\x3A\x0A\xC6\x3B\x0A\xC6\x3C\x0A\xC6\x3D\x0A\xC6\x3E\x0A\xC6\x3F\x0A\xC6\x40\x0A\xC6\x41\x03\xD0\xC9\xCB\xCE\x42\x0A\xD1\xC2\x23\x04\x1E\xD4\xCF\xEB\xCD\xCF\xB6\xCE\xCA\xE3\x14\x04\x21\xD7\xCF\xBE\xCB\xD2\xA2\xC5\x04\x29\xDD\x1B\x46\x0F\xD2\xE3\x17\x04\x32\xDC\xD2\xC8\xC4\x3E\x48\x05\xC7\xFE\x5A\x04\x35\xDC\x8C\x4B\x0D\xD3\x32\x2C\x04\x40\xD5\xCF\x76\x3D\x04\x6A\xCE\x04\x6A\xCF\x04\x6A\xC0\x05\x6A\xC1\x05\x3A\xD6\x10\x53\x0A\xC6\x54\x01\xC7\x12\x17\x05\x4F\xD0\x29\x59\x03\xD4\x06\x1A\x05\x5A\xD3\x7A\x5B\x0D\xD5\xF6\xC5\xCC\x36",
			"\xD4\xD4\x02\x4C\x05\x60\xD0\x00\x5D\x07\xD6\x5E\x07\xD6\x24\xD7\xD3\xB7\x2F\x05\x57\xD0\x63\x61\x0C\xD6\x3F\x82\x06\x74\xD5\x17\x63\x07\xD7\xC0\xC8\x2F\x64\x0A\xC6\x65\x0A\xC6\x66\x0A\xC6\x67\x0A\xC6\x68\x01\xD7\x00\x0A\x06\x6A\xCB\x06\x54\xDE\x10\x6E\x06\xD8\xCA\x10\x07\x67\xD1\x07\x7A\xDB\x6F\x72\x03\xD9\x2A\xD5\xD2\x1B\xDC\xCF\x5F\x13\x07\x96\xD2\xD6\x98\xDB\xD7\x63\xD3\xD2\x26\xD1\xDA\x9A\xD9\xD9\x61\xD0\x54\x74\x0D\xD9\xC6\xC7\xD9\x6E\xDC\xDA\x64\xD3\xDA\x9F\xD2\xD2\xA5\xD0\xDA\xB1\xDE\xDA\xA2\xD6\xDA\xFB\xC7\xDA\x56\x25\x07\xAA\xD6\x11\x76\x0D\xDB\xB5\xDE\xD9\xAD\xD2\xDC\xAF\xD8\xDB\x6D\xD5\xDC\xB4\xD3\xDC\xAB\xD4\xDC\x53\x77\x07\xC0\xD4\x34\x78\x0F\xDC\xC8\xD2\xDB\xBA\xD1\xDC\xCB\xD7\xDD\xA4\xD5\xDD\xCA\xD9\xDD\xB9\xDD\xDD\xF3\x99\x07\xD2\xDD\x47\x7A\x0A\xCF\x7B\x07\xD6\x7C\x0A\xC6\x7D\x0A\xC6\x7E\x0A\xC6\x7F\x0A\xC6\x80\x0A\xC6\x81\x0A\xC6\x82\x0A\xC6\x83\x0A\xC6\x84\x0A\xC6\x85\x0A\xC6\x86\x01\xDE\xB3\xDE\x9E\x87\x0C\xDF\x04\x18\x08\x00\xEE\xDD\xB0\xDB\xDD\xD6\xD9\x8D\x89\x03\xE0\xC7\xD7\xDB\x14\x8A",
			"\x08\x0A\xE0\x68\x8B\x07\xD6\x8C\x0A\xC6\x8D\x0A\xC6\x8E\x0A\xC6\x8F\x0A\xC6\x90\x0A\xC6\x91\x0A\xC6\x92\x0A\xC6\x93\x0A\xC6\x94\x0A\xC6\x95\x0A\xC6\x96\x0F\xE0\xC6\xDF\x83\x97\x03\xE0\x98\x08\xE2\xC9\xD3\xDD\xB6\xDD\xDF\x04\xA9\x09\x2E\xE4\xDD\x04\xE9\xE2\x34\x6A\x09\x67\xDB\x09\x67\xDC\x09\x35\xE1\xE3\xDA\xDA\x23\x9D\x0E\xD8\xE3\x4F\x09\x3F\xE2\x73\xA0\x03\xE0\xA1\x07\xE4\xD8\xD2\x11\xA2\x0A\xC6\xA3\x0A\xC6\xA4\x0A\xC6\xA5\x0A\xC6\xA6\x06\xD8\xA8\x0A\xC6\xA9\x0B\xD8\x0A\x1C\x0A\x44\xE5\x17\xAE\x07\xD6\xAF\x0C\xE4\x98\x40\x0B\x64\xE7\xE0\x68\xE6\xE0\x78\x81\x0B\x67\xD2\x0B\x67\xD3\x0B\x67\xEA\xE6\x44\xD4\x0B\x5F\xE7\x50\xB6\x01\xE7\xFE\x57\x0B\x03\xE8\x0B\x78\xEB\xCE\xB9\x0A\xC6\xBA\x0A\xC6\xBB\x0A\xC6\xBC\x0A\xC6\xBD\x06\xD8\xBF\x0A\xC6\xC0\x0C\xE5\x06\x13\x0C\x75\xE9\x1A\xC5\x07\xD6\xC6\x0D\xE7\x87\x47\x0C\x94\xE1\xE4\x0C\xE6\xE3\x87\xB8\x0C\x97\xE7\xE3\x2F\xE9\xE9\x40\xEE\xE9\x9A\xE5\xE0\x30\xEC\xDC\x42\xC9\x0C\x9D\xEB\xE0\x32\xE6\xEA\x98\xEB\xEA\x4D\xE2\xE7\xA0\xEC\xEA\xA2\xE1\xEA\xAA\xED\xEA\xB6\xE3\xEB",
			"\x19\xAA\x0C\x03\xEB\x0C\xA9\xE4\xEA\xB1\xEF\xEA\xA5\xE0\xEC\xBF\xEC\xDD\xB5\xE8\xEB\xC2\xEE\xEA\xC4\xEE\xEB\xC8\xE9\xE6\xC1\xE9\xEC\x38\xEF\xE9\xCB\xE0\xEB\xD1\xEA\x47\xCC\x0D\xEB\x6C\xBD\x0C\xD6\xE0\xED\xA0\x2E\x0C\xD9\xE9\x1A\xCF\x0D\xED\xB4\xEA\xEC\xB7\xE5\xEC\xE4\xE2\xEE\xC6\xEE\xEC\xDA\xE7\xEE\xCC\xE3\xEC\xEB\xE3\xED\xEC\xE2\xED\xE3\xE6\xEE\xE5\xEF\xEC\xA3\xE8\xDB\xD0\x00\xEE\xB2\xE3\xEF\xE9\xEA\xEF\xF5\xEB\xEF\xF2\xEF\xEF\xF4\xE1\xEE\x01\xF9\xEF\x00\xF4\x3E\xD1\x08\xEF\xC7\xE1\xEF\x03\xF9\xF0\xEA\xE0\xEF\x0D\xFD\xEC\xED\xEA\xF0\xFE\xEB\xF0\xE8\xED\xEF\x16\xF1\xEA\xD2\x08\xF0\x15\xF2\xF0\x13\xFD\xF1\x17\xF4\xF0\x14\xF1\xF1\x57\x23\x0D\x1A\xF2\xF2\xFC\xEC\xF1\x1F\xFC\xF0\x27\xF0\xF2\x1E\xF8\xF2\x2E\xFC\xF2\x29\xFB\xF1\x30\xFF\xF2\x2A\xF0\x68\xD4\x05\xF2\x0E\xFB\xF2\x35\xF1\xF2\x39\xF5\xF0\x31\xF2\xCA\xD5\x08\xF3\x66\x36\x0D\x42\xFF\xEE\x10\xFD\xF3\x3C\xF7\xF4\x4A\xF6\xF4\x4C\xFE\xEE\x4E\xF2\xF1\x3F\xF8\xF4\x2D\xF9\x85\xD7\x05\xF4\x4F\xFF\xF0\x4D\xF0\xF5\x34\xF2\xF3\x3B\xF3\xF5\x5D\xF1\xF5\x4B\xF7\xF5\x3A",
			"\xFC\xF5\x64\xF6\xF2\x3E\xFB\xF5\x66\xF9\xF4\x59\xF8\xF5\x05\x18\x0D\x56\xFA\xF5\x19\xA9\x0D\x6F\xFC\xF6\x70\xFF\xF5\x68\xF2\xF5\x60\xFB\xF6\x63\xF9\xF6\x5E\xF5\xF6\x78\xF7\xF7\xFE\x5A\x0D\x73\xFB\xF7\x7F\xF3\xF3\x86\xF6\xF7\x87\xFE\xF7\x44\xDB\x0D\x83\xF7\xF6\x89\xFC\xF7\x79\xF2\xF6\x8E\xF8\xF8\x94\xFA\xF8\x7A\xF3\xF9\x96\xF2\xF9\x6A\xFA\xF9\xE9\xEC\x0D\x8D\xFB\xF9\x75\xF9\xF9\xA1\xF0\xF9\x80\xF7\xF9\x6C\xBD\x0D\x9F\xFD\xF7\x3E\x2E\x0D\xA9\xFE\x9E\xDF\x0D\xFA\xA5\xFC\xF9\x91\xF3\xFA\x85\xF5\xF9\xA4\xFF\xF8\xB5\xF2\xFA\x74\xFB\xFB\x84\xF1\xF6\xB4\xFE\xFB\xBC\xF8\xF9\xB7\xF6\xFB\xB9\xF2\x11\xE0\x00\xFB\xB8\xFA\x23\xE1\x08\xFC\x37\xA2\x0E\xCC\xFA\xFB\xBD\xF6\xFA\xAA\xF5\xFC\xD4\xF0\xFC\xD1\xF2\xFB\xCC\x23\x0E\xCF\xF3\xFC\xD0\xF2\xFC\xD5\xF2\xFD\xB3\xF1\xFC\xA0\xF2\xFE\xD3\xF6\xFD\xDE\xF6\xFE\x6C\xB4\x0E\xDB\xFF\xFD\xD8\xF9\xFC\xE0\xF1\xFB\xBF\xFF\xFE\xEE\xFD\xFE\xC4\xF8\xFE\xE5\xF2\xFF\xF5\xF8\xFF\xDD\xF3\xFE\xD7\xF1\xFF\xF4\xF9\x8D\xE5\x07\xAC\x66\x07\xF5\x76\xFF\x7B\x37\x39\x04\x80\xFA\x7C\xFB\x4A\x80\xF6\x7E",
			"\xFF\x0D\x80\xF9\x61\x7F\xFD\x7F\x01\xB0\x7E\x09\x83\xFF\x0E\x81\x04\x97\x80\xE7\x79\x01\xBE\x52\x74\x0A\xC6\x69\x04\x02\x9F\x7F\x0B\x85\x00\x93\x80\x0C\x8C\xFF\x19\x80\x08\x8C\x80\x14\x81\xFF\x67\x80\x11\x85\x01\xA9\x83\xFE\x77\x7F\x2B\x82\x03\xAC\x80\x15\x86\x01\xA6\x81\x0D\x85\x81\x34\x32\x1D\x1F\x81\x1B\x80\x03\xBC\x82\xFA\x0B\x07\x3B\x86\x05\xA1\x80\x19\x84\x04\xB1\x82\x11\x9E\x81\xEC\x1C\x1D\x01\x82\x12\x8D\x03\xDD\x6D\x3B\x07\x6B\xEE\x03\x09\xB6\x80\x21\x88\x02\xCC\x80\x04\x93\x82\x56\x84\x59\x2F\x06\x29\x88\x03\xCD\x83\xE1\x50\x07\x67\x69\x1E\x1C\x82\x2F\x88\x05\xE5\x81\x17\x97\x82\x67\x83\x04\xB5\x14\x79\x03\x06\xA9\x0F\x3C\x0D\x83\x6A\x81\x0D\xAD\x81\x2C\x83\x07\xE6\x80\x19\x92\x83\x34\x84\x0A\xB3\x81\x17\x88\x06\xF0\x4C\x3D\x10\x83\x75\x80\x0F\xBC\x83\x38\x87\x07\x85\x85\x1F\x87\x84\x84\x80\x11\x81\x84\x43\x89\x08\x8D\x87\x22\x8A\x84\x79\x84\x0E\x91\x85\xFC\x15\x0F\x00\x87\x24\x82\x84\x43\x85\x20\x36\x06\x4B\x83\x08\x8F\x86\x23\x97\x84\x8C\x86\x13\xA2\x84\x7C\x17\x0F\x1C\x85\x26\x88\x82\x80\x60\x1F",
			"\x27\x6B\x7C\x06\x0A\xD5\x82\x1D\x90\x84\x9D\x80\x14\xB0\x85\x53\x80\x00\x7A\x05\x2B\x9B\x83\xB4\x83\x3E\x7B\x07\xB3\x6C\x0F\x37\x85\x11\x88\x85\xB2\x87\x13\xB1\x85\x61\x89\x0B\xDF\x09\x3F\x1E\x85\x05\x0E\x1F\x08\x86\x60\x84\x0C\xAE\x84\x26\x8E\x86\xA1\x81\x18\xA3\x85\x66\x88\x0B\xD0\x87\x2C\x96\x86\xDC\x13\x19\xBA\x83\x5F\x8B\x0D\xC7\x81\x37\x8C\x86\xC5\x87\x19\x95\x87\x71\x8C\x0D\xD5\x14\x00\x15\x00\x65\x30\x1B\x93\x87\x70\x81\x0D\xD4\x85\x39\x8F\x85\x16\x41\x00\x28\x86\x1B\x64\x0E\xDE\x86\x24\x8E\x87\xF6\x80\x1E\xAB\x86\x75\x82\x0D\xFD\x84\x3E\x80\x87\xFC\x87\x1F\x9F\x86\x00\x02\x00\x73\x86\x0E\x75\x87\x00\x88\x21\x83\x89\x7B\x8C\x0E\xD7\x85\x35\x43\x00\x06\x8E\x87\x4A\x88\x86\x85\x74\x04\x01\x44\x86\x62\x44\x6D\x00\x17\x88\x25\x66\x36\x06\x03\x46\x92\x0C\x07\x07\x23\x92\x08\x04\x02\x12\x8E\x09\x02\x05\x89\x0A\x0A\x01\x28\x88\x83\x0B\x00\x2B\x89\x41\x0C\x00\x2E\x8A\xD4\x31\x89\x52\x33\x13\x8F\x03\x4C\x90\x00\x33\x8C\x22\xAC\x59\x08\x09\x13\xF9\x1E\x04\x1D\x89\xE2\x87\x1D\x81\x8B\x7C\x82\x2A\x13\x00\x50\x90",
			"\x4F\x14\x07\x28\x8E\x88\xA1\x8D\x0E\x8D\x8A\x30\x8E\x8A\xFB\x83\x22\xBA\x86\x7F\x80\x15\xD4\x89\x40\x8D\x63\x4A\x8F\x29\x97\x8B\xAD\x82\x15\xC3\x89\x42\x8C\x8A\x4B\x8C\x28\x8D\x8A\x87\x76\x01\x59\x89\x54\x80\x8B\x5A\x8D\x2B\xA3\x8A\xB5\x81\x16\xDF\x8A\x58\x8D\x8B\x0B\x8B\x2A\x82\x88\x9D\x88\x16\xE7\x8B\x5B\x84\x50\x17\x06\x2C\x96\x8A\xB6\x89\x16\xF5\x8B\x5E\x9E\x8B\x73\x8A\x2E\x95\x8B\xC0\x8E\x15\xF1\x89\x61\x94\x8B\x77\x8E\x2E\xAE\x8B\xC5\x86\x18\xEB\x88\x60\x83\x8C\x90\x8E\xE1\x58\x00\xBD\x84\x18\x8E\x8D\x62\x98\x17\x19\x04\x32\xBE\x10\x0D\x0A\x19\xDC\x8B\x63\x9E\x8C\x97\x8D\x32\xB0\x8A\xC4\x80\x2A\x1B\x01\x67\x9C\x8B\x8A\x8D\x31\xB7\x14\x0E\x07\x1A\xC1\x11\x07\x0D\x8D\xA1\x89\x32\xA8\x8D\xBF\x81\x1B\xA0\x8C\x63\x95\x16\x1E\x00\x36\xA3\x4F\x0F\x0A\x1B\xAA\x8D\x5F\x95\x8D\xB3\x8A\x34\xBF\x8D\xDB\x82\x18\xB6\x8E\x6F\x89\x8D\xA4\x8F\x38\xB5\x1E\x10\x0D\x1B\xC9\x8E\x73\x85\x8E\xC1\x8A\x36\x9F\x8D\xE8\x86\x1C\xCF\x8F\x61\x90\x8E\xD3\x89\x3B\x80\x8E\xED\x84\x1C\xB4\x25\x08\x1D\x8D\x22\x03\x26\xA3\x01\xE6\x88\x1D",
			"\xDB\x8E\x79\x9D\x8E\x96\x88\x3D\xA3\x8D\xF2\x8A\x1E\xC3\x8E\x72\x82\x8E\xC8\x8C\x3D\xAF\x8E\xE9\x87\x1E\xF3\x8D\x75\x92\x8F\xD6\x89\x3D\x83\x88\x12\x04\x1E\xD7\x8E\x7F\x9A\x8F\xF9\x8B\x3D\xBF\x8E\x01\x90\x20\xF8\x8E\x81\x94\x31\x25\x05\x3F\x85\x91\x01\x9C\x3E\x26\x02\x82\x8E\x4F\x27\x07\x41\xB9\x0C\x14\x03\x13\xA9\x03\x4C\x8A\x01\x33\x8B\x05\x33\x88\x16\x03\x13\xAD\x03\x4C\x8E\x01\x33\x8F\x05\x33\x88\x18\x03\x13\xB1\x03\x4C\x92\x01\x12\x91\x3E\xB8\x3D\x19\x09\x22\xF8\x14\x0D\x0D\x91\xF0\x8C\x36\xAD\x8F\xD4\x85\x03\x30\x90\x7D\x8C\x8C\x36\x06\x46\xBE\x53\x1B\x0B\x11\x84\x03\x8D\x96\x8F\xD4\x89\x48\x9C\x8E\x20\x93\x24\x81\x91\xB1\x3B\x01\x33\x8C\x07\x3A\x90\x21\x90\x29\x3D\x03\x92\x9D\x1A\x3E\x05\x37\xBF\x01\xDE\x80\x04\x4F\x91\x7D\x98\x35\x41\x03\x26\x82\x03\x99\x83\x04\x33\x88\x11\x13\x89\x45\x03\x26\x86\x03\xDE\x87\x04\x33\x88\x12\x1B\x88\x54\x67\x90\x0A\x03\x99\x8B\x04\x33\x88\x13\x13\x89\x4D\x03\x26\x8E\x02\x2B\x94\x10\x4F\x03\x4C\x90\x02\x74\x94\x48\xB5\x8F\x28\x03\x13\xD2\x01\x9E\x87\x5C\x53\x07\x4F\x9F",
			"\x0A\x2A\x03\x13\xD5\x03\x4C\x96\x02\x33\x8F\x0A\x33\x88\x2C\x03\x13\xD9\x03\x4C\x9A\x02\x82\x94\x41\xAA\x91\x83\x2B\x05\x3D\x93\x8F\x86\x92\x93\x94\x40\x9A\x94\xF7\x88\x29\xB2\x92\xDD\x1F\x02\x91\x93\x41\xA2\x95\x4D\x99\x29\x9C\x97\x81\x83\x95\xA6\x92\x52\x9E\x95\x77\x20\x06\x21\x94\xA9\x8B\x95\xA7\x97\x55\xB1\x91\x59\x97\x29\xB1\x95\xAA\x88\x95\xF3\x19\x0C\x2E\x95\x5B\x92\x2B\xB5\x96\xAA\x94\x95\xF7\x8F\x57\xBE\x94\x5C\x90\x2B\xF5\x0A\x18\x1B\x95\xA5\x91\x59\x85\x96\x62\x90\x2C\xCC\x93\x8C\x8B\x96\xBD\x91\x58\x8C\x97\x61\x9E\x9E\x63\x00\xB2\x90\x96\xBC\x91\x5B\x8A\x97\x66\x95\x24\xB6\x97\xB6\x94\x96\xDA\x90\x5B\x9F\x96\x69\x9B\x6F\x64\x03\xB5\x9C\x96\x57\x96\x5B\xA2\x97\x75\x98\x2E\xCF\x95\xBB\x91\x58\x65\x07\x5C\xA0\x97\x71\x9E\x2C\xFA\x92\xBB\x93\x97\xEC\x92\xE4\x66\x02\x79\x94\x2E\xE1\x97\xBB\x9D\x94\xFF\x92\x5D\x81\x98\x61\x9D\x2F\xF4\x95\xB7\x98\x3D\x67\x04\x5F\xB5\x96\x80\x98\x2F\x83\x9B\xB4\x85\x98\xF9\x90\x62\x99\x46\x34\x0A\x30\x87\x9B\xC3\x8B\x98\x02\x9D\x61\x9A\x98\x89\x9B\x31\x98\x98\xC1\x9E\x98",
			"\x17\x9C\x1B\xA9\x03\x8A\x99\x2E\x9F\x9A\xC5\x91\x96\x20\x98\x65\xA7\x98\x7F\x93\x60\x6A\x00\xC9\x97\x97\x1C\x99\x66\xA9\x98\x96\x92\x33\xAB\x9A\xC1\x85\x08\x6B\x07\x65\xB6\x97\x9D\x9C\x30\xB5\x99\xC9\x81\x99\x3F\x9A\x65\x81\x9A\x9A\x93\x33\xBD\x0C\x1B\x1A\x99\x3D\x9D\x68\x91\x98\xA5\x9E\x30\xC2\x98\xCC\x8C\x9A\xCC\x45\x0D\x08\x9B\x8C\x9E\x33\xCF\x9A\xCD\x8B\x9A\x57\x9D\x69\x84\x9B\xAC\x9E\x23\x6E\x03\xD4\x86\x99\x43\x9F\x66\x96\x9B\xB0\x98\x35\xE4\x9A\xD6\x82\x9B\x3C\x9C\x6A\x90\x9B\xAA\x99\x36\xE0\x9B\xD8\x8F\x9B\xD6\x47\x0D\x1F\x9A\xA0\x90\x37\xC9\x98\xD7\x8C\x9B\x76\x9E\x6C\xBF\x90\x38\x03\x37\xCE\x99\xDB\x94\x9B\x7F\x9E\x6F\xB9\x9B\xBA\x9A\x36\xF7\x98\x51\x71\x03\x7D\x9B\x6B\xBA\x9A\xBC\x95\x38\x8B\x9F\xDA\x8F\x9C\x86\x99\x72\x8E\x9D\xB5\x72\x07\x09\x9C\xDA\x83\x9C\x81\x9A\x71\x84\x9C\xB7\x99\x39\x97\x9D\xE3\x9B\x9C\x80\x98\x73\xA2\x9D\xCF\x9D\x39\xE5\x98\xE8\x82\x9C\xA4\x99\x39\xB3\x02\xCB\x96\x3A\xBB\x98\x1D\x0C\x9D\x28\x35\x0E\x39\x92\x3B\x03\x13\xF7\x03\x4C\x98\x03\x33\x89\x0F\x33\x88\x3D\x03\x13\xFB",
			"\x03\x4C\x9C\x03\x33\x8D\x0F\x33\x88\x3F\x03\x13\xFF\x03\x4C\x80\x04\xB0\x9D\x63\x9D\x1B\x40\x0A\x33\x82\x05\xF2\x8C\x9C\x9C\x9B\x74\xB4\x25\x41\x0F\x3C\x90\x9E\x37\x84\x04\xD5\x9E\xBD\x05\x05\x3C\x96\x08\x33\x8B\x21\x13\x89\x88\x03\x26\x89\x05\x99\x8A\x08\x33\x8B\x22\x13\x89\x8C\x03\x26\x8D\x05\x99\x8E\x08\x33\x8B\x23\x13\x89\x90\x01\x7B\x93\x9D\xD7\x11\x09\x3A\x9A\x24\x12\x9F\xA7\x9A\x73\xA5\x9C\xDF\x33\x09\x78\x9E\x1F\x34\x04\xFE\x9A\x7A\xA1\x9D\xD4\x94\x40\xD1\x9D\x01\xA3\xA0\x06\xA1\x81\x88\xA1\x05\xA9\x1A\x15\x05\x00\xA7\xA0\xA8\x9A\x81\x91\xA0\x06\xAA\x3F\x82\xA3\x04\xBD\x5C\x96\x07\x81\x92\xA1\x0A\xA0\x41\x9C\xA3\x06\xBE\x9C\x1F\xA5\x75\x96\xA0\xF6\x17\x09\x1A\xA0\x05\xA0\xA1\x27\xA2\x84\x9D\xA0\x14\xA7\x41\x9E\xA1\x0A\xAF\x97\x98\x06\x84\xAD\xA0\x16\xAE\x42\xB3\xA2\x0A\xA1\xA1\x67\x9F\x86\xAF\xA0\xE5\x98\x60\x19\x06\x0C\xB5\xA1\xC5\x32\x13\x28\x93\x01\x3C\x09\x3F\xA1\x53\x3D\x04\x3A\x9E\x13\x06\xA3\xD6\x5F\x09\x33\x88\x28\x13\x89\xA1\x03\x26\xA2\x05\x99\x83\x0A\x43\xA2\x43\x05\x05\x33\x8E\x14\x1B\x88",
			"\x39\x6A\x10\x29\x06\x15\xBA\x11\xAB\x03\x89\xBE\x3C\x56\x02\x46\xBC\xA1\xFE\x94\xA1\x68\xA2\x87\xB6\xA1\x1C\xAC\x46\xE6\xA3\xFE\x9B\x1A\xAD\x05\x8C\x90\x9F\x1D\xA3\x47\xEB\xA2\x1B\xA3\xA1\x69\xA5\x8D\xAC\x9A\x57\x02\x47\xD6\x9F\x19\xAA\xA3\x40\xA1\x8F\xB7\xA3\x15\xA0\x48\x82\xA4\xD1\x0F\x05\x7D\xA2\x72\xBF\xA2\x3D\xAE\x47\xEF\xA1\x1D\xA1\xA4\x85\xA1\x92\xB5\x1A\x58\x09\x48\xF3\x9F\x22\xA3\xA4\x38\xA0\x93\xB4\xA3\x46\xA8\x47\x92\xA6\x44\x11\x05\x95\xA7\x92\x8F\xA4\x43\xAC\x49\x84\xA4\x23\xAA\xA4\x8E\xA5\x94\xB5\x0A\x59\x01\x4A\xA9\xA4\x2A\xBD\xA4\xA7\xA6\x92\xAE\xA4\x59\xA0\x4B\x9A\xA5\x6A\x13\x05\xAD\xA5\x96\xA3\xA4\x4F\xAB\x4B\xB1\xA6\x28\xAA\xA5\x9B\xA3\x48\xB4\x05\x5C\xA6\x4A\xB6\xA4\x24\xBE\xA5\xB3\xA7\x97\xAF\xA5\x62\xAC\x36\xB5\x04\x31\xB9\xA4\xBD\xA6\x98\xA4\xA5\x65\xA0\x4D\xC0\xA6\x1D\xA8\x81\xB6\x07\x99\x81\xA6\x5A\xAC\x4C\xD6\xA7\x31\xB2\xA6\xBC\xA6\x9B\xA9\x8D\x5B\x0A\x4D\xD7\xA6\x38\xA1\xA7\xD4\xA3\x9B\x8A\xA6\x6E\xA5\x4D\xC3\x90\x2E\x05\xA7\xDF\xA1\x9A\xB2\xA7\x73\xA8\x4C\xBA\xA4\x3D\xA0\xA7\xDC",
			"\x69\x17\x30\xA7\x69\xAC\x4E\xEA\xA5\x32\xBF\xA7\xF6\xA1\x9D\xA6\xA6\x81\xA1\x4F\xF7\xA4\x17\x3A\x05\x79\x93\x17\x3B\xA6\x74\xA7\x48\x3C\x07\x17\xAE\x2F\xBE\x03\xA1\xB5\x1B\x5F\x0A\x33\xC0\x06\x44\xAC\x46\xC1\x03\x26\x82\x07\x99\x83\x0C\x33\x88\x31\x13\x89\xC5\x07\xA1\x85\x09\x63\x03\x13\xC8\x07\x16\xB2\x08\xCB\x02\xA4\xA0\x15\x66\x07\x51\xD9\x2E\x33\x0D\xA9\x06\xA9\xA6\x84\xA8\x7E\xAB\x4E\xB5\xA8\x40\xBD\xA6\x33\xAC\xA1\xB6\xA9\x80\xA0\x29\x4F\x05\x9E\x90\x06\x30\xA9\xA7\xB5\x1B\x68\x0A\x52\x84\x33\x34\x01\xAA\xAF\x1C\x1A\x3A\x99\x6A\x08\x54\xE3\x4E\x35\x13\x89\xD7\x03\x26\x98\x07\x99\x89\x0D\x33\x8A\x36\x05\xAA\xDC\x03\x26\x9D\x07\x93\xAE\x10\x60\x05\x51\xAA\x0E\xE2\x05\xA9\x84\x31\x71\x02\x56\xEF\x24\x39\x05\xAB\x38\xAD\x9F\x83\xA8\xB5\xA5\x50\xC2\xA8\x3E\xAF\xAB\xF3\xA6\x20\x25\x06\xB4\xAD\x4E\xEC\xA8\x4D\xB7\xA9\x75\xAB\xA7\xA9\xAA\x07\x86\x0E\x74\xAA\x3F\xBC\xA9\x7A\xA9\xAF\xB8\xAB\xBF\xAB\x57\x83\xAF\x5A\xB0\x31\xE7\x06\xAF\x87\xAC\xC3\xAD\x56\xF6\xAA\x4E\xAC\xAC\x77\xA8\xB0\xBB\x7C\x74\x0A\x58\x8D\xAD",
			"\x60\xA4\xAC\x82\xAA\xB2\x9A\xAD\xC2\xAB\x59\x9C\x9D\x3A\x15\xAC\x91\xAC\xB3\xA2\xAD\xCC\xA3\x5A\x98\xAE\x69\xBC\x40\xEA\x00\xB4\x8F\xAD\xCE\xA7\x5A\x96\xAC\x64\xAB\xAD\xA5\xAB\xB1\xAC\xAD\x5B\x1B\x0E\x7E\x9C\x3B\x0A\xAD\xF5\xA1\xB6\xAE\xAD\xD9\xAB\x5B\xBA\xAD\x68\xB8\x3D\xED\x00\xB7\x92\x08\x77\x0E\x3F\xEF\x06\x70\xB1\xAB\x8E\xA9\xB7\xA4\xAD\xE5\xAD\x5A\xBF\xAC\x05\x50\x07\xC7\xAA\xA6\x89\xAE\xB8\xA2\x5D\x97\xAE\x6C\xBE\xAD\x40\x29\x1E\x11\xAE\xB7\xA8\x5C\xD6\xAD\x6F\xAC\xAE\xD7\xA8\xBC\x9F\xAF\xE6\xA0\x5B\xEC\x5A\x3C\x1B\xAE\xD3\xAD\xBB\xAF\xAC\xE5\xA4\x5E\xEC\xAD\x78\xB4\x40\xF3\x00\xBD\x9E\xAF\x0C\x54\x0F\x3D\x8D\x3D\x12\xAF\xEB\xAC\xBA\x9C\xAF\xEA\xA9\x5F\xEA\xAC\x6F\xA2\x2F\xF8\xAF\xBF\xA5\xAF\xF6\xAA\x5F\xE9\xAC\x7F\xA2\xB0\x98\x27\x1E\x01\xB0\xEC\xAE\x7B\x78\x05\x6F\x99\x07\x0B\xB2\xBC\x8E\xAF\xF7\xA4\x61\xE3\xAD\x85\xAD\x81\xFA\x01\xC2\x84\xB0\xFF\xAC\x60\x85\xB3\x7C\xA3\xB0\x17\xB0\xC4\x96\xB1\x11\xB3\x61\xA4\xB2\x88\xA5\xB1\x28\xB4\xE1\x7B\x07\x99\x8C\x0F\x1A\xB1\x88\xAE\xAF\x26\xB0\xC6\xA9\xB0\x19",
			"\xB7\x62\xB5\xB0\x8D\xAF\x97\xFD\x06\xC5\xB1\xB0\x51\x6E\x0F\x7F\x92\x8E\xB3\xB1\x16\x0E\x02\x31\x61\x01\x32\x00\x42\xB0\x3D\x8B\x67\x03\x06\xC8\x87\x89\x3E\x24\x00\x4A\xB2\x44\x88\xA5\x05\x06\xC9\x98\x88\x83\x06\x00\x52\xB0\x47\x86\x08\x07\x06\xCA\x92\x0C\x04\x0A\x65\x92\x09\x02\x16\xB2\x69\x94\x20\x0B\x01\x2E\xBE\x10\x0C\x02\x95\xBC\xA2\x06\x0F\x01\x20\xB2\x89\x01\x01\x64\xB2\x42\x12\x00\x6E\xB4\x1B\x93\x01\x38\xBE\x0D\x94\x00\x9D\xBF\xB0\x37\xB4\x8C\x15\x01\x3B\xB6\x37\x16\x00\x9F\xA8\xB0\xE5\x57\x02\x2B\xB3\xEC\x29\x01\x7F\xB1\xE9\x5A\x00\x86\xB0\x79\x1B\x01\x44\xB0\x38\x9C\x00\x9F\xBD\x00\x7C\xB6\x03\x3C\xB3\x0F\x0C\x67\xA0\x03\xA0\xAA\x08\x22\x04\xCF\xA3\x01\x33\xB2\x11\x26\x03\xA5\xA6\x08\x28\x04\xCF\xA9\x00\x46\xB1\xFE\x2A\x00\xA9\xB3\x80\x2B\x07\xD4\x80\xB2\x0E\xB2\x2A\x2C\x02\xAA\xB8\x17\x2D\x07\xD5\xB9\xB2\x3F\x5E\x02\x1F\xB4\x82\x30\x01\xB2\xB5\x5C\x71\x01\x5C\xB4\x34\x32\x00\xAF\xB5\x97\x33\x04\xCF\xB4\x00\x3E\xB5\x03\x7C\xB2\x0D\x1C\xB3\x37\x06\xD6\x84\x09\x1C\x0C\x67\xBA\x00\xA7\xAE\x08\x3D\x02",
			"\xD9\x97\x13\x1F\x0F\x6B\xEB\x78\x10\x15\xB6\x06\xB3\xBF\xAE\x2F\x20\x08\x6D\xF8\xB2\x87\xBD\xAF\x07\xB5\xC3\xAC\xB5\x0D\xB1\x6E\x92\xB2\x8D\xBF\xB6\x80\xB3\xDC\xAF\xB0\x74\xB9\x3F\x42\x01\xB7\xB6\x46\x43\x07\xDD\xA9\xB7\x72\xBF\x1A\x44\x02\xBC\xBF\x0A\x45\x07\xDE\xA6\xB7\x6C\x46\x04\x52\xB7\x3B\x28\x02\xFA\xB0\x3E\x49\x03\x80\xB7\x2B\x4A\x00\xC1\xAE\x8F\x4B\x04\xCF\x8C\x02\x3E\xBD\x04\x7C\xB2\x13\x1C\xB3\x4F\x02\xDA\x91\x02\x3E\xB2\x05\x4F\xB6\x42\x15\x02\xD2\xB7\x0A\x3C\xB2\x2C\x07\x70\xB2\x75\x16\x1D\xB8\x0C\x7A\x0B\x20\xB9\x59\xB4\x6F\xA9\x0F\x16\x03\xB9\x12\x0C\x0B\x28\xB8\x75\xB6\x81\x5D\x02\xBF\xA3\x27\x5F\x03\xE5\x95\x46\x30\x02\x73\xC1\x11\x18\x15\xB9\xDE\x82\x0C\x3C\xB3\x31\x0C\x67\xE4\x00\x9F\xA5\x03\x7C\xB6\x0C\x12\xB6\x34\x0C\x67\xE9\x02\xC5\xA6\x08\x6C\x02\xDA\xAE\x02\x3E\xBF\x06\x38\xBB\xAD\x70\x03\x4E\xBD\xBB\x71\x03\xA8\xB3\x6F\xDA\xB5\x41\x12\x03\x51\xBB\x0E\x14\xBA\x71\xB1\x75\x74\x03\xCB\xB4\x25\x76\x03\xEB\xB8\x3D\x3B\x02\x76\xAF\x0C\x1E\x05\xBB\xE1\x79\x0F\x3C\xB2\x3D\x0C\x67\xFB\x00\x9F",
			"\xBC\x03\x7C\xB5\x0F\x12\xB7\x3F\x0C\x67\x80\x07\xD1\xA5\x08\x83\x07\xEB\xAF\x0D\x42\x08\x76\xDE\x5E\x21\x1D\xBB\xAB\xB5\xE4\x8C\x17\x43\x00\x78\xE7\xB4\xCB\xA1\xBC\x56\xBE\xDB\x87\xBC\xC3\xB2\x78\x88\xBD\xB6\xAF\xBC\x8A\xBD\xF1\x8C\xBD\xC4\xB6\x37\x08\x05\xE1\xA8\x31\x7B\x03\x07\x03\xB3\xB4\x05\x2D\x61\xB2\x6E\x1D\xBC\x6B\x08\xF4\x9C\xBD\x5A\x1E\x79\x94\x0A\xE8\xBD\x0B\xA7\xBD\x36\x29\xBC\xE1\x0B\x7A\xA7\x11\xEB\xBF\xBC\xA4\xB9\xF4\xB1\xBD\xD1\xB2\x2A\x25\xBE\xE9\xB5\xBD\xB2\xB8\xF7\xB4\xBC\x61\x16\x7B\xB7\xBF\xAD\x13\x0F\x92\x0E\x47\x8E\x08\x2F\x0B\x16\x05\x02\x44\x0D\x05\x66\x32\x22\x07\x01\xDC\xB8\x10\x42\xBE\x42\x04\xBE\x69\x0E\xF8\x8E\x08\xE4\xB9\x0E\x8A\x0B\xF2\xBB\xBD\x02\x0D\xF7\xBE\xBC\x80\x08\x66\x90\x16\xF3\xA6\x08\xD0\xBD\x2F\x12\xBE\x85\x04\x7D\xC7\xB1\x41\x17\xBE\xA8\xB8\x22\x1A\xBF\xED\xBD\x7D\xA0\x17\xF7\xA5\x08\xE1\xBD\x36\x23\xBE\x83\x05\x7E\xCB\xB3\xF9\xAC\xBE\xD9\xB8\xFF\x81\x09\xF6\xB7\x25\x6F\xBC\x41\x11\xBF\xC2\x0B\xFE\x85\x09\xFA\xBF\x64\xF7\xBC\xF6\xA1\x08\xEB\xBE\xF7\xBC\xBE\xE5\x0E",
			"\x7F\x80\x00\x00\xC7\x11\x02\xC4\x20\x04\xC1\x29\xB6\x80\xE9\xBC\x43\x09\xC0\xB7\xBB\x01\xDF\x0B\x06\xCF\x80\xBA\x0D\x04\xC0\x00\x13\xC7\xCA\x95\xC0\xD5\xBA\x7E\xFA\xBC\xF7\xBE\x11\x92\x09\x01\x09\xBE\x87\x0D\x80\xC3\x01\xF1\xB2\x08\x7F\x03\x05\xD6\xBE\x13\xCF\x0F\x29\xC2\x0C\xC6\x08\x2D\xC7\x05\xCE\x09\x18\xC5\x7D\xD8\xB0\x0D\xD8\xC0\xA6\xBA\x03\xF5\x0A\x1B\xCD\x83\x85\x09\x0E\xD1\xBE\x30\xC7\x06\xE3\xC0\xD6\xB5\x82\x87\xC3\x09\xD2\x11\x44\xC6\xFC\x84\x09\x23\xC2\x7E\xC9\xC1\x11\xC4\x08\xE8\xBC\x04\xD7\xC0\x1A\xC2\x84\xAF\x0D\x14\xD6\xBF\x53\xC2\x22\x2E\xC0\x24\xCB\x83\xCA\xC0\x16\xDF\xC1\x5C\xC0\x05\xDE\xB2\x33\xC0\x00\x54\xC2\xFC\xB6\xC2\x52\xC0\x00\x19\xC2\x26\xCB\x85\xCE\xC3\x3F\x1D\xC2\xA9\x0F\x0B\xC5\xC1\x30\xCE\x10\x63\xC1\x15\xC5\xC3\x57\xC2\x0E\xE8\xC2\x3B\xC8\x87\xB9\x0F\x96\xAC\xC3\x6E\xC1\x00\xF0\xC2\x30\xC2\x88\xF6\xC3\x21\xC1\xC4\x89\xC0\x02\xCB\xC5\x3D\xCD\x88\x96\xC0\x42\x00\xC2\x14\x0D\x10\xFD\x0D\x47\xC1\x87\x91\xC6\x07\xD3\xC4\x14\xC7\x0C\xF6\xC2\x4C\xC0\x11\x1A\xC7\x78\x1C\xC4\x8C\xC6\x13",
			"\xD4\x09\x0F\xCC\x83\xF1\xC3\x1C\xCE\xBD\x4D\xC6\x12\xC2\x08\x53\xC6\x11\x28\xC4\x25\xCA\xC5\x10\x0C\x15\xEC\xC3\x57\xC0\x7B\xF5\xC2\x2C\xDB\xBF\x6A\xC6\x21\x08\x00\x44\xC2\x86\xBA\xC2\x42\x0D\xC5\x8C\xC4\x17\xDB\xBF\xFC\xB4\x88\xC1\xC6\x42\x03\xC6\x90\xC5\x18\xE4\xC3\x63\xCB\x8B\x83\xC7\x2F\xCF\xC2\x3A\x14\x14\xFA\xBD\x6B\xC8\x2F\x5A\xC4\xEF\xB4\xC1\x56\x16\x1B\xF7\x14\x71\xCC\x2C\x64\xC4\xB1\x06\xC7\xDD\xC0\x1C\xFE\x10\x74\xC1\x8E\xEA\xC6\x8C\x0C\xC7\xEB\xC6\x1D\xD9\xC6\x79\xC1\x24\x70\xC7\x3B\xD4\xC7\x90\x16\x1E\xFA\x11\xF9\x0D\x80\xFA\xC5\x3D\xD8\xC7\xA0\x16\x1F\xF9\xC6\x80\xC7\x25\x02\xC9\x40\xC4\xC8\xCA\x0E\x20\xC5\xC8\x84\xCF\x15\x0A\xC9\x42\xCC\xC8\x75\x0E\x21\xCD\xC8\x88\xCF\x1A\x12\xC9\x44\xD4\xC8\xA9\x0E\x22\xEF\x0C\x7E\xCC\x86\x96\x0B\x07\xCD\xC0\x31\x06\x18\xC6\x08\x31\x0C\x86\x9F\xC1\x18\x0E\x33\x76\x32\x22\x23\x03\x94\xCE\x10\x4A\xC7\x32\xC0\x08\x92\x0E\x23\xF2\x32\x89\x01\x92\xD3\xC7\x48\xC5\xC9\x12\x0F\x24\xCE\x08\xFE\xBF\x81\xAB\xCA\x43\x1F\xC0\x2E\xCF\x25\xE8\xC6\x5A\xCD\x91\xAC\xCA\x42\x00",
			"\xC9\x22\xCD\x20\x24\xC9\x40\xC6\x92\xA8\xCB\x4F\xCA\xC9\x46\xCE\x07\xE3\xC5\x34\xC0\x85\x96\x09\x54\xC6\xC2\x34\xC9\x29\xC4\x09\xA5\xC1\x87\xCD\xCB\x4E\xD7\xCA\x04\x0E\x27\xCA\x08\xA0\xC6\x8D\xDA\xC0\x42\x04\xCA\x81\xC2\x26\xEC\xC1\xAC\xC6\x93\xCA\xC8\x4E\xCE\x08\x3A\xCA\x21\x3C\xC8\xA8\xCF\x94\xAD\xC9\x59\xD4\xC3\x67\xCE\x19\xD6\xCB\x82\x0F\x91\xEC\xCB\x1F\xCA\x08\x5C\xCC\x11\xDE\xCA\xB9\xC0\x96\x80\x02\x58\xC6\x08\x64\xCB\x2A\xCD\xC7\xAA\xCB\x97\x88\xCF\x4C\xCE\x08\x35\xCF\x2F\xF7\xC8\xA6\xC9\x93\xCE\xCB\x58\xD4\xCB\x97\xCE\x2E\xCA\xCC\x6E\xC8\x96\x8D\xCF\x89\x1E\xBC\x92\x0E\x00\x04\xC7\x3E\xCA\x95\x80\x00\x32\xD4\xC4\x41\xCB\x19\xE1\xCD\xD1\xCA\x10\x7E\xC3\x1B\xC0\xC4\xAE\xC7\x2E\xF0\xC4\x86\x0D\x99\x8C\xC6\x68\xD1\xC6\xA4\xCD\x2D\xC4\x09\xD3\xC1\x8A\x95\xC6\x59\xCC\xC6\x9C\xCA\x2F\xC5\x09\xDB\xCD\x89\xD2\xC6\x64\xC5\x08\xBC\xCA\x04\xE2\xC4\x6E\xC3\x94\xC2\xCC\x41\x04\xCE\xA9\xC6\x38\xEF\xCC\x6A\xC1\x88\xA9\xCF\xF6\xAD\xCE\x8C\xCA\x21\x10\xCF\x5B\xC2\x9D\x8A\xC4\x6C\xC9\xC6\xB2\xCD\x17\xF9\xCB\xEC\xC4\x65",
			"\xAC\xCE\x41\x0E\xCD\xDE\xCC\x3A\xF1\xCD\xCD\xCF\x9B\xC0\xC4\x79\xDC\xCB\xE6\xCD\x20\x28\xCE\x49\xCF\x9D\xA8\xCC\x0D\xD2\x0C\x1F\xC1\xF8\x9D\xCE\xFA\xCA\x9E\xE0\xCC\x7B\xD8\xCB\xB3\xC6\x39\xC0\x01\xFC\xCF\x98\xAD\xCD\x69\xC9\xCE\x20\x89\x3C\xEF\xC8\x6C\xC1\x24\x78\xCD\x7C\xC4\x08\xF3\xCF\x13\xF5\xCF\xDE\xC6\x9D\xBE\xBC\x76\xDA\x11\x0E\xD0\x37\xC6\xD0\xDD\xC6\x9A\xD5\xC7\x7F\xD3\xCD\xE3\xC8\x43\xC5\xCC\xFD\xC9\x9B\xC7\xCF\x6E\xDE\xD0\xCC\xCC\x2A\xE2\xD1\xBA\xC5\x9C\xA5\xD3\x74\xC6\x08\x08\xD2\xF9\x8A\xD1\x05\xD5\x9B\x85\x0A\x46\xD9\xC8\x18\xC9\x37\x1C\xC9\xCD\xBC\x8D\xED\xC6\x1D\xDE\xD1\x3D\xD1\x1E\xFF\xD0\x21\xD1\xA4\xF7\xC7\x90\xC6\xD2\x45\xD3\x1E\xC7\xD2\x25\xD9\xA4\xFF\xC7\x92\xCE\xD2\x4D\xD3\x20\xCF\xD2\x29\xD1\xA5\x87\xCB\x94\xD6\xD2\x55\xD3\x21\xD7\xD2\x2D\xD9\xA5\x8F\xCB\x96\xDE\xD2\x5D\xD3\x22\xDF\xD2\x31\xD1\xA6\x97\xCB\x98\xC6\xD3\x65\xD5\x22\xF9\xD1\xDE\x07\xA3\xB9\x0D\x9B\xCC\xD3\x6B\xD3\x3C\x2F\xD2\x39\xD1\xA7\x96\x0B\x9C\xD6\xD3\x75\xD2\xCD\x39\xD2\x1E\xDD\x9E\xE7\xC7\x9E\xCA\x08\x77\xD2\x4F\xE7",
			"\xD2\x35\xD3\xA8\xB8\xD1\xA1\xCE\xD3\x7F\xD6\x20\x01\xD4\x3E\xD0\xA0\xE5\xC5\xA2\xD6\xD1\x8F\xD4\x20\x0B\xD4\x40\xD1\xA9\x84\x89\xA5\xCD\xC0\x28\x05\x34\xCE\x02\x41\xD9\x99\x8A\x0B\x13\x1A\x33\x32\xD6\x0E\xD8\xD4\x4D\xDC\xA9\x8E\xCE\x43\x1F\xD4\x0E\x0B\x3B\xCB\xCF\x3E\xDF\x0F\x17\xD1\x90\x03\xD5\x1C\xD3\x53\xCC\xD4\x82\x0F\x81\xA8\xD6\x76\xC1\xD5\x29\xD3\x31\xF3\x60\x89\x09\xA9\xB1\xD5\xA9\xD0\xCF\xA7\xD0\x54\xDA\xCD\x5C\xD1\x9C\xB2\x10\xAC\xC6\xD1\x00\x02\x56\xD4\xD4\x16\xD6\x10\x36\xD5\x79\xC3\xD6\xAC\xD6\x55\xDE\xBE\x5E\xD4\xAA\xB3\xD7\x80\xD2\x08\xCE\xD3\x38\xF8\xD5\x68\xDA\xA2\xAF\xD4\xB5\xDE\xD5\xD6\xD5\x56\xC2\xD7\x19\xCF\xA1\xE2\xCD\x80\xD2\x11\xF3\x0F\x03\xF3\x0E\xFE\xBB\xA3\x9E\xCE\x6E\x12\x0C\x92\x0C\xFF\xA4\xD1\x0D\xD8\xAC\xB1\xD0\xB4\xCD\xD4\x30\xCE\x32\xD1\xCE\x17\xD9\x9E\xB0\xD0\x8A\xDC\xD6\xBA\xD5\x41\xFA\xD6\xEE\xCC\xAF\xFC\xCE\xBF\xD5\xCE\x33\xD7\x25\xF5\xD1\xDE\xC2\xAF\x85\xD3\x79\xC7\xD0\xFF\xD0\x5F\xED\xD5\x6E\xD0\x29\x71\xD7\x83\xC0\x00\x11\xD3\x15\xE0\xC4\xE5\xCE\x9B\x92\xDA\xB4\xC0\x15",
			"\x16\xDA\x43\xCF\xD8\x0E\xD6\xAF\xE4\xD4\xB1\xCC\xD5\x0B\xDC\x63\xCD\xD9\xB5\xC5\xB0\x92\xD1\x7F\xD6\xCF\xE5\xD3\x41\xF7\xC2\x01\xD0\x9A\x8E\xDA\x7C\xD0\xD8\x08\xDE\x11\xFF\xD5\xDE\xC8\x8B\x8C\x0A\x2E\xD9\xD9\x27\xDA\x62\xE9\xD8\xC9\x05\xB3\xAC\xD8\xBD\xCF\xD1\xC8\xC9\x62\xE0\xD0\xE0\xC8\xB2\xB4\xDB\xC5\xD9\xD8\xB9\xC3\x63\xC9\xD1\x98\xD4\xA3\xCE\xDA\xC8\xD7\xD9\x24\xDA\x69\xE6\xD6\x04\xC4\xB1\xA0\xDB\xCE\xDC\xD8\x3D\xD8\x21\x3F\xD9\xF5\xC1\xB4\xCB\xDA\x7B\xCB\xD1\xCB\xD5\x45\xC7\xDB\x7E\xD9\xB4\xC0\xD8\xC0\xC5\xD6\x68\xDC\x11\xF3\xD7\x91\xD5\xAF\xDA\xDA\xCC\xD0\xD7\x4F\xD8\x67\xE4\xDB\xB7\xDD\xB4\xEF\xCD\x6F\xD3\xDB\x58\xDD\x6E\xEE\xDA\x8F\xDD\xB5\xD7\x10\xDE\xD7\xDA\x10\xD2\x6F\xFE\xCF\xB2\xDB\xB5\x8C\xD1\xC5\xCC\xC3\x80\xD9\x71\xD9\xDB\xC1\xD6\xB6\x80\x0B\xC7\xC6\xDC\x90\xDE\x66\xD2\xDC\xC1\xDB\xB7\x84\xDD\xC0\xCF\xDC\x81\xC1\x72\xD8\xD8\xC5\xD0\xB3\x8C\xDE\xCC\xC9\xD9\x93\xD2\x51\xD5\xD5\xD4\xD0\xA9\x87\xD4\x9C\xCE\xDD\x74\xD0\x76\xF8\xD2\xD9\xDF\xB5\xB2\xD8\x90\xCC\xD5\xB7\xDA\x62\xF9\xDD\xCA\xD9\x8E\xB4",
			"\xDE\xB5\xD6\xDD\x44\xD0\x77\xC1\xDE\xDD\xD3\xBC\xBC\xDE\x95\x0D\xC0\x3F\x05\x34\xF7\x02\xBB\xDB\xA0\xC8\xDE\xF2\xCC\xDE\x42\xCD\x70\xCC\xC0\x89\x09\xBC\x9C\xD3\xF2\xD4\xDC\x8D\xDB\x62\xDF\xDC\xF7\xB4\xBD\xCF\xDC\xF6\xD2\xD9\x97\xDB\x7A\xCE\x09\xEA\xD8\xAC\xD7\xDD\xE7\xDC\xDD\xE1\xDB\x03\xDD\xDE\xEB\xD0\xBD\xCB\xC5\xFA\xD5\x0B\xCE\xDC\x7D\xDF\xDF\x05\xDF\xBE\x9B\xCB\x5A\x0C\xD7\x6B\x0D\x68\xE6\xD9\x7D\xDB\xB6\x86\xD9\xDB\xC7\xDF\xD9\xDB\x6A\xEA\xDA\xBA\xD8\xB4\xA7\xD3\xFC\xD1\xDE\xDB\xD8\x73\xF7\xD6\x9E\xDB\x9F\xAE\xDB\xC1\xC0\xE0\xE0\xDA\x7A\xDF\x0A\x01\xEC\xBF\x84\xE0\xDB\xC6\xE0\x10\xE4\x7E\xD2\xE1\x21\xCB\xAD\x84\xD9\xFF\xCE\xE0\xFF\xDB\x71\xFC\xDA\xA1\xD2\xA0\xBC\xC6\xE8\xD0\xDA\x3E\xDA\x6A\xDD\xE0\xF4\xDB\xC1\xDE\xC3\x0A\xE0\xDB\x0D\xE2\x63\xD3\xD0\x8E\xD5\xA1\xB7\xBD\xFD\xD9\xC3\x9A\xD8\x86\xED\xD8\x19\xEF\xB2\x94\xD3\x7D\xD9\xE1\x27\xE4\x74\xFE\xE0\xAA\xDA\xB0\x82\xD1\x03\xC1\xE2\x93\xD9\x83\xC8\xE0\xB8\xD2\xB0\xC6\xD9\x05\xE1\xDC\x05\xE5\x43\xC7\xE0\xF7\xDD\xC2\xB8\xE2\x13\xFE\xE0\x16\xE6\x7F\xD8\xE0",
			"\x11\xEE\xB9\xCC\xE0\xE8\xC7\xCA\x79\xD9\x89\xDC\xE2\x16\xE9\xC0\xCA\x0E\xE8\xC8\xE2\x9C\xDB\x8C\xD9\xDF\x1B\xE6\x88\xEE\xD4\x03\xFB\xE1\x51\xDB\x86\xD4\xE0\x89\xD1\x93\xE1\xE1\x1A\xE5\xDD\x23\xE4\x77\xC3\xDA\x37\xEA\xC3\x9F\xE0\x0F\xEF\xE0\x6A\xE1\x82\xE5\xE3\x09\xEC\xC7\xE8\xE1\x14\xE5\xD9\x52\xCE\x74\xD5\xDA\xBF\xD6\x95\x86\xE7\x05\xF2\xE2\x4A\xE4\x8A\xC3\xE4\x0E\xEE\xC6\x8E\xE6\x16\xF0\xE4\x81\xE2\x83\xD3\xE4\x17\xE5\xC9\xB9\xE0\x0A\xE2\xDB\x2A\xE3\x81\xEB\xE3\x2A\xE9\x1B\x0D\xC1\x12\x05\xCD\x8B\x04\x8F\xF5\xE0\xD3\xB6\xCA\xA8\xE6\x2A\xE9\xD8\xCB\xC1\x65\xED\xE4\x0E\xD9\xCA\xEE\xE3\x2A\xF4\x08\x6C\xE5\x37\x33\xE4\x64\xD5\xCB\xEE\xD7\x2D\xF1\xC5\x7D\xDB\x57\xCE\x09\x53\xE4\xCB\xAF\xE4\x11\xF1\xE5\x3E\x13\x97\xD1\xE3\x5E\xEE\x99\xBF\xE6\x2F\xC1\xE6\xDE\xD3\x98\xEE\xE4\x5B\xE0\xCB\xEC\xBD\x32\xF2\x08\x47\x05\x34\xC9\x04\x63\xEC\x8D\x8D\xC1\x36\xFC\xD0\xDB\xE4\x9A\xC7\xE6\x6B\xE6\xAC\xD8\xE6\x36\xFC\xE6\x79\xE1\x7B\xF2\xE4\x73\xE0\xCE\xE8\xE5\x17\xF0\xE6\xD3\xD6\x21\x1F\xE6\x64\xD1\xCE\xBE\xE5\x35\xEA\xC0\xD7",
			"\xE2\x9E\xE7\xE6\x71\xEA\xC8\xC5\xE1\x39\xFA\xE7\xED\xE4\x9F\xE9\xE7\xD3\xDE\x23\x73\x0E\xE7\xAD\xC0\x0B\x05\x34\xD9\x00\x3E\xEF\x81\x98\x03\xD7\xCE\xE6\xCD\xBA\x22\x09\xE8\x0E\xDB\xD0\xEE\xE1\x43\xEF\xE8\xF7\xE1\x03\xF9\xE6\x85\x03\xD1\xC8\xD5\x45\xEE\xD7\x17\xEE\x5A\xD0\xE8\xA6\xD4\xC2\xFF\xE4\x47\xEA\xE8\x0C\xEA\x22\x0E\xE8\x91\xE9\xD1\xC1\xC3\x46\xEC\x89\x28\xEE\xA2\xEA\xE8\x8C\xE3\xCE\xF8\xE6\x49\xF0\xE9\x14\xE9\xA5\xCE\x09\x95\xE9\xB6\x89\xE7\x40\xEB\xE4\xC2\xE7\xA4\xF9\xE8\x99\xEB\xD3\xB4\xE9\x3F\xE8\xE6\x37\xED\x20\x3E\x01\xD2\xC6\x07\x6E\xE4\xEF\xCD\xC0\x4B\xEC\x43\xCD\xEA\x81\xEF\xCE\xA5\xE9\x50\xE6\x08\x51\xE8\x59\xD3\xEA\x7B\xE5\xD3\x9A\xE9\x52\xE4\x08\x59\xE9\x8A\xDB\xEB\x66\xED\xD2\x99\xC7\x4B\xEA\xEA\x4C\xEE\xA9\xE3\xE5\x4D\xE9\x1A\x50\xE9\x5A\xF4\xEA\x64\xE6\x8B\xDC\xDE\x87\x01\xD6\x8F\xE7\x58\xED\xCC\x23\xEC\x6B\xEC\xEA\x44\xDE\xBB\xEE\xD6\x59\xFF\xDD\x0B\xD3\x77\xD9\xDE\xC1\xE0\xBC\xC8\xD2\xF0\xC6\xEC\xC4\xD8\xB1\xC6\xDF\xE2\xD3\xD8\x8C\xED\x61\xEC\xD2\x87\xE8\xB2\xC9\xEC\xC9\xEB\xD8\x8A\xED",
			"\x63\xF6\xEC\x8F\xE8\x4A\xD1\xEC\xCD\xE3\xD9\xC1\x13\xBA\xD9\xDC\x57\xE4\x0F\xCA\x09\xC8\xC1\xC5\x81\xCD\x63\xC3\xCC\xAA\xDC\x59\xC5\x09\xC3\xC8\x95\xA2\xE7\xDD\xD7\xD8\x48\xCC\x43\xE6\xED\xBD\xC8\xDA\xAD\xDD\xA7\xC6\x08\xAC\xEA\xB4\xFE\xE9\xAA\xEA\xC7\x82\xD2\xE8\xD1\xED\xC8\xD3\xB6\xD6\xCB\xDA\xE2\xA9\x85\xCD\x6E\xED\xC3\x2F\xE2\x90\xF2\xEA\x05\xE3\xC0\xAD\xEF\x68\xE5\xCD\xC2\xEA\x2D\xCA\x09\xB8\xC9\xDA\xB7\xEF\x6A\xF9\xE1\x79\xEE\x72\xE4\xE5\x4D\xC0\xDB\xFE\xC9\x69\xFA\xE9\xD3\xEF\x6B\xFD\xC8\xEC\xE5\xD6\xA5\xC6\x6F\xF9\xE1\xC0\xEF\xBB\xC4\xEB\xF0\xE1\xAE\x98\xCC\x0E\xC9\xEE\x9A\xE3\xB9\xE6\xE3\xEE\xE0\x99\xD0\xEC\x78\xE6\x08\xD4\xEE\xB6\xE6\xD4\x85\x07\xDC\x8D\xC1\x76\xFA\xDE\xF2\xEA\x7D\xCE\x08\x26\x05\x9A\x90\x06\x5A\xF2\xD9\x0D\xC4\xC0\xDC\xD0\x03\xF0\xD7\xEB\xE9\x80\xF0\xDF\x12\x0A\xC1\xC8\xD6\x06\xFC\xD5\xC7\xE8\x39\xF7\xEA\x05\x0A\xC2\xD1\xE2\x0A\xF4\xD6\xDD\xEA\x4B\xFF\xEA\x00\x02\xC3\xCF\xE4\x0E\xF8\xD7\xE5\xEC\x6D\xC7\xEB\x04\x0A\xC4\xD7\xE4\x12\xFB\x97\xFF\xED\x2E\xE3\x0F\x09\xF5\xC0\xC7\xF1\xF8",
			"\xE0\xCF\xF3\xEA\x42\x1D\x00\xA5\xCA\x07\x33\xF1\x97\xCD\x80\xB8\xF0\x87\xDA\xF1\x0D\xF2\xB9\xF5\xF1\xFE\xB2\x11\x3E\xF0\xB2\xC0\xF2\x15\xF7\xA7\xFE\xE6\x0C\xF4\x10\x46\xF1\x14\xE8\xF2\x1D\xF6\xC2\xF6\xE8\x26\xF0\x00\x4E\xF3\x23\xF0\xF2\x25\xF6\xC3\xFF\xEA\x2A\xF6\xE5\x97\xE4\x96\xED\xF1\x26\xF1\x44\xD1\xE7\x1B\xF9\xE3\xBB\xF2\x24\xEF\xF0\xF6\xD9\x2D\x1E\xBC\xE0\xBC\xC7\x94\x09\x1D\xE9\x0B\x6F\xF5\x2F\x31\xF3\xDA\x03\xE7\xC2\x0F\x1C\xFC\xDD\x2E\xF3\xBB\xE3\x0F\x3C\xFB\xD7\xBD\x0C\x9F\xE8\xF3\xA9\x0F\xCF\xC3\xF2\xE5\x02\xE8\xD6\xE9\x90\x05\xF4\xBD\xE8\x5D\xF9\xDF\xDA\xD1\xD8\x8E\xED\xA3\xF8\xEC\x8F\xF4\xB2\xD7\xEC\x49\xF9\xD9\xD4\xD3\x66\xF6\xF4\x9D\xE8\xD3\xD5\xEC\x4A\xF1\xE9\x9C\xEF\xA6\xFE\xF4\x93\xF0\xD4\xD5\xF4\x2C\xD7\xE9\xA4\xF5\xA6\xE6\xF5\x9F\xF2\xD3\xE1\xF4\x55\xF3\xEA\xDC\xD1\xA9\xEE\xF5\xA7\xF0\xD6\xE9\xF4\x54\xFB\xEA\xB4\xF5\xAB\xE0\xD3\xAF\xF0\xD7\xF1\xF4\x5D\xF3\xEB\xB2\xF5\xAD\xFE\xF5\xB7\xF4\x4C\xF9\xF4\x61\xFB\xEB\xC4\xF5\xAF\xFC\xF5\xBF\xF0\xD9\xC1\xF6\x34\xD3\xEC\x8C\x0A\xAA\xD6\xD4\x7D\xED",
			"\xBA\xCD\xF6\x42\xD9\xA6\x86\xD5\xB5\xFC\xEB\xD7\xF7\x75\xD9\xF7\xD8\xDB\xED\xFC\xBC\xEB\xC5\xEE\xD1\xF2\xBF\xC5\xF6\x66\xF3\xEE\xD4\xF7\xB4\xF6\xF6\xE7\xF0\xDB\xE9\xF6\x6D\xFB\xEE\xB0\xF0\x9B\xA5\xCD\x25\x07\xBE\xC5\x08\x13\x06\xD4\xED\xF4\xD1\xCB\xDD\xF8\xF1\xDC\xE0\xF7\x6D\xF3\xBB\xFC\xF4\xA3\xEF\xC9\x84\xED\xD3\xEC\xF4\x81\xF6\xEB\x84\xF8\xB0\xE6\xF8\xCA\xF0\xE1\xC6\xF7\x64\xFB\xF0\xCB\xF6\xB9\xE5\xF7\xE8\xF0\xE2\xEA\xF6\x89\xFC\xEE\x94\xFB\x3F\x0F\xF6\xDF\xF0\xDA\xFE\xF6\xC0\xE0\xF0\x8E\xF5\xC7\xF0\xF4\x1F\xFC\xD3\xE1\xF8\x51\xFA\xF0\xA7\xF0\xC7\xEB\xC6\x01\xFB\xE4\xC3\xF8\x95\xF5\xF0\xAC\xFB\xC1\xEE\xF9\x09\xF8\xE6\xCD\xF9\x92\xFF\xF0\xC7\xF6\x80\xEA\x08\x11\x00\xDE\xF2\xF6\x82\x04\xEF\xAC\xEA\x96\xF3\xBD\x1B\xFD\xA7\xD6\xF9\x7E\xFD\xEE\xC4\xFB\xD0\xFF\xF7\x28\xFE\xE3\xC9\xFA\x90\xFB\xF4\xA2\xF9\xD3\xE4\xF9\x32\xFC\xDC\xF6\xF8\xA9\xFC\xF0\xD4\xFA\xC3\xF1\xF8\x53\xFD\xE6\xD5\xFA\xAD\xF7\xF5\x93\xF9\xD6\xF8\xFA\x5B\xFA\x20\x18\xF9\x7C\xF1\xF4\xD2\xF7\xD1\xE7\xF9\xDB\xB9\xE5\xCF\xFB\x95\xFB\xF6\xAD\xF9\xDB",
			"\xFA\x0D\xDE\xF4\xEC\xC5\xFA\xA4\xF9\xF6\xCA\xF9\xDD\xEC\xFA\x77\xFE\xE9\xF9\xFA\xA8\xFF\xF6\xB1\xF9\xDF\xF7\xF9\x06\x0F\x05\x25\xCD\x0E\xC2\xDD\x86\x0B\x17\x15\xF7\x16\xFF\xDE\xFA\xF6\x8D\xF3\xF7\xE8\xFA\xEF\xAA\xFB\x7B\xFC\xED\xD1\xFC\x50\x16\xD0\xB9\xE1\x03\x05\xCD\x1E\x00\xF1\xDF\xFB\x80\x0A\xF8\xE5\xF9\x63\xCE\xF3\x6D\xF0\x98\xE2\xF7\xCD\xFA\xCB\xF4\x41\x69\xD2\x03\xE2\xEA\x22\x33\x02\xF2\xE0\xBB\xF1\xFB\xE2\xF9\xF8\xB0\xFA\xEE\xE7\xFA\xA1\xF4\xFA\xDC\xF5\xE3\xF4\xFD\x61\xFE\xEB\xF9\xFD\x8A\xF5\xFB\xC6\xF9\xEF\xF4\xFB\x8F\xFE\xEE\xC1\xFE\xBC\xF3\xFC\xFA\xF9\xF1\xFC\xFB\x93\xFF\xE5\xFF\xFA\x67\xF0\xFC\xB7\xBC\xE4\xE7\xFE\x92\xF8\xFA\xEE\xFB\xE4\xFE\xF7\xD4\xFF\xCC\xF1\xFA\x5C\xFC\xE6\xE7\xD6\xDC\xFD\xF5\xBC\xFF\xEE\xF6\xFD\xB3\xFE\xEC\xFF\xFC\xC7\xFE\xFC\xC2\xFD\xF9\xE4\xFE\xE7\xFE\xF8\xE9\xFF\x31\xFB\xDF\xD1\xE3\x03\x1A\xFC\xDF\xF8\x7F\xF0\xF3\xE6\xF6\x7A\xCF\xFF\xFA\xF1\xFE\xF7\xFB\xFA\xD2\xFE\xE5\xF6\xFD\xD6\xFA\xF6\xFA\xFD\xDD\x7C\xF8\x73\xFE\x5C\x7F\xFF\x7E\xF7\x71\x00\xBE\x7E\xDF\x7C\x02\x87\x00\xB4",
			"\x7F\xAF\x5F\x02\x84\xFE\x75\x7F\xE6\x7C\x04\x88\xFE\x52\x80\xEA\x7C\x05\x88\xFC\x7B\x7F\xD5\x7C\x06\x87\xFD\x4B\x7F\xD9\x7C\xF6\x70\xF6\x4E\x80\x04\x82\x07\x80\x00\x85\x80\x02\x81\x02\x8C\x00\x80\x7D\xB7\x7E\xF8\x76\x02\x8F\x80\x0D\x80\x09\x8A\x00\xAE\x80\x27\x83\x80\x03\xF6\x6F\x7E\xB2\x7F\x00\x8A\x02\xA0\x80\x37\x80\x0C\x8C\x02\xA8\x80\x16\x7E\xEB\x7E\xF9\x7B\x7B\x29\x83\xE8\x7B\x02\xA1\x80\x1C\x83\x07\x8A\x03\x84\x81\xFD\x7D\x07\x85\x04\xA3\x80\x22\x81\xE9\x7E\x10\x33\x00\xA5\x67\x19\x0F\x96\x4A\x04\x66\x00\xEB\x7B\xED\x6A\x6B\xF7\x6D\xE8\x7F\xCC\x4E\x77\x06\x04\x09\x05\x9A\x44\x01\x66\x7B\x75\x65\x03\x83\x81\x39\x81\x13\x85\x02\xB8\x80\x42\x80\x1A\x80\x04\xA1\x7F\x69\x83\x11\x85\x06\x8B\x81\x06\x82\x1B\x8D\x06\xA6\x81\x2F\x80\x1D\x81\x03\x9F\x63\xB0\x6F\x0C\x8F\x03\x8C\x7E\x6C\x83\x1A\x86\x03\xB3\x81\x70\x83\x19\x82\x07\xBE\x81\x64\x80\x20\x89\x04\x9B\x7F\x6F\x83\x21\x8C\x04\x81\x82\x75\x80\x23\x87\x07\xA3\x63\x63\x82\x1A\x8C\x07\xBF\x81\x84\x82\x24\x8C\xE6\x61\x76\x68\x35\x69\x6C\x0A\x2D\x6F\xDB\x5D\x03",
			"\x6D\x05\x1A\x82\x9C\x82\x85\x6A\xE7\x56\x04\x9E\x80\x28\x83\xC5\x62\x81\x7D\x7A\xBB\x7E\x10\x1F\x82\x1C\x6B\x26\x87\x0A\xA2\x82\xA9\x80\x29\x82\x11\x2C\x82\xC8\x6A\x2B\x81\xC9\x68\x82\x80\x79\x29\x73\x0B\xA6\x82\xB7\x80\x2C\x89\x0B\x8E\x81\x0A\x04\x2D\x81\xC5\x76\x82\x99\x73\x12\x73\xE8\x40\x7E\x05\x06\x30\x8F\xC8\x44\x83\x78\x70\x6F\x7A\xCE\x68\x78\x99\x81\x2B\x81\x0A\xB6\x70\xA3\x81\x0E\x7A\x0C\x97\x72\xCC\x83\x10\x72\xE5\x5E\x75\x54\x7B\x35\x80\xC2\x44\x04\xD9\x80\x0D\x71\xE6\x48\x82\xF1\x71\x30\x8C\x0B\x85\x83\x67\x7B\x31\x80\xE1\x6B\x82\xE7\x81\x33\x81\xD7\x6A\x83\xAF\x05\x29\x82\x0D\xAF\x82\xD4\x81\x2C\x86\x0D\xAD\x83\xDA\x82\x92\x78\xD4\x55\x80\x2D\x82\x1D\x8B\x03\x9B\x63\x41\x81\x25\x83\x08\x93\x82\x85\x82\x40\x8E\x0F\x88\x81\x1A\x82\xFF\x77\x10\x89\x82\x09\x86\x12\x8A\x08\xB1\x81\x0B\x86\x21\x8D\x10\x86\x81\x11\x86\x41\x8E\x08\xBF\x83\x78\x83\xB6\x7A\x07\x81\x84\x04\x86\x24\x81\xFB\x74\x80\x20\x87\x1E\x83\xA7\x7E\x80\x1C\x87\x47\x82\x12\x91\x82\x03\x86\x49\x85\x12\x97\x6A\x12\x05\x10\x05\x9A\x7D\x01",
			"\xD3\x80\x2B\x7D\x12\xAF\x84\x31\x84\x2E\x75\x0D\x98\x82\x2E\x84\x87\x60\x13\xB4\x83\xA6\x5F\x8B\x72\x0B\x8E\x04\x39\x84\xB2\x6B\x13\xBD\x82\xF5\x83\x2F\x8A\x0A\x8A\x04\x41\x85\x14\x73\x14\xA8\x83\xB8\x80\x3C\x8D\xD6\x73\x84\x3A\x85\x4D\x82\xFA\x49\x7A\x54\x79\x52\x8F\xC8\x4B\x85\xEE\x82\x83\x7E\x14\xBA\x82\x40\x84\x4D\x8C\x13\xB6\x84\xF6\x80\x4E\x8E\x15\x84\x85\x3D\x87\x4D\x80\xC6\x5D\x85\x51\x87\x57\x83\x15\x8F\x83\x20\x7A\x55\x87\xC9\x58\x85\xF9\x82\x33\x84\xD0\x6D\x85\x63\x84\x53\x8E\x0B\x9B\x85\xC0\x82\x41\x0E\x16\x9F\x83\x00\x00\x5C\x82\x0E\xBF\x7C\x26\x7D\x55\x85\x17\x99\x85\x42\x7A\xA1\x75\x0E\xBA\x85\x83\x85\x5C\x8F\x0E\x86\x86\x94\x7F\xA2\x78\x11\x90\x82\x21\x87\x4A\x81\x19\xBD\x81\x1D\x85\x4A\x88\x12\x95\x84\x95\x84\x66\x8A\x12\x94\x86\x9B\x84\x25\x89\x19\x97\x84\x08\x85\xFE\x7C\xFF\x53\x84\x8B\x83\x43\x87\xF1\x4F\x82\x8E\x6B\x64\x8E\x19\x9D\x86\x05\x87\x67\x86\x1A\x8D\x82\xA6\x84\x49\x8C\x19\x97\x86\xA0\x84\x43\x82\x1A\x99\x80\xB7\x87\x06\x8F\x1A\xA8\x86\x7E\x6A\x6A\x8D\x1A\xAC\x86\x1E\x84\x6D\x8B",
			"\x1B\x8F\x86\xA9\x87\x49\x8E\x1B\x81\x87\xC7\x86\x65\x89\x1C\x9A\x86\xC2\x84\x69\x80\x11\xB5\x86\x12\x85\x6E\x8C\xFC\x44\x87\xBD\x86\x71\x86\x1D\x92\x86\xD7\x87\x6C\x8D\xFA\x7C\x86\xBD\x6D\x76\x8B\x1A\x8D\x87\xD2\x86\x43\x8E\x1C\x82\x82\xCC\x87\xE2\x7D\x80\x69\x6B\x7C\x72\xE7\x54\xA0\x58\x82\xFF\x77\x79\x85\x9A\x48\x80\xEB\x87\x59\x8B\xBF\x72\x85\x40\x74\xFB\x7F\xF9\x71\x71\xEE\x6A\x7A\x87\xB1\x48\x7A\x6C\x84\x95\x78\x1E\xAE\x71\xFA\x84\xE2\x6D\xB1\x4B\x86\x54\x86\x7D\x8B\x97\x7F\x71\x8D\x65\x80\x8D\xDC\x6B\x6A\xF4\x87\x92\x76\x20\x96\x65\x08\x8B\x5E\x6A\x20\x8F\x71\x0C\x88\x81\x8D\x1F\x8F\x88\xFF\x85\x7E\x83\xA2\x56\x81\xFA\x83\x85\x78\x21\xAF\x87\xA9\x7E\x80\x8C\x1F\xB3\x85\xFE\x84\x88\x8D\xDE\x62\x88\xE3\x83\xD9\x6F\x21\x9C\x68\xF0\x87\x7E\x89\x22\x8E\x6E\x36\x7A\x67\x61\x21\x96\x65\x13\x88\x16\x7B\x84\x56\x88\x24\x8B\x8A\x88\xAC\x6D\x88\x28\x88\x60\x82\xE6\x47\x86\xF7\x85\x0A\x70\x20\x9B\x88\xEC\x87\x8B\x83\xB3\x60\x78\x19\x8A\x67\x65\x23\xAF\x71\xF3\x84\x8E\x85\x1F\x80\x89\x07\x88\x7E\x8A\x24\x84\x89\xF2",
			"\x87\x6E\x7E\x24\x8E\x88\x90\x09\x92\x81\x24\xBF\x88\x51\x88\x43\x0D\xF9\x58\x87\x60\x8A\x76\x8E\x1D\xBF\x86\xE0\x86\x05\x88\xFF\x66\x89\xFA\x7D\x78\x84\x11\x90\x87\x16\x87\x70\x81\x1A\xA8\x89\xA3\x86\x9A\x85\x1A\xA3\x87\xB0\x84\x9D\x8C\x1D\xB6\x7F\x70\x88\x45\x0B\x11\xA2\x89\x61\x8B\x77\x8B\x1C\xAC\x89\xAE\x86\x9D\x84\x1D\x90\x09\xB2\x86\x9F\x83\x26\x88\x87\x87\x8A\x72\x89\x28\xA5\x87\x8B\x88\xA0\x80\x1C\x8A\x8A\x7D\x88\x99\x8F\x27\xAE\x89\xB6\x85\x9E\x8A\x1B\x82\x8A\x6F\x89\x3F\x8E\x28\xA5\x89\x9A\x88\xA5\x81\x1D\x96\x8A\x0A\x87\xA6\x89\x07\xB7\x89\x11\x81\xA7\x88\x29\x95\x8A\xA6\x8A\x9C\x8F\x1C\x9E\x8A\x6D\x8B\x78\x85\x28\x92\x8A\x8D\x88\xAB\x81\x28\xAA\x8A\xE4\x86\xA8\x81\x2B\xA7\x8A\x9F\x89\xB5\x0D\x80\x5F\x74\x51\x70\x0C\x01\x22\x8F\x77\x45\x8A\xA8\x62\x11\x3C\x8A\x8F\x72\xAF\x87\x22\x80\x8B\x55\x8B\x8D\x8A\x15\x8C\x86\x44\x7B\x1C\x35\x9A\x46\x8B\xB8\x7F\x07\x64\xDA\x5C\x81\xCA\x89\x61\x85\x20\x90\x89\x00\x00\xB1\x87\xC9\x50\x8B\x2A\x82\xB4\x8C\x21\x8D\x88\xFB\x83\x83\x8A\x2D\xBC\x85\xDC\x8A\x10\x8E\x2D",
			"\x81\x8B\xDB\x83\x87\x74\xE5\x63\x8B\x33\x89\xB9\x84\x08\xA7\x8B\xC9\x89\x85\x8B\x2C\x97\x8B\x31\x89\x41\x0C\x2E\x92\x89\x05\x06\xBB\x84\x10\xB0\x8B\xEF\x76\x6B\x74\xE3\x4C\x8B\xE2\x6E\x42\x07\x2F\x82\x89\x0A\x06\xBE\x8B\x24\x80\x00\xD3\x8A\x6E\x75\x2D\xBF\x8B\xF4\x89\xB3\x82\x30\x8F\x8B\xBF\x8A\x41\x09\x30\x88\x77\xFE\x8A\x31\x80\x30\x88\x83\x04\x07\xC0\x80\xCA\x4E\x04\x06\x8D\x61\x63\x31\xBE\x77\x46\x8B\x3A\x7E\x2C\x9C\x68\x1D\x8E\x6A\x74\x10\x1F\x8C\xF0\x76\xC5\x8D\x30\x81\x8C\x06\x06\xC6\x82\x10\x1F\x60\x25\x8E\x75\x77\x32\x9F\x8B\x57\x89\xB8\x88\x2D\xAE\x8C\x01\x04\xCC\x81\x31\x85\x04\x28\x8D\xC5\x89\x0E\x97\x8C\xEB\x83\xC3\x84\x32\xBB\x8C\x33\x8C\xBA\x8D\x21\x93\x79\xE2\x88\xC4\x87\x2C\x92\x8C\x34\x8F\xBC\x87\x21\x99\x89\x26\x89\x5F\x02\xFF\x72\x79\x6C\x62\xFE\x6D\x2F\x85\x8C\xA5\x64\x18\x02\x15\x9E\x89\x5F\x6E\xE8\x6A\x2F\xB3\x88\x5A\x8E\x5A\x8B\x05\xAB\x8C\x84\x72\xB5\x6E\x35\x99\x8D\x5B\x8F\x25\x66\x16\x8C\x62\x56\x8C\xB5\x84\x10\x1F\x8D\xF8\x88\x41\x01\x36\xA4\x85\x60\x86\x51\x85\x8B\x5D\x8D\x39\x70",
			"\xDC\x84\x30\x86\x04\x73\x8E\x5D\x85\x14\xB8\x85\xA7\x60\xDE\x88\x09\xBA\x8D\x1B\x8E\x42\x0D\x37\x84\x86\x0C\x8F\xD3\x8E\xB5\x66\x8D\x79\x8C\xDA\x82\x36\xAA\x8D\x61\x85\x1C\x6D\x36\x8A\x8C\x6F\x8E\xE3\x84\x37\xAB\x85\x39\x8B\x17\x7A\x02\xA7\x8D\x1C\x6B\xE1\x8A\x18\x8E\x8D\x99\x8F\xE2\x88\xFB\x5C\x8E\xC8\x6A\xE7\x8F\x17\xA9\x8B\x5B\x79\x13\x73\x3A\x8D\x8E\x9D\x8D\xDA\x84\xD2\x64\x8D\x94\x73\xEA\x83\x38\x96\x8E\x7E\x8D\x59\x81\x39\xAC\x8D\x17\x6C\xE1\x8F\x32\x92\x04\xA6\x8F\x9D\x70\x3A\x8F\x89\xA2\x8F\xE6\x8C\x3A\xA5\x8E\xAE\x8E\x5E\x76\x37\x95\x8D\xB9\x8C\xED\x88\x38\xAA\x8C\x8A\x8D\x9C\x80\x2A\xA9\x79\x7D\x07\x9A\x7B\x16\x3D\x63\x95\x69\xE5\x7E\xC6\x54\x04\xD4\x8F\xA4\x88\x2B\xAD\x8A\xB4\x89\x9D\x8D\x3D\xA4\x8A\x13\x81\xAA\x8F\x3C\xAB\x89\xB2\x8B\xA3\x8C\x28\x91\x8A\x88\x88\xFA\x80\x29\xBC\x89\xEC\x8D\xED\x7B\x27\x86\x8A\xEA\x8F\xF9\x8D\x3E\xB0\x8A\xF1\x8D\x20\x8F\x2A\xA9\x8F\xF3\x8C\xFE\x80\x3F\xB9\x8F\xEB\x8F\xFE\x8E\x19\x8D\x60\x2E\x01\x69\x6E\x0D\x99\x68\xE6\x83\x57\x66\x32\x80\x00\x5C\x03\xB8\x66\x25\x99",
			"\x6F\x00\x92\x00\x93\x05\x86\x04\xDE\x83\x5C\x6E\x10\x09\x90\xA9\x69\xCA\x8F\x33\xB0\x8E\xF1\x82\x44\x01\x40\x9C\x68\x03\x91\x61\x61\x41\x85\x66\x14\x93\xAD\x6E\x33\x8D\x85\x40\x8D\x06\x9E\x10\x1B\x90\xC8\x69\x07\x97\x40\x9F\x90\x07\x91\x08\x9F\xAC\x4D\x89\xBF\x8C\x96\x85\x2F\x84\x04\x28\x91\x14\x7A\x42\xB2\x8C\xD1\x80\x61\x6D\x42\x8A\x90\x0B\x8C\xF3\x81\x3A\x8E\x8C\x06\x05\x0D\x9F\xC8\x77\x90\xED\x7D\x32\x83\xB0\x74\x6A\x29\x5C\x0F\x92\x2F\x96\x8B\xCD\x8C\xCB\x85\x10\x02\x91\x97\x70\x11\x90\xAC\x45\x90\x3A\x90\x0E\x9E\x42\x9A\x6B\x23\x93\x5D\x85\x42\x8F\x85\x27\x92\x03\x94\x99\x6C\x83\x06\x92\x15\x9A\x44\x83\x88\x31\x92\xCD\x83\x43\x80\x00\x50\x90\x5F\x82\x45\x88\x91\x60\x91\x15\x95\x44\x84\x04\x57\x93\x73\x66\x41\xA4\x90\x18\x90\x17\x9A\x10\x29\x91\x33\x8B\x1A\x97\xAD\x6D\x91\x06\x06\x04\x9A\x10\x31\x91\x00\x03\xB3\x73\x22\x80\x8F\x40\x93\x13\x9E\x45\x9D\x65\xBB\x81\x18\x9F\x46\x88\x90\x63\x93\x20\x92\x43\x85\x92\x34\x93\x21\x92\x98\x49\x92\x6E\x93\x14\x96\x10\x00\x92\x82\x91\xC8\x80\x0D\xB8\x91\x71\x8D\x0E",
			"\x93\x49\xBC\x91\x05\x06\x1F\x97\x49\x8D\x92\x9A\x90\x88\x7C\x49\xBB\x8D\x46\x93\x17\x94\x45\xBD\x91\x20\x90\x29\x9E\x23\xA4\x83\x67\x93\x29\x95\x38\x90\x90\x0F\x91\x2A\x95\x49\xAC\x91\x7F\x92\x2B\x98\x3A\xA6\x77\x8A\x79\x5A\x0C\x8B\x5A\x89\xDC\x8F\xF8\x83\x27\x9F\x8F\x83\x88\x9E\x82\x3E\x87\x93\xB5\x08\x30\x93\x2B\x82\x93\xAB\x8B\xF6\x8B\x4C\x88\x93\x00\x84\xFF\x82\x3F\xBE\x8F\xF4\x8E\x34\x96\x2B\xAD\x7B\xEF\x8D\x35\x94\x4D\xBA\x8F\xDA\x91\x37\x9C\x4D\x81\x80\xF7\x8D\xFF\x8E\x4D\xA2\x93\xDF\x90\x39\x96\x4E\x93\x93\xE3\x90\x3A\x95\x4E\xAA\x93\xE7\x93\x35\x96\x4D\xA5\x8F\x9C\x88\x0F\x8B\x4D\xAD\x93\xF0\x92\xF6\x84\x4C\x99\x8A\xF2\x91\x3A\x91\x08\x99\x93\xEB\x92\x3B\x93\x4F\xAC\x93\x00\x96\x3F\x91\xFF\x60\x8F\xFC\x81\x3E\x9D\x4F\xB5\x93\xB7\x8B\x3D\x98\x2A\x86\x94\x03\x85\x03\x6A\x79\x5C\x68\x71\x01\x2D\x94\x10\x30\x01\x47\x90\x19\x98\xE0\x52\x04\x0F\x94\xB2\x61\x51\xAA\x92\x06\x04\x45\x9A\x48\xBD\x90\x17\x91\x13\x98\x31\x80\x00\x19\x95\x14\x7B\x51\x88\x92\x0E\x06\x47\x97\x4B\x96\x94\x89\x8F\x0F\x9E\x44\x84\x04",
			"\x25\x97\x23\x77\x52\x9F\x92\x0A\x06\x4A\x9C\x4A\x99\x91\x7F\x8F\x16\x9C\x15\x8A\x04\x31\x97\x25\x73\x53\x94\x62\x1F\x62\x4D\x91\x4A\xB3\x91\x5A\x91\x1D\x9B\x53\x86\x04\x3D\x94\x5F\x8F\x53\xBD\x66\x41\x95\x45\x9E\x48\xA6\x91\x90\x90\x49\x95\x9A\x4B\x95\x1C\x6D\x53\x9F\x51\x8B\x91\x2D\x94\x21\x9F\x52\x92\x95\x10\x96\x44\x90\x00\x02\x95\x04\x04\xFF\x5F\x54\x9E\x88\xD8\x89\x52\x93\x23\x94\x95\x04\x91\x47\x9E\x54\xA5\x92\x54\x7A\x59\x9D\x49\xA8\x95\x85\x64\x58\x90\x00\x22\x95\x6C\x97\x83\x8E\x56\xA8\x92\x04\x04\x5C\x97\x40\xB2\x95\x74\x97\x2B\x9A\x22\xA5\x95\x53\x96\x57\x9C\x57\x84\x95\x39\x96\x51\x99\x17\x85\x04\x77\x97\x2C\x95\x10\x3A\x95\x38\x93\x60\x98\x53\xB6\x8E\xC7\x8C\x26\x89\x58\xBB\x8E\x0E\x04\x63\x9B\x48\x8E\x96\x30\x90\x13\x9E\x52\xA3\x94\x93\x95\xCE\x82\x11\x16\x96\x96\x91\x41\x08\x59\x8B\x90\x9A\x96\x56\x9F\x15\x2D\x6B\x32\x89\x27\x98\x5A\xB9\x8A\x0C\x95\x40\x98\x50\xAD\x7B\x9E\x5F\x9C\x6C\x4F\xB4\x93\xCE\x92\xF9\x82\x50\x87\x94\xB5\x95\x3C\x92\x03\x84\x94\x17\x82\x42\x9C\x5A\x91\x93\xFF\x92\xFD\x8C",
			"\x5B\x82\x07\xE1\x92\x6B\x9E\x4C\xAB\x96\xC1\x90\x34\x99\x11\xB5\x8F\xA6\x85\x6C\x91\xA7\x73\x96\xC6\x96\x6F\x99\x5C\xAD\x96\xB7\x94\x6D\x92\x5D\x8F\x93\xD4\x96\x69\x80\x5D\x95\x97\xD1\x94\x33\x95\x2B\xAF\x96\x3D\x83\x70\x97\x22\x05\x97\xDC\x94\xA0\x8D\x80\x7D\x00\xA5\x65\x1D\x0E\x55\xB4\x01\x6B\x96\xB0\x80\x6D\x69\x97\xEB\x95\x7B\x9B\x4B\x81\x86\x0F\x88\x7A\x9C\xA1\x6A\x97\x1C\x95\x41\x0C\x5E\x97\x95\x2C\x96\x0F\x96\x5A\x81\x8D\x06\x06\x7D\x98\xAC\x78\x97\x28\x96\x42\x0B\x5F\xAB\x94\x63\x94\xD2\x88\x2D\x82\x98\x51\x70\x81\x94\x53\x86\x04\x07\x9B\x4D\x99\x59\x99\x95\x8F\x93\x56\x9C\x60\x8F\x72\x0E\x98\x50\x92\x11\x11\x98\x43\x97\x63\x95\x37\x80\x8E\x3F\x86\x42\x07\x61\x97\x72\x19\x98\x53\x9B\x61\xB2\x97\x47\x8C\x37\x85\x5F\xB0\x97\xF9\x94\x41\x0C\x61\xA1\x95\x84\x94\x64\x90\x62\xB9\x70\x23\x98\x5F\x85\x62\x95\x95\x27\x98\x7F\x99\x60\xAA\x98\x0B\x98\x8B\x95\x60\x90\x98\x28\x98\xB8\x84\x56\xA7\x91\x35\x9B\x8C\x87\x63\xA9\x95\xFA\x95\x90\x95\x33\x83\x99\x51\x95\x91\x9D\x49\x87\x99\x85\x67\x8B\x93\x57\xB1\x98\x1F",
			"\x9A\x4E\x97\x58\x84\x04\x4E\x98\x5E\x90\x00\x10\x99\x07\x92\x94\x9D\x57\xB3\x97\x5C\x89\x93\x9E\x63\x8F\x98\x49\x9A\x8E\x95\x57\xBD\x98\xF7\x95\x7C\x96\x66\xBE\x95\x30\x88\x73\x7E\x99\x64\x8E\x51\x71\xEF\x84\x65\x90\x04\x75\x78\x93\x86\x10\x3A\x8E\x9E\x96\x43\x02\x67\x9E\x98\x98\x8F\x7F\x9C\xC9\x6E\x6B\x70\x9B\x23\x7B\x67\x93\x98\xFE\x95\x85\x95\x36\x80\x9A\xC3\x8D\x9C\x95\x3C\x9A\x77\xB7\x8C\x25\x67\x37\xB3\x8E\xAD\x8F\xE3\x8F\x3A\xA2\x94\xB1\x8F\x9B\x99\x68\x82\x9A\x8B\x98\x80\x73\x63\xA9\x65\xC9\x8D\xA4\x97\x39\xA3\x8D\x94\x9B\x9F\x96\x69\x90\x9A\xC4\x8E\xA4\x96\x3C\x9B\x9A\x71\x63\xA3\x91\x2F\x80\x00\x78\x98\x40\x0F\x81\x43\x9A\xA4\x94\x85\x90\x55\xB3\x77\x9D\x70\xA9\x9A\x68\xA6\x9A\x8C\x99\x64\x99\x6A\x9D\x9A\xA5\x9B\xA7\x90\x39\xBA\x9A\x8C\x62\xAA\x97\x35\xB7\x99\xCA\x8F\xE7\x85\x5A\x86\x9A\x95\x99\x63\x61\x68\x97\x72\xB0\x98\x48\x94\x47\xA1\x9A\x56\x70\xA2\x96\x6B\x98\x9A\xB8\x9A\xA6\x96\x65\x81\x8E\xB5\x9B\xAA\x9D\x6A\xBF\x03\xAF\x99\xA6\x9E\x13\xA2\x97\xCE\x8E\x72\x90\x19\x89\x94\xDE\x96\xF7\x85\x6E",
			"\xA0\x9B\xB8\x87\xB9\x95\x4C\xA5\x8A\xD9\x95\x6E\x96\x4F\xAA\x9B\xF8\x90\x70\x9A\x4F\xA0\x97\xEE\x8C\xBA\x97\x29\x97\x97\xB6\x94\xBD\x93\x6F\xAE\x9B\xDD\x7A\xBD\x91\x2A\xBA\x9B\xB8\x94\xBE\x9A\x5B\x8B\x97\xEF\x90\xBF\x9C\x5C\x86\x9C\x05\x9E\xC0\x9F\x6E\xA2\x9B\xC5\x87\xC1\x9A\x70\xA4\x9B\x0C\x9D\x75\x8E\x70\xB0\x9B\x0B\x96\xBC\x91\x70\x9E\x97\xDB\x94\xC0\x96\x5D\x94\x9C\xBF\x94\xC1\x91\x5C\x9A\x9C\x66\x80\x79\x90\x72\xA5\x97\x23\x9D\xC9\x98\x70\x9F\x9C\x27\x9D\x6B\x87\xB8\x4A\x04\x2A\x60\x26\x86\x04\x25\x66\x86\x00\xD1\x80\x00\x31\x9C\x98\x83\x07\x65\x08\x05\x66\x1F\x63\x21\x0F\xC2\x5F\x60\x88\x03\x1A\x67\x40\xBD\x9C\x0E\x05\x47\x71\x6B\xAF\x64\x2B\x9E\x41\x0D\x72\xAB\x9A\x2F\x9C\x87\x64\x73\x91\x8B\x12\x07\xD2\x93\x6C\xA1\x96\x04\x07\xCD\x97\x40\xB9\x9C\x3B\x9E\x44\x00\x74\xAC\x9C\x85\x67\xD5\x98\xD3\x44\x9A\x21\x97\x66\x99\x6C\xBD\x66\x47\x9F\xD3\x94\x10\x09\x9D\xC8\x6A\xD3\x96\x2E\x8D\x9D\x39\x72\xCD\x98\x73\x92\x04\x3A\x9E\x28\x7C\x73\xBE\x9C\x38\x92\xD6\x95\x10\x02\x9D\xCE\x99\x51\x90\x6D\xAD\x71\x81\x61",
			"\xD8\x9E\x36\x80\x00\x64\x9D\x14\x76\x76\xAF\x8B\x68\x9D\xCD\x92\x11\x12\x9D\x38\x90\xD5\x9E\x76\x96\x9D\x70\x9F\x22\x92\x77\xA2\x59\x73\x98\xA8\x9E\x75\xA2\x9A\x94\x62\xDE\x94\x39\xBC\x9D\x30\x9E\xCC\x9F\x77\x94\x8C\x38\x90\xE1\x9B\x48\x86\x9E\x30\x93\xDB\x96\x12\x59\x9D\x12\x75\xE3\x9F\x6B\xA8\x9A\x72\x6D\xE2\x9B\x77\xBD\x9D\x8F\x73\xE5\x97\x30\x97\x9E\x0D\x62\xDA\x93\x75\xAC\x9D\x55\x9E\x43\x0B\x78\x80\x00\x92\x9F\x1E\x9A\x10\x33\x9E\x74\x9C\x56\x95\x68\xB3\x9A\x87\x98\x23\x65\x7B\x8D\x60\xA8\x9F\x25\x7A\x7A\x85\x66\xAC\x9D\x61\x6A\x79\x90\x9D\xB6\x9E\x41\x0D\x76\x9D\x9E\x88\x9F\xE7\x9F\x73\xA1\x9E\x7C\x9A\xE3\x9E\x67\x91\x9B\xBE\x9D\x0E\x71\x7C\xBC\x85\xC3\x9F\x01\x95\x7C\x87\x90\xC7\x9C\x2E\x9B\x48\x8B\x9F\x0B\x92\xE7\x98\x75\x8F\x9F\x41\x9E\xE8\x93\x69\x8F\x9E\xD4\x9D\xE4\x96\x7D\x95\x9E\x4B\x8D\x41\x0B\x7D\x99\x9E\x6B\x9E\x43\x00\x7E\x8A\x8B\xE2\x9E\xD1\x90\x7A\xA5\x9F\xD1\x9F\xE8\x97\x6D\x82\x9B\xEA\x9E\xCB\x9C\x7E\x8C\x9D\x0E\x07\xFB\x9B\x48\x9D\x9F\xC9\x9C\xF2\x93\x7F\xB2\x8B\xF5\x9D\x41\x05\x7B\x89",
			"\xA0\x8C\x9D\xFE\x97\x7E\x93\x9F\x78\x9D\x1C\x6F\x7B\x92\x04\xD7\x9F\x8C\x89\x7D\xB8\x90\x02\xA0\xF2\x94\x80\x9F\x60\x9C\x9D\xF8\x9D\x7C\xA3\x9F\x71\x9C\xF4\x9C\x75\x8F\x9B\xE8\x9D\x04\xA5\x7D\xBE\x9F\x4A\x9E\xE5\x99\x76\x83\x9E\xF1\x9E\x42\x07\x80\xA4\x91\x0C\xA0\xED\x97\x7F\x82\x75\x23\xA2\xDD\x95\x82\x9C\x77\x79\x9F\xFA\x99\x82\xAD\x9F\x04\x05\x06\xAE\x7D\x85\x04\x1B\xA1\x61\x6F\x82\xBC\x62\x31\xA3\x02\xAF\x81\x9B\x9D\x43\x9D\xD7\x90\x81\xB8\xA0\x12\xA2\x0E\xA5\x76\xAA\xA0\x82\x9E\x43\x01\x84\x87\x90\x43\xA3\x0C\xA6\x7F\xA4\x9F\x34\xA1\x12\xA4\x82\x8B\xA1\xD8\x99\x13\xA8\x82\x8F\xA1\x3C\xA3\xCC\x9B\x82\x92\xA1\x2D\xA2\xF2\x91\x7B\xB7\x9E\xA6\x9F\x0F\xA1\xE0\x22\xA0\x5A\xA2\x0D\xAC\x85\xBC\x9F\x7B\x65\xEE\x98\x79\x86\x04\x15\xA1\x27\x97\x81\x8B\x92\x3E\xA1\x01\xA1\x75\xA5\xA1\x05\x05\x15\xA8\x85\x97\xA1\x21\xA0\xFE\x95\x83\xB7\x5E\x75\x98\x00\x02\x87\x80\x9F\xFF\x9D\xB7\x81\x78\xAB\x9A\xAE\x9D\xE1\x90\x7B\x87\x9E\xB2\x9D\x1A\xAA\x87\x80\x00\xB8\x9E\xF9\x97\x6A\xBB\x9F\x45\x66\x20\xA2\x76\x94\x9E\x3B\xA0\x00",
			"\xAA\x10\x39\xA1\x8D\xA3\xE6\x9F\x88\x8C\x9F\x91\xA2\xF3\x91\x88\x99\xA1\x75\x9D\x61\x97\x77\x8C\xA1\x9E\x67\x21\xA4\x81\x89\xA2\x67\x9D\x00\xA3\x86\x8A\x04\x53\xA0\x0E\x9E\x87\xA7\xA2\x80\xA2\xE2\x9C\x86\xA9\xA2\x32\x98\x26\xAC\x69\x9A\xA2\xA7\x9C\x2C\xA0\x78\xB2\xA2\x51\xA0\x2D\xAC\x87\x84\x04\xB7\xA2\x2E\xA6\x8A\x8A\xA3\xA8\xA2\xEE\x9A\x84\x88\x9B\x90\x9D\x1C\xAE\x84\xBE\x9D\x50\xA0\x23\xAC\x82\xAF\x9E\xF2\x9F\x19\xA6\x10\x33\x9E\x46\xA1\x29\xAD\x8C\xBD\x97\xCF\xA0\xEF\x9F\x75\x96\x65\xAE\xA2\x43\x05\x87\x9A\x99\x77\xA0\xF2\x90\x8A\x97\xA3\x8E\xA1\x36\xA0\x89\xA8\xA1\xCB\xA0\xF2\x95\x89\x8E\xA0\x97\xA2\x61\x9D\x85\xAD\xA2\xD3\xA1\xEA\x95\x8D\x9B\xA2\xA1\xA0\xF2\x9D\x81\xB4\x9F\x47\xA2\x02\xA6\x85\xB3\x9D\x96\xA1\xAE\x94\x7A\x8E\x9A\xBB\xA3\xE4\x97\x8E\x8A\x96\x3D\xA3\x3E\xAB\x77\xBD\xA3\x6A\xA3\x24\xA9\x8C\xB2\xA3\x92\xA1\x0C\xA2\x87\xBB\x98\xEA\x8A\xEA\x88\x8F\x9F\xA1\xD4\xA1\x18\xAB\x8E\xA4\xA1\xD8\xA2\x0B\xAA\x8D\x85\x04\xDC\xA3\x40\xAD\x80\x83\xA2\xBD\xA2\x3D\xA0\x87\xA4\xA3\xF9\xA2\xF0\x9E\x90\x93\x9E",
			"\x10\xA7\x24\xAF\x8F\x88\xA0\x01\xA4\x41\x0D\x8D\xB0\xA3\xDF\xA0\x46\xA9\x3A\x9A\x8E\x8D\x65\x39\xAA\x10\x0B\xA4\x94\x97\x27\xAF\x92\xB3\xA1\x1A\xA3\x31\xA0\x00\x13\xA4\x11\xA5\x49\xAF\x87\x84\xA4\xF4\xA2\x41\xAE\x8B\xBB\x9A\xC0\xA2\x42\xA2\x8C\xBB\x8B\x8B\xA0\x3F\xAC\x8E\xA2\xA2\xEE\xA0\x29\xA8\x93\xB9\xA2\x14\xA5\x54\xA0\x8E\x9B\xA1\xD0\xA1\xFA\x92\x8D\x9C\xA4\xFA\xA2\x47\xA3\x8B\x86\x04\xB5\xA3\xF7\x93\x92\xAB\xA1\xF1\xA1\x52\xA9\x90\x9F\xA5\x6E\xA1\x58\xA6\x82\xBD\xA4\x2D\xA4\xF6\x93\x94\xAD\x9E\x57\xA6\x3F\xA3\x8A\x9E\xA0\xDE\xA0\x57\xAE\x96\x9E\xA5\x3A\xA4\x2F\x9B\x8F\x6B\x05\x0A\x02\x16\x88\x10\x10\x63\x7E\x74\x44\x09\x71\xA9\x9C\x17\x9D\xC4\x9D\x1D\x93\x9C\x8E\xA6\x31\x9D\x6E\x8F\x9C\x90\xA7\x64\xAC\x71\x93\x97\x16\x9F\xC6\x91\x99\xAC\x9B\xBB\x97\xBA\x91\x3E\x96\xA6\x9B\xA7\x67\xA9\x99\x9D\x97\x4F\x0A\xC8\x9C\x98\x9A\xA6\xA0\xA5\x6A\xA3\x9A\xA4\x9C\xA7\xA4\x66\x8F\xD9\x57\x8F\x74\x99\x0E\x70\x48\x94\x04\xED\x85\x12\x9E\x4B\xA7\x99\x67\x93\x6C\xA0\x11\x01\xA6\xF4\x94\xB6\x8A\x9B\x8C\x04\xBC\xA5\x98\x9B",
			"\x55\xBF\xA6\x08\x05\x70\xA0\x4B\x91\x95\xC4\xA6\x40\x06\x9C\xBF\x95\xB9\xA7\x5A\x0B\x9C\xAD\x99\xC3\xA6\x73\xA8\x9B\x88\xA7\xD2\xA4\x9B\x97\x24\x94\x79\xC9\xA5\x40\x0F\x9C\x97\xA7\x0F\x89\x76\xA0\x10\x1B\xA7\x22\x8D\x2E\x97\x9B\x96\xA7\xE1\xA7\x28\x93\x9E\xA0\x99\xC7\xA5\x74\xA7\x9E\xA9\x98\x19\xA6\x6F\xA5\x9D\xA8\xA7\xCC\xA6\x9B\x94\x89\x4B\x9B\x7C\x85\xB3\x9E\x8C\x9B\x5F\x45\x9E\x8D\x85\x39\x9E\x9A\xB5\x8D\x95\x9A\x92\xA0\x76\x0B\x88\xAB\x95\x6C\xA7\x8E\xEC\xA7\x4E\xA1\x3C\xB3\xA7\x97\x98\xB3\x9E\x6D\xAB\x8D\x08\xAA\x80\x8B\x6D\x9D\x9B\xD5\x9B\xB7\x91\xBA\x7C\x9A\xB7\x9A\xAF\x9F\x80\xB2\xA5\xAC\xA1\x83\xAA\x6D\x83\xA8\xBE\x8F\xB1\x92\x8E\x91\xA3\x1C\x6C\x7D\xA0\x36\x8B\xA8\x8D\x9B\xDF\x64\xA1\x94\x9B\x16\xA9\x3D\xAB\x8A\xB7\xA3\x1A\xAB\x26\xAF\xA0\xBC\x8E\x24\xA8\xB0\x9D\xA2\xBA\xA7\x02\xA8\x7F\xAB\x3C\xA1\xA3\x4C\x98\xAD\x91\x87\x62\xA8\x9D\x92\x7D\xA0\x97\xAA\xA2\x37\xA0\x8B\xA6\xA2\x93\x9B\x0A\xA9\x84\xAC\xA0\x83\xA9\x01\xAB\x8B\xAA\x67\xB1\xA8\x07\xA4\x92\xA4\x21\xB5\xA8\xBD\x99\x7F\xAD\x67\x98\xA8\xDF",
			"\x95\x6B\xAC\x9A\x94\xA6\x09\x9F\x65\xA8\x5D\xAB\xA6\x26\x9C\x96\xA8\x72\x9E\xA9\xFB\x98\x98\xAD\x98\xAA\xA6\x1E\x9D\x98\xA8\x71\xBE\x9B\xE2\x86\x98\xA8\x9A\x9C\xA9\x56\xA9\x97\xAE\x5D\xA6\xA6\x6A\xA8\x69\xA4\xA6\xA3\x9B\x95\xA4\x9B\xA1\xA7\xA6\x97\x12\x06\x70\x73\x23\xB5\x02\xF0\x7F\x45\x9E\x10\x3A\xA9\x9D\x90\x9F\xAE\xF3\x70\xA7\xD0\xA7\x48\x90\xA8\x9A\x99\x82\xA8\xEE\x70\x9E\x90\x83\x87\xA8\x43\xA0\x00\x09\xAA\x2A\x83\xA2\xA0\xE2\x4D\xAA\x41\xA6\x41\x00\xA9\x82\x81\x92\xA8\x95\x74\xA9\xB9\x99\x0A\x07\xA5\xA4\x08\x99\xAA\x0F\x8B\xA6\xAE\x6A\x92\x04\x9E\xA8\x41\x80\xAA\x98\x8B\xA2\xA8\xB7\x94\xAA\xBD\xA9\xB2\x99\x8E\xA6\xA8\xA5\x66\xA5\xAA\xE7\x57\xAA\xA7\x91\xA9\xAB\x07\x61\xAB\x85\xA4\xD6\x9B\x7F\xA8\x09\xB5\xAA\xAB\xAB\xA0\xA5\xA0\x82\xA6\xA1\xA8\xAC\xAC\xAA\xBB\x9E\xAE\xA8\x80\x9E\x96\x5C\x68\xB7\xA9\x53\xA9\xAB\xAB\xA8\x21\x9B\x64\x68\xAC\x49\xAB\x28\xA6\x7F\xAC\xAC\xB9\x70\xBC\xAA\x43\x00\xAD\xAD\xA1\x40\xAB\x1B\xA6\x98\x87\xA7\x97\x81\xBC\x95\xA6\xA3\xA9\x76\xAA\x96\xA9\x6F\xAD\xA9\xE4\xAB\x9D\xAE\xA6",
			"\xA1\xA6\x05\x95\xB8\xA8\xAE\xBD\x96\xE2\xA8\x4B\x8E\x10\x07\x77\x33\x8A\x2D\x03\xAC\x8B\x63\x0D\x60\xBC\xAD\x49\xB2\xAB\xBE\xAA\x90\x9A\x60\xA7\x91\xF6\xAA\x96\x98\xAF\x8A\xAA\xD3\xA7\x56\x9D\xAF\x8E\xAA\xFF\xA9\xA4\xA1\xB0\xA3\x94\x03\xAD\xA5\xA5\x10\x05\xAC\x98\xAB\xC1\xA6\xAC\xA1\x65\xA5\x64\xC3\xAF\xA9\x8E\xAC\x26\x90\x7F\x71\xB1\xB3\xAB\x60\xA7\x87\xA6\x47\xB8\x76\x17\xAD\xBE\xAB\x64\xBB\xAB\x51\x95\xC2\xAC\xA9\x86\x04\x12\xAE\xA9\xA4\xB1\x9B\xAC\xD7\x74\x87\x65\xB2\xB2\xAA\x27\xAF\x51\x99\xB2\x88\x6B\x2B\xAC\xAE\xA2\xA1\xAB\x9A\x22\xAF\xA8\xAE\x10\x31\xAC\xCA\xAB\xCC\xAB\x89\xB5\xAC\xAA\xAB\xCD\xA8\xB1\xB1\xA5\x1A\xAE\xCB\xA0\xB1\xAA\xAC\x3F\xAD\xB6\xA4\xA5\x8D\xAB\x2F\xAD\x14\x78\xB3\x91\xAB\x53\xA9\xD0\xAD\x1B\x2F\xA6\x89\xA4\xD7\x8E\x99\xA9\xAB\xDF\xAB\x9A\xA5\xB5\xAE\xA6\x6B\x07\x62\xA6\xAE\xA5\xAB\xED\xAB\xC2\x93\xA7\x8D\x9C\x59\xAB\xBA\xA7\x26\xA2\xAD\x69\x8B\x99\xA3\xB5\xAC\xAB\x64\xAD\xB8\x9F\xB5\x92\x9C\x61\xAE\x78\x00\xA7\x9D\xAD\x10\x9F\xDA\xAF\x98\xAD\xAD\xEA\xAA\xDC\xA2\x99\xB5\xAD\x78\xAF",
			"\xD5\xA7\xA5\x9A\xA9\xF3\x06\xD6\xA0\xB7\xB5\xA9\x7A\xAF\xB9\xA6\xB7\x9C\xA6\x81\xAC\xD7\xA9\xB6\xA9\x9B\x87\xAE\x62\xA8\xA6\xA4\x8F\x86\xAF\xE0\xA2\x9A\x85\xAE\x5B\xAC\xAD\x8F\xB6\x89\xAE\xFF\x99\xE3\xA9\xB7\xB4\xA9\x74\xAC\xE4\xAF\xB7\x99\xAE\x98\xAF\x97\xAB\xB9\x9E\xAE\x94\xAD\x9A\xAF\xB9\xA6\xA9\xA1\xAC\xE3\xA1\xB9\xA3\xAE\xE0\xAA\xE6\xA5\xBA\x81\x04\x7E\xAF\xEA\xAD\x4C\xA7\xAE\xAE\xAD\x95\xA0\xBB\xAE\xAD\x8B\xAF\x30\x98\xBA\x96\xAD\x9D\xAC\xE9\xAE\xB8\x94\xAD\xBF\x5D\x16\x80\x9B\x9A\x99\x0D\x60\x9E\x1C\x17\xAB\x00\x5E\x94\xF1\xA1\x86\x86\xAF\xAB\x99\x6D\xAE\x10\x02\xAF\x33\x88\xF2\xA4\x66\x84\x04\xCE\xAD\x2C\xAA\x10\x11\xAF\x93\x9F\xAC\xA1\x55\x8C\xAF\x9D\x90\xF5\xA8\x63\x8E\x04\xDA\xAF\xC1\x8A\xBD\xA0\x8C\xE4\xA4\x34\x88\xBD\x9A\x99\xDA\xAC\x92\x90\xBD\xB2\x9C\xDF\xAE\xCC\xA7\xA4\x84\xA5\x04\x07\xF8\xAE\xA8\xA5\xAF\x85\x65\xF7\xA1\xBF\x8D\x8D\x1E\xA9\xB1\xA5\xB1\x86\x04\xEE\xAE\xC2\xA7\xBE\xAD\x98\x00\x02\xFC\xA7\x40\xA9\xAF\x39\xAF\xFA\xA1\xBC\xA5\x66\xF0\xAF\xFF\xA8\xBE\xB4\xAF\xAD\xA8\xC8\xAB\x55\xB9",
			"\xAF\x23\xAD\x41\x05\xC0\xB8\x90\xFE\xAC\x04\xB8\xC0\x84\xAB\x0A\xB3\x48\x9C\xC0\xB6\xAC\xD3\xAD\xF1\xA7\xC0\x86\x8D\xFA\xA8\x8F\x97\x46\x97\xB0\x3D\xAD\x06\xBC\xBF\x91\xB0\x8B\x90\x00\xBC\xB4\x92\x9F\x47\xAD\x0E\x70\xC2\x9F\x60\x0F\xB1\x09\xBB\xC1\x89\xAF\x2D\xAF\x95\x93\x66\x04\xB0\x1A\xB3\xF1\xA3\xC1\xB8\xA8\x15\xB3\xC3\xA3\xC3\x9C\x68\x2D\xB0\xF2\x94\xC2\xBE\xB0\x37\xB1\xC6\xA6\xBF\xA8\xAC\xED\xAC\x0D\xB3\xC2\xAF\xB0\x9B\xA2\xF5\xAB\xC0\x86\xB1\x3F\x9A\x03\xB8\xC4\xBB\x9D\x4A\xB3\x69\x99\xB5\xB5\xAE\xAF\xAF\xED\xA8\xB5\xA9\x05\x53\x8D\x14\x73\xAE\x97\x97\x7D\xAC\x15\xB2\xBB\x96\xB1\x7B\xAD\xEC\xA6\x6E\xA2\xB1\x5E\xB3\x18\xBB\xBB\xA8\xAD\x67\xB2\x70\x0D\xBA\xA9\xB1\x65\xAC\x19\xB7\xB6\xA3\xAD\x6C\xB0\xDC\x75\xC6\xB3\xB1\x6F\xB1\x1B\xB1\xC7\x88\xAE\x77\xB3\xBD\x9A\xA5\x8D\x60\x22\x01\x69\x64\xBE\x51\x79\xAC\x68\x1F\xBE\xC7\xA1\x81\x40\xAF\x10\xB2\xB4\x80\x00\x7D\xB0\x87\x6F\xC7\x99\x79\x84\xA8\x77\xA8\x2D\x89\xB2\xC8\x6B\x22\xB0\xE6\x61\xAF\x20\x78\x24\xB1\xC5\x52\xB2\x56\x65\x14\xBA\xC3\x96\xB2\x8F\x70\x26",
			"\xB6\x11\x1A\xB2\xF7\xAD\x41\x0C\xC9\x97\x72\x9E\xB2\xFA\xA5\xA2\xAC\xAF\x88\xB3\x20\xB1\xE4\x49\xB0\x1E\xB1\x54\x93\xCA\xBC\x85\xA5\xB1\x00\xB7\xCA\x82\xB2\x8A\xB0\x21\xB6\xB4\x8E\xAD\x47\x86\x41\x0F\xCA\xB3\x88\xB1\xB3\x09\xBA\x7F\xBA\xAA\xAB\x9B\x2E\xBD\x49\xBD\xB2\xD8\xA9\x4A\xA3\xAD\x98\x82\xC2\xB2\x96\x94\xCC\xBC\xA2\xD2\xA9\x90\xA8\xB4\x84\x04\xC9\xB2\xA3\xAB\xCC\xB7\xA7\x85\xB1\x0E\xB1\xCA\x90\xB3\xAA\xB1\x92\x7D\xC1\xAD\xA7\x67\x91\x0B\x05\x9A\x5B\x01\xB6\xB2\x4C\x8E\x10\x1E\xB3\x1C\x68\x38\xBB\xCA\x94\xB0\xAD\xB3\x56\x94\xCE\x88\x6B\xE6\xB2\x36\xBF\xB1\xA9\xB3\x23\x97\x3A\xB1\xC5\x6D\xB3\x80\xB3\x36\xB6\xA0\x91\x95\xF2\xB3\x23\x74\xCF\x8C\xB2\xBF\xA9\x6F\xAD\xCD\x9F\xB3\xE1\xB1\x33\xBA\xAD\x98\x82\xF9\xB3\x25\x7B\xCF\x93\xB2\x8D\xB1\x79\xA5\x10\x05\xB4\x7C\x87\x41\xB9\xC9\xB1\xB0\xB9\xB3\x42\xB0\xD0\xA7\xB3\x38\xB0\x3C\xBA\xC3\x8C\xB4\x33\x8A\x43\xBF\xC9\x90\xB4\xCF\xB0\x00\x08\xD1\x9D\x92\x1A\xB6\x29\xB2\xA3\x93\x9E\x1F\xB6\x96\x91\xD2\xB2\xB2\x23\xB4\x2A\xB5\xD2\x8E\xAA\x27\xB6\x2F\xB7\xA1\xB8\xB2",
			"\x1D\xB7\x4A\xBA\xBF\x80\x00\x2D\xB5\x31\xB2\xD0\xA9\xB0\x04\xB7\x44\xBE\xCE\xA5\x91\x86\xB2\x0C\xB8\x04\x25\x66\x8A\x01\x40\xB0\x11\x0D\x60\x3F\xB4\x87\x61\xD4\x94\xB4\x42\xB2\x35\xB4\xC4\x80\x00\x45\xB4\xB2\x67\xD4\xBB\xB4\xF5\xAE\x52\xB7\xC8\x8D\xB5\x51\x73\x53\xB5\xCF\xAF\xB3\xDC\xB1\x54\x94\xD5\x8F\x72\x56\xB4\x3F\xB6\xCF\x80\xAB\xD8\x8B\x56\xB7\xC9\x5D\xB5\x08\xB5\x3F\xB2\x9C\xA3\x94\x62\xB4\x5F\x84\xD6\x8F\xB4\x94\xB0\x95\x79\xD6\xB3\x88\x6B\xB7\x46\xBD\xD6\x8F\x88\x6F\xB5\x27\x91\xD7\xA2\xB4\x4D\xA8\x2A\xB5\xD7\x9A\x99\x77\xB4\x4A\xB9\xD7\x84\xB5\x40\xB6\x50\xB8\xC2\xB0\xB4\x39\x73\x5E\xBE\xA8\xBD\xB5\x2E\xB6\x8A\xAE\xCC\x85\xB6\x81\xB4\x52\xB5\xCD\x96\xB4\xD7\xB0\x53\xBD\xD8\x90\xB5\xAC\xB1\x56\xBB\x55\x86\xB6\x33\xB4\x62\xB6\xD3\x8D\xAD\x3D\xB5\x44\xB4\x10\x02\x01\xA5\x66\x1F\x02\xD8\x91\x74\x0E\x04\x68\xBC\xA1\x62\xB6\x8E\xB7\x2D\xBD\xD9\x9D\xB4\xA6\xB4\xB2\x68\xDA\x94\xB6\xE8\xB2\x65\xB3\x52\xAD\xB6\x51\x73\x6B\xB7\xD5\xBC\xB4\x52\xB6\x0C\xB4\xDB\x8F\x72\xB6\xB6\x57\xB8\xD5\xB7\xB3\x5B\x97\x6E\xB7",
			"\xC9\x7D\xB6\x65\xB7\x57\xBE\xCF\x91\x95\xC2\xB4\x5F\x84\xDC\xAC\xB5\x09\xB4\x34\x89\xDC\xB3\x88\xCB\xB6\x5C\xBD\xDC\xA0\x78\xCF\xB5\x27\x91\xDD\xB8\xB5\x4F\xA7\x26\xA5\xDD\x9A\x99\xD7\xB6\x5F\xB9\xDD\xBB\x9D\xDB\xB6\xA3\xAD\xDD\x89\xB6\x4E\xA4\x30\xBA\xDD\xA1\xB6\xA3\xB7\x4B\xBB\xDA\xB9\x70\xE1\xB7\x4C\xB3\xDE\x9B\xB6\x83\xB7\x7A\xB8\x09\xAD\xB7\x0D\xB0\x41\x0F\xDE\x8C\xB3\x9C\xB5\x6E\xBE\xD9\x80\x00\xF4\xB4\x06\xB6\x10\x37\xB7\xD4\xB2\x6A\xBA\xDF\x9D\xB4\x57\x01\x69\x62\x0A\x29\xB7\x01\x05\x03\x65\xE0\x9C\x68\x07\xB9\x6A\xB6\xCC\x8B\xB6\x98\x83\x82\xB8\xAC\x4D\xB8\xB0\xB5\x45\xB2\xDB\xBA\xB0\x12\xB9\x14\x74\xE1\xB7\xB6\x51\xB4\x64\xBB\xD4\x99\xB8\x8F\x73\x86\xBE\xDB\xB8\xB6\x1E\xBB\x21\xB0\xE2\x97\x72\x22\xB9\x71\xBF\xDB\xA0\xB5\x67\x93\x89\xBC\x17\xA9\xB8\xCC\xB6\x59\xB9\x9E\xA3\x94\x2E\xBB\x8C\x80\xE3\x92\xB7\x32\xB9\x7C\xAB\x55\xB5\xB8\x9D\x93\x8D\xB8\xDD\xA6\xB7\x7B\x9C\x8F\xBA\x65\xBE\xB8\xDE\xB4\x90\xB3\x79\x82\xB9\x8E\xA8\x91\xB4\xDE\x8B\xAB\x10\xBB\xAA\x98\xE4\xB3\xB4\x4A\xB8\x7C\xBF\xCB\x87\xB3\x4E",
			"\xBA\x81\xB8\xE0\xA5\xB7\x54\xBB\x26\xAF\xE4\xB5\xB7\x00\x01\x94\xB8\xDF\xB1\xB7\x03\xB9\x0E\x7B\xE5\xBE\xB7\x8A\x07\x95\xBC\xE4\x83\xB4\xDE\xA9\xEE\xA9\xBA\xAA\xB9\xB8\xAC\xD8\xAE\x19\x8A\x93\x5B\xB0\x18\xB2\xB8\x97\xAE\x6E\xBA\xEE\xA4\xE7\xAC\xAD\xA0\xAD\x1E\xB3\x1D\xA9\xB9\x75\xBB\x9A\xBD\xE7\xAD\xB9\x78\xBA\x9D\xB2\x22\x13\xAE\x7A\xBA\xE8\xAE\xC6\xBC\xB9\x81\xBA\x9F\xB9\xE8\x83\x84\x50\xAD\x6A\x9A\x65\xB1\xB9\x87\xB9\xC5\x9A\xBA\x85\xBA\xA6\xAE\x9C\xB6\xB9\x93\xBA\x77\xBB\xDC\xA9\xE7\x99\xBA\x77\xAC\xA6\xBE\xE9\x93\x08\x6B\xB0\xA7\xB4\xB8\xAC\xB9\x72\xAA\xA8\xBF\xB8\x93\x08\x84\xBA\xA9\xBC\xBB\xBF\xB9\xA5\xBB\xA7\xBC\xEA\xA1\xB1\xC9\x92\xEF\xA1\xB5\x8E\xAA\x0D\x60\x62\xA1\xC5\x42\xAF\x85\x7D\x41\x0C\x18\x14\xA5\x0E\x07\xAE\xB0\xBE\x9D\x73\x23\x45\x69\x68\xEB\x85\x66\xBB\xBB\xC1\x8E\xEB\xBF\xB8\x59\xBB\xDE\x96\xEB\x8F\x72\xC3\xBB\x01\x95\xEC\x84\xBB\x41\xB3\x63\xB7\xE1\x91\xB6\xCB\xBB\x25\x7D\xEC\xB8\x90\xCF\xBA\xB3\xB1\xED\x82\xB8\x25\xBA\x0C\xB5\xED\xBC\x85\xD7\xBB\x22\x99\xED\x98\xBB\xDB\xBB\x83\xB8\xE6",
			"\x9B\xA2\xDF\xBB\x8C\x81\xEE\x88\x9F\xE3\xBA\xB8\xB5\xEE\xB7\xB4\x84\xB4\x26\x89\xEE\x9D\x92\xEB\xB9\x44\xAD\xEE\xAC\xBB\xEF\xB9\x7E\xBD\xED\xBB\xB7\xF3\xBA\x96\x95\xEF\x93\xA2\xF7\xBA\xBD\xB9\xEF\xA0\xB9\xFB\xB9\x47\xBD\xEF\x8E\xAA\xFF\xBB\x07\x61\xF0\x80\xBC\x03\xBF\x94\xBD\xE4\xA8\xBB\xC2\xBB\xCE\x70\x00\x0B\xBC\x0A\xBD\xC3\xBA\xDE\xA1\xB9\xF2\xB9\xC4\xBB\xDE\x46\x04\x14\xBE\x44\x07\xEC\x85\xB9\xC9\xBB\xE4\x97\xF0\xB3\xB4\x09\xBE\xC7\xB2\x73\x9F\xBC\x4B\xBA\xCE\xAA\xEC\x9A\xBC\x20\x76\xC9\xB1\x86\xA8\xBC\x52\xBB\xC5\xB5\xF0\xB9\x70\x23\xBC\x97\xB5\xF2\xBD\xBA\x27\xBE\xC5\xBA\xD8\xA7\xBB\x2B\xBC\x87\x67\xF3\xAF\x59\x39\xBC\x07\xBB\xE2\x87\xB7\x78\xB2\xAA\xB8\xC6\x86\xBD\x70\xB0\xD2\xB6\xC7\x8A\xBD\x6A\xAC\xD3\xB5\xF4\xAE\xBA\x8B\xB9\xAB\xB4\xEA\xB0\xBA\x4E\xBE\xE2\xA5\xC7\x8D\xBD\x50\xBE\xA6\xB2\xE8\x93\xBD\x73\xBB\xA0\xB4\xC7\x88\xBA\x5A\xBE\xA2\xB1\xF6\x80\xBA\x63\xBE\xD4\xBC\x2C\x33\x07\xB5\x9C\x9C\xB3\x70\x9C\xBD\x97\xB8\xDB\xB3\xBB\x95\xBD\x95\xAF\xDB\xB9\xF5\x9D\xBA\x6E\xBE\xA5\xB2\xF7\xB5\xBD\x91\xB9",
			"\xC7\x90\xEA\x9F\xBD\x92\xB8\xDE\xB4\xE9\xB6\xAE\x79\xBC\x66\xAE\xF5\x97\xBD\x4F\xBE\xDF\xB0\xF7\x86\xBA\x7F\xBD\x15\xB1\xF8\x90\x88\xBB\xA7\xB6\xA1\x10\x35\x9E\x90\xB9\xE2\xBF\xC5\x8B\xBE\x91\xBF\xE1\xB5\xE9\x94\xBE\x6B\xBF\xAB\xBD\xF5\x86\xBE\x73\xBF\xA8\xB9\x22\x21\xBA\x9D\xBF\xA9\xBA\xF9\xAD\xBD\xA3\xBF\xDD\xB9\x22\x29\xBA\xA1\xBF\xAA\xB1\xF5\x94\xBD\xA9\xBF\xD1\xBD\xFA\x90\x8D\xEB\xA7\x96\x82\x10\x35\x9E\x85\xA1\x61\xA8\x09\x80\x01\xA5\x64\x1F\x02\xF1\xB9\x01\x67\xA5\x41\x08\x07\x23\x91\x1F\x63\xEF\xB2\x8C\x45\x66\x7B\x02\x44\x06\xFB\x8B\xB9\xB5\xBD\x0E\x78\xFB\x9C\x68\xBA\xBF\xC6\xB5\x10\x3C\xBE\xC5\xA2\x41\x02\xFC\xA2\x90\x38\x93\xF4\xB6\x10\x1F\xBB\x1F\x61\xF1\xBE\x10\x07\xBF\x31\xBF\xCE\xB8\xD3\x90\xA5\x29\x46\xF2\xB9\xFB\xBB\xBE\xBD\xBC\x41\x06\xFD\x98\x91\xD5\xBD\xB0\xB7\x40\x9A\xBF\xE1\xBC\xC8\xBF\xF0\x88\xA4\xDB\xBE\xF8\xBC\xFC\xA4\xBF\xD1\xBE\xEF\xB0\xFC\x92\x04\xE7\xBC\x41\x08\xFD\x92\x04\xEC\xBE\x41\x0C\xFD\x9F\xB9\x0E\xBC\xCF\xBD\x9B\x56\x04\xFF\xBF\xE4\x9B\xFC\x88\x6B\xCD\xBD\xCB\xBE\x10\x10",
			"\xBF\xD6\xA2\x43\x09\xFF\x81\x92\x85\x67\x03\xCB\xFF\x8E\x04\xFD\xBD\x41\x05\x00\xFF\xA8\xE6\xBB\xF7\xB1\x6C\x86\xBF\xF2\xBC\x02\xC4\xFF\x8D\xC0\x0A\x07\x03\xCF\xEC\x41\xBF\xEA\xBC\x0E\x95\x01\xC4\x04\x17\xC0\x28\xB2\x96\x96\x65\x17\xC1\x03\x67\x00\xD1\x71\x09\xC2\x67\x6F\x81\x4C\xC0\x56\xA6\x03\xC7\xFF\xB6\xC0\xC3\xBF\xFA\xBC\x01\xEE\xBF\x02\xC0\xC7\x64\x00\xDD\xC0\x30\xC3\x07\xC5\x03\xE1\xC0\x37\xC0\x11\xC9\x03\xE6\xC0\x3B\xC1\xCA\xBB\xBE\x89\xBF\xB7\xBF\xF8\xBE\xFC\x84\x04\x34\xC3\x43\xA8\xFF\x85\xC1\xD2\xBD\x09\xCB\x48\xA7\xC0\x00\x01\x0A\xCC\xD1\x99\xA2\xED\xBF\xAA\x9F\x02\xCF\x72\x31\xC3\x69\x72\x11\x11\xC1\x30\xA7\x14\xC5\x41\x87\x90\x12\xC0\xF1\xB9\x04\xDD\xBF\x58\xBB\xFB\xB3\x00\xEB\xC1\x7B\x9F\x17\xC7\xC9\x61\xC1\xB4\x77\x18\xC5\xFE\x80\x00\x22\xC1\x04\xC6\x05\xC8\x9F\x58\xC2\x16\xC3\xD7\xBC\xA4\x7B\x65\x0B\xC2\x11\x32\xC1\x7C\x84\x1D\xC3\xDC\x76\xC1\xF5\xBE\xF9\xB4\x05\xF6\xBF\x47\xC3\x15\xC0\x07\xC1\xB8\x19\xC1\xBC\xB0\xFE\xBE\xBF\x40\xC0\x18\xC2\x04\xD2\xC1\x38\xC0\xF5\xBB\x48\xA9\xC1\x3A\xC1\xFC",
			"\xBC\x03\xDA\xC0\xF0\xBD\x17\xCB\x89\x84\xC2\x33\x8A\x21\xC9\xEB\x90\xC1\x77\xC1\x1E\xC8\x06\xFB\xC1\x11\xA5\x1F\xC8\xEC\xAE\xC1\x3E\xC3\x23\xC8\xCA\xA4\xC2\x9D\x92\x29\xC5\x98\x64\xC1\xA8\xB0\x09\xC7\x06\xE9\xBF\x8D\xC0\x1F\xC2\x0B\xEA\xC0\x3A\x6B\xF4\x8C\xF7\xBA\xBD\xA5\xBE\xDD\xB6\x0C\xD8\xBE\x5E\xAE\xE5\xB0\xF8\x92\xBE\x66\xB2\x32\xCA\xF8\x8C\xC3\xC3\xC2\xE0\xBB\xF7\x84\xBE\x7A\xB0\x32\xC1\xB7\x8E\xC3\x93\xBC\xED\xA4\x0D\xF1\xBD\xC7\xC0\x34\xCB\x0D\xC8\xBE\xD8\xC1\x33\xC2\x2C\x33\x07\x72\xA3\x7C\x0C\x8B\x55\xBE\xAF\xBF\xD2\xB9\x0E\xD8\xBD\x9C\xBD\x3B\xC5\x0C\xD6\xC3\x80\xAE\x3B\xCB\xFA\x9B\xBE\xEF\xC2\xE4\xB0\xFA\xB2\xC3\x65\xBC\xEB\xB8\x0F\xF4\xBD\xF5\xC3\x80\x08\xFA\xBB\xC3\x9E\xBF\x3C\xC4\xFA\x82\xC4\xA6\xBC\x41\xCC\xB7\xAB\x05\x69\xBF\x5A\x02\x87\xA8\xC3\x00\xC6\xE8\xB6\x10\xF0\xC3\x9C\xAD\x3F\xCB\x0E\xC5\xBE\x12\xC5\x43\xCA\xFA\xB9\xC3\xF4\xC3\x43\xC2\x1E\x37\xC3\x15\xC5\x47\xCA\x11\xE1\xC3\xD1\xC3\x96\xA3\xF8\xA0\xBD\xFC\xC3\x47\xC3\x11\xD5\xC3\xDE\xC0\x49\xC1\x10\xF8\x0B\x68\xBE\xE3\xB0\x10\x32\xA1",
			"\xF9\xA4\x41\x0C\x00\x15\xC2\x73\xC2\xC4\xBA\x07\x37\xC1\xB8\xC3\x08\xC6\x06\xCF\x63\x7A\xC2\x27\xC8\x04\xE5\x59\xB8\xA9\x4C\xC0\x00\x33\xC4\x4D\xC3\xFC\xBF\x04\xC0\x00\x37\xC5\x22\xC0\x00\x39\xC4\x3D\xC4\x4F\xCB\x0A\xFE\xC4\x8E\xC0\x50\xCF\x09\xD2\xC2\xA5\x9E\x54\xCE\x05\xCE\xC1\x0A\xC2\x42\x09\x14\xE0\xC0\x06\x04\x53\xCF\x14\xCE\xC5\xBC\xC2\x28\xCE\x0B\xD6\xC5\x6C\xC3\x99\xB0\x0A\xCE\xA9\x2F\x44\x4D\xC5\x08\xF6\xC4\x38\xC7\x22\xCA\x08\xFD\xC2\x11\xA7\x03\xC7\x01\xD9\xBF\x12\x04\x51\xCA\x04\xE7\xB2\x42\xC6\x5D\xC3\x0A\xD8\xC5\x32\xC2\x44\x0B\x15\xC3\xC1\x5D\xC6\x5B\xC8\x07\xEC\xC2\x93\xA2\x5C\xCA\x06\xE4\xC5\x00\xC2\xCC\xB3\xED\xAB\xC0\x92\x06\x5E\xC1\x07\xFC\xC5\x62\xC2\x43\x0F\x17\xD8\xC2\x0A\x06\x57\xC1\x16\xD7\xBF\x4D\xC4\x25\xCD\x09\xCA\x04\x8E\xC4\x24\xC0\xEF\xB2\xB7\x3B\xA9\x5D\xCA\x16\xE5\xC2\x6C\xC6\x52\xC6\x19\xDB\xC2\x84\xC6\x2E\xC2\x16\xED\xC2\xA2\xC7\x54\xC0\x1A\xD5\xC5\x9C\xC7\x68\xC5\x0B\xE5\xC6\x5C\xC7\xF3\xB2\x18\xDC\xC2\x97\xC6\x05\xC7\x18\xF1\xC6\xAE\xC4\xC6\xB1\x1A\xC8\xC6\x06\xC0\x64\xC5",
			"\x07\xD2\xC6\x6D\xC7\x2E\xC8\x1A\xF0\xC5\x85\xC6\x2C\xC4\x17\xC0\xC7\x18\xC3\x67\xCE\x1B\xF0\xC6\x06\x05\x67\xC3\x0B\xC2\xC7\x87\xC0\x71\xC6\x1A\xF7\xC6\xA9\xC7\x4E\xCA\x19\xFF\xC4\xBC\xC7\x5D\xC9\xD2\xB9\xC5\xB2\xC6\x96\x96\x0B\xC7\x90\x93\xC5\x19\xCB\x00\xD8\xC7\xC8\xC6\x6A\xCB\x1D\xD1\xC5\xDD\xC5\x59\xCA\xF2\xA8\xC5\x32\xC5\x78\xCE\xA8\xA3\xC7\x38\x91\x79\xC9\x0B\xC8\xC2\x9A\xC0\xF2\x98\x1B\xC7\xC7\xAB\xC7\x24\xA8\x05\xD2\xC7\xC0\xC1\x86\xAD\x9B\x52\xC7\x2E\xC0\x75\xC7\x0A\xC8\xC5\xC5\xC5\x7E\xC1\x17\xD9\xC7\x99\xC3\x7A\xC3\x16\xED\xC7\x89\xC6\xF7\xB4\x15\xF3\xA8\xF1\xC5\x51\xCE\x01\xC7\xC5\xF6\xC4\x5E\xA7\x1E\xC6\xC7\xFA\xC4\x83\xC6\x04\xFD\xC7\xCB\xC4\x84\xCE\x19\xFA\xBB\x8B\xC7\x5C\xA3\x20\xF2\xC7\x33\xB4\x7D\xCB\x48\x99\xC8\xB7\xC0\x7A\xC0\x16\xFC\xC7\x0E\xC8\x6B\xCC\x1C\xC1\xC8\xE3\x06\x32\x9D\xE8\xB2\xBE\xF1\xA6\xF5\x83\xEB\x93\x9A\x3A\xCB\x26\xA2\x03\x25\x66\x65\x02\xC4\xB4\x06\x05\xAD\xE2\xB2\x42\x0F\x23\xDC\x68\x41\xCB\x51\xC3\x24\xDE\xAC\x24\xB9\x89\xC2\xC3\x87\xC9\xC8\x69\x92\xC9\x15\xC6\x04\x4B",
			"\xC8\xC0\xAF\x07\xE7\x91\x50\xC9\x14\x72\x25\xFD\xC5\x0E\x05\x95\xC6\xB0\x97\xC9\x51\x95\x96\xCF\xC8\x5B\xC9\x91\xC6\x42\x0E\x25\xCD\xAC\x60\xCB\x56\x92\x26\xD7\x72\x64\xCB\x70\xC6\x26\xC4\xC9\xCE\xC7\xCC\xB8\x09\xAB\xC9\x7C\x85\x9B\xC5\x1D\xEF\xC9\x4C\xC9\x87\xBE\x24\xFB\xB7\x74\xCB\x8C\x86\x27\xC7\xC8\x67\xCB\xC4\xA9\x26\xE3\x94\x7D\xC9\x27\x9F\x27\xC5\x66\x81\xCA\xC9\xA3\x28\xFA\xB0\x85\xCA\x96\x97\x28\xC7\x90\x89\xC8\xCB\xAB\x28\xD1\xB6\x8D\xCA\xA3\xAF\x28\xF8\x90\x91\xCB\x2B\xCD\x03\xCD\x60\x95\xCB\x4C\xB7\x29\xCB\x92\x99\xC9\x6F\xC2\x27\xEB\x9A\x9D\xC8\x97\xBF\x29\xC8\x9F\xA1\xCA\x77\xCF\xD7\x92\x04\xA5\xC8\x99\xB4\x10\x27\xCA\x11\xA5\xAA\xCE\x1E\xC2\xB0\xAC\xC8\x90\xC2\x24\xF0\xC9\x24\xC8\x70\xB2\xC5\xAA\x79\x39\x73\x05\xC3\x23\x97\x00\x12\xBE\x95\x5A\x28\xC0\xBB\x50\xC7\x23\x70\x2C\xC7\xC5\xC2\xCA\xA4\xC3\xDD\x94\x79\xBE\xC9\x27\x97\x2C\xD3\xC9\x05\x05\xB2\xCA\x29\xE7\xC5\xA8\xB1\xB3\xCA\x65\x8F\xCB\x5C\xCA\x42\x02\x2D\xE2\xCA\x7B\xC9\x47\xB6\x2D\xCE\xAA\xD8\xC9\x99\xC6\x10\x1B\xCB\xAA\xCB\x77\xB3\x79",
			"\x9F\xCB\x33\xB5\xB8\xCE\x26\xE3\xCB\xB8\xC8\xC1\xBD\x2D\xFD\xCA\xA5\x66\xBA\xC7\x27\xEC\xCB\x79\xC9\x65\xBA\x2B\xFA\xB0\xE8\xC8\x97\xB2\x2F\xC7\xC8\xE4\xCB\xAC\xC3\xCB\xB2\xC2\xBF\xC9\xB0\xCD\x2E\xC1\xC0\xD4\xC9\x03\x69\x2F\xEE\xCA\x00\x03\xBE\xC5\x98\x7D\xCB\x11\xC9\x1B\xCB\x29\xC0\xCC\xCE\xCA\xC0\xC5\x2F\xF1\xB6\xF7\xC9\x64\xB7\x30\xE1\xB0\x06\x06\xC2\xC7\x40\x8C\xCC\x23\xCA\xBB\xC5\x31\xCB\xB5\x17\xCF\x07\x6A\x31\xF8\x90\x1C\xCD\x73\xC9\x2B\xEC\xB8\x51\x95\xC8\xC2\x11\x23\xCC\x8B\x91\xC9\xC4\x23\xDE\xCB\xF1\xCA\xC4\xC6\x25\xCB\xCB\xAE\xBE\x45\xC5\x33\xDE\xC4\x18\xC7\x40\xC9\x33\xC5\xC4\x3B\xCD\x37\xC0\x12\xDF\xC3\x97\xBD\x4A\xCD\xF7\xB8\xCC\x25\xC4\x94\x0C\x11\xE6\xC4\x36\xCD\xD2\xB7\x12\xDC\xC3\xB1\xAF\x3F\xC4\x34\xEB\xC4\x45\xCD\xD4\xC0\x35\xD3\xCD\x0E\xC4\xBE\x02\x14\xCD\x60\x58\xCD\x69\x62\x1D\xC7\xC8\x0E\x02\xCC\x97\xF9\x42\xBD\x01\x70\x7D\x7B\x6A\xB3\x88\x5B\xCD\x61\x6D\x35\xE1\xA1\x5F\xCC\x0C\xB3\x29\xCC\xC6\xE8\x75\x0E\x74\x36\xD2\xBC\x67\xCE\x27\xA6\x10\x29\xCD\x49\xB3\x16\xC3\xA1\x98\x82\x59\xCC",
			"\x87\x65\x36\xC7\x90\x71\xCE\x22\xAE\x10\x34\xCD\x50\xB2\xDD\xCF\x1B\xEB\x9A\x79\xCC\xB2\x6B\x37\xF8\x90\x7D\xCE\xF4\xA3\x37\xFA\xBC\x0E\xCC\xB5\xC7\x35\xED\xCD\x7A\xCC\xDC\xCE\x35\xCC\xCE\x66\xC7\x84\xC0\x1F\xE8\xB2\x85\xCD\x14\x77\x38\xCB\x92\x89\xCF\x30\xAA\x10\x00\xCE\xD5\xAE\xE0\xC0\x1D\xFB\x9D\x99\xCF\x23\x7B\x39\xC8\x9F\x9D\xCC\xAF\xBF\x39\xD4\xCE\xEF\xC5\x88\xA0\x39\xE3\xCD\x9D\x93\xE9\xC1\x91\xA9\xCE\x07\x8C\xE8\xC8\xCA\xAF\xCC\x00\xAB\x26\xA5\x3A\xD7\x72\xB2\xCF\x24\xA4\x3B\xC5\x66\xB6\xCF\xAF\xB9\xE3\x85\xAA\xE3\xA3\x6F\x7E\x36\xF1\xCE\x92\xCC\xDA\xCC\x3A\xCB\xC1\x62\xCF\x26\xAF\x36\xC7\xC5\xBF\xCF\x01\x91\x3C\xD3\xCB\x96\xCE\xEB\xC8\x37\xC7\xCF\x5A\x99\xEF\xCF\x81\x51\xCF\x38\x93\xF4\xCC\x2D\xDF\xCC\x26\xC9\x1F\x7A\x3B\xDA\xCD\xC9\xCE\xDC\xC5\x10\x1E\xCF\xE5\xCA\x91\xB6\x3D\xC4\xCE\xD8\xCE\xA3\xAA\x3D\xD2\x04\xDC\xCF\x22\x98\x3E\xFE\xCB\x29\xB7\x8D\xC7\x39\xFC\x5F\x0D\x63\x07\x05\x9A\x7C\x00\x12\xBD\x8D\x9F\x65\xAC\x6A\x42\xC4\xFE\xC2\x11\x3A\xCF\x1C\x68\xFF\xC7\x14\xFE\xCF\xD4\xCF\x6B\xC4\x21\xD3",
			"\x99\x98\x80\x01\xD8\xAC\x46\xD0\xD0\xC8\x96\x9A\x64\x8D\xC9\xE0\xCE\x80\xCA\xB2\x79\x70\x0E\xD1\x14\x70\x41\xD9\xCB\x01\x9B\x04\xDA\x27\xD5\xD0\x42\xAB\x05\xDD\x40\xFB\xCF\xFD\xCE\x07\xD6\x2F\xE8\xCC\x3A\xA8\x23\x62\x40\xCE\x04\x19\xD3\x23\x7B\x41\xE2\xCB\x05\x04\x02\xDF\x3D\xE8\xD0\xBD\x9C\x25\x6B\x42\xCA\x04\x2D\xD3\x25\x7F\x42\xEB\xCB\x31\xD2\x09\xD4\x31\xF4\xD0\xC5\xCD\x45\x99\x3F\xE4\xD0\x07\xD2\x0F\xD6\xE1\xA0\xD0\x2B\xA5\xC8\x6B\x6A\xB9\xD0\x7C\x87\x0E\xD3\x2F\xFD\xD0\x6B\x98\xCD\xC0\x08\xE2\xD0\x4B\xD0\x11\xD1\x41\xC0\x00\x32\xD1\xFA\xC1\xF2\xAB\xCF\x12\x9B\x26\xAC\x44\xF3\x88\x4E\xD3\x81\xC9\x45\xF4\xCF\x79\xB5\x00\xD8\x41\xD6\xD1\x1C\xD0\x14\xD8\x60\xA2\xCE\x0B\xD3\x0D\xD6\x10\x1F\xD1\x9D\x91\x18\xD5\x98\x63\xD1\x0D\xCD\xE5\xCA\x40\xF7\xCF\x67\xD1\x01\xD5\x42\xD1\xD1\xC3\xCE\x23\xB7\xA0\x8C\x6C\x79\xD3\x03\xDB\x47\xEB\xD1\x6B\xCD\x30\xCC\x2B\xC0\xCD\xCB\xC3\xCF\xCA\x12\xD5\xCD\x52\xCC\x23\xD4\x35\xD7\xC4\x8D\xD0\x24\xDF\x48\xF7\xCC\x48\xCF\xD3\xCE\x48\xCC\x72\x4A\xD3\x26\xA9\xDF\x57\x72\xB2\x02\xC4",
			"\xB4\x0B\x32\x9C\xB3\x02\x11\xD8\x9F\xAC\x61\x6E\xD1\x41\x0B\x49\xFC\x85\x9D\xD3\x51\xCF\x49\xE1\xA1\xA1\xD0\x1F\xD6\xDC\xA7\xB5\x41\xD0\x7F\x9D\x80\x67\xD2\x33\x89\x2A\xD7\x45\xEB\xD2\xE6\xCC\x41\x0D\x4A\xC4\xD2\x52\xD3\x1F\xD4\x45\xDA\xD2\xA5\x66\x2D\xD9\x46\xC4\x04\xB8\xD2\xDF\xCA\x10\x3B\xD2\x5D\xD1\x1D\xDD\x3A\xE6\xD1\x98\x80\x2D\xDD\x49\x82\xD3\x30\xD0\x31\xD0\x4A\xE2\xD2\xD2\xB8\x12\xD9\x3B\xDD\x98\xAB\x9A\x33\xDA\x65\x90\xD3\x3C\xD2\x34\xDC\x4A\xD4\xD3\xDC\xBB\xBB\xC7\x37\xEB\x94\xB3\xD1\x30\xDE\x49\xD3\xD3\xAE\xD3\xD0\xB0\x4B\xE0\xA8\x99\xD3\xDE\x9A\x4D\xCE\xAA\xDC\xD3\x13\xDE\x4D\xF9\xD2\x00\x00\x32\xD8\x4D\xE4\xD1\xE6\xC8\x17\xD7\x4F\xEE\xD3\xE6\xD2\x2A\xD8\x4E\xFC\xD2\x7D\xD3\x1E\x71\x88\x65\xD2\x04\x07\x3B\xD3\xD3\xB1\xD3\x07\xC9\x31\xDA\x38\xC5\x04\xF6\xD0\x8C\x93\x43\xC4\xBD\x35\xD0\x20\xDD\x4C\xFD\xD3\xB7\xD3\x3F\xD9\x4C\xDD\xCC\x04\xCD\xF5\xCC\x4C\xD9\xD3\x14\xD7\x30\xD0\x00\x0A\xD4\x9E\xCE\x41\x0D\x50\xCC\xD0\x5A\xD0\x2C\xCB\x51\xC0\xD3\x1C\x68\x42\xD5\x98\x60\xD4\xAA\xCE\x48\xD0\x4E\xD1\xC2",
			"\x77\xD2\x3E\xDE\x50\xDC\xD4\x29\xD7\x39\xDF\x4D\xE9\xD3\x14\xD0\x10\xDC\x4E\xC2\xD1\x95\x65\x4D\xDE\x4F\xF7\xD4\x00\xD7\x2B\xD3\xE3\xA3\xA3\x04\xD4\x2A\xB9\x28\xF3\x88\xB7\x02\xC4\xB8\x0B\x14\xCE\xED\xD3\xE4\x9D\x80\x47\xD5\x9D\x91\x52\xD7\x14\xCB\xD5\x60\xCF\x07\xDA\x53\xEB\xC0\x45\xD7\x53\xD5\x9A\x52\xD5\x57\xD0\x55\xDA\x36\xFD\xD2\xF2\xA7\x4C\xD3\x3E\xDD\xC9\x5B\xD6\x52\xDB\x3C\xF8\xC5\x3C\xD4\x26\x80\x55\xDA\x99\x5C\xD6\x47\xDE\x55\xF5\xCD\x85\xD2\x05\xD9\x55\xD2\x04\x6B\xD6\xA3\xAD\x56\xD1\xD3\x00\x03\x5B\xD1\x38\xF1\xD5\x21\xD3\x5C\xD4\x56\xDC\x68\x77\xD5\x37\xD9\x57\xE7\xD5\xDF\xC5\x5A\xDB\x6A\xB5\xD5\x33\xB5\x60\xD2\x4F\xC3\xD6\x55\xD7\x09\xD0\x51\xC4\xD5\xAF\xCC\x95\xC5\x56\xD3\xD5\x84\xD5\x19\xD6\x58\xDB\xA2\x88\xD4\x97\xBA\x58\xC7\xC8\x7A\xD5\xE8\xCC\x57\xEB\xA4\x7E\xD4\x9E\xC8\xAC\x5B\xD6\x85\x65\x67\xD7\x3B\xEC\xD1\x12\xD4\xFB\xCF\x57\xE3\xD6\x66\xD5\x63\xDF\x43\xCF\xD6\x20\xA9\x68\xD2\x59\xC0\xD6\xAD\xD7\x57\xD1\x50\xC2\x68\xB2\xD5\x41\x09\x59\xC8\xCC\xA4\xD7\x01\x96\x5A\xC2\xCF\x42\xD6\x8E\xB1",
			"\x51\xE4\xD4\x63\xD6\x68\xD1\xC5\x7D\xD6\x38\x93\x6F\xD9\x40\xCF\xC7\x38\xC9\x9B\x9C\x10\xD6\xD2\x92\xD3\x25\xD1\x5D\xD3\xD7\x94\xD1\xCF\xC0\x11\xDB\xBA\x4B\xCC\x38\xC9\x5D\xC1\xCD\xA2\x0B\xE3\xCA\x56\xD3\xD6\x57\xD1\x2E\x05\x51\x9F\x60\xCA\xD6\xB2\xAE\x5D\xC7\xD6\xE0\xD6\x47\xD2\x5E\xFC\x97\xE4\xD5\x65\xD9\x4F\xE7\xD7\x98\xD5\x7A\xD8\x57\xEB\xD7\x2B\x95\x7B\xDE\x5A\xC7\xD1\x57\xD5\xF8\xC6\x3C\xEB\xD6\xC7\xD6\xC4\xB4\x5F\xD7\xD4\x93\xA1\x79\xD5\x52\xFD\xC0\xF0\xD7\xDE\x9B\x5B\xD8\xCC\x05\x04\x72\xDB\x48\xBF\xD7\xFB\xD1\x44\xA2\x60\xF8\xD3\xEA\xCD\x81\xD3\x79\x87\xD8\x1F\x62\x82\xD8\x7C\x8C\xD8\x62\xD4\xF2\x9F\x60\xCA\xD3\xCC\xCE\x80\x8A\x55\xF4\xD6\x47\xC4\x86\xD4\x5C\xDA\xD8\xEE\xD5\x84\xDD\x3C\xFA\xD6\xF2\xD6\x60\xD2\x62\xE2\x92\x05\x07\x86\xD8\x51\xCA\xC6\xD6\xD3\x38\xD5\x5C\xF3\xD6\xAC\xD5\x88\xD3\x5E\xD2\x04\x2E\xDA\xC9\xCE\x31\xF9\xD7\x16\xD3\x7E\xD6\x5C\xCF\x72\x16\xD9\x44\xAB\x62\xE5\xD6\x25\xDB\x16\xD2\x61\xC6\xD5\x29\xDB\x62\xD3\x64\xFE\xD6\x45\xDA\x49\xD7\x62\xC4\x04\x14\xDA\x44\x01\x64\xD3\xA2\x4B",
			"\xD9\x72\xDD\x64\xC4\xD8\x4F\xD8\x00\x01\x65\xCE\x04\x53\xDB\x07\x65\x65\xCB\x92\x39\xD8\xEE\xC2\x63\xE4\xCE\x74\xD5\x92\xD7\x20\xDF\xD9\x24\xDB\x7D\xD9\xD4\xA3\xCA\xA3\xCE\x53\xD5\x66\xE0\xD8\xE1\xD7\x8D\xDE\x10\x21\xD9\xA8\xD4\xC7\x6E\x79\x45\xD5\x5B\xDA\x42\x0D\x65\xF8\xD8\x2F\xD4\xE8\x76\xAD\x78\xD9\x66\xD8\x91\xD8\x53\xD6\xD5\xB0\xD7\x0A\xC7\x67\xF9\x70\x79\xDA\x41\x0B\x67\xF3\xD9\x7D\xDB\xC9\xC5\x68\xE1\xCF\x87\xDB\x77\xD0\x67\xEE\xD5\x8D\xDB\x8E\xDF\x68\xD6\xD0\x91\xD8\x7A\xD3\x69\xF8\xD5\xA6\xD7\xFF\xC1\x5C\xC4\xCF\x20\xA9\xA6\xD1\x5F\xDB\xDA\x82\xD5\xA7\xDB\x5C\xEC\xD9\x94\x62\xA8\xD6\x60\xC1\xDA\x4C\xDB\xA0\xDE\x58\xEB\xD3\x86\xDB\x65\xD8\x62\xE4\xDA\x8B\xD6\xA9\xDF\x50\xF0\xDA\x90\xDA\xAC\xD0\x65\xEC\xDA\x56\xDA\xAB\xDF\x5A\xF8\xDA\x98\xDA\xAE\xDA\x65\xFC\xDA\x60\xD9\xA5\xD9\x51\xF1\xD4\x5F\x89\x83\xD8\x64\xF4\xDA\x9C\xD6\xB1\xD0\x63\xFC\xD8\x21\xD2\xAA\xD3\x61\xC4\xDB\x69\xD9\x50\xDA\x4E\xC3\xD5\xA1\xDA\xB0\xD9\x68\xC9\xD8\xB5\xD4\x80\xD2\x66\xD2\x8E\xDA\xD8\xB5\xDE\x60\xCE\xDB\x12\xC8\xB2\xDF\xB5",
			"\x40\xDA\xCC\xDA\xA0\xD6\x6D\xF9\xD4\x97\xD9\x8D\xCE\x18\xBB\xC8\x2A\xA9\x8F\xC4\x0C\xD5\xD2\xF4\xDA\x75\xD2\x34\xF3\xDB\xF6\xDA\x22\xD3\x34\xF5\xDB\x91\xD1\x75\xDD\x6F\xCA\xCD\x49\xCE\x3A\xC7\x2B\x05\xA2\xE8\xD9\x8D\xD1\x67\xE1\xA1\xB6\xD8\xF2\xBC\xC7\x45\xDC\xFD\xD6\x8D\xD8\x70\xE4\xDB\x8D\xCE\x46\xDB\x70\xC8\xDA\xE2\xD8\x95\xD2\x73\x89\xDC\x10\xDA\x91\xD3\x71\xD2\xDA\x06\xDE\x7A\xD7\x71\xD0\xDC\x76\xD0\x73\xDF\x06\xF2\xD2\x6F\xD9\xC7\xD3\x5F\xDF\xDC\xBE\xD8\x7E\xDD\x6E\xEB\xA4\x16\x04\xC3\xD0\x64\xFE\xD7\x28\xDF\xBA\xD4\x68\xC0\xDB\x21\xD1\xCB\xD4\x71\xE9\xDB\x07\x92\x88\xD7\x30\x98\xDC\x1C\xD8\x5A\xDE\xC6\x6E\xDC\x97\x73\xA2\xDA\x10\x3A\xDC\xEA\xDA\xB7\xD5\x67\xC4\xDC\x37\xDE\xC9\xDA\x62\xF1\xDC\x46\xDF\x67\xDC\x05\xC0\xD8\x1F\xDA\xD2\xDA\x64\xCC\xDD\xCA\xDB\xB7\xDB\x01\xE4\xDC\xFC\xD7\xCB\xDE\x70\xF4\xD3\x3C\xDF\x8B\xD5\x6E\xE2\xDC\xB1\xC0\xD6\xDF\x63\xC1\xDD\x30\xDF\xC3\xD9\x72\xEB\xD9\xE2\xD3\x24\xCA\x6C\xD1\xDD\x0D\xDF\xC1\xDC\x75\xE0\xDC\xCB\xD3\xC6\xDA\x69\xD2\xDD\x67\xD8\xD5\xD9\x61\xDE\xDD\x11\xDE",
			"\xB9\xDF\x73\xC9\xDD\x6D\xDE\xC7\xD6\x76\xF2\xDC\xAF\xD8\xB6\xDC\x5D\xDB\xD7\x89\xD0\xE1\xDF\x0C\xFA\xDB\xF8\xDB\xBF\xD2\x70\xD0\xD7\xFE\xDB\x24\xD0\x70\xCC\xDE\x8F\xDC\xBF\xD0\x0D\xAC\x00\xA5\x65\x16\x02\xF1\x9A\x01\x03\xCE\x40\x0D\x80\x54\xDE\x1C\x6A\xE5\xD7\x14\xD8\xDE\x13\xCE\xCA\xD4\x73\xDD\xB4\x9C\xDC\xB2\x6E\x79\xD7\xD1\xA0\xDF\xCC\xC7\x5B\xE0\x78\xA5\xDD\x14\x77\x7A\xDE\xD4\xA9\xDF\x97\xC0\x56\xDB\x95\xAD\xDF\x23\x7F\x7A\xF8\xD5\xB1\xDC\x9A\xC3\x7B\xE3\x94\xB5\xDF\x25\x77\x7B\xC2\xD6\xB9\xDE\xA0\xCB\x7B\xFA\xB0\xBD\xDC\x5F\x8F\x7B\xCB\xD6\xC1\xDF\xB0\xCB\x7A\xD4\x79\xC5\xDF\x8C\x87\x7C\xC7\xC8\xC9\xDE\xB2\xCB\x7C\xCF\x88\xCD\xDD\x27\x9F\x7C\xC5\x66\xD1\xDF\xA9\xD9\x76\xDB\xA2\xD5\xDE\x96\x97\x7D\xC7\x90\xD9\xDF\xAD\xD2\x78\xC7\xB2\xDD\xDE\xA3\xAF\x7D\xF8\x90\xE1\xDF\x80\xD5\x30\xD2\x04\xE5\xDF\x4C\xB7\x7E\xCB\x92\xE9\xDD\xC6\xD0\x0B\xDB\xDE\x95\xDF\xE5\xD9\x79\xDF\xDD\xA8\xDB\xE4\x9D\x7E\xDC\xB9\xEF\xDC\xF2\x91\x7F\xFD\xDC\x29\xB4\xFD\xDD\x79\xF6\xDF\xA1\xDC\xDA\xD1\x63\xCB\xD2\xD4\xD5\xE4\xD9\x6F\xC6",
			"\xDE\xD9\xC0\xE2\xD2\x0D\xD0\xDE\x8B\xDE\xE4\xD2\x5D\xCD\xDE\x13\xE2\x02\xEA\x78\xEC\xC3\x9F\xBD\x48\xCF\x5C\xD2\xE0\x09\xE1\x04\xEB\x80\xE8\xBA\x1A\xE1\xE6\xBC\x81\xD4\xE0\x1D\xE0\x06\xE3\x82\xD8\x8B\x4B\x01\x69\x6E\x08\x12\xBC\x8F\x02\xCC\x9D\x82\xE1\xA4\x06\x05\x23\x0A\x4B\x81\xB2\x12\x05\x0A\xEC\xA1\x6B\xE0\x47\xC7\x0B\xE4\x4F\xFA\xE0\x58\xA6\x42\x02\x83\xDC\xC8\x78\xDD\xC8\xD9\x7F\xE8\xB2\x36\xE0\xB2\x68\x83\xD7\xD1\x3C\xE3\x42\xD4\x10\x09\xE1\x11\xA7\x07\x6F\x83\xCA\xC8\x3A\xDB\xB1\xD0\x76\xCD\x60\x45\xE1\x14\x77\x84\xDE\xD4\x4C\xE1\x4B\xD5\x10\x19\xE1\x1C\xA2\x44\x0F\x84\xEF\x90\xF2\xDF\xC3\xCE\x10\x15\xE1\x8F\x73\x15\xE8\x57\xD9\xE1\x07\x8C\x17\xE5\x98\x5F\xE1\xE8\xBD\x18\xEB\x7E\xE3\xE1\x2A\xE0\x0B\xEE\x82\xC6\xA5\x6C\xE2\x1C\x92\x7E\xC2\xD7\x3A\xB0\x19\xE7\xC9\x66\xE1\x82\xD4\x1A\xE5\x98\x6A\xE1\x07\x91\x1D\xE0\x01\xF7\xE1\xA0\xDB\x52\xBA\x87\xFC\x85\x7C\xE3\x62\xDE\x87\xC7\x90\x80\xE0\x0E\x92\x88\xD9\x92\x4E\xDC\x26\x87\x88\xF3\x88\x89\xE3\x81\xCB\x88\xF8\x90\x8D\xE3\x22\x9F\x88\xDA\xDF\x07\xE3\x26",
			"\xA3\x89\xDD\x92\x95\xE3\x1F\xE3\x87\xF0\xE0\x05\x07\x26\xE4\x88\xFE\xD1\x51\x97\x27\xEA\x65\xA1\xE2\x8C\xE3\x28\xED\x8E\xBE\xE0\x33\xE3\xA7\xD8\x8A\xDB\x95\xAA\xE2\xA3\xAC\x8A\xD8\xE2\xAE\xE1\x0F\xE1\x83\xF1\xE2\xD7\xD8\x1E\xE1\xD9\xB5\xE2\x33\xB7\x2D\xEB\x48\x97\xE2\xC3\xE0\x1D\xEC\x8B\xEC\xDB\xA3\xDD\x0E\x70\x8C\xDC\xB9\xC2\xE0\xF2\x94\x8C\xCE\xE3\xC6\xE0\x10\xE1\x85\xCF\xDB\x2B\xDE\x32\xE1\x87\xF9\xE0\xB9\xE2\x5E\xAE\x10\x26\xE2\xEA\xDD\xF5\xCB\x81\xDF\xE0\x10\xE2\x09\xE0\x8E\xE7\xE0\x1E\xE3\x05\xE4\x11\xE4\xE3\xE2\xE2\x39\xE8\x12\xCE\xE0\x22\xC5\xC0\xDA\x1B\x07\xCD\xE3\xE1\x3C\xEA\x8E\xCC\xCD\xF7\xDB\x03\xE0\x22\x0E\xCD\xE8\xE3\x39\xE2\x8F\xCE\xDE\xE5\xE0\x3F\xE9\x8E\xC5\x74\xC2\xC3\xEF\xA8\x10\x05\xA2\x7E\xD8\xBC\xD9\xAF\x42\xE4\x02\x04\x41\xE1\x9B\x88\xE4\x9C\x7E\x4B\xC5\x83\x4E\xE4\x0A\xE6\xD4\xA6\x90\xCF\xE4\x0C\xE7\x41\xE3\x91\xD1\xE4\x03\xE6\x43\xE9\xC5\xB6\x79\x39\x73\x09\x05\x9A\x4D\x01\x66\xB9\x03\x6E\x91\xDC\x68\x20\xE6\x83\xB1\x27\xDB\xDF\x7B\x9F\x48\xE8\xAC\x65\xE4\x15\xBA\x01\xE0\x6D\xDD\xB4",
			"\x2A\xE5\x14\x7C\x92\xDC\xB8\x81\xDE\x2F\xEB\xD4\xB1\xE4\x8F\x73\x4C\xE3\xE2\xB3\xDC\xE3\xDE\x0C\xB8\x93\xD7\x72\x3A\xE6\x8A\xB8\x8C\xFD\xE4\xFB\xB7\x4F\xEC\x17\x81\xE5\x31\xBA\x2C\xEA\xD0\x84\x04\x46\xE7\x8C\x88\x94\xF8\xB8\x4A\xE4\x34\x8D\x94\xDD\x92\x4F\xE4\x27\xEF\x92\xDD\xE4\x1F\xE6\x99\xBD\x3A\xE2\xE4\x59\xE6\x49\xEE\x68\xC9\xE3\x98\x83\x54\xEA\x65\x95\xE5\xA7\xE3\x52\xE0\x00\x22\xE5\x8E\xA8\x59\xED\x8D\xF1\xD4\x5C\xE4\x49\xEA\x95\xF4\xCA\x0E\x04\x5A\xE3\xD3\xAA\xE5\x6E\xE1\xF5\xCF\xDF\x56\xDD\x00\xE1\x5E\xB8\x97\xC1\xE1\xAD\xCF\x5E\xE3\x8D\xF8\xDF\x28\xE4\x5F\xEB\xBE\xBE\xE5\x84\xE5\x9D\xD5\x98\xD1\xE2\x6B\xE4\xD8\xD7\x98\xDC\x63\x8B\xE7\xF4\xD0\x29\x0D\xE6\x51\xE6\x8C\x00\x99\xFD\xE2\x85\xE1\x6E\x03\x99\xC3\xE5\x36\xE6\x65\xE6\x98\xDB\xE6\x88\xE5\x5D\xE1\x53\xD7\xE6\x3C\xE5\x66\xEF\xB4\xAF\xDB\xFB\xDB\x3E\xE5\x81\xFD\xE3\xA7\xE7\x3F\xE9\x9A\xFA\xE3\xF3\xE2\x76\xDE\x8E\xEC\xE6\xFE\xE0\x6C\xEB\x9A\xEB\xE3\x0C\xE0\x3C\xED\x9A\xC3\xDE\xAF\xE4\x6D\xE9\x9B\xF4\xE3\xFE\xC1\x08\xE9\x0C\xCC\xE0\xE2\xC3\x6E\xEE",
			"\x9A\xE1\xE3\xB2\xE5\x09\xE5\x9C\xE4\xE0\xC8\xE6\x05\xE1\x9B\xFA\xE6\xC4\xE4\x73\xE9\x8F\xCE\xE7\xA6\xE6\x71\xE0\x9D\xF7\xE6\x86\xD1\xF4\x8E\x90\xCE\x97\xBF\xE6\x70\xE8\x9B\xCD\xE7\xBC\xE4\x70\xEE\x9B\xD7\xC3\xDE\xE4\x22\xD7\x78\xE1\xE7\x08\xE1\x72\xE8\x9A\xFD\x05\xB6\xE7\x72\xED\x9D\xDA\xE7\x85\xDC\x7B\xE3\x9E\xE0\xE0\xE2\xE5\x03\xE4\x9E\xE5\xE6\xD4\xE7\x7B\xEC\x9D\xC3\xE7\xCF\xE7\x7A\xE7\x9F\xDB\xE7\xF9\xE4\x7E\xE1\x9D\xE6\xE7\xAA\xE6\x74\xEA\x9F\xFD\xE7\xFC\xE7\x7F\xEA\x9C\xF3\xE6\x03\xEA\xD1\xCF\x9D\xF1\xC3\xFB\xE5\x7B\xED\xA0\xF6\xE7\xF7\xE3\x82\xE1\x11\xC4\xE8\x0E\xE8\x85\xE0\xA1\xC6\xE8\xBE\xD0\x02\x8D\x80\x76\xC9\x33\x8B\x2E\x0E\x55\xBA\x02\xF7\xDD\xDE\xDA\x33\xF5\xE7\xF2\xE6\x7B\xE5\xA2\xCF\xE8\x27\xEA\x85\xE9\xA2\xD8\xE8\x01\xE8\x80\xE7\x9C\xC7\xE8\x02\xEA\x7F\xED\xC5\xB1\xE7\xC1\xE4\x8A\xE5\xA3\xEA\xE8\x37\xE8\x8B\xE7\xCF\x9F\xE3\x24\xE9\x8E\xED\xA3\xD2\xE8\xD8\xD7\xC0\xD8\x3C\x98\x82\x1C\xE9\x27\x9E\xA1\xFC\xAF\x20\xE9\x01\xE5\x4D\xF5\xE3\xED\xE2\x8D\xE0\xA4\xDB\xBD\x4E\xE8\x8D\xEF\xA4\xE2\xBD\x3F",
			"\xEA\x94\xE6\xA5\xE5\xE7\x30\xE9\x6D\x09\x9E\xC8\xE8\x32\xEA\x7A\xED\xA5\xDC\xE9\x05\xEA\xFD\xCD\xA4\xF8\xE8\x53\xE8\xD9\xB5\xA5\xD8\xE9\xE7\xE6\x46\xAD\x98\x45\xD5\x70\xD2\x96\x9E\x44\xC7\x8C\x74\xD2\x60\xE9\x9D\xD1\xE9\x68\xE9\x8B\xE9\xA5\xF7\xE9\x69\xE8\x9E\xE6\xA7\xF9\xE9\x7C\xEB\x9E\xEE\xA7\xEF\xE8\x7D\xE8\xA0\xEF\x8E\xE5\xE9\x66\xBC\x99\xE7\xA5\xF4\xE7\x5E\xEB\x71\xAC\xA3\xC9\xEA\x15\xEA\x8E\xE3\x9D\xCC\xEA\x17\xEA\x95\x08\x74\xD3\xD4\x1C\x68\x4B\xD6\xBE\x80\x00\xF1\xD3\xC1\x83\x52\xDE\xDA\x94\xE6\xA3\xE9\xA0\xE7\xE9\x88\xE8\x98\xED\xA8\xE0\xEA\x89\xDC\xA4\xEB\xA2\xE4\xEA\xF6\xE2\xA7\xEF\xA5\xF1\xE8\x61\xEB\x14\xB7\xA8\xE5\xEA\xA2\xE9\xA4\xE6\xAA\xFE\xE8\xA6\xE8\x3E\xEA\xAA\xED\xEA\xB1\xEB\xA9\xE3\xAB\xC4\xEA\x80\x89\xB2\xD4\x08\x9B\xE8\xA5\x67\x91\xED\xC4\x84\x04\x49\xEA\xEA\xD2\xB1\x7F\x77\xDD\xA9\xA8\xEC\xAA\xE3\xEA\xBB\xEB\xAB\xE9\xAA\xE8\xEA\x63\xEB\xAD\xEC\xAC\xF9\xEA\xB4\xE8\xB5\xEC\xAB\xD9\xC4\xD2\xEA\xAC\xE6\xAD\xCE\xEB\xD1\xE8\xB4\xEB\xA8\xDB\xEB\x75\xEA\xA0\xE2\xAE\xCF\xEA\xE0\xEA\xB2\xEE\xA2",
			"\xE4\xEB\xE8\xE7\xB5\xE3\xA2\xCD\xEB\xE1\xE8\xBA\xE7\xAE\xC7\xB7\xDF\xEB\xB2\xEA\xAD\xF2\xEB\xBA\xE9\xB9\xE0\xAB\xF4\xEB\xD5\xE8\xBE\xEA\xAE\xFC\xCC\xDE\xEA\x08\xE9\xAD\xF5\xEB\xFA\xE8\xB7\xE1\xAF\xEF\xEB\xAB\xEA\x96\xEB\xAF\xFE\xCC\xF3\xE7\xBD\xE4\xB0\xF8\xEA\x52\x8F\xC1\xE7\x5D\xD0\xE9\x86\xE9\xBB\xEF\xA9\xC2\x68\x1F\x61\x6E\xDC\x3B\xE5\xCF\xC6\xD3\xE2\xC7\x76\xFE\x5E\x97\xEA\xC5\xEC\x17\xAF\xCF\x0E\x05\xFC\xC8\x7C\xB6\xCE\x9C\xE8\x66\xE5\x99\xE3\xE6\xF3\x7E\xB2\xAE\x97\xC3\xEC\x7A\xEB\xB8\xE3\xB1\xF6\xEB\xCF\xE8\xBB\xE6\xAE\xED\xEC\xEE\xE8\xCD\xEF\xB2\xC1\xEC\x12\xED\xC1\xE6\xB3\xC8\x04\x5B\xE8\xCE\xE3\xB3\xC1\xEA\x35\xEC\xD0\xE7\xB3\xF5\x06\xB6\xE9\xBF\xE3\xA7\xD1\xEC\x3F\xEF\x9F\xE1\xB4\xCA\xED\x43\xEF\xCE\xEC\xB0\xCB\xEC\xD3\xEA\xCF\xEA\xB0\xCE\xED\x51\xEC\xD4\xE3\xAF\xD6\xED\x00\xEC\xD6\xE9\xAF\xD8\xED\x3D\xEE\xD6\xEE\xB0\xCC\xE9\x2C\xEF\x78\x9F\xB5\xEC\xE3\x61\xEC\xD3\xEA\xB3\xC2\xED\x20\xAB\x05\xCE\xB1\xCF\xCF\x57\xD2\xC8\xE1\x91\xA4\xEC\x41\xC6\x2C\xCB\xB6\xC8\xCF\xD0\xCF\xE4\xCB\xB1\xE1\xD3\x9D\xE0",
			"\x25\x6A\xB6\xD1\xD6\xA6\xCC\xC6\xEA\x84\xC0\x00\x70\xED\x59\xE2\xA0\x7B\xED\xD7\xCD\xE4\xC5\xB7\xCA\xCF\x77\xEC\x4C\xD0\x76\xE5\xED\x2E\xEF\xD9\xE6\xB6\xCF\xED\x54\xEF\xD5\xE1\xB9\xD9\xED\x93\xEF\xD6\xE5\xB9\xE3\xED\x09\xED\xCC\xE9\x16\x1D\xED\x97\xEE\xC0\xEE\xAF\xC6\xED\xFD\x9A\xE7\xE7\xB4\xFF\xEB\x96\xEC\xDA\xE0\xB9\xE6\xEE\xE1\xCF\xB7\xB3\xB7\xD9\xCF\x7E\xED\x48\xD7\x3E\xE0\xDC\xB6\x63\xDD\xD8\x39\xE4\xCF\x87\xEC\x3D\xD1\xB8\xC9\xE6\x43\xE1\xEC\xE3\x62\xEE\xD9\x86\xED\xDB\xE6\xB7\xC0\xDE\xBF\xD8\x51\xEB\x92\xAA\xEE\x7C\xEF\xC5\xE5\xBB\xD9\xEC\xAF\xED\xE2\xE7\x92\xF9\xED\x9A\xEE\xD4\xED\xBC\xDE\xED\xA2\xEC\x78\xE6\xA2\xE5\xEE\x8F\xED\xD5\xED\xB9\xF9\xEC\xA7\xED\xF5\xE2\xB9\xE8\xEE\x00\x04\xE7\xEC\xBD\xD4\xEE\xDF\xEC\xF5\xED\xB8\xD9\xEF\x3B\xEB\xE7\xE2\xB3\xD3\xED\xE1\xEC\xE6\xE3\xBD\xEC\x61\xB5\x9F\xEA\xEE\x3E\xED\xEE\x5A\xE2\xA8\x10\xBB\xD2\xA2\xEE\xEF\x4C\xB0\xB2\xCA\x04\x6E\xEF\x24\xA7\xBB\xDE\xE6\x60\xDE\x1E\x62\xBB\xFB\xCE\x1F\xEC\xFC\xE5\x3B\xF0\xDD\x1D\xD8\x08\xA0\x75\xED\xCF\xF6\xEE\x00\xF0\x3C\xC4",
			"\xF0\xA7\xB1\xB2\xED\x5C\xD4\xE4\x17\xE4\xAE\xA0\x9A\xF5\xE4\x27\xEF\x9E\x75\x67\xCC\xEE\x4B\xEF\xF8\xE6\xBD\xE9\xEF\xD1\xEC\x83\xE8\xB4\xE8\xEF\xDA\xEC\xF8\xE1\xC2\xE2\xEF\x19\xF1\x09\xFB\xE7\x89\xED\x1A\xF3\xF6\xE3\xC2\xEA\xEF\x28\xE9\xD1\xE7\xBE\xCF\xEF\xD7\xEC\x0A\xF6\xC2\xCE\xEE\x29\xF2\x08\xF5\xC3\xE4\xF0\x4D\xEC\x07\xF8\xBD\xDB\xF0\x2B\xF1\x07\xF3\xA1\xE4\xEE\x2C\xF3\x07\xF0\xC3\xDF\xEF\xDE\xED\x0F\xFB\xC3\xEA\xF0\x37\xF1\x10\xF4\x28\x8A\xF1\xA0\xEE\x07\xF0\xC4\xFE\xF0\x9E\x86\xAF\xEB\xBB\xF3\xEE\xBD\xEE\x47\xD9\xBF\xDF\x60\xFB\xED\x1D\xD2\xC5\xF5\xEF\x5C\xBB\xFD\xE6\x10\x17\xF1\x12\x05\x16\xF2\xA7\xC5\xD6\x7F\xD9\xF1\xE1\xC0\xC7\xEF\x7F\xEE\x18\xFF\x97\xE2\xE8\xB9\xEF\xB9\xD6\xC6\xEC\xED\x56\xF3\xEF\xED\x74\xC3\xDF\xD9\xDA\xD8\xDE\x3C\xF4\xED\xBE\xEC\xE2\xE0\xBC\xE2\xDE\xC2\xEC\x13\xFF\xC2\xDD\xEB\x7F\xF0\x06\xF9\xC3\xC6\xF1\x32\xF3\x20\xF9\xC4\xD0\xF1\x10\xEF\x13\xF7\xC4\xE7\x86\x88\xF0\x95\xE1\xC8\xE6\xEF\xB9\xEA\x0B\xF0\xB3\xC0\xF2\x93\xF2\x20\xF4\xC3\xF3\xF0\x2B\xC3\xB3\x7C\xC5\xC8\xCC\x5E\xF1\x41",
			"\x00\xC6\xFF\xCD\xF3\xEE\x34\xEB\xC9\xC8\xD8\x15\xC9\x1E\xF6\xBB\xCC\xF0\x64\xF0\x14\xE3\xCA\xDF\x60\x9D\xF0\x41\x0F\xC9\xEB\xCE\xCA\xEF\x57\xED\xC7\xC1\x62\x9A\xF3\x1B\xF8\xC7\xF1\xF1\x7A\xF3\x1C\xFE\x98\xFE\xD2\xB5\xF1\xE1\xE6\x38\xCA\xF0\xD2\xCC\x2A\xF9\xD7\x96\xF2\xE4\xEC\x26\xFC\xC3\xC7\xF2\x8B\xF0\x0E\xF7\xC9\xC6\xF2\xC6\xF0\x12\xFD\xCC\xF6\xF0\xCF\xF2\x32\xF5\xCC\xE7\xF0\x20\xF0\x32\xF5\xC8\xCB\xF3\xD8\xF3\x34\xF9\xCD\xF1\xA7\xC4\xF3\x31\xF1\xCD\xFE\xF1\x95\xF1\xA5\x6E\x3B\xAB\xF2\xAD\xC6\x29\xF8\xBC\xF2\xEF\xB1\xF2\x44\xEB\x40\xA4\xF3\xCC\xC4\xD7\xC2\xC7\xD5\xDD\x47\xDF\x0B\x7C\xCE\xE2\xC8\x8B\xD7\x2B\xFA\xB1\xFB\xF1\x2E\xE5\x35\xE8\xBD\x73\xF3\xD1\xC4\x30\xFD\x3D\xC2\xF3\xEF\xD6\x3C\xF6\xCB\xEC\xEE\x68\xF2\xEB\xE8\xCE\xF8\xF3\x4B\xEA\x3E\xF9\xCC\xE0\xF3\xCE\xEC\x25\xFD\xD0\xDD\xF3\xCE\xF0\x33\xF2\xD1\xDB\xF3\x11\xF4\x45\xF0\xCD\xD3\xF4\xDA\xF2\xD8\x7C\xD0\xD0\xEF\x0B\xF5\x23\xF6\xA6\xF2\xBA\xD7\xF1\x46\xFE\xCD\xD8\xF4\x23\xF6\x45\xF2\xCD\xE5\xF4\x58\xD6\xB0\xDD\x80\x70\xF1\x78\xD6\x3D\xF9\xBC\xC8\xF4",
			"\x84\xA1\x45\x9C\xCF\xE9\xC5\x05\xF5\xFC\xE0\xB8\xC0\xF4\x26\xD8\x7F\x93\xD3\xE5\xF2\xB8\xF3\x29\xF9\xCE\xD2\xE1\x6D\xF2\x4E\xF3\xD0\xEF\xEF\x35\xF7\x00\xFF\xD3\xD4\xE3\x60\xE5\x1C\x6C\x7F\x7B\xF4\x43\xC6\x3F\xF2\x3F\xF8\xF4\x5B\xD2\x03\xFD\x25\x99\xE4\x15\xE4\x04\xFE\xE8\x94\xF5\x4B\xBB\x04\xF1\xBC\xE2\xE6\x16\xF1\x67\xE9\x97\xF9\xD3\x10\xF7\x45\xF6\xD2\xDB\xF4\x31\xF1\x35\xFF\xCD\xDE\xF4\x85\xEA\x22\xF1\xD2\xE8\xF4\x6C\xF5\x45\xFA\xD1\xE8\xF5\xFA\xC0\x9D\xEB\xD6\xEE\xF5\x6D\xF4\x2A\xE1\xD6\xE7\xF4\x74\xF5\x5E\xF2\xD6\xE2\xF4\x7A\xF4\x5E\xFB\xD7\xF5\xF5\x7E\xF5\x60\xF4\xD6\xFA\xF0\x73\xF7\x5F\xFD\xD7\xC3\xF6\x84\xF2\x59\xF4\xD2\xFA\xF5\x45\xF2\x35\xFA\xD8\xE3\xF5\x70\xF4\xB6\xE2\xA6\xF7\xF5\x88\xF6\x63\xF3\xC4\xC9\xF6\x97\xF5\x0A\xDC\x94\xA4\xD3\x08\xF1\x17\xFE\xD4\xE3\xEC\xA1\xF3\x37\xAC\xD4\xED\xF2\xA5\x1B\x3B\xF2\xBB\xFE\xE5\x92\x06\x1C\xA3\xDA\xDF\xF6\x6F\xEC\x54\xF0\x0B\xD4\xF6\x91\xF7\xBA\xE1\xCE\xE3\xEE\x4D\xF3\x0F\xF5\xDB\xC1\xE9\x72\xF7\x63\xFC\xD7\xCC\xF2\x1D\xF5\x6F\xF5\xD8\xC2\xF6\xB1\xF4\xBF\xE0",
			"\xD2\xFA\xF6\x80\xF5\x65\xF7\xD6\xFE\xF6\xC4\xF7\x61\xF1\x88\x52\xC7\xAB\xF5\x51\xFB\xC0\xC7\xF5\x0D\xE4\x73\xCD\xDC\xE6\xF3\x69\xF2\x6B\xF8\x65\xD2\xF7\x43\xF5\x02\xFE\xDC\xC1\xF3\xD0\xF4\x1B\xF1\x98\xCC\xBE\xEA\xF3\x03\xFD\xA1\x8B\x68\x5A\xF4\x1F\xFC\xD5\xC0\xF7\xC8\xF5\x66\xF7\xDC\xFF\xF6\xC6\xF7\x62\xF6\xD8\xEF\xF7\xE8\xF4\x7B\xF1\xDC\xC8\xEC\xEB\xED\x7C\xED\xD8\xEB\xF7\xC9\xF4\x7C\xFD\xDE\xD6\xF4\x92\xF3\x43\xF0\xC9\xFE\xF7\xB4\xF7\x23\xF1\xE0\xF3\xF6\xD2\xED\x6E\xFA\xDE\xEE\xF7\xF1\xF5\x7E\xF9\xE0\xC7\xF8\x90\xF5\x7A\xFE\xD0\xDC\xF4\x85\xF7\x7D\xF8\xE0\xFB\xF7\xBB\xF7\x82\xFF\xE0\xC4\x97\x14\xF9\x71\xF3\xDF\xCF\xEC\x8E\xF0\x23\x7B\xEB\x93\xF7\x3D\xF7\x39\xF7\xD3\xDD\xF7\x56\xF6\xAE\xBA\xD2\xF4\xEE\xD4\xF6\x41\xF3\xE2\xF0\xF4\x8A\xED\x50\xF0\xF4\xB6\xF1\x7B\x9C\x4B\xF2\x58\xEE\xF4\x07\xF6\x2E\xF1\x99\xF1\x6D\x26\xF8\x8C\xF3\x79\xB2\xF8\xF5\xF2\x69\xF3\xC5\xE8\xF6\x2E\xBC\x67\xF8\x09\xBC\xF8\xEE\xF1\x2E\xF0\xCF\xDE\xF5\xBD\x67\x87\xF9\xDD\xDE\xF6\xDB\xF7\x3F\xF4\xE2\xF1\xDD\x38\xBE\x8E\xF8\xCA\x84\xF9\x66",
			"\xCE\x8F\xF5\xB2\xE1\xE6\x15\xF2\x85\xF0\xDB\xCE\xF8\x5B\xFA\x7C\xFC\xE5\xFF\xF7\x10\xFA\x82\xF9\xE1\xCA\xF7\x5F\xFB\xA8\x8B\xE1\xE0\xED\x60\xF9\x59\xFC\xE0\xCA\xEA\x69\xF8\x61\xF2\xE6\xE7\xF9\x64\xEE\x38\xF1\xC6\xE7\xF8\x55\xF1\x4B\xF6\xE5\xF1\xED\xA0\xF2\x94\xFB\xD2\xF7\xF2\x76\xFA\x91\xF7\xDA\xF1\xF3\x79\xFA\x90\xF0\x3B\xC4\xF4\x29\xFA\x4D\xFA\xC6\xC0\xF9\x81\xFB\x01\xF3\xE4\xFC\xF9\x33\xFB\x9D\xF2\xB8\xCC\x72\x6A\xF0\x00\xF4\xE5\xFC\xCD\x8E\xF8\xEE\xEF\xDD\xD2\x06\x91\xF9\x67\xFC\xC9\xEC\xF6\xFA\xEE\x75\xFE\x38\xF3\xF9\x7A\xF8\x8A\xF1\xE2\xD5\xF7\x4F\xFB\xFA\xAD\xE5\xEF\xF9\x65\xF9\x81\xF2\xC4\xD7\xF8\x6E\xFB\x9A\xFA\xE1\xE9\xFA\x4E\xF3\x6D\xF9\xC8\xF3\xE8\xB0\xFA\x6D\xF2\xE0\xEA\xFA\xFF\xE9\x7F\xF1\xE6\xEE\xFA\x64\xFA\x97\xFE\xEB\xE8\xFA\xBF\xF9\x6F\x6F\xFE\x61\xFA\x75\xF9\xA3\xFE\xE7\xFF\xF8\x3F\x72\x43\x03\xEC\xC2\xFA\x77\xF0\xA1\xF3\xEA\xEA\xF8\x87\xF8\xA0\xFA\x10\x0B\xFB\x8A\xFB\xA0\xF4\xD4\xC5\xFA\x46\xF4\x8B\xFB\xBC\xD7\xE5\x81\x60\xB5\xFB\x76\xDA\xFA\xA4\xF1\x53\xFD\xE4\xCF\xF5\xA5\xFA\xCF\xD3\xED",
			"\xF4\xF9\xBF\xF3\xB8\xF0\xDA\xE5\xFB\xA9\xF1\x9A\x58\xEE\xDA\xCE\x9C\xF8\x16\xFE\xE9\xD2\xDC\xCA\xFB\xBB\xFD\xB7\xEA\xFB\xAD\xF4\xBB\xF3\xCC\xED\xF9\x98\xF4\xAB\xFD\xEF\xE7\xFA\xBC\xFA\x7E\xF0\xE7\xD9\xEE\xFE\xFA\x65\xF5\xF0\xF8\xF7\x01\xFE\x84\xFD\xE0\xC1\xFB\x07\xFF\x84\xF3\xF0\xF0\xE7\xB5\xF8\x6E\xFB\xEA\xC0\xFC\x0D\xFF\xC2\xF4\x89\x79\x7C\xC4\xF9\xBA\xF8\xED\xCF\xF7\xDA\xFB\x42\xE8\xF3\x76\xFB\xC6\xEF\xC6\xFC\xDD\xDD\xFC\x96\xD9\x52\xFC\x88\x58\xFC\xCC\xF9\x8C\xFC\xE8\xFD\xF8\xC7\xFB\x95\xF4\xC1\xF3\xE2\xC3\xD4\xCA\xF5\xED\xCD\xFB\xD7\xFB\xB3\xF6\xE8\xF3\xFB\x7A\xDF\xC7\xF9\xF1\xF0\xFB\xF8\xF9\xA7\xFA\xEF\xC1\xF4\x0E\x06\xCC\xFF\xED\xCB\xFA\xCE\xF9\x9F\xFE\xD3\xE4\xFC\x40\xF7\xA5\xFF\xEE\x7B\xFC\xF7\xFA\xC8\xFE\xE4\xC8\xFD\x48\xF7\x2C\xF1\xF1\xF3\xFA\xB7\xF9\xAC\xF5\xF5\xF6\xFA\x04\xFA\xD5\xF9\xF5\xD8\xFD\x00\xFA\x46\x83\xE6\xC2\xFC\x53\xFD\x87\xF4\xAF\xFA\xFA\x6A\xF9\xC5\xF5\xE1\xDF\xFD\x5A\xFA\x9C\xF1\xB2\xE0\xFC\x67\xF2\xD3\xF4\xEE\xD0\xFD\xD1\xF4\xFE\xEC\xF6\xD3\xFA\x88\xCD\xA5\xFC\xBF\xEE\xF8\x5F\xF3",
			"\xDC\xFB\xF2\xC5\xF9\x47\xFE\x8D\xFD\xA9\xC2\xD4\x72\xFC\xD3\xF1\xF2\xF6\xFC\xD9\xFA\xDF\xF6\xB2\xF0\xFC\xE3\xA1\xEA\xC0\xE2\xC6\xFD\x22\xF9\xB4\xF8\xE4\xDC\x6C\x8A\xFF\x92\xFB\xE9\xFD\xFC\xF2\xFB\xCF\xF9\xD3\xC1\xFE\x29\xFF\x8E\xFB\xF7\xD5\xF9\x2D\xFE\x55\xEA\xD0\xCC\xFC\x14\xFD\xE8\xFC\xEF\xC6\xFC\xA2\xFF\x80\xFD\xF5\xDA\xFD\xA7\xFE\xC5\x7A\xF0\xE7\xFD\x0F\xFE\x81\xF6\xF6\xF5\xF5\x64\xFD\xAB\xFF\xFA\xFD\xFA\xC0\xF9\xED\xF1\xF0\xD6\xF8\x92\x04\x04\x0A\xF7\xC5\xFD\xC6\xF9\xDF\xF7\xE4\xDC\x63\xB9\xFF\xEE\xF5\xF3\xCC\xFE\xA4\xF8\xDC\xFE\xDD\xCC\xEF\x1C\x6E\xEE\xF2\xF8\xED\xFD\x84\xFC\xC7\xF6\xF8\xD8\xF9\x88\xFC\x88\xAA\xFC\xD9\xFE\x53\xFB\xE6\xF4\xE9\xDD\xFE\x8F\xF8\x8E\xF4\x10\x13\xFF\x33\xFE\xCA\xFC\xFB\xEC\xFC\xBE\xFF\x9F\xFF\xF8\xC1\xFF\xCB\xFC\xDD\xFC\x39\xF6\xFD\x5F\xF7\xE5\xF2\xC6\x02\xFF\xDA\xF6\xDB\xFB\xEE\xC6\xFF\x42\xE3\x77\xF2\xD5\xE0\xF7\x58\xF7\x55\xF9\x90\xD0\xE4\xF8\xFD\x55\xF3\xDE\xEF\x64\xE5\xF5\x3E\xF6\xF2\xE9\xFF\x5B\x69\xFE\x7D\x42\x7F\xFF\x73\xC6\x7B\xF7\x66\xFE\x3B\x7D\xB3\x7E\xB0\x7C\xE8",
			"\x7B\xF4\x78\xF0\x69\x00\xA9\xFD\x07\x80\x65\x7F\xD2\x7E\xD7\x7D\xF5\x73\xF1\x6C\x00\x8E\xFC\x0B\x79\xB1\x7F\x7F\x7E\x05\x86\xE2\x77\xFB\x68\xFB\x5E\x00\x94\x80\x6A\x7A\xDB\x7E\x03\x87\x03\x81\xF6\x7F\xE8\x5B\xFD\x12\x7E\x21\x81\x84\x7C\x09\x83\x01\x80\x01\x92\xFD\x63\x84\x2B\x80\x22\x80\x09\x80\xEA\x78\x01\x82\x19\x02\x5E\x4B\xFE\x3D\x7F\x8D\x7F\xD0\x78\xFE\x54\xFD\x7C\xE4\x6E\xFF\x79\xFB\x70\x7F\xAD\x67\xF9\x7F\x5D\x77\x82\x7B\x01\x8C\xFD\x65\x00\xE9\x7A\xB2\x7C\xB1\x7C\x02\x82\x06\x8C\xF5\x6B\x02\x85\x01\xAC\x57\x30\x81\x0E\x80\x08\x81\x09\x84\x02\x59\x00\xA4\xFE\x4F\x80\xB4\x7E\x29\x83\x11\x81\xAE\x75\x01\x8D\x01\x9A\x00\xDE\x80\x57\x80\x30\x81\x03\x84\x09\x88\x02\x94\x02\xA6\x81\x2B\x7F\xAF\x7C\x16\x80\xAE\x7E\x0C\x82\x5C\x53\x02\x97\xFD\x65\x80\x6F\x80\xAA\x7C\x23\x39\x89\x13\xC5\x72\xF4\x56\xFF\x75\x7E\xD8\x7E\x85\x6E\x43\x04\x0E\x87\x03\x80\xFF\x79\x00\x96\x7F\x51\x7B\xB5\x03\xFE\x7B\x19\x3B\xB2\x78\x02\x8A\x00\xB1\x80\x86\x81\x07\x83\x1A\x81\x0E\x8A\x04\x91\x00\x89\x02\xDF\x7E\x68\x81\x2C\x83\x08\x86",
			"\x0D\x87\x02\x83\x28\x54\x02\xA9\x7F\x70\x81\x4A\x81\x23\x86\x05\x8F\x08\x97\x04\x8E\x01\xE2\x80\x17\x80\x35\x83\x0C\x86\x11\x80\x0A\x9C\x00\x89\x00\x91\x81\x87\x80\x2D\x82\x28\x85\x09\x83\xB9\x76\x02\xA3\x01\x9D\x81\x5B\x80\xC9\x7B\x1F\x7A\x32\x0B\x11\x35\x03\xA0\xFB\x2C\x79\xF1\x7C\x50\x7C\xFC\x7C\x16\x8C\x03\x93\xFC\x7E\x00\xBE\x7E\x40\x81\xF5\x56\x10\x84\x06\x35\x08\x85\x05\x86\x01\xAB\x81\x99\x80\x4C\x82\x1C\x82\x19\x8B\x09\x9F\x02\x8B\x02\x9A\x81\x24\x40\x54\x82\x22\x83\x14\x8C\x09\x86\x06\x9C\xF3\x30\x81\xC8\x81\x65\x83\x27\x87\x19\x8C\x0C\x86\x01\x9D\x03\xC8\x80\x8C\x80\x6F\x83\x36\x84\x1A\x8E\x0C\x84\x07\xA1\x01\x93\x80\xB1\x80\xD9\x7B\x37\x84\x0B\x89\xEB\x71\x02\x93\x02\xE9\x81\xC2\x7A\x68\x80\x66\x42\x74\x3D\x07\x9C\xFB\x7F\x01\xBB\x81\x39\x39\x7A\x80\xE7\x79\xFC\x78\xEC\x6F\xFC\x43\x03\xF6\x30\xC5\x80\x6E\x83\x38\x84\x15\x85\x0D\x82\x08\xA4\x02\x86\x82\x05\x82\x73\x83\x2B\x86\x1A\x8D\xBD\x6E\x07\xA4\x01\xDA\x81\xAD\x80\x87\x80\x36\x80\x11\x8C\x10\x89\x05\x91\xEB\x01\x82\x0A\x83\x50\x80\x45\x80\x21",
			"\x85\x0E\x84\x08\x9D\x04\xC9\x81\x03\x82\x90\x83\x41\x80\x9B\x42\x11\x95\x08\x93\x03\x9E\x82\xE5\x76\x93\x81\x49\x84\x23\x87\x0E\x99\x08\xA6\x02\x8F\x82\xCD\x81\x96\x80\x4A\x83\x21\x8C\x12\x94\x09\xAE\x04\xC7\x81\xF9\x7A\x69\x83\x4A\x87\x26\x89\x06\x99\xEF\x6E\x02\x9A\x82\xAA\x81\x8D\x80\x4F\x82\x12\x89\xF1\x2D\xC0\x2A\x00\x25\x33\x51\x00\x89\x5F\x14\x02\xE6\x42\x05\x14\x9C\x62\xE9\x73\x7F\x30\x82\x71\x83\x48\x83\x26\x80\x14\x8F\x07\x99\x03\xB1\x82\x36\x82\xAA\x83\x4B\x87\xB9\x4B\x13\x9A\x0A\xB8\x04\xC1\x82\x01\x7F\x9F\x83\x56\x82\x25\x8E\x09\x93\x0A\xA8\x00\x98\x82\x5E\x83\x9E\x80\x58\x86\x2A\x82\x14\x89\x0B\x84\x05\x93\x82\x6B\x83\xA8\x80\x38\x81\x57\x7A\x13\x85\x0B\x89\x04\xEE\x82\xEF\x7A\xB1\x83\x57\x84\x2D\x81\x17\x90\x0B\xBC\x05\xFF\x82\x93\x74\xD5\x6A\xC6\x7D\xF9\x73\xF2\x6F\xFE\x64\x80\x52\x78\x58\x83\xAA\x82\x5C\x84\x1D\x8C\x06\x92\x05\xB2\x03\x8C\x83\xE1\x81\xB9\x80\xBD\x75\x2E\x80\x0F\x94\xEF\x6E\xFE\x61\x7A\x7A\x82\xB5\x83\x5F\x83\x31\x8E\x18\x8D\xE8\x5B\xA7\x0D\x83\xEA\x81\x90\x80\x44\x87\x2E\x82",
			"\x12\x84\x0D\xA3\x06\x9F\x82\xA7\x82\x99\x81\xBD\x4E\x2E\x88\x1A\x89\x0C\xA3\x05\xA1\x77\x95\x82\x0E\x7E\x54\x86\x34\x8E\x1A\x9B\x0B\x8D\x60\x49\x6F\x33\x45\x53\x02\x57\x48\x15\x00\x72\x72\xB7\x7D\x05\xE4\x82\xB1\x82\x34\x7F\xE2\x3A\xED\x50\x1C\x97\x0A\xB3\x06\xAD\x83\xC7\x82\xD5\x81\x6A\x87\x99\x74\x19\x86\x0E\x92\x06\xA2\x83\xB5\x82\xCD\x80\x67\x81\x34\x86\x16\x8B\x0E\x8A\x06\xFE\x82\x98\x83\xAE\x81\x69\x80\x39\x81\x72\x4E\x07\xBE\x06\x9B\x83\xD8\x83\xF0\x81\x71\x85\x2D\x8B\x1D\x86\xF8\x44\x07\xB5\x82\xD7\x83\xF1\x83\x6F\x80\x3D\x8F\x1A\x83\x0A\xAF\xF7\x4D\x83\xE4\x82\xEB\x81\x7B\x80\x2F\x87\x12\x85\x0F\x99\x05\xF6\x83\xE9\x82\xF6\x83\x5E\x83\x3A\x82\xB9\x5A\x0E\xB2\x07\xFB\x83\x71\x35\xCC\x82\x24\x87\x3B\x8C\x1F\x96\x0C\xAB\xFA\x4A\x49\x0D\x31\x67\x3F\x8C\x42\xE8\x76\x62\x4E\x08\x1C\xFF\x3A\x6F\xED\x3C\xF7\x40\x16\x5E\x1D\x83\x04\x96\x4E\x60\x06\xF1\x81\xEB\x81\xCE\x80\x74\x81\x39\x87\x1F\x9F\x0F\x92\x07\xE2\x83\xFA\x82\x28\x80\x6B\x82\x39\x81\x1D\x88\xD9\x56\xE7\x23\x84\x28\x67\x02\x86\x6C\x87\x39\x85\x1D",
			"\x96\x04\x43\xF7\x6B\x83\xEE\x83\xFA\x82\x87\x87\x2D\x8A\x1E\x80\x0F\xB5\x08\xAA\x84\xC2\x83\x10\x84\x8D\x82\x47\x86\x11\x98\x11\xB1\xF9\x37\x84\x20\x85\x18\x86\x17\x58\x3E\x80\x23\x94\x0F\xBE\x07\xE0\x49\x47\x84\x0E\x85\x7E\x82\x48\x88\x22\x8B\x12\x94\x86\x0D\x30\xDA\x57\x19\x46\x15\x02\xCE\x6A\x10\x18\x02\x06\xA5\x54\x00\x6B\x52\x00\x02\x8B\x5F\x26\x56\x10\x15\x02\x2F\xA5\x4A\x57\x22\x58\x64\x37\x94\x84\xBD\x62\x11\x16\x12\xA4\xE2\x04\x02\x58\x85\x77\x52\x41\x03\x4B\x85\x98\x3E\x12\x80\xA6\x71\x34\x17\x61\xF9\x03\xB7\x5C\xD6\x76\xFF\x69\x70\x79\xFF\x41\x83\xA2\x04\x02\x85\x90\x86\x48\x8D\x24\x93\x0F\xB8\x07\xFE\x84\x33\x85\x1E\x87\x9E\x87\x4F\x8F\xD6\x78\x13\x84\xFC\x3E\x84\x0C\x70\x01\x86\xA0\x80\x48\x8C\x28\x9C\x11\x96\xF8\x0D\x30\x23\x01\xD2\x31\x72\x5F\x60\x4B\x17\x5A\x90\x48\x85\x59\x84\x84\x61\x09\x63\x07\x3E\x0F\x6B\xED\x30\x7C\x43\x0A\x81\x85\x32\x85\x12\x87\xA2\x86\x51\x89\x24\x8C\x11\xB4\x06\xCA\x84\x3C\x77\x52\x84\x64\x87\x31\x8A\x21\x98\xF0\x7D\x09\x80\x84\x8D\x84\x26\x86\x83\x7C\x4E\x8F\xC0\x7B",
			"\xC8\x57\x72\x50\x82\x9F\x84\x51\x85\xA8\x80\x55\x80\x2B\x84\x15\xAF\x0A\x9F\x84\xB1\x84\xBC\x80\x91\x86\x46\x8E\x2B\x86\x14\xA6\xE8\x0A\x85\xBB\x84\x53\x84\x77\x83\x55\x8D\xD0\x6D\x89\x5C\xEB\x34\x85\x53\x7B\xD9\x5D\x48\x60\x5A\x8F\x17\x8E\x16\xAB\x9A\x0E\x5A\x33\x45\x55\x02\xCC\x49\x15\x06\x94\x4A\x05\x04\xC6\x48\x75\xEF\x53\x3A\x84\x40\x02\x42\x8D\xB0\x7A\xFF\x6A\x0A\xB1\x43\x39\x38\x6F\x7F\x25\x3F\x95\x52\x7D\x72\xD8\x0D\x60\x6A\x85\x7C\x42\x76\x84\xAE\x50\x57\x83\x1C\x82\x04\x9A\xE4\x67\x85\xC7\x4A\x57\x76\xB1\x87\x32\x89\x2B\x9C\x15\x80\x0B\xC5\x85\xCE\x82\x66\x84\xD7\x70\x5F\x88\x21\x9B\x10\x8A\x0B\xA9\x82\x00\x87\xF8\x82\xAE\x84\x60\x86\x20\x89\x01\x84\x0B\xB2\x85\x01\x87\x56\x87\xA9\x87\x60\x8D\x21\x8B\x18\xBF\x0A\x8C\x7B\x0C\x87\x15\x86\xC0\x81\x22\x87\x31\x83\x15\x90\x0C\x8A\x86\xFE\x84\x19\x59\xEA\x63\x46\x41\x02\x1E\x2A\x60\x00\x54\x84\x6F\x68\xA7\x82\xBE\x82\x5C\x81\xEE\x7A\x13\xB0\x6E\x08\x83\x21\x87\xFD\x5B\x83\x87\x92\x31\x29\x9C\x5F\x5E\x81\x4A\x74\x78\x76\x26\x75\x53\x6E\x16\x8E\x10\x09\x13",
			"\x88\x6B\x20\x01\x3A\x80\x1A\x55\x03\x36\x67\x81\xC5\x20\x1A\xAA\xD9\x1C\x76\x5F\x37\x67\x3F\xD0\x85\x34\x36\x34\x90\xC2\x60\x0B\xAC\x44\x01\x72\xB5\x6C\xEF\x72\x21\x04\x34\x8F\xE4\x0D\x0D\xF0\x6A\xB0\x83\x27\x54\x00\x7D\x6A\x87\xC9\x37\x1A\xBB\xD5\x59\x86\xB5\x85\x7B\x85\x55\x7A\x7A\x47\x48\x73\xC8\x64\x0D\xA7\x84\x11\x78\x6E\x75\x03\x35\x29\x8C\xA1\x3B\x04\x2F\xE5\x75\x85\x29\x77\x89\x73\xB0\x80\xB9\x44\xFF\x65\x14\x8C\xFC\x74\x86\xD4\x85\xA2\x82\x44\x03\x29\x8C\xA1\x3D\x04\x1E\x95\x1C\x01\x28\x87\x82\x00\xE0\x87\x4C\x80\x00\x1E\x04\x1F\x0B\xF1\x34\xBF\x48\xD2\x70\xC8\x84\x62\x85\x17\x14\x17\x89\x0C\xC5\x84\x84\x84\xCD\x83\x79\x87\x63\x80\x39\x80\x15\x99\x0C\xB9\x84\xEE\x83\x61\x84\xA2\x85\xBE\x7B\x2F\x91\xD0\x5D\x0C\xC9\x85\x1B\x87\x89\x85\xE8\x83\x59\x82\x31\x84\x1D\x94\x07\xA2\x87\xA5\x86\x12\x85\xCC\x80\x74\x89\x3A\x95\x18\x91\x03\x97\x87\x3F\x85\xC7\x85\x02\x80\x59\x80\x3B\x87\x14\xBD\x0B\xF3\x81\x6A\x3B\x06\x31\xB6\x37\x92\x37\x09\x1E\x2A\x56\x02\x01\x87\x04\x02\x4C\x03\x0B\x3F\x69\x89\xAE\x75\xEA\x64",
			"\x0B\xD1\x38\xDF\x82\xC7\x84\xE5\x87\x61\x8C\x27\x93\x15\xA5\x66\x1B\x87\xFC\x85\x60\x85\xE4\x83\x47\x89\x39\x95\x1D\x9C\x0E\x91\x86\xA7\x86\x39\x5B\xE7\x86\x7A\x81\x3D\x92\x1D\x90\x0F\xDD\x80\xDE\x87\xDB\x87\xE8\x82\x75\x8C\x38\x80\x14\x96\x0C\x8B\x79\x9A\x86\xF1\x85\xEB\x86\x49\x85\xFB\x34\x1D\x9B\x0F\xEF\x87\x9D\x86\x87\x86\x50\x64\x17\x3A\x3B\x85\xCD\x3D\x0E\xFC\x57\xBF\x86\x32\x86\x43\x02\x78\x82\xCA\x24\x1E\x86\xEC\x46\x87\x0E\x72\x2C\x41\xD9\x84\x65\x8E\x3E\x93\xC8\x45\x10\x8B\x49\x9F\x01\x10\x74\x94\x00\x66\x85\x3E\x9D\x15\x8B\x0F\xDF\x87\x0E\x86\x08\x8B\x85\x85\x61\x83\x41\x91\x5D\x69\x0F\xD2\x87\x96\x86\xF8\x84\xF6\x85\x60\x8D\x22\x8B\x1D\x9C\x0F\xE0\x87\x0F\x89\x00\x87\x07\x89\x82\x86\x08\x87\x20\x8B\x0E\xE3\x87\xAE\x87\x06\x8B\x21\x5B\x95\x3E\x3F\x9C\xC8\x58\x82\x74\x80\xB4\x53\x38\x34\x03\x88\x85\x8C\x3E\x99\x20\xB1\x0F\x95\x88\x98\x87\xE6\x87\x06\x8C\x82\x81\x19\x9B\x27\x63\x10\xB8\x88\xB1\x87\x76\x3E\x09\x8D\x72\x87\x3E\x9B\x21\x9A\x0C\xB2\x45\x0D\x30\x79\x67\x8C\x41\x8D\x43\x08\x8D\x2E\x77\x09",
			"\x9B\x51\x29\x01\xD2\x30\x14\x01\xD3\x4E\x32\x81\x1F\xB0\x0D\xE8\x86\x46\x89\x1C\x8B\xF4\x86\x63\x8A\x43\x87\x21\xAB\x0F\xE6\x87\x31\x87\x0B\x8A\x15\x8B\x8C\x8E\x1E\x83\x22\x8C\x0F\xDB\x88\xAC\x87\xEC\x86\x79\x82\x71\x83\x79\x45\x02\x25\x66\x04\x01\x4C\x55\x2E\x8B\x5A\x85\x8A\x81\x42\x98\x20\x85\x11\xDE\x88\x6A\x89\x14\x88\x0D\x88\x8C\x87\x06\x9F\x21\xBD\x10\xDF\x88\xBB\x7A\x33\x8A\x04\x8F\x8F\x89\x47\x95\x0A\x9F\x07\x8D\x30\x4A\x01\xD2\x30\x23\x01\x8E\x8F\x3F\x52\x08\x07\x7E\x1C\x34\xB1\x00\xAF\x48\x2C\x07\x0E\x6E\x0A\x02\x8C\x6F\x02\x07\x87\xB0\x37\xB3\x85\x6D\x01\x71\x89\x16\x19\x1E\x7B\x81\x0D\x30\x8F\x88\x64\x35\x24\x8C\x7F\x53\x49\x8A\x8A\x55\x12\xD2\x71\x1F\x31\x4B\x88\x72\x65\x85\x87\x22\x07\x87\x6E\xAB\x0A\x02\xA1\x89\x28\x3B\x28\x8B\x58\x70\x00\x05\x25\xB5\xC6\x04\x02\xA7\x88\x28\x71\x2A\x88\x93\x87\x05\x42\x1B\xB7\x10\x84\x89\x1C\x88\xD4\x85\x21\x8C\x8F\x8B\x47\x8E\x20\xB2\x11\xE7\x88\x81\x84\x31\x89\x1D\x8C\x8C\x88\x17\x82\x24\xAA\x0F\xC3\x89\xC6\x88\x34\x89\x48\x65\x01\x3D\x06\x05\xCD\x04\x03\x32",
			"\x4E\xC5\x00\x95\x87\x84\x86\x5C\x88\x09\x45\x19\x9C\x68\x75\x3A\x42\x73\x00\x42\xE8\x32\x0A\x4C\xA1\x3E\x05\x26\xB9\x15\x84\x8C\x72\x62\x82\x3A\x8E\x42\x80\x90\x71\x1B\xAC\x0C\x9F\x30\x61\x7B\x19\x88\x20\x89\xEE\x7B\x89\x4A\xD6\x11\x71\x15\x01\x5E\x4A\x4A\x01\x6F\x83\x65\x8F\xC0\x67\x1E\x8F\x72\x74\x88\x94\x43\xA7\x80\x3F\x8C\x88\x87\x18\x9F\xFA\x72\x13\xCE\x49\x0D\x30\xA4\x73\x8C\x42\x12\x02\x73\x51\x04\x37\xC1\x13\x01\xC3\x87\x38\x36\x00\x8D\x78\x86\x40\x8F\x22\x8F\xF0\x58\x73\x7B\x40\xBA\x84\xC5\x7A\xA3\x8E\x17\x8D\xC0\x13\x11\x9C\x34\x99\x00\x99\x4E\x26\x03\x9F\x8D\x49\x9E\x0E\xB6\x0B\xCF\x85\x27\x8B\x8A\x88\x26\x46\x89\x1F\xE8\x5E\x2A\x4B\xF5\x05\x33\x96\x85\xB2\x60\x47\x8E\x8E\x8E\x41\x9A\x20\xB8\x11\xC1\x89\xA6\x86\x9C\x88\xF9\x85\x98\x8F\x2F\x84\x09\xB6\x14\x84\x8A\x2A\x88\xEA\x85\x78\x4F\xA7\x88\x4C\x97\x23\x80\x15\xBC\x8A\x32\x58\x96\x8A\xA3\x53\x72\x43\x89\x4F\x29\x87\x90\x31\x8A\x75\x68\x6A\x84\x40\x8F\xCD\x59\x52\x8C\x19\x9E\x12\xCB\x89\xEE\x82\x8C\x8A\x4F\x8F\x97\x8C\x2A\x90\x26\xBD\x14\xC2\x85",
			"\x7E\x89\xAE\x89\x7F\x81\x3E\x7E\x4C\x97\x22\xB5\x06\x57\x8A\xC7\x89\xB0\x7A\x56\x8A\xF5\x71\x56\x99\x10\x9E\x15\xC2\x8A\xAB\x82\xAE\x8A\x5B\x8A\xA7\x89\x22\x82\x21\x84\x15\x8D\x30\x5F\x3C\xBE\x40\x43\x5F\x52\x7F\x06\x04\x29\x98\x11\xB7\x8A\xDE\x4B\x83\x88\x17\x5D\xAA\x80\x58\x87\x22\xAF\x15\xDC\x88\xD2\x88\xA2\x8B\x20\x8A\xAC\x8C\x43\x80\xF1\x31\x7B\x1C\x34\x6E\x89\xA3\x63\xF5\x4F\x52\x73\xCF\x26\x0C\xA6\x81\x6B\x8A\x5B\x88\xC1\x8A\x96\x50\x9D\x8D\x47\x79\x1B\xA5\x10\x8E\x72\x0B\x62\x43\x82\x66\x89\x76\x53\x5A\x9A\x22\xB6\x10\xD9\x88\x41\x89\xB4\x8B\x33\x8C\xAE\x85\x43\x86\x2A\xB2\xD4\x00\x00\x33\x86\x54\x59\xCF\x38\x59\x39\x48\x81\x43\x75\x16\xAF\x71\x06\x03\xDB\x88\x5F\x52\x21\x04\xCC\x26\xE0\x48\x9F\x07\x71\xB6\x67\x0F\x32\x8A\x3D\xB4\x77\x40\x49\x6B\x71\x16\xFF\x3B\x42\x63\xD8\x89\x03\x33\xB6\x81\xC5\x3A\x2D\xBF\xED\x4E\x8B\x4D\x70\x89\x00\x74\x88\x06\x52\x11\x1D\x2D\xBE\xA5\x13\x51\xC0\x8B\xC2\x33\x70\x89\x75\x6F\x81\x26\x2E\xB3\x0B\xEB\x02\xF0\x85\x78\x8B\xB4\x83\x2D\x0D\x3B\x74\x08\x31\x09\x8A\x62\x0E",
			"\x72\xE9\x62\x78\x8D\x63\x85\x5A\x89\x2D\x89\x16\xF2\x8A\x06\x86\xA4\x88\x62\x8F\xB4\x85\x58\x86\x2D\x92\x82\x05\x51\x0C\x84\xD9\x89\x69\x33\xBA\x87\x30\x53\x2E\x9D\xE1\x0E\x02\xD3\x8A\x22\x52\x44\x04\xA1\x5A\x29\x86\x08\x16\x17\xBA\x63\x07\x49\x43\x70\x77\x89\xC2\x32\x11\x10\x17\x9D\x17\xCB\x7E\x7A\x80\x77\x35\x7E\x8B\xB9\x8B\x5F\x92\x39\x7E\x17\x85\x33\x01\x8D\xC2\x30\x81\x8D\x30\x37\x60\x88\x81\x45\x66\x0A\x8C\xDA\x8B\x06\x8D\x61\x31\xAD\x59\x5F\x8C\x25\xBA\x06\x31\x8B\xEB\x8A\xE7\x85\x5A\x06\x76\x64\x0E\x69\x2F\x8E\xE4\x34\x5F\xE9\x42\x87\x73\xB7\x5D\x10\x5A\x49\x82\x0E\x33\x18\xDE\x4A\x72\x85\x6B\x69\x44\x51\xC7\x81\x88\x2D\x17\x91\x0B\x81\x02\x37\x8C\x26\x64\x8F\x8B\x22\x7E\x4F\x87\x11\x2D\x17\xE3\x61\x84\x8B\x1F\x8F\xB8\x87\x3A\x7D\x56\x91\x2F\xB3\x13\xF0\x8A\xF4\x8B\xA3\x8B\x93\x8B\xBE\x8E\x5A\x99\xF8\x33\x14\xCC\x89\xEF\x8A\xD4\x8A\xED\x84\xA6\x81\x54\x94\x32\xB5\x14\xF0\x8B\x93\x76\x65\x8A\x6A\x8C\xCB\x82\x5F\x85\x2B\x98\x19\xD1\x8C\x45\x8B\x2F\x8F\x26\x55\x0A\x4C\xA1\x3B\x2B\x85\x66\x3D\x01\xC0\x86",
			"\x00\x00\x2F\x05\x30\x36\x62\x9A\x13\x63\x17\xEE\x89\xF5\x8B\x3C\x87\xF3\x83\xB5\x8D\x58\x93\x2B\xBD\x19\xCE\x8C\x87\x8B\x34\x88\x6B\x8C\x98\x83\x65\x82\x34\xBF\x19\x9D\x88\x5D\x8C\x43\x8E\x61\x8B\xD0\x81\x4D\x88\x33\x8D\x60\x19\x3F\x6D\x8C\xAF\x49\x52\x4E\xE5\x7D\x47\x80\x20\x95\xF5\x13\x8A\xB5\x02\xCC\x89\x6B\x42\x79\x83\x66\x87\x33\x95\x19\xFC\x8C\x8B\x8D\x43\x8E\x30\x8C\xD1\x82\x39\x91\x1A\x75\x06\x73\x84\x03\x8B\xBA\x85\x40\x07\xBC\x81\xFB\x4A\x32\xBF\x03\x28\x8D\x69\x02\x56\x8D\x5F\x01\x21\x61\x6B\x99\xE1\x20\x81\x11\x8D\xFC\x56\x41\x01\x9C\x88\x10\x06\x94\x41\x04\x19\x09\x83\x01\x92\x51\x3A\x8F\x50\x5C\xC9\x87\x57\x92\x08\x23\x09\xC8\x35\xA1\x00\x46\x88\x9A\x8B\xB1\x8E\x67\x81\x35\x8E\x1B\xF6\x8B\x6A\x8D\x3C\x8F\x96\x8E\xD3\x81\x6D\x93\x23\xBB\x19\xE4\x8C\x85\x8D\x26\x8C\xA2\x8A\xBE\x8E\xD7\x62\x33\x99\x19\xD2\x8D\xD7\x86\x9F\x82\xB6\x8B\xD4\x82\x6A\x99\x29\x87\xC4\x5B\x89\x13\x72\x78\x88\xA8\x88\xDA\x89\x68\x83\x37\xA6\x1B\xCF\x8D\xEE\x8B\x65\x8C\x57\x82\xB1\x8B\x6E\x91\x37\x88\x09\xF4\x8D\xD8\x8D\x40",
			"\x8E\x49\x88\xDD\x8F\x4E\x99\x07\xA5\x66\x65\x61\x85\x33\x0B\x63\xC1\x42\x10\x6A\xAC\x5C\x34\x9B\x11\xCC\x8A\x42\x62\x1B\x67\x5A\x07\xDB\x59\x62\x9A\x32\x93\x08\x18\x72\xD2\x84\x7C\x8C\xB5\x8D\xDD\x82\x71\x98\x2A\x9D\x1A\x96\x8E\xDF\x8C\x29\x8E\xBE\x8D\xE2\x87\x71\x9D\x38\x99\x1C\xE9\x8C\x14\x8E\x30\x8C\xB9\x8A\x57\x41\xE4\x71\xE2\x11\x11\xFC\x57\x27\x8F\x5B\x8B\x59\x72\x30\x6D\xAB\x20\x91\x52\x04\x47\x82\x33\x65\x38\x35\x68\x8E\xAC\x82\x1C\x1C\x24\xBD\x05\x41\x8C\xB8\x3F\x22\x8C\x5F\x43\xB2\x7D\x51\x93\xE9\x1C\x68\x02\x3F\x46\x55\x1A\x86\xC1\x8B\xD3\x87\x6D\x93\x38\x9C\x1B\xEE\x8D\x3B\x8B\x6C\x8C\xC7\x8F\xE3\x8C\x6C\x80\x34\xA4\x1A\xD0\x8C\x9F\x8D\x7C\x8F\xD3\x8E\xCB\x81\x72\x97\x1B\x8B\x1C\xC8\x8E\xCF\x78\x4D\x8D\x00\x46\xDB\x82\x6F\x92\x3A\xA5\x1B\xB5\x78\x5C\x8F\xA8\x8C\x8F\x82\x51\x86\x66\x8B\x1E\x83\x19\x8E\x8E\xDD\x86\xD8\x4B\x90\x80\xEB\x8D\x5A\x95\x36\xA0\x1C\xBE\x88\x4B\x8F\xAE\x8C\xD8\x81\x2C\x8C\x76\x90\x1E\x67\x1A\xCF\x6E\x02\x53\x5F\x51\x7F\x65\x01\x32\x1D\x73\x11\x6E\x19\x87\x48\x1A\x01\x38\x8C",
			"\x07\x02\x30\x63\x78\x8A\x13\x85\x04\x5D\x3C\x32\x51\x03\x4B\x06\x07\x17\x61\xA7\x3A\x39\xB3\x88\x49\x87\x45\x8E\x8E\x42\x67\x8E\xEB\x80\x6F\x93\x36\x98\x1C\xF2\x8E\x97\x8E\xB1\x8D\xE6\x8E\xED\x8D\x74\x9B\x36\x8A\x1D\xA2\x8E\xEF\x8C\x76\x8F\xD1\x8D\xAA\x7E\x29\x94\x3C\x92\xBE\x5A\x8E\xAF\x87\xB8\x8E\xE6\x8E\xE3\x89\x4C\x95\x3B\x8D\x1A\xF7\x8D\x18\x80\xD7\x8D\x75\x75\x36\x05\x7A\x86\x3A\x93\x19\xA8\x8F\x95\x8C\xD0\x8D\xD2\x8B\xE3\x8A\x7B\x8C\x0E\xB2\x1E\xD0\x8E\x55\x80\x2F\x59\xD9\x8F\x98\x86\x2D\x8D\xB3\x59\xC1\x43\x74\xDF\x50\xBE\x8D\x69\x37\xEF\x88\x43\x41\x3C\x8A\xC5\x05\x8F\x5A\x52\x83\x00\xF4\x88\x33\x67\x40\x48\x3C\xB3\xC5\x12\x02\x8B\x8F\x37\x84\xEC\x30\xD3\x8A\xC6\x5E\x25\xAC\x0C\xF3\x86\x91\x8E\xD6\x8F\xEA\x8C\xE9\x85\x6F\x96\x3C\xA2\x1F\x9C\x8F\xE5\x8F\x70\x8E\xC6\x8B\xEA\x8A\x68\x82\x3D\x9F\x1E\xE8\x8E\x20\x88\xE2\x8F\xD5\x8A\xF5\x81\x33\x98\x3D\xB0\x1D\xBD\x8F\x6D\x8F\xAA\x8C\xB8\x88\x45\x71\x76\x88\x3F\x95\x04\xE4\x8E\xBF\x8E\x77\x6D\x5A\x04\xE1\x89\x7E\x88\xD1\x76\x1F\xDA\x4B\x01\x91\xF6\x8E\xBD",
			"\x89\x8C\x89\x80\x9F\xFA\x40\x20\xF4\x8F\x57\x59\x9B\x8E\x8E\x89\xF1\x83\x38\x71\x91\x68\xB2\x7D\x8E\x9D\x48\xE6\x8F\x22\x4E\xF9\x85\x5F\x72\x08\x13\x1F\xED\x70\xC8\x4F\x0F\x90\x4D\x56\x21\x08\x78\x9C\x12\x85\x04\x59\x8F\xFD\x62\x61\x8C\x43\x06\xF1\x8A\x5A\x49\x32\xAA\x1A\xD8\x5C\x90\x8E\x0E\x36\xDE\x86\x21\x02\x82\x9C\x0B\x79\x00\x6F\x86\x3C\x85\x23\x8D\xEF\x50\xCF\x83\x79\x48\x41\x91\x71\x34\x00\x12\x5F\x1B\x02\x57\x48\x07\x01\x67\x96\x01\x0C\xD5\x7C\x38\x2C\x90\x2D\x4E\x40\x8B\x80\x8B\x7F\x80\x11\x3A\x20\xE7\x5E\x2E\x90\x6A\x86\x50\x60\xD6\x83\x6B\x97\x33\x94\x14\xC6\x8F\x54\x90\xDA\x8D\x0E\x3E\x07\x9F\xC8\x20\x42\x87\xC5\x42\x90\xFC\x56\x22\x92\xFE\x82\x21\x06\x84\x8A\x8A\x75\x00\x46\x52\x67\x90\xC3\x8C\x41\x05\x0C\x9F\x22\x7A\xE2\x48\x21\xAF\x8C\x56\x90\xA2\x74\xB1\x88\xFF\x86\x77\x8E\x21\xB4\x21\xF7\x7F\x97\x8C\x83\x89\x00\x8A\x0F\x9A\x77\x80\xC3\x7B\x9D\x1C\x90\x51\x38\x0D\x90\xF2\x4C\x4E\x6C\x62\x64\x08\x34\xC9\x50\x8A\x04\x02\x28\x42\x34\x72\x05\x93\xE5\x43\x3A\xA2\x0A\x90\x8E\x5C\x5D\x86\x8F\x03\x7A",
			"\xDD\x85\x11\x82\x8A\x6B\x66\x18\x41\x80\x91\x47\x3A\x20\x91\x22\x54\x88\x85\xCC\x07\x22\x85\x33\x8A\x90\xA7\x85\x9C\x37\x00\x97\x58\x8F\x42\x84\x0B\x0E\x91\xFE\x8E\xDB\x8C\xEF\x88\xFE\x84\x42\x86\x3D\x8B\x20\xFA\x8F\x6B\x83\x06\x33\xF1\x6B\x46\x44\x0A\x12\x78\x65\x02\x5E\x4A\xA6\x00\xBF\x8B\x59\x8B\x0E\x96\x75\x9C\x41\xAF\x20\xFF\x01\x68\x8B\xCC\x8A\x43\x71\x18\x91\x28\x82\xDD\x26\x09\xC8\x35\x9B\x91\x49\x53\x28\x02\x17\x92\x1C\x04\x45\xB4\x8A\x7D\x8F\xDD\x83\x3E\x92\x10\x47\xEC\x8B\x40\x7C\x3E\xA7\x08\x04\x90\xAE\x90\xF3\x8C\xF9\x89\x1B\x9A\x7E\x8F\x3B\xAF\x1F\xCD\x90\x0E\x87\x16\x8D\x55\x7D\x06\x93\x1F\x02\x96\x73\x07\x79\x8B\xF3\x02\xDB\x65\xE7\x8B\xE4\x8E\x7E\x8B\x45\xA0\x23\xC0\x88\xDA\x90\xCC\x8C\x58\x88\x02\x93\x7A\x97\x43\xB0\xFE\x0D\x90\xF4\x91\x6F\x92\xB5\x89\x2D\x04\x8E\x8B\x0B\x26\x23\xEB\x02\xE8\x91\xB5\x02\xED\x62\x28\x60\x2F\x85\x44\x4A\x17\xF4\x3F\x1F\x30\x6C\x90\x0E\x4D\xC0\x88\x7C\x5F\x76\x42\x18\xE3\x59\x1E\x65\xEB\x8B\xF5\x8A\x94\x32\x1D\x7F\x2F\xA7\xFB\x07\x48\xCF\x3D\xD8\x8A\x45\x96\x20",
			"\x04\x07\x9F\xC0\x0F\x7B\x35\x81\x1B\x93\x82\x01\x26\x91\x22\x5F\xEC\x3C\x42\x91\x17\x8E\x02\xAF\x58\x8F\x92\x44\x05\x66\x81\x61\x9E\xCC\x34\x01\x85\x51\xB5\x80\x62\x93\x8C\x42\x21\x9B\x48\x4C\x48\x91\xA4\x0E\x92\x1A\x8D\x88\x91\xDE\x8E\xE5\x84\x91\x86\x4A\x4E\x18\xE3\x48\x1A\x93\xC2\x31\x47\x93\x8C\x40\x92\x85\xCC\x23\x24\x93\x51\x25\x92\xA3\x51\x4A\x93\x8C\x4C\x92\x85\x8B\x42\xC5\x47\x92\x42\x62\x93\x90\x2A\x58\x08\x39\x90\x92\x39\x76\x24\x93\x51\x38\x93\x03\x4B\x86\x8F\x80\x45\x7B\x53\x48\xB0\x90\x15\x92\x85\x33\x9F\x92\x34\x71\x28\x97\x40\x43\x4A\x92\xE3\x45\x92\x80\x8F\xC2\x31\x52\x94\x70\x8B\x94\x92\xC6\x4D\x25\xEE\x90\x6E\x39\x57\x5A\x50\x67\x2D\x93\x79\x54\x4A\x84\xC6\x07\x46\x57\x93\xAA\x92\x1A\x96\xA3\x5A\x93\x96\x49\x4A\xC7\x2F\x38\x60\x93\x03\x4A\x58\x90\x0A\x74\x96\x98\x21\x66\x25\xD0\x70\x68\x93\xE6\x8E\x5A\x90\xFB\x8A\x94\x8B\x4C\x8E\x04\x74\x92\x6B\x78\x28\x06\x37\x8B\x22\x77\x32\x95\xEA\x4C\xD1\x73\x03\x90\x8D\x89\x70\xE2\x8B\x3E\x03\x2E\x53\x0F\x3C\x74\x2C\x86\x2C\x66\xE1\x03\xBF\x5C\x22\x0B",
			"\xEB\x53\x0F\x29\xCE\x45\x8F\xA9\x6D\x17\x38\x35\x96\xD5\x89\x84\x95\xFF\x62\x00\xA8\x91\xB0\x90\x6F\x92\x3B\x93\xFD\x8F\x75\x9A\x23\xBA\x23\xB2\x93\xEC\x8E\x7C\x92\x3D\x90\xF8\x81\x9B\x8B\x47\xA1\x1E\xAF\x91\xF5\x90\x56\x93\xF1\x32\x12\x5E\x77\x9E\x2A\x7C\x01\x85\x33\x89\x92\x99\x89\xB8\x87\x81\x7F\xEC\x38\x1B\xAC\x11\xB8\x93\xB5\x92\x50\x4E\x6C\x4A\x37\x92\x9C\x80\x26\x91\x27\xA9\x85\xF9\x91\xD9\x93\xEC\x82\xF8\x84\x21\x8B\x27\xA9\x13\x80\x82\xDE\x92\x56\x34\x67\x8F\x58\x71\x9E\x84\x4F\xA0\x27\xE7\x93\xDF\x93\x46\x58\x3C\x96\x44\x7E\x8C\x86\x5B\x7B\x26\xD4\x8E\xC1\x93\x77\x92\xA9\x70\x1A\x91\x9F\x94\x4D\xA5\xA6\x5C\x93\xD9\x93\xDC\x91\xC7\x85\x3D\x9F\x24\x14\x4F\xB7\x26\xBE\x93\xBB\x8F\x67\x90\x75\x92\x3E\x9C\x6F\x82\x37\x84\x15\x9F\x30\xC5\x6E\xA8\x71\xA7\x70\x5A\x7D\x80\x37\x41\xAD\x1A\x8C\x48\x12\x02\x30\x90\xB2\x35\x9A\x8E\x95\x65\xF9\x5D\x23\x8D\x30\x6C\x91\x28\x38\x1B\x02\xE2\x5B\xA1\x81\x3A\xB2\x0E\x98\x94\xA5\x33\x0E\x97\x15\x6A\x44\x92\xA5\x56\x50\xA9\x1D\xE7\x8F\x11\x91\x4C\x8F\x30\x93\xDF\x8F\x57",
			"\x8C\x4D\xB9\x70\x62\x90\xC8\x34\x37\x02\x57\x4A\x46\x90\x08\x8E\x2D\x85\xA2\x7D\x32\x0E\x02\x2F\x90\xB2\x32\x0D\x0E\x55\x4B\x03\x31\x19\xE8\x00\x77\x61\x34\x00\x9D\x8E\x48\x4B\x9E\x86\x40\xAB\x1D\xF9\x93\xD7\x93\xD7\x8D\x2A\x93\xAB\x85\x9D\x8C\x2C\x8D\xCD\x78\x93\xEF\x92\xDC\x7E\xC4\x5D\x01\x3A\xA3\x91\xE2\x3C\x28\xFC\x57\x3E\x95\x31\x92\x41\x00\x48\x9A\x14\x62\x52\x87\x90\x1F\x83\xD6\x93\xD8\x54\x7F\x93\x23\x63\xA0\x96\x4F\xAD\x23\xD3\x8E\xFE\x92\xED\x91\x76\x84\xAC\x85\xA6\x81\xBB\x78\x90\x54\x94\xA5\x33\x2B\x94\x2D\x89\x4B\x9D\x81\x8E\x08\x1C\x29\xAA\x8E\x5E\x94\x1C\x48\x98\x96\x49\x97\x7A\x87\x52\x91\x29\xED\x94\x00\x94\xAB\x5F\x9F\x90\x49\x97\x9F\x8C\x53\x84\x15\xB1\x90\x54\x47\x31\x6D\x44\x50\x4E\x9C\xA1\x32\x53\x8F\xAF\x00\x00\x74\x94\x00\x6F\x07\x37\x4E\x90\x18\x65\x08\x39\x29\x8B\x49\x7B\x95\x66\x8D\x9F\x96\xBE\x70\xA8\x85\x40\xB1\x1F\xF1\x8A\x4D\x94\x4D\x94\x36\x67\x01\x93\xA8\x8E\xF0\x42\xC5\x38\x94\x0A\x03\x2A\x97\x23\x3E\x51\x9A\x61\x4E\x08\x11\x2A\xCA\x6D\x93\x95\x20\x97\x90\x94\x9D\x8C\xA7\x98",
			"\x86\x63\x29\x9D\x53\xA5\x95\x50\x96\xD3\x89\x49\x95\xD7\x69\x53\xBA\x27\xEF\x93\xA4\x94\x5D\x95\xD9\x7F\x54\x99\xC3\x2A\x55\x97\x72\x2C\x95\x0D\x84\x85\x03\xAB\x92\x76\x71\xAB\x9D\x52\xB3\x2A\xEA\x93\x61\x95\x4D\x94\xFA\x85\x53\x9C\x8D\x87\x51\xA0\x2A\x84\x94\xA2\x95\x44\x84\x94\x92\x58\x9D\x18\x4C\x42\xAE\x1A\xBB\x86\x05\x72\x00\x6F\x3D\x5E\x14\x32\x6D\x7A\x0D\x25\x2B\xF6\x8C\xFC\x4B\x70\x96\xB2\x6A\x5A\x5D\x3A\x68\xC7\x2E\x2B\xC6\x44\xEF\x94\xEB\x51\xBC\x95\x91\x53\xAF\x9B\xE5\x57\x09\x64\x95\x15\x4A\x69\x56\x29\x35\x01\x3B\xAF\x99\x57\xAB\x85\x26\x31\xE0\x95\x61\x8D\xBA\x96\xE3\x72\xAE\x9F\x57\x91\x0D\x85\x96\xA0\x4D\x7E\x97\xC0\x91\xBC\x72\xBB\x63\x57\xA9\x1A\xA6\x31\x4E\x8B\x72\x87\x4A\x48\x61\x86\x00\x94\x57\xB0\x2B\x97\x96\xF2\x94\x8C\x96\xC5\x94\xAF\x6B\xB2\x20\xB7\x4B\x2C\x8E\x55\xA6\x30\x13\x3B\x1B\x97\x63\x93\xD3\x58\x57\xA4\x2C\xAA\x54\x00\x96\x7F\x95\xC2\x97\x60\x9B\xAE\x86\x58\x9E\x2B\xD3\x78\xD8\x46\x95\x94\x69\x5B\x62\x92\xA8\x88\x58\x87\xA6\x32\x96\x76\x87\x96\x94\x43\x04\x78\x75\x6B\x87\x59",
			"\x98\xB9\x26\x96\x34\x97\xE3\x58\xD0\x96\x66\x93\x69\x54\x31\xB8\x2C\xA2\x84\x15\x90\xE4\x4E\x29\x35\x97\x79\xA8\x81\x5A\xAE\x26\x8D\x96\x04\x96\x9D\x97\x94\x5B\x68\x92\xB5\x98\x43\x8E\x2D\xD6\x96\x44\x96\x94\x97\x73\x94\x6A\x90\xB5\x8B\x59\xAF\x2C\xDC\x96\x30\x96\x97\x95\x8B\x91\x6C\x9E\xB5\x83\x5B\xA0\x2D\xE7\x96\x5B\x97\xB4\x97\xD7\x92\x6D\x96\xB6\x8C\x5B\xAA\x28\xBE\x96\xCB\x54\xB4\x95\x49\x88\x6E\x97\xAE\x91\x5A\x9D\x2D\xE1\x4C\x29\x97\x41\x44\xEA\x32\x63\x95\xB1\x9D\xA3\x75\x2B\xD7\x4D\xA6\x91\xF8\x7C\x08\x6C\x17\x36\x8A\x35\xD8\x4B\x27\xF7\x96\x11\x8F\xAB\x95\x40\x00\x26\x63\xB2\x8A\x5C\x80\x04\x3C\x96\x7D\x03\x0B\x63\xFC\x87\x68\x9F\xB8\x94\x5C\xB1\x2D\xA5\x33\x85\x96\xCB\x94\xE4\x97\x6D\x9E\xB8\x80\x46\x96\x2E\xFC\x95\x6E\x97\x66\x92\xE5\x91\x62\x91\xC5\x26\xC5\x1B\x2E\xAE\x85\x9D\x96\xD2\x94\xEA\x91\x6B\x9D\x66\x52\x5B\xAD\x2D\xBE\x91\x79\x97\xCE\x95\xC0\x94\x61\x94\xB6\x98\x4E\x9D\x2E\xA7\x97\x9F\x33\xCF\x97\xE8\x94\x3B\x49\xB2\x30\x58\xBA\x2E\xF0\x96\xA0\x97\x07\x96\xEB\x92\x0E\x94\xB7\x9B\x5D\x85",
			"\x2F\xF0\x96\xAA\x97\x4B\x3A\xEF\x90\x79\x96\xB9\x96\xB9\x45\x28\xA9\x75\x2F\x3D\xF6\x74\x42\x66\x72\x9A\xC6\x74\x08\x11\xFE\x3D\x96\x9D\x96\xC2\x75\x5F\x07\x7A\x9D\x17\x10\x17\x8B\x2F\x9D\x97\x86\x97\xE7\x95\xED\x97\x38\x5F\xBD\x8C\x5D\xA5\xF8\x29\x75\xBD\x97\xD0\x97\x89\x01\x78\x97\x85\x95\x5A\x88\x2D\xE6\x97\xCC\x7A\xC2\x52\xE5\x91\x7E\x98\xBD\x90\x5F\x96\x2E\xB3\x97\x78\x97\x17\x87\xF8\x97\x7D\x9E\xBE\x9F\x4E\x56\x2E\xCC\x96\x9B\x89\xDF\x95\xE7\x94\x7D\x91\xC0\x90\x5B\xB8\x2E\xBA\x03\x84\x97\xF9\x8D\xEA\x96\x78\x9D\xB9\x80\x60\xB5\x1C\xFF\x97\x96\x96\x57\x8B\x29\x5B\x6F\x93\xC1\x9E\x11\x21\x2C\x96\x97\xE1\x96\x89\x96\xF9\x94\x80\x92\x1C\x1C\x60\xA2\xED\x40\x97\x02\x99\xD2\x71\xFA\x92\x46\x05\xBE\x9D\x5F\xA8\xE2\x25\x98\x88\x97\x55\x8F\xFC\x94\x81\x96\xBE\x99\x60\x95\xD7\x23\x98\x4D\x96\xF3\x94\xFE\x90\x6B\x96\xC2\x89\x5E\xBA\x06\x1E\x98\xDA\x87\x01\x98\x0B\x9E\x84\x98\xC3\x91\x59\x8C\x2F\xA0\x98\x3F\x98\x1D\x9A\x43\x00\x08\x0B\x48\x9C\xE3\x06\x31\xC7\x98\x48\x99\x24\x9A\x12\x9B\x89\x93\x81\x96\x44\x8D\x31",
			"\xCF\x98\x8A\x95\xD7\x8A\x14\x7A\xD3\x84\xC5\x9F\xDA\x15\x31\xD6\x35\x57\x98\xDC\x3D\xB9\x96\x86\x9C\xC5\x92\xE9\x5E\x31\xC2\x7A\x60\x99\x95\x4A\xC7\x70\x80\x74\xC6\x86\xE3\x65\x31\xBE\x79\x33\x6C\x6D\x70\x6E\x8A\x8D\x9A\x8B\x6C\x63\xAE\x31\xA7\x92\x6B\x98\x3B\x70\x14\x77\xD9\x34\xC7\x83\x23\x75\x31\xD2\x71\x77\x99\x39\x9A\x1D\x9F\x18\x7C\x8B\x3D\x63\x91\x14\xFD\x87\x7F\x98\x18\x4A\x1F\x98\x90\x92\xCA\x3F\x76\x5D\x25\xEF\x52\xD2\x62\xDB\x65\xEA\x60\x5E\x81\x5B\x99\x2F\xBB\xBA\x42\x57\x74\x80\x43\x9A\x2C\x62\x0E\x59\xC8\x90\x9F\x62\x18\x8E\x84\x10\x8C\x8E\x5E\x44\x00\x92\x94\x18\x67\x64\x9E\xA5\x15\x99\x6B\x7F\x7A\x7C\x26\x99\xE8\x75\x72\x85\x08\x1C\x32\x8E\x02\xB5\x80\x49\x99\xB1\x67\x24\x5D\xCF\x69\xF4\x5E\xF2\x17\x99\x0A\x03\x46\x99\x29\x9D\x88\x5B\x07\x8D\x63\x1D\x32\x93\x99\xE5\x79\x7B\x79\xDE\x7A\x94\x91\xCB\x99\x64\xB9\xF8\x0A\x02\xA7\x98\x85\x01\x2A\x9A\x12\x57\x01\x74\x64\xBA\x02\xBB\x99\x17\x93\x5E\x98\x29\x99\xCA\x70\xCC\x92\x08\x34\x01\xC3\x99\x6D\x53\xE3\x8F\x27\x9F\x98\x9F\xCA\x9C\x65\xAB\xFF\x4B",
			"\x99\x2F\x7D\x66\x99\x2D\x98\x39\x6E\xC9\x9F\x46\x60\x32\x98\x7F\xEE\x7D\x51\x9A\xCE\x79\x9B\x9B\x03\x9B\x66\x82\x33\xB7\x99\xAB\x98\x43\x51\x2E\x9F\xA5\x78\xCC\x81\x67\x8A\x33\xE3\x99\x9A\x99\xE5\x56\x33\x9E\x96\x9C\xCD\x98\x65\x8C\xC7\x0A\x99\xB0\x99\x6B\x98\x3C\x9F\x97\x95\xCE\x8A\x08\x0F\x33\xE8\x99\xFD\x62\x63\x9A\x2B\x9E\x95\x79\xCF\x85\x08\x32\x32\xCC\x99\xFD\x98\x8E\x90\x3D\x9D\x0D\x9E\x97\x89\x67\x82\x34\xB0\x79\xE0\x99\x82\x00\x23\x9E\x97\x98\xC6\x1B\x64\xB3\x33\xA8\x99\x00\x9A\x0B\x93\x43\x9A\x97\x95\xCD\x89\x66\xBA\x33\x86\x02\x8E\x98\x8B\x9A\x39\x9E\x20\x00\xCD\x9E\x2D\x9E\x18\xD3\x99\x03\x9A\xE2\x8A\x47\x9E\xA0\x94\xD1\x93\x78\x62\x34\xFE\x99\x0B\x9A\x7A\x64\x43\x9C\x02\x9A\xD1\x8B\x67\xB5\xF8\x1D\x9A\xEE\x99\x8F\x99\x19\x1B\x96\x9B\xC3\x50\x69\x98\x34\xF5\x99\x0E\x9A\x9B\x9B\x8A\x7D\x9D\x92\xD1\x92\x08\x07\x34\xE4\x99\xA6\x99\x8B\x9B\x4C\x9D\x9B\x98\x84\x54\xE9\x50\x34\xC4\x9A\x04\x03\x89\x98\x36\x99\x9E\x9A\xCD\x9E\x69\xA7\x33\x8E\x02\xF2\x64\x55\x99\x40\x9A\xA8\x98\xCF\x96\x66\xAC\x34\xD3\x9A",
			"\xFC\x99\xA4\x9B\x48\x9D\x20\x05\xD2\x92\x48\x88\x32\xD4\x99\x04\x9A\xAF\x9B\xF6\x7D\xA5\x9F\xC8\x8A\x6A\xA4\x34\x99\x9A\x08\x8C\x6F\x98\x5A\x9A\xA5\x99\xD3\x9F\x6A\xBB\x33\x95\x9A\xF2\x99\xB1\x98\x41\x05\x16\x82\x2C\x7A\x6A\xB5\x34\xF7\x99\x96\x98\xB5\x98\x6C\x8C\xAD\x9F\xD2\x8A\x68\xBF\x34\xCB\x9A\xF6\x98\x7A\x79\x57\x9B\xA5\x9B\xD6\x80\x6B\xB8\x35\xD5\x9A\x86\x9B\xAB\x98\x62\x99\xA8\x90\xD8\x81\x65\x8C\x36\x83\x9B\x8E\x9A\x97\x99\x5E\x9E\xAA\x9F\xD6\x98\x6A\xB0\x35\xA7\x9A\x72\x9B\x94\x9B\x22\x9E\xA8\x94\xD8\x9B\x6C\x91\x36\x9D\x9B\x0A\x03\xAC\x98\x31\x9F\xAC\x92\xDA\x85\x68\x8D\x36\xF7\x9A\x9A\x9A\xC8\x99\x41\x07\x9F\x9E\x10\x1D\x6B\xAB\x36\xA8\x9A\x4F\x9A\x9C\x99\x51\x9A\x9C\x90\xD2\x9C\x69\x81\x33\xA8\x9B\x32\x9A\xEA\x8E\x49\x9A\x9A\x91\xDA\x99\x6D\xA9\x35\x97\x9B\x47\x9A\xAA\x99\x42\x9B\xB6\x91\xD3\x85\x08\x3E\x35\xF1\x9A\x4D\x9A\x9E\x78\x3B\x9A\xB7\x91\xD5\x84\x6D\x99\x36\xED\x9A\x7A\x9B\x73\x23\x67\x9C\xB8\x91\xDD\x82\xF7\x46\x37\xF4\x9A\xBB\x9B\x77\x99\x6F\x98\xA1\x92\xD6\x9C\x6C\xA4\x35\xDB\x9B\xC5",
			"\x98\xAE\x99\x60\x98\xB9\x95\xDA\x92\x6D\x84\x04\x34\x9B\x93\x9B\xAD\x99\x65\x99\xA2\x95\xDD\x9C\x6D\xBB\x34\xE4\x9B\xB4\x98\xF3\x9B\x5E\x98\xBD\x9C\xDA\x9F\x6E\xA3\x36\xF6\x9B\x04\x03\x90\x9A\x69\x9C\xB9\x97\xD8\x81\x6E\x85\x04\x1F\x93\x3B\x93\xBF\x9A\x62\x9B\xBD\x95\xD7\x8F\x6D\xA3\x37\xC8\x9A\xF9\x9B\xD3\x9B\x81\x9F\xB6\x95\xDC\x9C\x68\x87\x37\x8D\x9C\x98\x9A\xD8\x98\x76\x9A\xBF\x90\x00\x08\x70\x8D\x34\xF2\x9B\x0B\x9C\xCB\x98\x86\x99\xB9\x91\xD6\x91\x70\x84\x38\x92\x9B\x06\x02\x0F\x9C\x4D\x98\xBA\x9B\xD9\x6D\x65\xBE\x37\xAE\x9B\x19\x9D\x07\x9E\x72\x9D\xBC\x92\xE1\x9B\x6F\x85\x75\x51\x99\xE9\x9B\xF9\x98\x54\x98\x00\x02\xD5\x9A\x70\x85\x36\xA7\x9C\xC0\x9B\x09\x9C\x8E\x9D\xBF\x96\xE1\x80\x6F\xB5\x37\xE2\x9B\xF7\x9A\x08\x9D\x4F\x9D\xC6\x9A\xDD\x97\x71\x83\x37\xB9\x9C\x21\x9C\xFA\x98\x8F\x9E\xBA\x9E\xE3\x83\x70\xAF\x37\xBE\x8E\x4F\x9C\x22\x9F\x74\x9F\xC2\x91\xDE\x9A\x69\x81\x38\xBE\x9B\x6E\x9B\xF3\x9A\x93\x9E\xAC\x98\xDB\x85\x72\xBF\x37\xC8\x9C\x5F\x9C\xFC\x9B\x92\x98\xC8\x92\xE6\x8A\x08\x2A\x38\xCC\x9A\x2D\x9C",
			"\xA7\x9A\x99\x98\xC6\x94\xE2\x8F\x6C\x8B\x37\xD7\x9C\x05\x9C\x21\x9D\x96\x9D\xCC\x9B\xE5\x86\x72\x93\x39\x80\x9C\x00\x00\x01\x9E\x7B\x98\x00\x00\xDF\x89\x71\x94\x38\xDD\x9B\xDF\x99\x1D\x9D\x8F\x9A\xC6\x95\xE2\x8B\x73\xB8\x39\xA8\x9C\x7A\x9C\x32\x9D\x85\x9D\xCF\x97\xE6\x9E\x72\x81\x3A\xE0\x9C\xD9\x9B\x5A\x83\x9B\x99\xB1\x9E\xE2\x93\x73\x82\x36\xF5\x9C\xB1\x9B\x3B\x9C\xA1\x9D\xB9\x94\x10\x02\x96\x5B\x3A\x94\x9B\x51\x9C\x45\x9C\x95\x9C\xD1\x96\xE7\x94\x71\xAC\x39\xB6\x9C\x6E\x9D\x43\x9D\x9C\x9A\xBA\x97\xD3\x9C\x72\x87\x39\x96\x9D\x82\x9C\x51\x9C\x1D\x87\xD4\x90\xE2\x9D\x74\x94\x3A\xF4\x9C\xED\x9A\x5D\x9C\xA9\x99\x61\x68\xE5\x92\x74\x88\x3A\xF3\x9A\x95\x9C\xBB\x98\xAB\x99\xD4\x9E\xEA\x8F\x74\x81\x39\x84\x02\xBC\x9C\x05\x9E\xAF\x9D\xD6\x9E\xE7\x8B\x74\x89\x39\xB3\x9C\x26\x9C\x67\x9D\x9B\x9E\xD0\x93\xE4\x9C\x73\x94\x3B\xC9\x9D\x0E\x9D\x6B\x9D\xA3\x9F\xB7\x9B\xED\x91\x96\x45\x3B\x89\x9C\x2C\x9C\x56\x9A\x9C\x9F\xD7\x9F\xE9\x81\x76\x8D\x3B\xA3\x9D\x79\x9C\x68\x9E\xAC\x9A\xDD\x94\xEB\x83\x6A\x94\x37\xFF\x9C\x68\x9D\x4B",
			"\x9E\x9A\x9C\xDC\x90\xEB\x9C\x76\xBB\x39\x93\x9D\xDF\x9C\x60\x9F\x75\x9F\xC7\x9A\xED\x9D\x77\x85\x04\x72\x65\xD1\x9D\x74\x9E\x3A\x9A\xC7\x97\xEF\x96\x76\xA9\x39\xCA\x9C\xFC\x9D\x26\x9D\x6A\x9F\xDC\x9F\xE1\x92\x76\xAB\x3B\x81\x9E\xED\x9D\x81\x9E\x95\x98\xDE\x90\xE9\x85\x75\x94\x3C\xAB\x9C\xA0\x9B\x63\x9D\x6B\x99\xE3\x95\xE5\x83\x74\x85\x3A\xE6\x9D\x63\x9C\x74\x9D\xC8\x9B\xD6\x9E\xDD\x9E\x74\xAC\x37\x9A\x9E\x26\x9F\x61\x9D\xC2\x9B\xE5\x94\xEF\x8D\x79\xAC\x3B\xAF\x9E\x25\x9E\x61\x9D\xBC\x9D\xC3\x93\xEF\x8B\x78\xA9\x3A\x8D\x9E\xAB\x9C\x71\x9D\xAB\x99\xDB\x9C\xF1\x8F\x76\xBC\x3C\xDD\x9D\x00\x9E\x7B\x9E\xAD\x98\xDF\x98\xEB\x98\x74\x9C\x38\x9A\x9D\x3D\x9F\x8D\x9B\xCD\x9B\xC4\x9E\xEE\x84\x7A\xA7\x3C\xF2\x9D\x48\x9E\x91\x9F\x8B\x9C\xE4\x9B\xEC\x9B\x70\x8C\x39\xFC\x9A\xC3\x45\xA8\x9E\x7A\x9A\xC4\x9D\xE5\x8A\x76\x82\x3D\xCC\x9D\x56\x9F\xB0\x9D\xD6\x9C\xE5\x99\xE8\x80\x7A\x80\x3A\xB9\x9D\xEF\x9C\x3A\x83\xB8\x40\xCE\x95\xF3\x8D\x7B\x8B\x3D\x8E\x9E\xFA\x9C\x88\x9D\x98\x9E\xE0\x99\x31\x42\x7B\x8C\x3C\xF7\x9E\x41\x9F\x87\x9C",
			"\xB6\x9E\xD1\x95\xF4\x85\x77\xBD\x3D\xEB\x9E\x75\x9E\x64\x9E\xC0\x99\xE7\x91\xF7\x83\x76\xB3\x3D\x9C\x9D\x17\x9E\xA5\x9D\xB5\x99\xF0\x99\xF7\x83\x7C\x91\x3C\xB5\x81\x8F\x9E\x54\x9F\xB4\x9A\xF2\x90\xEE\x91\x71\xA7\x3D\xDE\x9E\xAF\x9D\x6C\x46\xDF\x9F\xE7\x90\xF8\x8F\x7B\x8E\x3D\xDF\x9E\x6A\x9F\x7F\x9E\xD6\x9E\xE5\x94\xF5\x90\x79\xBA\x3C\x9D\x9E\xA2\x9E\xC4\x9E\xCF\x9B\xF3\x9B\xD8\x8D\x7D\x8C\x3E\xE9\x9E\x3B\x9F\xCC\x9D\xAF\x99\xF2\x95\xFB\x85\x7B\xA1\x3B\x82\x9F\xE3\x9D\xBD\x9E\xC4\x9D\x65\x43\xFA\x94\x7D\x8C\x38\xBE\x9F\x9E\x9E\xE0\x9F\xD0\x9C\xF0\x97\xF5\x91\x7D\xAA\x3E\xEC\x9E\x8A\x9E\xAE\x9F\xE7\x9C\xE0\x95\xF8\x9C\x7B\x8E\x3F\xC6\x9D\xD0\x9F\x91\x9C\xCE\x9D\xEB\x94\xFD\x8D\x7E\x82\xCB\x3A\x9F\x16\x9F\x7A\x9D\xEF\x9F\xD6\x96\xF6\x8A\x7E\xA8\x3D\xCC\x9F\x8E\x9F\xE2\x9C\xEF\x9F\xF8\x94\xFE\x9F\x7D\x95\x3E\xC1\x9F\xD9\x9A\xF0\x9E\xC2\x9A\xEA\x98\xF1\x9B\x7E\x93\x3F\x9B\x9E\xCD\x9E\x79\x66\xFC\x9C\xE6\x93\xFB\x8B\x7F\xA4\x3D\xED\x9F\xC9\x9F\xF7\x9F\xF2\x9F\xF2\x99\xFA\x98\x7E\x89\x3E\xDA\x9F\xB6\x9E\xEE\x9C\xFE",
			"\x99\xFD\x92\xFB\x94\x7F\x9C\x3E\x8B\x9F\x0A\xA1\x98\x9F\xCE\x9F\xFB\x9A\xFE\x82\x7F\xAC\x3F\xCC\x9E\xE5\x9E\x01\xA3\xF9\x9C\x00\xA3\x32\x4F\x7E\x87\x40\xDB\x9E\xF6\x9E\xF3\x9C\xE8\x9D\xE0\x93\xFC\x96\x17\x55\x40\xB6\x9E\xF5\x9F\x04\xA3\xFD\x9A\x02\xA0\xFB\x9A\x7F\xA7\x40\xF6\x9E\x93\x9E\xD3\x9F\xBE\x9A\xF8\x95\x0B\x8E\x81\x8D\x40\xE3\x9E\x52\x9C\xBC\x9C\xDC\x98\xF7\x90\xFB\x94\x80\xB7\x40\xFF\x9E\x31\xA1\x7C\x9F\x0E\xA0\xFD\x93\x01\xA5\x80\xAA\x3C\xDC\x9B\xD9\x9E\x10\xA2\x0A\xA2\x04\xAD\xFD\x8C\x80\x9E\x40\xFD\x9F\x16\xA1\xFF\x9C\x06\xA6\xFD\x93\x04\xBC\x80\x82\x8D\x4F\xA0\x0E\xA1\xF1\x9F\x14\xA1\x00\xA5\x05\xB4\x81\x86\x41\x95\x9E\xF3\x9E\x1C\xA2\xAA\x9A\x06\xAA\xF7\x99\x74\x9F\x41\xA0\x9E\x48\xA1\x0F\xA0\xEB\x98\xF9\x90\xEA\x83\x81\x95\x3F\xA5\xA0\x87\x9E\x2C\xA2\x18\xA6\xED\x92\x04\xA7\x7D\xA1\x3E\xE0\x9E\x0E\x03\xA3\x92\x54\x95\x06\x94\xF7\x90\x82\xA8\x40\x8F\xA0\xD2\x9E\x26\xA3\x02\xA4\x06\x9F\x02\xB1\x7E\xA1\x40\x9A\xA0\x6E\xA0\x3A\x80\x1F\xA0\xF2\x91\x05\xB9\x81\x94\x3E\xDD\xA0\x66\xA0\x42\xA3\x0F\xA4",
			"\xF4\x91\x04\xAD\x7A\xB3\x40\x91\xA1\x0A\x03\x45\xA2\xE6\x9E\xFF\x9E\x08\xA4\x83\x96\x3E\xDE\xA0\x92\xA0\x39\xA0\x10\xA5\xF3\x9D\x06\xAD\x82\xBB\x3C\x9A\xA1\xBB\x9F\x46\xA3\x18\xA5\x0E\xA7\x09\xBC\x70\xA8\x42\xE1\x9F\x7F\xA0\x2D\xA2\x0E\xA6\x0E\xA4\x02\xB5\x05\xAF\x42\xE1\xA0\xA3\xA0\x08\xA3\x0A\xA7\xF5\x96\xF4\x97\x85\xBC\x3F\xD9\xA0\x17\xA1\x59\xA1\x2B\xA0\xF5\x91\x0A\xA6\x80\xBE\x41\xB0\xA0\xA4\xA1\xAA\x9C\x11\xA0\xF6\x9E\x0B\xA9\x83\x87\x43\x86\xA1\x4B\xA0\x44\xA2\x29\xA4\x19\xA5\x08\xA8\x80\xAC\x41\xCA\xA1\x56\xA0\xE9\x8D\x35\xA2\x09\xA7\x0D\xAE\x7D\x8D\x3E\xC5\xA0\xC5\xA1\x23\xA0\x94\x9E\xF8\x92\x05\xA2\x86\xA5\x41\xCF\x9E\x1E\x91\x6D\xA3\x1A\xA0\x00\xA5\x0A\xA3\x84\x99\x42\xEA\xA1\x53\x9F\x6E\xA3\xED\x9B\x19\xA6\xF4\x92\x97\x4D\x43\xE3\xA1\x9C\xA1\x55\xA2\x25\xA7\x1C\xA4\x0C\xAF\x87\x93\x42\xE4\xA1\x9D\xA0\x56\xA0\x3F\xA7\x0E\xA9\x0E\xBF\x87\xB9\x43\xF4\xA0\xFB\xA1\x4F\xA0\x26\xA6\xC0\x94\x10\x17\x87\x9A\x39\xA9\xA0\xF2\xA1\x08\xA0\x2F\xA6\xF0\x90\x00\x0E\x88\x9E\x3B\x80\xA1\x87\xA0\x48\xA0\x3A\xA1\x1C",
			"\xA0\x06\xBF\x85\xB3\x41\xA5\x9F\x02\xA2\x85\xA3\x46\xA3\xE2\x9C\x11\xA8\x83\xB8\x43\xAA\xA1\x08\xA3\x0C\xA2\x46\xA5\x1F\xA9\x31\x65\x88\xA2\x42\x94\xA1\xC9\xA0\x6F\xA0\x0F\xA6\xE8\x92\x2C\x76\x88\x89\x3D\xB2\xA1\x8F\xA0\x5A\xA3\x1B\xA0\x0F\xAE\x0F\xAF\x89\x80\x44\xFA\xA1\x2A\xA2\x9D\xA1\xF3\x9E\x26\xAB\xFA\x91\x87\xAC\x43\xD8\xA1\xA0\xA1\x9E\xA2\x31\xA0\x18\xA5\x0E\xB9\x89\x83\x43\x84\xA2\x25\xA3\x3E\xA0\x53\xA1\x20\xA9\x10\xB0\x7F\xA3\x44\xDA\xA1\x06\xA2\x94\xA0\x48\xA5\x2A\xA3\x00\xA9\x8A\x98\x45\xBE\xA2\x07\xA3\xAD\xA1\x50\xA7\x29\xA5\x0B\xB2\x08\x02\xCB\x08\x8F\x68\xA3\x22\x3E\x5A\xA4\x04\x9B\x16\xA4\xF3\x2C\x45\xEF\xA2\x6E\xA3\xB8\xA2\x41\x01\x2D\xA0\x17\xB3\x8B\x92\x04\x19\x93\x4B\xA3\x8F\xA1\x25\xA3\x2C\xA3\x10\xA4\x81\xB8\x45\xE2\xA1\x0F\xA2\x8C\xA1\x34\xA3\x25\xA1\xFA\x9F\x8B\x9D\x44\xCE\xA1\x53\xA2\xA0\xA0\x15\xA2\x28\xA3\xEC\x86\x8C\xA6\x44\x81\xA3\x38\xA2\x4F\xA2\x55\xA4\x25\xA5\x10\x0E\x8C\x92\x45\xFA\xA2\x31\xA3\x79\xA1\x36\xA5\x32\xA0\x0F\xB0\x88\x87\x45\xB2\xA2\xF4\xA0\x8A\xA2\x65\xA4\x11\xA1",
			"\x0B\xA1\x86\x8E\x45\xFD\xA2\x6F\xA1\xD1\xA3\x26\xA2\x2B\xAB\x17\xAB\x8C\xA4\x45\xBB\xA2\x77\xA3\xCE\xA2\x60\xA1\x22\xAB\x0B\xBF\x86\xB0\x3E\xAA\xA3\xA9\xA1\xD2\xA1\x53\xA2\x32\xAD\x15\xAB\x88\x9C\x46\xD9\xA2\xBA\xA2\xAA\xA0\x5F\xA2\x24\xA4\x19\xA4\x08\x38\x46\xB0\xA1\xC8\xA0\x5D\xA2\x20\xA4\x05\xA6\xF4\x87\x8E\xB8\x42\xB0\xA2\xCA\xA2\x69\xA2\x3B\xA5\x39\xA2\x1B\xB1\x8C\xA1\x44\x93\xA3\x50\xA2\x6D\x65\x6C\xA0\x38\xA9\x1C\xA1\x84\x92\x47\xCC\xA3\xA2\xA3\xEA\xA2\x69\xA4\x37\xAB\x01\xA2\x7E\x8E\x47\x9E\xA2\xB9\xA0\xEF\xA0\x61\xA5\x2C\xAE\xD9\x8E\x08\x27\x47\x88\xA3\x98\xA3\xE8\xA3\x7A\xA0\x36\xAE\x1E\xA2\x8F\xBB\x46\xD7\xA3\xBD\xA3\xAB\xA3\x6F\xA0\x2C\xAC\x1A\xB9\x8C\x92\x44\xB6\xA3\x34\xA3\xED\xA0\x7F\xA1\x38\xAA\x18\xBC\x82\x8C\x46\xBB\x9E\xEF\xA3\x93\xA0\x81\xA1\x25\xAE\x1A\xA8\x8D\x8D\x3F\x89\xA4\x90\xA3\xF1\xA0\x7E\xA5\x3C\xAE\x1B\xA4\x08\x32\xCB\x10\xA4\x17\xA2\xEB\xA0\x57\xA4\x42\xAA\x1F\xB6\x90\x82\x48\xF9\xA2\xE9\xA3\x8C\xA3\x81\xA5\x07\xAF\x21\xA0\x8C\x99\x48\x92\xA4\x1B\xA5\x44\xA3\xB0\x9A\x58\x68\x21",
			"\xB7\x89\xA8\x48\xC3\xA3\xD8\xA2\xF6\xA2\x42\x05\x45\xA5\x14\xBE\x8C\x9B\x41\xED\xA1\xE0\xA2\xEB\x9C\x8D\xA1\x09\xAB\x0E\xB7\x91\x88\x45\x95\xA4\x00\x01\x1D\xA6\x1A\xA6\x28\xAE\x23\xA0\x8D\x9B\x46\xC6\xA3\xF6\xA2\xE1\xA1\x83\xA4\x38\xA9\x1D\xA6\x08\x02\x49\xCF\xA1\xD6\xA1\xCF\xA2\x66\xA6\x2B\xA8\xF2\x9A\x8E\xAD\x47\xD6\xA4\x24\xA3\x2C\xA4\x43\xA0\x00\x02\x2C\x62\x96\x4C\xD1\x17\xA3\x21\xA5\xC1\xA3\x88\xA1\x65\x8C\x1D\xB0\x86\xB4\x46\xCB\xA3\x13\xA2\x82\x03\x97\xA4\x34\xAD\x1D\xA2\x91\xAF\x46\xCD\x9F\x6B\xA5\xD5\xA3\x82\xA2\x2C\xAB\x24\xB1\x91\xB4\x47\xB8\x68\x49\xA5\x02\xA4\x8E\xA1\x4D\xA0\x07\xA0\x00\x31\x49\xB9\xA3\x6D\xA4\x31\xA7\x9B\xA3\xD8\x9F\x27\xA8\x8E\xA6\x49\xD2\xA4\xFF\xA3\x99\xA1\x41\x05\x50\xAF\x1C\xBF\x89\x8C\x48\x86\xA4\x83\xA5\x9D\x9C\xA3\xA0\x3D\xA0\x1D\xAA\x8F\xA3\x49\x94\xA2\x93\xA4\xF8\xA1\x98\xA7\x4C\xAF\x1D\xBC\x93\xB5\x02\x99\xA5\x0A\xA5\x40\xA4\xA7\xA3\x3E\xA0\x27\xB9\x93\x8F\x4A\xFB\xA4\x00\xA4\x4C\xA6\xA9\xA4\x4E\xA0\x29\xAE\x90\x84\x4A\xAB\xA5\xAD\xA3\x56\xA4\x93\xA2\x46\xAB\x25\xA0",
			"\x95\x91\x48\xF7\xA3\x29\xA5\x69\xA2\xD1\x9E\x56\xA7\x22\xB8\x95\xB0\x48\xF9\xA3\x4C\x9C\x5E\xA6\x8B\xA6\x57\xA5\x27\xA0\x96\x8D\x49\x87\x9E\x03\x68\x58\xA6\x7F\xA5\x36\xAA\x28\xB6\x7E\x82\x4B\xB5\xA4\xB3\xA2\x44\xA4\xB3\xA1\x34\xAE\x2C\xAA\x96\xB2\x47\x97\xA5\xD6\x9E\x2F\xA6\xB5\xA6\x52\xA1\x29\xB0\x7D\x8F\x4B\xBC\xA4\x44\xA4\x73\xA3\xAC\xA7\x4E\xA4\x26\xA3\x90\xA2\x4A\xD2\xA5\x68\xA5\x54\xA6\xF5\x9A\x5E\x6F\x2D\xA3\x92\xB6\x48\xE2\xA5\x76\xA5\xFC\x9D\xB2\xA5\x4C\xA1\x25\xA5\x92\x93\x49\xC0\xA4\xDA\xA4\x7A\xA4\x37\xA0\x5D\xAD\x29\xAA\x97\xBD\x49\xF9\xA5\xE6\xA5\x43\xA6\xBD\xA1\x51\xA4\x2D\xBD\x93\xAD\x4B\xD0\xA4\xFB\xA5\x81\xA7\xB4\xA7\x48\xAE\x27\xBB\x96\xAE\x49\xAE\xA5\x92\xA4\x87\xA6\xA0\xA0\x62\xAE\x2D\xB2\x98\xA3\x4A\xD8\xA5\x06\xA6\x8B\xA4\xBF\xA4\x54\xAB\x22\xB2\x08\x15\x26\x81\xA6\xF5\xA4\x78\xA6\xB1\xA4\x04\xAF\x31\xA0\x91\x95\x4A\x8F\xA6\xE3\xA4\x3A\x81\xC9\xA6\x44\xA3\x2C\xAA\x92\xB2\x4A\xF1\xA5\xC3\x9D\x95\xA7\x61\xA1\x54\xA2\x30\xA2\x99\x9C\x48\xC5\xA3\x00\x00\x99\xA7\x63\xA5\x57\xAE\x32\xA8\x95",
			"\x8D\x4B\xFD\xA4\x3A\xA6\x30\xA7\xC9\xA3\x62\xA9\x32\xB1\x99\x9A\x4C\x8A\xA6\xE9\xA5\x9F\xA5\xD0\xA4\x4D\xA5\x33\xA7\x8D\x85\x4D\xBB\x9E\x4B\xA6\x39\xA7\xB9\xA0\x69\xAD\x2F\xBF\x99\xB5\x02\xD1\xA6\x80\xA5\xA6\xA4\x79\xA2\x45\xA0\x35\xA7\x9A\xB6\x4C\xDC\xA6\xB0\x9E\xAC\xA6\xA1\xA1\x64\xAE\x34\xB0\x99\x9D\x4D\xFA\xA5\x3D\xA5\xAF\xA6\xAE\xA4\x22\xA2\x36\xAD\x94\xA1\x45\xB1\xA5\x3E\xA7\x82\xA4\x4F\xA6\x20\x0D\x36\xB4\x94\x8E\x4A\xAC\xA5\x71\xA6\x86\xA5\xDD\xA2\x53\xA3\x34\xB7\x98\x9D\x4B\xF4\xA6\x5E\xA7\xB2\xA7\xC8\xA4\x5C\xA8\x2C\xAE\x08\x3B\x4D\xB4\xA6\x64\xA7\xAD\xA7\xDA\xA6\xFA\x97\x38\xB7\x95\xBD\x4C\xBF\xA4\x1D\xA5\x9C\xA5\xE0\xA2\x71\xA3\x1D\xB4\x88\x82\xCB\x0D\xA7\x3C\xA6\x3D\xA4\xE4\xA0\x67\xA8\x39\xAD\x99\x9A\x4E\xC6\xA4\x54\xA4\x82\x01\xE7\xA0\x5A\xAA\x21\xBF\x95\xB7\x4C\xC7\xA5\x1E\xA4\xC3\xA7\xE4\xA3\x42\xA0\x36\xB5\x87\x9E\x4C\xAB\xA7\xB9\xA5\xCA\xA5\xB6\xA7\x75\xA8\x36\xA1\x97\x82\x4E\xA7\xA7\xB4\xA5\x2A\xA4\xE0\xA5\x76\xAF\x2E\xB7\x9D\xAD\x4E\xEC\xA6\xB0\xA6\xD3\xA7\xEF\xA4\x71\xA1\x3C\xA5\x96\xB8",
			"\x4E\x84\xA7\xA2\xA7\xE2\xA7\xCB\xA3\x70\xAD\xFC\x83\x9D\xA0\x4B\xBD\xA7\x94\xA7\x1C\xA4\xD0\xA2\x79\xA9\x37\xA1\x9D\x9C\x49\x92\x02\x93\x92\x93\xA7\xDD\xA0\x6E\xAB\x39\xA1\x7D\x99\x4F\xAC\xA6\xA4\xA7\x17\xA6\xF1\xA3\x78\xA0\x00\x1F\x9E\xB3\x4C\x8E\xA7\x9F\xA7\x7B\xA5\xE4\xA6\x7C\xAB\x33\xBE\x9C\xA7\x4A\xDD\xA7\xB9\xA6\x82\x00\xFB\xA2\x68\xAB\x3D\xAB\x96\x89\x4D\xF2\xA6\xD8\xA6\xEA\xA4\xFC\xA0\x79\xA5\x3E\xBA\x9F\xA0\x4E\xD9\x9B\xF3\xA6\xA6\xA5\xE2\xA4\x75\xAB\x38\xBD\x93\x81\x50\xD2\xA6\x5A\xA6\x02\xAA\xEC\xA6\x80\xAE\x3F\xAA\x9F\xB8\x4C\x87\xA8\x59\xA7\x01\xA9\xEC\xA2\x7A\xA5\x0B\x90\xA0\xA3\x4D\x89\xA6\x6A\xA7\x05\xA9\x05\xAD\x81\xA4\x30\xAC\x98\x96\x50\xEE\xA6\xFD\xA3\x6B\xA7\xDF\xA6\x72\xA9\x3F\xBC\x9D\x91\x4B\xD4\xA6\x1C\xA7\x9D\x9F\x07\xAE\x6E\xAF\x36\xB6\x9F\x95\x4D\x85\xA6\x2B\xA8\xBE\xA5\xFD\xA2\x84\xA4\x31\xAE\x9D\x8E\x04\x31\xA8\x88\xA6\x0C\xAA\xEF\xA5\x80\xAB\x41\xA6\xA1\xA5\x4E\xE3\xA7\x3C\xA9\x12\xA8\xC8\xA2\x87\xA1\x3D\xBE\x94\xA6\x45\xC2\xA8\xDA\xA7\x16\xA8\x0D\xAF\x69\xA0\xFB\x98\xA1\xA8\x4F",
			"\xEF\xA7\xFF\xA7\xF5\xA4\x07\xAB\x61\xA6\x3D\xB2\x97\x4E\x51\x99\xA7\x50\xA8\x07\xA8\xEA\xA4\xD8\x97\x43\xB3\xA2\xB7\x4F\x8C\xA6\xC2\x65\x2B\xAA\xFB\xA0\x6F\xAB\x3F\xBE\x7E\x88\x51\xE0\xA7\xCF\xA7\x13\xA9\x06\xAC\x82\xA7\x46\xA7\x9F\x98\x51\xE4\xA8\x51\xA9\x07\xAA\x17\xAF\x85\xAE\x41\xB3\xA3\xA9\x50\xCD\xA8\x76\xA8\x8C\xA5\x0F\xAB\x88\xA9\x36\xBB\xA1\x9A\x50\xC7\xA8\x28\x93\x3C\xAB\x08\xA8\x9B\x5E\x43\xA2\x9F\x8B\x4F\xC7\xA7\x74\x81\x57\x58\xFD\xA2\x89\xAC\x2D\xB5\xA1\x94\x44\x8A\xA9\x02\xA8\x22\xAA\x02\xAC\x8D\xA1\x48\xA5\xA4\x84\x4B\x87\xA9\xE4\xA7\x5A\x80\x24\xA8\x81\xA2\x41\xA2\x9E\x81\x51\x95\xA9\x7C\xA8\xDB\xA5\x11\xAE\x5F\xAB\x49\xB1\xA0\x92\x52\x93\xA8\x46\xA8\x50\xA9\x12\xA9\x84\xAD\x48\xAC\xA2\x86\x3D\xA5\xA9\x17\xA9\x3E\xAB\x28\xAE\x6A\xA2\x11\x10\xA5\xA0\x50\xF3\xA4\xDC\xA7\x38\xAB\x16\xAE\x96\xAC\x42\xAC\xA5\xA8\x4C\xE6\xA6\xB0\x9E\x5E\xAA\x0C\xAC\x91\xAF\x4B\xAC\x9E\x83\x3B\xC2\xA9\x39\xA8\x59\xAB\x24\xA9\x95\xA8\x25\xBA\x65\x42\x52\x8E\xA9\xD6\x9E\x64\xAB\x13\xA8\x8E\xAA\x45\xA4\x81\x92\x53\xEF",
			"\xA8\xB9\xA9\x6A\xA8\xFF\xA2\x5E\x67\x4D\xA3\xA3\x99\x53\x9D\xA8\xD6\xA7\x6E\xA9\xF8\xA7\x92\xA5\x3D\xA0\x92\xA2\x53\xE9\xA8\x3F\xA8\x4C\xAB\x27\xAD\x99\xA2\xCA\x4F\xA6\xAE\x52\x8F\xA9\xEE\xA8\x60\xAB\x2B\xA9\x9E\xA6\x4C\xBB\x79\x9C\x53\xF4\xA9\x88\xA9\x61\x9F\x3D\xAE\x92\xAF\x38\xBA\xA5\xB1\x4F\xD7\xA7\xAA\xA8\x34\xAA\xBB\xA2\x8D\xAE\x47\xB4\xA4\xAC\x53\x84\xA9\xA1\xA8\xE8\xA7\x32\xAE\x5F\xAA\x49\xB8\xA7\x99\x52\xB5\xA9\x0E\xAB\x75\xAA\x33\xAC\x9F\xA9\x3E\xA0\xA7\xA6\x53\x91\xAA\x7F\xA9\x80\xAA\x1B\xAE\x9B\xAE\x42\xB7\xA3\x81\x48\x8F\x93\x18\xAA\xE9\xA4\x64\x93\x91\xAE\x4B\xA4\x9A\xB2\x53\x85\x02\x23\xAB\x48\xAA\x32\xA8\x95\xAC\x50\xAB\x49\xA1\x54\xCC\xA9\x06\x03\x94\xA8\x27\xAF\x94\xAE\x49\xB9\xA8\x8A\x04\x32\xAA\xA6\xA9\x95\xA9\x4D\xAE\xA0\xA1\x53\xAF\xA9\xBE\x4B\xB8\xAA\xB1\xA8\x51\xAB\x42\xAC\x96\xA0\x52\xB4\xA8\x99\x51\x96\xAA\x91\xA6\xA0\xAB\x2D\xAB\x6A\xAB\x46\xB0\xA9\xA8\x54\xBE\xAA\x44\xAB\x9B\xA8\x54\xA8\x7F\xA5\x54\xA9\xA8\x84\x54\xB3\xA9\x54\xAA\xA9\xAA\x51\xAC\x9A\xA8\x54\xB8\x99\x82\xCB\x4A\xAA",
			"\xBD\xA8\x5C\xA9\x47\xAA\x8F\xAE\x52\xBB\xAA\x9F\x53\xD4\xA8\xD9\x9A\xB0\xAB\x30\xAD\xA4\xAE\x37\xB0\xA6\xBD\x49\xF2\x65\x6A\xAB\x64\xAA\x50\xAC\xA5\xA1\x55\xBD\xA9\xA6\x55\xE3\xAA\x83\xA9\x3E\xA5\x5C\xAB\x9A\xA7\x56\xBF\xA2\x96\x4F\xDF\xAA\x53\xAA\x86\xA7\x5E\xA8\x9B\xA8\x57\xAE\xAB\xB5\x02\x83\xAB\x1C\xAB\x25\xAB\x49\xAB\x5D\xA5\x56\xB6\xAA\xA9\x53\xE5\xA9\x91\xA6\xB8\xA9\x60\xAF\xAF\xAD\x58\xAB\xA5\xA2\x55\x8A\xAB\xF5\xA8\x12\xA5\x55\xAE\xB2\xAC\x54\xA5\xA8\x8E\x55\x84\x02\x88\xAB\x71\xA9\x3F\xAA\x9B\xAD\xFC\x81\xAD\xA8\x53\x86\xA9\x90\xAA\x9C\xA6\x69\xAB\xA0\xAF\x58\xA5\xA3\x83\x3B\xAB\xAB\x08\xA6\x9D\xA8\x10\xAE\xA6\xA6\x57\xAE\xAC\xA8\x56\xAE\xAB\xE0\xA0\x85\x03\xCD\x82\x21\x0F\x58\x8A\x08\x0C\x17\x82\xAA\xB1\xAB\xB9\xAB\x4E\xAC\x4F\xAF\x5B\xBB\xA8\xA2\x56\x95\xAA\x68\xAA\x0E\x9D\x71\xAD\x7D\xA7\x5C\xA7\xAA\x89\x57\xB8\xA6\xCB\xAA\x92\xAB\x65\xAD\x95\xAB\x58\xBD\x93\x91\x57\xAA\xAA\xC2\xAB\xD9\xA8\x4F\xAB\xDE\x33\x59\xA0\x92\x97\x57\xB3\xAA\xB2\xAA\x75\xAB\x02\xAF\xBB\xA9\x53\xB9\xAE\xA2\x57\xDB\xAB\x3C",
			"\x3F\xEE\xA9\xE4\xA4\xBC\xA1\x54\xAA\xA8\xB4\x55\xD9\xAA\x06\x02\xF6\xAB\x52\xA9\x81\xAF\x5E\xAC\x98\xB2\x57\xE1\xAA\x9D\xAA\xAC\xAA\x7D\xAA\xBD\xA0\x5D\xBC\xAF\x9B\x51\xC2\x65\xF7\xAB\xB5\xAB\x74\xAD\x98\xA9\x4F\xBB\x79\x81\x58\xF2\xAA\xEE\xAB\xE1\xAA\xBF\xA7\xC0\xAC\x57\xA5\xAC\xAF\x53\x8C\xAB\xD1\x18\xFF\xAB\x3F\xAC\xC1\xA4\x58\xB8\xAC\x85\x58\xB0\x9F\x14\xAD\xC4\xA8\x75\xA9\xB3\xAF\x51\xBE\xAD\x92\x58\xFC\xA7\x19\xAD\xE6\xA8\x57\xAF\xB9\xAB\x45\xA1\xB1\xA7\x56\xE4\xA9\xB8\xAB\x16\xA1\xA7\x2F\xC3\xA2\x2F\xB1\xB0\xB7\x55\x96\xAC\x0F\xAB\xDA\x9B\x8A\xAF\xC5\xAB\x61\xB7\xB0\x9D\x58\xF1\xAB\x2C\xAD\x61\x9E\x89\xAC\xB5\xA7\x5B\xBE\xA7\xA0\x58\xB9\xAC\x06\xAC\x20\xAC\x86\xAA\xC8\xA6\xF4\x9B\xB1\x81\x57\x89\xAC\xDA\xAB\xCF\xA8\x40\xAA\x21\x06\x94\x72\xAE\xB9\x57\xC3\xAA\x05\xA7\x26\xAC\x76\xA8\xC9\xA7\x5E\xBC\x93\x92\x59\xE0\xAB\xE6\xAB\xD4\xAB\x16\xAF\xCA\xA5\x5E\xB4\xB2\x9A\x59\xFF\xA9\x5C\xAD\xF6\xAB\x55\xA8\xCA\xAC\x30\xA1\xB3\xB3\x57\x9D\xA9\x49\xAD\x96\xA9\x5C\x74\xC8\xA5\x10\x06\xB3\xB8\x57\xF4\xAB\x0A\xAD",
			"\xBA\xA9\x9B\xAC\xCD\xA6\xFD\x8E\xB3\x82\x58\xCF\xAC\xF5\xAA\xEB\xA6\x9D\xA8\xC1\xA3\x66\xB9\xB3\x80\x49\xFB\xAC\x0D\xAC\x18\xAE\x44\xAB\xCE\xA4\x63\xA4\xB0\xB1\x58\xCC\xAC\x74\xAD\x7F\xA6\x44\x00\xD0\xA5\x61\xB5\xB1\x87\x5A\x86\x02\x8C\xAC\x0D\xAE\xA1\xAD\x80\xA1\x69\xA2\xB1\xBD\x55\xF4\xA8\x55\xA9\x45\xAD\xA2\xAD\x16\x85\x69\xA7\xB1\xA3\x56\xDD\xAA\x5B\xAD\x4D\xAC\x20\xA8\xD1\xA5\x68\xA6\xA9\x9C\x58\x94\xA2\x9D\xAC\x1E\xAC\x8A\xAE\xC7\xAD\xFC\x89\xB5\x87\x59\xFD\xAC\x71\xAC\xF8\xA9\xE1\xA4\xD4\xA6\x5B\xAB\xB5\xA4\x56\xFA\xA9\x9A\xAD\x52\xAD\x5B\xAF\xC1\xAA\x68\xAB\xB3\xBA\x5A\x9B\xA6\x64\xAA\x19\xAE\xAF\xAD\xD6\xAF\x69\xA4\xB1\xA0\x59\xA2\xAD\xC3\xAC\xCE\xA8\x9C\xA9\xCD\xA2\x67\xAC\xCA\x48\x5B\xB4\xAD\xCA\xAC\x34\xAD\x95\xAA\xCD\xA0\x6D\xA0\xAE\x89\x46\xCE\xAB\x7E\xAA\x7C\xA7\xB7\x34\xD8\xA8\x5C\xB9\xB6\x9C\x38\xAD\x8E\xD1\xAC\x9A\xA8\xB3\xAD\x60\xA0\x6E\xB6\xB6\xB1\x47\x8E\xAD\x83\xAC\x82\x01\xB9\xAE\xB8\xAE\x69\xBD\xB6\x98\x5A\xC0\xA4\xEB\xAC\xE6\xA9\xBB\xA8\xDB\xAF\x6E\xB1\x9C\xB1\x5B\xCE\xAC\xCB\xAD\x69",
			"\xAD\xB3\xA8\x00\x07\x6F\xB3\xB2\xB0\x5A\xE3\xAD\x11\x9F\x7E\xAC\x96\xAE\xCB\xA9\x62\xA6\x7A\x82\x5C\xDD\xAC\xFF\xAC\x7D\xAE\xAC\xAA\xDD\xAF\x6C\xA0\xB5\x0D\x5C\x85\x02\x07\xAE\x31\xAD\x6B\xAC\xD5\xA3\xEC\x91\xB8\xA7\x59\xE2\xAD\x0A\xAE\x86\xA6\xC5\xAF\xCD\xA2\x6D\xBF\xB2\xBC\x4F\xC2\x65\x1B\xAF\x3B\xAD\xBE\xAE\xE3\xAD\xFC\x81\xB9\xBC\x59\x93\xAE\xB7\xAC\x87\x02\xC9\xA9\xD0\xA8\x6E\xB4\xAD\xB3\x5A\x8E\xAE\xBF\xAC\x14\xA9\xB0\xAA\x21\x0B\x72\xAD\xB4\x93\x5A\xAE\xAE\x0C\xAF\x98\xAD\x53\xAC\xDA\xAB\x25\xB5\xB9\x92\x5A\xA6\xAD\x36\xAC\x8A\xA2\xCF\xAE\xD2\xAE\x60\xB5\xAE\xB5\x02\xC3\xAE\xF3\xAD\x11\xAE\xB7\xA8\x67\xA2\x2F\x68\xBA\xAA\x5A\xC5\xAD\x4B\xAF\x2D\xA9\xD3\xAF\xE1\xAE\xF1\x8A\xB9\x94\x5D\xCB\xAC\x30\xAE\x6E\xAC\xBD\xAE\xA3\xA2\x74\xB7\xBA\x8E\x5D\xAF\xAD\x28\xAE\x50\xAF\x3F\xAF\xEB\xA7\x6D\xAA\xBA\xB5\x5B\xB8\xA6\x64\xAF\x73\xAF\xCD\xA8\xBD\xAC\x6F\xB7\xBA\x82\xCB\x29\x8E\x06\x02\x98\x8E\x42\x00\xEE\xAE\xC4\x4E\x08\x05\xDF\x74\xAE\xFB\x56\x85\x00\x43\x58\xEF\xAD\xBF\x43\x30\x92\x04\x7C\xAE\xDA\x57\x34\x48",
			"\xE0\xAA\x22\x00\x74\x93\xBB\x92\x04\x5A\x57\xFA\x45\xC1\xAE\xDD\xAF\xEF\xA7\x78\xBE\xEE\x05\x04\x0A\xAF\xC8\x44\x83\x00\xE4\xAE\x20\x04\x27\x73\xBC\x85\x04\x21\x91\x92\xAF\xC6\xAD\x8E\x94\xF1\xAC\xBD\x52\x08\x29\x21\x86\xAF\x9D\xAF\x2E\x4A\x43\x06\xF2\xAB\x86\x9C\xBC\xA1\x09\x86\x02\xC6\x94\x00\x00\xE9\xA8\x8D\x46\x7A\xA6\x08\x1A\xAF\x29\xAF\xAB\xAE\x09\x95\xE6\xA9\xF4\xAA\x10\x10\x51\x86\x04\x0E\x94\x0A\x02\xB9\xAF\xED\xAA\xF3\xAA\x10\x05\xBE\x78\x5E\xAE\xAF\x7E\xAE\x87\x03\xEF\xAD\xEE\xAA\x77\xB2\x08\x03\x5F\xF9\xAE\x41\x48\xE3\xAC\xEF\xA9\xF0\x3A\x7C\xB4\xBD\x84\x9B\x42\xAF\xCB\xAF\x82\x02\xEF\xA9\xFA\xA5\x34\x4A\x08\x07\x5F\xFD\xAE\xF5\x3A\xE8\xAE\xF3\xAD\x20\x04\x27\x77\xBE\x9A\xAF\x18\xAF\x05\x02\xEF\xAE\x44\x01\xF5\xA2\x7E\xAE\x08\x1F\x5E\xBB\xAF\xDB\xAF\x48\x4A\xF6\xAF\xF4\xA5\x10\x19\x50\xA1\x5F\xD4\xAF\x00\x00\xF2\xAC\xFC\xA9\x8D\x45\x7E\xA9\x55\x8D\x5F\xEC\xAF\x04\x02\xD9\xAF\xFB\xA9\xFD\xA0\x00\x16\xBD\x85\x04\x79\x8A\xF8\xAD\x8E\xAD\xC1\xAF\xFF\xA9\x68\xA0\xC0\xBE\x5B\xE1\xAE\xC6\xAC\xFE\xA6\x01",
			"\xB3\xE0\xA9\x70\xA4\xB9\x83\x3B\x8B\xB0\x08\xAE\x04\xB1\xD4\xAF\x9F\xA0\x81\xB2\xB8\xBD\x58\xA9\xAE\xB0\x9F\x0A\xB3\xC5\xA9\xBC\xAE\x80\xAE\x08\x1A\x60\x9C\xAE\x18\xAF\x0E\xB1\x06\xB7\xEA\xAF\x81\xA2\xB9\x82\x60\x94\xAE\x3B\x9F\x12\xB3\xC9\xAF\x02\xB2\x76\xAA\xC0\xA4\x60\xAF\xB0\x3A\xAE\xCF\xA8\xCF\xAA\x77\xA4\x80\xB1\xC1\xBA\x57\xD6\xA7\x2A\xB0\x96\xAF\xDA\xAC\x4F\xA9\x83\xB6\xB9\x80\x5D\x8F\xAD\x2F\xAF\x1A\xB2\xD6\xAE\xEC\xAC\x75\xB6\x7E\xBD\x60\xBF\xAE\xBB\xAC\xA3\xAE\x44\x07\x08\xB4\x74\xA2\xB4\xB8\x5C\xD8\xAE\x42\xB1\x70\xAC\x07\xB3\x00\xB6\x84\xB0\xC1\x83\x61\x97\xAD\x45\xB1\xB7\xAB\x12\xB7\xEA\xA2\x2F\x6C\xC2\x89\x5D\xD8\xB0\x33\xAF\x2D\xA6\x17\xB7\xE9\xAE\x6E\xB9\xC2\xB3\x4D\xD1\xB0\xE6\xAD\x4D\xA4\xB0\xA9\xAF\xA5\x0B\x83\xC3\xA0\x5D\xAC\xB0\x09\xB1\xE6\x9E\x1B\xB5\xEC\xA0\x86\xAC\xC3\x9B\x61\xB6\xB0\x64\xAC\x1C\xB2\x15\xB2\x0A\xB9\x65\xB4\xC2\xBD\x5A\xBC\x4A\x89\xAD\xA4\x49\x00\xB1\x04\xBE\x87\xA2\xC4\x87\x60\xF0\xB0\x13\xB0\xFE\xA6\x21\xB4\x01\xB2\x81\xA7\xBB\x9B\x51\x8B\xB1\x11\xB0\x44\xB2\x23\xB7",
			"\x9F\xA0\x89\xB6\xC0\xB6\x5A\xAD\xB0\xCD\x9F\x4A\xB3\x06\xB5\x0F\xB8\x82\xA0\xC4\xB8\x61\xFE\xAC\x91\xA6\x4D\xB0\x08\xB3\x0A\xBD\x89\xA6\x7A\xA2\x62\xA6\xB0\x84\xB1\x52\xB0\x45\xA7\x14\xBB\x82\xB7\xC4\xB1\x61\xC3\x9D\xAC\xB0\x1D\xB3\x0F\xB1\xDD\xAC\x55\x57\xC2\x85\x5D\xA7\xAD\xD6\x9F\x58\xB2\x0F\xB1\x09\xB8\x8B\xBF\xC3\x88\x95\x57\xAE\xBA\xB0\x24\xB3\x1A\xB6\xAD\xA1\x8C\xAD\xC2\xAD\x5C\xEC\xAE\xF2\x65\x62\xB3\x17\xB7\x16\xB1\x74\xB9\xC5\x80\x63\xEE\xAE\x18\x4B\x67\xB3\x27\xB1\xD6\xAC\x30\xAA\xC6\xA4\x61\xDB\xAE\x61\xB1\x20\xB0\x4C\x4C\x0B\xB1\x8D\xB3\xC6\x80\x5C\x94\xAB\x0E\x02\x6B\xB3\x1B\xB6\x15\xB9\x88\xA6\xA3\xA1\x63\xD2\xB1\xB6\xB0\x27\xB0\xDB\xAA\x1C\xB4\x87\xAC\xC6\x80\x61\xDB\xB1\xDE\xB1\x8C\xAE\xF5\xA4\x1D\xBA\x76\xB3\xC5\x8F\x61\xF4\xB1\x6A\xB0\x99\xAE\x1D\xB2\xD8\xAA\x10\x0E\xA2\x43\x62\xA4\xB1\x18\xB0\x83\x02\x3F\xB7\x10\xB4\x8E\xB3\xC4\xAF\x41\x83\xB2\x8C\xB0\x49\xB2\x19\xB6\xF4\x31\x8F\xA2\xC1\x86\x3D\x88\xB2\x91\xB1\x82\xB3\x42\xB6\x21\x00\x91\xB6\xC4\x90\x5D\x86\xB2\xCD\x9F\x8A\xB3\x26\xB4\xE0",
			"\xAA\x8A\xA4\x08\x1A\x64\xA3\xB1\x9C\xB1\x80\xB0\x45\xA7\x23\xB8\x8A\xA0\xC8\x98\x62\xC3\x9D\x24\xB3\x56\xB3\x45\xB3\x22\xBD\x8F\xB7\xBA\xA9\x64\xB2\xB1\xBC\xB1\x66\xB1\x9F\xA7\x25\xBB\x8B\xA3\xC6\xBC\x5A\xB5\x81\x34\xB2\x61\xB2\x3E\xB6\xB0\xA3\x6A\xA2\xC8\xAE\x64\x89\xAD\x39\xB2\x63\xB3\x0E\xB3\x06\xB9\x3A\xAD\xC9\x8D\x64\xFE\xB0\x38\xB3\x9F\xB3\x51\xB5\x23\xBE\x8B\xA5\x08\x01\x65\xCB\xB1\xEA\xB0\x25\xAF\x53\xB7\x1A\xB4\x84\xB9\xC6\x9E\x64\xDC\xB1\x14\xB2\xAC\xB2\x51\xB1\x1D\xB7\x8C\xAA\xB2\x82\xCB\x53\xB2\xE3\xB1\x95\xB2\x55\xB0\x0A\xB7\x95\xAB\xCA\xA2\x64\xD6\x9F\x60\xB3\x76\xB1\x54\xB4\x28\xB0\x00\x09\xCB\xB5\x63\xB1\xB2\xEF\xB1\xB6\xB2\x52\xB4\x2B\xB3\x94\xBB\xB7\xAE\x65\xF9\xB1\x3B\xAF\x7D\xAE\xB0\x65\xC6\x4F\x8F\xA1\xC9\xA7\x64\xEF\x4B\x66\xB3\xBF\xB2\x88\x4F\xEA\xAC\x97\xA4\xC8\xA2\x65\xFB\xB1\x83\xB3\xC0\xB3\x2B\xB3\xE7\x95\x98\xA9\xC8\x92\x64\xE3\xB2\x8D\xB3\x88\xB3\x61\xB6\xAD\xA1\x99\xB6\xC8\xA5\x61\x90\xB3\x84\xB3\xCC\xB2\x62\xB5\x1C\xB3\xEC\x95\xCC\x9B\x64\x8D\xB0\x48\xB2\x89\x02\x67\xB0\x24\xBC",
			"\x91\xA7\xCB\xBD\x49\xA3\xB3\x25\xB2\xBF\xB3\x62\xB2\xB3\xA9\x98\xB4\xCB\xB6\x63\xEC\xAE\xA8\xB2\x95\xB3\x65\xB1\xAF\xA1\x9B\xB0\xC9\xB6\x64\xCA\xB0\x57\xA5\x0E\x6B\x66\xB0\x23\xBD\x99\xBA\xCC\xAE\x66\xF0\xB2\xB4\xB1\xBD\xB2\x6F\xB4\x0F\xB5\x9A\xA2\xCC\x86\x3D\xB5\xB3\x35\xB3\x9D\xB3\x4D\xB3\x65\x62\x9A\xBA\xCA\xBA\x66\xBF\xB3\xB7\xB3\x5E\xB3\x19\xB2\x82\x6B\x9B\xAC\xC9\x9B\x49\xC8\xB3\x3A\xB3\xBC\xB3\xC2\xA8\x8B\x63\x9C\xA9\xC3\xBD\x4D\xD1\xB3\x32\xB3\x5A\x80\x76\xB2\x28\xBF\x9A\xAA\xB2\xA3\x67\xD0\xB2\x5D\xB2\xB6\xB3\x79\xB4\x2A\xB5\x87\xBC\xC9\xBC\x63\xD8\x3A\x12\x02\x70\x88\x00\x02\x3E\xB4\x9F\xB1\xCF\xB6\x67\xF4\x3A\xF7\xB3\x59\x11\x7E\xB0\x3E\xB8\x9F\xBD\xCF\xBA\x67\xFE\xB3\x06\x02\x4C\x5B\x73\x9C\x34\xB0\x9A\xAC\xCA\x82\x68\x89\xAD\x07\xB5\xEA\xB3\x58\xB1\x41\xB0\x9D\xAA\xCE\xB8\x66\x8A\x02\x0C\xB4\xE2\xB1\x81\xB6\x34\xB5\x0B\x91\xD0\x9E\x67\xB3\xA8\xE9\xB3\x7D\xAE\x85\xB4\xDD\xAC\x9E\xAE\xC7\x85\x50\x9B\xB4\xF2\xAD\x0E\xB7\x5A\xB2\x43\xBC\xDF\x89\xCE\x9A\x67\x8C\xA6\x20\xB5\xBE\xB1\x71\xB3\x35\xB6\xF4",
			"\x89\xD1\x86\x66\xB3\xB3\xEE\xB2\x08\xB5\x89\xB1\x3B\xB2\x83\xA4\xD1\x80\x35\x92\xB3\x30\xB5\xE5\xB3\xF8\x33\x46\xB4\x9E\xA0\xCE\x8F\x61\xC2\x65\x2E\xB4\xC7\xB3\x64\xB2\x47\xB2\xA3\xB7\xD1\x96\x66\xD8\xB1\x79\xAB\x20\xB4\x8E\xB0\x49\xB1\xA3\xAD\x89\xBB\x68\xC6\xB4\x9F\xB3\x46\xB2\x75\xB5\x20\x0A\xA4\xA7\xD2\x95\x65\x88\xB3\x01\xB4\x1E\xB4\x7A\xB5\x2E\xBB\x9D\xA0\xD2\x9A\x69\xA2\xB4\x19\xB5\xED\xB1\x95\xB1\x4A\xBA\x90\xAB\xD0\x9F\x69\xE1\xB2\x39\xB5\x07\xB6\x93\xB5\x48\xB1\xDF\x96\xD2\xAD\x67\xC4\xB4\x6B\xB5\x2C\xB4\x94\xB4\x40\xB2\xA5\xA3\xCB\x9E\x69\xF3\xB4\xA9\xB3\x15\xB4\x67\xB1\xB7\xA2\xA7\xAD\xD3\xA4\x69\x8F\xB3\x58\xB4\x2A\xB7\x99\xB2\x2D\xB1\xA6\xA8\xD1\x83\x6A\xEF\xB2\xE0\xB3\xB8\xB3\x98\xB4\x4E\xB5\xA6\xA1\xD4\x84\x04\x0B\xB5\x79\xB5\x09\xB6\x71\xB4\x22\xA0\xA9\xB2\xCD\x8C\x69\xF0\xB4\x34\xB0\x82\x01\xA6\x81\xD1\xAB\xA9\xAA\xD0\xB9\x55\x9D\xB5\x0D\xB5\x13\xB6\xF5\xA0\x54\xB2\xA1\xB5\xD3\x8E\x6A\x80\x00\xA4\xB5\x0B\xB4\x31\xAD\x3C\xBC\x96\xA9\xD5\x9C\x68\xE8\xB4\x97\xB4\x35\xB5\x41\x06\x55\xB1\xA2\xB0",
			"\xD5\x97\x69\xEE\xAA\xB4\xB4\x15\xB6\xA4\xB4\x45\xB4\x11\xB9\xD5\xAF\x68\xB1\xB5\xD2\xB3\x41\x63\xA1\xB0\x2F\xB5\xA3\xBB\xCE\xBE\x6A\xC2\xB4\x69\xB5\x60\xB7\x10\x9B\x58\xBF\x9D\xAE\xD0\x8A\x6B\x8A\x02\xC7\xB5\x25\xB7\xAD\xB0\x53\xBA\xA9\xAC\xD6\x98\x68\xDC\xB4\x60\xA8\x61\xB4\x9E\xB6\x52\xB3\xAD\xB2\xD5\x95\x6B\xDB\xB5\xB6\xB2\x67\xB6\x4C\xB1\x5A\xBE\xA6\xBE\xD0\x8F\x61\xF2\x65\xE4\xB5\x3F\xB7\x90\xB6\x5B\xB8\xAA\xB6\xD6\xAB\x6A\xBE\xB4\x6C\xAF\x74\xB4\xA3\xB0\x50\xBD\xA4\xB9\xD4\xAD\x6B\xE0\xB5\x26\xB5\x62\xB4\xC3\xA2\x5E\xB1\xA9\xA6\xD5\xB5\x6B\xDF\xB5\x7E\xB5\x79\xB7\xBA\xB7\x59\xB1\xA7\xB3\xD5\xAE\x6B\xEC\xAA\x89\xB4\x5A\xB0\xBA\xB7\x60\xB3\x60\xAC\xD5\xBA\x65\xDA\xB5\x01\xB7\x7E\xB5\xA3\xB7\x5F\xB4\x96\xB7\xD7\x91\x6C\xDC\xB5\x6F\xB4\x76\xB4\xBF\xB0\x63\xB6\xAE\xB1\xD7\x8C\x6C\xF8\xAC\xD4\xB1\x51\xB7\xC7\xB3\xE4\xA1\x9A\xAB\xD6\xB8\x6B\xB4\xB4\x37\xB0\x20\xA7\xC6\xB1\x5C\xB2\xAA\xBA\xB6\xA8\x85\x17\xB6\x2C\xB6\x7D\xB6\xF0\x9B\x2F\x43\xA0\xB2\xD8\xB4\x6B\xBC\xAD\x34\xB7\xAB\xAD\xCE\xB6\x53\xB4\xB1\xBB\xD9",
			"\xA1\x6A\xB2\xB6\x40\xA4\x9F\xB5\xA9\xB3\x62\xB4\xAD\xA0\x00\x02\x6D\xAA\xB5\x08\xB6\x71\xB4\xF9\xA7\x68\xBF\xAA\xA4\xD4\x98\x6B\xD6\xA7\x4C\xB7\x5A\xB6\xD3\xB6\x61\xBB\x9D\xB1\xDA\xBA\x6A\xFE\xB5\x45\xB6\xAB\xB7\xAF\xB5\x5B\xB4\xB0\xA5\x08\x1A\x6D\xC8\xB5\xC0\xB5\xF0\xB0\x54\x40\x66\xB9\xAF\xA9\xD9\x91\x4E\xDF\xB6\xD2\xB5\x8C\xB5\xD7\xB5\xEA\xA7\x29\x87\xD9\xBD\x68\x89\xB6\x4F\xB0\xB4\xB5\xB9\xB3\x44\xB5\x30\xB2\xDB\xAA\x6B\xC9\xB5\x62\xB7\xDC\xB2\xD7\xB3\x64\xB7\x82\xB4\xD0\xA3\x6D\xC2\x9B\x43\xB7\x9B\xB4\xBB\xB6\x6E\xB2\xB0\xB8\xDB\xB1\x65\xC2\x65\x84\xB6\x9B\xB7\xC0\xB1\x6F\xBD\xB6\xA4\xDB\xA8\x6C\xF9\xB0\x41\xB6\xBE\xB5\x2A\xB6\x6F\xBA\xB7\xA4\x08\x09\x6E\x9C\xB6\x74\xB6\x86\xA6\xBC\x67\x72\xB1\xB3\xA6\xDB\x9E\x55\xFF\xB6\xCE\x9A\x68\xB3\xCB\xB0\x70\xB8\xB4\xAD\xD8\xB0\x6B\xCA\xAC\x9C\xB7\xB2\xB4\xE4\xB7\x6C\xB2\xB9\xA6\xC9\xBC\x6A\xD6\x9F\xA9\xB7\xC7\xB4\x28\xB0\x67\xA1\xBB\xAF\xDB\x8A\x6D\xB4\xB1\xB5\xB7\x2D\xB4\xD5\xB1\x5B\xB5\xDA\x4D\xDD\xAA\x66\xFB\xB4\x0A\x03\xE4\x59\xCD\xB0\x73\xB5\xA8\xA2\x7E\x82",
			"\x6F\xD7\xAE\xC7\xB6\x9E\xB5\xD1\xB1\x79\xBF\xB3\xBE\xDC\x9B\x51\xCC\xB7\x81\xB7\xC5\xB5\x5C\xB0\x7A\xB5\xBA\xA0\xD9\x9F\x63\xD9\x9B\xD4\xB7\xA6\xB4\xA2\xB7\x76\xBF\x84\xB9\xDE\x92\x6D\xDB\xB7\x2D\xB7\xC8\xA6\xF7\xB7\x6A\xB4\xB4\xAC\xD7\xA3\x6F\xDB\xB6\x6A\xB6\xC6\xB6\x41\x07\x7C\xB0\xB6\xBC\xDA\xAA\x6F\x85\x02\xEC\xB7\xB4\xB5\xC7\xB2\xC9\xA1\xBF\xB3\xDB\x85\x6F\xAE\xB6\xC1\xB6\xDF\xB6\x9E\xB4\x37\xBB\xF3\x95\xDF\xB7\x6D\xE1\xB6\xE4\xA6\xFF\xB5\xE1\xB0\x80\xBA\xB0\xB2\x08\x02\x70\x8A\xB7\x86\xB6\x5A\xB3\x01\xBC\x78\xBF\xB4\xA0\x92\x8B\x70\x9D\xB7\xAB\xB7\xCF\xB5\xEF\xB6\x6D\xBA\xBB\xA7\xDD\xAC\x65\x8F\xB8\xAA\xB7\xD9\xB7\xF3\xB2\x7F\xBB\xAB\xA0\xDE\xB6\x50\xF9\xB7\x14\xB8\x30\xB5\x03\xB9\xB2\xA6\xC0\xBC\xE0\x98\x6D\xEC\xB5\xC2\x64\x0C\xBA\xEC\xB1\x64\xB8\xBF\xAB\xDF\xA6\x70\xE5\xB7\x6B\xB6\xFE\x5B\x0B\xBA\x70\xB1\xC3\xAA\xE1\xB6\x6E\xE1\xB7\x38\xA6\x1B\xB9\x05\xB8\x6E\xBC\x76\xBA\xE1\xA2\x70\xBB\xB7\xD6\xA6\x1F\xBA\xAD\xB1\x7D\xB7\xB8\xAD\xE0\x24\x6F\xB4\xB8\x32\xB3\x08\x37\x11\xBA\x7A\xB5\x40\xAA\xE2\xA8\x6F",
			"\xF3\xB7\x6C\xB2\x27\xB9\xFB\xB4\x88\xB4\x8B\xB2\xE2\xB2\x6F\x99\xB7\xD6\xA6\x2B\xBA\xFD\xB3\x84\xB8\x33\xBA\xE2\xBF\x6F\xEE\xB7\xE4\xA6\x2F\xBB\x00\xB8\x8C\xB5\xC5\xB7\xBA\xA2\x71\x88\xB8\x04\xB9\x27\xB3\x19\xBC\x81\xB0\xC4\xA0\x92\xAB\x71\x90\xB8\x1A\xB9\x7F\xAB\x1B\xB9\x83\xBC\xC2\xB1\x9C\xB3\x71\xAB\xB8\xD7\xB7\xC8\xA6\xB0\x67\x8E\xB7\xC3\xA0\xDA\xB6\x71\x89\xAD\x7C\xB9\x1D\xB8\xF7\xB0\x19\xB6\xC4\xAF\xE2\x98\x71\xEE\xB8\x66\xB8\xD1\xB7\x07\x3B\x89\xB9\xC0\xAA\xE3\x89\x72\xCA\xB7\xEC\xB4\x79\x65\x20\xBF\x87\xB6\xC1\xBB\xB7\x92\x72\x8A\xB9\x59\x39\xEF\xB4\xB1\xB6\x79\xBF\x4F\xBB\xE3\x8F\x72\xCD\xB7\x11\xB9\x2D\xAB\x24\xBB\x88\xB0\xC5\xBB\xB7\xA3\x72\xD3\xB6\x95\xB9\xED\xB3\x29\xB8\x7C\xBE\xC7\xBD\xE2\x98\x72\x85\x02\xB7\x8C\x50\xB9\x1C\xBF\x0D\xA1\xCB\xB1\xDE\x8D\x72\xD2\xA7\xB5\xB9\xEA\xB4\xC9\xB4\x29\xB5\x0B\x99\xE5\x9A\x6F\x9B\xB9\xA1\xB9\x7F\xAA\x2F\xBA\x93\xBD\xAC\xB8\xE1\x9B\x51\xC3\xB9\x8C\xB9\x34\xB8\xDB\xA8\x99\xB6\xC8\xB7\xDF\x9C\x38\xCC\xB9\x53\xB9\x52\xBB\x76\xB0\x9A\xB7\xC5\xAE\xE6\xB8\x4C\xD4",
			"\xB9\x5B\xB9\x36\xB9\xE4\xA0\x9B\xBF\xC5\xB4\xE2\x8F\x61\xDC\xB9\x63\xB8\x6F\xBB\x32\xBF\xEA\xA0\xCE\xA8\xE3\xA4\x71\xBF\xB4\x12\x03\x72\xB8\x1B\xB9\x95\xBC\x30\xAA\xE7\xB0\x71\xF5\xB8\x4C\x9C\x77\xB8\x1D\xB9\x8F\xBC\x74\xA9\xE7\xA4\x73\xF7\xB9\x90\xB9\x18\xBA\xB0\x62\x9E\xB8\xC7\xB2\xC7\x80\x49\xFC\xB9\x7D\xB8\x4E\xB8\xFF\xA0\xA0\xB2\xC8\xA6\xE6\xBF\x53\xF2\x65\x04\xBA\x4A\xB8\x0F\xBA\xC9\xA8\xD0\xAF\xE5\x84\x04\x09\xBA\xA4\xB9\x43\xBA\x1E\xBE\x9E\xB9\xCF\xAF\xDF\x8F\x74\xF8\xB9\xB2\xB8\x78\xBB\x31\xB8\xA3\xB6\xCB\xAA\xE6\x8A\x59\x90\xBA\xA8\xB9\x85\xB8\x5B\xB2\x58\x61\x59\x99\xE8\xB4\x73\xA1\x9F\x25\xBB\x8E\xBB\x39\xBA\x7A\xA9\xD2\xBA\xE5\xBD\x6D\x93\xB5\xD6\x9F\x96\xBB\x2F\xBD\x98\xBD\xCA\xBB\xA2\xB2\x74\xC4\xB9\xD7\xB4\x6D\xB8\xCE\xA7\xA6\xB9\xCC\xAB\xE9\x8A\x59\xBC\xBA\xCD\xB8\x2E\xB8\x4A\xBF\xEA\xA0\xD4\xB1\xE6\x92\x74\xBB\xBA\x44\xBB\xA4\xB9\x45\xB9\x2E\xB5\xD4\xB5\xE6\x82\x75\xFF\xA9\x4D\xBB\x6C\xB8\x3B\xB8\x1C\xBA\x10\x11\xEA\x9D\x73\xD2\xB9\x0C\xA6\xAB\xB9\x38\xB8\xAB\xB2\xFC\x9A\xEA\xA6\x73\xE2\xB9",
			"\x0C\xBA\x89\x02\x57\xBB\x9D\xB2\xD2\xBB\xB7\xA3\x75\xEF\xB9\x27\xBA\xA8\xBA\x43\xB8\x00\x07\xD6\xB3\xE7\xBE\x73\x91\xA7\x6D\xBB\x7E\xBA\x43\xB4\x22\xA1\xD7\xA1\xE8\x81\x73\xDB\xA9\x62\xBA\xE7\xB1\x41\x05\xAE\xB5\xD0\xB5\xE9\x9D\x72\xF9\xBA\x4B\xBB\xE0\xB0\x60\xBE\xA4\xBF\xD6\xA8\xEA\x81\x76\xCF\xB0\x7C\xBA\x85\xBB\x20\xBF\xA7\xBA\xD4\xA4\xEC\xB3\x75\xB1\xBA\x6B\xBB\xEB\x4D\x4F\xB8\xAC\xBE\x2F\xB2\xEC\x81\x75\xBA\xBA\xA1\x9E\xCB\xBA\x51\xBE\x9A\xBB\x45\xBA\xEC\x8E\x75\x98\xBB\xFF\xA8\xCF\xBA\x54\xBD\xAC\xBB\x9D\xA2\xED\x97\x75\xC7\xBA\x9D\xBB\x44\xAE\x69\xBB\xAB\xB8\xDA\xA1\xED\x97\x5D\xAB\xBB\x5F\xBA\xAE\xB8\x90\xA0\xB6\xB4\xD6\xAB\xEC\xAC\x65\xB4\xBB\x68\xBB\xC2\xB9\x6A\xBF\xB0\xBC\x76\xB8\xED\xAE\x75\x8F\xBB\x4D\xB3\xB1\x4F\x6B\xBA\xB5\xBA\xD7\xA2\xEE\xBC\x76\xCA\xAC\xBE\xBA\xB9\xB9\xC9\xB7\x27\x51\xD9\xA3\xEE\x87\x77\xB7\xBB\xC5\xBA\x4E\x52\x63\xBB\xB9\xB5\xB0\xA6\xEE\x93\x77\xBC\xB9\x3D\xB3\x82\x01\x72\xBE\xAE\xB3\xCB\xA6\xC7\x8C\x77\xCF\xBB\xFB\xAD\xED\xB9\x5F\xBA\xA0\xBD\xFC\x82\xEF\x8A\x76\x86\xBA\xFC",
			"\xA6\xF3\xB9\x44\xBC\xB3\xBE\xDA\xA0\xEF\xA5\x76\xEB\xBA\x95\x8A\x97\xBB\xE4\xB0\xA6\xB0\x00\x11\xEF\xB3\x74\xB9\xBA\x53\xBB\xEC\x9A\x7D\xB8\xA7\xBF\xAE\xA4\xED\x8C\x4C\xFB\xBB\x93\xBA\xD9\xB9\xE4\xA0\xC0\xB7\xD9\xB9\xEF\x83\x78\xD7\xAE\x04\xBD\xCD\xBB\x53\xBF\x0D\xA9\xE0\xBF\xEC\x86\x78\xB8\xA6\x0D\xBD\xD1\xBA\x6D\xBB\xDF\xA1\xE1\xA7\xED\xAC\x77\xFC\xA7\x15\xBC\xD6\xBB\x85\xBD\xF9\x99\xE1\xB1\xED\xAD\x76\x98\xBC\x08\xBC\xF8\xB9\x88\xBE\xBD\xB1\xF1\x9D\xF0\xB5\x76\xE8\xBB\x2D\xAC\x85\x02\x89\xB9\xB7\xB0\xDC\xB5\x05\xAB\x78\xBF\xBB\xD4\xBB\x82\x03\x8B\xBA\xB9\xB8\xDD\xAF\xCF\xB2\x78\xA3\xBC\xD7\xBA\xCA\xB6\x8A\xB9\xBA\xB3\xE3\xBC\xEE\x9A\x74\x87\xBA\xEC\x39\x1C\xBC\x7D\xBB\x3A\xB5\xDF\xA2\xF1\xA4\x78\xD6\xA7\x3D\xBD\xF1\xBB\x5D\xBC\xC3\xB8\xE3\xAA\xE9\x94\x76\x94\xBC\x4D\xBC\xF9\xBA\xEB\xB6\x83\xB4\x42\xAE\x08\x29\xB5\x01\xBC\x1F\xBC\x3A\x83\x95\xBD\xC0\xBE\xDF\xA2\x7E\x9B\x79\x8A\xBC\xA0\xBA\xFE\xA7\x97\xBE\xC1\xBD\xE5\xA0\x92\xA3\x79\x92\xBC\x28\xBD\x61\x9F\x99\xBE\xC2\xBB\xE0\xAD\x7E\xAB\x79\x9A\xBC\x6D\xBC",
			"\x89\x03\x9B\xBE\xC3\xBB\xE1\xAA\xF3\x97\x5D\xF3\xBC\x27\xBC\xBF\xBA\x98\xBF\xCE\xBC\xE7\xA7\xF2\xA6\x79\xEB\xBA\x78\xBC\x16\xBD\x8C\xBC\x20\x01\xE8\xB0\xF1\x8C\x65\x85\xBD\x34\xBC\x1D\xBD\x75\xBA\xB2\x5E\xE7\xB1\x9C\x88\x7A\xBE\xBC\x69\xBB\x3D\xBD\xA3\xBA\x82\xBA\x10\x0F\xF4\x8A\x79\xDD\xBB\x76\xBD\x49\xBF\x16\xAE\xD2\xB7\xDE\xBA\xF3\xA9\x78\x86\x02\x9C\xBD\xF5\xB9\x9C\xBE\x9E\xA2\xE7\xA0\xF4\xA6\x7A\x9A\xBD\xFF\xA9\x50\xBD\x48\xBB\xC2\xBB\x9D\xAA\xF5\xAC\x72\xE4\xBB\x99\xBC\x21\xBF\xEB\xB5\x4F\xAE\xEA\xA0\xE6\x98\x7A\xBB\x9E\xB5\xBC\x9A\xB8\xAC\xBC\x4F\xB5\x10\x1D\x30\xBC\x77\xC9\xB6\x69\xBC\x69\x38\xAA\xBF\x0D\xAE\xEB\xB8\xF2\xB5\x79\xBB\x9E\xC5\xBC\x2E\xBC\xAB\xBC\x61\xA9\xEC\xA0\xF3\x8F\x78\xDB\xA8\xCD\xBC\x32\xBF\xB2\xBE\x7A\xA1\xED\xA8\xF3\x9E\x7A\xD5\x8B\x57\xAF\x6A\xBC\x9B\xB9\xCC\xBD\xFC\x9A\xF6\xB0\x79\xDC\xBD\xC3\x9C\x6F\xBC\x9D\xBB\xD4\xB0\xFB\x82\xF7\xB9\x79\xBB\xBD\xE5\xBD\x6C\xBF\x5A\xBE\xDC\xB2\xE8\xB5\xF1\xBC\x16\x89\xAD\xEC\xBC\x43\xBE\xA2\xBA\x1B\xB0\x00\x11\xF7\x89\x7A\xC3\xBC\xD8\xBD\x61",
			"\xBD\xB7\xBB\xDD\xBA\xEE\xBA\xF7\xA1\x7B\xD1\xBB\xF6\xBC\x48\xBE\x6E\xB8\xC8\xB2\xEC\xB2\xF5\x94\x79\xB3\xA7\x05\xBE\x27\xBE\x80\xBC\xD2\xB6\x60\x9D\xF7\x86\x7C\xFC\xB7\xE9\xBC\x7F\xBC\xB2\xBE\xE1\xBA\xF0\xB9\xF2\xBF\x7B\x92\xBE\xAC\xB3\xDC\x89\xA2\xAB\xBA\x86\xEC\xA4\xF7\x9A\x7C\x98\xBE\x46\x9E\x8E\xBE\xB2\xB9\xD8\xB0\xFB\x82\xF9\x8E\x7B\xE5\xBC\x91\xA6\x93\xBE\xB4\xBC\xE4\xB1\xF2\xBB\xF8\x97\x5D\xAA\xBE\xD6\xBC\x74\xBD\xCB\xB8\xE4\xB4\x11\xB0\xF9\x9B\x7B\xCF\xBD\xFF\xA8\x9B\xBF\xB7\xB8\xE7\xBC\x3F\xBA\xF9\xA3\x7B\xE0\xBD\x3B\x9E\x9F\xBF\xB9\xBB\xC9\xBD\x31\xA0\x30\xAF\x7C\xAE\xBE\x34\xBE\x08\xAE\x42\x02\xE8\xBD\xEE\xB3\xF7\x84\x04\x4C\xBE\xF2\xBC\x7C\xBE\xD1\xB9\xE9\xB1\xDC\xA0\x00\x10\x7D\xF7\xBD\xB3\xBD\x5A\x83\xD5\xBA\xE0\xBD\xE2\xB2\x2E\x91\x77\xDB\xBE\x97\xBD\x1F\xBC\x5E\xBB\xEA\xBF\xF0\xB3\xD2\xAC\x6D\x9F\xBE\x65\xBE\x3B\xB6\xD7\xBC\xEA\xBA\xF5\xA7\xFA\xAC\x7D\xEB\xBE\x69\xBF\x53\xB4\xD8\xBD\xD3\xB2\xF3\xB5\xF9\xAB\x75\x87\x71\x1D\xBE\xA0\xBE\x42\x00\xEF\xB3\xF2\xB7\xF6\xB0\xE1\x6F\xBE\x7F\xBF\xB8\xBC",
			"\xC5\xB4\xEF\xB7\xF2\xB3\xF6\x80\x49\x84\xBF\x2B\xBE\xBF\xBC\xEC\x98\xF1\xB1\xF3\xA4\xFA\x81\x7E\x95\xBE\xC7\xBD\xC5\xBF\xD5\xAC\xF1\xB7\xF3\xA8\xF9\xB8\x4C\x94\xBF\x3B\xBE\xCB\xBF\x16\xA8\xF3\xBF\xF3\xBC\xF9\x8D\x3F\x9C\xBF\x43\xBF\x5B\xBE\xE4\xB8\xF0\xB7\x50\xA0\x00\x20\x7E\xCD\xBE\x52\xBF\xBD\xBD\xA2\xAF\xF4\xB1\xF5\xB9\xFA\x8C\x67\x8F\xBF\x52\xBD\xDF\xB4\xC4\xBE\xE8\x9C\xFA\xB8\xFA\x87\x7C\xFD\xA4\xB5\xBE\xAE\xBF\xA0\xBD\x62\xB9\xFB\xA1\xFB\x91\x7A\x9F\xBF\x93\xBF\xE8\xB9\xEF\xBC\xEE\xBE\xF8\xAA\xB1\xB0\x7E\xF7\xBB\xFD\xBA\xC3\xBF\x44\xBF\xF8\xBF\xEB\xA6\xDD\x9A\x7E\xFF\xBA\xCC\xBF\xBC\xBE\xE7\xBB\xD8\x93\xFC\xA2\xF5\xBA\x7D\xB4\xBF\xC1\xBE\xD2\xBE\x41\x05\xFA\xBB\xEA\xAC\xF9\x94\x44\xDC\xBF\xAF\xBD\xE2\xBF\x8D\xA9\xC3\x3C\x60\x83\xF0\x25\x7F\x8A\x02\xC3\x8B\xF4\xBF\xF9\xBE\x20\x0A\xFE\xA6\xFF\xAE\x7F\xE8\xBF\xEB\xBE\xF2\xBF\xFB\xBE\x20\x08\x94\x75\xFF\x92\x04\x76\xBF\x0E\x02\xFC\xBE\x42\x02\xFF\xB4\xFF\xB7\xFF\xBE\x7F\xF9\xBF\xFF\xBF\xFD\xBD\x00\xC6\x20\x06\x4F\x85\x08\x05\x80\x84\x02\x07\xC1\x64\x36\x44",
			"\x01\x01\xCC\x00\xCB\x00\xCE\x80\x8E\x02\x0D\xC0\x08\xC3\x03\xC2\x21\x01\x01\xD4\x00\xD8\x6B\x17\xC0\xC1\x35\x0C\xC2\xA7\x30\x03\xCB\x01\xDA\x00\xCD\x6B\x1C\xC0\x1F\xC0\x0F\xC1\x41\x03\x77\x80\x00\x04\x01\xE6\x80\x92\x02\x1F\x8A\xC1\xBC\xAF\xA9\x05\xC0\xF9\xBE\xF8\x85\x04\x2C\xC0\xB1\xBF\xFD\xB6\xD9\xB8\x00\x00\x03\xC8\xFE\x80\x7B\x8A\xBF\x46\x9F\x1A\xC1\xF3\xBE\x7A\xB3\xF0\xBC\x9F\xBA\x80\xD2\xBF\xCF\xBE\x1F\xC1\xA2\xAF\x07\xCD\xF7\xB5\xFB\x96\x3F\xC4\xC0\x85\xBE\xEF\xBF\x11\xC7\xEA\xA8\x04\xC9\xFC\x86\x81\xFD\xA4\x4D\xC1\xC6\xBE\xE8\xB9\x07\xCC\x04\xCB\xEB\x91\x81\x95\xBF\xCA\xBE\x9C\xA7\x15\xC1\xF3\xB9\x05\xC1\x7D\x9B\x81\x9D\xBF\x41\xC1\x4F\xBF\x0B\xC5\x0A\xCA\xFD\xA3\x03\xE5\x81\xE7\xBE\x66\xC0\x15\xC0\xBB\xB7\x0B\xC1\xFA\xA2\xFB\x8D\x3F\xEC\xC0\xA8\xBE\xD7\xBD\xE5\xB4\x06\xC1\xDD\xB0\x03\xED\x7E\xB7\xBF\x44\xBC\x3B\xC2\xED\xBB\xF6\xB5\xE5\xAA\x08\x3A\x81\xBA\xBF\xEE\xBC\x83\x03\x1F\xC6\xF7\xBD\x03\xCF\x03\xE4\x81\xEA\xC0\x31\xB9\x41\xC0\xF1\xBB\x0A\xC4\x11\xAA\x04\xD6\x7F\xD3\xBF\xBC\xBC\x82\x01\x52\x84",
			"\xEA\xB3\x09\xC8\x04\xF2\x64\x95\xC1\x2D\xC1\xEB\xBC\x45\xA0\x13\xC1\x03\xDD\xE0\xBC\x81\xD6\x9F\x9C\xC0\x1B\xC2\xF3\xBD\x0B\xCF\x4F\xA1\x05\xFB\x80\xBB\xB9\x4E\xBE\x00\x02\x29\xC0\x08\xC4\x0A\xCF\x83\xAB\x82\xC5\xC0\xE2\xBF\x4D\xC3\xD5\xAF\x15\xC9\x04\xD8\x01\xF2\x82\xE7\xC0\xAA\xC1\x59\xC2\x2E\xC0\x17\xC2\x2C\x74\x05\xCE\x81\xB1\xC1\xA0\xC1\x44\xAE\x2F\xC2\x0A\xCE\x06\xD8\xB5\x8E\x04\x43\xC1\x58\xC0\x25\xC1\x9F\xA0\x19\xCC\x05\xCA\x06\xF5\x02\xCC\xC1\x60\xC1\x56\xC2\x77\xBE\x20\x00\x0D\xCD\x03\xFF\x7E\xC3\x9D\xD5\xC1\x38\xC0\x1E\xC2\x22\x09\x0D\xD7\x03\xDF\x82\xDA\xB0\xC7\xC1\xE8\xB9\x37\xC3\x0F\xC3\x03\xDD\x05\xEB\x75\xE3\xC1\x80\xC1\x54\xC0\x3A\xC4\x10\xCD\xF5\xA1\x07\xF8\x82\xEB\xC1\x8B\xC1\x62\xC3\xCE\x98\x1E\xCF\x08\xC1\x03\xD8\x83\xEB\xBA\x6C\x86\x4B\xC0\xF9\xA1\x1F\xC9\x09\xD0\x04\xCA\x04\x7C\xC1\x9D\xC1\x13\xB9\x0C\xB8\x20\xC2\x0A\xDC\x01\xED\x83\xFF\xC1\x57\xAE\x82\xC3\x29\xC7\xA5\xB2\x07\xC8\x08\xD4\x7D\x8A\xC2\xAC\xC0\x67\xC2\x44\x00\x22\xC0\x0B\xCC\x04\xD6\x3F\x94\xC2\xB5\xC1\x27\xC1\x2D\x80\x23",
			"\xCF\x0B\xD6\x08\xFD\x49\x9C\xC2\xC4\xC1\x6B\xC3\xCE\x98\x24\xC9\x0C\xD6\x05\xD7\x84\xF8\xC1\x09\xC3\x44\xAC\x49\xC5\x19\xC6\x12\xC0\x07\xCE\x84\xFA\xC1\xB4\xB1\x95\xC1\x34\xC2\x22\xCE\x10\x12\x09\xD6\x83\x85\xC1\x45\xBF\x97\xC1\x3F\xC6\x1E\xC3\x12\xC9\x09\xF8\x82\xF2\x65\x36\xC2\x6D\xC3\x37\xC5\x06\xA3\x11\xC8\x09\xFC\x82\xC5\xC2\xB8\xC1\xA0\xC2\x37\xC3\x06\xCA\x14\xC4\x07\xE3\x65\xCD\xC2\xE9\xC1\xD4\xBE\x41\x00\x2A\xCC\x0E\xDB\xFD\x94\x85\xF1\xC1\x22\xC3\x8C\xBD\x41\x04\x6F\x8A\x10\x1C\x0A\xD0\x35\x7B\x86\x60\xC2\x87\x02\x57\xC3\x2B\xC1\x16\xDD\x0A\xE5\x85\xDF\xC2\x62\xC3\xB3\xC0\x59\xC1\x2D\xCC\x16\xD0\x7D\xB5\x02\xEF\xC2\xC3\x9C\xB8\xC3\xCE\x9A\x2E\xCA\x15\xD6\x7E\x84\x85\xF3\xC2\x39\xC2\xA3\x9C\x5D\xC3\xD1\xB7\x17\xD5\x0B\xD5\x7D\xFB\xC2\x14\xA2\xC0\xC0\xC2\xBC\x6A\x82\x11\x1C\x1A\x80\x00\x06\xC3\xB5\x80\xC4\xC1\x61\xC3\xD8\x9A\x18\xDD\x19\x8B\x86\xBB\x9E\x8D\xC2\xC2\xC0\x64\xC4\x31\xC4\x19\xD3\x0C\xD1\x82\x87\xC3\x95\xC2\xC9\xC2\xF1\xBA\x33\xC6\xF4\x91\x0C\xC6\x04\x1E\xC3\xF6\xB4\xD0\xC0\x9A\x81\x33\xCF",
			"\xC1\xBF\x0C\xC6\x83\x9C\xC3\x7D\xC0\xD3\xC3\x65\xC2\x34\xC8\x19\xD6\x0C\xF0\x3E\xAC\xC3\xB0\xC3\xBC\xC1\x41\x06\x4D\x87\x71\x32\x08\x34\x86\xC6\x9E\xB7\xC2\x8A\xA1\x6E\xC6\xFA\x9B\x1B\xDD\x93\xBD\x86\xBD\xC3\xB5\x80\xE0\xC2\x6D\xC3\xD8\x92\x1C\xCE\x08\x05\x87\xB5\xC3\x3B\x9F\xE3\xC3\x96\xA2\x39\xC3\x1B\xC3\x0E\xE4\x7A\xC6\xC3\xC4\xC3\xE8\xC3\x65\xC4\x39\xC4\x10\x14\x0E\xC0\x00\x56\xC3\xF2\x64\xEC\xC2\x73\xC6\x2F\xC6\x1D\xC2\x96\x56\x87\xDF\xC3\xD2\xC2\xD8\x9C\x78\xC7\x32\xC7\x6C\x86\x08\x25\x87\x85\x02\xE7\xC2\xEB\x9D\x7A\xC5\x4F\xAB\x1E\xD5\x05\xAD\x87\xC6\x8D\xF0\xC3\x9D\x9F\x7B\xC6\x21\x03\x1F\xCA\x08\x35\x87\xE6\xC3\xC3\x9D\xFB\xC0\x7A\xC2\x36\xC4\x10\x1A\x0F\xFD\x87\xF1\xC3\x9B\xC2\xFC\xC2\x7C\xC1\x3F\xCC\x1F\xC0\x00\x3E\x87\x86\xC4\x04\xC5\xE7\xC2\x7D\xC7\x34\xC2\x20\xDE\x0B\xC7\x88\xC2\x65\x07\xC5\x08\xC5\x82\xC0\xF6\x92\x21\xD7\x0C\xEE\xB8\x17\xC4\xC3\x9C\x17\x5D\x2D\x82\x43\xC5\xD5\x19\x10\xDD\x88\xBB\x9E\x1C\xC4\x87\x01\x88\xC2\x21\x03\x22\xCB\x13\x9E\x88\xA0\xC4\x05\xC5\x12\xC5\x41\x00\x43\xCA\x20",
			"\xC6\x11\xE8\x88\xAF\xC4\x7E\xC2\x15\xC4\x41\x02\x46\xCA\x25\x8C\x10\xEB\x88\xB6\xC4\x33\xC5\x14\xC6\x8E\xC0\x46\xC6\xF4\x94\x11\xFE\x88\xA7\xC4\x7E\xC3\x63\x92\x41\x02\x48\xC5\x10\x04\x12\xD6\x3F\xC6\xC4\x7D\xA4\x24\xC5\x2D\x82\x49\xC5\x26\x8D\x12\xFB\x3C\xCC\xC4\x0E\x02\x28\xC5\x95\x83\xD8\x92\x25\xC3\x12\xD4\x89\x85\xC4\x55\xC5\x22\xC6\x93\xC1\x40\xCA\x25\xCF\x12\xD7\x89\x97\xC3\x59\xC4\x82\x01\x98\xC0\x00\x03\x26\xD2\x97\x65\x89\xDB\xC4\xE3\xBE\x31\xC4\x96\xC7\x4B\xC0\xFB\x83\x13\xEE\x89\xEC\xC4\x69\xC4\x00\x03\xF1\x6B\x4E\xC2\x11\x14\x13\xCE\x04\x76\xC4\x0A\x02\x3C\xC6\x41\x02\x4F\xC5\x10\x1C\x13\xC4\x04\x7E\xC4\x72\xC4\xE1\x9C\x1D\x85\xF9\x94\x28\xC3\x76\x85\x8A\xC0\xA4\x87\xC4\xD8\x9D\xA2\xC6\xE8\x9B\x28\xC9\x0D\xDB\x51\x83\xC5\x38\xC4\xFE\xA5\xA3\xC3\x30\xC8\x33\xB3\x14\xEE\x84\xF5\xB9\x2D\xB9\xFF\xAA\xF5\xA6\x52\xC5\x0B\x9C\x14\xD4\x75\xDB\x1A\x12\x03\xE4\x6D\xF2\x6D\x16\x83\x2A\xC1\x15\xC3\x3B\xA5\xC5\x0E\x02\x51\xC7\xA9\xC3\x55\xCB\xF3\x88\x15\xCA\x04\x2E\xC5\xA0\xC5\x56\xC5\x81\xC0\x56\xC5\x10\x0A",
			"\x15\xED\x88\xB5\xC5\xAC\xC4\xD8\x9C\xAD\xC0\x0D\xC4\x10\x1B\x15\xC0\x00\x3E\xC5\xBE\xC4\x79\x65\xB0\xC6\x54\xC7\x19\xDE\x15\xC2\xCB\x40\xC5\xB9\xC4\xA3\x9C\xB2\xC2\x56\xC7\x19\xD1\x78\x8E\x8B\xD6\xA7\x0C\xA7\x68\xC4\xB4\xC2\xF8\x92\x2D\xC0\x92\x95\x8B\x91\xA7\xD7\xC4\x9C\xA4\xEF\xB4\xED\xAF\x2C\xC0\x92\xB2\xCB\x59\xC5\x5B\xA9\x6D\xC6\x92\xA8\x5C\xC4\xF0\xA4\xE4\xA8\x73\xE7\xC5\xDC\xC5\x69\xC6\xB5\xC2\x5D\xC8\x2D\xDF\x14\xC5\x04\x0E\x5A\x74\x80\x78\xC6\x44\x02\x5E\xCB\xF3\x94\x17\xF0\x3E\xF6\xC5\x46\x9E\x7C\xC4\x45\xA2\x5F\xC4\x10\x1C\x17\xFD\x49\xFE\xC5\xB5\x80\x80\xC7\xBC\xC6\x7A\xA2\x30\xCE\x08\x05\x8C\x8A\x02\x07\xC7\x2D\xA5\xC2\xC7\x5D\xC2\xFC\x8B\x18\xC5\x65\x86\x02\x0E\xC6\x9A\x58\xC1\xC6\x5D\xCD\x2F\xD3\x18\xC0\x49\x91\xC6\xF2\x64\x8C\xC7\xC0\xC1\x53\xC5\x31\xDC\x18\xD2\x8C\x97\xC6\x16\xC7\xC8\xA5\xC4\xC3\x64\xC4\x31\xCC\x24\x59\x37\x80\x49\x74\x80\x94\xC7\xB0\x9A\x65\xCB\xF3\x8C\x19\xF0\x3E\xAE\xC6\x46\x9E\x98\xC5\x41\x02\x66\xC6\xFD\x94\x19\xFD\x49\xB6\xC6\xB5\x80\x9C\xC6\x6D\x51\x72\xAA\x33\xD3\x20",
			"\x65\x8C\xBD\xC6\xE2\x52\x0E\x9C\xD0\xC3\xD1\xB3\x34\xD3\x19\xD6\x4F\xC5\xC6\xBC\xC4\x93\xC4\xCF\xC7\x68\xC9\x69\xBE\x19\xDE\x8B\xBB\xC6\x0C\xBE\xA3\xC6\xC7\xC0\x69\xCA\x34\xD8\x99\x94\x8D\xD7\xC6\x4C\xC6\x8F\xC6\x37\x44\x0E\x8B\x35\xD4\x24\x78\x4C\xDD\xC6\x3B\x9E\xB0\xC4\xEC\x9A\x6C\xC6\xF4\x84\x1B\xF6\x92\x5F\xC6\xD6\xA6\xB3\xC6\xF5\x9A\x6D\xCD\x27\xAC\x1B\xF5\x02\xEE\xC6\x5E\xC6\x4D\xC4\x28\x4F\x9F\xAC\x36\xD0\x1B\xF3\x81\xF6\xC6\xAB\x49\x2D\xA8\xDE\xC3\x4B\xAB\x37\xC7\x1B\xFA\x8D\xCD\xC6\x79\xC7\x72\xC4\x2D\x4A\x6B\xC5\x32\xDD\x1B\xC4\x04\x06\xC7\x9E\x49\xBF\xC4\x90\xA0\x71\xC8\x38\xC2\x96\x64\x4F\x8F\xC7\xB4\xB1\xB8\xB2\xE4\xC1\x72\xC5\x40\xB3\x1C\xCF\x61\x96\xC7\x6C\xAE\xCC\xC6\x92\xAD\x88\xB7\xAA\xB0\x1C\xE7\x6B\xE3\xB2\x9A\xC7\x91\xB8\xE8\xC4\x72\xCF\x39\xC7\xD5\xB2\xCB\x1C\xC7\x14\xB6\xC7\xC4\xE9\xC1\x73\xCB\x3A\xDB\x1C\xED\x8E\xA2\xC7\xC3\x2F\x02\xA9\x07\x31\xE2\x93\x3B\xD6\x9E\xB5\x8E\xC0\xA4\xB7\xC7\xC8\xA5\xEE\xC0\x67\xAB\x3B\xC1\x7D\xBD\x8E\xFF\xA9\xBF\xC6\xFE\xA5\xF0\xC5\xF9\x93\x3C\xC3\x76\x85",
			"\x8F\xBB\x9E\xC7\xC6\xD8\x9D\xF2\xC1\x4E\xCB\x3C\xD4\x88\x8D\x8F\xFF\x2F\x05\xB9\xD8\xC7\x13\xB7\x79\xCD\x27\xB4\x1E\xC4\x79\xD6\xC7\x12\x02\xEC\xC6\xF4\xC6\x5C\xCF\x7C\x31\x1E\xDD\x8F\xE8\xC5\xE0\x2E\xC1\xBB\xF6\xC2\xC9\xAA\x3D\xDF\x1E\xEC\x5D\xE5\xC7\xE1\xC7\xE9\xC6\xF8\xC0\x96\x85\x40\xB1\x25\xBE\x4B\xEE\xC7\xFB\xAC\xF8\xC7\x76\xB2\x7E\xCC\x30\xB4\x1F\xD6\x4F\xF6\xC7\xD9\x9A\xFC\xC5\xE4\xA2\x7F\xC8\x33\xBC\x1F\xDB\x51\xFE\xC7\xFF\xA8\x00\xC8\xFF\xA2\x80\xCD\xFC\x84\x20\xC5\x88\x86\xC8\x3B\x9E\x04\xC8\xFB\xC5\x74\xCB\x40\xCC\xBB\x8A\x90\xC6\x9E\x0F\xC8\x47\xC4\x41\x01\x82\xC6\xFD\x94\x20\xFD\x49\x96\xC8\x7D\xC2\xC3\x3E\xF7\xC2\x83\xC0\x3E\xC5\x08\x18\x90\xD9\xBB\x13\xC8\x5A\xB3\x07\xCE\x21\x03\x42\xCD\x20\xCA\x59\xA5\xC8\x1C\xC8\xB6\xAE\xB0\x66\x74\x41\xF1\x8C\x21\xC2\x3F\xAE\xC8\x40\xA4\x18\xC9\xE4\xA2\x86\xC8\x33\xB4\x21\xDB\x51\xB6\xC8\x24\xA0\x1C\xC8\xFF\xA2\x87\xCD\xFC\x9C\x21\xC3\x3B\xBE\xC8\x3B\x9E\x20\xC8\xEC\x9A\x88\xC6\xF4\x84\x22\xD2\x90\x80\x00\x46\xC8\xEB\x9D\x12\xC8\x89\xCB\x41\xC5\x08\x0B\x91",
			"\xB5\x81\x4F\xC8\x18\x55\x07\xCA\x6E\x44\x8B\xB1\x22\xCB\xA9\x0C\xC8\x7C\x47\x26\xC8\x15\xCB\x8A\xCC\x44\xDC\x22\xD6\x91\x86\x47\x55\xC9\x30\xCB\x13\xB7\x8B\xC9\x45\xDC\x22\xE7\xD2\x11\x9E\x67\xC8\xE1\x9D\x1A\xC8\x48\xAB\x46\xD1\x9C\xAD\x91\xB8\xA6\x6F\xC9\x2D\xA9\x1C\xCC\x04\xA3\x47\xDC\x9F\xB5\x91\xCD\x9F\x77\xC9\x61\x9D\x1E\xCB\xE7\x9B\x47\xD0\x7D\xBD\x91\xC6\x9E\x7F\xC9\x23\xC9\x20\xCE\xFA\x93\x48\xC0\x00\x05\x92\x99\xC8\xA6\x68\x5A\xB3\x21\xCD\xA7\x6A\x42\xCC\x24\xCA\x59\x8B\xC9\x70\x32\x2D\xCA\x21\xCA\x92\xC0\x49\xC5\xFD\x95\x92\xDB\xA4\x97\xC9\x44\xCB\x13\xB1\x93\xC5\x50\x6A\x24\xDE\x92\xDC\xC8\x59\xB1\x50\xCB\x58\xB3\x06\xC4\x4A\xC3\x25\xD8\x4C\xA5\xC9\xA7\xB4\x54\xC8\xC5\xB2\x95\xC5\xB4\xA5\x07\xFB\x7E\xA2\xC9\xA6\xC7\x57\xCA\x29\xCF\x54\xB2\x2C\x6C\x25\xEC\x6B\xB3\xC0\xF2\x64\x5C\xCB\xEE\xBD\x96\xCA\xF6\xA1\x04\xCD\x84\xD2\xC2\xBF\xC9\x60\xCB\x36\xC6\xC6\xBB\x95\x38\x98\x82\x77\x64\xA7\xC7\xC8\x5A\xB1\x32\xCF\x09\xBB\x4C\xCC\xBB\x8D\x93\xCA\xAC\xCF\xC8\x7F\xA5\x34\xCB\xDF\xA3\x4D\xDB\xCE\x95\x93\x8C",
			"\xA6\xD7\xC8\xEB\xA5\x36\xC8\x48\xAB\x4D\xD1\x9C\x9D\x93\xD1\xC6\xC5\xC9\x53\xB7\x37\xC9\xF4\x93\x4E\xC2\x1C\xC7\xAB\x14\xB6\xE5\xC8\xFE\xA5\x3A\xCB\x1A\xC7\x4E\xC5\xDA\xAB\x93\xC3\x9D\xEF\xC9\x5B\xC5\x38\xCC\x62\xB2\x2F\x71\x27\xFE\x85\xF6\xC9\x71\xC4\x7C\xC8\x45\xA2\x9F\xC6\xFD\x9C\x27\xFD\x49\xFE\xC9\xB5\x80\x80\xC9\x9E\x55\x97\xC6\xB1\x59\xAB\x87\x77\x64\xA7\x07\xCA\x5A\xB1\x42\xCF\x09\xBB\x50\xCC\xBB\x8D\x94\xCA\xAC\x0F\xCA\x7F\xA5\x44\xCB\xDF\xA3\x51\xDB\xCE\x95\x94\x8C\xA6\x17\xCA\xEB\xA5\x46\xC8\x48\xAB\x51\xD1\x9C\x9D\x94\xE0\xC9\x86\x33\xB1\xB3\x47\xC9\xF4\x93\x52\xC6\x27\xC3\xAD\x14\xB6\x25\xCA\xFE\xA5\x4A\xCC\x9D\xC7\x52\xC5\xDA\xAB\x94\xC3\x9D\x2F\xCA\x79\xC9\x48\xC9\x96\xCF\xAE\x44\x28\xDC\xAC\x34\xC9\xEE\x3A\x76\xB5\x4C\xC8\xF6\x9B\x53\xC6\x7A\xBD\x94\x94\xA2\x3F\xCA\xEB\x9D\x50\xCD\xEA\xB0\xDC\xA5\x2A\xFB\x7E\x87\xC2\x1E\xC3\x5A\x80\x52\xCA\x1E\xC0\x0C\xDD\x93\x8B\x95\xD9\xC2\x46\x9F\xA7\xC8\x4E\xC3\xE7\x92\x55\xD2\x2A\xC2\xCB\x55\xCA\x7E\xB0\xA9\xCA\xBC\x60\xAB\xCE\x4B\xD0\x2A\xC7\x91\xDC\xCA",
			"\xA9\xC0\xAD\xC9\x4B\xC0\x91\xCE\x55\xD4\x14\xCC\x95\xF1\xC4\x60\xCA\x60\xC9\x59\xCE\xA9\xC7\x54\xCD\x2B\xDD\x95\x95\xB6\x89\x65\x2C\xB1\x5C\xC8\x63\xA3\x57\xC7\xD5\xB5\x95\x94\xB6\x77\xCB\xA2\xB5\x5E\xCC\x5D\xBB\x57\xDD\xC5\xBD\x95\x96\xBA\xC3\x6D\xB7\xCB\x5F\xC9\x2E\xB3\x58\xD4\xC5\x85\x96\xCF\xB0\x87\xCA\xB6\xAD\x62\xCE\x2B\xB5\x72\x6A\x2B\xC1\x96\xA6\xB3\x8B\xCA\xB6\xB2\xBC\x61\xB2\xCB\x6F\xB4\x2C\xDB\x67\x96\xCB\xE2\xC5\x59\x6D\x2A\xC0\xB3\xC6\x3D\xBC\x2C\xCF\x8D\xD9\x6E\xC3\xC8\x2D\xA6\x66\xCE\xB1\xC2\x2C\x7E\x2C\xCB\x7F\xE3\x6E\x43\xC3\xC6\xCA\x30\xCF\xB1\xCE\x58\xC6\x2D\xF8\x4C\xAE\xCB\x5B\xA8\xD8\xC8\xF4\xBA\x21\x06\x27\x79\xC2\xB5\x96\x98\xA6\xB7\xCB\x53\xB5\x6E\xCC\x62\xBB\x5B\xC5\xDA\xBD\x96\xEC\xB5\xBF\xCB\x5E\xB1\x70\xC8\xB0\xC3\x5C\xD1\xCB\x85\x97\xB4\xB1\xC7\xCB\x27\xB1\x72\xCC\xED\xAB\x5C\xCA\xB2\x8D\x97\xB0\xC7\xB4\xCB\xDD\xBF\x73\xCF\x67\xA3\x5D\xDB\xCE\xB2\xCB\x55\xCB\x0C\xA6\xEC\xCA\xF5\xA2\xBB\xCE\x31\xDC\x2E\xD1\x4E\xDE\xCB\x38\xA6\xF0\xCA\xD4\xAA\x22\x02\x5E\xC6\x29\xC0\x00\x65\xCB\x1F",
			"\xAE\xF2\xCB\x2E\xCA\xBD\xCF\x56\xC8\x2F\xCD\x3F\xEE\xCB\xC3\x9C\xF8\xCB\xCE\x9A\xBE\xC0\xFB\x94\x2F\xF1\x89\xEC\x8C\xA6\xB2\xFC\xC8\x7D\xBA\xBF\xCB\x5A\xDC\x2F\xE1\x96\x86\x02\xFE\xCB\xD4\xCA\x43\x01\xC0\xC3\x03\xC4\x30\xD8\x4C\x86\xCC\xA7\xB4\x04\xCC\xC5\xB2\xC1\xC5\xB4\xAC\x30\xEC\x6B\x8E\xCC\x31\xB8\x08\xCC\x60\xCA\xC2\xC8\x3A\xC0\x30\xFB\x7E\x94\xCC\x05\xA8\x0C\xCC\x16\xCD\x20\x0A\x61\xCC\xBB\x9D\x98\xCA\xAC\x1F\xCC\xE8\xCA\x85\xCF\xAD\xC1\x62\xDB\xB7\xA5\x98\xD6\xCB\x12\x03\x13\xCE\xE6\xB1\xC5\xCB\x5E\xC3\x30\xED\x98\xD4\x40\x17\xCD\x18\xCC\x89\xCA\xC6\xC9\x0A\xCA\x31\xE5\x8C\xE4\x89\xA6\xB2\x1C\xCC\x7D\xBA\xC7\xCB\x5A\xDC\x31\xFF\x97\x85\x02\x3E\xCC\x01\xCE\x42\x01\xC8\xC3\x03\xC4\x32\xD8\x4C\xC6\xCC\xA7\xB4\x24\xCC\xC5\xB2\xC9\xC5\xB4\xAC\x32\xEC\x6B\xCE\xCC\x31\xB8\x28\xCC\x60\xCA\xCA\xC5\x61\xC0\x32\xFB\x7E\xD4\xCC\x05\xA8\x2C\xCF\x86\xCC\x20\x0A\x65\xCC\xBB\x9D\x99\xCA\xAC\x5F\xCC\x11\xCE\x95\xCF\xAD\xC1\x66\xDB\xB7\xA5\x99\xA8\xCC\x0E\x03\x33\xCF\x8A\xC9\xCD\xCF\x62\xC6\x08\x2A\x99\xB7\xCC\x57\xCD",
			"\x38\xCC\x99\xCA\xCE\xC9\x0A\xCF\x33\xDE\x8C\x94\x95\xB3\xBC\x3C\xCF\xED\xBA\xCF\xC2\x64\xDB\x52\xBB\x7E\xFC\xCC\x33\xC0\x40\xCF\x58\xB2\xD0\xC9\x57\xA4\x34\xD4\x6C\x86\xCD\x45\xB6\x44\xCC\xBB\xB2\xD1\xC1\xC3\xAC\x34\xC0\x96\x8E\xCD\x71\xB2\x48\xCF\xFA\xC6\xCF\xCF\x56\xD2\x34\xCB\x50\x96\xCD\xDC\xC6\x4A\xCD\x2A\xC0\xD3\xCA\x64\xBC\x34\xE2\x99\x84\x02\x9E\xCD\x7D\xAD\xA8\xCB\x3B\xB3\x6A\xCB\x33\xCA\x04\x25\xCD\x80\xC6\x4D\xCC\x69\xCA\x22\x08\x6A\xD7\x33\xFF\x99\xAF\xCD\x95\xCC\x58\xCF\xA6\xCD\xCD\xC6\xA9\x9E\xC3\x97\x2A\xB3\xBD\xB7\xCD\x1F\xCC\x41\x01\xD7\xCD\x67\xD5\x35\xEF\x95\xBC\xCD\x33\xC0\x60\xCC\xC6\xA2\xD8\xC7\xAA\xA4\x36\xD4\x6C\xC6\xCD\x45\xB6\x64\xCC\xBB\xB2\xD9\xC1\xC3\xAC\x36\xC0\x96\xCE\xCD\x55\xCD\x5D\xCF\xEE\xB8\xDA\xC5\x40\xB4\x36\xDB\x99\x80\x00\xD6\xCC\xB6\xAD\xB6\xCA\xC9\xAB\x6D\xDF\x34\xD8\x9B\xD3\xCD\xE0\xCD\xB7\xCA\xBC\x65\xDB\xC6\xC9\xB2\x08\x24\x9B\xDD\xB4\xE6\xCC\x5A\xCE\xB4\xCF\xD7\xC1\x6E\xC9\x05\xE7\x9B\x8C\xA6\xEF\xCC\xEB\xA5\xBC\xCE\x63\xCA\x0C\xD5\x37\xE3\x95\x96\xBE\x3B\x9E\x9A",
			"\xC2\x0B\xC6\xFA\x96\x6F\xDA\x08\xF8\x9B\xB0\x9F\xFA\xCC\x4D\xC0\xBF\xCF\xDE\xC1\xF9\xA6\x7A\x81\x9C\xF6\xB5\x07\xCE\x9E\xC3\xBE\xCF\x52\xCE\x0F\xC6\x38\xC4\x9C\x8B\xCE\x44\xBD\x84\xCE\x34\xC3\xD8\x92\x71\xD2\x97\x55\x9C\xFF\xCD\x71\xC4\x89\xCE\xB0\x62\xE2\xCC\x71\xCF\x38\xC2\x9C\xFD\xA4\x1D\xCE\x7F\xCC\x31\xCF\xB0\x1D\x12\xC8\x56\x93\x95\x8A\x02\x26\xCE\xA9\xC9\xCA\xCB\xF7\xBB\x72\xCF\x2B\xED\x9C\xA9\xC1\x2F\xCE\xFA\xB9\xCC\xCB\xB5\xC3\x73\xDA\x35\xE4\x9C\xA2\xCE\x28\xCE\x8F\xCD\x41\x05\xE6\xCD\x6B\xC4\x08\x3C\x9C\xB3\xC0\x3F\xCE\x9B\xCB\xCE\xCA\xE7\xCE\x73\xC5\x39\xC4\x9D\xDC\xA8\x39\xCE\x9C\xCE\x41\x01\xE8\xC7\xAA\xAC\x3A\xE9\x8E\xDD\x12\x47\xCE\xA7\xCD\xD1\xB2\xEA\xC1\xC9\xB0\x3A\xCA\x9D\xF4\xBD\x54\xCE\x7D\xBA\xD5\xCD\xA9\xC4\xE4\xB9\x3A\xC0\x96\xDE\xCE\x71\xB2\xB0\xCC\x2D\xB2\xEC\xCF\x84\xA4\x3B\xEC\x5D\xE6\xCE\x8C\xCA\x24\xB8\xF9\xA3\xE1\xB1\xFA\x8C\x3B\xFF\x53\xEE\xCE\xFC\xA6\xB8\xCD\xF3\x9A\xEE\xC3\xEC\x94\x3B\xEA\x9D\xB4\xB1\x76\xCE\xD8\x9D\xDE\xCE\xE8\x9B\x77\xD4\x88\xBD\x9D\xD6\x9F\x7F\xCF\x3E\xA5",
			"\xE0\xCC\xC8\xB3\x78\xD0\xE1\xB2\x64\x85\xCF\x73\xC0\xC4\xCC\x13\xBF\x09\xBA\x78\xDB\x92\x8D\x9E\x9E\xBA\x6C\xB3\xC7\xCF\xC3\xC0\xF2\xC5\x6E\xD7\x3B\xDC\x91\x92\xCF\x15\xB6\xCC\xCE\xE6\xC8\xE3\xCE\x77\xDC\x3C\xC0\x9E\x9E\xCF\x82\xCE\xD0\xCC\x91\xBB\x59\x93\x71\xCE\x55\xA0\x9E\xA4\xCF\x12\xCE\xD4\xCF\xD1\xCA\xF5\xC7\x75\xC4\x08\x2C\x9E\xDC\xCE\x12\x03\xD7\xCE\x47\xC2\xF6\xC7\x56\xD4\x88\xB4\x9E\xEB\xCA\xB5\x81\xDB\xCF\xC9\xCE\xE8\x9A\x7B\xD2\x2A\xFD\x9E\xBB\xBF\xBF\xCF\xB7\xC9\xF0\xC9\x15\xC2\x2C\x63\x3E\xCE\x96\xC6\xCF\xB3\xBC\xE4\xCE\xCD\xCA\x5E\x6A\x7C\xDD\x39\xD0\x2A\xA2\xCF\xB1\xCE\xE8\xCF\xC8\xCD\xF9\xC3\x03\xD4\x3E\xE3\x65\xD6\xCF\x34\xCA\x65\x96\xF4\xCA\xB4\xCE\x7A\xDB\x3E\xDB\x49\xD8\xCF\x4F\xCE\xD3\xCD\xC1\xCE\xF6\xCE\x7D\xD8\x99\x25\x9F\xDD\xCF\xE3\xCE\xEB\x9C\xF8\xCD\x68\xBB\x7E\xC8\xE1\xA8\x82\xF4\xBB\x02\xC2\x99\xB1\xFC\xC9\x2E\xB3\x7F\xD4\xC5\xB5\x9F\xCF\xB0\xF7\xCE\xB6\xAD\xFE\xCC\x4F\xAB\x7F\xCC\xCB\xBD\x9F\xFB\xAD\xFF\xCF\xED\xB1\x00\xD4\x61\xA3\x80\xD6\x9E\x85\xA0\xC0\xA4\x07\xD1\xD3\xCB\x94",
			"\xBE\xF9\xC9\x80\xCC\x72\x8D\xA0\xE3\xCB\x0C\xC2\x9B\xCF\x03\xD7\x9F\xA3\x81\xC9\x2F\xD1\xA0\x8C\xD0\x86\xCE\xFA\xCD\x06\xD2\x92\xC5\x81\xC2\x03\xF2\x80\xC2\xCE\x1F\xD0\x9C\xCB\x05\xD3\x06\xCD\x81\xC3\x76\xA5\xA0\xBB\x9E\x27\xD0\xD8\x9D\x0A\xD6\xE8\x9B\x82\xC7\x22\xE4\x28\x94\xCF\x05\xA7\x17\xD2\x4F\xBE\x5F\xA2\x83\xCF\xF2\x9B\x67\xB5\xD0\x98\xCE\x1C\xD3\xF9\xC8\x00\x0A\x83\xC9\x3F\xFD\x49\xBD\xD0\x0B\xCE\x20\xD3\xC7\xCD\x16\x82\x84\xCD\x38\xD4\x44\xC5\xD0\x0A\xCE\xA3\x9C\x12\xD5\xF4\xC0\xFB\x8B\x42\xD2\x9C\xCE\xD0\x47\xCE\x28\xD1\xEB\xCD\x62\xB2\x85\xD0\x3D\xCE\x04\x55\xD0\x1E\xC2\x2C\xD1\xED\xCA\xE9\xB8\x74\x3B\x40\xCF\x61\xDA\xD0\xB8\xCE\x89\x00\x18\xD3\xF7\xCE\x82\xDE\x42\xEC\x5D\xE3\xD0\x52\xCA\x34\xD3\xEE\xBA\x5E\x6A\x86\xC2\x37\xE2\xA1\xE6\xD0\x69\xCE\x85\x01\x1B\xD4\xF8\xCF\x86\xD6\x3C\xE7\xA1\xF0\xD0\x6C\xB3\x39\xD2\x63\xCA\x0F\xDB\x5A\xDC\x43\xF6\x9C\xFE\xD0\xCE\xCE\x61\x66\x41\xC6\x0F\xB3\x88\xCC\xCA\x85\xA2\xA9\xC1\x87\xD0\xC7\xC9\x22\xD3\xB5\xCB\x88\xD6\x39\xCD\xA2\xDF\xC1\x8F\xD1\x19\xC1\x24\xD3",
			"\x2C\xB3\x89\xC7\xD5\x95\xA2\x94\xB6\x97\xD1\xA2\xB5\x26\xD4\x5D\xBB\x89\xDA\x3A\xF6\x7A\xDB\xD0\x7D\xA5\x4E\xD2\x4C\xB2\x14\xD1\x97\xB2\x97\x64\xA2\xB4\xB1\xA7\xD1\x27\xB1\x2A\xD5\x91\xCF\x89\xC1\x43\xED\xA2\xE4\xD0\xD6\x9F\x55\xD1\x58\xBF\x15\xD2\x56\xD4\x45\xEA\x9B\xA3\xC1\x1A\xCF\xF0\xBD\x52\xCA\x17\xD0\x8A\xD5\x05\xB2\xA2\xEC\xB2\xBF\xD1\x7D\xAD\x30\xD3\x3B\xB3\x8C\xD9\x2C\xC4\x04\x14\x94\xF3\xBB\x59\xBC\x32\xD3\x01\xD9\x85\xAB\x46\xF2\x7E\xB3\xC0\xCE\xD1\x10\xD0\xC5\xB1\x1A\xDE\x09\xD0\x46\xEF\x9F\xAB\xCB\xD4\xD1\x16\xD3\x31\xD7\x1A\xD6\x73\xD9\x46\xF8\xA1\xFB\xAD\xDE\xD0\x3B\xD2\x92\xA9\x1C\xDB\x78\xCC\xBB\xA4\xA3\xB7\xB9\xE3\xD0\x6E\xD2\xF3\xCF\x1C\xD0\x83\xC6\x46\xC0\x00\x6C\xD1\x33\xD0\x70\xD2\x3A\xD5\x19\xD3\x8F\xC3\xCB\xB2\xCB\x70\xD1\x36\xD0\x86\xA4\x3E\xD0\xF3\xCB\x8F\xDB\x41\xC2\xCB\x7D\xD1\x3E\xD1\x5A\x80\x40\xD0\xE2\xC2\x11\x03\x48\xC3\xA1\xAF\xBF\x0A\x02\x83\xD2\x11\xD4\x0B\xD5\x10\x0A\x48\xC9\xA1\xC7\xC8\x0E\xD2\x26\xD1\x9C\xC1\x22\xD2\x71\xD4\x48\xC7\x9D\x96\xD2\x53\xD0\x8C\xD2\x15\xD1\x21",
			"\xD5\x8F\xC7\xD5\x9A\xA4\xBB\xD1\x23\xCF\xEE\xBD\x4B\xC2\x24\xDF\x04\xC4\x49\xDB\xA4\xD1\xC2\xAB\xCA\x93\xD0\x48\xD6\x29\xC7\xAA\xAA\x49\xE0\xA2\xAE\xD2\xAE\xD0\x96\xD0\xC5\xB0\x26\xD0\x8B\xDD\x93\xB4\xA4\xD2\xCA\x37\xD3\xDD\xBD\x4E\xD7\xAD\xCB\x93\xD4\x43\xCB\x85\xE3\xB2\x3D\xD2\xFA\xB9\x50\xD3\xB5\xC2\x2F\x63\x4A\xF6\x9C\xC6\xD2\xCE\xCE\xA4\xD2\x2B\xCF\x27\xDD\x92\xDC\x45\xF1\xA4\xA8\xD2\xCB\xCE\xA1\xC2\x2E\xCC\x29\xD1\x7E\xD2\x49\xC5\x6D\xC2\x65\x4A\xD2\xA0\xD2\x53\xD5\x26\xD5\x0B\x99\x4A\xCD\xA5\xB6\xD1\x3C\xD3\xAD\xD0\x4E\xD2\x2C\xD7\x8B\xD4\x51\x96\xA5\xD5\xAB\x66\xD2\xA8\xD3\x37\xC1\x2D\xD5\x15\xCF\x2B\xEC\xA5\xD8\xC2\x5C\xD2\x89\x03\x5B\xD5\x1E\xC2\x91\xD4\x88\xB3\xA5\xDE\xD2\x14\xB7\xBB\xD0\x59\xD4\x29\xBA\x97\xC0\x4B\xE9\x82\xFD\xD2\xBA\xBD\x93\xD1\x41\x00\x30\xD8\xDF\xAF\x48\xD6\x3F\x84\xD3\xC9\xBE\x89\xCC\x62\xD7\x06\xC3\x85\xCB\x4C\xF8\xA2\xC7\xCE\x8E\xD3\x62\xD1\xC9\xC1\x32\xDD\x91\xD9\x4B\xD2\xA5\x98\xA6\x94\xD3\x11\xD2\x3D\xD2\x2E\xD7\x99\xC7\xD5\x99\xA6\xC9\xD1\x36\xCF\xCF\xD0\x33\xD0\x04\xD0",
			"\x00\x02\x4D\xCF\xA3\xE3\xB2\xA6\xD2\x69\xD1\xD1\xB1\x35\xD5\x8D\xDB\x4C\xCC\x36\x1D\xD3\xF4\xC8\xCE\xD0\x55\xD7\x2A\xD2\x9B\xC7\x4B\xDE\xA2\x8A\x02\xAC\xD2\x6D\xD1\x9F\xA1\x37\xDF\x8D\xDB\xCE\xBC\xA6\xE2\xD1\x6C\xB3\xDF\xD1\x39\xD2\xC9\xA2\x9C\xC8\x47\xC1\xA7\xB0\xD3\xB4\xD2\x87\x01\x5F\x8B\x36\xD5\x5D\xAB\x4E\xF6\xA6\xB2\xB2\xCE\xD2\xB5\xD3\x0C\xC1\x3A\xDD\x96\xC9\x05\xD4\xA7\xF0\xD2\x52\xCB\xEB\xD0\x5D\xD2\xE2\xCA\x9D\xD8\x4B\xFC\x5A\xDD\xD3\x7B\xD2\xEB\xD0\x72\xD4\x5D\xB0\x9E\xDE\x4B\xCE\x96\xE5\xD3\x81\xD3\x95\xD2\x41\x00\x3D\xD5\x98\xD5\x4B\xD6\x3F\xEC\xD3\x89\xD3\xA3\xCC\x7C\xD4\x31\xD2\x98\xC9\x1A\xF3\xA7\x8F\xD3\x53\xD1\xFB\xD2\x64\xD1\xBB\x9A\x9F\xD5\x4C\xC5\x6D\xF2\x65\xFD\xD2\xCD\xD3\xA9\xB1\x40\xD0\x9A\xCE\x3E\xC4\xA8\xA3\xD3\x22\xD0\x85\x03\x81\xD7\x34\xD3\xA0\xC3\x4F\xF1\x70\x8B\xD4\xAA\xD3\xAA\xCE\x72\xD6\x41\xD0\x58\xC0\x50\xD4\xA8\xD1\xCD\x00\x00\x08\xD5\x6B\xD1\x41\xDB\x9E\xD7\x50\xF4\x62\x9A\xD4\xBA\xD3\x5A\x80\x88\xD5\x37\xDC\x30\xA3\x51\xC0\xA7\xFB\xAD\x26\xD5\xE1\xD0\x5B\xB1\x45\xD6\x9C",
			"\xCF\xD8\x99\x84\xCD\xCA\x37\xC2\xE0\xB9\x8C\xD3\xF7\xB3\xA3\xCF\x2B\xF5\xA8\xA9\xC1\x37\xD4\xC7\xC9\x8E\xD3\xD6\xBB\xA3\xD6\x39\xFD\xA8\xCE\xCF\x3F\xD5\x19\xC1\x90\xD3\x2C\xB3\xA4\xC7\xD5\x85\xA9\x94\xB6\x47\xD5\xE4\xD1\x47\xC5\x17\xD5\x11\xC0\x45\xC9\xA9\x92\xD4\x4B\xD5\xA7\xD1\x49\xC3\x0A\xDF\xA4\xD7\x4D\xE1\x84\xF1\xD2\x2F\xD4\xF5\xD3\x94\xD5\x3E\xD8\x74\xD7\x52\xF5\xA2\xD1\xD4\x58\xD5\xD2\xBD\x95\xD0\xB0\xC2\x2C\x63\x53\xF1\x65\xE6\xD4\xB4\xB0\x34\xD7\x13\xB2\x4D\xDC\x76\xAC\x53\xCA\x59\xEE\xD4\xDE\xCC\xB9\x48\x9C\xD7\x67\xA2\xA7\xDE\x50\xCB\x50\xF5\xD4\xCC\xD3\x18\xB8\x9E\xD7\x39\xD1\x97\xBB\x53\xD2\xA7\xE3\xB2\x7E\xD5\xEA\xD2\x63\xC9\x50\xD8\x9D\xDE\xC3\x84\xAA\xDB\xD3\x47\xCF\x43\xD6\x77\xD4\x5D\xBA\xA8\xC1\x4F\xC3\xAA\xCD\xD4\x52\xD5\x89\x48\xA4\xD1\x4C\xDA\x56\x59\x52\xCC\xA9\xA9\x4A\x93\xD4\xAB\xCA\x44\x05\x51\xD6\x9E\xCB\x2D\xDC\xAA\xE9\xD3\xA0\xD1\x4F\xD5\x7B\xD7\xE2\xC8\xA9\xD6\x54\xD1\xAA\xDF\x4A\x99\xD5\xDD\xBE\xA8\xD1\x3E\xD3\x85\xC2\x96\x6B\xAA\xF4\xD3\x5A\xD4\x49\xD6\xA9\xD4\x52\xD2\x5A\x49",
			"\x55\xEE\xA1\xA5\xD5\x60\xD5\x2F\xD5\xA5\xD1\x57\xD7\x8B\xCF\x55\xF8\xA7\xDC\xD4\xAE\xD4\x5B\xD5\x2A\xC6\x57\xDB\x9F\xD1\x9C\x84\xAB\xFE\xD3\x8C\xD4\x61\xD7\xA3\xD3\x56\xD2\x55\xC7\x56\xC2\xA8\xD5\xD2\x3B\xC2\xF7\xD3\x42\xC5\x40\xD9\x85\xB1\x08\xC7\x9D\xD6\xD5\x53\xD0\x6C\xD4\x97\xD2\x5B\xD1\xAB\xD3\x56\xC8\xA8\xEE\xAA\xDC\xD5\x4B\xD4\x4C\xC7\x09\xB1\xAE\xC7\x55\xE5\xAB\xB4\xD5\x05\xC2\x64\xD5\x0C\xBF\x5C\xD2\x55\xCC\x57\xF7\xA2\xEE\xD5\x6F\xCA\x78\xD6\x69\xB2\x5E\xDE\x58\xD2\x97\x74\xAB\xAB\xCB\xF7\xD4\x9B\xCD\xBE\xD1\x10\xD7\x75\xBB\x57\xF3\x80\xFE\xD5\xAE\xD3\x71\xD5\xA6\xC9\x20\xC4\xA2\xC5\x19\xC0\xAC\x9C\xD4\x04\xD7\x13\xD7\x76\xB7\x60\xD4\xB1\xAC\x58\xC5\x6D\x8E\xD6\xEC\xB4\x88\xD7\xBA\xD2\x59\xDB\x5A\xC2\x96\x54\x95\x12\xD6\x32\xB3\x8B\xD4\xC5\xD7\xF6\xBA\xB1\xCC\x56\xFB\x7E\x9D\xD6\xBC\xD5\xB7\xC8\xC8\xD6\x4B\xDF\xB1\xD7\xBA\xA3\xAC\xDB\xD4\x1E\xC3\x93\xD4\x4B\xC3\x0A\xDA\xB2\xD3\x09\xC7\x9D\xAD\xD6\x73\xD5\xED\xB0\xCC\xD6\x4E\xDC\x76\xB3\x59\xF9\xA9\x80\xCB\x36\xD6\x3E\xD4\x2D\xB1\x67\xDF\xA7\xC8\x58",
			"\xF9\x95\x26\xD6\x89\xAC\x9E\xD6\xA0\xD4\x28\xDF\x59\x40\x5A\xF8\x82\xC2\xD6\x85\xD5\xB7\xCA\xC5\xD6\x68\xD2\xB0\xCA\xB2\x88\xAD\x88\xD5\x53\xD0\x79\x67\xD3\xD3\x51\xD1\xC3\xB2\x5A\xEB\x75\xD3\xD6\x8E\xD5\x8A\xD5\xD1\xD7\x68\xDC\xB4\xD1\x56\xD2\x9C\xD8\xD6\x9D\xD4\x9B\xCC\xD8\xD0\x54\xD7\xAA\xC3\x5B\xE3\xAA\xC7\xCE\xC2\x64\xD4\x3E\x43\x03\xF5\x3E\x10\x12\x32\x58\xAC\xE4\xA7\x6C\xD6\x03\x4D\xA2\xA9\x6E\xD0\x64\x58\x05\xF4\xAD\xE5\x4C\x4D\xD6\xB6\xB3\xDD\xD6\xC5\x47\x75\xBB\x5B\xDB\x99\x2A\x3F\x39\x4D\xBC\xD7\xBE\xAE\x6F\xDE\xB6\xDB\x58\xDF\x83\x84\xD7\x7D\xD7\xC0\xD6\xD7\xD7\xE8\xC8\xB8\xD6\x5B\xCA\xAE\x89\xD6\x2A\xD5\xC1\xD7\xE3\xD1\x5D\xDF\xAC\xC5\xDA\x8D\xAE\x82\xD7\xDB\xB3\xCB\xD7\xE2\xD5\x55\xD0\xB8\xCD\x5B\xC9\xAE\x9E\xD7\x54\xBE\xCD\xD4\xE4\xD5\x45\xD8\x66\xCA\x08\x22\xAE\x94\xD7\xD4\xD5\xB1\xB3\xE9\xD6\x5B\xDC\xA0\xD4\xD8\xAB\xAE\xEF\xD6\x93\xCD\x82\x03\xEB\xD6\x70\xD3\x03\xD3\x5D\xDE\xAC\xEF\xCA\x7E\xD6\xBF\xD7\x5D\x3C\x20\x0E\xB7\xC6\xDF\x06\x04\x39\xD7\x9D\xD6\xD3\xD5\xF0\xD7\x77\xDA\x1D\x72\x5D\xF8",
			"\xC7\x44\xD7\x6B\xD7\xE3\xD6\xF1\xD1\x79\xD0\xBA\xD8\x5C\xE6\x9A\xC8\xD7\x72\xD7\x9F\xC3\xF0\xD5\x20\x06\x1F\x78\x82\x7E\xAD\xF6\x63\xD7\xD7\xE9\xD4\xDF\xD7\x28\xCC\xBC\xCA\x08\x3B\xAE\x80\x00\xBA\xD6\xED\xD4\x00\x05\x70\xD7\xBB\xDE\x49\xC2\xAF\xCD\xD7\x9B\xD6\x2E\xD6\xED\xD1\x64\xD9\x0A\xCB\x5F\xE4\xAC\xB8\xD7\x93\xD6\xD6\xD5\x84\xD1\x86\xBE\xBE\xC8\x59\xE2\xAB\xD0\xD7\x75\xD6\xE7\xD5\xC9\xC6\x10\x64\xBE\xCC\x5F\xF4\x77\xFC\xD7\x89\xAC\x00\xD8\x2E\xC2\x80\xDA\xBF\xC0\x92\x84\xB0\xE9\xD7\xDD\xD4\x43\x63\x8D\x4F\x80\xD3\xBA\xCD\x47\xD6\x4F\x8C\xD8\xA8\xD7\x6F\xD4\xAF\xA8\x82\xD2\xBF\xDB\x50\xD4\x6C\x94\xD8\xB0\xD7\x27\xB0\x06\xDC\x76\xD3\x96\xBB\x60\xE5\xAF\x8E\xCB\x1E\xD8\xFF\xD7\x6A\xC9\x84\xDF\xBE\xC9\x05\xE4\xB0\xF6\xD7\xA7\xD4\x61\x67\x09\xDB\x65\xDC\xA5\xCB\x61\xEE\xAC\xCF\xC0\x2E\xD9\x98\xD7\xF3\xD5\x20\x01\xC3\xD4\x59\xCA\x59\xB5\xD8\x37\xD7\xB8\xB0\x0E\xDA\x67\xDC\x45\xDB\x61\xFD\xAC\x97\xD8\xF1\xD7\x0C\xD8\xDB\xAE\x10\x66\x08\x7F\x5E\xC6\xC2\x3E\xD7\x34\xD8\x89\x00\x11\xDA\x89\xDC\xC4\xCE\x08\x06\xC2",
			"\x0F\x60\x86\x60\x5C\x63\x12\xDB\x43\x6A\x10\x13\x62\xD1\xAF\x85\xD8\x24\xB8\x27\xD9\x10\xDC\x83\xD9\x7D\xC6\x08\x06\xC2\x55\xD7\x4D\xD8\xAD\x61\x18\xDE\x20\x06\x1F\x7E\x61\xC3\xAD\xB6\xCE\x2A\xD8\x89\x02\x11\xDA\x8D\xD3\xC6\xD8\x5B\xC8\xB0\xF7\xD7\xF6\xB4\x33\xD9\xD2\xD6\x84\xDB\xC5\xDF\x60\xE3\xB0\xF5\xD8\x22\xD8\x9B\xCE\x1C\xD8\x6A\xDD\xC2\xD8\x63\xE5\xB0\xA0\xD8\x7E\xD8\x14\xD8\xBA\xD5\x62\xBE\x17\x4B\x6E\x49\x67\x42\xD8\x7C\xA5\x43\xD8\x17\xDE\xAD\xAA\xC8\xD6\x63\xF6\x9C\x8D\xD9\x79\xD8\xE7\xCC\x24\xDF\x8F\xDB\x5A\xD3\x64\xC2\xB2\xD2\xCA\x96\xD8\x16\xDA\x47\xC1\x93\xDF\xC2\xDC\x52\xDC\xB2\xB2\xD8\xD6\xA7\x4F\xDA\x0D\xDC\x2D\xB2\xCA\xD9\x61\xF4\x62\xA5\xD9\x3C\xD8\xB6\xAC\x2A\xDF\x87\xD5\xB4\xAB\x65\xE7\xB1\xFC\xD5\x33\x38\x44\xD8\x29\xD9\xD1\xAE\xCA\xD3\x63\xF5\xAB\x9B\x36\xB2\xD9\x7D\xAD\x2D\xDC\x8F\xDD\xAD\xDB\x65\xD4\xAD\xE4\xD4\xB8\xD9\x45\xD9\x2B\xDF\xEA\xAE\xCB\xD9\x5A\xD1\xA5\xB1\xD9\xC2\xD8\x28\xD4\x20\x3D\x81\xD1\x8F\xC8\x37\xC8\xB3\x8E\xD9\xB0\xD9\x1E\x39\x05\xD9\x44\xD1\xCC\xD0\x66\xF3\x80\xC5",
			"\xD9\x61\xD6\x49\xD8\x31\xDB\x9B\xDC\xBD\xCA\x08\x3C\x1A\x8E\x02\xDF\xD8\x6F\xDA\x44\x01\x9C\xD6\x10\x04\x67\xC5\x04\x66\xD9\x04\x02\x74\xD8\x00\x02\x9D\xDC\xCE\xC3\x67\xEE\xB3\xE0\xD9\xEF\xD8\x71\xD8\x3C\xDE\x21\x0E\x6B\x94\xFA\xB5\xB3\xD8\xD8\x4C\x9D\x7B\xDB\x1B\xDF\x54\xDA\xCF\xCC\x66\xF9\xA3\xD6\xA7\xFD\xD9\x08\xD9\xEB\xD5\x68\xB1\xD0\xD3\x66\xC5\xAC\xC0\xA4\x05\xDB\x5C\xD9\xC1\xA1\xA1\xD9\xCC\xD1\xE1\x8C\xB4\xD6\xD9\x63\xB3\x87\xD9\x24\xDB\x06\xC2\xD1\xD4\x64\xF6\x9C\x95\xDA\x97\xD9\xDD\xBC\x46\xDA\x93\xD0\xC7\xC4\x08\x1B\xB4\x9D\xD9\xDD\xD4\x61\x67\x47\xD8\x94\xD8\xD0\xC9\xB4\xA3\xB4\xA3\xD9\x95\xCE\x85\x03\x49\xDE\x94\xDF\x84\xAB\x69\xE9\xB2\xCA\xAC\x2E\xDA\x56\xDA\xFB\xCC\x9E\xD7\x75\xB1\x69\xEF\xB2\x94\xDA\xD1\xBA\x9B\xDA\x2D\xDC\x68\xD4\xD3\xDD\x66\xC6\x04\x3A\xDA\xBC\xD9\x8E\xD9\xC5\xB0\xA8\xDF\xCB\xD1\xCB\x84\xB5\xC6\xD9\xCE\xCF\xA3\xD9\x36\xD8\xA7\xD8\x0B\xCA\x6A\xE4\xAD\x83\xD9\x4E\xDB\xB3\xD4\xE7\xD6\x21\x0A\x6B\x8E\x08\x00\x1B\x8E\x02\x7E\x43\xAB\xDA\x42\x03\xB9\x50\x47\x94\xFA\x9D\xB5\xF8\xD9",
			"\xA1\x9F\xAF\xDB\x3E\xDB\x90\xD2\xD6\xDE\x67\xD8\x9E\xE5\xDA\x02\xDB\xF9\xD4\x60\xC8\xAD\xD6\xD0\xCA\x58\xCC\x4C\xEC\xDA\x0A\xDB\x88\x9C\x5C\xDD\xA1\xDB\xD6\xD7\xBA\xB3\xB5\x90\xDA\xA7\xB5\xBB\xDB\x44\xDB\x2C\xBA\xD7\xD6\x68\xCE\x9F\xFD\xDA\x19\xDB\xB7\xC8\x60\xDC\xA3\xD9\xC2\xD2\x08\x03\xB6\xA0\xDA\x42\xDB\xC3\xD8\x49\xDC\xC3\x9A\xD8\xC8\x69\xE5\xAE\x86\x02\x8D\xDA\x96\xD8\xDB\xA9\xB2\xDF\xD2\xCC\xCB\x94\xB6\xB2\xDA\x56\xD5\x82\x03\x65\xDF\xA6\xDC\xD7\xD6\x6B\xD1\x77\x9B\xDB\x3B\xDB\x63\xDA\x42\x00\xB4\xD1\xD4\xC5\x6C\xCE\x04\x24\xDB\x45\xDB\xD8\xD4\x41\x00\xB5\xD8\xD4\xD3\x01\xEC\xB6\xCB\xDA\x9D\xDA\x5C\xC3\x6B\xDF\xA9\xD2\x55\xD3\x6D\xD2\xB5\xDC\xD4\xB6\xDA\x56\xD4\xB0\xD1\x2F\x5D\x90\x54\xFA\x97\x9E\x71\xDA\xC2\x9F\xDF\xD8\x5D\xD9\x2E\xB2\xDC\xD8\x6B\xD4\x6C\xC5\xDB\x7B\xDB\x53\xB4\x72\xDE\xAF\xD3\x03\xCB\x6E\xC1\xB6\xA6\xB3\xCE\xDA\xC2\xDB\x20\xD9\xBA\xD8\xD8\xC7\x55\xD4\xB7\x8B\xDB\x38\xA7\xEB\xDA\x63\xDC\x61\xAA\xDD\xD2\x6C\xCA\x59\xDD\xDB\x95\xDB\x7D\xAC\x78\xD8\xB3\xD0\xCC\xC4\x46\x60\xB5\xFF\xA9\xE3",
			"\xDA\xCE\xD9\x5E\xA9\xBD\xD1\xDA\xCE\x3E\xF2\xCB\x6C\xDB\xA5\xDB\xE9\xDB\xD5\xA8\xBE\xD9\xDA\xDC\x22\xF4\xB7\xAD\xDB\x63\xB3\xFB\xD8\x6C\xDA\xB9\xD1\xDD\xBA\x6F\xF4\xB6\xEB\xD0\x55\x52\xB3\xDA\x3F\xD1\xC0\xD9\xD6\xD6\x60\xCA\xA9\x86\x02\xFE\xDB\xDB\xD9\xB7\xD1\xC1\xDA\xDB\xCB\x70\xF3\xB7\x8F\xDC\xB8\xC0\x06\xDC\xAC\xD2\xA8\xD2\x2C\x6F\x41\x40\xB7\xD9\x9B\x16\xDD\xE1\xD9\x01\xA9\xC3\xD6\xDC\xC5\xDA\x9C\xB8\xC9\xDB\x14\xB7\x0F\xDC\x73\xDB\x2C\xB2\xE2\xCF\x6E\xCE\x96\xA5\xDC\xD2\xDA\xE0\xB8\x8A\xDD\xBA\xD3\xC8\xCB\x71\xD8\xB7\xDB\xA8\x2E\xDD\xED\xDA\xF5\xA1\xC6\xDE\xDD\xCC\xCB\xB4\xB8\xE1\xDB\xDB\xB3\x1B\xDC\x79\xD9\x2E\xBA\xE3\xCA\x6F\xD0\xAB\xFD\x50\x57\xAF\x1E\xDD\x7B\xD9\x0B\xB2\xE4\xD1\x6F\xFA\xAA\xC0\xDC\xB8\xC1\x22\xDD\x7D\xDC\xED\xAA\xE4\xD8\x6F\xFE\xAC\xC7\x52\x41\xDD\x28\xDE\xF4\xD1\x2B\x53\xD6\xC7\x72\xC8\xA3\x6B\xBA\x4D\xDD\xFD\xDB\x8F\xDF\xCA\xD9\xE4\xD2\x72\xE7\xB7\xFC\xA7\x59\xDD\xFF\xDB\x5B\xC9\xCC\xDA\xE0\xC2\x6A\xE4\xB9\x8D\xDC\x14\xDD\x9A\x50\x00\x05\x9E\x36\x10\x0B\x6B\x4C\x73\x05\x02\x45\x99",
			"\x2F\xDC\x1D\x81\xCE\xD5\xE5\xDE\xC3\xB4\xB9\x82\xDC\x01\xD2\x89\x03\x9D\xDD\xC0\xD4\xCD\xCE\x08\x3B\xB9\xED\xDA\x91\xD7\xED\xB3\x9F\xDF\xC2\xD1\x39\xA3\x74\xDA\xB8\x8B\xA8\x86\xDD\x0E\xDC\xBB\xB1\xD1\xD0\xE2\xC5\xDA\x8C\xBA\xA3\xDC\xA7\xB5\x47\xDE\x89\xDB\xB5\xC2\xE9\xC9\x71\xFB\x7E\x95\xDD\x2C\xDC\xA9\xC8\xA6\xDF\xC5\xD3\x5B\xC6\x08\x1B\xBA\xB2\xDC\x40\xA5\x4F\xDD\x8D\xDF\x67\xA2\xEA\xD8\x71\xF3\xB0\x84\x02\xA5\xDD\x1D\xDC\x2D\xB1\xD5\xDE\xE3\xCE\x74\xEB\x75\xAC\xDD\x43\xDD\xB1\xB0\xAC\xDE\xC8\xD7\xE9\xD1\xEE\xB3\xBA\xCB\xDC\xB3\xD0\x85\x03\xAD\xDE\xC9\xDB\xE5\xC0\x00\x3B\xBA\xDA\xDC\x07\xDC\x38\xDF\xD5\xAF\xD7\xD2\xE6\xC9\x05\xC4\xBB\xE5\xDC\xA7\xD5\x63\xDC\x9A\xD9\xD9\xD3\xEC\xCB\xEB\x82\xE2\x04\xDD\x4C\x9D\x67\xDF\xA1\xDA\x7A\xA2\xED\xCA\x74\xF1\x70\xD5\xDD\x8D\xDC\x76\xB4\xB6\xD8\xD2\xD4\xB1\xBB\x76\xD3\xBA\xB6\xCE\xDE\xDC\x4B\xDC\x53\xB1\xDC\xD9\xE9\xDB\xFD\xA4\xBB\x9C\xDD\xFC\xA7\x73\xDC\xA8\xD9\x72\xAA\xEE\xC3\x75\xDB\x67\xED\xDD\xA6\xDC\xEB\xA4\xBC\xDA\xD5\xDF\x84\xB3\x77\xED\xBA\xB3\xDA\xB0\x70\x5C",
			"\xC2\xBD\xD9\xD6\xD9\x57\xBB\x77\xF4\xBA\xB7\xD5\xF9\xDC\x39\xDF\xB0\x9E\xDF\xD8\xEB\xCC\xCB\x84\xBC\xBC\xDD\xC1\xDC\x82\x03\xC1\xD8\xD8\xDA\xED\xD7\xBA\x8B\xBC\xC5\xDD\xB7\xD9\x6D\x71\x74\xBF\xE1\xD8\xEC\xC3\x64\xC2\xCB\x14\xDE\xCB\xDC\x8B\xDE\x17\x76\xE1\xDC\xF1\xDA\x77\xDD\xBC\x82\xDE\x3B\x9E\x8C\xDF\x84\xDE\xB4\xDA\x10\x09\xC4\x59\xE1\x2C\x3C\x00\x00\x87\x8A\x43\x04\xA1\x84\x01\x72\x08\x10\x14\xD4\xBE\x2F\xDE\x90\xDE\x42\x01\xE6\xD5\xE7\xCF\x2B\xF4\xBC\xF8\xDC\x04\xD2\x87\x03\xCD\xDC\xCF\xD7\xD0\xD1\x9C\xBB\xBC\x80\xDD\xA4\xD6\x86\xA7\xCF\xD8\xDA\xD1\xFA\x83\x7A\xD3\xBB\xCA\xAC\x46\xDE\x6B\xDC\x60\xC9\xE9\xD9\xED\xD1\xE1\x8C\xBD\xDC\xDD\x45\xB7\xA7\xDF\xB7\xDE\xF9\xC2\xF5\xC2\x77\xE9\x82\xD5\xDE\xE5\xDC\xA5\xD6\xCB\xDF\xEA\xA8\xF5\xC8\x77\xF4\x01\xDD\xDE\xEB\xDC\x4C\xC7\xCC\xDC\xEB\xD4\xF6\xDE\x69\xC5\x04\x60\xDE\xEE\xDC\xA1\xDD\xD9\xDA\xE6\xD5\x1A\xC7\x7B\xD1\x77\xE8\xDE\xF1\xDC\x8F\xC4\xDC\xDC\xDE\xDC\x8A\xC3\x7B\xF8\x82\xF3\xDE\xF7\xDC\xA7\xDF\xDA\xDD\xE6\xD7\xF5\xDB\x7B\xF8\xBC\x87\xD2\x23\xCE\x7D\x88",
			"\xD5\xBA\xF0\xDC\xF6\xC5\x08\x04\xBE\xFC\xDE\x8E\xCB\xC3\xDF\xDF\xDB\x21\xDD\x27\xAA\x7C\xFC\xBC\xEE\xDA\xD6\xA6\xC7\xDC\xD0\xDE\x81\xD0\x24\xB2\x7C\xC4\xBD\xA4\xA0\x96\xDF\xA3\xDC\x5B\xB1\xF3\xDA\xF4\xD1\xCB\x9C\xBE\xCD\xDE\x80\xCB\xCF\xDC\xD4\xDC\x5D\xB2\xFA\xD3\x7A\xF3\x80\xA5\xDF\x56\xDF\xC4\xDF\x5A\xB8\xF5\xD9\xF5\xC9\x05\xEC\xBE\xDE\xDE\x12\x03\xD7\xDD\xD8\xD8\x02\xDA\x10\x12\x7D\xE9\xBD\x91\xDF\x57\xAE\xDB\xDD\xDC\xDA\x01\xD6\xF8\xD9\x7D\xFE\xBE\xD3\xDC\xB5\xDF\xE8\xBA\xEE\xDC\xEE\xD1\x87\xC6\x08\x03\xBF\xF9\xDE\xE5\xDB\xE0\xDC\x2E\xC7\xF8\xDC\xEF\xD4\xD8\x8C\xBF\xFF\xDD\xAE\xDF\xDF\xDD\xE1\xDE\xFA\x9F\xFC\xC5\x78\xEE\xA8\x8A\x02\xF8\x88\xAA\xBD\xF6\xDB\xFA\xD4\x9E\x17\xBA\x9B\xBF\x88\xDF\xAB\xCB\xEF\xDF\xE2\xDE\x30\xDD\x27\xA2\x7F\xCF\xBE\x81\xDD\x0C\xA6\xF3\xDF\xE4\xDD\x99\xD1\xF1\x8A\x7F\xD7\xBE\xFC\xA7\xEE\xDE\xCD\xDF\xBE\xA9\xFE\xDD\xF9\xD4\xC5\xB4\xBF\xA0\xDF\x71\xB3\xFB\xDF\xE8\xD9\x86\xBA\xFF\xC6\x7D\xE3\x65\xFD\xDF\xA9\xDE\xAD\xD6\x43\x00\x00\xED\xFA\xCE\x2C\xC4\xC0\xB0\xDF\x03\xE1\xE8\xBB\x01",
			"\xE3\xF6\xDF\x4F\xAB\x80\xF7\xBE\xC0\xA4\x0E\xE1\xDD\xDC\x48\xC9\x02\xE4\xFC\xCC\xCB\x94\xC0\xC8\xDF\xF9\xDE\x05\xE2\x06\xE6\xEC\xD4\x10\x17\x80\xCD\xBF\x89\xDE\xDD\xDE\x5C\xC2\x07\xE0\xFA\xD6\x00\xFE\x7E\xE6\xC0\xA2\xE0\x6B\xBB\xFC\x84\xF7\xDA\x05\xE0\xFE\xD7\xFD\xAC\xC0\xE3\xDF\xD2\xD5\x5A\x83\x0B\xE7\xFC\xD1\xF4\xD6\x9E\xB3\xC0\xEB\xDF\xFF\xD8\x20\xA7\x0D\xE7\xFD\xDD\xFC\x9B\x81\xF2\xBF\x85\xA6\x3E\xE1\xFA\xDF\x13\xB1\x08\xE8\xFF\xD4\xC5\x84\xC1\xFB\xDF\x80\xCB\x23\xE2\xFF\xDF\x54\xBA\x04\xE1\x80\xF6\x9C\xCD\xE0\x05\xE1\xD5\xC8\x14\xE0\x01\xEE\x17\xD3\x82\xCC\xC0\xFC\xA7\x56\xE1\x07\xE0\x87\x99\x0B\xE2\x01\xF4\x7D\xC6\x04\x5C\xE0\x15\xE1\x7D\xAC\x18\xE0\x03\xE6\x04\xE9\x81\xD7\x5D\xE3\xE0\x1F\xE0\x76\xB4\x1A\xE4\x04\xEC\xD3\xCA\x08\x2B\xC1\xD6\xDF\x8F\xDB\x82\x03\x1B\xE0\xE1\xD8\xEF\xDF\x82\xE6\xC1\xB8\xC1\x73\xE0\x86\xDD\x0C\xB9\x0F\xE0\xF1\xD2\x82\xE7\xC1\xFF\xE0\x1C\xE0\x00\x03\xFD\x82\x21\x0C\x3F\x97\x62\xED\xC0\xDF\xC1\xFD\xD6\x24\xE0\xF9\xA1\x11\xEB\x04\xF4\xD8\x8C\xC2\xCE\xE0\xCE\xCF\x47\xE1\x14\xE6",
			"\xE6\xC7\x63\x52\x84\xD4\xC1\xC6\x9E\x96\xE1\x2B\xE0\x1D\x81\x13\xEA\x05\xF8\x99\x9C\xC2\xDD\xE0\xFF\xA9\x4F\xE1\x18\xE3\x3B\xB2\x0A\xE4\x83\xCF\x61\xA5\xE1\x69\xE1\x18\xB8\x2A\xE4\x0D\xE6\x73\xCB\x85\xF0\xC1\xEE\xD1\xAE\xE0\x3A\xE2\x2A\xE1\xD1\xA1\x0B\xFA\x83\xD5\xA8\x81\xD9\x90\xE1\x19\xC1\x2D\xE5\x0F\xED\x0A\xEB\xEB\xBB\xC2\x95\xDE\x52\xCB\x5F\xE1\xC6\xDA\xAA\xCF\xBD\xC8\x62\xEF\xC5\x15\x63\xCA\xD7\xED\xD4\xF7\xDC\xAC\xC3\xBE\xD1\xEE\xA0\xB1\xD6\x63\x62\xD8\xF4\xD4\x0C\xE1\x17\xDE\x10\x1F\x5E\xDF\xAF\xC2\xE1\x23\xDE\x8D\xDE\x34\xE4\x06\xE4\xF9\xD1\x9C\x98\xC3\xBF\xD5\xDD\xD5\x6F\xE1\xB1\xD6\x13\xE7\x75\xA2\x87\xEA\xAB\x80\xCB\xE6\xE1\xCA\xD5\x1D\xE5\x20\x01\x52\x94\xFA\xAD\xC3\xDC\xDF\xEF\xE1\x43\xE3\x0C\xC1\x1E\xE3\x0D\xE7\x3A\xF4\xC3\xDC\xE1\xEC\xDE\xEB\xA7\x3D\xE0\x07\xE8\x79\xDB\x87\xFC\xC0\x92\x02\xFE\xE1\x1F\xE0\xC3\xA1\x20\xE2\x04\xEC\xBB\x84\xC4\xC5\xE0\x4F\xB1\x83\xE2\x22\xE4\x16\xBA\x10\xED\x84\xC5\x6D\x8D\xE2\xB9\xE1\xB1\xB0\x44\xE3\x12\xE1\xCD\xC6\x08\x13\xC4\x97\xE1\x14\xA3\x8B\xE2\x26\xE0\x20",
			"\xE1\xDD\xBA\x88\xDD\xC2\xDB\xA8\x1E\xE2\x50\xE0\xFF\xA1\x24\xE3\x0A\xEE\x47\xE4\xC4\xA6\xE1\x06\xE3\xAB\xAF\x49\xE1\x15\xE7\x0B\xEE\x08\x2B\xC4\xAC\xE1\xEE\xDA\x8E\xE1\x20\xE7\x25\xEF\x0A\xE5\x19\xF4\xC4\xB2\xE1\x80\xCB\x9B\xE2\x2D\xE1\x2E\xBA\x13\xFC\x85\xCE\x9F\xBD\xE2\xC0\xE1\xDD\xBC\x50\xE3\x18\xE2\x14\xEB\xEB\xA3\x14\xD4\xBE\x47\xE2\xEE\xDD\x52\xE2\x1E\xE3\x96\xAB\x8A\xF5\xC3\xD3\xD0\x4E\xE2\x7C\xE1\x0E\xE1\x72\xA1\x15\xFC\x87\xFB\xA0\xD5\xE2\xFF\xE0\x87\x00\x56\xE2\x20\xE6\x3D\xBB\x8A\xC5\xC4\xCA\xAC\x5E\xE2\x84\xE0\xDB\xA9\x2C\xEB\x10\xEF\xC2\xA4\xC5\x8E\xE2\xEC\xB5\xB3\xE1\x44\xE7\x54\xBA\x16\xF4\x88\xCB\xA5\x8A\x02\x6D\xE2\x8C\xE2\xF5\x99\x2E\xEB\x11\xFA\x8A\xD1\x77\xF4\xE2\x1F\xE3\x7F\xA8\x5E\xE2\x24\xED\xFC\x9B\x8B\xE5\xC4\xA5\xC6\x7E\xE2\x94\xE0\x58\xE7\xEA\xA1\x18\xEC\x89\xE5\xA2\x92\x02\x85\xE2\x98\xE3\x54\xD0\x2E\xE6\x14\xED\x8C\xF8\x82\x89\xE3\x35\xE2\x20\xA4\x64\xE0\x27\xE1\x97\xB3\x8C\xFB\xC4\xB4\xB1\x96\xE2\x9F\xE3\x0C\xC1\x33\xEB\xF9\x80\x29\xF0\x07\x00\x2D\x2C\x01\x00\x0D\x00\x01\x82\x80",
			"\x0E\x03\x82\x81\x07\x06\x81\x90\x09\x80\x01\x08\x86\x09\x0C\x93\x0C\x94\x0C\x85\x08\x86\x0B\x0C\x9B\x4C\x89\x0C\x82\x04\x87\x05\x0C\x8C\x0C\x80\x89\x85\x81\x84\x84\x09\x8B\x89\x8E\x89\x80\x89\x84\x89\x09\x94\x89\x9A\x89\x84\x8D\x84\x8F\x09\xA0\x89\x82\x99\x84\x92\x82\x93\x06\xA8\x86\x8A\x96\x84\x96\x82\x97\x06\xB0\x86\x92\x96\x84\x9A\x82\x9B\x06\xB8\x86\x9A\x96\x84\x9E\x82\x9F\x03\xC0\x83\x82\xA3\x84\xA3\x80\xA3\x03\xC8\x83\x8A\xA3\x84\xA7\x80\x8B\x33\x9B\x9D\x9F\x81\x93\x90\x86\xAD\x07\x8C\x9E\xA2\x80\xB2\x82\xB0\x81\x64\x82\xA6\xA2\x88\xB5\xA6\xB5\x9B\x6C\xBB\xAE\xA5\x9C\x84\xAE\x81\xB9\x01\xF5\x81\x97\xB1\x81\xBD\x81\xBD\x01\xFD\x83\x8E\xA3\x80\xAB\x80\xA9\x03\xD4\x83\x96\xA3\x80\xAE\x80\xB8\x01\x86\xCA\x8C\x8A\xC0\x00\xC6\x00\x8E\x80\x10\xC0\x02\xCA\x80\xCA\x81\x96\x82\x98\xC2\x8A\xCA\x80\xCE\x81\x9E\x81\xA0\xC0\x02\xD0\x00\xC5\x86\x0F\x91\x93\x99\x8F\xB9\xA9\xC1\xAA\x83\xBF\x85\xD2\xB4\xD1\xE3\x97\xE1\x09\xAD\xC1\x8F\xD1\x81\xD9\x81\xD9\x01\xB5\xC1\x97\xD1\x81\xDC\x83\xE5\x29\xCD\xED\x82\xE1\x9D\x88\xE3",
			"\x9A\x6B\xB9\xAD\xBD\x9F\xB0\xF3\xA0\xF1\x47\xE4\xCB\xA6\xF9\xB0\xF4\xC0\xF5\x82\xEC\xC4\xC7\x9C\xE3\x96\xE7\xA4\xD0\x46\x42\x74\x00\xD4\x40\x06\x74\x00\xD8\x40\x0A\x74\x00\xDC\x40\x0E\x77\x6E\xBD\x7F\x65\x6B\x69\xA9\x6B\x63\x81\x81\x07\x89\x8B\x81\x83\x0F\xAE\x7D\x54\x7C\x61\x72\x75\x58\x7D\x7E\x76\x76\x70\x7E\xC8\x7A\x7A\x70\x7F\xE1\x7E\x73\x7B\x73\xE5\x51\x77\x47\x79\x4F\x69\x73\x57\x7A\x57\x6D\x7C\x8B\x7B\x2E\xB1\x70\x8F\x7C\x32\xB5\x75\x8F\x7D\x37\xB9\x79\x8F\x7E\x41\x7D\x75\x53\x7F\x63\x41\x83\x65\x71\x97\x47\x7B\x65\x72\x59\x5E\x87\x60\x88\x76\x62\x8A\x5C\x89\x03\x57\x04\x8D\x65\x36\x99\x68\x8D\x67\x3A\x89\x9D\x8B\x92\x2F\x80\x81\x8E\x80\x5F\xB0\x61\x98\x6D\x63\xB8\x65\x9B\x56\x4A\x9F\x5C\x90\x5E\x4E\xBC\x5D\x99\x75\x6F\x99\x71\x9D\x77\x73\xB1\x57\x9A\x9D\x69\x8D\x9B\x9B\x59\x33\x82\x90\x98\x91\x62\x86\x94\x98\x92\x74\x83\xA4\x5F\x9D\x8D\x79\x91\x67\x9E\x06\xBD\x9A\x83\x9F\x0E\x81\xA1\x69\x9D\x93\x85\xA8\x9F\xA1\x7A\x8A\xAE\x98\xA3\x70\x8E\xA2\x9C\xA4\x82\xBC\x88\x9A\x8F\x6A\x80\x9C\x99\x42\x5E\xA6\xAC",
			"\x9C\xAA\x7E\xAA\xA0\xA0\xAB\x9F\x92\xA9\x60\xA5\xA8\x56\xAC\x68\x43\xB5\xA5\x83\x93\x89\x45\xA9\x87\x93\x8A\x66\xAE\xA4\xA0\xAC\x86\xB2\xA8\xA1\x42\x18\x76\xA9\xA4\xAE\x9B\xBA\xAD\xA4\xAF\xBC\x60\xAF\xAE\xA8\x95\xA4\xA7\xA4\xB5\x98\x99\x82\x96\x6D\x54\x9F\x66\x97\x68\x3D\xA1\x8F\x8F\x88\x41\x86\xBB\xA0\xB2\x8D\x8A\xBF\xA0\xB3\x91\x8E\xB1\xA8\xB4\xA3\x92\xB5\xAA\xBC\xA7\xB4\xB9\xAA\xBD\xAB\xB8\xBD\xAB\x87\xED\x99\x9F\xBB\x96\xF1\x8F\x96\x89\x94\x28\x93\x9A\x89\x95\x3B\x88\xCF\xAA\xBB\xB1\xB0\xB3\xAC\xC0\xB7\x82\xC9\xAC\xC1\xBB\x86\xCD\xAE\xBE\xDF\xBC\xB1\xBA\xBF\xE3\x9C\xC7\xB6\xC7\xD9\xA0\xCB\xB6\xC8\xDD\xBE\xA0\x70\xB8\xC1\xA2\xB3\xB0\xB9\x09\x5C\x2C\x41\x27\x0C\x5E\x2C\x43\x27\x50\xB2\x67\xBB\x76\xE9\xBA\x6B\xBA\x6F\x58\x8B\x6A\x97\x63\x3F\xC1\xD7\x77\xD0\x0C\x85\xDF\x75\xC5\x57\x89\xCA\xD3\xC2\x4C\xC9\x40\xD3\xC3\x42\xD1\xC8\xBB\xC4\xEA\x94\xDC\xBB\xC5\x0A\xD9\xCC\xC3\xC6\x03\x5B\xD7\xB0\xC4\xC9\x92\xCB\xB0\xC5\xCD\x96\xCF\xB0\xC6\xD1\x9A\xC3\xB6\x41\x6A\xF3\xBC\xD9\xBD\x6E\xF7\xB0\xDD\xBE\x72\xFB\xB4\xDD",
			"\xBF\x76\xFF\xB9\xDA\xD3\x08\x90\xDC\x86\xA7\x31\xE4\xC3\xCE\xC9\x35\xE8\xC7\xCC\xDE\x88\xDA\x8C\xA5\x87\x62\xC8\xD6\xD6\x69\x4B\xEA\x6D\xD0\xD7\x4F\xDE\xD4\xD0\xD8\x46\xD9\xE2\x84\xB0\x15\x9C\x92\x41\xDE\x01\xFB\xD3\xC1\xDF\x05\xFF\xD7\xC1\xD5\x64\xD7\xD6\xD9\xD6\x68\xEB\xE5\xE6\xE2\x52\xD0\x8E\xB7\xE3\x83\xE7\xC5\xE1\xCA\x87\xE0\xE9\xE2\xE8\x51\xE4\xE3\xD5\xDC\xB4\xF3\xD5\xD9\xDD\x67\xF7\xD5\xF3\xDA\x5D\xED\xDF\xD7\xDB\x61\xCC\xF3\xDA\xF3\xB6\xD0\xF8\xEE\xF4\xBA\xC6\xF6\xE6\xB6\x98\xDA\xFA\xE5\xED\x9C\xD8\xDE\xE5\xC3\xE1\xD4\xF1\xEA\xF5\xA3\xD8\xF5\xEA\xF9\xA7\xF4\xC9\xE8\xFB\x01\x55\xB4\xE6\xF8\xBC\xCA\xFE\xEE\xCC\x13\x5D\x72\x85\x1F\x7E\x7D\xE3\x70\x79\x79\xF2\x6B\x78\xE0\x4D\x72\x71\xE7\x44\x71\x7A\xED\x7A\x6D\xF5\x7C\x67\x7A\xBF\x59\x7B\x81\xDB\x6D\x81\xF7\x0F\x8F\x7A\xC3\x42\x25\x58\xD3\x72\x83\xFB\x14\x81\x7E\x0B\xB3\x78\x83\xE7\x7C\x79\xFA\x37\x7B\x7D\xDC\x41\x24\x75\x1D\x6E\x77\xC7\x30\x71\x64\xD9\x63\x61\x70\x25\x61\x79\xE4\x43\x73\x73\x10\xAD\x73\x82\xAF\x75\x81\xEC\x17\x83\x77\x0C\xB9\x86\x81\xC2",
			"\x70\x80\xF1\x02\x2A\x7E\x1F\xB1\x80\x88\x33\x82\x89\x0D\xC4\x87\x86\x06\x87\x8B\x83\x49\x9D\x83\x12\xAF\x8B\x76\xE4\x4B\x74\x5B\x11\x49\x6B\x0A\xDE\x7D\x84\xF0\x5C\x8C\x7F\x5E\x9D\x77\xD1\x75\x70\x73\xFB\x6E\x80\x00\x20\x91\x83\x0F\xA3\x81\x89\x12\x83\x8F\x84\x45\x89\x86\x06\xE3\x8C\x83\x32\x9E\x81\x20\x71\x87\x8D\x01\xE3\x7E\x65\xF2\x68\x84\x8D\x3A\x8E\x8E\x19\x80\x0D\x88\x39\x8F\x8C\x8E\x51\x96\x8F\x14\xF8\x85\x8A\x23\x80\x78\x89\x3B\x8A\x89\x0F\xCC\x84\x80\x11\x86\x84\x84\x08\x86\x86\x02\xF9\x88\x90\x4C\x8A\x97\x8F\x00\x10\x87\xCA\x32\x8D\x64\x1A\xAF\x66\x86\x8D\x78\x87\x25\xD8\x89\x92\x2D\x9B\x92\x90\x9E\x84\x92\x2B\x86\x94\x94\x31\x94\x42\x58\x03\x4A\x96\xB9\x69\x8E\x7F\x35\xBE\x92\x80\xAA\x78\x97\x1C\x9F\x95\x8F\x50\xB7\x8B\x94\x95\x9A\x8F\x15\xFC\x89\x8A\x3F\x9B\x89\x95\x5D\x87\x83\x17\xB0\x61\x8D\xCD\x7F\x96\x66\x03\x4D\x91\x40\x20\x1C\x21\x50\x0C\x22\x14\xE5\x8C\x23\x28\x67\x9A\x9C\x86\x24\x14\x9D\x09\x2F\x9D\x42\x25\x10\x9E\x83\x34\x99\x21\xA6\x0C\x23\x29\x0C\x28\x14\x86\x29\x14\x21\xAA\x0C\x23\x2A",
			"\x0C\x2C\x14\x86\x2D\x11\x9B\xA0\x9B\x98\x2C\xDD\x98\x7D\x6F\x92\x77\xA0\x68\x9A\x9A\x1A\xA6\x77\x98\xF5\x6B\x30\xA2\x83\x9D\x7D\x02\xFF\x7E\x71\x00\x96\xA1\x99\x00\x18\xA1\x2E\x9A\xA2\x94\x8E\xB2\x96\xA3\x2C\x83\x81\x42\x22\xAB\x98\x5D\x92\x8F\x95\x54\x91\x96\x15\xB3\x94\x9B\x5A\x96\x9F\x96\x21\xA8\xA1\x33\x8A\xA1\xA6\x86\xAA\x86\xA1\x3C\x83\x40\x4B\x8F\x9C\x99\x48\x8E\x9B\x92\xD0\x92\xA6\x25\xA8\xA4\x8D\x8B\xBA\xA6\xA8\x3C\xB4\x92\x52\xD2\x94\xA6\xA0\x9A\x92\xA8\x4F\xAD\x97\x4B\xBC\x91\x9B\x52\xB4\x97\x94\xD7\x83\xAB\x2A\xD0\x8A\xAA\x49\xB0\xA2\xAA\x3E\xBB\x8E\x55\xB6\x98\xAB\x88\x89\xA3\xA2\xF4\x75\xA1\x4A\xA0\xA2\xAD\x61\x92\xA5\x98\x14\xBE\x98\x32\xF8\x79\xA6\xB7\xBB\xA0\xAE\x87\x92\xAD\x53\xF4\xA9\xAB\x0D\x40\xB5\x97\x7A\xBF\xA0\x5F\xE2\x9D\xAF\x8C\x84\x9B\xA3\xC6\x89\xB3\x5C\xFC\xA5\xAE\x4D\x46\xB0\xAF\x71\xB2\xB3\x60\xAB\xA5\xB1\xCB\x4C\x71\xAD\xD3\x8B\xAF\x4D\x83\x41\x91\xC6\xA3\xA7\xB1\x25\xB1\xB1\x43\xFB\xAF\x8D\xCA\x98\x5F\xB2\x90\xB9\xAF\x6A\x8A\xBD\xB5\xCE\xA4\x7F\xB3\xBF\x6C\xA9\x1F\xAA\xA6\x20",
			"\xC6\xAE\xB4\x65\xB0\xA9\xB6\x6C\xBF\xAC\xB5\x45\xBF\xB4\x95\xC1\xAF\x9A\x49\xB3\xAA\xB7\x6A\xBC\xB3\x20\xC7\xA4\xAD\x72\xC8\xAB\xB9\xA5\xA8\x70\x98\xC4\x46\xA2\x6D\x85\x98\xB6\x00\x97\xB8\x9C\xD9\xBC\xB2\x5F\xD0\xA7\xB1\xAE\x82\xB3\xB7\x20\xBE\xB7\x76\xBB\x9D\xBB\x8E\x9F\xBA\x72\xE1\x9A\xBB\x78\xE5\xA7\xA9\xB3\x89\xA8\xB4\x55\xA5\xB8\x2A\xD1\xB0\x92\xFA\x91\xAF\xBE\xB9\xAF\xBD\x50\xF2\xBE\xB1\xBB\xB1\xB1\xB3\xB3\xB3\xB1\x6D\xF3\xB3\xBA\xFB\x95\xBC\xAA\xCD\xB6\xA7\x73\x82\x2C\xBF\xA2\xBE\xBD\xBC\x53\xBE\xA9\x4D\xE0\xA8\xA7\x0A\xEE\xA6\xAC\x5C\xB9\xC3\x79\xCE\xB9\xBC\x86\x2E\x14\x21\x2A\x06\xC4\x43\x2B\x0C\x20\x16\x2A\xC1\x21\x2C\xC9\x21\x0B\x2F\xC6\x21\x18\xC6\x23\xC6\x09\x27\xC4\x8C\x8C\x2E\x04\x1A\xC3\x26\xC6\x03\x2F\x06\x8F\x82\x20\xC8\x81\x30\x03\xC8\x01\x25\xC9\x40\x2E\xC9\xC7\x15\xCC\x21\x06\x48\xC0\x02\x92\x80\x00\xCB\x26\xFB\xC1\x21\x32\x11\xCB\x94\xB3\x0A\xCA\x86\x34\x05\xCB\x09\x35\x04\x98\x86\x2D\xC6\x2B\xF5\xC4\x21\x36\x03\xCF\x40\x5F\xC6\xCD\x1F\xFC\xC2\xCD\x02\x2C\xCE\x41\x3A\xC7\xCD\x84\x37\x00",
			"\xCE\x01\x38\x04\x43\x2F\x18\xC5\x3D\xCE\xC9\x21\x4C\xC6\x20\x9F\xD7\xC7\xC6\x3F\xC4\xD3\x20\x38\xC2\xD3\x9F\xE4\xC6\xD1\x3A\xC6\x22\xC8\x09\x23\xD2\xA3\x83\x27\xC9\x48\xCB\xD3\x20\x81\xC3\x22\xA4\xEE\xC9\x21\x2A\xCA\xD7\xD0\x02\x3E\xD2\xA6\x97\xD2\x21\x2C\xD6\xD0\xD4\x01\x3C\xCB\xA9\x93\xD1\xCF\x46\xDC\xD6\x20\x62\xCB\xD7\xAB\x83\x25\xCD\x4F\xEC\xD1\x20\x69\xD2\xD4\x91\xDE\xCE\xD5\x5D\xC9\x25\xD6\xA3\xC8\xD4\x00\x72\xC1\xD9\x5B\xC0\x07\xCE\xBA\xC9\xC8\x43\x7A\xC9\x20\x74\x89\x20\x16\x0C\x31\x15\xB4\xD3\xD9\x20\x69\xD5\xDC\xDA\x06\x36\xD9\xB6\xD8\xD3\x20\x6D\xDD\xDC\xDB\x02\x3E\xD9\xB8\xE0\xD1\x20\x71\xC1\x22\x16\x0C\x33\x15\xBA\x8C\x24\x17\x7A\x83\x25\xDD\x09\x35\x16\xBB\x82\x22\xDF\x84\x36\x14\x21\xF7\xD6\xDC\xBE\xFB\xDA\xDF\x7E\xC6\x21\xDF\xFF\xDC\xDD\xC0\xFE\xD3\x20\x80\xC5\xE2\xE0\x07\xE9\x23\x2D\x0C\x28\xDC\x85\xEB\xDE\xE1\x09\x2A\xDD\x42\x38\x13\xDF\x80\x14\xE1\x21\xB9\x15\xE0\x00\x19\xE9\x20\x5D\x0C\x26\xE3\x1D\xFF\xE2\xC8\xA1\xE4\xE4\x83\x20\xE6\xE4\x23\xE8\xE5\xC9\x83\x27\xE4\x96\xE9\xE6\xE5\x09\x3B",
			"\x14\xC3\x8C\x22\xE7\x88\xF4\xE7\xE1\x06\x3C\x14\x43\x3A\xE9\x20\x9E\xF9\xE3\xE7\x40\xFD\xE5\xD0\xBF\xE2\xE9\xA2\xC4\xEF\xE8\x03\x3E\xE5\xD2\xC3\xE3\x21\x5E\x2B\xBB\xAB\xED\xA7\xA6\x80\x9A\x9E\xE8\x06\xDE\xB0\x8C\x01\xD6\x7E\xB0\x55\xE5\xC1\xB7\x98\xB1\xB0\x9A\xA8\xBC\x5F\xDC\xE7\xB4\x03\xC2\xB8\xC1\xC4\xB4\xB7\x22\xE4\xED\xA4\x92\x8A\xBA\xB5\x69\xEA\xC3\xDA\xCF\xE0\xC5\xA8\xCC\xBB\xEA\x6C\xAC\x20\xDB\xC4\xAF\xC3\xFA\xA1\xC0\xBF\x11\xDC\xC3\xDE\xE3\xAD\xBF\x06\xFF\xE9\xEB\x6D\x98\xB9\x42\x03\xF6\xAE\xAF\xC7\xC0\xEC\x09\xDB\xB3\x1B\x8C\xF6\xB3\xAB\xDC\x98\xF1\x89\x8A\xF2\x41\x14\xFF\xB4\xCB\xCB\xA0\xF3\xA6\x9A\xF1\xD3\xF4\xEE\xEE\xBB\xD6\xBA\xEB\xE0\xAB\xF0\xE9\xFF\xBF\xC0\x0D\xE2\xB3\xC2\x01\x3C\xF0\x70\x9E\xFD\xA6\xD0\xDF\xAA\xF4\x9C\x8A\xF6\xD5\xB7\xB8\xEA\xEF\xA8\xF0\xBE\x7A\xEB\xF4\x86\x80\xF8\xEF\x9B\xB2\xF0\xB9\xB4\xE8\xAE\xED\x9B\xC8\xF6\x40\x81\xFB\xF7\xDC\xBD\xF6\x7B\xBF\xF3\xC0\xDD\xDD\xEF\xAF\x5F\xE8\xB1\xE4\xE2\xE3\xF2\xE1\xD9\xFE\xBC\x61\xE4\xC7\x62\xCF\xF7\xFA\xF2\x9F\xFA\xC4\xE1\xF2\xC0\x48\xC7",
			"\xF2\xBB\xE4\xC0\xC6\xF7\x89\xE9\xF7\xE6\xDE\xFF\xF0\xED\xF1\xEA\xF2\x8B\x85\xB4\xFB\x85\xFE\xFD\xD6\xE3\xC2\xFD\x7C\x5A\x7F\xF4\x77\x76\x90\x77\x7F\xDC\x7B\x48\x8C\x5B\x7F\x16\x66\x78\xA6\x70\x61\xC5\x70\x7B\x8C\x44\x7E\x65\x7E\x78\x04\x86\x7F\x6A\x5A\x5F\xD7\x4A\x80\x7D\x7C\x7A\x70\x77\x81\x6A\x78\x4A\x1A\x8E\x76\xD4\x5D\x81\xA1\x58\x81\x38\x51\x82\xA8\x5F\x76\xC3\x5E\x81\x72\x70\x82\x03\x8A\x82\x68\x7C\x82\xF8\x7E\x82\xD0\x7C\x5E\xD2\x72\x75\xD4\x77\x55\x89\x26\x10\xBE\x0C\x10\x3D\x89\x10\x3F\x8C\x83\x3E\x83\x84\x40\x84\x84\x42\x85\x84\x48\x87\x84\x4A\x83\x10\x41\x8C\x84\x46\x83\x10\xBF\x0C\x10\x51\x89\x10\x53\x86\x10\x55\x80\x85\x52\x89\x85\x54\x8A\x85\x56\x8C\x85\x58\x8B\x85\x60\x8D\x85\x61\x83\x10\xC0\x0C\x10\x65\x89\x10\x67\x86\x10\x69\x84\x86\x66\x8D\x86\x68\x8E\x86\x6A\x80\x87\x6C\x8F\x86\x74\x81\x87\x75\x83\x10\xC1\x0C\x10\xC2\x0A\x87\x7C\x89\x10\x7B\x8E\x87\x7D\x86\x10\x7F\x82\x88\x81\x83\x10\x83\x86\x88\x85\x82\x10\x87\x8A\x88\x89\x81\x10\x8B\x81\x10\xC3\x0F\x82\x23\x8B\x82\x25\x8F\x81\x90\x82\x89",
			"\x0E\x64\x82\xF9\x56\x89\x00\x01\x89\x35\x80\x75\x37\x87\x77\x39\x89\x77\x09\x1E\x89\xE5\x77\x61\xE7\x74\x7C\xA3\x83\x5A\x0C\x16\x8A\x13\x88\x7D\xF5\x70\x7E\xDB\x72\x7E\x6F\x4E\x8A\x6D\x79\x82\x93\x81\x83\x95\x8D\x82\xD7\x46\x8B\x7C\x72\x82\x99\x84\x89\x9B\x8C\x8B\x9D\x88\x89\x87\x70\x7F\x99\x72\x7F\x03\x1E\x8B\x84\x7B\x80\xFD\x7A\x89\x81\x7D\x7C\xC5\x8F\x89\x75\x71\x8A\xA7\x71\x7F\xC0\x75\x8A\xC6\x8D\x80\xAE\x76\x82\x03\x2C\x8C\x8D\x70\x8B\x15\x82\x8B\x06\x84\x8B\x8B\x40\x8E\x95\x7C\x7B\x97\x78\x8C\xA1\x7A\x8C\x02\x18\x8E\x9D\x7A\x8E\x9F\x7C\x8E\xB7\x7E\x8E\xF9\x3D\x8A\xDB\x86\x8D\x0E\x8B\x8A\x10\x80\x8F\xB3\x72\x8F\xB5\x74\x8F\xCC\x76\x33\xFE\x88\x7C\x00\x9A\x7C\x02\x9F\x7A\x20\x55\x5A\x05\x9D\x7E\x07\x9F\x7E\xD3\x78\x8D\xD5\x76\x10\x0D\x9C\x7F\x0F\x9E\x7F\xE9\x7C\x61\xDF\x89\x8F\xEB\x81\x91\xC9\x89\x8D\xBD\x58\x8F\xD4\x85\x7A\xFA\x8D\x8D\x9C\x8B\x91\x23\x9C\x81\xC2\x81\x8D\xF6\x83\x8D\xA7\x8C\x80\x25\x9F\x7F\x1A\x91\x5E\x14\x9C\x91\xF3\x8E\x91\xED\x80\x92\x5D\x22\x92\x2F\x9F\x8C\x2B\x9F\x80\x25\x6A\x8D\x29",
			"\x93\x7C\xCB\x7A\x90\xE3\x72\x94\x3D\x97\x91\xD0\x80\x94\x7C\x55\x91\xCE\x8A\x94\x3F\x9C\x8F\x20\x5E\x94\x1B\x84\x94\x09\x9E\x8D\x3C\x9F\x8A\xE6\x71\x8B\xE8\x73\x8B\x00\x85\x8B\x36\x91\x90\x38\x95\x8F\x3A\x9F\x8E\x61\x98\x90\x63\x93\x90\x65\x97\x8F\x09\x14\x0C\x67\x90\x91\x38\x82\x91\x9A\x4E\x96\x43\x99\x8A\x45\x96\x82\x74\x99\x94\xD1\x7D\x91\x71\x9F\x91\x13\x93\x10\x79\x9A\x95\xA8\x8C\x95\xAA\x82\x97\xA4\x86\x10\x81\x97\x8B\x66\x70\x83\x05\x82\x83\x07\x88\x4A\x89\x9F\x8B\xB8\x81\x8C\xBA\x83\x8C\x33\x87\x4D\x91\x9D\x8C\x55\x96\x97\x57\x9C\x89\x99\x91\x8E\x5B\x93\x8E\x5D\x95\x8E\x5F\x9B\x48\x9F\x99\x8E\x7B\x97\x93\x7D\x99\x93\x7F\x92\x10\xA7\x91\x8F\xA9\x92\x96\xAB\x94\x96\xAD\x91\x10\xAF\x9F\x8F\xB1\x98\x96\xB3\x9A\x96\xB5\x90\x00\xB7\x96\x90\xB9\x90\x97\xA2\x86\x98\xAC\x8D\x96\x6F\x98\x91\x5E\x93\x93\xC6\x95\x97\x84\x97\x97\x27\x9B\x83\x80\x97\x9C\x4B\x92\x95\x7C\x5F\x9B\x0E\x91\x9C\xC8\x94\x9A\x1C\x66\x9D\x16\x98\x9D\xD3\x94\x9C\x10\x85\x5A\xDC\x9F\x94\xDE\x91\x95\xE0\x90\x52\xE3\x9B\x99\xCD\x9D\x99\xC4\x83",
			"\x20\xE9\x90\x8C\xC7\x89\x96\x46\x9F\x46\x8C\x5F\x9E\x93\x91\x9F\xBB\x93\x9F\xA6\x92\x9D\xE6\x9E\x97\x3A\x8B\x9C\x7A\x96\x83\x7C\x93\x9C\xFE\x97\x98\x3B\x90\xA0\x82\x90\x93\x03\xA7\x8D\x05\xA5\x9C\x06\x12\x9E\xFC\x95\x99\x2C\x9B\x96\x11\x88\xA0\x8A\x94\x81\x8C\x96\x81\xBB\x87\x99\x38\x55\x9F\x11\xAD\x98\x1B\xAF\x98\x98\x9F\xA1\x1A\xA6\x99\x22\xA8\x53\xF6\x9B\x98\xB9\x80\xA2\x26\xA6\x8E\x90\x94\xA2\xE4\x8E\x98\x2E\xA3\xA2\xCC\x92\x9A\x85\x9D\xA0\x10\x89\xA2\x18\xAB\xA2\x25\xA3\xA1\xBD\x9C\x58\xC5\x0A\x71\x41\xA9\x10\xC6\x0A\x71\x45\xA9\x10\xC7\x0C\x10\xC8\x0D\x88\x00\x09\x0C\x4A\xAC\xA4\x4B\xA0\x88\x09\x11\xA5\x84\x83\xA5\x50\xA7\xA5\x52\xA6\x10\x54\xA8\x88\x56\xA9\xA5\x03\x1B\xA5\x8C\x8D\xA5\x55\xAA\xA5\x58\xA3\xA6\x5F\xA5\xA6\x5C\xA4\xA6\x5E\xA2\x10\xCA\x0C\xA4\x6D\xAB\xA6\x01\x1F\xA6\x66\xAC\xA6\x6E\xA5\xA7\x70\xA0\x00\x72\xA9\xA6\x03\x19\xA7\x61\xA6\x10\x7C\xAE\x88\x0C\x1F\xA7\x00\x0F\x88\x78\xA6\xA7\x73\xA1\xA7\x86\xAA\xA7\x74\xA7\xA7\x82\xA4\xA8\xCB\x0C\x10\xCC\x0C\x10\xCD\x02\xA9\x94\xA9\x10\x93\xA6\xA9",
			"\x95\xA6\x10\x97\xAA\xA9\x99\xA3\x10\x9B\xAE\xA9\x9D\xA2\x10\x9F\xA2\xAA\xA1\xA1\x10\xA3\xA1\x10\xCE\x0C\x10\xA9\xA9\x10\xAB\xA6\x10\xAD\xA3\x10\xAF\xA2\x10\xB1\xA8\xAA\xAA\xA5\xAB\xAC\xA6\xAB\xAE\xA8\xAB\xB0\xAA\xAB\xB2\xAC\x10\xCF\x0D\x67\x09\x1F\xAB\xC2\x69\x69\x02\x12\xAC\xC6\x69\x68\x03\x16\xAC\xB3\x62\x10\xC8\xA5\xAC\xA4\x61\x10\xC0\x6E\xAC\xC2\x60\x69\x06\x1A\xAC\xBE\x66\x10\x95\x65\xAD\xCF\xA0\x00\xC4\xA1\x10\xD6\xAA\x6C\x9D\x6E\xAB\xDB\xA2\x6A\xD2\xA6\x6C\xA6\x6A\xAD\xC2\x6A\x6A\xE8\xA6\x6C\xC4\x65\xAE\xCB\xA1\x10\xB1\x6B\xAE\xEF\xA0\x00\xD1\xAE\xAD\xDB\xA9\x6B\xF2\xA7\xAD\x6B\x62\xAE\xC2\x65\xAF\x00\x0F\xAD\x52\x6C\x6B\xC1\xAB\xAD\xC8\x66\x10\xD0\x0C\xAF\xC6\x6C\x6C\x06\x11\x0D\xC0\xAB\xB0\xDB\xAD\xAD\x00\x0C\xB0\xC2\x6D\xAC\x01\x12\xB1\xC7\xAC\x10\x16\xB3\xAF\xFE\xA9\xB1\xFA\xA2\x10\xD4\xA3\x10\x1C\xB0\xAE\xD8\xA8\xB1\x0F\xB4\xB2\xC2\x64\xAE\x15\xB3\xAE\x26\xB6\xAE\x2B\xB3\xAF\xEA\xA0\xB2\xDB\xAD\xAE\x29\xB2\x6C\xF1\xA0\xB3\xFD\xAD\xB2\x1D\xB8\x6B\x38\xB2\xB2\xFB\xA9\x10\x21\xB1\xB0\xBF\x6B\xB3\x40",
			"\xB6\x10\x32\xB1\xB1\x04\xBC\x10\xD2\x02\xB4\x53\x6A\xB0\x03\x13\x0D\x0C\x1E\xB4\x09\x10\xB5\x06\x12\xB5\x4D\xBF\xB4\x56\xB1\xB5\x57\xB3\xB5\x59\xB5\xB5\x58\xBD\xB5\x5A\xBE\xB5\x03\x14\x0D\x0C\x12\xB6\x09\x14\xB6\x06\x16\xB6\x61\xB3\xB6\x6A\xB5\xB6\x6B\xB7\xB6\x6D\xB9\xB6\x6C\xB1\xB7\x6E\xB2\xB7\x03\x15\x0D\x0D\xB5\xB7\x25\xB9\x10\x76\xB3\xB1\x0C\x1B\xB7\x17\xBA\xB7\xDB\xAE\xAF\x7E\xB3\xAF\x1F\xB2\x10\x83\xB9\xB3\x00\x09\xAD\x78\xB3\xAC\x7D\xBA\xB2\x80\xB7\xB2\x8D\xB2\x6C\xE7\xAB\xB8\xC6\x6F\xB2\x86\xB1\xB3\x91\xB6\x6C\x35\xB7\xB9\x37\xBF\xB8\xC6\x68\xAF\x94\xB3\xAF\x45\xB7\xB8\x3C\xB2\x10\x82\xB8\xB9\x9E\xB3\xAF\x05\xB3\x10\xD6\x09\xB9\xF3\xAC\xB4\x02\x17\x0D\x77\xB1\xBB\x79\xB6\x10\xB2\xBC\xB7\x09\x17\xBB\x7F\xB6\xBB\x81\xBC\x10\xBA\xB4\xB8\xBE\xBB\xAD\x8A\xB4\xBB\x8C\xB9\xBB\x8E\xBC\xBB\x90\xB6\xBC\x92\xB1\xBC\xE9\xAC\xBC\xEC\xAE\xBC\xF3\xAB\xB9\x01\x1F\xBB\x88\xBE\xAF\xD4\xB5\xBA\x3A\xBA\xBC\xCF\xBA\xBD\x1A\xB0\xBD\x88\xB5\xB4\xD7\xB3\xB4\x03\x1B\xBA\x02\x18\x0D\xDE\xB8\xBD\x00\x00\xBB\x01\x19\x0D\x0C\x1C",
			"\xBE\x09\x1E\xBE\x06\x10\xBF\x03\x12\xBF\x02\x14\xBF\xEB\xBD\xBE\xF8\xBF\xBE\xF9\xB1\xBF\xFB\xB3\xBF\xFD\xB5\xBF\x0C\x1A\x0D\x01\xC3\xC0\x09\x12\xC0\x05\xC4\xC0\x06\x16\xC0\x09\xC8\xC0\x03\x1A\xC0\x0D\xCC\xC0\x02\x1E\xC0\x11\xC0\xC1\x01\x12\xC1\x01\x1B\x0D\xB3\xB7\xC1\xB5\xB3\x10\x18\xC8\xBB\x06\x1D\xC1\xBB\xBC\xC1\xBD\xB9\x10\x20\xC0\xBC\x24\xC2\xBC\x0C\x15\xC2\x88\xB0\xB1\x2A\xC8\xBE\x28\xB0\x00\x2D\xC2\xBE\xA1\x69\xC2\xDB\xA3\xB9\x02\x11\xC3\x5B\x64\xC3\xC2\x65\xB4\x38\xCC\x10\xD2\xB0\xC3\x23\xCF\xC1\xF7\xAA\xC3\xDB\xB2\xC4\x9D\xB6\xC4\x45\xC2\xC2\xC2\x64\xBE\x01\x1C\x0D\x44\xCF\xBA\x0C\x1D\x0D\x19\xC0\x00\x52\xC5\xBC\x06\x15\xC5\x21\xC2\x10\x58\xC3\xAF\x14\xB4\xC5\x41\xC3\x10\x5B\xC8\xB8\x85\xB1\x10\x61\xC8\xBE\xC3\xB4\xC6\x1B\xCA\xC5\xC7\xB0\xC6\x6B\xCA\xC6\xCB\xB9\x10\x65\xC2\xC3\xA9\x61\xC5\xA8\xB7\xC5\xDB\xAF\xC3\x71\xC3\x65\xFE\xA9\xC7\x68\x64\xC7\x3B\xCE\xC7\xC6\x6B\xC7\x75\xCC\xC6\x4B\xCC\x10\xDE\x00\xC8\x50\xC9\x10\xDF\x0C\x10\xE0\x0C\x10\xE1\x0C\x10\xE2\x0C\x10\xE3\x0C\x10\xE4\x0C\x10\xE5\x0C\x10",
			"\x8B\xC9\x10\x97\xC9\x10\xE6\x08\xC9\x0C\x1D\xC9\x09\x17\x0E\x9E\xC1\xCA\x0C\x18\x0E\x8E\xC5\xCA\x0C\x19\x0E\xA7\xC9\x10\xAA\xC9\x10\xEA\x0B\xCA\x06\x1F\xCA\x09\x1B\x0E\x0C\x1C\x0E\x0C\x1D\x0E\xB7\xC9\xCB\x09\x18\xCB\xBB\xCA\xCB\x06\x1C\xCB\xBF\xCE\xCB\x03\x10\xCC\xC3\xC2\xCC\x02\x14\xCC\xC7\xC6\xCC\x01\x18\xCC\x01\x1E\x0E\x0C\x14\xCB\x09\x1E\xCC\x09\x1F\x0E\xCF\xCC\x10\xD4\xC9\x10\xF0\x0C\x10\xD9\xC8\xCD\xDA\xCD\xCD\xDC\xCF\xCD\x06\x1B\xCD\xE1\xCE\xCD\xE3\xC0\xCE\x03\x12\xCE\xE7\xC4\xCE\xE9\xC9\x10\xF1\x00\xA3\xA3\x92\xA3\xA5\x92\x10\xED\xC5\xA3\x19\xA1\xA3\x21\xA3\xA3\x00\x03\xCF\x01\xA0\x8A\x0B\xAB\x8F\xE7\x9C\x57\xFA\xC9\xA0\x3E\x92\xA1\x4C\x9F\x46\x01\xD7\xA1\xE2\x85\xCF\xEF\xC7\xCF\xF1\xC7\x4D\x07\xD2\x99\x2A\xA4\x99\x2C\xAE\xA3\xFF\x96\x10\x0F\xDA\x99\xF0\x9C\x8D\x32\x92\x2C\x17\xD0\x9A\x83\x96\xA3\xCE\x9D\x9E\x0C\x1D\xD1\xA8\x92\xA0\xAA\x94\xA0\xAC\x95\xD1\x03\x14\xD2\xB0\x96\xD2\xB2\x98\xD2\xB4\x9A\xD2\xF2\xCE\xCE\x37\xA9\xD2\x06\xA3\xD3\xF4\xCC\xA3\xF6\xCD\xA2\x0D\xD8\x53\x2C\xD8\x9B\x2E\xDA\x9B\x30",
			"\xDC\x9B\x32\xD1\x10\x3F\xD0\x9C\x41\xD2\x9C\x0C\xA6\xD3\x0E\xA3\x10\x8C\x57\xD4\xD7\x99\xD4\xD9\x90\xCF\xCA\x96\xD1\x34\xD1\xD2\x1C\xA0\xD5\xDD\x92\xD5\xDF\x98\xA3\x0B\x93\xD2\x57\xDC\x9E\x1C\xA3\x20\x5A\xD4\x9E\x5C\xDD\x9F\x4C\xD0\x81\x65\xDA\x9E\x20\xD2\xD6\x27\xA1\x5F\xEC\xC1\xD6\xF2\x98\x95\x71\xD9\xD3\x12\xDD\xA3\x05\xDB\x48\x6B\xD9\xD1\x31\x99\x91\xD2\x85\x5A\x7B\xD7\x9F\x1A\xDE\xD7\x2D\x90\xD8\x72\xD9\x9F\x74\xD1\x92\x75\xDB\xCF\xD5\x8D\xCF\x26\x92\xD2\x38\x36\xD5\x76\xD8\x9F\x43\xDA\x9F\xA8\x41\xD8\x11\xD4\xD9\x4B\xD1\xD3\x37\xD6\xD4\x87\xD5\xD9\x89\xDB\xD2\x9F\xDB\xD9\x44\xDD\xD9\xF9\xC3\xDA\xFE\xCE\xD5\x00\xD8\xDA\x8F\xD3\xD6\xD0\x92\x10\xF2\x0C\x10\xB1\xD9\x10\xB3\xD6\x10\xB5\xD3\x10\xB7\xD0\xDB\xB2\xDB\xDB\xB4\xDC\xDB\xB6\xDE\xDB\xB8\xD0\xDC\xBA\xDD\xDB\x09\x13\x0F\x0C\x16\xDC\xC5\xD7\xDC\xCA\xD9\xDC\xCC\xD6\x10\xC8\xDE\xDC\xCB\xD0\xDD\xCD\xD3\x10\xCF\xD4\xDD\xD1\xD6\xDD\x80\x6C\x10\x5D\xCD\xC5\xFE\xA3\xC6\x89\xBD\x62\x4F\x61\xDE\x58\x6C\x10\x96\xB1\x10\x45\xBF\xC3\xFE\xA0\xBA\xAD\x61\xB4\x09\x15",
			"\xB4\x4C\xC9\xBE\x53\xC3\x65\x10\xB3\x65\x5D\xC4\xDF\x5F\xC2\xC6\x28\xC6\xC5\xF3\xAF\xC2\x53\x6C\xDF\x0C\x16\xC3\xE8\xB5\xDE\x72\xC3\x6C\x77\xC7\xDF\xE8\xBA\xDE\xE8\xB5\xB4\x7A\xC3\xC8\x88\xBF\xDE\x4B\xBC\x10\xF4\x0C\x10\xF5\x00\xDE\x09\x13\xE1\x32\x62\xE1\xDA\xD8\xE1\xEC\xD6\x10\x16\xEF\x68\x1A\xE3\xB2\x15\xE4\xE1\x1C\xE2\xDE\x23\xE1\xAE\x21\xE3\xDE\x27\xE6\x10\x02\xED\xE1\x3D\xB5\xE2\xB0\x6F\xE1\xB4\x60\xE3\x02\x18\xE0\x00\x0C\xE2\xEB\xDE\xE2\x31\xE9\xE2\x2D\xE3\x10\x36\xE1\x10\xEF\xDD\xE3\xF0\xD9\x10\xF6\x0C\x10\x43\xE9\x10\xF7\x0C\x10\x47\xE9\x10\xF8\x0C\x10\x4B\xE9\x10\xF9\x04\xE4\x0C\x1F\xE4\x42\xEC\x10\xFA\x00\xE5\x09\x15\xE5\x53\xE9\x10\xFB\x03\xC5\x5B\xEA\xDF\x02\x1D\xE5\x59\xC1\x10\x60\xEC\xC5\x0C\x13\xE6\xD5\xB5\xE6\xDB\xAE\xDD\x66\xE6\xC6\x68\xEE\xE5\x62\xED\xC6\x6F\xE9\xBC\x06\x1B\xE6\x03\xE0\xE0\x00\x04\xE7\x39\xCA\xE5\x0C\xE1\xE7\x9A\xBD\xE6\x81\xCE\xE7\xF3\xA4\xE3\x78\xE2\xB0\x73\xE6\xE0\x77\xEB\xE7\x00\x0C\x0F\x80\xED\xE0\x8B\xE8\xBE\xEA\xB0\x00\xFD\x03\xC5\x91\xEE\xE6\x90\xEB\xAD\x5D\xC3\xE9",
			"\x61\xE5\xE9\x47\xC3\x10\x98\xE6\xC2\x06\x1D\xE9\x88\xB7\xC6\x9A\xE6\x6C\x10\xB0\xEA\x2E\xCC\x10\xA6\xE3\xE0\x2F\xC9\xEA\x53\x66\xE7\xAC\xE4\xDE\xA8\xE8\xE8\xAF\xE1\x66\xB1\xEB\xE9\x02\x13\xEB\x06\x14\xE3\xB8\xEB\xE3\xB7\xE6\xE8\xBB\xE7\xE3\x03\x1E\x0F\xB5\xE6\x6C\xEF\xDF\xEB\x79\x6C\x10\xFF\x03\xC5\xC9\xE4\xE9\xCB\xE9\xE9\xCD\xE4\xE6\x09\x1F\xEC\x67\xE1\xED\x69\xE8\xEC\xF9\xD6\x10\xD2\xE8\xBE\x10\xB9\xED\xAA\xE6\xED\x72\xE3\x10\xDC\xED\xEA\xDE\xE5\xB9\xE3\xE2\xBA\xE5\xE8\xB8\x3F\xC1\xEE\x6F\x64\xED\xC2\x64\xE3\xEA\xED\xDE\xE7\xE8\xBE\xFE\xAF\xEE\x44\xB1\xEF\x03\xEF\xDE\xF4\xE3\x10\x8F\xE0\x00\x01\x09\x10\x29\x6C\x10\xFD\xE4\xEA\x0C\x1C\xEF\x1E\xC6\x10\x01\xF0\xED\x09\x17\xF0\xD3\xE9\xF0\xD3\xA3\xF0\x0A\xFC\xE6\x00\xF4\xE9\x04\xF6\x6C\x2F\xC3\xF1\xFB\xDE\xF0\x6F\xCC\xF0\xE4\xE1\xF1\x49\xC3\x10\x0F\xF3\xE0\x3F\xC6\xF1\x0B\xF6\xF0\xED\xE8\xF1\x1D\xF2\x10\x1F\xFB\xE0\x1C\xF6\xEE\x09\xFF\xF1\x22\xF8\xBE\xEF\xDF\xF2\x03\xEF\xE8\x02\x0F\xF1\xFF\xE6\x10\x35\xF4\xE9\x39\xF9\xE9\x3B\xF8\xF0\x03\x1D\xF3\x23\xF2\x10\x40",
			"\xF8\xBE\xDE\xD3\xF4\x03\xE2\xEA\x46\xF2\xDF\x0C\x19\xF4\x24\xEF\xF3\x29\xFD\xF4\x42\xFF\xF4\x28\xE8\xF3\x52\xFA\xE2\x4B\xF5\xF5\xBC\xE1\x10\x4C\xF4\xEB\x09\x1B\xF5\x8C\x6D\xF5\x58\xF3\xE3\x57\xFF\xC7\x60\xF6\xEB\x5A\xF1\xF6\xE6\xDC\x10\x03\x0F\xF1\x5E\xF3\xBE\x63\xF9\xB0\x0C\x14\x00\x36\xF1\xF7\x68\xFC\xAD\x74\xF5\xF0\x02\x12\xF7\x78\xF1\x10\x7A\xFF\xE7\x09\x1D\xF7\x9E\xE3\x10\x80\xF1\xEA\x77\xF2\xF0\x7F\xF5\xF7\x2F\xC3\xF8\xA7\xE7\xF8\x19\xF2\xF8\x75\xF2\xE0\x8A\xF3\xE0\x45\xB1\xF9\x53\x6F\xC3\x94\xFB\xEE\x06\x17\xF9\x09\x14\xE3\x9A\xF5\xEF\x8C\xFE\xF7\x99\xF5\xF7\x93\xF5\xF7\xEF\xDD\xF9\xFA\xEB\xF4\x2B\xF4\xF2\xD1\xE5\x00\x2E\xFA\x29\xFF\x0F\xFA\xB0\xFF\xFA\x03\xF3\xF0\x6A\x0A\x03\x1A\xF3\xFB\x03\x18\x00\xC8\xE1\xFB\xB0\xF8\xFB\x09\x1B\x06\xB6\xFA\xFA\xBE\xF4\x4B\xBC\xFD\xFB\xC3\xF2\x10\x6C\x01\xFC\x1E\xF7\xFC\xC4\xF5\xFC\xDC\xE3\xFB\x6D\x0A\xFC\x28\xFC\xFC\x54\x5E\xFC\xCF\xF3\xF0\x6E\x02\xFD\x01\x1D\xFA\x0C\x1A\x01\xBB\xF5\xFC\xD4\xF0\x00\x6F\x0A\xFD\x32\xF3\xFB\x24\x0F\xFD\xBC\xF1\xFE\x70\x04\xFE\xDC\xF9",
			"\x10\xA2\xE6\xFD\x03\xF3\x00\xE8\xF1\xFB\x03\xFB\x1A\x45\xB0\xFF\xD4\xF1\x07\xE4\xF2\x00\x9D\x31\x05\x1F\xF8\xFF\x09\x0A\xFE\x49\x09\x39\x0C\xFE\x40\x16\x12\x1F\x7F\xCE\x79\xFE\x73\x7E\xE3\x7B\x39\x42\x00\x02\x80\x7F\x6A\x7B\x01\xB2\x7D\xDF\x10\x04\x0F\x81\xFA\x71\x80\x09\x0C\x0E\x05\x81\xCC\x1A\x03\x16\x80\xFD\x78\x80\x06\x0D\x0E\x1B\x80\x98\x14\x03\x1E\x80\x03\x86\x08\x02\x86\x20\x36\x03\x11\x82\x4A\x2E\x02\x09\x93\x80\x01\x84\x21\x37\x02\x16\x8F\x52\x28\x03\x0B\x8F\x7E\x29\x83\x20\x38\x02\x1A\x86\x54\x13\x03\x0D\x8A\x80\x09\x09\x0F\x3C\x80\x0B\x3A\x00\x3F\x80\x08\x83\x08\x7A\x03\x08\x87\x10\x3A\x70\x00\xA8\x80\x43\x1B\x03\x43\x82\xF7\x53\x66\x09\x88\x03\x8C\x08\x1F\x03\x82\x07\x00\x95\x51\x77\x04\x87\x04\x82\x09\x1F\x03\x82\x39\x82\x20\x2D\x5D\x2D\x80\x01\xB1\x81\x42\x1E\x03\x43\x80\x62\x64\x5C\x00\x0D\x04\xC3\x7F\x1F\x1B\x7F\xC2\x16\xDD\x5C\x82\xE6\x71\x08\x43\x83\x6A\x04\x7F\x6C\x83\x0E\x87\x7E\x41\x03\x04\x8C\x2C\x11\x14\x82\xE1\x7B\x10\x3D\x82\x86\x0F\x07\xE4\x83\x05\x8C\x7E\x84\x06\x0E\x8C\x08\x24\x00",
			"\x08\xD4\x7D\x21\x03\x82\x03\x7F\x09\x0D\x84\xE6\x76\x08\x0A\x85\x42\x0D\x02\x93\x87\xF8\x47\x04\x4B\x86\x10\x57\x01\x26\x83\x7E\x88\x04\x13\x83\x08\x2E\x0F\x09\xBE\x7D\x22\x02\x85\x02\x0B\x0B\x25\x84\xDC\x7A\x08\x28\x85\x40\x02\x03\xAB\x83\xF6\x4B\x04\x57\x80\x00\x61\x01\x2C\x83\x78\x8C\x03\x08\xBC\x7F\x84\x06\x06\x37\x84\x43\x0D\x04\xBA\x84\x21\x28\x02\x5F\x89\x10\x0E\x04\x2D\x8B\x03\xC4\x86\x20\x0F\x04\x5A\x80\x07\x49\x87\x40\x10\x04\xCC\x86\x19\x82\x09\x48\x03\x04\x85\x86\x41\x12\x03\xD2\x81\x20\x12\x05\x21\x85\x02\x54\x73\x2E\x80\x77\x7A\x83\xF8\x53\x04\x38\x89\x10\x43\x01\x99\x7F\x86\x02\x0D\x0D\x82\x09\x30\x81\x10\x15\x07\x10\x94\x71\xED\x00\x1D\x81\x08\x75\x81\x10\x6C\x84\x00\x16\x04\x43\x82\xC0\x6E\x06\x79\x89\x07\xE5\x82\x13\x89\x08\x97\x01\x0D\xB2\x6C\x7E\x84\x0F\x80\x02\x3D\x98\x04\x43\x85\x8B\x77\x06\x82\x81\x0E\xEB\x84\x43\x19\x04\x43\x85\x68\x6F\x06\x86\x8E\x0F\x83\x0A\x3D\x9A\x04\x43\x84\x07\x1A\x66\x8A\x87\x08\xFF\x85\x53\x03\x82\x3E\x04\xC8\x5C\x89\x0F\x86\x06\x86\x08\x27\x03\x82\xDE\x6C\x1E",
			"\x23\x89\x13\x86\x11\xBB\x1B\x10\x81\x02\xCF\x63\x25\xB0\x80\x8F\x83\x10\x1E\x07\x10\x9E\x57\xF1\x02\x26\x95\x82\xAD\x13\x04\xA2\x75\x3D\x1A\x89\x40\x86\x20\x20\x05\x21\x86\x02\x47\x6C\x50\x9D\x82\x01\x09\x14\x03\x82\x21\x05\xCB\x47\x89\x49\x83\x08\xA2\x05\x1A\x8C\x08\x6C\x86\x08\xA4\x8B\xF1\x63\x05\xB4\x82\x0F\x19\x86\x00\x04\x0A\x64\x86\xE4\x19\x03\x5B\x8E\x14\x19\x8B\xAD\x87\x0A\x5E\x88\x0F\x21\x04\x5B\x89\x15\x10\x84\x86\x05\x08\x5B\x8A\x2A\x03\x82\x2E\x7D\x11\x1B\x8B\x55\x00\x17\x8C\x08\x22\x1B\x8A\xAC\x05\x2E\x89\x08\x45\x0B\x15\xAD\x06\x5E\x86\x08\x77\x8D\x2A\xAC\x88\xDF\x7E\x0A\x34\x84\x25\x1B\x8A\xAF\x04\x16\x96\x05\xAD\x80\x0B\x34\x85\x26\x1B\x8A\xB1\x04\x16\x85\x11\x82\x83\xF0\x32\x04\x2D\x9C\x19\x82\x8B\x26\x83\x7F\x59\x04\x0B\xE6\x25\x66\x97\x7E\xEC\x34\x16\xAB\x27\xCF\x81\xFE\x35\x04\x2D\x97\x27\xD8\x75\x21\xB8\x7C\x5B\x04\x0B\x8D\x39\x6A\x95\x88\xBE\x7F\x16\x2B\x8A\x82\x39\x0E\xAA\x8F\xEC\x78\x05\xB3\x8A\xE5\x2F\x8D\x8E\x83\xFC\x39\x05\x6E\x93\x43\xBB\x8E\x2A\x83\x7E\x5D\x0F\x1B\xFD\x50\x38\x90",
			"\x8D\xB8\x7B\x17\x34\x85\xCC\x44\x19\xBB\x3A\x59\x93\x4B\x5B\x8E\x17\x0F\x8E\x5B\x26\xBE\x24\x8C\x52\x9D\x87\xBC\x8E\xF7\x71\x61\xE6\x88\x86\x51\x83\x28\x61\x8E\x83\x88\xF7\x41\x06\xEF\x89\x10\x0F\x66\x75\x8C\x7E\xC2\x04\x3C\x86\x09\x49\x67\x1E\xC7\x7F\x30\x0A\x8F\x03\x0B\x93\x60\x8E\xCD\x8E\xFB\x44\x04\x7C\x82\x08\xA2\x65\x3D\x83\x7F\x62\x05\x1C\x81\x09\x25\x7A\x8F\xBE\x7E\x18\x37\x8F\x65\x6B\x15\xC7\x06\x12\x97\x6E\xB5\x88\x39\xB3\x7C\x64\x07\x20\xBA\x71\x82\x99\x8E\xB8\x79\x19\x0D\x90\x83\x09\xE4\x73\x8C\x68\x89\x08\xCA\x03\x08\x89\x10\x6E\x7C\x1D\x86\x0B\x32\x1A\x90\x00\x7E\x08\x8C\x7E\x66\x00\x22\x81\x82\x88\x87\x7E\xCD\x05\x44\x86\x08\xD6\x70\x20\xB8\x7E\x33\x03\x82\x0B\x16\x01\x27\x91\xE1\x7F\x0C\x30\x92\x5C\x13\x91\xBE\x78\x1A\x03\x83\x06\x17\x01\x38\x90\xEE\x71\x06\x3B\x94\x21\x19\x00\x1F\x93\xFB\x52\x05\x90\x89\x08\x1B\x04\x48\x83\x79\x69\x07\x24\x86\x09\x07\x0A\x92\x63\x5D\x49\x83\x09\x0F\x00\x25\xFA\x5A\x94\x82\x08\x21\x05\x4A\x86\x08\x6B\x03\x04\xDE\x0C\x0B\x1A\x92\x03\x0F\x1A\x03\x83\xDD\x02\x03",
			"\x60\x91\xF9\x43\x82\xBD\x08\x07\x26\x93\xF5\x53\x04\xBF\x0E\x0F\x0B\x93\x00\x02\x1B\x03\x83\xD3\x07\x04\x70\x93\x36\x13\x93\x0C\x0E\x08\x30\x92\x6E\x03\x04\xA9\x0D\x13\x10\x93\xDD\x04\x16\x97\x02\x38\x9E\x0D\x03\x85\x42\x16\x02\x70\x97\x1B\x03\x83\x10\x0C\x10\x5B\x00\x9C\x80\x07\xB4\x81\x1D\x30\x93\x70\x03\x1D\x95\x52\x41\x0B\x07\x44\x96\x1E\xA3\x07\x21\x8B\x01\x35\x65\xA6\x94\x64\x09\x8C\x21\x2A\x06\x38\x95\x0E\x15\x94\x06\x17\x65\x9F\x91\x94\x43\x82\xEF\x73\xCD\x29\x96\x41\x08\x07\x43\x80\x04\x0C\x08\x77\x0E\x2A\x83\x09\x3A\x03\x82\x1D\x04\x21\x07\x07\x5A\x92\x10\x6A\x07\xA2\x8D\x94\x70\x93\x1D\x06\x94\x83\x02\x06\x3C\x95\x40\x0C\x07\x43\x87\x54\x89\x09\x31\x06\x2C\x80\x01\x3B\x14\x85\x6E\x00\x4E\xAE\x07\xFE\x82\xFE\x70\x93\x3B\x10\x96\x70\x90\x1E\x03\x97\x81\x0D\x06\x70\x91\x3C\x03\x82\xA5\x2C\x0D\x30\x92\x79\x04\x0B\xF8\x00\x9C\x93\x07\x95\x94\xB1\x37\x02\x38\x95\x0F\x65\x94\x9C\x96\x07\x95\x93\x35\x05\x04\x38\x98\x0F\x43\x83\x80\x1F\x03\x70\x91\x1F\x36\x96\x86\x08\x2F\xAD\x93\xEC\x7A\x07\xDB\x92\x20\x01",
			"\x04\x38\x9B\x0F\x01\x99\x40\x0A\x04\x70\x94\x1F\x34\x85\x48\x00\x27\xFD\x07\xC2\x90\x93\xFE\x06\x60\xB7\x86\x38\x9F\x0F\x12\x9A\x25\x10\x93\x00\x03\x07\x37\x7D\x81\x0E\x01\x06\x28\x9C\x81\x00\x1A\x9A\xF8\x5C\x99\x3D\x30\x27\x82\x01\xC8\x8B\x7E\x91\x6D\xDB\x30\x93\x01\x07\x32\xD3\x7E\xCD\x1B\x05\x70\x94\x00\x2D\x99\xED\x72\x2C\x30\x9A\xBF\x83\x78\x05\x03\x66\xA5\x7F\xD5\x02\x0C\x70\x92\x01\x1A\x99\x2E\x7C\x67\xB0\x93\x03\x00\x34\x8C\x0B\x07\x0C\x08\xC5\x00\x4E\x88\x01\xA2\x99\x10\x47\x99\x42\x09\x9A\x37\x9B\x23\x0C\x9A\xC9\x10\x0D\x70\x92\x02\x13\x9A\x3C\x25\x1A\x30\x93\x05\x08\x35\x9A\x24\x36\x10\x93\x0C\x05\x6B\xAC\x4B\x0F\x60\x27\x8D\x02\xD8\x96\x94\x03\x0E\x1B\x30\x92\x07\x07\x36\x8C\x2C\x38\x10\x93\x0F\x07\x6C\xAB\x0C\x73\x00\x27\x90\x01\xDB\x96\x64\x70\x91\x02\x27\x9B\x13\x08\xE4\x70\x92\x04\x07\x9B\xDD\x81\x21\x1C\x00\xA7\x87\xFC\x13\x02\xCE\x9C\x87\x00\x04\x6F\x86\x72\x38\x95\x01\x7B\x9B\xC0\x64\x9C\xC3\x7E\x02\x0E\x9C\xD4\x76\x21\xE1\x7F\x05\x17\x9B\xD1\x70\x4E\x98\x01\xB3\x92\x02\x0C\x0A\x01\x10\x9C",
			"\xBE\x79\x03\x27\x9B\x11\x0C\x10\x08\x00\xE8\x98\x7D\x1A\x04\x73\x9E\x9D\xD3\x93\xFB\x1B\x03\xE8\x85\x9D\xAC\x9B\xE0\x5C\x00\xD5\x99\x10\x1F\x9D\xD4\x89\x08\x1D\x07\x75\x89\x08\xD3\x97\x3B\x86\x0A\x07\x12\x9B\xA4\x09\x76\x86\x9B\xB3\x96\x0D\xDD\x12\xF0\x89\x08\x20\x04\x78\x84\x17\xE3\x96\x10\x21\x00\xE0\x8C\x08\x83\x9D\x77\x83\x08\x11\x07\x36\x83\x7A\x07\x0C\x9E\x03\x0B\x04\x18\x9C\x83\x02\x02\x2C\x9E\x3D\x84\x01\x67\x9C\x03\x0C\x09\x11\x0E\x3D\x8C\x09\x09\x13\x9C\x37\x30\x7B\x82\x08\x13\x08\x3E\x88\x36\xFA\x81\x08\x27\x05\x7A\xAB\x31\xF7\x90\x00\x28\x03\xD9\x89\x01\x0C\x09\x05\x34\x9F\x14\x0D\x3E\x82\x09\x0D\x14\x9F\x2A\x05\x7F\xB0\x56\xFA\x9B\x02\x72\x9D\x42\x13\x01\xF4\x9C\x05\x37\x9F\x27\x34\x3F\xAD\x02\x01\xA6\x08\x41\x04\x7E\xAE\x00\xE0\x99\x10\x44\x00\xFD\x8F\x01\x0F\xA3\x20\x0C\x02\xFA\x90\x03\x19\xA2\x40\x1B\xA0\xD2\x99\xD4\x1E\xA1\x80\x09\x05\x74\x9E\x0C\x1B\x9E\x03\x0E\x0B\x34\x9F\x19\x03\x42\x80\x02\x19\x14\x9F\x34\x07\x70\x82\x16\x31\x04\x3F\xB6\x00\x05\xA6\x08\x64\x04\x7E\xB7\x00\x01\xA0\x00\x71",
			"\x00\xFD\x98\x01\x3C\xA6\x87\xA1\xA1\x80\x09\x03\x28\xA2\x40\x0F\x03\xF4\x9A\x07\x27\x9B\x17\x60\x07\x74\x9F\x0E\x06\xA2\x01\x08\x89\x83\xA2\x00\x0C\x03\x4B\xA0\x43\x0D\xA2\x53\xA5\x07\x10\xA2\xF1\x74\x3F\xBE\x03\x16\xB7\x03\xF4\x9F\x07\x2D\xA1\x40\x04\x3F\xC0\x03\x18\xB4\x9F\x41\x02\x79\xA7\x82\xFA\x92\x04\x67\x9B\xF9\x69\x08\x7F\x04\x7E\x83\x02\x35\xA6\x10\x7E\x00\xFD\x84\x02\x6E\xA4\x5F\xB4\x9F\x22\x0D\x42\x89\x04\xFD\x86\x02\x7D\xA4\x7E\x87\x02\x3A\xA3\x10\x06\x04\xFD\x88\x02\x79\xA1\x21\x07\x04\xFA\x99\x04\x04\xA6\x40\x06\xA4\x53\xA2\x09\x09\xA4\x83\x0B\x48\xD3\xA3\x12\x0D\xA1\x91\x04\x7E\x8C\x02\x4C\xA4\x3F\xCD\x02\x23\xA1\x08\x8E\x04\x7E\x8E\x03\x49\xA3\x10\x0F\x04\xFD\x8F\x02\x9F\xA0\x00\x21\xA5\x29\xA0\x05\x24\xA6\x40\x06\xA5\x53\xA1\x0A\x0F\x9F\x84\x09\x09\x74\x9E\x14\x12\xA1\x09\x09\x70\x86\x09\x5A\xA3\x45\xD4\x03\x2C\xA2\x8A\xF4\x9D\x0A\x38\xA4\x83\x0A\x4B\x83\x08\x28\x14\x9F\x57\x07\x6C\x8F\x75\x51\x04\x3F\xD8\x02\x32\xA5\x27\xF4\x99\x0B\x27\x9A\x3C\x8C\x0A\x74\x9E\x16\x13\xA6\x06\x2C\x7E\x9B\x02",
			"\x6C\xAB\x52\x74\x9C\x17\x07\x9B\x3A\x98\x00\x32\x04\xFA\x9D\x05\x60\xA5\xBA\x34\x9F\x5E\x06\x9C\x91\x38\xFA\x9F\x05\x3F\xA7\x40\x18\x05\xF4\x98\x0C\x03\xA7\x81\x05\x4C\x82\x08\x3C\xB3\xA2\x62\x05\x85\xBB\x04\xFA\x93\x06\x67\x99\x0F\x0C\x08\xC1\x04\x7E\xA4\x02\x7F\xA0\x50\xF4\x9D\x19\x0D\xA1\xC9\x04\x7E\xA6\x03\x1B\xA3\x10\x4B\x04\xFD\x87\x03\x2D\xA7\x1C\x34\x9E\x34\x0D\x42\xE6\x04\xFD\x89\x03\xEE\xA2\x20\x3A\x06\xFA\x9A\x06\x67\x9A\x39\x9A\x72\xE5\x9E\x5F\x85\x03\xA5\x7C\x0E\x9D\x93\x40\x0B\x03\xF3\xA2\x20\x23\xA9\x00\x85\x52\xB6\x8F\xC0\x6D\x03\x67\x9B\xA5\xA8\x81\x96\xAA\x20\xD8\x7F\xD9\x86\x02\x0C\x0F\x00\x34\xA8\x08\x93\xFB\x6F\x03\x4D\xBB\x08\x3B\xAA\x38\xBE\x7C\x38\x09\x4A\x8F\x01\x50\xA1\x8F\xB3\x79\x0E\x27\x9B\x23\x0F\x16\x47\xA8\x7D\x98\x7D\x72\x05\xA8\x8E\xAB\x0B\x96\x10\x73\x03\x52\xAD\xAA\x53\xA4\x0E\x12\xAB\x29\xA5\x07\x29\xA4\x05\x13\xAA\xE1\x7E\x0E\x17\xAB\x97\x00\x56\xD4\x7F\x1D\x1E\xAA\x65\xAC\xF9\x78\x03\xB1\xA9\x14\x69\xAB\xF1\x79\x03\x68\xAB\x8A\xBA\x03\xB3\x99\x08\x0C\x2C\xE5\x95\x9C\x5B",
			"\x88\x71\xA6\xA9\x19\x6E\x2F\x85\x88\xE2\x9A\xAB\x2E\xAC\x21\x39\x95\xBE\xA6\x1B\x84\x03\x5D\xA7\x8E\x3C\xAB\xE0\x4C\x2D\x82\x85\x10\x86\x03\x61\xAF\x90\x42\xA8\xF7\x43\x10\xC6\xA6\x1B\xD2\x80\xCE\x7B\x8A\xAB\x0C\xB2\x8A\x91\x04\x10\x58\xB5\xA8\xF4\x91\x85\x05\x8D\x41\x1D\xAD\xC4\xAC\x29\x1A\xAC\x4F\xBB\x0D\xA3\xA9\xB2\xB3\x7D\x05\x16\x5A\xAA\xAF\x6F\x09\xAD\x48\xAB\xE0\x5D\x94\xC2\xAA\x20\xA7\x0C\x6C\xAF\xAA\xB3\x7D\x00\x20\xAC\xDB\x8B\x1A\x37\xAC\x55\xA2\x7C\xBB\xAA\x41\x8C\x2C\xDF\xA1\xFE\x0E\xAC\x6D\xBC\xA9\xCA\x97\xB2\x93\xA3\xD4\x0D\x5A\xC8\xA8\xAB\x8A\xAE\x78\xAC\xF9\x65\x2D\xE6\xA8\x5B\xE2\x9D\xD7\x7B\x8A\x1D\x9F\xB8\xAA\xAD\xEC\xA0\x5D\x88\xAE\x6A\xA8\x9C\xF6\x84\xBA\x8F\x7E\x59\x9B\x31\x90\xAC\x52\xB6\x87\x2E\x7A\xBC\x83\x78\x46\x9F\x14\xE6\xAC\x6E\xB6\x87\xF8\x9A\xBB\x88\xAB\x37\xAB\x22\xB1\x86\x3D\x97\x79\xDE\xA8\xA9\x85\x89\xF8\xA5\x5F\xFE\x96\x3D\x93\x32\xEA\xA8\xF3\x43\x08\xDD\xAE\x5F\xA2\x71\x7E\xB8\xAD\x05\x8A\xC0\x44\xB1\xE8\xA4\x13\xCC\x55\x70\xBC\xA9\x8F\x73\xC1\x87\xB1\x9D\x8F\xF5\x0C\xB3",
			"\x84\xA3\x78\xFF\xA1\x21\x12\xB0\xF7\xAF\xFC\x06\xAD\x79\xB3\x87\xB6\x8D\x20\x8C\x8B\xBF\x71\x0B\x9E\xB2\x41\x1C\xAF\x17\xB1\x16\xB8\xA9\xDA\x95\x62\xCA\x75\x88\xB6\x8D\x4C\x06\x73\xAD\xB0\x61\x31\x60\x89\x0A\x14\x12\xB1\xFE\x96\xC4\x98\x35\x07\xBA\x5A\xD8\x00\x8E\xB6\xB0\x79\x79\xC3\x72\xAE\xDC\xAE\x05\x3F\xB1\x8A\xA4\xB1\x1B\x77\xC8\x80\xB3\x80\x04\x06\x46\xB0\x87\xB8\x99\xA9\x7F\xC9\xB1\x84\x35\x01\xF7\x31\x87\x86\xA1\x08\x28\xB2\xCA\xBE\x96\x37\x0E\x64\xA0\xB2\x82\x97\xB2\x00\x00\xBF\x9A\xB3\x25\xB0\x00\x74\x01\x97\xB8\x8E\xAA\xA8\xCC\x80\xB1\x17\xBA\x20\xDA\x88\x8B\xBE\x97\x60\xB3\xDB\x6C\xB2\x9E\xA0\x08\x67\xB1\x41\x80\xB3\x5D\x65\xC6\x86\x08\x43\x06\x67\xB6\x8C\x98\xB3\x77\x73\xB2\xB5\x8C\x05\x3E\xBA\x20\xC6\xAD\x77\xA3\xB3\x4A\xB3\x20\x12\x05\xC7\xA8\xFB\x2E\x7A\xA1\xA3\x08\x2F\x62\xCF\x83\x09\xC3\x87\x5D\x9F\xB1\xF9\x6F\xB4\x02\x0B\xB0\xA4\xB3\x82\x8B\x18\x95\xB7\xA1\xB4\x99\x6F\xB2\xB1\x5B\xB4\xDB\x88\x09\x0C\xB6\x41\x91\xB2\x01\x08\xD3\x97\x26\x49\xB2\x10\x1A\x06\xA9\xBA\xB1\x2E\x9E\x20\x2A\xB5\x9B",
			"\x2C\x6A\x81\x0A\xCE\x1E\xB4\x03\xB0\xD5\x80\x01\x59\xB6\x5D\xA3\xB6\x82\x9E\x19\xB8\xB2\x20\x33\xB4\x47\xB5\x5A\x81\xB4\x52\xA4\x27\xC1\xB1\x20\x19\x82\x4B\xB3\x6B\xAC\xAE\xB1\xB8\xAD\xCE\x37\xD3\x80\x00\xCB\xA8\x32\xB2\xB4\x43\x13\xAD\xBE\xB4\xA7\xB2\x26\x69\xB7\x20\x44\xB6\x86\xBC\xB1\x48\xA9\x9F\x09\xB6\x0B\x3E\x6D\x99\x7C\xB8\xB8\xAD\xFD\x23\xDC\x8B\x11\x72\xB3\x10\x33\xB5\xAD\xA0\x00\x01\x2B\xDC\x8D\x10\x76\xBD\x47\x6F\xB5\x41\x23\xB7\xDE\x0C\xDE\x8E\x3F\x21\xBF\xFC\x74\x33\xCF\x6C\x1C\xFA\xB0\x00\x1C\xAF\x44\xB8\x68\x82\x08\xB4\x23\xB7\xBD\x0E\xE5\x4B\xB6\x69\xBF\x6E\xAE\x8F\xBF\xB2\x19\x0A\xB8\x71\x2F\xB6\x78\x32\x32\x85\xBA\xB2\xB0\x7A\x5E\xB4\xA7\x85\x89\x7A\x32\x6D\xA5\x0D\xC4\xB8\x9D\xE7\xB7\xF9\x4B\x39\x71\xB7\x1A\x1F\xBA\xA8\xA4\xB8\x19\xBA\xB5\x9C\x38\x69\xB9\x1A\x26\xBB\x22\x2F\xB7\x35\x3A\xDA\xAB\x0C\x97\xBA\x49\x6F\xB7\xE0\x28\x9C\x03\x14\xE6\x81\x09\x5E\xB8\x72\xE8\xB0\x52\xB7\x42\x42\x7F\xB5\x60\xB4\x83\x0B\x70\xAE\x27\xBB\xB9\x43\xE3\xB5\xB4\x3A\xB8\xFA\x2F\x6E\xCC\x44\xE2\x89\xAE\xD5\xB3",
			"\x20\x05\xBA\x81\x08\x6D\xBD\xB9\x41\x83\x52\xD2\xB1\x03\x3A\xB5\xA9\xB1\x10\x60\xB3\xBB\xA9\x52\xE3\xB7\xB9\x91\xBA\x81\x0C\x75\x80\x00\xAC\xA9\xB9\xFA\xAE\x36\x8E\x53\x71\xB5\x75\xB1\xB6\xD4\xA4\xB4\x1A\xBE\x36\x8F\x55\x71\xBC\x73\xEE\xB8\xD9\xBD\x1C\xEF\xB7\x54\x40\x00\xC4\x9A\x69\xE3\xBB\xC5\xB4\x15\x21\xBB\xE0\x40\x58\xC4\x93\x70\xF6\xBB\xDF\xBE\x9D\x81\xBA\x68\x48\x9C\xA7\x95\x71\x81\x08\xB5\xAB\x26\xEF\xB4\x6A\x46\xBC\x9F\xB8\x5B\xDD\xB5\xE2\xB4\x5B\xC2\xB1\x16\x87\x11\x2C\xB8\x76\x88\xB2\x6D\x96\x60\xD3\xB2\xF3\xAE\xB0\x05\x95\x10\x91\x67\xEE\x82\xBD\x34\xB7\xD9\x8F\x7E\x59\x66\x10\x0F\xBD\xE7\xAF\x7E\x07\x12\xCE\xA4\xBC\xDB\x89\xDB\x0E\xBC\xEA\xA5\x34\xFC\xB3\xE0\x58\x73\xD6\xB7\x7B\xB9\x71\xB6\xBF\xAE\x1F\x7E\xF5\x94\xBD\xE7\x79\x20\x65\xBB\xBB\xA5\x82\x96\xB5\x20\xAB\xB7\xCB\xB3\x15\x1F\x7B\xD9\xA3\xBE\x03\x7B\x41\x1C\xBC\xE8\xB1\x0B\x8F\x03\xC7\x6E\xB7\xB6\x8B\x41\x22\xB3\xD7\xB3\xF0\x05\x89\x05\x17\xBE\xB1\x83\x41\x2B\xB3\xD9\xBA\x20\xC9\x91\xA8\xBD\xB9\x0B\x12\xF6\xB1\xBA\x05\x99\x25\xE7\xBE\xC5",
			"\xB4\x2F\x79\xB2\xF5\x83\x79\x13\x00\x7E\xFE\x97\x82\x00\xB4\xE4\xBC\xA7\xAD\x01\xFA\xB4\x66\xF3\xB4\xF3\xA3\x08\x33\x06\xF9\xB1\x85\x06\x13\x7D\xEF\xB7\x0D\x1C\xBF\x3D\xBD\x41\x1B\xBE\xEA\xBE\x2F\xBD\x00\x02\xCF\xBF\x0D\x13\xFC\xAB\xBE\x9E\xA3\x04\x0F\xC0\xF7\xBC\x14\xEA\xBA\xB5\x85\x89\x24\x06\x81\x8C\xC2\xCB\x11\xBF\xF9\xBA\xB5\x8F\x03\x0E\xC1\x5A\x82\xB3\xFB\xA5\x88\x55\x04\x04\xF6\x8C\xEF\x04\x5C\xB1\x86\xA3\x83\xB7\xE4\xAD\xF1\xB6\x2F\x48\xB2\x7F\x8C\x09\x17\x0C\x7B\x0C\x0C\xBD\xB2\xC0\xEF\x05\x1A\x6F\xB7\x17\x1F\x78\xE9\xAB\x05\xC2\xAD\xFF\xB2\x10\x60\x00\x0E\xC9\x08\x9D\x9E\xD2\x9E\x0F\xC5\xA5\x83\x89\x09\xB1\x83\xB7\xA4\x9A\x09\xE0\x29\x77\xB4\x06\x47\xC2\x41\x14\xAF\x7E\xBE\xBE\x19\xAD\x26\xC6\x10\x66\x02\x15\xD4\xA7\xBA\xB6\x3B\x35\xBB\x0B\xCE\x2F\xE8\x03\x17\xCB\x9F\x61\xC5\xD8\xA1\xC0\xA4\xAA\x06\x67\xC0\xFC\x89\xC3\xC8\x1F\xDD\xA2\x97\x71\xB8\x02\x70\xC2\x41\x0D\xBB\x64\xC4\xCC\x91\x97\x71\xB3\x7D\xAE\x7A\x77\x1E\xBA\x5C\xC3\x20\x30\x02\x37\xC1\x66\xF6\xC0\x70\xB9\xBD\x53\x8C\x10\xD3\x32\x3F\xC0",
			"\x77\x9A\xC2\x6D\x94\x03\x84\xC0\x62\x4C\xC4\xF5\x1F\x6E\xF6\x00\x21\xDD\x62\x93\xC7\x41\x44\xC3\x80\x06\x2E\xE3\xB6\xBF\x59\xC4\x23\x98\x11\xC9\x08\x3D\x04\x88\xDE\x6E\xCB\x68\xAD\x9B\xC0\x00\x3C\x02\x42\xC2\xEA\x27\xC4\xC6\xBE\xC0\x3D\xBE\x0F\x04\xC5\x17\x6E\x8A\xA0\xBA\x28\xC6\x08\x80\x04\x10\xF6\x73\x5A\xC7\x72\xA7\xC2\x6D\x82\x04\x84\xC2\xC0\x7C\xC5\x97\xB1\x88\x82\x08\x21\x04\xC4\x45\x5B\x18\xF5\xB9\x62\xC1\x10\x06\x04\x21\xDF\x61\xCA\xC3\xE7\xA9\xC4\x44\x04\x88\xB4\x71\x34\xD5\x2F\xEF\xB0\x61\xA3\xB7\xF7\x67\x8D\xCE\xB7\x1A\xD8\xAD\x8C\x04\x10\xCF\x75\x6B\xC8\x87\xB0\xC7\xFB\xAE\x04\x84\xC1\x07\x3A\xB5\xDD\x00\x88\xDF\xC7\xF3\x70\x04\x84\xC0\x0F\x97\xC7\xE7\xBF\x6E\x92\x04\x21\xC1\xA7\xD7\xC0\xFB\xAE\xC7\x81\x74\x09\x04\xC6\x46\x96\xB4\xBB\x0C\xB9\x8C\xC7\x89\x93\x6E\x99\xB2\x0C\xDB\x0D\xD3\xAB\x20\xD8\x04\x42\xC1\x12\x80\xC8\x43\x05\xBC\x79\xC5\xE7\x9A\x04\x42\xCF\x03\x3A\xB5\x6F\x0D\xC1\xFE\x94\x13\x04\xC4\x20\x06\x91\xAF\xC7\xBB\xBE\x04\x84\xC0\x26\x96\xB5\xDE\x0D\x77\xBE\xC6\x82\x80\x05\x84\xC3\xC4",
			"\xB2\xC1\xDE\x0C\x84\xFB\xC7\x39\x24\xC4\x1F\xAB\x25\xD3\xC3\x81\xC4\x0A\x04\xC5\xF1\x93\xBC\xBD\x0B\x0B\xEE\xC8\x7C\x24\x88\xB2\xA9\x16\xDD\x0D\x63\xC6\x1C\xD1\xC8\x81\x08\x0A\x04\xC7\x8A\xB2\xC9\xDA\x17\xDD\xAA\x04\x42\xCC\x54\xA3\xC8\xD4\x16\xB7\x84\xC4\x11\x8E\xCA\x24\x99\x8A\xAE\x04\x21\xC9\x02\x1D\xCF\xDB\xB7\xC5\x81\x00\x0B\x04\xC6\x12\x19\xCA\xE6\xB3\x2B\xC2\x08\x59\x04\x88\xCB\x00\x58\xCD\xB7\xA9\xC4\x16\x04\xC5\x18\xB3\x95\xAC\x23\xBB\xB6\x05\x84\xC0\x13\xAD\xCB\x03\x5F\x7B\xC8\xA8\x2E\x04\xC4\x4E\x07\x2C\xC2\x08\x88\xC2\x94\xFD\xCA\x2E\x04\xC4\x92\x86\xD2\xBF\x0D\x20\xCB\x93\xB9\x3A\x00\xDE\x97\xBF\x0D\x00\xC3\xC8\x60\x0A\x82\x8A\x93\x6F\x0B\xC0\xEF\xB6\x18\x0D\xCC\x9E\xAF\x1B\x12\xC2\x23\xCA\x90\xCC\x03\x32\xEE\xAC\x03\xB6\x92\xBC\xAA\x34\x1A\xCC\x48\xAF\x37\x20\xC1\x09\xCA\x5A\xDF\x9A\xFB\xA3\xCA\x96\x20\xFF\xA4\xCC\xA4\xAA\x36\xA7\xCD\x5F\xC5\x0D\xBD\x0F\xDD\xA4\x06\x20\xC1\x0B\xA7\x0F\x6E\x0F\xB7\xE5\x04\x36\xFE\x97\xD3\x0D\x83\x83\xC8\xDD\x89\xBE\xB6\x89\x35\x1E\x0F\x77\xB7\x0E\x3A\xCC\x99\xB3",
			"\xB9\xA9\xC0\x1D\x07\xCD\xE3\xC9\x3F\xA9\xC4\x3B\x00\xCD\xB8\xAB\x35\x10\xCD\x81\xC2\x0F\x50\xCF\xF3\x6B\x0D\x96\xC9\xED\x8A\x90\x7C\x06\x9D\xF5\x7C\x67\xC8\xCD\x7D\xCE\x1F\x1D\xCE\x61\x13\x9A\x97\xCC\x4F\xA4\x00\xFC\x82\x1F\xFC\xA9\xD5\x0A\x9A\xE6\xCE\x6A\xAA\x00\xE9\xC9\x16\xB9\xB9\x54\xC0\x01\x7C\x84\x3D\xD6\x8D\x03\x12\x31\xC5\xCD\xB2\x01\x9F\xFE\x97\x80\x13\xCE\xFB\xCA\x20\x1A\x01\xFE\xC4\x66\x83\x11\x76\xDE\xBC\x0A\x90\x04\x04\xD1\x9E\xB3\x20\x19\xC2\x76\xDC\xA9\x26\x03\x41\xEF\xBF\x01\x15\x9E\x8F\xD2\x6A\xAC\x01\x12\xD0\x3C\xC3\x11\xF6\xC6\xA1\xC8\xAA\x0C\x19\xD0\x7D\xCC\xB1\x04\xCD\xD5\xC8\x5B\xB8\x02\x7D\xD1\x85\x8C\x2A\x3F\xE4\xD1\xE7\x7C\x03\x20\xD1\x41\x8C\x2C\x00\xD3\x45\xC3\x78\x21\x0E\xA2\xB6\x8C\x63\x27\xD0\xCF\x7D\x20\x88\x03\x1A\xD2\x5C\xDF\xCD\x5F\xC5\x88\x4E\x04\x47\xFC\xA8\xC6\x25\xA1\x88\xD0\x4F\xB4\x02\x42\xD2\xB5\x8C\x2C\x0E\xD6\xA4\xAA\xAE\x16\x09\xD2\x48\xAD\xB4\x18\xC8\x32\xB0\x06\x7C\x84\xE2\x90\x02\xBA\xB5\xB4\x34\xC1\x00\xDF\x0A\xD6\xD0\x43\x11\x02\x59\xD3\x08\xE2\xCA\x26\xBE\xA5",
			"\xB6\xB1\x98\xC9\x99\x9D\xCA\xB5\xAF\xA1\x71\xB3\x05\x67\xD3\x1B\x2F\xB7\x68\x05\x4C\xC6\x08\x2A\x0E\xA6\xBC\x23\xBB\xAA\x03\x72\xD3\x20\x15\x03\x3A\xD2\x10\x41\xCA\x1C\xD9\xD3\x02\x0E\x0A\x3C\xD2\xB3\x2F\x6E\xEE\x00\xA0\xC1\x08\x9E\x86\xD2\xA5\x2C\x6F\xC2\xA3\xD7\xA3\xA1\xC0\x00\x3E\xB2\x51\xD7\xB7\x54\xC2\x07\x0F\xD5\x16\x03\xD4\x00\x05\x1D\xCD\xD5\x0C\x8F\xA8\xDA\x00\xA6\xD7\xCF\x5C\xD0\x00\x36\x03\x47\xDA\x0A\x92\xD6\x6B\xCF\xB7\x78\x07\x51\xE4\x84\x53\xDE\x96\x83\xCA\x1E\x0F\xD4\x5D\x00\x53\xC9\xC9\x50\xDC\x07\x0F\xD5\x91\xAC\xD5\xA1\xC5\x2E\xF8\xAC\x3B\xA3\x6E\xDF\x02\xAE\xB0\xBA\x93\xBF\xDD\x80\x04\x7E\x81\x5E\xB6\x8C\xB0\xD8\xB2\xA9\xC3\x10\x3C\x86\x4D\xDA\x5A\xC7\xD5\x21\xC3\xD3\x00\x00\x11\x0B\xD7\x58\x8E\xAC\xB8\xD1\xF7\xB6\x8D\x8D\x03\x5A\xFE\x96\x67\xDE\xA0\xCD\xD0\x52\xB2\x04\xDA\xD4\xCC\x8E\xD7\x22\xD9\xA3\xB6\x8F\x25\x01\xD7\x3D\xBE\x59\xCC\xD3\x72\xDA\x20\x9C\x04\xBA\xCF\xBF\x5A\xB9\x21\x0E\xD7\x77\xB1\x0A\x7C\x87\x88\xCA\xAD\x62\xBA\x20\x31\xD6\x5D\xDF\xFC\x22\x06\xBD\xD1\x85\xE5\xC7\x5E\xDD",
			"\xD0\xDC\xAC\x4C\xC8\xB0\x99\xA5\xC7\x2A\xD6\x3D\xC8\xAB\x53\x00\xA5\xB8\xAD\x39\xD1\xD1\x0A\xD8\xB7\xAD\x05\x86\xDF\xFC\x65\xC6\xB5\xD1\x85\xB3\x04\x62\xF2\xAC\x1F\xDF\x6E\xB9\x06\xC6\xD3\xD4\x17\x70\x5A\xFF\x05\x8F\xD4\x95\xC9\xB1\x9A\xC8\xAA\xC5\x04\x64\xC6\x09\xA0\xC2\xB0\xDE\xD4\x6E\xAE\xA8\x06\xDD\xE7\x81\xCB\x84\xD3\xB0\xCF\x7F\x33\x0A\xD9\x03\x09\x28\xD0\xD9\x9A\xD3\xF0\x55\x04\xCE\xDD\xD3\xDB\x57\xDD\x9B\x07\x9F\xD2\x8D\xD9\x6C\xB4\xC1\x07\x44\xD8\x00\x01\xCA\x72\xD7\xAD\x8A\x92\x44\xA7\xD5\xB6\x89\x28\xEB\xD7\xA6\xDC\x53\xF1\x84\xD4\xCA\x90\x25\xCB\xE8\x96\xBA\xDB\x83\x0F\x27\xD2\xBF\x99\xDA\x00\x04\x66\xEE\xD9\xE7\x7B\x10\xD7\xD8\x4F\xA0\xDB\x3B\xDB\x6C\xC3\x79\x7E\x09\xB4\xE0\xDB\xC5\xDE\xAF\xEC\x82\x3D\xEA\xAC\xB0\xDD\xAD\xEC\xD4\x4F\xA9\x00\x71\xD9\x16\xA0\xDA\xA6\xD5\x7D\xF9\xDB\xD7\xC6\xC1\xE0\xCE\xFB\xBE\xDA\x32\xBC\x97\xAD\xDA\xDD\xCA\xAD\x1B\x04\x1D\x85\xD6\x05\x9C\x97\xE2\xDB\xE1\xC8\xAA\x1E\x04\x1D\x8C\xD6\xC8\xD3\x7A\x9B\xD6\x41\x03\x01\x92\xD9\x16\xBC\xCB\xB7\xD4\x66\xA8\x01\xE6\xDE\x97",
			"\x7C\xCD\x6E\xD4\xDA\xD5\xAD\x02\x1F\xDC\xE1\xC2\xB2\xFC\xD3\xE0\x72\x00\xD3\xDD\x73\xFC\xCB\xD4\xD1\x85\x37\x04\x75\xEF\xBE\xC6\xB9\x85\xEF\xB4\x0F\x0A\xDC\xB1\x84\x76\xC2\x08\xC7\xD3\xBA\xC8\xAB\x0F\x12\xDD\xE0\xCA\x77\xC1\x09\xB4\xDF\xB8\xB8\xAC\x11\x00\xDE\x7D\xCA\x78\xC3\x71\x77\xB9\x04\x48\xDD\x41\x8A\xDE\xA2\xD9\x16\x8E\x02\xE7\xD6\x1B\xCA\xDC\xDF\xDE\x97\x53\x04\x7A\xCA\x90\xE5\xDF\xBA\xFE\x94\x16\x1A\xDE\x3C\xA9\x06\xC3\x08\x1D\xCB\xB5\x8A\x91\x17\x0C\x87\x86\xDB\xBD\xBA\xB5\x77\xBE\x05\x6C\x84\xA8\xDC\xA9\xE4\xDB\x77\xE9\xC4\x31\x03\xB8\xBD\xB9\xFC\xC3\xDE\xA9\xC0\x0D\x35\xDF\xF7\xB7\xBF\xCB\xDF\x40\xCE\x03\xFB\xD8\x3C\xFD\xDF\xE8\xDE\x2F\xF4\x01\x00\xFD\xCB\xFD\xDF\x7A\xE4\xB2\x3D\x07\xC0\x85\x89\xFF\xDD\xDE\x64\xB0\x10\x0D\xE0\xDB\x89\x84\xB2\xC3\xBB\xA6\x04\xB8\xDE\x5F\x95\xE1\x81\x0C\xBB\xB1\x85\x22\x00\xDF\xAA\xAB\x83\xC2\x08\xE2\xDD\xBB\xB8\xAE\x23\x00\xE1\x48\xAA\x84\xE8\x5F\x77\xB3\x09\x28\xE0\x6E\xAA\xE1\x76\x78\x5A\xD8\x04\x17\xEF\xFC\x30\xE2\x02\xFD\xB9\x9D\x04\x86\xC3\x78\x18\xE0\xC1\xBD",
			"\xBA\x28\x1A\xE1\xE3\x9E\xD4\xAF\xB7\x53\x0C\x0E\x88\x9C\x18\x1A\xB5\x51\xC4\x98\xA9\xC5\x54\x08\xBE\xB1\x85\x12\xF0\xB4\xA9\xC2\x15\x05\xE2\x86\x06\x0B\x96\xB7\x13\xF9\xB4\xA9\xC4\x15\x13\xE2\x27\xC8\xC4\xC2\xBB\x8F\xD6\x8D\xAE\x03\x8B\xC6\x09\x31\x0D\xC5\xFC\x2B\xBB\xB0\x05\x62\xE3\x20\x0D\xB2\x2B\xE2\x2C\x0D\xB9\x1A\xE2\x08\x65\x05\x8C\xEB\xD9\xB4\xCF\xC6\x81\x09\x2F\x8C\xE3\x49\xCB\x20\xF6\x05\x3A\xE0\x00\x67\x02\x1C\xE0\x25\xEF\xB0\x17\x3C\xE3\x61\x88\xC7\xF7\xC1\x2A\xDA\x05\x7C\xE1\x0D\x3F\xE2\x81\x03\xB9\xEA\xDB\xCE\x3C\xE3\x54\xB5\x90\xC7\xC5\xD4\xDE\x83\x7C\xE0\x32\x92\xE4\x99\xB8\x5A\xC0\x06\x3E\xEC\x06\x0B\xE5\x35\x2F\xB7\xC2\x04\x8F\xED\x02\x4F\xE0\x47\x29\xC4\x31\x1C\xE3\x5C\xB0\x93\xC1\x08\xBE\xC1\x99\xFC\xE3\x1B\x1A\xB5\x58\xC2\x20\x35\xA7\xC0\xD6\x1B\xC8\x05\x13\xFE\x97\xB3\xE5\xFC\x6F\xB7\x64\x03\xC1\x8A\x91\x2E\xFD\xE0\xFE\x97\x19\x2C\x86\xE1\xB5\x10\xB9\xE4\x09\xF1\x85\xD7\x03\x98\xF1\x85\x5C\xEC\xB9\xBD\xBB\x37\x0A\xE6\xB8\xE4\x63\xC3\xC9\x73\x00\xCD\xE4\xB1\x2E\xF7\xE1\xEF\xBF\x1D\x15\xE7",
			"\x9E\xB9\xCB\xBD\xE3\xFB\xB7\x07\xDB\xE7\xFD\x85\x8A\xE0\xC1\xAA\xFF\x05\x06\xE4\xB3\xE3\xE7\xC4\xA9\xC4\x01\x07\x76\x8D\xE7\xF3\x69\xE7\x03\x0F\x98\xFE\x97\x03\x0D\xCE\xB1\x84\x3C\xE8\x5C\xEF\xB4\x01\x35\xE6\x7F\x97\xCF\xCB\x31\x2A\xD1\x00\xFB\xE0\x9D\xE8\xDD\xF2\xD3\xA4\x81\xE9\xCF\xBD\xE7\xF4\x51\x15\xDB\x00\x83\xEF\x7E\x8A\x9E\x05\xE3\xC8\x20\x07\xEC\x8B\xDC\x9E\xAE\xD0\x9C\xE1\x2A\xC3\x01\x0C\xE8\x3C\xD5\xE9\x11\xE9\x8A\xA8\x01\x46\xFD\xCB\x1B\xEB\x85\xC3\xC9\x16\x0F\xD1\x85\x89\x48\xF1\xE1\x94\xE0\xCB\x25\xE8\xDB\x87\xD2\xD8\xE4\x78\xD7\x01\x2B\xEA\x41\xA7\xE8\x6F\xE0\x9E\xBC\x01\x4C\xFC\xA9\x75\xC1\x21\x27\xE9\x77\xB1\x04\x67\xB9\xFA\xCD\xCE\x4D\x99\x15\xC2\x02\x9F\xE1\x0B\x8B\xC2\xF8\xC7\xD9\xB8\xAB\x08\x04\xEA\x7F\x93\x65\x30\xE3\xBB\xA4\x02\x4B\xEC\xCC\x90\x59\x2B\xE4\xCB\x8A\x91\x11\x11\xEA\x3D\xBD\x8B\x48\xE9\x77\xB6\x04\x58\xEB\xFB\xBE\x57\x39\xE9\xA5\xC6\x09\x23\x0E\xD5\xE0\xCE\x29\xC9\xC5\x48\x05\xAC\xFD\xCA\xEF\x60\xCC\xE4\xB1\x12\x12\xE8\xB1\x86\xBB\x72\xE6\x32\xBC\x04\x70\xEA\xBF\x9E\x6E\xCD",
			"\xE7\xFD\x8F\x02\xBB\xE4\x66\xDE\x6C\x01\xE4\xB3\x52\x04\xAF\xFD\xB8\xEF\x6E\xD2\xFD\xC9\x15\x02\xEC\xEF\xBE\xBB\x74\xE9\xBE\xC8\x05\x08\xEC\x78\xC2\x75\xDE\x6F\xDD\x9B\x02\xB5\xE5\x10\xAF\x63\x94\xDD\xB9\x5C\x07\xEC\x88\x9D\x66\x86\x69\xAF\x63\x96\xD6\xDC\x29\xA2\xB3\xCC\x09\x38\x0A\x6B\xAF\x60\xD8\xCF\xB7\x60\x02\xB4\xC9\x08\xAA\x82\x83\xAF\x61\x4B\xC0\xED\x02\x0A\x0C\x2A\xED\xAA\xA5\xDA\xB3\xC9\xA8\xC4\x03\xB3\xEB\x20\x26\xB3\xCE\xED\xC6\x83\xCA\x19\x19\xED\x02\x0D\x0E\x35\xEC\xC1\x99\xBF\xC0\xED\x40\x16\x03\xC3\xEE\x65\x37\xD2\xE3\xE0\x00\x77\x01\x72\xE0\xE4\x03\xCC\x0D\x0C\xEE\x3C\x0F\xDC\xD4\xB9\x2A\xCE\x03\xCC\xE8\x2C\xBC\xEC\xAD\xC2\xD6\x82\xC4\x73\xEE\xB3\xAD\xED\xCA\x90\xD6\x39\x0C\xDC\xFB\x01\x75\xE9\xB5\xA9\xC4\x0E\x0C\xEE\x3E\x07\xDE\xB6\x29\x25\xCC\xEE\x7D\x05\xBD\xF3\xD4\xD8\xEC\x89\xCC\xEE\x1F\x0D\xEF\xAC\xE6\x55\xCC\xEF\x3F\x0A\x6B\xF6\x73\x21\x70\xD6\x7C\x04\xB9\xF5\xB2\xE5\x16\xE7\x0D\x64\xB4\xDE\x03\xCC\xEA\x2E\x84\xF0\x86\x0D\xA6\xD0\xD4\x20\x0C\xEE\xAE\xB4\x5B\x36\x73\x3D\xD0\xAD\x82\x04",
			"\x73\xE9\xB7\x30\x1E\xCE\x47\x05\x54\xC4\x08\x4C\xEE\xC1\x31\x29\x76\x76\x7E\x5F\xE2\x05\x96\x08\x4C\xED\x66\x44\x93\x9F\x63\x1A\xCC\xEF\xA4\x5B\xE0\x99\x81\x2A\xCA\x04\xCC\xE9\x93\x59\xF0\x86\x01\xDF\xD0\xD4\x23\x0C\xEE\xCC\x61\xA9\x36\x73\xFB\xE0\xAD\x8E\x04\x73\xF4\x73\x28\xF1\x21\x2B\xE3\xEE\xE2\x10\x10\x04\x73\xE9\x00\x1F\x79\xC8\xC6\x09\x38\xE0\xAD\x92\x04\x73\xFD\x91\x12\xF6\x0A\xA9\xC4\x4A\x0C\xDC\xA5\x01\x92\xFF\x6F\x0C\x0F\x2B\xD0\xD6\x4B\x0C\xDC\x81\xC1\xE6\x16\x73\xA0\xBF\xDD\x98\x04\xE6\xEE\x00\xD1\xF0\x2B\x69\xC5\x9A\x04\xB9\xD0\x03\x8F\x7E\x1D\x76\x71\x0E\x0C\x9D\x05\x8C\x13\x0C\xEF\x1B\xCF\xE5\x8C\x08\x9F\xB0\xD6\x9E\x04\xB9\xF3\xC3\x19\xF9\x10\x02\x05\x2A\xC0\x05\xDF\xEF\xCA\xD3\x7B\x81\x08\x95\xD0\xD6\x28\x0C\xEE\xD4\xC5\xCE\xC9\x09\x58\xD0\xAD\xA4\x04\x73\xF7\x04\x82\xF6\x20\x36\x72\x32\xE0\xAD\xA6\x04\x73\xE5\x05\x91\xF3\x20\x36\x73\x1D\x00\xE7\xB6\x8C\x2A\x0C\xEE\xB3\x07\xE3\x7D\x0C\x3B\x7A\x03\x1D\xF6\x82\x8A\x05\xCC\xED\x67\x8A\xF4\x08\xA9\xC5\xCC\xED\x34\x02\xF5\x58\xF1\x21\x1C\xC8\x68",
			"\xDE\x0A\x4C\xEF\xDB\x8B\xF5\xCF\x81\x15\xF0\x04\xE6\xEF\x0E\x19\xF5\xA9\x2C\x08\x91\x01\x15\xF2\x04\xE6\xED\x0F\x3E\xF5\x40\x16\x73\x8E\x01\x2D\xCC\xEF\x05\x0C\x0F\xCA\xF1\x29\xA9\xC5\xB6\x04\xB9\xD9\x01\x66\xF1\xEB\x86\x0B\xA2\xB0\xD6\xB8\x04\xB9\xE7\x00\x6A\xF3\xE8\x82\x08\x96\xD0\xD6\xBA\x04\xB9\xFF\x9F\xCC\x15\xB4\x02\x73\xBB\xBC\x05\x67\xBF\x7D\xEA\xAD\xF3\x69\x8A\xC0\x04\x65\xF6\x8D\x3F\x67\xBF\xC4\xF3\x80\x01\x0C\x4C\xEE\x05\xAA\x1E\x3F\x66\xC0\xF3\xF7\x4E\x4C\xDC\xD1\x00\x3F\x9E\x0E\x3F\x65\xC1\xFB\xF7\x62\x0C\xDC\xAA\xA0\xB7\x1F\x61\x14\xF3\xDF\xC7\x06\x3D\xFC\xED\xAF\x72\x22\xA9\xC5\xC9\x07\xBB\xCD\xF9\x81\x0F\xC3\x22\xF3\xBB\xAB\x06\x88\xF3\xE2\xFE\x9F\x14\xF0\xAD\xCD\x04\x73\xF6\x04\xFF\xF6\x87\x4C\x09\xDD\xEB\xEF\xCF\x04\x73\xE5\xD8\x30\x1F\x87\x75\xF1\x7D\xF1\x0D\x4C\xED\x2C\x1A\xF8\xF0\x54\x21\x3C\xF1\x7D\xF3\x0D\x4C\xEF\xC8\xC7\xF8\x0C\x0B\xC8\xC4\xE8\xD5\xA5\x0D\x4C\xED\x33\x10\xF9\x00\x07\x87\x4C\xF3\x7D\xF7\x0D\x4C\xEF\xD0\xD8\xF9\x09\x0C\xBD\xD0\xD7\x6C\x0C\xDC\xE9\x04\xD0\xFF\x61\x5A\xF3",
			"\xDF\xDB\x06\xE6\xE5\xB6\xE6\x1F\x0F\x61\xF3\x03\xCD\x1B\x0C\xEE\x03\x0C\x0E\xBB\x0F\x0F\x6D\x65\xFB\xF7\x1B\x0C\xEF\xAF\xA8\xEF\x8C\x0B\x9B\xE7\xDA\xCC\xE9\x04\x2C\x87\xDE\x0F\xC3\x77\xF3\xBE\xE3\x07\xCC\xE8\x06\x1D\xFA\x91\xFD\xE7\xA9\xC5\x39\x0C\xEE\x3E\x03\xEE\xDC\x7A\x83\x05\xE8\xFB\xF7\x39\x0C\xEE\x4C\x03\xED\xF4\xFA\x83\x0C\xE8\xFB\xF5\x3A\x0C\xEE\x5B\x02\xEF\xCE\xF9\x31\xE9\x8A\xEB\x04\x73\xE9\x03\x8A\xFC\xE2\xCC\x08\x4E\xF0\xAD\xED\x04\x73\xF7\x03\x82\xFB\xEF\xC3\x09\x52\xF0\xAD\xEF\x04\x73\xF8\xE0\x99\x1F\x87\x62\xC9\x7D\xF1\x0F\x4C\xED\x25\x19\xFC\x8B\xFB\x20\x33\xF5\x7D\xF3\x0F\x4C\xEC\x29\x08\xFD\x92\xF9\x21\x10\x05\x54\xC5\x0F\x20\xF5\xE4\xFB\xF8\x09\x09\xD8\xD0\xD7\x7B\x0C\xDC\xC1\x07\xED\xF1\xF9\xC5\x81\x15\xF9\x06\xE6\xE2\xCC\xC8\xFA\x32\x89\xC5\xFB\x04\xB9\xDD\x07\xDF\xF1\xF4\x8C\x0B\xB5\xFB\xF7\xFD\x04\xB9\xEB\x06\xE6\xFF\xC3\x5F\xF7\xBE\xFF\x07\xCC\xE9\x1F\x30\xFC\xB1\x77\x40\xA9\xC5\x00\x17\xB2\xEA\xF0\xA9\xAF\x6F\x70\xAF\x6E\x85\x03\x95\xB7\xEC\x02\x0A\x1D\xC9\x08\x79\xFB\xF3\xC8\xAB\x01",
			"\x07\xFF\xA5\x9F\xEC\x9E\x0E\xF5\xF6\x10\x7A\xF5\xFB\xF5\xBC\xF0\xF9\x3A\x32\xFE\xB3\xFC\xE0\xA9\xC7\x02\x19\xFF\xDC\x4F\xD9\x5B\x1B\x34\x7F\x7A\x69\x2A\x6D\x00\x00\x80\x94\x1A\x00\x8C\xFF\x4F\x7C\xD0\x6B\x03\x08\x00\x82\x04\x3E\x02\x02\x89\x10\x04\x80\x00\x30\xB4\x61\x01\x0F\x80\x01\x05\x5D\x7C\x2D\x14\x80\x01\x04\x28\x3B\xEF\x53\x00\x18\x80\x00\x0A\x05\x3B\x7F\x13\x83\xC8\x79\x8A\x55\x00\x21\x83\x19\x02\x01\x86\x04\x1C\x80\x00\x0B\xF2\x77\x7F\xCF\x3F\x05\x01\x02\xB5\x01\x2B\x83\x40\x0D\x02\xB3\x7C\x30\x83\xC0\x39\x01\x21\x80\x83\x01\x0D\x89\xFE\x79\x7C\x0A\x75\x08\x81\x09\x3E\x80\x44\x50\x43\x03\xF4\x79\x80\x82\x55\x08\x8F\x09\x04\x81\x00\x01\x0B\x8A\xF4\x7B\x7B\x1F\x01\x08\x8D\x0A\x0C\x81\x2D\x81\xD4\x78\x04\x89\x04\x21\x01\x08\x8B\x0B\x27\x5D\xBD\x05\x0B\x88\xF5\x61\x6A\x23\x01\x08\x8A\x0C\x14\x81\xA9\x31\x2A\x65\x02\x21\x80\xD8\x00\x09\x8C\x02\xA6\x7D\xA6\x78\x45\x71\x02\xB7\x7D\x99\x0D\x0B\x8E\xF6\x57\x81\x27\x59\x08\x84\x0F\x24\x81\x75\x7C\xB4\x6B\x02\x21\x80\x02\x03\x95\x53\x00\x8C\x04\x7D\x7C\x1D\x88",
			"\x68\x21\x80\x10\x03\x95\x5D\x05\xB6\x60\xA9\x63\x0B\x01\x02\x91\x81\x1B\x80\x43\x04\xE9\x7B\x7B\x31\x01\x08\x8D\x02\x3E\x81\x0B\x82\x41\x04\xF9\x7B\x7B\x33\x01\x08\x8B\x03\x06\x82\x95\x83\xE6\x7D\x06\xAA\x56\x35\x01\x08\x8A\x04\x1C\x82\x25\x81\x42\x03\xFA\x42\x82\x02\x07\x0D\x01\x02\x99\x01\xA4\x83\x1A\x82\xEB\x69\x62\x39\x01\x08\x88\x06\x2D\x82\x36\x80\x43\x03\xFB\x50\x6B\x9B\x83\xB8\x57\x07\x14\x82\xA5\x82\x41\x0A\xFB\x7B\x7B\x3D\x01\x08\x85\x08\x3C\x82\xAE\x82\x41\x09\xEC\x50\x6B\x3F\x01\x08\x83\x09\x04\x83\xB5\x81\x42\x0F\x08\x29\x62\x41\x01\x08\x81\x0A\x0C\x83\x3F\x81\x42\x0F\xFC\x68\x82\x01\x07\x10\x01\x02\xAF\x02\xD4\x81\x11\x89\x10\x16\x7F\xD8\x80\x00\x05\x04\x21\x80\xBD\x00\x2D\x82\x10\x38\x41\x8F\x3B\xBB\x57\x04\x20\x7F\xB1\x41\x38\x5D\x02\xAF\x5B\x4B\x03\x95\x5F\xD3\x49\x04\xFF\x62\x41\x06\x05\x88\x75\xCF\x3C\x13\x01\x02\x85\x44\xF5\x80\xA1\x79\x8A\x4E\x01\xFB\x82\x6D\x4D\x0F\x82\x04\xA7\x80\x3E\x83\xF0\x10\x01\x01\x86\x82\x43\x10\x81\x04\xAB\x7D\x38\x82\x05\x09\x84\x3C\x57\x42\x80\x00\x20\x83\x06",
			"\x84\x43\x04\x05\x10\x84\xAA\x55\x43\x66\x10\x15\x64\xD0\x6A\x15\x02\x0F\xB1\x42\x1C\x86\x41\x06\x90\x61\x83\x57\x03\x95\x53\xD1\x6A\x56\x0D\x84\x04\x89\x8A\x5A\x01\x1F\x86\xBF\x45\x10\x81\x04\x5A\x00\x91\x45\x10\x5B\x01\x21\x80\x33\x0D\x12\xAC\x7A\x09\x06\x4A\x61\x0E\x9D\x01\x37\x85\xCF\x5A\x13\xAA\x54\xA9\x62\x17\x0D\x13\xAF\x5F\x31\x67\x40\x01\x13\x90\x6B\x5F\x01\x08\x8D\x0C\x03\x85\x01\x07\x4D\x61\x10\x23\x84\x15\x85\x42\x01\x06\x2C\x83\x22\x54\x43\x05\x14\x91\x85\x4B\x78\x53\x8D\x97\x47\x65\x69\x4D\x2A\x66\x06\x21\x80\xCE\x03\x95\x5E\x1D\x1C\x85\x02\x06\xFD\x78\x15\x83\x04\xB3\x83\xB8\x5B\x0D\x22\x85\x79\x49\xFF\x70\xAD\x6A\x01\x21\x80\x3A\x0D\x0D\x80\x00\x64\x85\x40\x09\xF0\x61\x83\x6C\x01\x08\x86\x0F\x33\x85\x75\x84\x00\x0B\xE1\x50\x6B\x6E\x01\x08\x84\x00\x2A\x5A\xBB\x05\x5F\x86\xF1\x43\x64\x70\x01\x08\x82\x01\x04\x86\x6D\x84\x27\x34\xA9\x61\x80\x20\x02\xAA\x53\x16\xA6\x80\xD0\x68\x1D\x02\x09\x8C\x86\x09\x05\x5F\x8F\x02\xA7\x85\x02\x06\x1D\x0A\x09\x98\x86\x06\x05\x5F\x88\x03\x9C\x86\x9C\x61\x08\x89\x04",
			"\x20\x86\x03\x05\x5F\x8A\xF3\x64\x86\x00\x02\x1E\x01\x02\x97\x01\xA8\x86\x40\x0D\x17\x87\x81\xAC\x84\x1F\x01\x02\xA5\x01\xB1\x85\x40\x0D\x17\x8F\x81\xE1\x82\x1F\x01\x02\xB3\x01\xB9\x84\x5D\x89\xE5\x69\x62\x80\x01\x08\x81\x08\x2A\x5A\xBD\x05\x5F\x8F\x05\xB4\x77\x00\x02\x20\x01\x02\x90\x02\xC1\x85\x5F\x80\xF6\x61\x83\x84\x01\x08\x8E\x09\x12\x86\x8D\x84\x0B\x8F\x09\x88\x55\x86\x01\x08\x8B\x0A\x08\x87\xD9\x85\x21\x53\x8D\x61\x80\xBA\x01\x74\x8C\x10\x3E\x79\xD0\x6A\x22\x01\x02\x88\x03\xE6\x85\x42\x01\x08\xAC\x86\x8C\x01\x08\x86\x0D\x20\x87\x99\x84\x22\x8D\xE3\x6F\x81\xED\x84\xE3\x70\xAD\x50\x02\x21\x83\x3C\x09\x1F\x83\x04\x97\x81\x38\x82\x09\x21\x80\x01\x00\xD7\x59\x1C\x8C\x04\x9C\x7F\xBE\x74\x09\x04\x82\x06\x89\x78\x84\x10\xA9\x62\x96\x03\x22\x8D\x20\xB5\x87\xAF\x82\x0C\x71\x02\xAE\x00\x13\x89\x68\x86\x0B\xA8\x79\x21\x81\x0F\x0C\x75\x45\x86\xC0\x79\x2A\x6C\x09\x21\x80\x4B\x03\x87\x8E\x20\xA0\x52\xA9\x62\x27\x0B\x0A\xA6\x88\x14\x8B\xF1\x70\xAD\x60\x02\x29\x80\x8B\x8A\x21\x96\x83\xA9\x62\x28\x03\x03\xB2\x88\xA9\x84",
			"\x43\x04\x11\x95\x75\xDA\x58\x0F\x89\x21\x83\x04\x4D\x66\x48\x89\x8A\x66\x02\x26\x85\x2C\x42\x95\x63\x75\x4B\x72\x56\x8B\x81\x67\x88\x23\x78\x4F\x5A\x0A\x0A\x89\xB6\x47\x3D\x8A\xF5\x29\x62\xAB\x01\x08\x82\x09\x1C\x5D\x2E\x3E\x94\x84\x65\x29\x62\xAD\x02\x32\x88\x25\x83\x87\xB6\x63\xBE\x7C\x0D\xA3\x5B\x94\x03\x97\x89\x10\x1A\x89\xAF\x75\xC4\x6F\xFC\x31\x02\x21\x81\x25\x06\x26\xB6\x83\xB6\x74\x73\x83\x0B\x21\x80\x96\x03\x9B\x83\x10\x1A\x89\x3A\x64\x73\x85\x0B\x21\x80\x97\x02\x9D\x82\x10\x1A\x89\x7E\x6B\x40\x67\x0B\x21\x80\x98\x02\x9F\x81\x10\x1A\x89\x0D\x09\xC7\x61\x02\x99\x02\x86\x88\x00\x0A\x25\x8C\x6A\x6A\x8B\xC0\x3B\x0B\x21\x80\x9A\x01\xA3\x8A\x25\xA5\x63\x36\x5D\x08\x8B\x09\x16\x8A\x0C\x06\x3B\x75\xC2\x4F\x3F\xBF\x01\x08\x8C\x09\x1C\x8A\x31\x6C\x6B\x81\x0C\x21\x80\x9D\x00\xA9\x86\x6D\x50\x6B\xC3\x02\x75\x8A\x2A\xA4\x11\xEF\x59\x31\x0A\x04\xAF\x8A\x1F\x11\x2A\x67\x0C\x21\x80\xA0\x00\xAD\x8B\xCA\x50\x7C\xD2\x81\xA3\x86\x96\x6B\x7F\xA9\x63\x32\x01\x02\xA2\x02\x5C\x5E\x77\x0F\x2B\xB5\x7F\xA9\x63\x52\x83\x6E\x6F",
			"\x02\xC5\x88\x43\x07\x2C\x83\x04\x02\x7D\x38\x8F\x0C\x21\x80\xBC\x00\x8E\x82\x10\x0F\x8B\x02\x07\x5D\x8C\x1A\x91\x03\x62\x82\xB5\x81\x10\x18\x8B\x01\x07\x5F\x84\xF3\x68\x81\xDE\x88\x00\x00\x2E\x80\x00\x87\x85\xA8\x65\x0D\x21\x80\xE6\x01\xB9\x87\x2E\x9E\x80\xE1\x83\x35\x06\x07\x8D\x8B\x09\x07\xB9\x84\xF2\x61\x83\xD9\x00\x81\x8E\x7A\x7B\x06\xE7\x8B\x66\x8C\x23\xAA\x56\x6B\x84\xC2\x5B\x2F\x8E\x8B\x32\x7D\x2A\x6D\x0D\x21\x80\x1D\x03\xC0\x85\x2F\x80\x81\xD0\x6B\x37\x01\x02\xAB\x00\x0A\x8E\x41\x07\x2E\xB4\x86\xFF\x88\x52\x51\x0E\x21\x80\x39\x01\xC4\x83\x10\x27\x8B\xBC\x84\x6B\x83\x0E\x21\x80\x47\x02\xC6\x87\x2D\xA0\x89\xFB\x79\x39\x01\x02\x95\x01\xAE\x5D\x6F\x07\x2E\x8B\x87\x91\x88\x43\x07\x0E\x21\x80\x64\x02\xC8\x8F\x2D\xA5\x81\xD0\x69\x3A\x01\x02\xB2\x01\xAE\x5E\xB1\x8C\x06\x90\x6B\xEB\x01\x08\x8F\x07\x29\x8C\x04\x8D\x42\x03\x07\xAC\x86\xED\x01\x08\x8E\x08\x32\x8C\xE6\x8B\x79\x89\x8A\x6F\x03\xA2\x88\xD2\x87\x2E\xAF\x87\x15\x8C\x6E\x51\x0F\x21\x80\xAA\x00\xD0\x8B\x30\x8B\x7A\xA9\x63\x3C\x01\x02\xB9\x02\x4E\x8E\x23",
			"\x84\xFB\x61\x80\xC7\x01\xD7\x89\x10\x01\x88\xAC\x87\x3D\x01\x02\x95\x03\x56\x8E\xC4\x88\x20\x9B\x87\xB8\x55\x3E\x01\x02\xA4\x03\x69\x8F\xC6\x8C\x10\x2F\x84\x4D\x8A\x6A\x5B\x0F\x3D\x87\x71\x8F\xC8\x85\x21\x90\x7F\x7C\x82\x75\x0A\x32\x9B\x88\xD0\x6B\x3F\x01\x02\x91\x00\xD6\x04\xBF\x81\x22\x90\x6B\x01\x02\xAA\x5B\x78\x45\x8E\x41\x8E\x31\x89\x8A\x43\x00\x8A\x8E\x76\x3C\x38\x97\x8D\x2E\x8B\xBE\x75\x00\x11\x8E\x63\x8F\xE4\x8A\x36\xB4\x88\xD0\x6B\x01\x08\x39\xBC\x7D\x9A\x8E\xDC\x8F\x0D\xA9\x62\x09\x03\xE7\x83\x10\x17\x01\x7E\x8C\x43\x0C\x96\x42\x89\xD0\x6B\x02\x0A\x6A\x61\x7F\xB8\x56\x5C\x66\x10\x2B\x8E\xE1\x83\x03\x0A\x6A\x73\x83\x06\x05\x5E\x64\x39\xA1\x83\x10\x03\xED\x81\x0B\x41\x66\xB9\x8F\x3F\x7E\x3B\xBE\x4B\x3B\x88\x00\x00\x15\x91\x8D\xCF\x3F\x62\x8D\x5E\x60\x67\x60\x69\x42\x01\x2D\xAC\x86\x15\x02\xE9\x8F\x7E\x4D\x8F\x06\x06\xB6\x88\x3C\x83\x3C\x17\x02\xF4\x8C\x3C\x8C\x04\xE2\x89\x38\x89\x01\x1A\x8F\x7D\x64\xF5\x8E\xBF\x10\x6B\x1B\x00\xF8\x85\x10\x62\x8F\x02\x07\xBD\x8C\x1A\x9D\x00\xE6\x8E\x6D\x48\x3E\x81\x04",
			"\xFE\x89\xDD\x88\x54\x5F\x00\xED\x8E\x82\x4F\x3E\x80\x00\xA3\x87\xF5\x89\x83\x75\x8F\x3C\x57\xFD\x8B\x1A\xBA\x8F\x09\x07\x08\x0C\x3F\xAA\x56\xF7\x8C\xC5\x82\x3F\xB8\x56\x25\x03\x00\x98\x54\x77\x8F\x1D\x8C\x00\x96\x10\x27\x00\x0A\x90\x6E\x57\x3F\x9A\x89\xEF\x59\x0A\x00\x3E\xA6\x01\xD6\x06\xCB\x37\x3F\xAC\x8C\x3C\x6F\x8A\x11\x41\x8F\x3F\xF7\x8F\xD9\x7B\xEF\x6D\x00\xE0\x8F\x19\x09\x41\x9F\x69\x76\x79\x22\x8F\x41\x83\x3C\xF7\x8C\x7A\x80\x09\xAB\x90\x28\x92\x7B\x89\x8A\x73\x00\xE0\x8C\x1A\x07\x42\x89\x04\xF7\x8D\xE1\x71\x0E\xB5\x00\x30\x90\x0E\x9E\x35\x90\x6B\x37\x01\x0F\x96\x10\x37\x8F\x64\x8E\x03\x96\x03\xA0\x8F\x69\x03\x0D\x93\x44\xAB\x8D\xB8\x80\xF8\x8A\x06\x0A\x91\x03\x07\xFD\x84\x37\xAF\x5B\x3D\x00\xF8\x8B\x06\x10\x91\x02\x07\xFD\x89\x12\x86\x91\x02\x07\x0F\x00\x3E\xAC\x01\x58\x91\x40\x07\x3F\xB7\x82\xFB\x79\x10\x02\x44\x91\x91\x87\x8F\xBE\x73\x04\x27\x91\x59\x90\x43\x07\x0C\xBB\x7B\x45\x00\x1B\x92\x46\x8C\x04\xCF\x80\xB4\x67\x04\x32\x91\x00\x03\xFD\x87\x0D\xAC\x86\xA7\x87\xB8\x57\x3E\xBA\x88\xA9\x63\x12\x00",
			"\x3E\xAD\x01\x61\x90\x00\x0F\x3C\x81\x04\x74\x68\xB4\x6D\x04\x03\x8F\x64\x59\x22\x96\x10\x37\x58\xD0\x6A\x13\x0A\x6A\x67\x84\x48\x56\x23\x93\x10\x20\x5D\xFB\x79\x14\x0A\x6A\x5E\x8A\x16\x87\x93\x2D\x11\x9B\x92\xB1\x42\x25\x92\x10\x2B\x5D\xFB\x7B\x16\x00\x4A\xBE\x4B\xA2\x90\xA2\x20\xAD\x60\x01\xA7\x91\x23\x9C\x10\x33\x5D\xFB\x78\x6E\x8C\xDD\x7D\x5C\xA9\x90\x00\x01\xA9\x2F\x85\xAD\x90\x2D\x95\xAA\x07\x90\xCF\x3F\x1B\x09\x4B\xAF\x5F\xB5\x93\xAC\x2C\x4B\x83\x3C\x74\x03\x2F\x90\x9E\x75\x92\x00\x2F\xBB\x59\x07\x06\x93\x7D\x65\x2D\x97\xB0\x07\x78\xCC\x91\x41\x45\x4B\xBF\x2C\xEF\x5B\x20\x01\x4D\xB6\x46\xB5\x90\x8B\x7B\xEF\x48\x02\xD7\x92\x82\x45\x4B\x92\x5E\x5C\x91\x40\x0D\x08\x1D\x93\x47\x6B\xDB\x2C\x1A\x92\x02\xE4\x92\x6A\x56\x3D\x80\x00\xEC\x7C\x6B\x87\x09\x20\x8F\x6E\x02\x75\x0E\x1D\x2B\x93\x66\x85\x38\x90\x00\x19\x02\xE0\x8F\x1E\x02\x4F\x8C\x04\xEB\x93\x21\x93\x4C\x99\x04\xE0\x8C\x22\x01\x3A\x99\x8B\xFC\x91\x2A\x6D\x09\x20\x8F\x96\x03\x40\x96\x17\x9C\x8F\xA9\x63\x27\x00\x3E\xA4\x02\x0A\x94\x00\x0B\x4E\xA9\x8B\xCC",
			"\x85\x28\x00\x3E\xB2\x02\x11\x97\x3A\x90\x2F\xAC\x86\xA3\x00\xF8\x80\x0C\x3B\x93\x09\x07\x3A\x9A\x3E\xB6\x93\xA5\x00\xF8\x8D\x0C\x19\x94\x34\x79\x2A\x67\x0A\x20\x8F\xDB\x00\x4A\x97\x06\x4B\x71\xE0\x8D\x3A\x0E\x52\xB8\x50\x54\x88\xF8\x87\x0F\x33\x94\x03\x06\x01\x9F\x6E\x6D\x02\xE0\x8D\x01\x08\x1D\x3B\x06\xEB\x91\x03\x9F\x4F\x91\x1A\xE0\x8F\x04\x0F\x53\x85\x94\x67\x89\x2A\x61\x0B\x20\x8F\x21\x00\x76\x0D\x1B\x2B\x93\x1C\x92\x23\x71\x71\x20\x8F\x30\x03\x51\x91\x52\xB4\x8C\xFB\x79\x2D\x00\x3E\xBE\x00\xD8\x07\x3C\x9B\x33\xBB\x7B\xB7\x00\xF8\x8B\x04\x0E\x95\x48\x97\x9E\x59\x8A\x79\x02\xE0\x8E\x16\x06\x55\x95\x8F\x4A\x8C\xB4\x6B\x0B\x35\x90\x6B\x95\x01\x82\x43\x90\x6B\xBD\x00\xF8\x86\x07\x24\x95\x57\x94\xD6\x82\xB2\x60\x8F\x85\x01\x5C\x94\x50\x8B\x4B\xA9\x61\x30\x00\x3E\x93\x02\x7E\x97\x42\x93\x36\xAC\x8D\xCF\x3F\x30\x00\x3E\xA1\x02\x78\x94\x5B\x99\x10\x09\x88\xE1\x81\x31\x00\x3E\xB0\x02\x8D\x96\x5C\x98\x13\x8A\x7C\xE0\x8F\x2F\x05\x59\xBF\x95\x06\x07\x16\x93\x54\x86\x04\xC9\x00\xF8\x8E\x0C\x1B\x96\x86\x96\x41\x04\x46",
			"\xA1\x83\xCB\x00\xF8\x8D\x0D\x05\x96\x12\x95\x1A\x91\x0E\x8D\x03\xE0\x8F\x3A\x0C\x5A\xAB\x93\x6F\x92\xB4\x80\x3E\xB9\x03\xB3\x94\x1D\x99\x8A\x51\x03\xE0\x8F\x01\x0A\x1D\x00\x95\xCE\x7D\x2A\x63\x0D\x20\x8F\x15\x03\x6F\x95\x56\x83\x04\xC5\x8F\xBB\x55\x0D\x20\x8F\x23\x02\x76\x0D\x1B\x02\x6A\x66\x68\xB4\x67\x0D\x13\x92\xB1\x40\x74\x96\x10\x18\x92\xE1\x82\x36\x09\x4E\x88\x55\xD6\x97\x99\x2D\x30\x9B\x97\xB8\x55\x77\x93\x4A\xA9\x62\xE4\x00\x78\x9F\xFC\x22\x97\xAA\x92\xE1\x76\x5E\x83\x3C\xE8\x94\x00\x00\x4B\xA1\x83\xEE\x03\x7A\x9C\x10\x2D\x97\xB7\x90\xEB\x72\x5F\x87\x4A\xBB\x93\xBB\x58\x0F\x37\x97\x06\x05\x7B\x92\x4C\xAF\x5B\xFD\x00\x7F\x93\x10\x2D\x97\xC9\x93\x40\x62\x00\x1C\x5D\x9C\x90\x7E\x99\x10\x0F\x93\xFB\x7B\x01\x08\x60\x95\x97\x42\x2D\x3E\x7F\x60\xBE\x4B\xED\x96\x36\x91\x0E\x91\x00\x13\x98\x99\x5D\x5E\xA0\x93\x9F\x96\x53\x39\x61\xBD\x5C\xED\x94\xDA\x2C\x1A\x9B\x00\x1F\x9B\xFB\x59\xA8\x7D\x97\xA9\x60\x08\x0D\x28\x85\x44\x91\x6A\x41\x0D\x4E\xB6\x93\x21\x00\xD7\x58\x38\x72\x00\xDA\x06\x77\x0D\x62\x83\x04\xF5\x91",
			"\x87\x92\x10\x23\x00\x32\x98\x43\x0F\x03\x35\x98\x0C\x07\x8D\x92\x10\x3E\x93\xEF\x59\x09\x0D\x63\x89\x04\x4C\x02\x71\x99\x10\x02\x99\xA5\x95\x38\x87\x02\x07\x99\x06\x06\x16\x0A\x64\x86\x04\x4C\x9A\x5F\x89\x8A\x69\x00\x50\x98\x5A\x83\x65\x83\x04\x55\x98\x45\x9D\x32\xB0\x18\x59\x99\x67\x8B\x65\x82\x04\x55\x9B\x46\x96\x4F\xAD\x00\x61\x99\x40\x04\x08\x00\x99\x4B\x98\x65\x8B\xEF\x6F\x00\x69\x98\x00\x01\x09\x23\x99\x01\x05\x95\x91\x3F\xAF\x5B\x31\x01\x9C\x9F\x09\x34\x99\x90\x69\xC1\x80\xAD\x73\x00\x71\x99\x2B\x0C\x67\x95\x99\xFF\x8E\x8E\x90\xAF\x31\x99\xBB\x03\xA0\x96\x04\xA9\x62\x37\x01\x9C\x99\x0C\x0A\x9A\x49\x7C\x2C\x81\x67\x97\x03\x90\x98\x9C\x88\x0B\xB1\x99\xE5\x02\x73\x91\x64\x94\x30\x86\x9A\xF1\x81\x67\xB4\x03\x95\x9A\xAD\x49\x8A\x7F\x00\x71\x9A\x00\x0C\x1D\x36\x98\x5F\x95\x38\x81\x04\x31\x99\x0F\x00\x77\x0D\x1B\x15\x99\x43\x8E\x3D\x93\x04\x31\x99\x1E\x00\x77\x0B\x1B\x15\x99\x2E\x91\x38\x85\x04\x31\x99\x2C\x02\xAD\x9B\x69\xB3\x95\xFB\x7B\x11\x01\x67\xBA\x00\xAE\x9B\xAF\x94\xF8\x69\x62\x49\x01\x9C\x99\x04\x3E",
			"\x9A\x6D\x98\x60\x90\xAD\x65\x88\xE3\x5B\x15\x0C\x6C\x94\x99\x93\x7C\x62\x93\xF0\x0D\x01\x71\x99\x19\x05\x6C\x8D\x9B\x06\x04\x64\x9C\x1A\x8F\x01\x71\x98\x1D\x0B\x6D\x94\x9B\xA6\x81\x2A\x61\x05\x31\x99\x83\x03\xB8\x9C\x65\x8C\x04\x9E\x97\xBB\x53\x05\x31\x99\x92\x02\xBA\x94\x66\x80\x8E\xFB\x79\x15\x01\x67\xA1\x02\xD3\x9B\xBA\x99\xFB\x69\x62\x57\x01\x9C\x9F\x0A\x39\x9B\xF3\x99\xF0\x70\xAD\x59\x01\x71\x99\x2F\x00\x70\xB5\x99\xBA\x94\xB4\x6B\x05\x31\x99\xCB\x03\xC1\x9D\x67\x9C\x8E\xFB\x79\x17\x01\x67\x99\x03\x0E\x9D\x95\x99\x5C\x83\x64\x5F\x01\x9C\x97\x0E\x32\x9B\x24\x52\x21\x39\x8A\x61\x01\x71\x9A\x3D\x07\x6A\x8C\x04\x97\x69\x42\x09\x63\xAF\x5B\x63\x01\x9C\x93\x00\x39\x06\xDE\x05\xC9\x96\x10\x04\x99\x03\x65\x19\x01\x67\x90\x00\xB9\x07\x6E\x0E\x72\x96\x96\xE1\x83\x19\x04\x6B\xB5\x9C\x24\x9C\x43\x90\xAD\x69\x01\xBC\x98\xCF\x99\x10\x37\x9C\x15\x83\xBE\x7B\x06\x03\x9B\x42\x9E\x41\x04\x74\x9D\x80\xA9\x61\x1B\x01\x67\x88\x01\x2C\x9D\xCF\x9E\xE2\x50\x6B\x6F\x01\x9C\x95\x05\x09\x9D\x03\x07\xD2\x9E\x02\xA9\x62\x71\x01\x9C",
			"\x93\x06\x18\x9D\x02\x06\xD6\x99\x3F\x9D\x9A\x73\x01\x9C\x91\x07\x20\x9D\x1D\x9E\x90\x79\x8A\x75\x01\x71\x9B\x1F\x08\x76\x80\x00\x5A\x9E\x4E\x93\x90\x77\x01\x71\x99\x23\x0F\x76\x9A\x9D\x42\x96\x32\x91\x67\x9B\x02\x77\x9C\xC9\x81\x0E\xBB\x01\x71\x99\x2A\x09\x1B\x3D\x06\x5A\x9D\x54\x95\xBC\x4F\x3F\x7D\x01\x9C\x98\x0B\x3D\x9D\x67\x78\xB4\x6F\x07\x31\x99\xC6\x01\xD4\x93\x74\xA9\x9A\xAC\x85\x20\x01\x67\x93\x03\x83\x9E\xD4\x96\x56\x90\x6B\x83\x01\x9C\x92\x0E\x0C\x9E\x06\x05\xAE\x9C\x1A\x85\x02\x71\x98\x3C\x00\x7A\xBE\x83\xD0\x6B\x21\x01\x67\xBE\x03\x99\x9F\xE4\x9A\x57\xBB\x7B\x89\x01\x9C\x9D\x00\x20\x06\x36\x9F\x0F\x9B\xEF\x4B\x02\x71\x9B\x06\x04\x7B\x9A\x9E\x00\x8A\xB5\x9F\x0B\x71\x99\x29\x00\x68\x04\x78\x8C\x91\xFB\x7B\x23\x01\x67\xB8\x00\xC2\x9C\xEF\x9F\x20\x90\x6B\x91\x01\x9C\x97\x04\x09\x9F\xAE\x9D\x67\x99\x8A\x53\x02\x71\x9A\x15\x00\x7D\x8A\x9D\xF4\x99\x38\x8E\x26\xA3\x5B\x65\x03\xEE\x91\x7D\x83\x04\xBF\x81\x38\x8D\x27\xA3\x5B\x73\x02\xF7\x98\x7D\x82\x9C\xFB\x78\xA3\x83\x6E\x41\x02\xE6\x9D\xD6\x99\x70\xBB\x7B",
			"\x9B\x8B\xB8\x5F\x08\x2D\x9F\x61\x9D\x70\x90\xAD\x69\x8A\xE3\x59\x27\x04\x7F\xA9\x9D\x06\x07\xC5\x91\xAA\x5F\x02\x71\x9B\x2A\x07\x7D\x86\x85\x0C\x04\x24\x9B\xEF\x61\x02\x5C\x5C\xEC\x8F\xFC\x1E\x6A\x48\x29\x2A\x65\x0A\x1C\x5D\x72\x6C\x52\x5C\x80\xAA\x29\xFB\x7B\x2A\x00\x81\xB1\x42\x13\xA3\x40\x04\x4A\xA1\x83\xB1\x03\x05\xAE\x2F\x59\xA0\x8B\x28\x58\x9E\x81\xA4\x59\x20\xA1\x40\x0F\x5E\xAC\x86\xBD\x03\x08\xAD\x73\x65\xA0\xB6\x91\x2A\x63\x0C\x2A\xA0\xEF\x5C\x0B\xAA\x77\x7B\x72\x30\xA0\x78\x6C\x82\xBF\x97\x03\x67\x33\x05\x83\xBD\x65\x2C\xA1\x81\x9A\x2E\xBB\xA0\x05\x44\x0B\xAC\x60\xA1\x83\xDB\x00\x10\xA6\x1B\x6C\xA0\xD4\x93\x40\x61\x0E\x06\xA1\x0A\x48\x0B\xA6\x61\xAC\x86\xE7\x00\x13\xAC\x53\x6C\xA0\x1C\x9B\xBB\x5D\x0E\x12\xA1\x4E\x6A\x39\x96\x4F\xB3\x03\x58\xA0\x52\x55\xAA\x51\x99\xC2\x7F\x8A\x96\x1B\x6B\x6A\xE7\x9F\xBE\x7A\x0F\x22\xA1\xE6\x6E\xB1\x91\x0E\xBB\x03\x68\xA0\x4F\x57\xAB\x6E\x98\xA9\x60\x3F\x01\x67\xBA\x02\xA0\x06\x77\x0F\x86\xB8\x98\xA9\x62\x3F\x01\x67\x87\x03\x75\xA0\x43\x07\x87\x83\x99\xA9\x61\xE8\x52",
			"\x6D\x54\x03\xFB\x9C\x00\x0F\x87\x8D\x99\xAC\x86\x00\x0E\x7A\x48\x4E\xE2\x01\x21\xA7\x88\x96\x99\xD0\x68\x01\x0B\x88\x9A\x33\x8E\xA3\xFF\x26\x4F\x86\x00\x93\xA1\x42\x0E\x0F\x15\xA2\x8E\x84\xB4\x68\x00\x19\xA2\x55\x06\x68\x06\x87\xAE\x99\xE1\x82\x02\x00\x8A\x83\x04\x19\x02\x68\x0B\x1B\x0F\xA2\x77\x9B\x40\x6C\x00\x27\xA2\x02\x07\x09\x0A\x8A\xBE\xA1\x7E\x9B\xBE\x7E\x00\x30\xA2\xF0\x2B\x2C\xA9\x10\x0F\xA2\x85\x9B\xBB\x50\x01\x38\xA2\x00\x03\x10\x0A\x8B\x86\x04\x8F\xA2\xDC\x91\xAA\x52\x00\xC0\xA1\x14\x03\x8C\xA9\x50\x52\x78\xB4\x64\x01\x00\xA3\x5F\x03\x32\xA2\x10\x0F\xA2\x14\x93\x40\x66\x01\x00\xA3\x6D\x02\x68\x0D\x1B\x0F\xA2\x86\x9F\xA7\x83\xF0\x18\x00\xC0\xA0\x1F\x02\x8D\x81\x04\x8F\xA3\x74\x8C\x1A\x9A\x00\xC0\xA2\x22\x02\x8A\xB4\xA2\x13\x82\xEF\x92\x38\x40\xA3\x97\x02\x36\xAC\x8E\x9B\x9E\xFB\x7A\x07\x00\x8C\xA6\x02\xE3\xA2\x21\xAD\x56\xBB\x7B\x20\x00\x30\xA4\x0B\x39\xA3\x8F\xA0\xD4\x8D\x69\xA2\x00\xC0\xA2\x30\x02\x8F\xBB\xA2\xF6\x87\xBE\x74\x02\x00\xA3\xD1\x00\x40\xA6\x7B\xA1\x83\x26\x00\x30\xAF\x0D\x0E\xA4\x87",
			"\x94\xB4\x68\x02\x00\xA3\xED\x03\x41\xA4\x8C\x84\x9F\xE1\x82\x0A\x00\x8C\xBC\x03\x1A\xA4\x33\xA5\x6E\x90\x6B\x2C\x00\x30\xAB\x00\x08\x06\xDB\xA0\xBB\x99\x8A\x6E\x00\xC0\xA2\x06\x08\x92\xB3\xA3\xB9\x78\xB4\x60\x03\x00\xA3\x29\x00\x62\x0B\x8A\xAE\x96\xAC\x86\x0C\x00\x8C\xB7\x00\x36\xA4\x4C\xA2\x10\x35\x96\xAC\x84\x0D\x00\x8C\x85\x01\x3D\xA4\x42\xAE\x0C\xA9\x62\x36\x00\x30\xA3\x05\x05\xA5\x1B\xA4\xC4\x91\x0E\xB8\x00\xC0\xA1\x18\x0C\x94\xA2\xA4\xFD\x9D\x2A\x6A\x03\x00\xA3\x6F\x03\x4B\xA9\x10\x3E\x6A\xC0\x88\xB4\x6C\x03\x00\xA3\x7E\x00\x62\x0E\x1D\x1C\xA5\xC8\x88\xB4\x6E\x03\x00\xA3\x8B\x02\x58\xAC\x10\x24\xA5\xD0\x89\x2A\x60\x04\x00\xA3\x98\x03\x54\xA2\x10\x2C\xA5\x9C\x95\x38\x82\x04\x37\xA3\x72\xA5\x40\x04\x97\xA1\x8B\xA9\x60\x11\x0E\x8F\xB9\xA5\x00\x03\x5E\xA8\x2E\xA9\x62\x46\x01\x41\xA0\x98\x82\xA6\x66\x99\xA7\x98\x04\x00\xA3\xD0\x02\x5A\xAB\x95\xA4\xA2\xAC\x86\x12\x00\x8C\x9D\x03\x87\xA5\x4A\x90\xAD\x4C\x01\xC0\xA3\x3A\x05\x99\xAF\x94\x91\x90\x30\xA9\x0F\x1B\xA6\x34\x94\xB4\x60\x05\x00\xA3\x07\x02\x62\x0B\x1B",
			"\x02\xA6\xC6\xA0\x73\x82\x05\x00\xA3\x15\x02\x69\xAB\x96\x8D\xA3\xFB\x78\x15\x00\x8C\xA3\x00\xAE\xA7\x63\xA9\x54\x9D\x84\xC0\xA1\x0C\x0A\x18\x3D\x06\x82\xA5\x37\xA1\x0B\x58\x01\xC0\xA0\x10\x05\x9B\x86\x04\x82\xA6\x39\xA6\x4F\x9A\x01\xC0\xA2\x13\x0A\x18\x23\xA5\x94\x9E\x3D\x9C\x05\x00\xA3\x5B\x03\x6E\xAF\x9A\x82\x8D\x41\x84\x30\xAA\x06\x03\xA7\x03\x06\x60\xA2\x7A\xB6\x93\x60\x00\x30\xA8\x07\x18\xA7\x73\xA4\x20\x83\xBF\x40\xA3\x86\x02\x74\xA6\x9B\x87\x9B\xD0\x69\xCC\x83\x6E\x55\x02\xE0\xA6\x5E\xAF\x90\xAC\x86\x66\x00\x30\xA3\x0A\x2D\xA7\x81\xA5\xB5\x90\xAD\x68\x01\xC0\xA1\x2C\x06\x9E\x84\xA7\x1C\xA4\x6B\x8A\x06\x00\xA3\xC0\x03\x7E\xA9\x9D\xB3\x8D\xA9\x60\x1B\x00\x8C\x8F\x03\x02\xA9\x78\xAB\x37\xA1\x83\x6E\x00\x30\xAE\x0D\x09\xA8\xEE\xA6\xEC\x79\x8A\x70\x01\x18\xA4\x7D\xA2\x98\xA1\x9F\xAC\x84\xCE\x83\x6E\x7B\x03\x16\xAA\x1B\x99\xDE\x40\xA3\x09\x00\x63\x07\x9A\xAF\x9F\xE1\x82\x1D\x00\x8C\x97\x00\x22\xAB\x74\xA6\xED\x69\x62\x78\x00\x30\xA5\x02\x29\xA8\xE7\xA4\x72\x99\x8A\x7A\x01\xC0\xA3\x0C\x0C\x18\x3D\x06\x47\x71",
			"\x74\x9B\xEF\x7C\x01\xAE\x5E\x02\xA3\xF0\x39\xA8\xD7\x94\x71\x8E\x7A\x51\xA0\xB8\x54\x90\xAE\x5D\xBB\x7B\x86\x03\x90\xA1\x0B\x46\xA9\xE3\x96\x8D\x7A\xA4\xBE\x4B\x4C\xA9\x7A\x92\x20\x8F\xA9\x54\x6B\x2B\x99\x8A\x58\x02\x54\xA9\xCF\x51\xA5\xAD\xA0\x78\x79\x96\xAF\x7E\x5B\xA9\x33\xA0\x4D\x6E\xA5\xA0\x67\x5B\xA8\x0E\xA1\xAA\x55\x8D\x66\x6E\x6A\x5B\xA5\xBE\xA0\xCC\x84\x2C\x03\xA6\xBD\x65\x5B\xAB\x10\xAC\x1A\xB6\x02\x6F\xA9\x41\x4B\xA5\x89\xA1\xA1\x68\x2F\x05\xA7\xB6\x46\x5B\xAB\x13\xA6\x4F\x82\x03\x7B\xAA\x82\x4B\xA5\x95\xA1\x03\x64\x32\x01\xA8\xBC\x54\x5B\xAA\x88\x96\x4F\x8E\x03\x87\xAA\x6A\x55\xC5\x46\x04\x5B\xAB\xBB\x54\x0D\x2E\x5E\xB8\x8F\x40\x00\x0B\x71\xA8\xAC\x84\xDA\x84\xCE\x7C\x54\x8F\x80\x55\xA1\x0E\x96\x03\x94\xA9\x2C\x45\x68\x86\xA0\xF1\x89\x8F\xA2\xAA\xBA\x4A\xA9\x63\x36\x0D\xA8\x88\x55\x85\x98\x98\x26\x4F\xA1\x03\xAB\xA8\x6E\x55\x68\x9B\xA0\x50\xA1\xAC\xAF\xFC\x05\x9A\x82\x2A\x15\xA6\xAB\x83\x3C\x85\x9B\x09\xAB\x85\xBB\xAA\x0C\x8E\x41\x05\x5F\xA1\x83\xF9\x00\xB0\xAA\x76\x98\x2A\x81\x8E\xB1\xA1\x9A\xB9",
			"\x2A\xD0\x69\x01\x06\x1D\x04\xA9\xB7\xA8\xC2\x21\x0E\x8B\x00\xCF\xAB\xA9\xAB\x60\xBF\x73\xD5\xAA\xBF\x45\x68\xB8\xA9\xCC\x87\x05\x09\xAD\xA4\x59\x85\x9A\x9F\xAD\x69\x9D\x00\xDF\xA9\xCF\x55\x68\x84\xAA\x60\x81\xB9\xAF\x7E\x45\x9A\x8A\xA9\xA7\x99\x02\x2A\xAB\xE0\x66\x01\x94\xFE\x43\x64\x2F\x02\x75\x08\x38\x42\x01\x8C\x06\xCB\x37\xC7\x46\x04\x7E\x70\xB4\x61\x03\x05\x92\x05\x47\xBE\xA3\x10\x1D\x72\xD0\x6A\x0C\x00\xB0\xB6\x46\xFD\xAA\x25\x83\x43\xB6\xAB\x56\x85\xBE\xA2\x0C\x4C\x04\x09\xAF\x0E\x97\xB0\x8A\x48\x84\x72\x41\x04\xB0\xBB\x7B\x36\x03\xC4\xAC\x53\x4A\x72\x5D\xA7\xBE\x77\x03\x0C\xAC\x15\x50\x63\x0E\x1D\x1C\xAC\x65\xA7\xBE\x79\x03\x20\xAC\x43\x92\xC8\xAC\x10\x24\xAC\x6D\xA4\x2E\x88\xB2\xA9\x50\x30\xAA\x41\x0C\xB2\xB5\xA5\xAC\x85\x0F\x0F\xB2\x88\x3F\x31\xAF\x40\x03\xB3\xBC\xA5\xC8\x83\xCD\xA1\x10\x3A\x01\x39\xAE\x40\x0B\xB3\x83\xA6\xD0\x69\x10\x0E\xB3\x91\x6B\x41\xAD\x40\x03\xB4\x89\xA6\xEF\x5B\x10\x07\xB4\x96\x02\x2A\xAD\x42\x03\xB4\xA3\x94\x9D\x99\x11\x07\xB4\xA3\x02\x49\xAC\x00\x03\xB4\xAD\xA2\xA1\x6B\x11",
			"\x07\xB4\xB1\x02\x59\xAF\xD0\xA3\x76\x8C\x6F\x47\xAF\x2F\x01\xB6\x81\xAB\xE1\x83\x12\x07\xB4\x8D\x03\x67\xAD\x42\x09\x9A\x9F\x99\x06\x05\x13\x07\xB4\x9B\x03\x6D\xAE\x41\x09\x77\x83\x64\x4F\x03\xD1\xA9\x0E\x35\xAD\x77\x8A\xB9\x97\xB4\xB7\x03\x37\xAB\xCA\xAC\x69\xAE\x9B\x47\xAE\x01\x0E\x18\x3B\x06\x43\xAE\x71\xAD\x69\x95\x01\x47\xAC\x05\x0E\x18\x23\xAC\xCD\xA5\xA7\x98\x3A\xA3\x5B\x21\x02\x63\x0D\x1B\x03\xAD\xB1\x99\xA7\x99\x05\x07\xAD\x30\x03\xE1\xA2\xB8\xB9\x81\xA5\x93\xD1\xAE\x03\x1E\xAE\x52\xAE\x78\xA0\xAD\x5D\x01\x47\xAC\x13\x06\xB9\x9F\xAE\xE8\xA7\xBE\x7F\x05\x07\xAD\x5B\x00\xE9\xA2\xB3\xAF\xA7\xF6\x91\x18\x07\xB4\xA9\x01\xB2\xAE\xCE\xA6\x9F\xBB\x7B\x63\x03\xD1\xA7\x07\x2B\xAE\xA5\xAF\x63\x9E\x8E\x8B\x79\x47\xAE\x21\x00\xBC\xB3\xAE\x23\xA7\xBE\x76\x42\xAB\xA7\xC7\xAE\xEE\xAB\xA0\xAC\x86\x49\x93\xB8\x54\x0A\x0D\xAF\x42\xAD\xF6\x9C\x1A\x97\x91\xE3\x5B\x2C\x09\xBB\x95\xAF\xFB\x98\xB4\x64\x48\xA3\x5B\xC1\x03\xF6\xAA\xB4\x9E\xA8\x54\x9F\xD1\xAF\x0C\x22\xAF\x5A\xAC\x89\xAC\x1A\xB1\x01\x47\xAD\x37\x08\xBE\x83\xAD",
			"\x7B\x92\x3D\x93\x07\x07\xAD\xEB\x03\xFB\xA0\x48\x90\x6B\x75\x03\xD1\xA9\x0F\x14\xAF\x01\x05\x24\x7F\x48\xA9\x62\x77\x02\x75\x09\x60\x86\x04\xFE\xAF\x25\x99\x8A\x7C\x01\xD6\x06\xF1\x56\x1B\x45\xB0\x02\x06\xAB\xAD\x69\x83\x02\x09\xB3\x94\x5C\x10\x34\xAA\xF6\x92\x22\x01\xC1\xBE\x4B\x0C\xB2\x94\xAC\x1A\x91\x02\x17\xB0\x99\x59\xC1\xAE\x97\x57\xA9\x07\xBD\x73\x5F\xB0\xC3\xA8\x6B\x8F\x09\x22\xB0\xEF\x5F\x07\xB1\xA6\xA1\x6A\xA6\x00\x0A\xB0\x9E\x5F\xB0\x66\xA8\x73\x8D\x0A\x2E\xB0\x7D\x67\x07\xBC\xA6\xB0\xAD\xEF\x18\x0D\xB5\x10\x5F\xB0\x72\xAA\x3D\x9B\x0B\x3A\xB0\x0B\xB1\x84\x93\x90\x42\x03\x40\xB2\x82\x4F\xC1\xA2\xAB\xBB\x71\x11\xBC\x53\x5F\xB0\xE8\xA8\x73\x80\x0D\x0A\xB1\xAA\x57\x07\xBD\xAE\xAF\x5B\xD7\x00\x14\xB8\x54\x57\x72\x04\xB1\x2A\x6E\x0D\x1A\xAC\xAA\x57\xC5\xAE\xBC\xA1\x7D\x5C\xB0\x52\x53\xCA\x5D\xAC\xE1\x80\x38\x07\xB4\x88\x00\x90\x06\x77\x03\xC6\xA5\xAC\xE1\x82\x38\x07\xB4\x95\x00\x69\xB0\x43\x0B\xC6\xAD\xAC\xFB\x78\x39\x07\xB4\xA2\x00\x90\x07\x6E\x03\xC7\xB4\xAC\xF6\x92\x39\x0C\xB9\xB9\xB1\x72\xB2\xCF\x9B",
			"\xEF\x68\x03\xA2\xAC\x20\xB9\x10\x3B\xB1\xF7\x2C\xB4\x6A\x0E\x29\xAE\x86\xB2\x41\x08\xC8\xA2\x3F\xCE\x65\x18\xB8\x5B\x4F\xB2\x4C\xAF\x40\x6D\x0E\x07\xAD\x5A\x01\x1C\xB7\xC8\x90\xA6\xF6\x93\x3B\x07\xB4\xA7\x01\x8D\xB0\xB7\x46\x99\xA4\x7E\x47\xAD\x1D\x01\xCA\x82\x04\x8F\xB3\xD8\xA3\x90\x73\x03\x47\xAF\x20\x07\xCA\x81\x04\x8F\xB1\x2F\xA3\x90\x75\x03\x47\xAD\x24\x0F\xCA\x80\x00\x8F\xB3\xDB\xAD\x41\x86\x39\x47\xAF\x27\x07\xCB\x8F\xB2\x77\xAD\xA8\x69\x0F\x07\xAD\xAD\x03\x2F\xBE\x77\xAC\x86\xFB\x03\xD1\xAB\x0B\x10\x06\xBD\x07\x23\xBE\x9B\xBE\x4B\xFD\x03\xD1\xAA\x0C\x06\xB3\x8D\x9F\xF5\x77\xB4\x98\x03\x9A\xB2\x23\xB1\xB9\xAF\x5B\x01\x00\x76\x08\x38\x65\x03\xCC\xB1\x20\xB4\x9D\x90\x6B\x03\x02\x37\xB0\xE1\x14\xB3\xA1\x9D\x2A\x6E\x53\xA3\x5B\x02\x02\x74\x0A\xC7\xA6\xAE\x0D\x9A\x39\xB9\x12\x12\x07\xCD\xB1\x42\xA1\x0E\x89\x00\xF2\xB2\x41\x0F\x01\x2E\xB3\xE2\xB2\x7E\x8B\xEF\x4B\x00\xF9\xB0\xA2\x1C\xCF\x9B\xB2\x15\xA7\xBE\x7D\x00\x01\xB4\x02\x07\x0E\x04\xCF\xBD\xB3\x9E\x81\x03\x88\xD0\x87\x8A\x0B\xB4\x41\xB7\x59\x97\x98\x0F",
			"\xB4\xDC\x91\xD1\x9A\xB3\xCF\xAE\x3D\x96\x54\xA3\x5B\x68\x03\x45\xB2\xCA\x92\xA8\xD0\x69\x05\x05\xD1\xB7\x01\x03\xB4\x46\xBE\x0B\xA9\x62\x17\x01\x45\xB5\x08\x25\xB4\x1F\xB6\xE3\x80\xAD\x59\x00\x15\xB7\x24\x0C\xD2\xA8\xB2\xEA\xAE\x3D\x9B\x01\x15\xB4\xA1\x03\x4C\xB0\xCB\xB6\x9F\xFB\x79\x07\x05\xD1\xAF\x02\x3A\xB4\x2E\xB7\xBF\x90\x81\x15\xB5\x2F\x0E\xD1\x82\x04\xA9\x70\x1C\xA0\xAD\x4D\x95\xE3\x58\x33\x02\x1D\x1E\x07\x49\xB4\x1E\xA0\xAD\x63\x00\x15\xB5\x36\x0F\xD4\x8C\x04\x51\xB4\x20\xA0\xAD\x65\x00\x15\xB6\x39\x01\xD4\x99\xB5\x88\xA2\x3D\x97\x02\x15\xB4\xF4\x03\x57\xB2\xC8\xA1\x83\x29\x01\x45\xB2\x00\x22\x13\xBB\x04\x58\xB4\xB4\xBB\x7B\x2B\x01\x45\xB0\x01\x2C\xB5\x58\xB4\xC7\x73\x42\x95\xB4\x1E\x02\x38\x10\xD5\x9C\xB2\x9D\x9B\x0B\x05\xD1\xAB\x00\x74\xB5\x42\x0E\xD6\x9C\xAD\xCC\x85\x0C\x05\xD1\xB9\x00\x81\xB6\x41\x0E\xD6\xAA\xB2\xA1\x6B\x0C\x05\xD1\x87\x01\x89\xB7\x40\x0E\xD6\xB2\xB2\xA1\x69\x0D\x05\xD1\x95\x01\x91\xB4\x52\xBB\x68\x80\x91\x15\xB7\x18\x09\xD9\x81\x04\x6E\xB5\x30\xBC\x1C\xB9\x00\x15\xB5\x1C\x0F\xD9",
			"\x80\x00\x6E\xB5\x35\xA1\xAA\x7B\x00\x15\xB7\x1F\x02\x4E\x3D\x06\x6E\xB7\x33\xB4\x66\x7D\x00\x15\xB6\x23\x07\xDA\xAE\xB5\x8A\xAF\xBB\x5F\x03\x15\xB4\x9C\x02\x5E\xB5\xD7\xAD\xA3\x45\xAD\x45\xB9\x0A\x2F\xB6\xBF\xB4\x3D\xA1\x0E\x83\x01\x15\xB4\x2E\x07\xDB\xBB\xA3\xBA\x99\x45\xB6\x0C\x0B\xB7\xC0\x99\x38\x87\x04\x15\xB4\xD4\x00\x71\xB2\xD8\xB6\xB3\x7C\x91\x45\xB3\x0E\x10\xB7\xFE\xB1\xDA\xA5\xD1\xB1\x03\xDC\xB5\xEF\x9A\x48\x95\xB4\xFF\x02\x75\xBA\xD8\xBD\xA7\xF6\x93\x13\x05\xD1\x8E\x00\x81\x10\x6C\xB4\xA0\x90\x6B\x51\x01\x45\xBD\x01\x2D\xB7\xC5\xB6\xEA\x79\x8A\x53\x01\x15\xB4\x0B\x04\xDF\x97\xB7\x20\xB5\xBD\x95\xD1\xBB\x00\x81\x11\x5B\xB8\x93\xB6\x93\x57\x01\x45\xB9\x04\x01\xB8\xF5\xB7\x4F\xA9\x8A\x59\x01\x15\xB7\x15\x08\xE0\xBC\xB7\x95\x8D\x38\x8B\x05\x15\xB4\x65\x03\x83\xB7\xDE\x8E\xA5\xAC\x85\x17\x05\xD1\xB3\x01\x16\xBA\x64\xB3\xD4\xA1\x83\x5F\x01\x45\xB1\x08\x3B\xB7\x06\x07\x2B\x7A\xA3\xA1\x83\x61\x00\x76\x0E\xA3\x8C\x04\x26\xB9\x90\xA0\xAD\x65\x01\xD8\x04\xB4\xA3\xF0\x2D\xB8\x47\xA9\x38\x8B\x06\x31\xB8\xB1\x40",
			"\x8D\xBD\xA4\xBB\x7B\x71\x00\x8E\xBE\x2F\x7A\xB8\x1A\xB2\x3D\x97\x07\x3E\xB8\x64\x58\x90\xB0\xC2\x90\x6B\x7D\x00\x91\xBD\x73\x46\xB9\x25\xB2\x3D\x93\x08\x0A\xB9\xEF\x5E\x91\xBB\xC2\x8C\x87\x89\x00\x94\xB0\x9E\x46\xB9\x31\xB0\x0E\xBF\x4A\x56\xB9\x7D\x66\x91\xB7\xC3\xBB\xB2\x06\x05\x25\x0C\xE5\x85\x44\x46\xB9\x0F\xBD\x69\x9B\x02\x63\xBA\x6D\x46\xE4\x9C\xAB\x5A\xB9\x52\x49\xE6\x8A\x48\x46\xB8\x12\xB3\x90\x67\x02\x6F\xB8\x4F\x56\xE4\x8D\xB1\x6D\xB9\x48\x15\xE7\xAA\x56\x46\xBB\x14\xB3\x90\x73\x02\x7B\xB8\x52\x5C\xD9\x57\xB8\xFB\x79\x2E\x08\x1D\x15\xAA\x02\x07\xA0\xB3\x10\x06\xB9\xEF\x5A\x2E\x07\xE8\xB1\x42\xA4\x77\x00\x49\x8A\x7B\x02\x8F\xBA\xBF\x41\xE9\x95\x05\xC3\xAD\xD2\x15\xD1\x90\x02\x81\x10\xE2\x47\xE9\x8A\x5A\x99\xBA\x40\x0E\x0B\x15\xB4\x92\x01\x20\x16\x0F\x5F\xBA\x42\xAD\xA8\xB1\x10\x00\x03\x15\xB5\x25\x06\xEA\xA3\x76\x0C\x07\x1C\x0A\xEA\x83\x2A\x15\xB4\x26\x0F\xEA\x89\x04\xA8\xB8\x11\x53\xEB\x84\x03\x15\xB7\x26\x07\xEB\x86\x04\xB9\xB8\x00\x0E\x03\x33\xBA\xC6\x01\x45\xBE\x09\x3F\xBA\x03\x05\xB0\xB3\xAA\x50",
			"\x6B\xC8\x00\x4E\xB8\xEC\x82\x04\xC1\xBB\xAB\x60\xAD\x4A\x03\x15\xB4\x29\x0F\xEC\x81\x04\xC1\xBA\x2A\x03\xEB\x8C\x03\x15\xB7\x29\x07\xED\xBD\x50\x0C\x04\x2C\x03\xEB\xA3\x96\xE3\x5A\x2A\x0F\xED\x81\xBB\x37\x7F\xBE\x70\x0D\x15\xB4\xAD\x03\xB9\xBA\x23\xB3\xBA\xD2\x01\x45\xB0\x0B\x2E\xBB\x09\x04\x37\x03\xEB\x94\x03\x15\xB7\x2C\x04\xEF\xA3\x75\xB3\xBA\x35\x05\xD1\xB6\x02\xFB\xBA\x78\xBB\xEF\x58\x03\x15\xB5\x2E\x01\xF0\x82\x04\x5D\x03\xAC\xBA\x0D\x15\xB4\xBC\x03\xC1\xB1\x10\x1E\x03\xB3\xB8\x37\x05\xD1\xBF\x02\x0E\xBC\x00\x0E\x6D\xB6\x93\xDE\x01\x45\xB2\x0C\x15\xBC\xDD\x03\xAC\xB0\x0E\x15\xB4\xC5\x01\xC5\xB5\x01\x33\xBA\xE2\x01\x45\xB8\x0C\x15\xBC\x48\x6C\xB4\x64\x0E\x15\xB4\xCB\x03\xB7\xBC\xDA\x43\x04\x73\x01\x2A\x66\x0E\x15\xBA\x64\x5B\xCB\xB6\x1B\x33\xBA\xE7\x01\x45\xBE\x0C\x1D\xBA\x53\x46\xF3\x73\xEB\xA9\x03\x15\xB4\x34\x0E\xF2\xAB\xAC\xB3\xBA\x6C\x93\x6E\x53\x03\x43\xBF\x00\x43\xEB\xAD\x03\x15\xB6\x35\x09\xF4\x9A\x87\x9D\x7D\x55\xBF\xF4\x83\x04\xC3\xB8\xB4\x61\x0F\x15\xB4\xDC\x03\xD4\xBD\x19\xB3\xBA\xF3\x01\x45",
			"\xBF\x0D\x1A\xBD\x3F\xAF\xAC\xB5\x0F\x15\xB4\xE2\x00\xD8\xB0\x6F\x73\xBA\xF7\x01\x45\xB5\x0E\x26\xBD\xE2\xB8\xB4\x68\x5B\xA3\x5B\xE8\x02\xD9\xB9\xEE\xAB\xA1\x15\xB7\x3A\x06\xF6\x90\x01\xB3\xB9\x3F\x05\xD1\xAE\x03\x66\xBE\xBD\xB1\x38\x9F\xB7\x66\xBF\x11\x03\xEB\x81\x00\xDA\x04\xE2\x44\x0F\x26\xBD\x45\x91\xA7\x93\x00\x05\xBE\x48\x3A\xD9\xB9\xF0\x8D\xAB\x8C\xBF\x95\x36\xF6\x90\xBC\x9D\x8D\xE4\xBF\xE9\x26\xBD\x17\xBD\xA7\x99\x00\x16\xBE\x06\x07\xB1\x66\x0F\x76\xBC\x64\x33\xAC\xBB\x00\x1C\xBE\xEB\x42\xE7\xBD\xF3\x91\x07\xB3\xB9\x03\x04\xFA\xA9\x5A\xA6\xBF\x6A\x7E\xC8\x33\xBA\x0F\x03\xEA\xB6\x20\x2D\xBE\xB4\x77\x89\xBC\x1A\x91\x00\xDA\x07\x8A\xB2\xE9\x8D\xA0\x21\xB6\x76\x02\xE3\xB1\xBA\x9E\x93\xBE\x7B\x01\x3E\xBE\xB1\x41\xCC\xB9\x10\x14\xB0\x9D\x99\x08\x04\xFC\xBE\x4B\xC6\xBE\x9F\x29\x8A\x67\x00\xCB\xBC\x99\x5D\xFC\x8D\x54\xA9\x61\x0B\x01\xFD\xBD\x5C\xD3\xBE\x40\x0D\xE4\x9D\x9A\x33\x03\xF5\xBF\x7E\x59\xBF\xA6\x28\x2C\x8E\xFD\xA0\x67\xE0\xBC\x00\x09\xE5\xA0\xB9\x03\x07\x8F\x99\xA6\x88\x55\xE5\xBF\x97\xB2\x55\x86\x04",
			"\x45\x03\xF8\xBD\x97\x65\xBF\x66\xB8\x3C\x82\xFF\x85\x44\xE5\xBC\x9B\xB8\xFE\x99\x91\xF7\xBE\x6D\x45\xFE\xB2\xB9\xA1\x6B\x15\x0D\xFF\x8A\x48\xE5\xBC\x9E\xBB\xFF\x81\x04\x5D\x03\x00\xCC\x53\x65\xBF\x7E\xB9\xA8\x63\x06\x0A\xC0\xAA\x54\xD5\xA4\xAA\x90\xAF\xB9\xBD\x2C\x44\xB5\x98\x97\xAC\x85\x1B\x00\x01\xC8\x55\x54\xAE\x03\xBF\x6E\x73\x01\x1B\xC0\x6E\x54\xB5\x88\xBF\xCA\x91\x08\xCF\xFC\x14\xAD\xB9\xAB\x40\x6F\x07\x26\xC0\xC4\x92\x95\xA0\xAD\x45\x02\x2C\xC0\x5F\xBB\xFD\xAF\x5B\x8B\x01\x0C\xC3\x75\x9C\x2A\xCC\x9E\x0D\xC6\x10\x14\xAD\xE7\xBF\xFB\xB3\x10\x17\x02\x3A\xC2\x6E\x72\xAD\xAC\x86\x9D\x01\x10\xC9\x3E\x8C\x04\xF5\xBF\x40\x63\x0A\x06\xC1\x01\x04\xD5\xAA\xFF\xBE\xC0\x02\x05\x2A\x0C\x04\xE5\x59\x48\x2D\x2A\x6F\x0A\x13\xC1\x54\xAE\x01\xC0\x05\xC1\x04\xB5\x00\x16\xCA\x85\x9D\x9A\x89\x9B\xFA\xB8\x5B\x42\x77\x64\xB2\xA9\x82\xFB\x8C\x00\xC7\x6A\x77\x04\x06\xEC\xB1\xAC\x87\x30\x02\xFB\x99\x00\x69\xC0\x43\x0B\x06\xF4\xB1\x91\x96\xEC\xB6\x02\x07\x6B\xBB\x07\x1C\xCC\xC7\x9D\x9A\xC7\x02\xEC\xB4\x03\x38\xC1\x72\xC3\x59\xBC",
			"\x1A\x8F\x9A\xE3\x5A\x10\x00\x08\xC9\x04\x7A\xC1\x22\xBB\xEF\x4B\x03\xB2\xBC\x14\x07\x08\xE1\x40\x76\xB7\x6B\x92\xFB\x9E\x01\x71\xC0\x22\xCC\xD7\xAF\x5B\xCF\x02\xEC\xBB\x06\x0F\xC2\x03\x05\x22\xCB\x75\x90\x6B\xD1\x02\xEC\xB9\x07\x1C\xC2\xC1\x75\x2D\xA1\x0E\x93\x03\xB2\xBF\x21\x04\x0A\xC1\x04\x9E\xC0\x65\xBC\x1C\x95\x03\xB2\xBD\x25\x0B\x0A\xC0\x00\x9E\xC2\x2E\xBB\x05\xC0\x00\x94\x9B\xB8\x53\x0A\x33\xC2\x9E\xC2\x68\xB9\xE7\x99\x03\xB2\xBD\x2C\x0C\x0B\xC7\xB3\xF6\x93\x36\x02\xFB\xBF\x02\xC7\x69\x6F\x0E\x09\xF2\xB6\x3D\x5D\x37\x02\xFB\x8E\x03\xC3\xC1\x35\xB1\x0E\x9F\x03\xB2\xBC\x37\x05\x09\xD0\xC2\xC0\xB7\xBE\x71\x0E\x32\xBE\xE9\x01\x32\xC1\x08\xE3\xB3\x6F\x7E\xEC\xB8\x0F\x11\xC3\xE9\xB0\xB4\x69\x69\xA3\x5B\x06\x03\xBE\x61\x53\x1E\xC2\x02\xA4\x71\x62\xFB\x94\x00\xEA\xC1\x34\x1E\x09\xFA\x90\xAC\x85\x3A\x02\xFB\xA3\x00\xF1\xC1\x52\x1E\x09\xDD\xAA\xAC\x87\x3A\x02\xFB\xB1\x00\xF9\xC1\x1E\xCB\xBB\xA1\x83\xED\x02\xEC\xBF\x03\x39\xC3\xCA\xC0\x7A\xBD\x69\xAF\x03\xB2\xBE\x13\x08\x10\xDF\xC3\x13\xB4\x6B\x81\x0F\x32\xBE\x5D",
			"\x03\x43\xC6\x09\xD9\xB4\x9D\x9B\x3C\x02\xFB\xAC\x01\x16\xC4\x36\xC6\x5A\xB4\x7E\xB2\xBF\x1E\x01\x10\xD0\xC4\xE0\x9D\x2A\x67\x0F\x32\xBE\x89\x03\x48\xC7\x11\xEE\xB4\xFB\x79\x3E\x02\xFB\x97\x02\x2A\xC6\x47\xCF\xEC\x50\x6B\xFB\x02\xEC\xB5\x0A\x31\xC4\x9D\xC0\x4F\xB1\x0E\xBD\x03\xB2\xBF\x2C\x08\x13\xE5\xC2\xA3\x8D\xE0\x82\xFB\x81\x03\x1D\xC7\x40\x08\xDC\x65\xC1\xF6\x91\x00\x0C\x1D\x08\x4E\xD0\x01\x3E\xCE\x1D\x07\xC5\x6C\xC2\x3D\x93\x00\x0B\xC5\x51\x32\x53\xCC\x10\x10\xC5\x74\xC0\x6B\x85\x00\x14\xC5\xAE\x33\x4F\xC7\xDC\x47\x97\xAC\x87\x01\x0C\x15\xC6\x04\xF8\x02\x57\xC2\xAA\x42\xC2\xF6\x91\x02\x03\x16\xED\x5B\xF9\x69\x52\x18\x15\xC5\x9D\xD3\xAB\x5A\xCA\x17\x2D\xC5\xBB\x07\x5B\xCC\x74\x90\x6B\x0D\x02\x5C\xC1\x10\x22\x00\x6D\xC7\x53\xC7\x09\xC3\x64\xAD\x9B\xB8\x5F\x02\x34\xC5\x57\xC7\x28\xB7\x61\xBA\xC5\xC6\x8C\x61\xC9\x10\x36\xC5\xF8\x8D\x2A\x63\x01\x08\xC6\x4B\x02\x62\xCA\x02\x68\xAD\xD0\x8C\x62\xC9\x05\x12\xC6\x46\xC7\x66\xBB\xEF\x57\x00\x88\xC7\x19\x08\x19\xDD\x86\xB0\xA6\xF7\x88\x18\xF5\x01\x9F\xC7\x57\xC7\x9B",
			"\x82\xBF\x88\xC7\x20\x0D\x16\xFD\x06\x8C\xC4\x33\xCF\x7E\x5D\x00\x88\xC6\x24\x05\x1A\xE7\xC5\xD2\xC0\x6B\x8F\x01\x08\xC6\xA0\x01\x5F\xC5\x18\xD9\xC3\xE1\x81\x08\x08\x18\xED\x02\xAB\xC7\x6E\xC6\xDC\xAC\x86\x23\x00\x62\xCC\x0B\x33\xC6\x8C\xC7\x76\xAD\x69\xA5\x00\x88\xC6\x32\x08\x1C\xF0\xB3\x4E\x98\x62\xC8\x0D\x01\xC7\x8B\xC4\x76\xB6\x4F\xA9\x00\x88\xC7\x39\x0F\x1C\xCE\x9B\x70\xB4\x62\xC5\x0F\x1B\xC7\x96\x83\xAC\xBD\x02\x08\xC6\x03\x00\x1E\x6C\x1A\xCA\xC4\xEF\x5B\x0B\x08\x18\xD2\x00\xE6\xC6\x70\xC3\x10\x13\x91\x03\x65\x0C\x08\x18\xE1\x00\xED\xC5\x75\xC8\x11\xEF\x5B\x33\x00\x62\xC0\x03\x35\xC7\x93\xC5\x7F\xBB\x43\x88\xC6\x3F\x00\x1E\x65\x17\xC3\xB8\x9D\x9B\x0D\x08\x18\xCD\x01\x02\xCA\x7B\xCA\xE0\x90\x6B\x39\x00\x62\xCB\x05\x09\xC8\xF6\xC5\x84\xBC\x1A\xBB\x00\x88\xC5\x1A\x00\x21\xFD\xC7\x2B\xA8\xB4\x6D\x03\x08\xC6\x77\x03\x85\xC9\x19\xC1\xC5\xFB\x7B\x0F\x08\x18\xC5\x02\xFC\xC7\x40\x0E\xDC\x76\xBE\xF6\x91\x10\x0C\x1D\x07\x08\x05\x47\x89\xCE\xE2\xBB\x7B\x4A\x00\x77\x00\x29\x88\x55\x2E\xC9\x8D\xBC\x1A\x95\x01\x32\xC9",
			"\x2C\x45\x23\xFB\xB8\xE1\x80\x18\x09\x23\xFE\x4B\x3B\xC9\x90\xBD\x69\xAB\x01\x3F\xC8\x99\x51\x24\xC7\xB9\xFB\x7A\x1D\x05\x24\xFD\x5C\x47\xCB\x0C\xC3\x90\x41\x02\x4B\xCB\xFB\x57\x24\xD3\xB9\x79\xB8\x23\x01\x25\xE0\x67\x47\xC9\x0F\xC7\x78\x83\x3C\x97\x03\x95\xCD\x97\x47\xC9\xEE\xBF\x96\xC7\x4E\x1E\xC9\x2D\xC8\x12\xCC\x25\xA4\xC9\xB6\x47\x91\xCF\x04\xE2\xC9\x13\x1C\x9A\xCA\x20\x47\xC9\x00\xC0\x73\x83\x0C\x2E\xC9\x3C\x57\x91\xCA\x05\xEC\xC9\xAE\x28\x9D\xCA\x5A\x47\xC9\x0D\xC0\x73\x84\x71\xB1\x61\xB6\x44\x75\x78\x22\xDD\x9A\xE4\x03\x8A\xC1\x0B\x42\xCA\x2F\xC8\x41\xCA\x27\xC8\x55\x88\xCA\x8D\xC6\x4F\xB8\x03\x8B\xC8\x6E\x5D\x28\xFC\xC8\xAC\x87\xCA\x90\x28\xCA\x48\x93\xCA\x90\xCF\x6E\x4E\x00\xB9\x07\x8C\xC2\x29\xEE\xC0\xFB\x79\x06\x0D\x29\xC7\xCA\x90\x29\x2A\x64\x02\x23\xCA\xFE\x49\xA6\xC0\x00\x14\xC9\x07\xC0\x00\x0F\x02\x28\xCA\x64\x5A\xAA\xCA\x25\xDE\xA3\x08\x88\xAC\xCD\x73\x6A\xCA\x61\xC8\xAD\xC9\x10\x05\x01\xB6\xCB\xFB\x5A\x2A\xC9\xC1\xA1\x68\x14\x0D\x2B\xE0\x67\xAA\xCB\x9A\xCA\x2B\xC6\x04\x5B\x03\xB0\xCD\x97\x6A",
			"\xCA\x71\xC9\x9E\xB6\x06\x0A\xCB\x05\x46\xAA\xC7\x27\xC7\xCB\xC9\xB8\xB4\xC1\x28\xDF\xC1\xEF\x58\x1F\x06\x2D\xCA\x48\xDA\x76\x41\x0A\x2A\xEF\x5B\x87\x01\x6E\x08\xE8\x81\x04\xDD\xCA\x89\xC3\x8D\x62\xCB\xB1\x40\x78\x7F\x21\xF0\x9E\xE8\xCA\xBF\x46\xDE\x48\xC5\x9D\x9A\x22\x09\x1B\x08\x4E\x94\x00\x1E\x6E\x1D\x2F\xCB\x51\xC5\xA7\x9C\x08\x33\xCB\xE5\x12\xBD\xCF\x04\x6E\x85\xFB\x7A\x23\x0C\x2F\xF9\x18\x1E\xCA\x40\x08\x2F\xF8\x9C\xAC\x84\x24\x03\x30\xF9\x1C\x05\xCD\x40\x07\x30\xC2\x04\xDD\x8F\x39\x9B\x30\xFB\x29\x0D\xCC\x00\x0F\x30\xCA\xC2\xE1\x80\x25\x03\x31\xE5\x2F\x15\xCF\xC5\xC0\x00\x15\xB2\xA1\x6A\x25\x0B\x31\xDD\x80\xFE\xC9\x42\x0E\x31\xD4\xAD\x62\x7B\xC8\xC0\x00\x33\x03\x1D\xCE\x61\xCC\x1A\x9A\x02\x2A\xCD\x00\x03\x86\x7B\x06\x1E\xCC\x63\xBC\x1C\x9C\x02\x2A\xCF\x03\x03\x33\xFF\xCB\xC7\xAB\xBE\x7E\x09\x2A\xCC\x1D\x03\xCE\xC6\x32\xDA\xC6\xE1\x80\x28\x0A\x32\xEB\x00\x42\xCE\x41\x0E\x31\xFE\xC2\xAD\xCA\x28\x0A\x32\xF9\x00\x49\xCF\x40\x0E\x31\xEA\xB6\xCC\x84\x29\x0A\x32\xC7\x01\x63\x61\x6F\x0E\x31\xEE\xC6\xE0\x66\x29",
			"\x0A\x32\xD6\x01\x51\xCE\xC1\xC8\x55\xA1\x83\xA8\x02\xCA\xC4\x06\x23\x61\xF7\xCB\x36\xB3\x90\x6A\x02\x2A\xCD\x1C\x09\x35\xFC\xCC\xC3\xC6\x3D\x9C\x0A\x2A\xCC\x80\x01\xD8\xCE\x30\xCC\xB7\xAC\x86\x2B\x0A\x32\xCE\x02\x76\xCE\xC5\xC0\x1D\xEC\x86\xB0\x02\xCA\xCC\x09\x2F\xCD\x43\xCF\xEB\x91\x0E\xB2\x02\x2A\xCF\x2A\x0D\x37\xDE\xCC\xFC\xC2\x3D\x94\x0B\x2A\xCC\xB9\x03\xE2\xC3\x10\xF3\xA9\x2A\xCF\x31\x04\x38\xCA\xCD\xE8\xC7\x40\x6B\x78\xA3\x5B\xD6\x03\xE5\xC2\x35\xEF\xB7\xFB\x7A\x2E\x0A\x32\xE5\x03\x9E\xCE\xD8\xC7\x1F\xC3\x64\xBC\x02\xCA\xC4\x0F\x25\xCE\x77\xCE\x7F\xCC\x1A\xBE\x02\x2A\xCF\x00\x09\xB5\x74\xCC\x04\xCB\xBB\x50\x0C\x2A\xCC\x11\x03\xEC\xC0\x37\xC3\x04\x40\xA7\x9F\xAA\x32\xDF\x00\xBA\xCD\xE1\xC2\x21\xF6\x93\xC4\x02\xCA\xCD\x02\x01\xCF\x98\xCC\x86\xB6\x4F\x91\x9E\xE3\x5B\x0E\x08\x3C\xDF\xCE\x20\xC9\x38\x88\x0C\x2A\xCC\x49\x01\xD6\x6D\x1B\x02\x95\x1E\xCF\xBB\x5A\x0C\x2D\xCB\x64\x5A\x50\x9E\x09\xD7\x7C\xDC\xCD\xCF\x51\x3F\x93\xC0\xF6\x90\x33\x0A\x32\xC5\x44\xF1\x8C\x06\xCB\xA8\xB9\x06\xBA\xBE\x41\x01\x3F\x9E\xC0",
			"\x03\x66\x34\x0C\x3E\xF1\x42\xF1\x8C\x09\xC3\x90\x56\x03\xF3\xCE\xBF\x41\x3F\xA9\xC0\xA1\x6A\x36\x09\x3F\xE4\x59\xF1\x8E\xAF\xAD\x69\x9E\x03\xFF\xCE\xF8\xC5\x2A\xD0\x6B\x9F\x9D\xA9\x80\x9E\x71\x8F\xAC\xCB\x2D\xC6\x0E\x05\xD0\xEF\x5D\xFC\x83\x2B\xF1\x42\xEA\x00\x04\xDB\x40\xC3\xC1\xF6\x92\x3B\x06\x41\xFD\x65\xF1\x8C\xB0\xCC\x1C\xB2\x03\x1B\xD0\xFA\xC2\xC4\xA1\x6A\xF6\x01\x08\xD6\x1B\x71\x8F\xCD\xC9\xAB\xCA\x0F\x26\xD0\x0A\x49\xFC\x83\x2D\xF1\x42\xAC\x9E\x02\xDC\x41\xD8\xCB\x06\x98\x68\x0D\x3E\xC3\x04\x63\x9C\xF9\xCD\x69\x86\x00\x36\xD1\x2C\x43\x76\xAA\xCF\x9D\x9A\x02\x00\x1A\x3F\xBE\x9C\xA4\x05\xAC\x3B\x83\xD1\x3E\xD3\x04\xB9\x8A\x56\x00\x48\xD2\xBF\x43\x76\xBC\xCF\xCC\x84\x07\x0D\x44\xE4\x59\x63\x9E\x00\xDF\x6E\x62\x00\x53\xD1\x2C\x67\x40\xFB\x7B\x28\x01\x16\xDF\x7E\x63\x9D\x0D\xD0\x9E\xC4\x6B\x1E\xD1\xE0\x67\xD8\x93\x41\xFE\x4B\x34\x00\x19\xDD\x97\x63\x9D\xB9\xC9\x2C\x4A\x03\x2A\xD1\x05\x47\xD8\x9E\x41\xF9\xB9\x40\x00\x1C\xD6\x1B\x63\x9D\xC6\xCA\x8A\x56\x47\xCA\x48\x63\x9D\x0A\xD7\x0B\xCC\x01\x7B\xD0\x4F\x53",
			"\x76\xAF\xD0\xFE\x4A\x14\x01\x48\xEA\x56\x63\x9D\x9F\xC9\xE7\x98\x01\x87\xD0\x52\x5C\xDF\x70\xCB\xEC\x6C\x68\x08\x38\x58\x01\x59\x6E\x77\x0F\x48\xF9\xCB\xA8\x76\x24\xD6\x04\x95\xD2\xFC\x48\xC0\xC1\x0E\xA2\x01\x9A\xD3\x6A\x7F\x3C\xC2\x04\x97\xD0\xC2\xC6\x4F\xA4\x01\xA1\xD0\x2E\x63\x4A\xC1\x04\xA5\xD0\xC4\xCE\x15\xA9\xD2\xBC\xCF\x2A\xD0\x00\x2D\xD2\x18\xCC\x6B\x88\x06\x30\xD2\x02\x04\x27\x02\x4B\xF4\xD2\x1F\xCD\x2A\x6A\x06\x38\xD2\x01\x06\x2A\x0C\x49\xF0\x51\x7F\xC5\xA8\x6C\x06\x00\xD3\x00\x03\x2D\x0B\x4B\xEE\xCC\xF6\x92\x1B\x08\x4C\xC5\x03\xCB\xD1\x11\xD1\x0E\xB0\x01\xC8\xD3\x34\x01\x4D\xCB\xAB\xE1\x82\x1C\x08\x4C\xE1\x03\xD7\xD1\x4E\x99\xDE\x48\xD3\xEF\x01\x37\xD2\x10\x0C\xCD\xB7\xC2\x1D\x08\x4C\xFD\x03\xE2\xD3\xA1\x8C\xA2\x88\xD3\x0B\x00\x44\x6D\x1B\x3C\xD2\x5C\xCD\x5F\x6A\x07\x08\xD3\x1A\x00\x44\x6B\x1B\x3C\xD2\xB9\xB7\x40\x6C\x07\x08\xD3\x28\x00\x44\x66\x49\xEA\xCD\xA1\x6A\x1F\x08\x4C\xF5\x00\xEE\xD1\x27\xD0\x0E\xE1\x83\x80\x00\x32\xD4\x04\x36\xD3\x06\xD5\x39\xCB\xEF\x42\x02\xC8\xD2\x14\x0C\x50\xC4\xD3\xD1",
			"\xB4\x6B\x84\x08\x08\xD3\x60\x01\x41\xD4\x51\xED\xAE\xE1\x82\x21\x08\x4C\xEF\x01\x13\xD6\x41\x0C\x4B\xCD\xCE\x9D\x98\x22\x08\x4C\xFD\x01\x21\xD7\x40\x0C\x4B\xC9\xBE\xD9\x60\x32\xDB\x08\x1A\xD4\x22\xD5\xE6\xC1\xAA\x4C\x02\xC8\xD2\x26\x00\x53\xEA\xD4\xA0\xCD\x38\x8E\x08\x08\xD3\xA9\x03\x4D\xD4\x4A\xEA\xA4\xFB\x84\x32\xD8\x0B\x3E\xD4\xAC\xD2\xF5\xA6\x4F\x92\x02\xC8\xD3\x31\x09\x52\xFF\xD4\xDD\xAE\x82\x88\x4C\xD5\x03\x4B\xD5\x51\xD8\x7E\xA1\x83\x96\x00\x32\xD3\x0E\x11\xD5\xB3\xD1\x4D\xBD\x69\x98\x02\xC8\xD1\x3C\x08\x55\xFC\xD2\xF1\xAD\xA7\x9A\x09\x08\xD3\xFF\x03\x57\xDF\xE1\xAC\x86\x9C\x00\x32\xDD\x00\x02\x6F\xBD\x07\x80\x7F\xBF\xB8\x79\xA0\x04\x25\x98\x5B\x6E\xD5\x06\xB0\xB4\x61\x0A\x20\x06\x03\xB3\x40\x04\x57\xCD\xB0\x43\x88\x5E\xD1\x0B\x7B\xD5\x01\x06\xFD\xC1\xAA\x42\xA0\xB3\x93\xFB\x50\x58\xC5\x2A\xD0\x68\x2C\x0E\x57\xFE\x4B\x87\xD6\x15\xD3\x90\x75\x02\x8B\xD5\x04\x7B\x45\xE1\x83\x74\xA1\x61\xD0\x9E\x47\xD6\x61\xD0\xB5\xC2\x10\x3F\x02\x91\xD5\xCF\x57\x58\xE7\xD1\x64\x58\x31\x0D\x59\xC6\xD6\x18\xD1\xA7\x99\x0C",
			"\x23\xD6\x97\xD6\x99\xC0\xAD\x4E\x03\xA8\xD5\x5F\x67\x58\xF9\xD1\xFE\x4B\x34\x0D\x5A\xC5\x44\x87\xD6\x1F\xD2\x46\xE5\x2F\xB3\xD6\x6D\x47\x58\xC4\xD2\x64\x59\x37\x09\x5B\xCA\x48\x87\xD6\x22\xDD\x2A\xCD\xA2\x96\xD5\x5F\x68\x16\x49\x04\x87\xD4\x71\x60\x1A\x23\xCB\xCD\x85\x43\xD1\x0E\xA8\x03\xCB\xD5\x2C\x43\x08\x02\x71\x03\x65\x3A\x08\x4C\xDC\x00\xC2\x6E\xCB\x33\x5D\xE6\x38\xFB\x7B\x3A\x08\x4C\xDD\x00\xD9\xD4\x43\x0B\x5D\xCE\x49\xA9\x61\x3B\x08\x4C\xDE\x00\xE1\xD5\x42\x03\x5E\xCE\x35\x4B\x8C\x32\xDF\x01\x29\xD7\x06\x07\x7A\xD8\x4A\x2F\x5B\xF1\x00\x32\xD0\x02\x30\xD7\x03\x06\x7C\xD6\x4B\x2F\x5B\xF3\x00\x32\xD1\x02\x38\xD7\x02\x06\x7E\xDA\xB4\x74\x7E\xC8\xD2\x08\x00\x60\xC1\x04\x02\xD9\xA2\x83\x90\x77\x03\xC8\xD3\x08\x07\x60\xC0\x00\x02\xDA\xA7\xC7\x5B\xC1\x04\xF9\x00\x32\xD4\x02\x0F\xD8\x02\xD8\xA6\x83\x90\x7B\x03\xC8\xD1\x09\x08\x61\xDD\x8A\xA9\x61\x3F\x08\x4C\xE6\x00\x1F\xDA\x0C\xDF\x6E\x7F\x03\xC8\xD3\x09\x05\x62\xEB\x8A\xFB\x79\x00\x02\x1A\x08\x4E\x28\x03\x8A\xD0\x2B\x83\x64\x03\x03\x8B\xD9\x3F\x72\xD8\xB5\x89",
			"\xB3\xA6\x63\xFE\x3B\x38\xDB\xAE\x8D\x39\xBB\xD8\x35\x1B\x83\xD4\x08\x05\xA0\xA4\x8E\x68\x02\x57\xCF\x3F\x43\xD8\xEF\xBB\xEF\x4C\x00\xA2\x05\x5E\xD6\x8C\x41\xBF\x17\x99\x93\xD1\x0B\x49\xD9\xA0\x97\x12\xD2\x65\xFE\x4B\x54\xDB\x9E\x2A\xD0\x57\xD9\x64\x59\x96\xD2\x10\x0E\xD6\xA1\x68\x08\x0C\x65\xFD\x5C\x5E\xD9\x40\x0E\x24\xE1\x6A\x25\x03\x98\xDF\x7E\x65\xD9\xAB\xC9\x2A\x6A\x02\x2A\xD9\xE0\x64\x9B\xD0\x5A\xC3\x76\x70\xD9\x5F\x6C\x66\xED\xD1\x68\xD1\x9D\xD5\x10\x6C\xD9\x73\xD1\xAB\xC9\x03\x3A\xD9\xB6\x44\x9B\xD0\x5B\xE4\x59\x3E\x00\xA0\xDA\x20\x6C\xD9\xB6\xD6\x66\xD9\x0D\x86\xDA\x3C\x54\x9B\xDC\x5B\xFD\x5C\x48\x00\xA3\xDA\x5A\x6C\xD9\xC2\xD7\x2D\xCD\x04\x12\xDA\x48\x55\x5B\x49\x10\x2C\xD9\xEF\x5A\x14\x02\x1A\x0C\xD7\x99\xAE\x80\xDE\x6E\x9F\xDA\xB1\x41\xC4\xCF\xF0\xA9\x62\x54\x00\x90\xD8\x69\x02\x6F\xBB\x06\xA9\xD0\x00\x27\x9C\x03\x66\x15\x0A\x6A\xE7\x83\xAC\xD8\x5A\xC6\x48\xA9\x62\x58\x03\xAC\xD1\x10\x08\x01\x6C\xD6\xAD\xDB\x4E\xAF\x5B\x5A\x02\xAE\xD0\x00\x17\x01\xBD\xD8\x03\x84\x49\x69\x62\x5C\x02\xB0\xD6\x06\x05",
			"\xDB\xC7\xD9\x42\x0B\x08\x01\x85\xA4\xDA\xBF\x4E\x6A\xDE\x99\xAD\xC9\x34\xA3\x6E\x75\x01\xCC\xDB\x40\x0E\x6A\xE0\xCC\xCC\x85\x18\x02\x6C\xC4\x02\xB5\xDA\xB1\xD2\x04\xD0\x6B\x63\x02\xB0\xD2\x09\x19\xDB\xAE\xD1\x42\x04\xD8\xB9\xB9\x65\x02\xB0\xD1\x0A\x28\xDB\x3C\xAD\x1D\x59\x8A\x67\x01\xC2\xD8\x2C\x00\x6F\xD0\xA2\xD8\xD0\xF4\xA2\x6C\xFF\x02\xF7\xDA\xAB\xD6\x0B\xD3\xD8\x00\x03\x1A\x02\x6C\xCE\x03\xFD\xD9\x68\xC9\x01\xC2\xDB\xDD\x01\xC1\xD7\x1A\xE1\x83\x6F\x02\xB0\xDC\x0E\x02\x6F\xBF\x06\xAB\xD1\x4F\xC5\x44\x71\x02\xB0\xDC\x0F\x0A\xDC\x06\x05\x3E\xD1\xAA\x73\x01\xC2\xDB\x02\x07\xD4\x49\x15\xAE\xDA\x08\x91\x0E\xB5\x01\xC2\xD9\x06\x0F\x71\xD1\xDC\x29\x90\xB4\x67\x07\x02\xDB\x29\x03\xC7\xDD\x1B\x2E\xDA\xCA\xC6\x32\x92\x6C\xF8\x00\x2E\xDE\xAD\xDD\x0E\xC3\x64\x7B\x02\xB0\xD7\x04\x27\xDC\xB6\xD8\x3D\xC6\x4F\xBD\x01\xC2\xDB\x15\x05\x73\xE2\xDB\x02\x04\x49\xDF\x6E\x7F\x01\xCA\xDB\xD0\xDD\x6C\xE1\xC7\xD0\x69\x20\x02\x6C\xF5\x01\x3C\xDC\xD1\xD1\x10\x19\xBE\xD5\x92\xB0\xD5\x08\x11\xDD\x4B\xDF\x7B\xC9\x8A\x45\x02\xC2\xD9\x25",
			"\x08\x75\xDA\xDB\x40\xD7\xBE\x77\x08\x02\xDB\xA5\x03\xD7\xD9\x6E\xDF\xC4\xD0\x69\x22\x02\x6C\xF5\x02\x4A\xDC\xD8\xDD\x54\xE1\x83\x8B\x02\xB0\xD4\x0C\x2D\xDD\x67\xDC\xEF\xC9\x8A\x4D\x02\xC2\xDB\x34\x04\x77\xF1\xDB\x33\xC5\xF1\x92\x6C\xE2\x03\x7B\xDC\xBE\xDA\x68\x69\x62\x91\x02\xB0\xD1\x0F\x01\xDE\xAE\xDA\xFF\x9C\x1C\x93\x02\xC2\xD8\x00\x07\xBF\x7F\x06\x81\x46\x52\xBB\xEF\x55\x02\xC2\xD8\x04\x07\xBF\x7B\x06\x91\xDE\x54\xBB\xEF\x71\xA3\xE3\x5A\x07\x07\x79\xF6\x45\x9E\xD0\x6B\x89\x09\x02\xDB\x2C\x03\xFD\x6D\x1B\x19\xDE\x7B\xC3\xBB\x5B\x09\x02\xDB\x3B\x02\xE9\xD0\x7A\xD2\xDD\x9D\x99\x27\x02\x6C\xCA\x01\xAE\xDD\x42\x08\x7A\xC1\x04\xCF\xD8\xB4\x6F\x09\x11\xDB\x64\x5B\xED\xDF\xD6\x85\xCD\xC2\xD9\x16\x05\x7B\xC0\x46\x91\xC0\x6B\x82\x0A\x02\xDB\x68\x03\xE7\xD6\x7B\xC5\xD3\x55\xCE\xB0\xD6\x07\x03\xDF\x03\x06\xEF\xDB\x6E\xED\xCA\xF8\xA3\xB8\x55\x08\x10\xDF\x02\x06\xEF\xD6\x33\xF9\xB9\xA8\x02\xB0\xD4\x09\x18\xDF\x01\x06\xEF\xDE\x0A\xF9\xB9\xAA\x02\xB0\xD3\x0A\x20\xDF\xD1\x68\xD1\xCC\x1A\xAC\x02\xC2\xDA\x2C\x08\x7E\xFE\xDE",
			"\xE4\xD0\xC0\xDE\x0A\x02\xDB\xC1\x03\xFB\xD4\x0C\xDD\x9A\xB0\x02\xB0\xD0\x0D\x0F\xDE\xAF\xDF\x02\x30\xAD\x72\x02\xC2\xD8\x38\x06\x7F\xF5\xC6\x8E\xCE\xB0\xDF\x0E\x0A\xDF\xC4\xDC\x6F\xC3\xA7\x82\xDB\xFD\x00\xFF\xDB\x7C\xC7\xD4\xAC\x84\x2E\x02\x6C\xCD\x00\x2A\x73\xE9\xD8\x37\xF6\x93\xBA\x02\xB0\xDC\x01\x15\xE0\xFD\xDC\xEA\x9B\xEF\x7C\x02\xC2\xDB\x0A\x0A\xC2\x50\xDE\xD6\xC5\xA7\x9E\x0B\x2C\xDE\x1C\xE3\x03\xED\xDD\xAC\x86\xC0\x03\xEC\xD9\x82\xC9\xE0\x4C\xDF\xBE\x76\x90\xA3\x5B\x59\x03\x08\xED\x81\xE7\x83\xBB\xBA\xB0\xD9\x06\x36\xE0\x2A\xE2\xD6\xD0\xAD\x46\x03\xC2\xD9\x1E\x0C\x83\xF0\xE0\xF6\xB4\xB3\xB2\x6C\xC9\x02\x43\xE1\xF4\xD6\x54\xDD\x9A\xCA\x02\xB0\xD9\x09\x2F\xE0\x4A\xE3\xDB\xDC\x1A\x8C\x03\xC2\xD8\x2A\x00\x85\xD9\xDF\xE4\xAF\xBE\x7E\x0C\x02\xDB\xB7\x03\x15\xE1\x7E\xDA\xD5\xEF\x58\x34\x02\x6C\xC6\x03\x5E\xE1\xFA\xDA\x3C\xDD\x9A\xD2\x02\xB0\xD5\x0D\x25\xE1\xBE\xDE\xE2\xD9\xE7\x94\x03\xC2\xD8\x39\x09\x84\xC2\x04\x89\x02\xC7\x90\xAD\x56\x03\xC2\xD8\x3D\x0A\xC2\x7B\x06\x75\xE2\xC9\x99\x8A\x58\x03\xC2\xDA\x00\x04",
			"\xD5\x7C\xE1\xA1\xDE\x3D\x9A\x0D\x15\xDE\x54\x75\x6F\x0D\x87\xCE\x96\xFB\x78\x37\x02\x6C\xDF\x00\x89\xE0\x43\x0B\x88\xEE\xDD\xFB\x7A\x37\x02\x6C\xEE\x00\x91\xE1\x42\x03\x89\xF0\xC5\xAC\x84\x38\x02\x6C\xFD\x00\x99\xE2\x41\x0B\x89\xF7\xC5\xFB\x7A\x38\x02\x6C\xCC\x01\x83\xE2\x24\xEC\x7C\xF9\xB9\xE4\x02\xB0\xDA\x05\x21\xE2\x03\x07\x28\xEF\x09\xFB\x7B\xE6\x02\x0E\xE0\x8B\xF4\xE1\xA6\xC0\x6B\x88\x0E\x02\xDB\x78\x03\x2D\xE1\x10\x32\xE2\xE3\xDD\xAB\xCA\x0E\x02\xDB\x87\x02\x2F\xE0\x00\x32\xE2\xFF\xDA\xA2\xD0\x00\x2C\x03\xC2\xDA\x25\x06\x8C\xF2\xE2\xF1\xDE\x32\xEE\x0E\x24\xDD\xCF\xE3\xFD\xDF\x6E\x70\x03\xC2\xD8\x2D\x04\xD5\x7F\x06\xB2\xE3\xC4\xD4\x7B\x72\xDD\xD5\xE0\x01\xED\x69\xB4\x03\x79\xDD\x2A\xEA\x89\xC0\xD4\xCC\x86\x3D\x02\x6C\xE1\x03\xDB\xE2\x2A\xE0\x81\xCF\xCA\x86\xDD\x38\xEE\x50\xE1\x83\xFA\x01\xE3\xD1\xCB\x53\x15\xB2\xE3\xCD\xD1\xAA\x60\xA4\x08\x5F\x3D\xEC\x8D\xE5\xE0\xEF\x5A\x3F\x0F\x88\xF7\xE3\x8A\xE0\xED\xAD\x69\x92\x13\x88\x4E\x0B\x04\x90\xEE\xE3\x31\xE1\x38\x82\x00\x08\x06\x88\x4D\x0F\x0E\x8F\xCC\xE4\x0D",
			"\xB7\xBE\x74\x00\x10\xE4\x0C\x05\x13\x03\x91\xE7\xE3\xC9\xAD\x38\x86\x00\x18\xE4\x8B\x7B\x46\xE2\x8A\xE1\xDD\xE1\x80\x02\x00\x92\xCE\xB2\x22\xE5\x2C\xEB\x84\xC7\x5F\x27\xE7\x40\x0D\x07\x0B\xE4\x1C\xE7\x49\xB0\xAD\x4C\x00\x2D\xE6\x40\x0C\x08\x30\xE4\x23\xE7\x54\xDC\x1A\x8E\x00\x35\xE7\x74\x08\x93\xEA\xE4\x47\xA4\xB4\x60\x01\x3D\xE4\xF0\x5B\x4F\xE8\x8B\xE7\xE1\xEF\x5A\x04\x04\x94\xF9\x02\x46\xE7\x2F\xE7\x56\xF6\x93\x14\x00\x51\xE8\x0C\x29\xE4\x02\x04\x5F\x41\x93\xE1\x83\x16\x00\x62\x0C\x5C\xD6\xE5\x06\x07\xA0\x50\xAD\x57\x00\x5A\xE5\x2C\x49\x7B\xEF\xD5\xFB\x78\x06\x08\x18\x0E\xD9\xB8\xDC\xAA\xA0\xAD\x5D\x00\x88\x06\x02\xBA\x20\x63\xE5\x8E\xC9\xA7\x94\x02\x2D\xE5\x62\xE6\x12\xDA\x07\xB4\xE5\xFE\x48\x5C\xE1\x82\xA1\x83\x32\x00\x5E\xE4\x66\x7A\xE5\x26\xA0\x2C\x8E\x97\xFD\x5C\x80\xE4\x97\xAB\xEF\x40\x01\x83\xE7\xFB\x55\x98\xD9\xD6\xB1\x43\x11\x09\x98\xE0\x67\x85\xE7\x9C\xDF\x7E\x4E\x01\x8F\xE5\x5F\x65\x98\xF8\xD9\x64\x59\x15\x05\x99\xC5\x44\x85\xE5\x9F\xD7\x0B\xDC\x01\x9B\xE6\x6D\x45\x98\xC3\xDA\x3D\x5F\x18\x01\x9A",
			"\xEF\xE5\x55\xC3\x5B\x87\x9A\xFC\x54\x85\xE7\xA3\xDF\x7E\x71\x01\xAB\xE6\x6A\x55\x98\xD5\xDA\x00\xDC\x1E\x01\x9B\xC8\x55\x5E\xE6\x41\x05\x98\xC7\xDD\x61\xE6\xBF\x4A\xE0\x52\xDE\x08\xD4\x51\xE8\x0D\x37\xE3\xBB\x07\x6F\xEA\x79\xE1\x83\x82\x00\x51\xE6\x0E\x04\xE7\xBF\x41\x21\xED\x69\x84\x02\x44\xE4\x3D\x0D\x94\xC0\x00\xC6\xE7\x51\xE8\xA4\xBD\xE6\x64\x59\x75\xE1\x10\x39\xE6\xE1\x83\x21\x08\x9D\xFD\x5C\xDA\xE5\x6B\x90\xAD\x48\x02\x44\xE7\x00\x03\xCB\x7D\x06\xE1\xE6\xAB\xD9\x8D\x44\xE5\x12\x03\x79\xED\x9C\xCE\xDB\xA9\x60\x23\x0F\x9D\xEF\x5F\xE1\xE4\xB5\xD7\x0B\xCD\x02\x44\xE5\x08\x0E\x9E\xC9\x04\xE1\xE4\xB7\xD9\xE7\x8F\x02\x44\xE4\x0C\x03\xCB\x45\xE7\xAB\xE1\xAB\xC1\x09\x04\xE5\x3E\x03\x7E\xE6\x10\x21\xE7\xD3\xDF\x2D\xC3\x09\x04\xE5\x4D\x02\x82\xE3\x10\x21\xE7\xDB\xDD\xAB\xC5\x09\x04\xE5\x5C\x02\x84\xE2\x10\x21\xE7\xC1\xE3\x2D\xC7\x09\x04\xE5\x6B\x02\x86\xE2\x4E\xAA\xDF\xF6\x91\x26\x04\x94\xFA\x01\x22\xE8\x75\xE6\x70\xF6\x93\x9B\x00\x51\xE9\x08\x29\xE8\xE1\xE4\xD5\xC9\xE7\x9D\x02\x44\xE4\x26\x03\xCB\x7F\x06\xE1\xE6",
			"\x37\xEA\x20\x5F\x02\x44\xE4\x2A\x00\xA3\xE3\xCD\xAC\x85\x28\x04\x94\xF7\x02\x03\xEB\x7B\xE0\xF5\xBB\x7B\xA3\x00\x51\xE5\x0C\x37\xE8\x46\xEA\x78\x80\xAD\x65\x02\x44\xE5\x35\x0F\xA3\xE0\xAE\xE1\x83\x29\x04\x94\xE4\x03\x53\xE8\xDF\x7B\xC4\x44\xE5\xF3\x00\x93\xEC\x9F\xC0\xE4\x03\x67\x2A\x05\x9E\xFD\x73\xE8\xE6\x41\xEB\x53\xAC\xE7\x64\xE9\x93\xE9\xD0\xB3\xBA\xAF\x01\x7E\xED\xCF\x78\xE8\x32\xD4\x73\x81\x0B\x04\xE5\x31\x03\x9B\xEA\xA6\xC1\x04\xF0\xC5\xA8\x63\x0B\x04\xE5\x41\x02\x9D\xEF\xA5\xE7\xCE\xA1\x69\x2D\x04\x94\xD1\x01\x7E\xEB\x82\xEB\x92\xC2\x8A\x44\xE5\x18\x09\xA6\xFF\xE9\x32\xE5\xA1\xB4\x94\xF0\x01\x8B\xEA\xA1\xEA\x93\xFE\xB0\x44\xE7\x1F\x01\xA9\xD3\xE8\x60\xE3\x40\x6D\x0B\x04\xE5\x8E\x03\xA5\xEB\xA1\xFA\xC4\xAC\x87\x2F\x04\x94\xDD\x02\x9E\xEB\x88\xE1\x3D\xE6\x8A\x44\xE4\x2B\x05\xA8\xF6\xDD\x83\xC9\xD3\x58\x18\x07\xD9\x03\x3D\xEF\xC0\x00\x00\xD1\x91\x67\x59\xE1\x0B\x72\xEA\xF0\xCD\xA8\x6B\x0C\x36\xEA\xFE\x4A\xAC\xE2\x58\xCE\xB1\xBC\xE8\x99\x52\xAB\xD0\xD1\x79\xB9\x35\x01\xAC\xFD\x5C\xB2\xE8\x98\xDC\x1C\x9A",
			"\x03\xC7\xEB\x39\x63\x59\xEC\x86\xDF\x01\xB3\xE0\x9E\x72\xEA\x8C\xE6\xBF\x44\x0E\x12\xEB\x7D\x66\xAC\xE2\x99\xE0\x67\xE9\x00\xB6\xE5\x10\x72\xEA\x98\xE5\xCF\x5E\x0E\x1E\xEB\xB6\x46\xAC\xEE\x99\xC0\xDC\xF3\x00\xB9\xEA\x20\x72\xEA\xA4\xE7\xFB\x58\x0F\x2A\xEB\x3C\x56\xAC\xE9\x68\xF1\x42\xFD\x00\xBC\xEA\x5A\x72\xEA\xAE\xE4\x78\x62\x00\x0A\x06\x68\xE6\x2A\x54\x43\xE1\x6A\xA5\xA5\x71\xD5\x10\x75\x91\x64\xE5\x38\x8C\x00\x0A\x06\xB0\xEA\x56\xD4\xAB\xC0\xC6\xFC\xE9\x2C\x44\xB0\xF1\xE5\xEF\x58\x05\x0D\xB0\xFE\x4B\x0F\xEC\xA5\xC6\x4F\x99\x00\x13\xEC\x99\x55\xB1\xDA\xCA\x03\x66\x07\x09\xB1\xFD\x5C\x1B\xEC\x92\xC1\x0E\xB4\xA6\x02\xEE\x6D\x41\xB2\xE7\xD9\xCC\x84\x0A\x0F\xB1\xEF\x5F\x21\xED\xB5\xE4\x66\x6D\x00\x2B\xEC\x78\x61\xB2\xDB\xEB\x7D\x66\x0C\x01\xB3\xFD\x65\x21\xED\xB8\xEF\x7E\x77\x00\x37\xEF\xC0\xEA\x5A\xFB\x7B\x3C\x01\xCF\xE6\xB2\xE3\xD0\xCC\x85\x10\x02\xB4\xCA\x48\x21\xEF\xBC\xEE\x2F\x46\x01\x47\xEC\x4F\x51\xB2\xF9\xEB\x7D\x67\x12\x0D\xB4\xEA\x56\x21\xEC\x6D\xEA\x8C\xD0\x01\x53\xEC\x52\x57\x5A\x82\x04\x3A\xD3\xBB",
			"\x55\x05\x08\xEC\xB1\x43\xD6\xE1\x10\x0B\xEC\xA1\x68\x16\x09\xB5\xF8\x56\x62\xEC\x00\x09\xAB\xCC\x87\x5D\x03\xD9\xEF\x8E\x76\xE5\xFB\x7A\x18\x0E\xB6\xC3\x3C\x69\xEC\xB1\xED\x2A\xE7\x01\x73\xEF\x12\xEA\xAC\xF9\xB9\x6C\x01\xDE\xEE\x3A\xE6\xD9\x5C\x9E\xDF\xE8\x76\xF8\xC0\x49\xCA\xE0\xE1\x93\x8C\xAB\xFB\x7B\x1E\x06\xB8\xC5\x79\xA5\xD6\xB0\x6B\xB8\xC1\x04\x69\xEF\xB9\xEA\x8C\xC5\x02\x8F\xEC\x00\x09\xB6\xED\xEB\xE0\x66\x22\x05\xB9\xE9\xED\x4A\xEE\xC6\xEB\xB9\xDB\x2D\xAC\x84\x25\x0F\xB9\xD8\x5E\x25\xE9\xE5\xE8\xA1\x81\x04\x5D\xEF\x40\x6E\x09\x20\xED\xFE\x4B\xE9\xE3\xAB\xE9\x62\xA1\x02\xE9\xE0\x65\xEC\x86\xA6\x02\xEC\xE7\xFC\x94\x89\xB6\xEE\xF3\xB9\x58\xF9\xEE\xD4\xBC\xB4\x65\x0B\x3C\xEE\xDA\xBF\x21\x70\xBC\xE1\xBF\x22\x6F\xF0\xE6\xFE\xA6\x72\xC6\xEE\xCE\xE0\x9E\x49\x03\xC6\xEE\xE4\xE1\x0B\x4E\x03\xC6\xEC\xE6\xED\x97\x53\x03\xC6\xED\xE7\xED\x73\x58\x03\xC6\xEC\xD4\xE5\x10\x5D\x03\xC6\xEE\xD5\xE1\x0B\x62\x03\x95\xED\x58\xD9\xBA\xE1\x6A\xE7\x00\xEB\xE4\x66\x61\xD5\x64\xEC\x73\x8A\x0E\x21\xEF\xB3\xED\x27\xBC\xBE\xF7\xEE",
			"\xD0\x68\x3D\x0F\xBE\xFA\xEE\x2D\xC7\xFC\xED\xBB\xFB\x7B\xFE\x02\xFD\xE1\xBC\xE4\xB3\x8C\x05\xBF\xE1\x56\xEE\xEC\x3D\x5C\x02\x0D\xBF\xF1\x42\x61\xD4\xCD\xE5\x10\x4D\x00\x03\xF2\xBF\x41\x56\xCA\xEF\x7D\x66\x04\x09\xC0\xE7\xEF\x3F\xED\x38\x88\xA2\xA5\xEC\x0A\x49\x58\xD2\xBD\xC5\x44\x1C\x03\x03\xFD\x73\x61\xD5\xD6\xEC\xFF\x6A\xC1\xEF\x5F\x61\xD6\xF6\xE6\x1B\x66\x00\x1F\xF0\x78\x61\x56\xDE\xEF\x4C\x75\x09\xFD\x97\x53\x02\x76\xE3\xBE\x70\x03\x0C\x06\x88\x4C\x2F\x0D\xCF\x5E\x07\x2C\xF2\x1F\xE5\xB0\xB0\xF0\x13\xB3\x0C\xFC\x10\x35\xF0\x2F\x9D\x2A\x64\x03\x38\xF0\x09\x06\x35\x0D\xCF\x7B\x06\x3C\xF2\x29\xDD\x69\xB6\x00\x40\xF2\x41\x04\x0E\x03\xF1\x3B\xF2\xAD\xDF\x6E\x78\x00\x49\xF0\x6E\x3C\xC4\xC9\x04\x45\xF0\x27\xE6\x4F\xBA\x00\x51\xF3\x40\x01\xD2\x44\xF1\x0C\x07\x25\x09\x8A\x7C\x00\x0E\xAE\xBF\x45\xC5\xE4\xE2\xE1\x81\x0F\x09\xC5\xFA\x06\x21\x74\x0D\xF5\xA0\xF7\xC2\x3F\x03\x19\xF0\x00\x1B\x00\x5B\xF1\x13\xFA\x6E\xD0\x83\x6E\xF1\x0A\x01\xC7\xD4\xF1\xB9\xE2\xAC\x9E\xC6\xF7\x00\x77\xF2\x41\x03\xC6\xC0\x00\x1D\xE8\xC0\xD5",
			"\x04\x2E\xF1\x45\x01\x1F\xF3\x10\x3F\xF1\xC9\xE1\x63\xEE\xC6\xD3\x01\x86\xF2\x40\x0F\xC7\xD1\xE3\xB1\x41\x12\x0E\xC6\xE1\x01\x8D\xF1\x40\x0F\xC7\xF2\xE8\xAD\xCB\x12\x0E\xC6\xEF\x01\x21\x75\x6F\x0F\xC7\xFA\xE8\x3C\x55\x13\x0E\xC6\xFE\x01\x95\xF0\x00\x0F\xC7\xDA\xDC\xCC\x87\x13\x0E\xC6\xCC\x02\x69\xF2\x1C\xF7\xA4\xE1\x83\x51\x02\x1B\xF9\x09\x1D\xF2\xAE\xF2\x93\xEB\xEF\x53\x01\x6E\xF0\x2A\x05\xCA\xFF\xF1\x31\xDF\x40\x65\x05\x2E\xF1\xB6\x03\x2E\xFF\x37\xC4\xB8\x6E\xF0\x31\x04\xCB\xF8\xF1\x86\xCC\x6B\x89\x05\x2E\xF1\xD3\x02\x30\xFC\x1D\xD2\xB8\x6E\xF1\x38\x0E\xCC\xCD\xE4\x19\xBA\x1B\xFF\x0E\x07\xF3\x7E\xF1\x9C\xE9\xE7\x9F\x01\x6E\xF2\x3F\x08\xCD\xC7\xF2\x39\xD4\x6B\x81\x06\x2E\xF1\x0D\x01\x58\x79\x47\x3F\xF1\xED\x9B\x40\x63\x06\x2E\xF1\x1C\x02\x39\xF1\x4D\x3F\xF1\x69\xEF\xBB\x55\x06\x2E\xF1\x2B\x02\x3B\xF9\x54\x3F\xF1\xAE\xEF\xBB\x57\x06\x2E\xF1\x39\x02\x3D\xFC\xC5\xD3\xEA\x9D\x99\x1A\x0E\xC6\xC7\x01\xFE\xF1\x2D\xFF\x4A\x69\x62\x6B\x02\x1B\xF5\x05\x05\xF4\xC8\xF1\x86\xCB\xEF\x6D\x01\x6E\xF3\x18\x0C\xD0\xD9\xF3\xA7",
			"\xEA\x3D\x9F\x06\x2E\xF1\x71\x02\x3D\xFD\x1B\x14\x5A\x61\xB8\xD7\x91\xC6\xE4\x59\x1C\xF7\x0F\xC4\xA9\x5F\xF4\x3D\x5D\x25\x0D\xC2\xE1\x83\x73\x02\x1B\xF0\x08\x36\xF3\xDE\x06\x49\xF6\xC3\xFB\x7B\x75\x02\x1B\xFD\x08\x2C\xF4\x0C\x06\x4B\xFD\xC3\xEA\xDC\x6E\xF2\x26\x03\xD1\xC3\x04\x36\xF6\x11\xFA\x4C\xB9\xF2\x3B\xF6\x40\x0D\xD3\xF5\xDD\xAC\x87\x1E\x00\xCC\xC1\xF5\xED\x42\x25\xAD\x69\xBD\x01\xC5\xF0\x52\xF0\x00\x03\xF5\x64\xF0\x6B\x8F\x07\x2E\xF1\xD2\x00\x4D\xF9\x10\x10\xF5\x54\xC1\xD3\xDE\xC6\xDF\x03\x4E\xF4\x56\xFD\xA0\xC0\xDC\x83\x02\x1B\xFD\x0E\x1D\xF5\x79\xF1\xA7\x95\x08\x2E\xF1\xFB\x00\x59\xFD\x33\xDD\xE7\x6E\xF1\x02\x0C\x79\x7B\x06\x58\xF5\x22\xFE\x2F\x49\x02\x6E\xF3\x05\x0F\xD6\xF5\xF4\x2B\xE9\xA7\x9B\x08\x2E\xF1\x25\x03\x5D\xF7\xD5\xD6\xE3\x03\x65\x23\x0E\xC6\xF3\x00\x9C\x5D\x6F\x08\xD5\xE0\xF2\x54\xEE\x1B\xF2\x04\x3E\xF5\x1D\xF6\x38\xEF\x6E\x51\x02\x6E\xF0\x14\x0C\x79\x6D\xF4\xE8\xE1\x9E\xB3\x09\x2E\xF1\x5D\x01\x61\xF8\xD7\xEF\xE3\x9D\x99\x25\x0E\xC6\xEC\x01\x8C\xF4\x4F\xF7\x81\xDD\x9A\x97\x02\x1B\xFA\x07",
			"\x21\xF6\x42\xF7\x30\xFD\x69\x99\x02\x6E\xF0\x22\x0A\xD9\xFF\xF5\xC9\xF0\x8B\xEE\xC6\xD7\x02\xA8\xF5\x52\xFF\xCC\xC4\xC1\x6E\xF1\x29\x05\xDB\xCF\xF5\x93\xCE\x3D\x9F\x09\x2E\xF1\xB3\x03\x6B\xFD\xD8\xDD\x9B\xB3\xB9\x28\x0E\xC6\xC2\x03\xC2\xF6\x68\xFD\x91\xDC\x94\x6E\xF1\x34\x09\xDC\xE9\xF6\x80\xE8\x73\x85\x0A\x2E\xF1\xE0\x03\x73\xF6\xDB\xC3\xEE\x55\xEA\x35\xFB\xDB\xD8\xF5\xF9\xF3\x40\x69\x0A\x2E\xF1\xFD\x03\x76\xF9\x85\xE1\x83\xAB\x02\x1B\xFB\x00\x1B\x5F\x70\xF5\xA6\xE1\xAA\x6D\x02\x6E\xF1\x06\x08\xDE\xDB\xF6\x0E\xF5\x38\x8F\x0A\x2E\xF1\x27\x03\x7B\xF0\xDB\xD5\xA5\xD0\x68\xD8\xA3\x6E\x75\x00\xDB\x5D\x6F\x0D\x69\x43\xF7\xE1\x83\x2C\x04\xD2\xEF\x5F\xFF\xF6\x48\xF0\xAD\x74\x02\x03\xF8\x78\x6E\xC5\xED\xEA\x8F\xD6\x0A\xF5\x10\x4B\xF8\x89\xC8\x6B\x8A\x0B\x0C\x06\x6E\xE4\x4F\x50\xE1\xD0\xEC\x03\x65\x30\x04\xE1\xF1\x42\x17\xFA\xC5\xED\x69\x88\x03\x1B\xFA\xBF\x4D\xE1\xDC\xEC\xA1\x6B\x33\x01\xE2\xE4\x59\x23\xFA\xC8\xEC\x1A\x96\x03\x27\xF9\xCF\x59\xE2\xE8\xEC\x79\xB9\x37\x0D\xE2\xEF\x5F\x29\xF8\x00\xFF\x7E\x64\x03\x33\xFA",
			"\x82\xFC\xAB\x36\x93\xEB\x01\x8E\xFD\x97\x69\xF8\x0C\xF1\x41\x42\x0F\x3E\xF8\x0F\xF9\x04\xFC\x1A\xB9\x03\x44\xFA\xB9\x64\xB4\xF9\xB9\xB5\x11\x85\xFA\x5A\x69\xF8\x1D\xF0\x78\x67\x00\x0E\x06\x4E\xF8\x52\x59\xE2\xE2\xF0\x0A\x4A\x03\x04\xE5\xDC\xF8\xFF\xE8\x73\x85\x01\x1B\xF9\xFE\x49\xA9\x50\x49\xC3\x64\x1C\x02\x63\x08\x38\x44\x01\xDB\x5E\x77\x02\xE6\xD8\xD2\x1D\xEE\x99\xFF\xA5\x69\xF9\x0C\x07\x9A\xF9\x15\xF6\x93\x20\x02\x9B\xFB\x8B\xB6\xF7\x06\x06\x9C\xF9\x7A\xC3\x64\x22\x02\x9D\xF6\xB1\xB8\xF9\x03\x06\x9E\xFC\x77\xEC\x86\x24\x02\x9F\xF8\x04\x40\xFA\x02\x06\xA0\xFF\x7B\xEC\x86\x26\x02\xA1\xF9\x7D\xC8\xFA\x01\x06\xA2\xFE\x9F\xED\xCA\x28\x02\xA3\xF1\x10\x16\x02\x70\xF9\x42\x0A\xE8\xE8\xCC\x03\x66\x0A\x06\xE9\xC0\x00\xA3\x00\xA4\xF0\x00\x0A\xFA\x5F\xF6\x32\xEC\x02\x1F\xFA\xB1\x02\xA8\xFA\xE8\xD5\xE8\xB7\xC2\x0B\x0F\xE9\xFF\x02\xAA\xF8\x65\xC6\x4F\x9D\xAE\xE3\x59\x33\x01\xEB\xEE\xAD\xA9\x62\x0C\x0F\xE9\xDB\x03\xB7\xFA\xDD\xAE\xC3\xDF\xFA\xE9\x01\xAF\xFD\xB7\x90\x6B\x36\x03\xA7\xF7\x0F\x3D\xF7\x71\xFB\xE0\xA3\x90\x78",
			"\x00\x9F\xFA\x01\x0A\x64\x3B\x06\x8A\xF8\x2A\xF9\xE7\xBA\x00\x9F\xF8\x05\x0A\x64\x2A\xF9\x95\xF5\xAB\xCC\x03\x1F\xFA\x21\x02\x92\x1D\x1B\x0A\xFA\x99\xAF\xBB\x53\xBA\xA3\x5B\x30\x03\xB3\xF9\xEC\xD4\xE9\xAC\x84\x10\x0F\xE9\xFE\x00\xE6\xFA\xA6\xFA\xDA\xEF\x5B\x42\x03\xA7\xFC\x04\x1E\xFB\xE7\xF8\x47\xDC\x1A\x84\x01\x9F\xFB\x16\x0D\xEE\xF9\xF9\x66\xEB\x40\x66\x04\x1F\xFA\x69\x03\xBE\xF1\xE8\xFD\xF6\x8A\xA7\xA7\xF7\x07\x34\xFB\xEE\xFA\xF0\xA0\xAD\x4A\x01\x9F\xFA\x21\x08\xF0\xFC\xFB\xCB\xF6\x3D\x9A\xBA\xAB\xA7\x0F\xFF\xC0\xF1\xDD\xF9\xB9\x4E\x03\xA7\xF4\x0A\x15\xFC\x89\xFB\xA1\xE1\x2C\xDF\xFA\xB3\x02\xC0\xFD\xF1\xD2\xE1\xF6\x92\x14\x0F\xE9\xC1\x03\x22\xFD\xA4\xF3\xDE\xEC\x86\x54\x03\xA7\xFF\x0C\x29\xFC\xA3\xFA\x7A\xFC\x1C\x96\x01\x9F\xF9\x37\x00\xF3\xCA\xFA\x61\xD7\xBB\x58\x05\x1F\xFA\xEB\x03\xCD\xFF\x94\xDD\x9A\x5A\x03\xA7\xF9\x0F\x1C\xFC\x01\x07\x63\x49\x10\x00\x5B\xFB\x78\x17\x0E\x18\x0C\xD7\x46\xFE\x41\x01\xE1\x51\x9C\x4B\xFD\x2C\x4F\xF4\xDD\x85\xD0\x6A\x17\x0F\xE9\xC8\x00\xDD\x2A\x77\x03\xF5\xE5\x85\xA9\x60\x18",
			"\x0F\xE9\xD5\x00\x59\xFC\x43\x0B\xF5\xC1\x04\x30\x9D\xA8\x62\x06\x1F\xFA\x22\x01\xB7\x2B\x1B\x23\xFD\xE2\xE7\xBE\x74\x06\x1F\xFA\x30\x02\xDA\xF2\xF6\xCE\xF1\xBE\x77\xBA\xF2\xF7\xC9\x04\x6C\xFE\x7D\xE0\x70\xE8\x01\xF2\xFB\xDD\xFE\xF4\xC5\xDF\xF6\x92\x1A\x0F\xE9\xDA\x01\x61\xFC\xDE\xFB\xC6\xC0\xDC\x6C\x03\xA7\xF7\x06\x3E\xFD\x03\x04\xDB\xF5\xEA\xF1\x42\x6E\x03\xA7\xF5\x07\x0C\xFE\xAD\x59\x59\xFF\x6E\x70\x01\x9F\xFB\x20\x04\xF9\xC1\x04\x6C\xFD\x20\xFA\x8C\xF2\x01\x9F\xF9\x24\x0B\xF9\xC0\x00\x6C\xFE\x5C\xF4\x66\x74\x01\x9F\xFB\x27\x03\xFA\xEC\xFD\x90\xF2\xBF\x46\x07\x1F\xFA\xAD\x03\xEA\xF0\xD8\xE1\x6A\x78\x03\xA7\xFB\x0B\x1D\x2B\xBD\x04\xDB\xF8\xD8\xC8\x55\x7A\x03\xA7\xFA\x0C\x32\xFE\x8E\xF6\x3E\xDF\xE9\xD8\x03\x85\xFF\xDF\xFA\x80\xF6\x93\x7E\x03\xA7\xF5\x0E\x38\xFE\x73\xFC\x67\xF2\xAC\x5F\xFA\xF4\x00\xF0\xF3\x8F\xEC\x86\x82\x03\xA7\xF2\x00\x14\x2C\x6B\xFF\xBB\xF3\x90\x44\x02\x9F\xF8\x04\x04\xB1\x39\xFE\x60\xE9\xA8\x66\xBC\xA3\x5B\x1F\x00\xF6\xFD\xFC\xEB\xE0\xF6\x90\x22\x0F\xE9\xED\x00\xE6\xFE\xE1\xF5\xD0\xA1\x83",
			"\x8A\x03\xA7\xFB\x03\x1F\xFF\xE7\xFD\x45\xE1\x0E\x8C\x02\x9F\xFA\x12\x04\xFF\xEE\xFF\x11\xC6\x3D\x9E\x08\x1F\xFA\x59\x01\xFD\x7E\xF1\x7A\xFA\x4B\x1F\x5F\xF4\x68\x01\x02\x80\x8D\x7E\x8F\x7C\x73\x42\x12\x06\xF0\x6D\xFF\x43\x00\xA5\x62\xD0\x34\x4A\x03\xA7\x7D\x10\x0E\x00\x89\x00\x80\xF4\x6F\x2D\x96\x01\x4F\x7F\x24\x05\x02\x85\xF9\x61\xCA\x7B\x7B\x18\x01\x9F\x7D\x50\x00\x07\x84\xF3\x70\xAA\x76\x27\x5A\x02\x1F\x7D\xAF\x01\x11\x80\xE9\x7F\xE7\x7F\x6E\x3C\x04\x1F\xFA\x3D\x01\x08\x80\xD7\x00\x43\x07\xD6\x2E\x33\x71\xFA\x7E\x4B\x05\x04\x48\x7F\x70\x43\x27\x06\x06\x84\x66\x34\x01\x94\xFD\x7B\x3D\xA0\x01\x4F\x7C\x33\x04\x62\x1E\x1D\x1E\x01\x9C\xFD\x06\x3D\x9F\x7D\x6C\x00\x11\x83\x06\x8E\x9C\x6F\xB7\x13\xAF\x63\x2D\xE6\x00\x15\x82\x11\x81\xAC\x5D\x69\x46\x05\x10\xFF\x52\x80\x74\x7F\x50\x34\x2A\x06\xFA\x75\xAF\x1B\x0D\x13\x01\x8B\x7D\xF6\x48\x55\x01\xF7\x7D\x0B\x8C\x04\x9D\x44\x7B\x7B\x2C\x01\x9F\x7C\x0F\x01\xBD\x15\x08\x87\xF8\x6A\xC6\x6E\x02\x1F\x7D\x2B\x00\x32\x81\xCE\x04\x99\x68\x7F\x7F\xF4\x79\x00\x72\x80\x26\x22\xCB",
			"\x7F\x40\x32\x16\x0F\xE9\x67\x02\x38\x01\x83\x02\x5F\x80\xCF\x7D\x2C\x24\x16\x0F\xE9\x75\x02\x3F\x01\xB9\x69\x24\x75\x4E\x4E\x2D\x07\xD3\x73\x06\x07\x04\xB6\x5A\x79\x7A\x81\x39\x4F\x7D\x1C\x06\x11\x80\x00\x1F\x02\x98\xF2\x37\x61\xBA\x01\x4F\x7F\x1F\x05\x5E\x1D\x1B\x1F\x02\xBB\xFE\x38\x2B\xBC\x01\x4F\x7E\x23\x04\x12\x8F\x05\x92\xF6\x6D\xCA\x3E\x01\x9F\x7C\x4E\x03\x1A\x85\x0C\x8F\xCA\x6C\xC1\x5F\xFA\x29\x01\x9C\x80\x56\x82\x2D\x79\x1C\x42\x0C\x1F\xF4\x78\x02\x24\x81\xA3\x7B\x77\x2C\x31\x07\xD3\x76\x0C\x18\x05\x95\xD4\x4B\x67\x9F\x7C\x6A\x01\x2C\x83\x0E\x81\xDB\x7F\xF0\x5F\xFA\x63\x01\xBE\x80\xF4\x7C\x13\x77\xD3\x71\x0F\x09\x06\x82\xBC\x61\x41\xCC\x01\x4F\x7F\x3F\x03\x18\x89\x07\x8A\xF8\x5A\xE1\x1F\x7D\x0E\x01\x31\x19\x27\x81\x9C\x76\x4F\x50\x06\x1F\xFA\x1D\x00\xDA\x80\x59\x82\x40\x01\x9D\x71\xAA\x32\x06\x1F\xFA\x2C\x00\xE1\x80\x62\x80\x76\x7C\x35\x44\x0D\x12\xFF\x63\x31\x5E\x80\xB5\x67\xFB\x67\xA7\x79\x09\x0F\x0E\x82\x07\xA8\x88\x50\x35\xD8\x01\x4F\x7F\x15\x05\x1E\x8A\x0E\x9D\xBB\x59\x97\x1F\x7D\x65\x00\x7E\x81",
			"\x35\x81\xBE\x7C\x1A\x5C\x06\x1F\xFA\x73\x00\x02\x82\x40\x80\x0B\x83\x20\x3E\x0D\x1F\xF4\x41\x02\x69\x81\x06\x02\xCC\x23\x40\x85\x8C\x5C\x03\x98\xE1\x3D\x0C\x29\x31\xE1\x01\x8A\x83\xFB\x29\x07\x8C\xB5\x69\xC5\x22\x03\x0E\x03\xC4\x38\xDB\x20\x47\x83\x6C\x79\x8A\x2A\x07\x0E\x06\x1B\x24\x22\x83\xF6\x77\x38\x77\x24\x81\x0B\x23\x09\x8D\x29\x79\x50\x2C\x82\x7F\x26\x4B\x86\x6E\x77\x0B\x68\x63\x58\x0B\x05\x22\x2E\x83\xBD\x75\xAB\x62\x02\x00\x19\x08\x09\xBF\x5A\x4F\x75\xF6\x48\x0E\x01\x4F\x85\x25\x89\x5F\x43\xC8\x26\x00\x43\x82\x32\x83\x1D\x7D\xA7\x48\x06\x08\x14\x84\xB3\x2E\x04\xC1\x7C\xB6\x22\x1D\x01\x53\x85\xE7\x2E\x12\x8E\xDE\x7E\x4B\x44\x00\x53\x83\x8D\x83\x92\x7D\x55\x6E\x04\x19\x0A\xA0\x67\x2E\x82\x51\x7C\xC6\x3A\x57\x85\x2F\x3E\x12\x98\xF2\x7C\x54\x62\x00\x63\x82\x9C\x81\x97\x7C\x6F\x79\x16\x96\x8D\x2A\x12\x7B\x09\xD0\x34\x3B\x00\x64\x04\xB9\x68\x6C\x20\xCE\x6C\x86\x77\x00\x90\x02\xC4\x24\x24\x03\x8C\x1E\x1D\x15\x0B\x87\xE7\x2C\x43\x79\x01\xBC\x83\xCE\x04\x2F\x8C\x10\x1E\x0B\x9A\xB5\x09\x77\x82\x83\x84\x02\x2A",
			"\x01\x21\x82\x10\x06\x0C\x94\x01\xEF\x2D\x7D\x01\xC4\x82\x41\x00\x17\x0C\x18\x83\x27\x19\x01\xCC\x43\x7F\x00\xC9\x83\x40\x06\x18\x05\x19\x80\x00\x0E\x06\xE0\x80\x9D\x4D\x40\x02\x66\x82\x20\x04\x0D\x1D\x0C\x9F\x06\x93\x7D\xB7\x60\x57\x5B\xB8\x2A\x1C\x04\x18\x89\x08\x1F\x06\x9C\x7D\xA1\x35\x42\x03\x68\x81\x20\x0F\x0E\x06\x0D\xB4\x01\xE0\x65\xB3\x82\x48\x1E\x6D\x82\x9A\x6C\x1A\x49\x04\x39\x06\x8B\x00\x67\x19\xDD\x03\x67\x82\x10\x89\x97\x79\x0D\x99\x00\x41\x83\x85\x83\x44\x83\xBB\x2D\x11\x09\x1B\x87\x01\x08\x07\xAE\x83\x90\x81\x81\x33\x23\x01\x37\x85\x03\x0F\x0E\x82\x45\x33\x7F\xCC\x42\x5B\x5B\xB8\x2B\x08\x07\xC6\x1D\x0D\x1F\x06\x9F\x81\xCF\x1F\x49\x01\x6E\x82\x0A\x06\x1D\x86\xA6\x00\xE9\x76\x49\x95\x01\xDC\x80\x18\x07\x8C\x1D\x17\x99\xF6\x5E\xE8\x39\x83\x6D\x01\xEE\x81\x72\x86\xF9\x73\x90\x39\x04\x39\x06\xFC\x00\xE5\x83\xC6\x81\x2E\x83\x20\x3B\x09\x19\x0D\x8A\x02\x79\x83\x96\x83\x5F\x81\xEC\x69\x37\x88\x09\x12\x0F\x90\x07\xC5\x81\xEF\x2C\x5F\x5B\xB8\x2F\x14\x00\x20\x9E\x0C\xBD\xFB\x21\x35\xA1\x01\xDC\x81\x2D\x05",
			"\x41\x8F\x19\x8C\xA9\x4A\xC1\x39\x83\xC3\x00\x03\x87\x75\x86\x1A\x81\x0E\x45\x05\x39\x06\xD2\x01\x1A\x84\xF3\x81\xC4\x7D\xD3\x47\x0A\x19\x0D\xA1\x03\x21\x84\xFA\x83\x8B\x7D\xAB\x61\x15\x09\x1B\x90\x07\x28\x08\x81\x84\xEB\x80\x7B\x4B\x2A\x01\x37\x8F\x0F\x14\x10\xB1\x03\xEB\x7B\xB9\x83\x06\x00\xCA\x12\x38\x8B\xF2\x76\x27\x6F\x02\x39\x83\x1B\x01\x1D\x87\x7C\x83\x78\x6D\x69\x51\x05\x39\x06\xA9\x00\x42\x85\x03\x84\x41\x86\x9E\x43\x0B\x19\x0D\xB7\x00\x49\x84\x1B\x84\xFC\x79\x56\x49\x37\x85\x04\x08\x59\x3D\x06\x1E\x23\x06\x02\x71\x2C\x58\x4B\x2E\x81\x0B\x38\x12\x90\x45\x29\x31\xB8\x00\x2E\x86\xBF\x21\xDA\x2F\x03\x81\x07\x79\x02\x39\x83\x54\x00\x94\x16\x77\x04\x4C\x87\x04\x9B\xF7\x0B\xB3\x63\x2D\x61\x00\x35\x86\xC6\x0D\xEC\x7C\x1C\x5D\x05\x39\x06\xEE\x00\x50\x85\x2F\x85\x5E\x4B\xDF\x3F\x0B\x17\x0F\xB9\x09\x82\x02\x6C\x85\x41\x7E\x3D\x49\x18\x0E\x1F\x9F\x13\x81\x04\x01\x85\xA0\x83\xA6\x2C\x81\x86\x50\x80\x00\x08\x14\xA8\x06\x80\x6E\xC5\x01\xDC\x82\x29\x02\x4E\x8D\x6C\x0D\x03\xB1\x42\x47\x01\xB9\x83\x59\x00\xA3\x80\x51",
			"\x8F\xF8\x7E\x97\x09\x03\x39\x83\xC1\x01\x4D\x86\x1E\x82\x57\x79\x1B\x8F\x06\x22\x0A\xEB\x7A\xAC\x43\x66\x01\x6E\x85\x1B\x07\x2A\x8B\xF2\x29\x62\x4F\x01\xB9\x83\x75\x01\xAB\x83\x20\x0D\xFA\x64\xB3\x11\x03\x39\x83\xF9\x01\x59\x87\x9F\x42\xB8\x49\x1B\x87\x00\x00\x38\x3D\x03\x88\x84\xF0\x81\xCF\x31\x37\x86\x01\x00\x70\x3B\x06\x08\x85\xA6\x81\x5B\x63\x35\x01\x37\x84\x02\x00\x70\x2B\x09\xEE\x83\x00\x6F\x6C\x01\x6E\x81\x06\x0F\x2B\x9A\x38\x21\xFB\x03\x32\xDB\x01\xDC\x80\x10\x06\x58\x8A\x71\x1D\xE5\x61\x6A\x5D\x01\xB9\x82\x27\x00\xB7\x85\x52\x82\x20\x8F\xB7\x1F\x03\x39\x83\x5C\x01\x6A\x84\xB9\x86\xDE\x7F\xAA\x59\x0D\xAB\x01\x63\x85\x06\x02\x44\x86\xD1\x6B\x20\x33\x0E\x19\x0D\xB9\x01\x70\x85\x7A\x84\x6A\x7A\x3D\x48\x9C\x53\x6E\x27\x04\x2A\x0B\xF1\x85\xDA\x79\x56\x67\x39\x01\x37\x86\x09\x1F\x17\xB9\x0B\xBE\x70\x86\x3F\xDC\x81\x29\x06\x60\x80\x28\x84\xC9\x7D\xC3\x39\x83\xB4\x00\x86\x87\xA1\x82\x01\x89\xE7\x4D\x07\x18\x08\xF8\x85\x0D\x86\x92\x7F\x42\x61\x37\x81\x0D\x18\x18\x93\x0C\x97\x80\x03\x33\x78\x01\x6E\x87\x1B\x0E",
			"\x31\x8D\x14\xB2\xFC\x79\x5C\xF3\x01\xDC\x81\x3B\x05\x64\x88\x28\x99\xF9\x73\xB2\x39\x83\xFB\x00\x96\x87\x42\x81\x54\x37\x0F\x19\x0D\x89\x00\x65\x1B\xBD\x03\xD1\x22\x41\x03\xDB\x24\xAC\x42\x13\xA4\x59\x3A\x86\x03\x02\x2D\x84\x3D\x76\x67\x8D\x73\x3C\x19\x82\x04\x2F\x4C\x9D\x4D\x7D\x01\x6E\x80\x03\x05\xDE\x1E\x0E\x06\x0D\x81\x02\xB0\x6D\x50\x35\x3F\x01\x37\x85\x02\x0D\x1A\xAE\x13\x4D\x80\x03\x33\x7F\x01\x6E\x82\x06\x05\xDE\x1B\x0D\x0F\x0D\xED\x7E\xE1\x41\x00\x02\x74\x00\x71\x20\x04\x1D\x1A\x97\x0D\xB0\x6F\xEF\x2D\x01\x03\xD8\x84\x21\x0E\x04\x06\x1B\xB1\x13\x4A\x7A\xE5\x3F\xB5\x85\x42\x04\x0B\x0E\x36\x9B\x19\x80\xFE\x1D\x4D\x07\x00\xB9\x84\x01\x5E\x6A\x8F\x36\x97\x81\x77\xB3\x7A\x86\x26\x65\xBA\x87\x40\x07\x6B\x8D\x29\x84\xB3\x0B\x00\x00\x87\x02\x03\x42\x02\xE0\x82\x20\x0F\x35\x8C\xF5\x40\xDC\x0D\x00\x88\x86\x4B\x7B\xE2\x81\x20\x0F\x35\x84\x0E\xA4\x59\x0F\x00\x91\x86\x00\x01\x28\x03\x72\x8C\x15\x2A\x0E\x83\x64\x11\x00\x99\x87\x57\x00\xE7\x87\x6B\x85\x2B\x9D\xB9\x13\x00\x19\x87\xBD\x01\xD1\x84\x76\x81\xCF\x55\x01",
			"\x19\x1C\x8B\x03\x38\x86\x67\x86\xFF\x6F\x66\x61\x73\x8A\x0D\x0A\x1D\x81\xFF\x21\x35\x19\x01\xCC\x84\x3A\x04\x6F\x86\x37\x87\xFE\x5D\x9A\x1B\x00\x99\x87\x7A\x00\xEC\x85\x6F\x81\x37\x63\x57\x59\x0E\x84\x00\x32\x16\xAF\x87\x7E\x81\x54\x3B\xCF\x44\xB9\x09\x0F\xB1\x87\x1E\x71\xDE\x61\xE6\x80\x04\x02\xB3\x1D\x0D\x1F\x0D\xBE\x6E\x9D\x4D\x11\x01\xE6\x87\x05\x0F\x3C\x84\x1E\x83\x04\x73\x85\x68\x6D\xCC\x85\x0F\x05\x7B\x8D\x3B\x9A\x17\x9D\x9A\x27\x00\x99\x87\x25\x01\xF5\x80\x7A\x88\x83\x70\xD6\x29\x00\x19\x87\x5A\x01\xF5\x86\xF7\x83\xF9\x40\xD7\x59\x1C\xA9\x01\x72\x87\xE5\x87\x22\x73\x08\x49\x73\x88\x07\x18\x1F\x83\x0E\x94\x86\xAD\x65\x17\x01\xE6\x87\x10\x04\x3E\x9F\x1F\x9A\x0C\xF8\x4C\x99\x87\x4A\x01\x01\x8C\x71\x8D\x23\x9C\x7E\x59\x0E\xA3\x01\x0B\x88\xCA\x87\xC9\x85\x55\x65\x03\x19\x1C\xB1\x02\x11\x88\x9D\x86\xA4\x73\x40\x37\x06\x09\x39\x9F\x05\x18\x10\xDF\x86\x6E\x70\x3F\x6D\xE6\x85\x19\x0E\x3F\x82\x08\x28\x46\x06\x88\xFB\x3C\x85\x5B\xA6\x52\xB5\x27\x42\x82\x08\x02\x0D\xAC\x43\x3C\x00\xE9\x00\x73\x6F\x85\x88\xBA\x69",
			"\xC5\x3D\x00\x52\x03\x2C\x64\xDB\x20\x0D\x8F\x75\x70\xAD\x26\x02\x12\x07\x12\x6C\x03\x1F\x1D\x8B\xDA\x71\xCF\x51\x05\x1F\x21\xB1\x42\x3B\x88\xBF\x75\x3C\x5C\x17\x06\x88\x8E\x2F\x3B\x21\xB4\x04\x80\x6E\x67\x00\x26\x88\x99\x2B\x87\x8A\x13\x97\x85\x72\x01\x52\x88\x3D\x2F\x1D\x88\x8C\x7D\x55\x6D\x07\x18\x22\xAF\x5F\x3B\x88\x36\x7C\xF0\x30\x22\x06\x8B\x8D\x35\x6A\x0A\xAC\x70\x64\x88\x7D\x33\x1D\x88\x54\x87\xD7\x28\x46\x85\x88\x3B\x10\xD6\x82\x64\x2D\x54\x01\x1B\x8A\x87\x8B\x15\x97\x85\x74\x02\x73\x88\x0A\x25\x1D\x89\x58\x85\x20\x2F\x0B\x18\x23\xBC\x54\x3B\x88\x66\x82\xD5\x2A\x32\x06\x8F\x8A\x5A\x3B\x21\xA8\xF0\x64\x2C\xD5\x00\x42\x8B\xC2\x33\x48\x85\xC6\x52\x21\xB1\x42\x18\x3C\x16\x7E\x6D\x62\x23\x8E\x5F\x2F\x4F\x1A\x1A\x1E\x04\x93\x89\x64\x2D\x78\x2E\x41\x00\x92\x8E\x31\x58\x24\xBD\x5C\x03\x0A\x09\x03\x4A\x89\x1D\x5E\x93\x8F\x7E\x37\xB7\x06\x04\x62\x0A\xB8\x32\x52\x88\x78\x32\xAC\x03\xBE\x6C\x0E\x5E\xB5\x26\x6C\xB6\x22\xB1\x09\xFA\x71\xCF\x5A\x0E\x12\x0E\x04\xD1\x27\x89\x2A\x83\x6B\x72\x2D\x89\x16\x22\x56\x09\x22",
			"\xAD\xCA\x76\x01\xBB\x88\x7F\x26\x58\x0F\x89\x8A\x8C\x7C\x07\x01\x13\xE4\x2C\x62\x0B\x2A\x88\xC0\x6B\xAD\x52\x06\x6F\x7E\x22\x15\x5B\x88\x35\x82\x71\x0B\x2D\x88\xBA\x05\x14\x81\xD5\x0E\x00\x52\x89\xBC\x88\x33\x8B\x40\x34\x02\x08\x4D\x82\x26\x8D\xEE\x03\x32\x1A\x01\x6E\x88\x32\x8E\xC8\x74\xE7\x62\x27\xBD\x5C\x62\x0A\x17\x79\x11\x7A\x39\x8F\xFD\x22\x56\x1B\x23\xB6\x46\x2C\x00\xEB\x89\x55\x88\xE8\x76\x9E\x42\x03\x11\x27\xBD\x65\x62\x0A\x87\x89\x9E\x2C\x0E\x06\x9E\x85\x10\x3E\xB7\x02\x04\x1B\x0D\xAC\x42\x1F\x02\x38\x0C\xB9\x60\x50\x95\x21\x88\x83\x62\x09\x37\x69\x7F\x8A\x5A\x72\x8D\x4C\x4F\x96\x8D\x05\x14\xEA\x76\xC8\x4D\x86\x8A\x82\x27\xA1\x8E\x4B\x97\x85\x4F\x01\x12\x8A\x3C\x2B\x87\x88\x31\x89\x16\x28\xD9\x4D\x26\x83\x3C\x0F\x8A\xCA\x88\x65\x73\x16\x00\xA3\x8A\x5A\x2F\x28\x90\x13\x80\x6E\x61\x00\x92\x88\x52\x2F\xA1\x81\x46\x9D\xCB\x27\x01\x2A\x8A\xB8\x2B\x87\x8A\x01\x7E\x36\x2D\x06\x10\x29\x8F\x3F\x0F\x8A\x6B\x89\x05\x62\x4D\x8F\xA3\x84\x4E\x9D\x34\x79\x01\x3B\x8A\xBD\x0D\x99\x17\xBE\x3E\xB5\x5E\x51\x81\x2A\x80",
			"\x00\x6E\x89\x0A\x25\x42\x00\x50\x89\xD9\x00\x00\x01\x24\x88\x55\x0B\x01\x4B\x8A\x5B\x0C\xDC\x13\xDF\x31\x09\x11\x2A\x9C\x65\x27\x7A\xEE\x48\x71\x08\xE2\x24\x1B\x02\xB3\x1E\x0E\x07\x5C\x6C\x7C\xA1\x35\x4C\x02\x56\x89\x95\x1D\x55\x81\x77\x58\x0D\xA1\x35\x9B\x01\xB1\x8A\x90\x18\x83\x8F\x55\x9E\xE9\x43\x64\x1D\x01\x6A\x8B\xCC\x1E\xF4\x13\x37\x0D\x56\x84\xEA\x7E\xF6\x71\x8A\x61\x03\xB9\x8A\x59\x8A\x7F\x16\x57\x78\x2B\x82\x04\x20\x00\x7A\x8B\x67\x0F\xDD\x87\xDD\x23\x0A\x1E\x2B\x90\x2B\x52\x17\x5E\x8A\x4B\x86\xBF\x25\x14\x06\x58\x99\x98\x01\x16\x86\x02\x75\x8A\xF8\x46\x4A\x4D\xB1\x89\x04\x0F\x2C\x97\x15\xBC\x83\xF6\x49\xE1\x59\xB4\x4E\xB2\x86\x70\x32\xF5\x5D\x9A\x2B\x01\x8D\x8B\x32\x00\x67\x89\x20\x01\x59\x80\x00\x26\xFE\x67\x89\x8D\x8B\x39\x03\x68\x88\x00\x05\x5A\x85\x1D\xAF\x5F\x2F\x01\x8D\x8B\x40\x03\x6A\x8D\xB4\x87\x09\x80\xB8\x71\x02\x0D\x8B\x8F\x00\xE9\x15\x6F\x05\xB4\x82\x2C\x89\x37\x0D\x16\x9E\x01\xB3\x8B\xF3\x81\xA7\x4D\x16\x0D\x58\x8C\x05\x08\x16\xFB\x8A\xAD\x80\x7B\x4B\x2D\x05\xB1\x89\x0B\x1A\x2D\x88\x17",
			"\xB3\x81\xAC\x43\x5C\x01\x63\x88\x19\x01\x5C\x88\xF7\x7E\xB0\x0D\x8B\xD6\x01\xEA\x8A\x96\x74\xAE\x4D\x58\x84\x07\x0E\x17\x82\x8B\x08\x85\x81\x33\x2F\x05\xB1\x83\x0F\x1A\x2E\x9F\x0F\x81\x4B\x8D\x8B\x00\x00\x82\x1C\xAE\x84\xF0\x6D\xBA\x0D\x16\x8F\x00\x08\x1D\xDD\x89\xC0\x87\x16\x65\x0C\x0D\x2C\x9E\x00\x71\x8B\xCF\x8A\xFA\x85\x38\x47\x18\x0D\x58\x8D\x01\x38\x17\xE0\x8B\x04\x81\x7D\x3D\x32\x05\xB1\x8C\x03\x1F\x2F\x90\x16\x80\x88\xB7\x61\x65\x01\x63\x8B\x09\x0B\x5E\x99\x2F\x81\x04\x5D\x7B\xA1\x35\x66\x01\x63\x89\x0B\x0D\x60\x80\x30\xAC\xEA\x25\x3E\x8D\x8B\x33\x01\x85\x8F\xC0\x8E\x01\x81\x07\x51\x03\x0D\x8B\x75\x01\x0D\x8F\x65\x8B\x49\x8D\x69\x53\x06\x0D\x16\x83\x01\x22\x8D\xCE\x89\x45\x7D\xD3\x45\x0D\x0D\x2C\x91\x02\x06\x8C\xDF\x0C\x06\x7D\xA8\x37\x1A\x06\x55\x83\x37\x0A\xD9\x61\x41\xDD\x00\x71\x09\x48\x82\x41\x26\x6E\x10\x28\xA6\xC3\x3A\x8C\xB1\x21\x1E\x8D\x45\x88\xE0\x6D\x0E\x00\x32\xBE\x4B\x3D\x8C\x1B\x8A\x7F\x25\x3D\x06\xC8\x84\x66\x3D\x31\xA1\x14\xF4\x75\x4C\x8D\x9E\x2D\x8F\x8F\xA4\x8A\x8C\x65\x00\x01\x12\x3B",
			"\x8C\x3C\x2B\x1E\x8D\x4B\x8F\x80\x77\x65\x81\x32\x9A\x13\xA1\x35\x15\x01\x2E\x8F\x91\x8F\x9B\x81\xAA\x33\x6F\x67\x5E\x63\x8C\xD7\x55\xAD\x5A\x98\x8D\xC9\x85\x47\x80\xB8\x6D\x00\x6B\x8C\x52\x8D\xD4\x73\xBE\x3D\x06\x00\x67\x8F\xBF\x3D\x18\xCE\x8A\xB8\x2B\x1E\x01\x9D\x88\x3C\x3D\x63\x99\x27\xAF\x5F\x45\x00\x7B\x8D\xBE\x32\xC3\x2E\xC6\x8B\xEF\x2D\x02\x01\x12\x4C\x6B\x12\x0F\x82\x74\x6B\x46\x09\x01\x48\x1D\xD7\x49\x1A\xF5\x6A\xB7\x79\x40\x09\x95\x78\xB7\x2F\x68\x9C\xAB\x50\x6B\x5A\x00\x92\x8C\x8C\x34\xDC\x70\xC5\x59\x69\x9E\x97\x15\x1A\xA4\x7C\xCC\x42\x34\x01\xA7\x8C\xCC\x2F\x69\x8A\xF1\x56\xF4\x23\x8D\x3D\x2F\x52\x8C\x95\x89\x16\x26\x07\x08\x35\xAF\x5F\x25\x8D\x5B\x8D\x13\x6A\xAB\x88\x3C\x35\x6A\x93\x29\x87\xDA\x33\x8D\x7D\x33\x52\x8D\x4E\x8A\x36\x78\x6B\x85\x88\x25\x1A\xF0\x88\x1B\x79\x5E\x8E\x6D\x25\xD4\x89\x4E\x8A\x90\x19\x02\x42\x8D\x0A\x25\x52\x8C\x52\x8C\xA7\x20\x0A\x08\x36\xBC\x54\x25\x8D\x78\x8D\xE7\x1E\xB7\x59\x21\x03\x69\x8F\x7E\x25\x1A\xFE\x8C\xE0\x32\x57\x02\xB3\x8A\xB5\x24\x71\x23\x08\x25\x1A\xEF\x2D",
			"\xB5\x01\x43\x8D\x2C\x24\xE3\x2F\x70\x3B\xF7\x00\xBC\x63\x2D\xA0\x00\x04\x1E\xCB\x1C\xDC\x8C\x57\x3B\xF7\x38\x02\x3C\x5E\x09\x03\x50\x02\xBA\x8C\x21\x0C\x6E\x81\x08\x27\x76\x03\x32\xBA\x00\x78\x8D\xBC\x83\xDE\x81\x6F\x1E\xE2\x27\x7B\x7A\x8D\x03\x03\x51\x00\xBF\x8E\x20\x05\x6F\x98\x29\x2F\x5B\x3E\x01\x00\x8E\xC6\x87\xC0\x8B\x20\x05\x70\x99\x13\x79\xB9\x40\x01\x09\x8F\x80\x01\x29\x03\xE1\x84\x6F\x1F\xAC\x10\x6B\x1B\x5E\xE3\x2C\x53\x00\xC5\x8C\x0B\x6A\x86\x2C\x0E\x44\x03\x11\x8E\x00\x01\x53\x03\xC6\x88\x00\x05\x70\x80\x22\xB1\x42\x46\x01\x20\x8E\x54\x03\xC8\x8D\xE0\x8A\x61\x61\xD5\x27\xBC\x63\x2D\xA9\x01\x95\x8C\x88\x6B\xDA\x50\x72\x8A\x05\x32\x1C\xB0\x89\xA1\x34\x66\x00\xC8\x8B\x15\x07\x73\x8C\xB1\x61\x83\x3B\x5E\xE3\x2C\x56\x01\xCF\x8B\xC6\x61\xAA\x22\x7A\x63\x5B\x2D\x01\x43\x8F\x1C\x6F\xBE\x3A\x1A\x00\x72\x8E\x05\x09\x1D\xBE\x6C\xFB\x3C\x6A\x00\xC8\x8F\x15\x03\x72\x9F\xF0\x06\x14\xFB\x3D\x4E\x5F\xA2\x88\x6D\x24\x24\x80\xAD\x39\x7A\x67\x19\xE4\x2C\x56\x8E\x1F\x8D\x1D\x59\xD0\x85\x10\x21\x3B\x83\x19\xCA\x71\xEC",
			"\x00\xB2\x8E\x6D\x21\xEC\x89\x64\x84\xB3\x07\xBE\x5F\x8E\x3D\x2F\xB0\x8F\x93\x8E\x5F\x2C\x0F\x0A\x3B\x8A\x48\x61\x8E\xAB\x8D\x1C\x2F\xB1\x30\xCB\x8A\x5A\x21\x3B\xB1\x1A\x8A\x24\x68\x60\xB8\x8F\xFB\x29\xEC\x86\x6B\x8B\xCF\x3B\x1D\xB1\x21\x61\x8F\x5D\x8C\x52\x2C\x03\x07\x78\x9E\x97\x21\x1D\xC0\x8D\xEF\x2E\x12\x01\xE3\x88\xEC\x8D\x66\x86\xF5\x53\x1E\xF1\x8E\x72\x8D\x70\x43\x1F\x62\xF0\x80\x9E\x21\x3B\x91\x1B\x83\x1E\x3C\x01\xCB\x8F\xE0\x8B\x2D\x8D\x2A\x64\x02\x22\x1E\xE0\x33\x23\x2E\x45\x8E\xC4\x7F\x58\x3D\xAF\x69\x3D\x90\x1A\xB0\x79\xC7\x35\x6A\x8F\xC0\x1E\xF5\x86\x69\x9B\xF7\x18\x01\x31\x8F\xB1\x20\xDA\x8D\x60\x69\x15\x3F\x05\x18\x3D\xBE\x4B\x3A\x8F\x88\x6B\x7D\x3E\x19\x06\xF7\x84\x66\x20\x3E\xB3\x1D\xE4\x2C\x6D\x00\xE2\x8D\xCF\x28\xF8\x89\x77\x87\xFD\x4A\x1F\xEF\x2F\xC0\x8F\xBF\x8C\x4F\x2B\x0F\x0F\x7C\x88\x3D\x9F\x19\xCC\x43\x82\x01\xEA\x8D\x5F\x30\xF8\x8A\x78\x98\xAD\x09\x02\x5A\x8F\x05\x22\xE0\x8C\xE4\x88\x3C\x30\x09\x00\x3F\xB6\x46\x40\x8F\xC5\x8C\x0B\x7E\xF9\x8A\x41\x20\x7C\x8B\x36\xAA\x56\x1E\x01\xEB\x8E",
			"\x9E\x28\xF0\x8F\xF3\x8C\x10\x05\x05\x31\x1F\xAA\x2B\xC0\x8E\x6C\x8D\x5F\x34\x15\x07\x7F\x96\xCB\x0C\x04\x40\x8F\xEF\x2D\x59\x03\xB1\x34\xB9\x6B\x72\x25\x37\xA1\x83\x34\x01\xC7\x34\xC4\x24\x2C\x03\xE4\x85\x80\x8D\x37\xA1\x83\x36\x01\x09\x91\x68\x0C\x03\x92\x4C\x3E\x6E\x91\x40\x89\x04\x32\x01\x13\x90\x34\x34\x06\x76\x02\x96\x10\x13\x05\x19\x20\xEF\x34\xA8\x66\x0E\x93\xBB\x0F\x03\x96\xA7\x23\xC8\x3E\x02\x22\x90\xF4\x0C\x12\x90\xD0\x32\x93\x38\x82\x81\x08\x36\x02\x2A\x90\x84\x35\x21\x59\x0B\x91\x99\x60\x83\x8C\xBA\x03\x64\x44\x01\x33\x90\x5C\x01\x0D\x95\xE5\x8C\x1C\x46\x06\x33\x20\xB9\x01\x35\x91\x7E\x75\x41\x20\x19\x03\x83\x9A\x05\x35\x20\x89\x8A\xE0\x32\x65\x03\x0C\x93\x17\x05\x83\x93\x26\xAF\x5F\x4C\x01\x33\x90\x5E\x01\x0D\x92\x20\x31\xAA\x30\x86\x63\x5B\x3D\x01\x35\x91\xF9\x39\x9E\x58\x1A\x03\x83\x9E\x05\x35\x20\xF9\x3B\xE5\x81\x19\x93\x2F\x03\xE4\x8D\x72\x1D\x08\x90\x6B\x54\x01\xC7\x34\x27\x91\x40\x05\x0C\x9C\x75\x9B\xF7\x1A\x03\x27\x8F\x7E\x33\x5C\x8B\x40\x32\x1C\x00\x87\x85\x88\x2C\x21\xAF\x82\x8A\x59\x3A",
			"\x92\x6D\x27\x0E\x9D\x76\x9D\xB9\x32\x03\x7A\x90\x0A\x25\x3B\x93\xF1\x8D\xE7\x2A\x0F\x00\x44\xBC\x54\x77\x90\xCD\x8F\x9E\x2E\x00\x01\x1F\x6C\x77\x88\xAA\x37\x21\xD2\x8F\xEF\x32\x46\x91\x2C\x27\x0E\x95\x78\x8A\xAD\x12\x00\x12\x91\xFE\x25\x3B\x91\xF7\x8F\xF9\x1A\x01\x18\x44\xA4\x59\x77\x90\xE3\x8F\xBE\x32\x08\x06\x13\x9D\x73\x37\x43\xA9\x1F\xAA\x2B\x2A\x00\x52\x93\xFB\x2F\x0E\x9E\x7E\x9E\xD0\x2A\x22\xE0\x33\x77\x90\xFA\x8F\x63\x4F\x15\x91\x87\x84\xDD\x5D\x9A\x42\x00\xB4\x91\x82\x21\xCC\x2B\x20\x0D\x4A\x99\x73\x4A\x01\x79\x61\xFD\x75\x5D\x92\x40\x03\x96\x8D\x2A\x6F\x02\x39\xC3\x32\x8F\x37\x0E\x31\x15\x38\x46\x0A\x07\x8C\x91\x85\x02\x23\xBB\x8F\xA7\x57\x66\x92\xBF\x27\x19\x91\x7C\x81\x07\x64\x01\x52\x91\x64\x2C\x6A\x93\x20\x97\xFD\x2B\x06\x18\x46\xBD\x5C\x54\x91\x89\x91\xF7\x2E\x1C\x06\x1B\x9F\x7E\x34\x46\x90\x22\xC8\x2A\x79\x00\x72\x90\x78\x34\x1A\x95\x89\x88\xAA\x00\x02\x6A\x91\x7D\x32\x6A\x93\x26\x93\xE0\x17\x08\x10\x47\xBA\x22\xBD\x8A\xEF\x2C\x47\x02\x3D\x96\x36\x24\x8D\x87\x45\x88\x55\x15\x01\xFB\x90\x05\x24",
			"\x35\x95\x15\x98\x5B\x3C\x04\x01\x24\xBC\x2A\xD4\x90\x59\x92\x41\x03\x14\x07\x90\x8A\xAD\x14\x23\xFA\x8F\x05\x22\x55\x01\x43\x90\xA9\x2A\x74\x16\xA7\x0A\x95\x79\x61\xCC\x6B\xC1\x0D\x03\x96\x9E\x42\x0B\x18\x48\xB1\x42\x4D\x10\x02\x02\x6A\x91\x00\x96\x23\x9E\x2F\x20\xBA\x13\x89\x07\x7C\xF9\x60\xC4\x24\x30\x03\xE4\x86\x92\x9B\x12\x50\x6B\x36\x01\x29\x92\x80\x28\x4B\x94\x02\x91\x0E\x58\x05\x31\x24\xFE\x10\x33\x92\x0D\x91\xA7\x4A\x17\x07\x93\x94\x48\x39\x24\xA0\x90\x79\x55\x9E\x90\x60\x17\x27\x95\x82\x81\xD5\x3E\x02\x42\x92\x02\x03\x62\x00\x51\x93\x05\x9B\xEF\x20\x06\x08\x25\x81\x02\xC6\x01\xA5\x91\x0C\x91\x54\x32\x0C\x0F\x4A\xB3\xEA\x52\x92\x36\x91\x50\x34\x31\x06\x2A\x98\x0C\x18\x4A\xBC\x20\xF9\x5C\xC6\x00\xAB\x91\x32\x00\x2B\x92\x84\x95\xE5\x16\x25\xCA\x01\x58\x92\x24\x91\x5F\x32\x19\x06\x95\x8B\x06\x18\x25\xEA\x90\x7D\x32\x66\x02\x55\x94\x19\x08\x95\x94\x42\x8C\x87\x4E\x01\x56\x93\x66\x00\x56\x92\x0B\x9D\x2A\x6D\x8A\x63\x5B\x4E\x01\x58\x92\x30\x90\x73\x42\x1A\x06\x95\x8F\x06\x23\x1C\xEB\x10\x66\x91\xA8\x8D\x3E",
			"\x60\x2E\x98\x98\x8D\x43\x99\x97\x39\x91\xB6\x23\xC6\x92\xD8\x8D\x8D\x50\x99\x8A\x90\x12\x26\xE7\x8E\x14\x69\xCA\x90\x4F\x2A\x32\x9D\x87\x8F\xBF\x32\x03\x1A\x93\xAA\x2A\xC9\x93\x36\x90\x3C\x3A\x0F\x00\x4D\x88\x55\x12\x93\xE1\x90\x7D\x75\x5B\x65\x11\x98\x5B\x32\x4C\xA7\x23\xB8\x2B\x0A\x01\xD5\x91\x2C\x22\x32\x9D\x8E\x98\xAD\x12\x00\x32\x93\xFE\x24\xC9\x93\x3C\x95\xFB\x18\x9B\x84\xB3\x12\x26\xA1\x91\x05\x22\xBE\x60\xE7\x8D\x2F\x32\x99\x9E\x47\xB8\x56\x2A\x00\xBD\x93\x9E\x2E\x64\x94\x20\x9F\xFC\x12\x01\x09\x27\xEF\x2F\x92\x92\x85\x93\xE6\x3F\x39\x90\x9E\x32\x4C\x90\x24\xB6\x23\x42\x00\xEA\x91\x5F\x30\xE9\x2C\x70\x23\xC8\x0A\x01\x6D\x62\x4C\x63\x91\x8C\x77\x90\x8A\x37\x99\x40\x4F\x98\x2C\x62\x93\x34\x93\x45\x8E\x79\x91\x21\x02\x0D\x08\x4F\xBA\x24\xEF\x2D\x50\x01\xF5\x93\xD4\x16\x3D\x90\x94\x8A\x4D\x72\x27\xE1\x16\xF4\x93\xA2\x90\x73\x44\x0A\x07\x9F\x86\x5C\x39\x27\xCC\x92\xCB\x91\xFE\x91\x40\x06\x1A\x0F\x9F\x93\x4A\x8C\x87\x58\x00\x02\x94\x5C\x61\x81\x91\x2B\x9C\x1C\x5A\x02\x09\x28\xD8\x01\x0B\x95\xAF\x91\xAB\x64",
			"\x0B\x09\xA0\x99\x06\x0B\x28\xE5\x92\x0A\x24\x2F\x01\x82\x92\x1B\x0B\xA0\x8A\x4B\xB6\xA9\x09\x94\xDB\x01\x05\x94\x5C\x95\x20\x22\x06\x09\x50\x9C\x03\x0B\x94\x76\x93\x3C\x5C\x19\x01\x41\x9D\x0D\x0B\x50\xBC\x25\xB7\x61\x66\x01\x04\x96\x37\x03\x41\x92\x98\x99\x73\x68\x01\x09\x94\xDF\x01\x91\x8C\xA1\x15\x17\x9D\x2A\x6A\x03\x2D\xC5\x6A\x92\x84\x14\x62\x93\x2D\x66\x0D\x0D\x16\x70\x4B\x84\x2A\x43\x88\xAD\x64\x3A\x01\x91\x91\x16\x24\xA8\x18\x4C\xBE\x4B\x7A\x00\x4B\x94\x7F\x24\xA1\x15\x33\x97\x59\x71\x52\xA4\x59\x0E\x15\xA9\x30\x43\x02\x95\x95\xE7\x24\xA8\x09\x4D\xBD\x65\x0C\x01\x5B\x95\xF7\x2C\xA1\x17\x35\x9F\xFC\x12\x8D\x5A\x1D\x87\x15\xC7\x76\x19\x39\x98\x90\x3C\x34\xA8\x1B\x4D\x87\xFD\x6B\x94\x7D\x32\x42\x14\x70\x96\x36\x24\x0A\x10\x53\x85\x44\x04\x15\xC6\x93\xE7\x1E\x2A\x06\x4E\x96\x1B\x24\x54\x0C\x27\x83\x1E\xB0\x00\x3E\x96\x82\x24\x50\x12\x9D\x82\x08\x36\x02\x02\x95\x3C\x2A\x42\x17\x75\x92\x41\x27\x1C\x67\x53\x8B\x23\x58\x8A\x7F\x55\x04\x94\x38\x00\xC1\x1E\x1D\x0C\x46\x11\x0D\x9E\x8E\x09\x95\x76\x00\xA5\x91\x2B",
			"\x17\x18\x81\x07\x46\x03\x09\x94\xFA\x01\x14\x8F\x25\x13\x4F\x82\x3D\x69\x50\x88\x00\x4C\x18\xBB\x02\x66\x12\x7A\x73\x20\x3E\x1C\x63\xB7\x16\x00\x28\x95\x9C\x95\x5A\x69\xF9\x61\x41\x94\x02\x10\x55\x88\x25\x03\x02\x8F\x84\x65\x72\x33\x01\x41\x92\x03\x0C\x62\x15\x2A\x8A\x8B\x64\x2C\x68\x01\x82\x97\x07\x06\xAB\x95\x49\x33\xF1\x50\x35\xD2\x01\x04\x95\x13\x05\x58\x9F\xA8\x98\x2C\x9D\x9A\x54\x01\x09\x95\x2D\x00\xB3\x96\x2C\x18\x2A\x96\x27\x56\x03\x09\x94\x69\x01\x69\x97\xA8\x96\x55\x88\x0F\x89\x50\xB7\x01\x5A\x95\x2E\x12\x5A\x85\x2A\x32\x1B\x09\xA0\x85\x04\x20\x2B\xCC\x11\xB5\x8A\x65\x70\x37\x01\x41\x93\x09\x0C\x62\x3D\x06\x4C\x11\xBD\x8B\xF5\x3D\x82\x92\x14\x07\xAE\x82\x2E\xAF\x5B\x60\x01\x09\x94\x58\x02\xAF\x91\x56\x9D\x04\x44\x79\x49\x28\xBD\x01\xEE\x94\x7E\x97\xB5\x81\x54\x34\x0E\x09\x50\x8C\x03\x75\x95\xD6\x8B\x4E\x4E\x39\x03\x43\x98\xB0\x9B\x2E\x83\xB2\x09\x94\xE8\x01\x80\x97\xAD\x90\xE1\x55\x12\x89\x50\xB7\x03\x0D\x96\xE7\x8A\x68\x34\x3B\x01\x41\x95\x00\x0A\x5F\x29\x2A\xED\x8B\x03\x32\x77\x01\x82\x93\x02\x0A",
			"\xBE\x0F\x57\xB3\x17\x80\x6E\xF0\x01\x04\x96\x08\x05\x64\x9C\xAF\x99\xD3\x5F\xD0\x09\x94\x31\x00\x96\x97\xC4\x94\x21\x49\x8A\x34\x07\x09\x28\xC0\x00\x32\x96\x63\x95\x8C\x85\xD3\x46\x0F\x09\x50\x8F\x01\x1E\x96\xFC\x94\x08\x8C\x73\x40\x1F\x09\xA0\x9D\x02\x00\x2D\xB3\x96\xFE\x74\x68\x36\x3E\x01\x41\x9B\x06\x07\x5A\xBA\x2C\xFE\x81\xAC\x42\x7E\x01\x82\x91\x0F\x0E\xB4\x8D\x56\xA4\x18\x81\x72\x09\x95\x43\x01\xD5\x94\x5A\x92\x25\x81\x07\x6F\xF1\x6B\x53\x39\x97\xE8\x12\x8C\x8C\x39\x42\x00\x18\xC3\x30\x25\x99\x13\x42\x94\x80\x6C\x02\x00\x0F\x3C\x9A\x8F\x7E\x19\x26\x48\x94\xB7\x60\x08\x00\xDB\x91\x16\x29\x99\x0E\x52\xA2\x6B\x73\x96\xFE\x25\xCC\x10\x95\x95\x2F\x30\x02\x18\x5B\xA1\xD6\x20\x65\xE1\x40\x14\x02\xDF\x95\xE7\x29\x99\x1E\x52\x85\x44\x7B\x63\xC3\x93\x82\x21\x66\x14\x4C\x93\xF0\x18\x01\x03\x2E\xEF\x2F\x99\x13\xDA\x93\xF3\x18\x08\x0F\xB8\x80\xCF\x19\x26\x6E\x94\x06\x02\x24\x01\xE5\x95\x2F\x39\x99\x13\x53\x8A\x48\x50\x00\x9B\x96\xC5\x95\xE5\x8F\x37\x51\xBA\x96\x8D\x19\x26\x7F\x94\x0C\x02\x30\x01\xE9\x92\x41\x29\x99",
			"\x05\x54\x81\x04\x68\x00\xAB\x96\x9E\x29\x66\x13\x51\x9C\x53\x30\x03\x31\x2E\xAA\x2B\x58\x2F\x32\x84\x6B\x40\x0F\x08\x87\x28\x9C\x24\x02\x6A\x17\xDE\x03\xDC\x95\x9B\x81\x1C\x4A\x07\x1D\x5D\x91\x1B\x40\x97\x48\x27\xB3\x88\x73\x44\x0F\x06\xBC\x80\x42\x1B\x2D\x81\x02\xC2\x97\xC7\x83\x40\x36\x0F\x0D\xBC\x82\x56\x4F\x2F\x80\x00\xD1\x96\xC1\x6C\x6B\x40\x10\x05\xBD\x8D\x60\x17\x2F\xD9\x97\x7A\x7E\x65\x72\x20\x05\x7B\x92\x10\x08\x07\x1F\x2F\x83\x8B\xDB\x7E\xF2\x95\x40\x06\x1E\x08\xBC\x8F\x9A\x00\x2B\xBD\x2E\x86\x00\xF5\x96\x41\x24\x03\x4B\x1B\x19\x5E\x85\x0E\xBD\x2E\x88\x00\xF9\x95\x04\x04\x7E\x99\xBC\x8E\x56\x99\x63\x72\x97\x1F\x00\xFE\x96\xFB\x95\x5A\x9A\x2F\x72\x5F\xAD\x00\x02\x98\x06\x03\xEC\x97\x69\x8F\x1C\x32\xBF\x9B\x01\x08\x30\x83\x02\xD9\x96\xD7\x88\xF9\x8A\x7E\x99\x04\x0F\x60\x89\x25\xAB\x87\xAD\x64\x49\x02\xFC\x97\x0A\x0C\x01\x5D\x0D\x19\x2F\xF1\x95\x06\x03\x7A\x67\xB8\x2E\x0C\x06\xC1\x90\x5E\xB6\x2B\x83\x32\x96\x00\xF9\x94\x1D\x04\x03\x41\xBC\x90\x16\x8A\xE3\x18\x01\xF2\x97\x40\x01\x07\x9D\x7F\x95\x3C\x8F",
			"\xB7\x1A\x02\x72\x97\x90\x01\x12\x98\xF6\x93\x79\x87\x33\x72\x5F\x9E\x02\x3A\x98\xD9\x96\x7D\x70\x73\x46\x13\x02\xBF\x8C\x05\x33\x30\x83\x98\xEC\x85\x4E\x4C\x28\x02\x7E\x9B\x0B\x00\x62\x8F\x08\xCC\x43\xA2\x00\xF9\x95\x32\x06\x89\x9F\xFE\x6C\x0D\x64\x02\x72\x97\xD7\x01\x23\x99\x02\x9F\x64\x9A\x8C\x66\x05\x32\x2F\xE6\x01\x5A\x98\x08\x98\x37\x85\xD3\x48\x0A\x12\x5F\xB5\x03\x61\x98\x17\x98\x15\x87\x2D\x62\x15\x02\xBF\x84\x00\x24\x3F\x1E\x98\x08\x8C\x80\x6C\x2B\x02\x7E\x93\x01\x04\x7F\x35\x2F\xB7\x84\xCC\x42\x57\x02\xFC\x91\x04\x06\xC7\x94\x61\x97\x18\xE1\x41\xB0\x00\xF9\x97\x0B\x05\x8F\x98\xC4\x90\x5A\x9C\x24\xF2\x97\x3D\x00\x42\x9B\x16\x9A\x83\x81\xAA\x34\x05\x32\x2F\xCB\x00\x8A\x98\x31\x9B\x8A\x8F\x2D\x32\xBF\x99\x02\x2F\x31\x8C\x02\x47\x15\x45\x9A\xBB\x88\x0F\x3C\x5C\x60\xA2\x7F\xF1\x1D\x36\x9C\x99\x58\x22\x03\x5A\x93\x84\x59\x61\x65\x9E\x0A\x82\x0A\x93\x5C\x53\x98\x99\x2A\x50\x16\x4A\x81\x07\x7C\x02\x2A\x99\x3D\x2E\x01\x6A\x3F\x8E\x9E\x4D\x0B\x10\x65\x8F\x21\x8E\x8C\x26\x70\x5B\x98\x78\x32\xEF\x2D\x6D\x81\xD5",
			"\x7A\x32\xFD\x32\xC2\x49\x82\x8E\xED\x67\x97\x95\x10\x20\x58\x15\x24\x83\x85\xC4\x98\xDB\x22\x99\x5B\xF0\x00\xCA\x29\x66\x8A\x48\x3F\x16\x20\x92\x7B\x4B\x30\x06\x99\x9E\x99\x3E\x42\x2C\x86\x44\x01\xD4\x98\xD5\x28\x87\x4B\x3C\x9C\x1A\x45\x06\x19\x33\xC8\x2A\xED\x55\x4C\x9A\xA7\x97\x9B\x98\x5B\x2D\x57\x4C\x23\x5F\x2E\xE4\x99\xE7\x1F\x1A\x24\x47\x97\x0B\x68\x06\x38\x61\x09\x76\xA9\x17\x61\x91\xB0\x40\x0F\x3D\xAF\x6B\x83\x30\x2D\x80\x6E\xD0\x00\x7A\x99\x2C\x23\x0D\x26\xB7\x9D\xB9\x15\x03\x7A\x99\xFE\x25\x35\x23\xDE\x95\x20\x2A\x0D\x00\x68\x88\x12\x80\x97\xD0\x74\x83\x9A\x3F\x98\x28\x84\x28\x6A\x68\xAF\x5F\x6B\x20\x8C\x97\x54\x1A\x43\x98\x3C\x3B\x06\x32\x5C\x83\x3C\x6E\x01\x13\x9B\xBE\x33\x1A\x20\x73\x94\xDD\x19\x68\x85\x44\x6B\x20\x9E\x96\x9E\x28\x3E\x06\xA3\x96\x1B\x2B\x83\x39\x29\xEB\x36\x24\x9A\x05\x27\x1A\x20\x75\x9D\xF5\x03\xC3\x35\x33\xF3\x89\x78\x86\x97\x9B\x3E\x9C\xF4\x87\x0B\x6C\x00\x32\x34\xFE\x25\x63\x20\xD5\x8D\xA7\x49\x02\x03\x86\x2C\xAE\x79\x34\xAF\x8F\xAC\x42\x09\x03\x18\x30\x9E\x9B\x25\x32\x43\xA0",
			"\x19\xC3\x9A\xB1\x21\x9F\x9A\x87\x7F\xDD\x28\x01\x08\x6A\xB8\x34\x81\x15\x0A\x3A\xA7\x98\x99\x2A\xA9\x91\x98\x70\xD6\x1E\x00\x52\x9A\x3D\x2E\xAA\x9A\x61\x75\x37\x68\xD5\x8F\xBF\x1A\x35\x91\x9A\x09\x02\x12\x01\x57\x98\x3C\x3A\xD5\x96\x68\x8C\x04\x27\x00\x63\x9B\xBE\x32\x56\x9C\xA3\x93\xC2\x29\x6B\x85\x44\x5A\x9A\x21\x9A\xD2\x36\x5B\x9E\x36\x2A\xD5\x87\x69\x8C\x04\x30\x00\x73\x9A\x05\x26\x56\x9C\xA5\x9A\xE2\x19\x6B\xBC\x54\x5A\x9A\xAE\x96\x00\x02\x0D\x06\xAF\x9A\x5A\x3A\x6A\xB4\x2E\xAA\x2B\x50\x67\xE5\x45\x5F\x31\x7C\x1C\xCE\x80\xB8\x7C\x00\x3D\x9A\xC8\x39\x85\x89\x19\x7C\xB0\x98\x54\x21\x5F\x37\x33\xCA\x71\x40\x00\xCA\x98\x6E\x29\x7C\x1D\xCF\x84\x0A\x5A\x36\xCF\x1F\xE1\x17\x81\x9A\x6D\x26\x08\x0F\xD9\x83\x78\x21\x2F\x23\x93\x7D\x33\x24\x01\x69\x9F\x7C\x1B\xD5\x8C\x0D\x4C\x01\x2B\x9B\xDC\x16\x52\x14\xB4\x37\x09\x00\xDB\x88\x5E\x08\xEE\x0E\x42\xB5\x9B\x30\x24\x99\x8C\x39\x45\x05\x19\x6D\x84\x2F\x06\x16\xB8\x6C\xDF\x9B\xF4\x13\x74\x9E\x2F\x3B\x02\x02\x37\xB8\x61\x99\x8E\xD6\x42\x17\x07\xB8\x91\xBE\x01\x6C\xA1\x01",
			"\x4C\x9B\x34\x9A\x80\x6F\xD9\x62\xB1\x95\x10\x35\x8E\x36\x36\xB9\x4E\x90\x9A\x7F\x26\x88\x38\x69\x80\xA7\x23\xC3\x08\x4E\x68\x00\xE4\x1E\xEF\x02\x88\x3F\x52\x99\xE7\x4A\x03\x1E\x37\xF2\x60\xE1\x9A\xA5\x78\x9D\x84\x6F\x77\xDE\x9D\xF3\x11\x32\xD6\x78\x60\x86\xD6\x42\x1B\x05\xBD\x96\x5A\x4F\x6F\xB2\x2A\xDA\x97\xF6\x48\x38\x00\x7D\x9D\x26\x26\xDF\x80\x0D\xA1\x2F\xB1\x21\x72\x01\xFD\x9A\x40\x01\x2F\x2C\x2D\x02\xF1\x39\x2A\x96\x60\x02\x9D\x35\x91\x7A\x9C\xAF\x8B\x03\x69\xC5\x36\x01\x09\x9C\xB3\x75\xFE\x9A\x88\x3F\x7E\x9E\x2B\x70\x70\x95\x03\x12\x9C\xA3\x84\xE6\x42\x1E\x00\xC2\x9B\x29\x25\x70\x9E\x16\xD9\x65\x10\x9D\x6F\x26\x87\x98\xD7\x77\xE0\x30\x70\x95\x4C\x23\x9C\xBE\x7C\x07\x3C\x84\x9E\x6C\x28\xE2\x83\xF6\x4F\xD4\x10\x9C\xAE\x27\xCC\x06\x88\x38\x84\x93\x10\x04\x04\x10\x38\x81\x28\x2D\x9C\x81\x01\xB2\x80\xE0\x66\x08\x10\x70\x80\x51\x4A\x07\x22\x3C\x91\x6C\x6B\x40\x11\x00\xE1\x9C\xA3\x32\x38\xA9\x6E\xFB\x3C\x45\x00\x84\x9E\x97\x29\xE3\x81\x08\x1E\x0B\xCC\x43\x8C\x00\x08\x9D\x3E\x2D\xC9\x90\x00\x02\x62\xB9\xB9\x7C",
			"\x66\xE3\x2C\xA2\x2B\x91\x99\xBC\x81\xAA\x30\x04\x10\x38\xFF\x00\x3A\x27\xDD\x02\x88\x38\x7C\x8B\x00\x90\x70\x8D\x02\x61\x9C\x4A\x7A\x0B\x85\xA8\x34\x12\x00\xE1\x9B\x04\x3A\x4C\x3D\x03\x22\x3C\xAA\x6C\x0A\x98\xC2\x9A\x0A\x0F\x73\x8A\xF5\x2E\x96\x79\x5C\x4C\x00\x84\x99\x17\x06\xE7\x8C\x70\xBA\x0F\xE1\x41\x9A\x00\x08\x9C\x32\x05\xCF\x9C\xBF\x1F\xDB\x5D\x9A\x03\x67\xE3\x2D\x6B\x00\x9A\x9E\xCF\x93\x0D\x29\x11\x50\x38\xE5\x01\x8B\x9D\x42\x9C\x4B\x65\x68\x60\xE1\x93\x07\x11\x3A\xE3\x47\x44\x85\x77\x2E\x28\x00\xC2\x91\x00\x0B\x08\x62\x39\xA5\x80\x9D\x4C\x52\x00\x84\x9F\x01\x0E\xE9\x8A\xEA\x61\x10\xB7\x61\xA6\x00\x08\x9D\x07\x03\x21\x4D\x1B\x00\xBD\x28\x7F\x60\x33\xA8\x00\x08\x9C\x0B\x03\x21\x4E\xF2\x00\xBD\x1F\x76\x64\x6F\x10\x9D\x16\x00\xAD\x9C\xD3\x47\x6F\x81\xD5\x2C\x02\x10\x9C\x2E\x01\x5D\x9F\x01\x1F\x3D\x93\x90\x2E\x05\x10\x38\xAF\x00\xC2\x9C\xD9\x84\x31\x31\x54\x30\x0B\x10\x70\xB0\x00\x49\x9D\x0F\x18\x9B\x05\xC3\x28\xC2\x91\x03\x10\x76\x93\x30\x44\x3B\x07\x7C\x08\x9E\x0C\x06\xDA\x95\xC1\x1D\x38\xB9\xB9\x36\x01",
			"\x10\x9D\x19\x00\xB7\x99\x4E\x2F\x94\x3A\x9C\x50\x38\xB4\x00\xE3\x9C\xD0\x2E\x84\x90\x13\x80\xE1\x95\x01\x29\x3B\xB3\x8E\x1F\x70\x08\x9E\x0D\x07\xDD\x98\x73\x8C\x0E\x7E\x02\x10\x9C\x37\x00\x7A\x9E\xCF\x8C\x05\x7E\xE3\x9A\x77\x84\x1D\xCC\x43\xC2\x00\x08\x9D\x0E\x06\xDF\x9A\x74\x81\x07\x44\x03\x10\x9C\x3A\x00\x82\x9C\xD4\x8E\x53\x90\xE1\x9B\x01\x23\x3B\xB1\x18\xC1\x5D\x77\x2C\x32\x01\xBB\x94\x66\x31\x61\x0F\xB2\x3B\x39\x14\x9F\x9E\x2E\x13\x1B\xCC\x71\xAA\x2A\x06\x26\x38\xB6\x23\x1B\x9E\xB0\x88\x73\x44\x19\x0F\xF1\x8A\x90\x21\x3C\xF3\x7C\x9D\x4C\x67\x00\x84\x9C\x07\x03\xEE\x87\x79\xBB\xF9\x45\x8E\x10\x9D\x1E\x01\xCB\x9F\x32\x89\xE7\x52\x06\x10\x38\xBE\x00\x33\x9E\x46\x9E\x3D\x4C\x1A\x00\xE1\x9F\x01\x39\x3C\x86\x02\x07\x9C\x9C\x99\xC9\x9C\xA7\x2E\xF2\x8D\x82\x7F\xE1\x10\x9C\x40\x01\x9F\x9E\x4B\x73\x5C\x90\xE1\x81\x02\x0A\x3D\x82\x02\x8E\x86\x75\x94\x84\x9A\x08\x0F\xF4\x8C\xB2\x1A\xB1\x10\x9C\x43\x01\xAA\x9E\x69\x89\x15\x30\x0E\x10\x70\x84\x01\x5A\x9E\x12\x99\xBE\x32\x38\x05\xC8\x9A\xF5\x89\x57\xB1\x42\x64\x01\x10",
			"\x9C\x23\x03\x42\x43\xAB\x8A\xEC\x61\xD5\x26\x03\x10\x9C\x48\x00\xAD\x9F\x8E\x9A\x19\x78\x0E\x03\x7A\xAA\x56\x45\x9E\xFD\x94\x45\x58\x84\x99\x09\x0B\xF6\x8C\x08\x38\x3D\x83\x96\xCC\x42\x76\x00\x84\x9B\x09\x0A\xF5\x8F\x72\xB9\xB9\x6E\x01\x10\x9C\x26\x02\xD6\x9E\xCA\x9D\x2A\x70\x07\x10\x38\xCD\x00\x7D\x9F\x7A\x5D\xF8\x7F\x83\x60\xE1\x8F\x02\x1A\x3D\xE4\x9C\x79\x5D\xD5\x67\xB8\x28\x0A\x0A\xF5\x8A\x73\xA9\xE3\x10\x9C\x51\x01\xC8\x9E\x41\x00\xEF\x92\xE7\x81\xD5\x38\x03\x10\x9C\x53\x00\xD1\x9F\x40\x00\xEF\x98\xE7\x8A\xA1\x50\x38\xD5\x00\xAA\x9E\x81\x00\xDE\x9C\x1C\x8C\x1C\x5C\x07\x10\x38\xD7\x00\xB1\x9F\x26\x19\x1C\x9A\x19\x7E\x0F\x10\x70\x99\x01\x5A\x9E\x42\x96\x26\x7D\xD6\x30\x71\x2A\x05\x1A\x7A\xB2\xEA\x6F\x2D\x02\x01\xE1\x9D\xA3\x22\xEB\x91\xB2\x6F\xB7\x04\x00\x4A\x9F\x73\x86\xAD\x9E\xCB\x81\x54\x36\x00\x10\x7E\x84\x7E\x5A\x9E\xA7\x9C\xB5\x96\xF5\x99\x85\x29\xFB\x8C\x27\x50\x2A\xC1\x68\xDB\x9F\x22\x33\xB8\x98\x69\x84\xDE\x8D\x95\x4C\x00\x61\x9F\x01\x03\x30\x03\xF8\x9A\x79\x99\xE7\x4E\x00\x28\x3F\x80\x00\x62\x01",
			"\xEE\x9C\xD2\x87\xD7\x63\x90\x30\x00\x2F\x3F\xE4\x00\xF2\x9E\x9A\x9F\x4E\x87\xFD\x96\x06\x19\x7F\xBA\x3C\x9D\x4D\x14\x01\xF7\x9C\x1A\x06\xFF\x90\xF4\x8B\xA2\x6F\x3F\xEA\x00\xEB\x9E\xBF\x84\x6B\x40\x03\x0F\xFE\x8B\x03\x04\x40\xCB\x9E\xD0\x34\x0D\x03\xFB\x9D\x0D\x0F\x00\xB0\x7A\xA9\x62\x1C\x00\xEF\x9F\x37\x01\x05\xA6\xEA\x96\xD5\x8F\x7F\xB1\x01\x1B\xA0\x5B\x9E\x68\x34\x08\x07\xFD\x93\x07\x00\x81\xA1\x3D\xC1\x93\xEF\x9F\x3A\x00\x08\xA6\xEC\x9E\x2F\x24\x01\x2F\x3F\xF7\x00\x0B\x42\x7B\x20\xD2\x84\xC6\x9B\x3E\x2F\x7F\xBA\x01\x20\xA0\x73\x9F\x58\x20\x0A\x07\xFD\x9C\x07\x09\x80\x89\x17\x9D\x4D\x2A\x01\xF7\x9D\x1F\x01\x06\xAF\xFD\x80\x7C\xB9\xB9\x2C\x00\xEF\x9E\x40\x00\x08\xA6\xF0\x9D\x2A\x6E\x01\x2F\x3F\x82\x01\x20\xA0\xC6\x9F\x2D\x60\x06\x0F\xFE\x84\x04\x04\x41\xF0\x65\xD8\x87\x77\x2E\x0C\x07\xFD\x97\x08\x00\x81\x98\x3E\xAD\x65\x34\x01\xF7\x9D\x22\x00\x04\xAE\xF9\x99\x73\x76\x00\x6F\x9F\x8B\x01\x2B\xA2\x5D\x83\xEA\x63\xEB\x58\x01\x2F\x3F\x8E\x01\x6A\xA0\xDD\x94\x9E\x76\x2A\x5F\xFE\x91\x04\x31\x41\xC7\x86\x0E\x86\x7B",
			"\x48\x0F\x07\xFD\x94\x09\x17\x83\xA7\xDA\x06\x9D\xE2\x7D\xF7\x9F\x25\x00\x04\xA1\xFC\x8D\x95\x40\x01\x6F\x9F\x99\x00\x10\xA3\xF1\x9B\x20\x32\x04\x0F\x7F\x9B\x02\x20\xA0\xCD\x9F\x81\x30\x11\x07\xFD\x9D\x09\x00\x81\x93\x3F\xCC\x43\x46\x01\xF7\x9F\x27\x00\x04\xA9\xFD\x8A\xC6\x48\x01\x6F\x9F\xA1\x00\x3F\xA0\x00\x02\xC6\x34\xC8\x10\x91\x59\x6D\x7D\x75\x39\x4C\xEE\x98\xDE\x57\xFD\x94\x0A\x03\x77\xB9\x98\x65\x9F\xB7\x61\x28\x03\xFB\x9D\x14\x0E\x0A\xAC\x7F\xAD\xCA\x53\x00\xEF\x9E\x53\x01\xF7\x99\xC7\x44\xFF\x81\xD5\x15\x01\x6F\x9F\xA8\x01\x5D\xA2\xFE\x9F\x16\x67\x05\x0F\x7F\xAA\x02\x42\xA1\xFF\x9F\x77\x2D\x16\x07\xFD\x9C\x0A\x08\x86\x85\x40\x8A\x4E\xEF\x9E\x57\x01\x2D\xA2\x01\xA6\x4F\x5D\x02\x2F\x3F\xAF\x01\xCE\xA0\x08\xA2\xEB\x57\xFD\x91\x0B\x19\x86\x96\x40\xD0\x35\x61\x01\xF7\x9F\x2C\x06\x1B\xAC\x01\xBC\x5D\x6F\x3F\xB5\x01\xE4\xA1\x10\xA1\x2C\x4F\xFD\x97\x0B\x09\x87\xA7\x40\x88\x56\xEF\x9F\x5C\x01\x3A\xA4\x05\xA4\x66\x29\x03\x2F\x3F\xBB\x01\xA2\xA1\x1C\x4C\x0D\xA1\x20\x0B\x06\x0F\x7F\xBE\x02\x69\xA1\x39\xA0\x7F\x25",
			"\x1B\x07\xFD\x90\x0C\x13\x86\xBF\x40\xEF\x2D\x6F\x01\xF7\x9D\x30\x01\x1F\xA8\xE4\x81\x07\x71\x01\x6F\x9F\xC4\x01\x74\xA0\x13\xA7\x16\x63\x07\x0F\x7F\x86\x03\x69\xA1\x52\xA0\x80\x6D\x1D\x07\xFD\x98\x0C\x0C\x88\x9C\x39\xCC\x43\x77\x01\xF7\x9F\x32\x01\x1D\xAF\x05\xB7\x85\x79\x01\x6F\x9F\xCD\x01\x74\xA1\x19\xA5\x55\x6B\x07\x0F\x7F\x8F\x03\x1E\xA2\xC4\x7A\x24\x5F\xFB\x9A\x1A\x00\x13\xA8\x18\xA1\x83\x7F\x00\xEF\x9F\x6A\x01\x4D\xA3\x1C\x89\x8A\x21\x04\x2F\x3F\xD8\x01\x3B\xA2\xC8\x75\xB2\x37\xFD\x9B\x0D\x09\x87\x85\x42\xB7\x61\x85\x01\xF7\x9D\x37\x01\x1D\xAB\x08\xA1\xD5\x07\x02\x6F\x9F\xDF\x01\x74\xA1\x24\xA1\x54\x39\x08\x0F\x7F\xA1\x03\x69\xA1\x97\xA1\x3C\x5F\x22\x07\xFD\x93\x0E\x09\x87\x9D\x42\xB1\x21\x8D\x01\xF7\x9D\x39\x02\x14\xA6\x1E\x36\x63\x10\x6B\x0F\x01\xA7\xA1\xEF\x77\xF7\x9F\xDD\x24\x09\x0F\x7F\xA8\x03\x63\x9D\xA6\x2E\x91\x9D\x9E\x5E\x12\x0F\xFE\x89\x07\x30\x45\xB6\xA1\xB7\x60\x4C\x03\xFB\x9A\x1D\x0D\xFD\x91\x8B\xAE\x15\xA1\x35\x9A\x01\xF7\x9C\x3B\x05\x2F\xA3\x0C\xA0\xB8\x7A\xD2\x63\x2D\xEE\x00\xC2\xA1\x32",
			"\xA2\x75\x7F\xFE\x90\x07\x0A\x46\xCF\xA1\x40\x81\xF7\x9E\x3C\x07\x2E\xA4\x0D\xBD\x34\x62\x02\x6F\x9F\xF3\x01\xC7\xA2\x36\xA1\x1C\x44\x0A\x0F\x7F\xB5\x03\x1A\xA3\xDF\xA1\x7D\x3E\x29\x07\xFD\x97\x0F\x00\x8D\xA5\x43\xE4\x66\xEF\x9F\x7C\x02\x69\xA2\x1D\xA1\x0E\x42\xA6\x5B\xA8\x2B\xA3\xEF\xA0\x05\x24\x2B\x07\xFD\x9D\x0F\x0B\x8D\xB4\x43\xBD\x2E\xAE\x01\xF7\x9F\x3F\x02\x14\xAE\x17\xB7\x76\xBB\x7B\x30\x01\xEF\x9E\x01\x03\xF1\x44\x11\x57\xC2\x81\xD5\x32\x02\x6F\x9F\x04\x01\xE3\x46\xCB\x1D\x37\xAA\xEB\x47\xF0\x6F\x3F\x85\x00\xC7\x46\x7B\x20\x73\xA0\x00\x06\x04\xAD\x95\x76\x02\x6F\x9F\x08\x01\xE1\xA0\x24\x1C\x87\x99\xE7\x58\x05\x2F\x3F\x8A\x00\xDA\xA3\x84\x03\x74\xA1\x23\xAA\x8C\x7A\x05\x2F\x3F\x8C\x00\xD1\xA3\xED\xA3\x47\xA1\xCF\x5C\x0B\x0F\x7F\x8F\x00\x61\xA3\x06\x03\xE9\xA1\x49\xA0\xE0\x6E\x0B\x0F\x7F\x91\x00\x70\xA3\x03\x03\xE9\xA3\x4A\xA7\x16\x60\x0C\x0F\x7F\x93\x00\x69\xA3\xE2\xA2\x2E\x98\x93\x97\xFD\x96\x01\x00\x90\xB1\x47\xE3\x98\xBA\x81\xF7\x9D\x06\x06\x40\xA9\x1F\xB9\x83\x9D\x9A\x46\x01\xEF\x9E\x0E\x00\x83\xA2",
			"\x20\x03\x1D\xB1\xE7\x45\xAA\x6F\x9F\x1F\x00\xFC\xA0\x85\xA0\x8F\x99\xE7\x4A\x06\x2F\x3F\xA1\x00\x1A\xA5\x80\x03\x74\xA5\x29\xA3\xF2\x8F\x7F\xA3\x00\x21\xA4\x00\x01\xE9\xA3\x54\xA7\x2E\x9F\xFE\x85\x01\x28\x48\xD3\xA3\x59\xA3\xBE\x93\xFB\x9F\x04\x0F\x22\xB3\x19\x83\x26\xEF\x9F\x29\x01\x09\xA5\x40\x04\x3D\x26\x16\xB1\x3A\xA9\x45\xD6\x75\x6B\xA3\x81\x31\x36\x07\xFD\x9C\x02\x0A\x8E\x94\x32\x0C\x19\xA9\x55\xF7\x9D\x0B\x06\x48\xA9\x10\x1F\x8F\x37\xF4\x7B\x3D\xDD\x01\xF7\x9E\x0B\x00\x45\xAE\x24\xBF\x8B\x8C\x87\x5F\x01\xEF\x9E\x18\x00\x95\xA5\x30\xAA\x8C\x7C\xA6\x63\x5B\x32\x00\x5B\xA5\xC5\xA1\xA8\x33\x1C\x0F\xFE\x94\x01\x21\x49\x90\xA3\xE1\x41\x72\x03\xFB\x9E\x06\x0C\x24\xAA\xE2\x6F\x2F\xEF\x2F\xE7\x01\xF7\x9F\x0D\x07\x4C\xAB\x19\xB5\x87\x6F\x3F\xB9\x00\x74\xA5\xD0\xA1\x38\x43\x1D\x0F\xFE\x9B\x01\x39\x49\xA7\xA3\x44\x47\xF7\x9D\x0F\x07\x4F\xAC\x1A\xAC\x0D\x61\xD3\x63\x2D\x3F\x00\x42\xA5\x6C\xA4\xA7\x21\x0F\x0F\x7F\x81\x01\x04\xA5\xB7\xA3\xF7\x2F\x3C\x07\xFD\x93\x04\x1A\x91\x80\x00\x55\xA4\xBE\xA3\x70\x41\x3D\x07\xFD",
			"\x96\x04\x04\x94\x81\x44\xE4\x2C\xF7\x01\xF7\x9C\x12\x05\x4D\xA3\x10\x18\x94\x8D\x47\xAD\x62\xEF\x9F\x24\x02\xA5\xA6\x54\xA4\x1D\xA8\xFE\x2F\x3F\xCC\x00\x84\xA5\x89\xA0\xC0\x68\x9D\x63\x6E\x2E\x02\x04\x4A\xE4\xA3\xA0\x2B\xF7\x9C\x14\x03\x55\xA3\xF9\x99\x73\x41\x00\x10\x32\x88\x27\x29\x00\xA1\xA3\x3E\xAA\x8C\x63\x00\x00\x4B\xFC\x49\x84\xA5\xFD\xA0\xC0\x6D\x00\x07\x2C\xA9\x08\x17\x01\x3C\xA5\x1C\x85\xB0\x61\xB3\xA1\xCA\x40\x2D\xBD\xFF\x5A\xBE\x53\xA5\x03\x03\x2E\x01\xB5\xA7\xCF\x9C\x1A\x4D\xA7\x63\x5B\x60\x00\xDB\xA4\xC6\x74\x5E\x60\x5B\xA5\x74\x64\x94\x87\x45\x80\x6E\x0F\x00\x72\xA5\x40\x05\x0C\x04\x28\xA4\x91\xB9\xB9\x11\x00\xEA\xA5\x3E\x38\xA1\xA3\x45\xA9\xE7\x53\x00\x31\x4B\xE9\x00\x84\xA5\x18\xA7\x2D\x65\x02\x01\x2F\xAB\x03\x04\x4A\xDF\xA2\xFE\x25\x0B\x01\xBC\xA5\x0D\x06\x29\xB2\x8F\x25\x42\xDE\x47\x10\x32\xB8\x91\x62\x52\x15\xAC\x3C\x91\x97\xB0\x01\x24\xA5\x02\x03\xC4\x50\x2C\xA0\xE0\x61\x02\x11\x97\xB1\x01\x10\xA6\x51\x7A\xB2\x7F\x45\x39\x5E\xA2\x07\x08\x91\x89\xA6\x3D\xA1\xCC\x43\x12\x01\xBC\xA4\x0E\x0E",
			"\x31\xBC\x92\xB1\x42\x27\x00\xF1\xA4\x3B\x01\xC9\xA2\x4C\xAC\x1C\x49\x01\x31\x4B\xF8\x00\x2B\xA6\x34\xA4\x6B\x43\x05\x01\x2F\xBA\x03\x18\x4C\xBD\x69\x95\xA3\x77\x2D\x0B\x01\x5E\xAB\x07\x11\x99\xB5\x49\xF6\x49\x2F\x01\x78\xA5\x1F\x06\x67\xAA\x27\xAC\x0D\x71\x00\x71\xA5\x7F\x00\xA2\xA4\xA0\xA6\x9E\x43\x03\x11\x97\x81\x02\x4A\xA6\x85\xA4\x7B\x48\x41\x6B\xDC\x23\x08\x10\x9A\x8B\x4A\xAA\x2B\x37\x01\x78\xA5\x21\x00\x6A\xA1\x29\xA0\xCF\x39\x00\x71\xA5\x87\x00\x4B\xA5\x62\x53\x1F\xA9\x31\x31\x97\x8A\x02\x50\xA6\x9F\xA5\x9E\x2D\x0F\x01\x5E\xAC\x08\x17\x99\x89\xA6\x42\x9C\xF6\x49\x1F\x01\xBC\xA5\x11\x02\x36\xAD\x88\xAC\x86\x41\x00\xF1\xA4\x48\x00\xD4\xA2\x56\xAA\x8C\x63\x02\x31\x4B\x92\x01\x50\xA6\x5C\xA6\x48\x29\x5E\xA4\x09\x15\x9B\xAB\x47\xAD\x65\x47\x01\x78\xA7\x25\x00\x6A\xA4\x2C\xB1\xE4\x71\x4B\x99\x01\x50\xA6\x65\xA6\x32\x73\x09\x01\x2F\xBB\x04\x06\x4E\xB1\xA2\x85\x8D\x78\xA6\x27\x07\x72\xA6\x13\xBF\x36\x71\x4B\xA1\x01\x9C\xA6\x9E\xA0\x7C\x59\x5E\xA4\x0A\x01\x9D\x82\x45\xD0\x35\x53\x01\x78\xA7\x29\x00\x6A\xA7\x2E",
			"\xAA\xC6\x55\x01\x71\xA5\xA9\x00\xA8\xA6\xBB\xA5\x55\x67\x05\x11\x97\xAB\x02\x50\xA6\xF4\xA5\x56\x65\x16\x01\x5E\xAD\x0A\x10\x9A\xBA\x4B\x80\x6E\x5B\x01\x78\xA7\x2B\x00\x6A\xA0\x30\xA4\xB3\x1D\x01\x71\xA5\xB1\x00\x4B\xA5\x7E\x25\x47\xA0\xE2\x50\xC8\x3D\xEB\x26\x19\x70\x19\x54\x30\x19\x00\x22\x3C\x5C\x6A\x5C\x53\x47\xF2\x79\xD4\xA7\x58\x22\xE2\x57\xD5\x9D\x97\x26\x03\x31\x4B\xB4\x01\x37\xA6\xC5\x57\xAD\x9D\x55\x68\x06\x11\x97\xB5\x02\x61\xA7\xE9\x93\xC0\x7D\xBC\xA6\x16\x08\x3E\xA4\x76\x86\xD3\x71\xA5\xB7\x01\xF6\xA5\x7D\x91\xCF\x5E\x06\x11\x97\xB8\x02\x72\xA7\xFA\x93\x3C\x5C\x1C\x01\x5E\xA9\x0B\x18\x9F\x80\x28\x99\x54\xF1\xA4\x5D\x02\xFF\xA6\x40\x99\xE7\x54\x03\x31\x4B\xBB\x01\x03\xA8\x06\x95\x9E\x5E\x0E\x01\x2F\xBC\x05\x09\x50\xEB\x9D\xB5\x73\x78\xA5\x2F\x01\x81\xA8\xA1\x9C\xA9\x3A\x01\x71\xA5\xBE\x01\x04\xAA\x87\x96\x36\x2C\x07\x11\x97\xBF\x02\x09\xA8\x23\x95\x3B\x69\xBC\xA0\x18\x09\x40\xA9\x51\xAD\xCA\x00\x01\xF1\xA5\x60\x01\x02\xAF\x45\x90\x70\x62\x04\x31\x4B\xC2\x01\x09\xA9\x1A\x95\xAB\x64\x10\x01\x2F\xA3",
			"\x06\x37\x4C\xAC\x2F\x72\xA1\x4E\x4E\x21\x01\x5E\xA4\x0C\x17\xA1\x88\x49\xE3\x73\xF1\xA5\x62\x02\x0F\xAE\x79\x4F\xE2\x31\x97\x86\x03\x28\xA4\x38\xA9\x97\x9C\x94\x99\x5E\xA8\x0C\x08\xA2\xA6\x4C\xBD\x75\xF1\xA4\x65\x02\x13\xAC\x65\xA9\xE7\x50\x04\x31\x4B\xCC\x01\x53\xA8\x99\xA7\x51\x69\x5E\xAE\x0C\x03\xA2\x8D\x38\x91\x80\xF1\xA5\x67\x01\x16\xAF\x67\xAD\x69\x56\x04\x31\x4B\xD1\x01\x63\xA9\xA2\xA6\x3D\x48\x13\x01\x2F\xB3\x06\x29\x51\xCB\xA6\x62\x6B\x78\xA5\x35\x07\x8D\xA1\x35\xA7\x74\xB1\x4B\xD7\x01\x74\xA9\xAB\xA4\x52\x2E\x13\x01\x2F\xB9\x06\x34\x51\xDD\xA6\x7D\x32\x50\x01\xBC\xA3\x1B\x06\x29\xA9\xA2\x9D\x3B\x86\x3D\xF1\xA4\x6F\x00\x1D\xA9\x6D\xAF\x7E\x24\x05\x31\x4B\xE0\x01\x5E\xA8\x1B\x43\xAC\x5E\x14\x01\x2F\xA1\x07\x05\x52\xF6\xA6\xF6\x48\x54\x01\xBC\xA4\x1C\x04\x47\xBC\x9B\xB1\x42\x2A\x01\xF1\xA4\x73\x00\x1D\xAA\x70\xA4\x66\x2C\x05\x31\x4B\xE8\x01\x97\xA9\xC3\xA7\x2D\x66\x15\x01\x2F\xAB\x07\x34\x51\x8D\xA7\xFE\x24\x58\x01\xBC\xA5\x1D\x04\x47\xB2\x9C\xB1\x42\x32\x01\xF1\xA5\x77\x01\x2A\xA8\x73\xA7\x80\x91\x97",
			"\xB2\x03\x3B\xA9\x9D\xA6\x7B\x4A\x2D\x01\x5E\xA5\x0F\x00\xA6\xA2\x4E\xEE\x8D\xF1\xA4\x7C\x02\x31\xAF\x74\xA1\x3A\x71\x97\xBB\x03\x74\xA8\xAD\xA7\x58\x20\x2F\x01\x5E\xAD\x0F\x14\xA3\xB3\x4E\xB7\x61\xBE\x01\x78\xA7\x3F\x04\x8E\xA9\x3B\xBC\x8F\xB1\x4B\x81\x00\x1A\x43\xA0\x2E\x2B\x18\xD4\x90\xCA\x31\x97\x83\x00\x61\xA9\x27\x93\x58\x1A\x8D\xA1\xCF\x54\x0C\x11\x97\x85\x00\x68\xA9\xA7\x2D\x84\x02\x2D\x1C\xE3\x9D\x83\x91\x97\x88\x00\x70\xA9\x2E\x1F\x79\xAA\x5C\xA5\x55\x68\x0C\x11\x97\x89\x00\x78\xA9\xB5\x18\xBC\xA0\xC0\x6A\x19\x01\x2F\xAA\x00\x30\x53\x88\x27\xFA\xA8\x2B\xA5\x9E\x5C\x19\x01\x2F\xAC\x00\x07\x54\x81\xAA\x68\x87\x81\x32\x33\x01\x5E\xAE\x00\x0F\xA8\xB2\x53\xF0\x86\x03\x32\x68\x01\xBC\xA0\x02\x06\x51\xA6\x08\x09\x54\x91\xA6\xA9\x30\x69\x01\xBC\xA2\x02\x00\x50\xB7\xA8\xB9\x4C\x83\x32\xD4\x01\x78\xA7\x04\x05\xA3\xA3\x10\x1F\xA8\x92\x16\xF7\x70\xF1\xA5\x0A\x00\x4B\xAA\x20\x0E\x52\xAD\x8C\x78\x03\xF1\xA5\x17\x01\x99\xAB\xB1\x27\xC3\x93\x90\x3A\x06\x31\x4B\x99\x00\x3A\xAB\x65\x72\xE7\x81\x54\x3C\x0D\x11\x97\x9B",
			"\x00\x41\xAA\x35\xAA\x3D\xA8\x6E\x2E\x1B\x01\x2F\xBD\x00\x08\x55\x98\x98\xB7\x60\x70\x01\xBC\xA7\x03\x00\x4F\xB6\x87\x35\x54\xE4\xA6\xE2\x01\x78\xA6\x08\x07\xA9\xA7\x3B\x8C\x0E\x64\x03\x71\xA5\x24\x01\x92\xAA\x47\xAE\x85\x91\x0B\x26\x07\x31\x4B\xA5\x00\x55\xAA\x88\xA9\x0D\x9B\x20\x38\x0E\x11\x97\xA8\x00\x5C\xAA\xD3\x7E\x7B\x4A\x3A\x01\x5E\xAA\x02\x10\xAB\x91\x0F\xAC\x43\xEC\x01\x78\xA4\x0B\x01\xAD\xA6\x52\xA9\x62\xAF\x5B\x6E\x01\xF1\xA5\x17\x02\x5D\xAD\xE8\x69\x8A\x30\x07\x31\x4B\xB1\x00\x83\xAB\x80\x02\x2D\xAE\x5F\x22\x0F\x11\x97\xB3\x00\x7C\xAA\x63\xAB\x68\xA6\x3D\x4C\x1E\x01\x2F\xB6\x01\x10\x56\xAD\xAA\x08\xA5\x81\x32\x3D\x01\x5E\xA9\x03\x17\xAC\xB4\x54\x8E\xA4\xFA\x4B\x78\xA4\x0F\x06\xB3\xAB\x53\xA0\x84\x83\x64\x7A\x01\xF1\xA5\x1F\x01\x62\xAA\xCE\x41\x87\x51\x97\x81\x01\x2B\xAB\xD7\xA8\x80\x6E\x3F\x01\x5E\xA3\x04\x0B\xAD\x9D\x53\x80\x6E\x00\x00\xE1\x34\xE2\x25\x08\x0B\x5A\xBF\x9D\x8A\xE3\x02\x00\xBA\xAA\x86\x03\x11\x03\xB5\xA5\x3C\xBD\xB9\x04\x00\x41\xAB\xEE\x42\xD2\xAA\xB3\x25\x9A\x10\xAD\x26\x00\x02\x6F",
			"\x70\x92\x39\x3C\x69\x1B\x92\x6A\x78\x3D\xB6\x97\x68\xAA\x55\xE1\x41\x14\x01\x07\x6D\x41\x27\x9A\x17\x29\x27\x01\x5A\x57\xB6\x23\xDC\xAB\x81\x02\x74\xA8\x2B\x72\xBC\x24\x6A\xAB\x33\x6B\xA0\x9D\x4D\x0C\x00\x72\xAB\x76\x41\x54\xA8\x67\x03\x2F\xA3\x4C\xEB\xAB\x81\x02\x13\x05\xBD\xA2\x50\xAA\xC6\x60\xD7\x1B\x9F\xCA\xAA\xF7\xAA\xF4\x94\x79\x81\x5F\xA3\x32\x79\x57\xCF\xA8\x64\x2D\xFF\x6B\xB8\x2E\x0A\x0F\x5F\xB4\xA2\xAD\xCA\x0E\x6C\x34\x71\x02\xAE\x16\xAB\x39\x6D\x5F\xA1\x08\x1C\x01\x74\xAB\x27\xAB\x50\x36\x8A\x6B\xDC\x2E\x05\x0A\xB0\xA4\x51\x95\x48\x0D\xAD\x5A\x22\x85\xAA\x8D\xAD\x69\x4B\x01\x19\x58\xE4\x00\x1B\xAC\x38\xAA\xCE\xA1\xC3\xA7\x06\x01\xB1\xB5\x51\xE9\x63\x19\xAC\x35\x02\x89\xAA\xA9\xAF\xFC\x11\x01\x19\x58\xED\x00\x26\xAC\x40\xA9\x82\x29\xC3\xA0\x07\x10\xA7\x8F\x5F\x7A\xAB\xE4\x9C\x68\x35\x0D\x01\xC3\xA4\x07\x06\xB1\x8C\x52\xAF\x3A\x19\xAD\x3B\x00\x84\xAF\x20\xA3\x90\x39\x01\x19\x58\xF9\x00\x36\xAC\x75\x1B\x23\x29\x15\x3B\x03\x19\xB0\xBD\x01\x26\xAC\x9E\xA9\x06\x31\x86\xA8\x10\x06\x62\xA4\xA5\xBD\x5C\x3F",
			"\x00\x19\xAD\x41\x01\x92\xAE\x9C\x14\xB1\x85\x5A\x59\x58\x87\x01\x26\xAC\x58\xA8\x99\x2B\x08\x09\x61\xAA\x04\x26\x58\x8B\xAB\x64\x2D\x22\x01\x86\xAD\x11\x0B\x65\xA5\x67\x3C\x52\xAC\x43\x47\x01\x0C\xAD\x24\x05\xCD\xA7\x5E\xA1\xA6\x9D\x9A\x49\x00\x19\xAD\x4A\x00\x9D\xAA\x20\x08\x63\xB4\x7D\xB9\xB9\x4B\x00\x19\xAD\x4C\x03\x9E\xA9\x20\x08\x63\xB6\x90\xA1\x6A\x4D\x00\x19\xAD\x4E\x02\x89\xA9\x9A\xAE\x2F\x2F\x02\x19\x58\xA0\x01\x26\xAD\xD8\xAA\x32\x71\x0A\x09\x61\xA3\x05\x26\x58\xB7\xAB\xCA\x71\x29\x01\x86\xAE\x14\x06\x62\xBE\xAD\x9C\x14\x99\xAC\xA9\x00\x13\xAD\x71\xAE\xC4\x49\x61\xAC\x05\x03\x5A\x80\x00\xB5\x2E\xEF\x9F\xC0\x49\xC3\xA0\x0B\x01\xAA\xA9\x5A\x93\xA6\x22\x8B\x0C\xAE\x2C\x06\xD5\xA5\x5F\xB1\x85\x1D\x01\x19\xAC\xB4\x00\xE5\xA9\xAA\xA8\x64\xAB\xCD\x79\xB0\xB7\x02\x3A\xAD\x00\xAD\x9E\x2D\x18\x01\xC3\xAA\x0B\x00\xB6\x86\x58\xB7\x61\x63\x01\x0C\xAD\x2F\x06\xD8\xAB\x60\xB2\xE7\x59\x58\xC0\x01\xB4\xAD\x08\xAC\x73\x47\x0C\x09\x61\xA2\x06\x0C\x5B\x97\xAC\x03\x33\x34\x01\x86\xAD\x18\x07\x6D\xBC\xB0\xAF\x5B\x6B\x00",
			"\x19\xAC\x64\x01\xB7\xAA\xC4\xA3\x90\x2D\x03\x19\x58\xCB\x01\xE3\xAD\x13\xAF\x40\x37\x0D\x09\x61\xAE\x06\x29\x5B\xAC\xAC\x03\x1F\x38\x01\x86\xA9\x1A\x09\x6E\xB2\xB1\xBE\xBF\x19\xAC\xD4\x01\x53\xAD\xAA\xAC\x6C\xA8\x6D\x63\xB7\x18\x03\x69\xAD\x3F\xAD\x2F\x65\x86\xAB\x1B\x01\x6D\xA4\xB2\xA1\x6A\x79\x00\x19\xAD\x6E\x02\xBE\xA8\x93\xAD\x69\x5B\x03\x19\x58\xE1\x01\xE9\xAD\x28\xAC\x00\x69\xC3\xA4\x0E\x09\xB7\x96\x59\xEF\x2F\x7F\x01\x0C\xAF\x39\x03\xE1\xAA\x4A\xA0\xB8\x41\x02\x19\xAC\xEB\x01\x74\xAE\x98\xAD\xE7\x23\x08\x19\xB0\xAE\x03\x69\xAD\x68\xAD\x9E\x2D\x21\x01\xC3\xA1\x0F\x1C\xB8\xAF\x59\xF6\x49\x87\x01\x0C\xAD\x3D\x06\xE5\xA6\x67\xAF\xB7\x09\x02\x19\xAC\xF9\x00\x9A\xAF\x31\xA8\xEE\x69\x61\xBD\x07\x3A\x5C\xCC\xA9\xE1\x41\x46\x01\x86\xA9\x00\x01\x12\x4E\x88\x04\x37\x0D\x75\xE1\x41\x47\x01\x86\xAC\x00\x05\x74\xB5\x87\x02\x37\x77\x81\x54\x8B\x0C\xAF\x01\x05\xE9\xA1\x4F\xBF\x6D\x1D\x18\xAC\x43\x93\x01\x0C\xAE\x02\x04\xEA\xA6\x0F\x29\xB5\x9E\x5A\xFE\x25\x95\x01\x0C\xAD\x03\x04\xEB\xAF\x74\xB3\x08\x69\x62\x17\x01\x19",
			"\xAC\x08\x00\xD5\xAF\xF9\x25\xDD\x18\x69\x29\x9F\x4F\xAB\xB1\x21\xB6\xAD\x40\x05\xC9\x1B\xEF\x3F\x04\x14\x57\xF1\xAE\x51\x1C\x95\x4B\xDD\xAE\x5F\x22\x77\xA0\x00\x3B\x5E\x72\x7B\x7B\xAE\xB7\x8D\x90\xA1\x54\x37\x0B\x19\xB0\x94\x00\x54\xAE\x86\x5F\x1F\xA9\xA1\x59\xC3\xA6\x01\x08\xBC\x90\x38\x35\xAD\xD3\x91\x0C\xAC\x06\x04\xEC\xA9\x10\x11\x70\x24\x2A\xA8\x50\x19\xAD\x0D\x00\xE5\xAE\x20\x06\x79\xB9\xBA\x61\xEA\x19\xAC\x1E\x01\xCD\xAF\x40\x05\xF3\xA8\xE9\x81\x07\x41\x03\x19\xAC\x21\x00\xD1\xAE\x40\x04\xF4\xA0\x52\xAC\x15\x59\x58\xA4\x00\x8E\xAF\xCA\xAF\x9B\xA0\x3C\x35\x0C\x19\xB0\xA6\x00\x2A\xAF\x01\x02\xD6\xAF\x4B\xAA\xE1\x39\x61\xA9\x01\x38\x5E\x80\x00\xBA\xAE\x9B\xAA\x80\x89\xC3\xAC\x02\x1F\xBD\x81\x5F\x96\x87\xB1\x99\x0C\xAF\x0B\x06\xF8\xA3\x54\xAC\x0E\x4D\x03\x19\xAC\x32\x00\xE6\xAD\xA4\x48\x5A\x3F\x0C\x19\xB0\xB5\x00\x52\xAF\x96\x4C\x96\x3D\x86\xA8\x07\x0B\x76\xAF\xBC\x83\x3B\xB4\x3E\x19\xAC\x1E\x00\xF6\xAA\xD4\x40\xAD\x35\x06\x19\x58\xBF\x00\xB1\xAE\xCE\xAC\x59\xAE\x5F\x27\x0D\x19\xB0\x81\x01\x5D\xAF\xB2\xAE",
			"\xFA\x81\xA8\x31\x1B\x09\x61\xA5\x02\x23\x5F\x82\x02\x12\xAF\x9E\x2F\x36\x01\xC3\xA8\x04\x17\xBF\x81\x04\x17\xAE\xE0\x33\x84\x6F\xB8\x2B\x09\x00\x7F\xAA\xBF\x9D\x5C\xCA\x71\xDF\x01\x0C\xAF\x13\x06\xFF\xA0\x00\x03\xB9\xAF\x5F\x61\x01\x19\xAC\x29\x00\x03\xB1\xE5\xAF\x7E\x23\x07\x19\x58\xD5\x00\x05\xB1\xD1\xAE\x80\xA6\x5F\x25\x0E\x19\xB0\x99\x01\x19\xB0\xAB\xAF\xCC\xA8\xF9\x71\xC3\xAD\x05\x00\xC1\xB9\x5E\xA0\xAB\xD5\x6B\x0C\xAD\x18\x06\x04\xB0\x7C\xBB\x7D\xB1\x42\x6B\x01\x19\xAD\x32\x00\x03\xB4\xD1\xA4\x66\x2D\x07\x19\x58\xE8\x00\x0C\xB0\x49\xAD\x2C\x27\x1D\x09\x61\xAB\x03\x0C\x60\x98\xAD\xB1\x21\x78\x01\x86\xAE\x0D\x0C\x80\xBF\xBA\xA4\x59\x73\x01\x19\xAD\x38\x00\x03\xB3\xD4\xA0\x9E\x35\x07\x3C\x58\xAC\xB0\x40\x1D\x8B\x1B\xBB\x2F\x1E\x00\x77\xAA\x32\x8C\x39\x21\x6C\x81\xAF\x9E\x2C\x90\x1A\xCA\x16\x39\x5F\xB8\x55\x57\xB2\x1C\x01\x03\xBF\xAC\x6B\x45\x01\x0E\x85\xB1\x85\x05\x39\x68\xAB\xEF\x2D\x0A\x03\xC7\x68\x71\x28\x07\x09\xBF\x83\x04\x67\xB0\x7F\x82\x7B\x4B\x05\x03\x0D\xBC\x10\x1A\x03\x2E\x61\x82\x02\x70\xB1\x4E",
			"\x94\x6B\x46\xE4\x63\x6E\x3C\x03\x3F\x5E\xF9\xB0\xFB\xAA\xE6\x43\x06\x04\x0E\xB0\x47\x3F\xC3\x81\x5B\xAF\x63\x84\xB1\xD0\x4E\x21\xB7\xD8\xA0\x70\x7F\x00\x09\x62\x83\x02\x85\x01\x45\xB1\xB3\xAB\x20\x31\x02\x0F\xC4\x99\xDF\x77\xB0\xEB\x97\xD9\xAD\x5F\x33\x04\x06\x89\xA7\x98\x12\x62\xD8\xAD\x68\x6D\x4E\xB0\x75\x77\x13\xBE\x6D\xA3\xC8\x27\x00\x22\xB1\x90\x00\x52\xB0\xB9\xA9\x54\x3D\x72\x63\xB7\x13\x02\x2A\xB1\xEA\xAD\x50\x37\x0A\x02\x14\xB6\x09\x10\xC5\xB0\x5B\xDA\x1B\xA2\xB1\x4C\x00\x2C\xB6\xDE\xAA\x20\x2F\x01\x22\x62\x9C\x01\x2C\xB0\x40\xB1\x8E\xA8\x12\x42\x8A\xA0\x05\x30\x62\x81\xAE\x09\x2C\x51\xB3\x28\x00\x13\xB0\x00\x02\xC6\xB0\x4D\x9D\x4D\x35\x00\x51\xB1\x29\x01\x18\xBC\x70\xA6\xC0\x22\x62\xA9\x01\xB0\xB1\xFC\xAF\xFB\x29\x07\x02\x8A\xAC\x05\x30\x62\x80\xB0\x7D\x33\x1D\x02\x28\xB7\x15\x04\x8D\xA7\xC0\xB1\x42\x3D\x00\xA2\xB1\x59\x00\x2C\xB6\x01\xB0\x9E\x3F\x01\x22\x62\xB6\x01\xB0\xB0\x0A\xB0\x78\x31\x08\x02\x8A\xB9\x05\x25\x63\xAF\xAE\x9D\x4D\x21\x02\x28\xB5\x17\x07\x8F\xB5\xB9\x83\x64\x45\x00\xA2\xB1\x60\x01",
			"\x3F\xB3\xE7\xA0\x67\xA2\xC5\x85\x03\x03\xB2\x40\xAE\x3E\x4A\x28\xB1\x19\x00\x8B\xB4\xC1\xBD\x5C\x4B\x00\xA2\xB0\x66\x00\x2C\xB2\x07\xBE\x2F\x2D\x02\x22\x62\xCF\x01\xB0\xB0\x20\xB1\xA3\xAA\x14\xB2\x0D\x10\xC5\x86\x61\xBD\x2E\x51\x00\x51\xB1\x35\x00\x16\xBC\x84\xBD\xCB\x13\x01\x22\xB1\xD8\x00\x16\xB1\x85\x22\xB4\x10\xAD\x35\x02\x1F\xDC\x70\x92\x2B\xB2\x81\x00\xDD\xAA\xC2\x55\x86\xBE\x97\x31\x64\x94\x6C\xA9\x31\x31\x01\x4D\xB0\x54\xA4\xE5\x08\xE8\x7B\x64\xBD\x2E\x33\xB3\xE1\x1B\xBE\x3B\x0E\x0F\x71\x6C\xAE\x5C\x61\x9A\xB0\x95\x43\xA2\xB1\x2C\x22\x0C\xB9\x89\xB8\x5F\x4A\x65\xFE\x25\x74\x1C\x29\xB3\x40\x36\x0E\x0F\x94\xA4\xB3\x34\x39\x41\xB2\x42\x5D\x8F\x6E\x79\xAF\xCB\x19\x77\xB0\xD6\x3A\x01\x5A\xB2\xB1\x20\x3A\x1C\x53\xB3\xA9\x70\x96\xB4\x3B\x83\x5E\xCC\x43\x80\x00\x51\xB0\x37\x07\xF7\xAA\xE8\x0F\xE9\x48\xE7\x22\xB1\xDF\x00\xB6\xB0\xE4\xAD\xCB\x62\x8A\xA2\x07\x2C\x60\xED\xB2\x8C\x71\x8E\x6A\x28\xB6\x1C\x07\x97\xA7\xC4\xA2\x11\xA2\xB1\xEA\x01\xBE\xB0\x23\xB2\x19\x7A\x08\x02\xC5\xAE\x03\x02\xB3\x93\xB1\x99\x6A\x28",
			"\xB2\x1E\x02\x97\xB2\xB6\x97\x39\xA2\xB1\xF5\x00\xC4\xB0\x28\xB4\x39\x40\x09\x02\xC5\xB9\x03\x12\xB3\xA5\xB1\x50\x36\x24\x02\x14\xBD\x0F\x18\xCC\xAB\x62\xCC\x43\x94\x00\x51\xB1\x00\x03\x8B\x4F\x7C\x38\xCB\x9E\xD3\x5B\x3C\xA2\xB1\x02\x00\x69\xB4\x21\x06\x9A\xA3\xA7\x57\xA9\x22\xB1\x09\x01\xD5\xB1\x42\x05\x35\xBA\x4E\x70\xD6\x1A\x02\x22\xB1\x0D\x01\x2D\x48\x98\x2C\x36\xB3\x8C\xA1\x07\x5C\x02\x22\xB1\x12\x00\xD9\xB2\x41\x04\x37\xB8\x8C\xA2\x09\xA2\x62\x96\x00\x5B\x48\x7B\x20\x6F\xB7\x19\xBF\x6E\x20\x05\x22\x62\x99\x00\xBA\xB2\xD6\xB1\x35\xB3\x20\x32\x0A\x02\xC5\x9E\x00\x42\xB3\x03\x02\xDE\xB2\x36\xB0\x3C\x34\x0A\x02\xC5\xA2\x00\x58\xB3\x02\x02\xDE\xB0\x38\xB6\x8D\x82\x8A\xA6\x01\x11\x67\xB3\xB3\xBD\xA5\x56\x64\x2A\x02\x14\xBB\x02\x00\xCF\x81\x04\x3C\xB3\xEC\xB1\xBE\x32\x2A\x02\x14\xBF\x02\x0E\xCF\x89\x3A\x20\x96\xBE\x9C\x51\xB3\x0C\x07\x3C\xB3\x9C\xBB\xC0\xA4\x59\x2E\x01\xA2\xB0\x1C\x00\x7F\xB1\x3B\xB2\x82\xAD\x53\x62\x62\xBD\x00\x03\xB5\xF0\xB0\x0A\xB6\x38\xA2\x8A\xA2\x02\x09\x68\xEF\xB3\x2E\xB0\x7F\x24\x2D\x02",
			"\x14\xB7\x04\x16\xCF\xBC\x66\x8E\xB2\x83\x8E\x51\xB3\x12\x06\x42\xBD\x40\x81\xE4\x22\x62\xCF\x00\x1C\xB5\xAB\xAC\x06\x72\x14\xB3\x05\x01\xD1\x97\x2D\xA8\x67\xA2\xB1\x2B\x02\x89\xB2\x46\x50\xAD\x3E\x05\x22\x62\xDB\x00\x0F\xB4\x00\x02\xB0\x1C\x9E\xAF\x70\x82\xC5\xA0\x01\x49\xB3\x0C\x03\x19\xB7\x3E\xAF\x16\x62\x0C\x02\xC5\xA3\x01\x38\xB4\x9A\x51\xB9\xB0\xE1\x92\x14\xB6\x06\x16\xCF\xBA\x68\x8A\xAA\xAD\x64\x63\x02\x28\xB2\x0D\x06\xA4\xBE\xCB\xBD\x65\x48\x01\xA2\xB0\x37\x01\x93\xB3\x30\xB1\x0B\x2A\x06\x22\x62\xF2\x00\x53\xB5\xC4\xB3\xC8\x9A\x14\xB6\x07\x00\xD2\x86\x04\x47\xB4\x47\x61\xD5\x6A\x28\xB1\x0F\x09\xA5\xB3\xCC\x9B\x21\xA2\xB1\x7D\x01\x32\xB5\x66\xB3\x30\x92\x8A\xA1\x04\x2A\x69\x9F\xB3\x6F\x70\x51\xB1\x21\x07\x4D\xB1\x8B\xAC\x0E\x56\x03\x22\xB1\x89\x00\x3A\xB7\x2D\xB1\x21\x08\x0D\x02\xC5\x8D\x02\x74\xB4\xBC\xB0\x9E\x2A\x36\x02\x14\xB1\x09\x11\xD1\xA0\x69\x87\xA9\x8D\x70\x5A\xB0\x9D\xB5\x38\xBA\x20\x3E\x06\x22\x62\x9A\x01\x5E\xB5\x60\x1F\xFA\xAC\xCC\x20\x0E\x02\xC5\x9D\x02\x06\xB5\xD3\xB3\x50\x34\xE0\x6B\xDC",
			"\x22\x0A\x14\xD3\x9B\x67\xFD\x32\xE4\x00\x51\xB2\x29\x04\x4E\xB3\x9E\xB6\x8D\x26\x03\x22\xB1\xAA\x00\x4C\xB6\x39\xB6\x5F\x28\x0E\x03\xC7\xB4\x69\xF1\xB3\x05\x22\x75\x01\x3A\xB4\x4E\xB2\x8F\xBD\xCB\x2C\x03\x22\xB1\xB7\x00\x55\xB4\x3E\xB7\xAF\xA2\x8A\xBC\x05\x3A\x6A\xFE\xB1\xA1\x34\x78\x01\x40\xB7\x57\xB4\x90\xB6\x27\x72\x03\x22\xB1\xC6\x00\x62\xB5\x42\xB3\xB2\xA2\x8A\xAB\x06\x34\x69\x98\xB4\xE0\x32\x7B\x03\x45\xB4\x4E\xB4\x91\xA4\xB3\x38\x03\x22\xB1\xD3\x00\x3A\xB6\x46\xB4\xCC\x2A\x0F\x02\xC5\x97\x03\x74\xB4\x1F\xB3\xF7\x2C\x3F\x02\x14\xBB\x0D\x14\xD3\xA5\x64\x85\x22\xFE\x00\xB8\xB1\x8C\xB4\xDB\x19\xEA\x0F\xB7\x0E\xDE\x0E\x95\xE9\x20\xCF\x26\x4C\x46\x36\x26\x00\x17\xDF\x1F\x61\xEC\x1D\x44\x2F\x79\xB5\x96\x7E\x5E\xB0\x5A\x25\x9D\x3A\x6B\xC3\x34\xFC\xB5\xBE\x2B\x46\x07\x5F\xBB\x5D\x21\xD8\xA4\x59\x32\x1E\x0C\xA6\xE6\x42\x09\x07\x7E\x38\x38\x24\x07\x11\x6A\xFE\x2E\xB0\xAC\x1D\xA0\xC3\xB6\x65\x4F\xB0\xA6\xBC\x2B\x37\xAD\x65\x2A\x01\x89\xB6\x2B\x1E\x3E\xB2\xF3\x1C\xB5\xAD\xCA\x25\x6F\x88\xA2\x8E\xB7\xC7\x1B\x55\x91",
			"\xAA\x2E\x01\x1A\x6C\xB6\x1B\x22\xB6\x2A\xB6\xBF\x20\x06\x07\xB2\xAF\xC3\xA9\x6C\xDA\xB4\x79\x5C\x19\x01\xCB\xB2\xA3\x25\xB1\xBA\xDA\x06\x3D\xD0\x35\x34\x01\x99\xB5\x40\x05\x1F\x0F\xB2\xA6\xD3\xAD\xCA\x36\x00\x3A\xB6\x7E\x1F\x4B\x47\xF9\x22\xF3\x11\x7A\xB1\x42\x38\x00\x41\xB7\x02\x03\xD0\xB6\xE4\x1A\xC6\x36\x4A\x41\x6D\x89\x00\x4B\xB6\x54\x2F\x02\x9D\xA6\x31\xB4\xAD\x00\x11\x6D\x9F\x2C\x7B\xB4\x83\x02\x0F\x01\x68\xB1\x01\x17\xDA\x8D\x5E\x01\xB5\x28\x43\xA0\xB5\x05\x07\x25\x40\x66\x32\x79\x24\x4D\xC2\x00\x41\xB6\x0D\x02\xD7\xB6\xEF\x2C\xA8\xBC\xA9\x04\x01\x41\xB6\x1E\x01\x97\x42\x3D\x22\xE6\x1C\x9C\xBE\xF7\x41\x6D\xA1\x00\x64\xB6\xA6\xB7\x92\xA8\x5A\x38\x04\x01\xDA\xA6\x00\x6B\xB6\x86\x2F\x4F\xB5\x41\x24\xF6\x63\x6E\x2A\x01\x00\x6E\xB6\xB6\x55\x9D\x54\x30\x13\x01\x68\xBE\x02\x19\xDB\xA8\x5A\x59\xA0\x03\x32\x27\x01\xD0\xB3\x06\x07\xB8\xB2\x79\x30\x6A\xB6\x23\x50\x01\xA0\xB7\x0D\x05\x72\xBF\xF1\x15\xD5\x85\x44\x52\x00\x41\xB7\x1D\x02\xE3\xB7\xC3\x25\xFA\x9B\x4F\x81\x6D\xC0\x00\xA3\xB7\xC6\x2D\xEB\x9F\x16\x66\x05",
			"\x01\xDA\x85\x01\x29\xB7\x7E\x2E\x3F\xAD\xAB\x60\x0B\x01\xB4\xAA\x02\x30\x6E\x86\x2F\x86\xAD\x06\x95\xD0\xB7\x09\x0C\xB9\xA7\x20\x83\x64\x5C\x00\x41\xB7\x29\x01\xEF\xB3\xD2\x9A\xDC\x81\xDA\x97\x01\x43\xB7\x86\x99\x4E\x4C\x18\x01\x68\xBB\x05\x08\xDE\x82\x04\x61\xB5\xE0\x32\x31\x01\xD0\xB7\x0B\x0E\xBC\xA1\x08\x27\x6B\xB6\x23\x64\x01\xA0\xB7\x18\x07\x76\xBC\xEF\x1F\x78\x2D\x6B\xBE\x3B\xF7\x36\xB8\x91\x00\x07\xFA\x24\xB0\xA8\xAA\x2C\x01\x06\xB6\x3D\x2F\xF1\xB4\xB5\x8D\x7C\xB2\x02\x68\xDF\xAF\x5F\x6A\xB7\xAD\x2E\xF6\xB7\xF3\x1C\x0F\x0E\xBE\xA0\xCF\x30\x6F\x95\x03\xF2\xB7\x81\x1C\x21\x05\x7E\xBD\x97\x26\x7A\x09\x6C\xD5\x64\x41\xB6\x34\x02\xDC\xB7\xED\x11\x87\xBD\x34\x4E\x02\x41\xB6\x6B\x01\x01\xB9\xD9\x1F\x49\xA1\x0E\x50\x04\x01\x6D\xEE\x00\x87\xB6\xA3\x1E\xC7\xB7\x16\x62\x09\x01\xDA\xB2\x01\x11\xB8\x23\xB7\x29\x3D\xD0\xB6\x0E\x08\xC1\xAA\xD9\xA4\x59\x16\x01\x41\xB6\x3D\x01\x07\xB8\x66\xBD\x2A\x78\x04\x01\x6D\xFE\x00\x0A\xB8\xAA\x1E\x63\xB5\x55\x6A\x09\x01\xDA\x81\x02\x23\xB8\x3E\xB7\x5B\x60\x27\x01\x68\xB5\x08\x10",
			"\xE1\xAB\x69\xF9\x5C\x9E\x01\xA0\xB5\x22\x06\x86\xB0\xA7\xAD\x95\x60\x02\x41\xB6\x8D\x00\x1E\xB9\x9D\xB1\xCF\x52\x0A\x01\xDA\x91\x02\x42\xB8\x59\xB7\xC1\x85\xD0\xB5\x12\x02\xC4\xA0\xDB\xA1\x5B\x41\xB6\x99\x00\xEE\xB6\xD1\x1C\x6C\xA8\x0A\x01\xDA\x9E\x02\x42\xB8\x6D\xB6\xD5\x2A\x2A\x01\x68\xB2\x0A\x09\xE1\x8E\x3D\x3E\x87\xF6\x2D\xA0\xB5\x29\x02\x8A\xBF\xF1\x15\x8E\xAB\x52\xC1\xB6\xAA\x00\x21\xBA\xE0\xB6\x36\x20\x0B\x01\xDA\xAE\x02\x42\xB8\xA5\xB4\x05\x26\xFB\x6B\xDC\x22\x0B\x04\xE3\xAB\x6A\xE4\x2C\xB4\x01\xA0\xB7\x2D\x02\x88\xB7\xB9\xB7\x3B\x81\x6D\xBB\x01\x42\xB8\xCF\xB6\x6D\x20\x17\x01\xB4\xBF\x05\x36\x71\xBB\xB5\xF8\x8D\xA0\xB4\x31\x07\x90\xB0\xAC\xAC\x0E\x7C\x02\x41\xB6\xC9\x00\x46\xB9\xB1\xB6\x04\x71\xB4\xAE\x06\x12\x72\xCB\xB5\x9D\x4C\x60\x01\xD0\xB3\x1A\x02\xC4\xB0\xD6\xB1\x29\xC1\xB6\xD7\x00\x21\xB9\xB5\xB4\x70\x91\xB4\xBB\x06\x02\x71\xDB\xB5\x3D\x2E\x63\x01\xD0\xB7\x1B\x02\xC4\xB0\xDE\x8F\x69\xC1\xB6\xE3\x00\x21\xBB\xF5\xB2\x41\x2A\x0C\x01\xDA\xA7\x03\x5C\xB7\x6B\x1F\x84\x03\xF7\xB1\xE7\x81\xBE\xB6\xAF",
			"\x24\x6F\xC8\x95\xFC\xB7\x82\x21\x2E\xB9\x5F\xB0\xAD\x3A\x06\x01\x73\xB6\x23\xC3\xB9\xDC\x1D\xFE\xB0\x92\x17\xCC\xAA\x90\x09\x73\xB0\x03\xCB\xB8\x57\x19\x33\xBF\x3C\x3F\xF1\x1F\xDF\xAD\xCA\x72\x01\x41\xB6\x76\x02\x17\xB9\xEF\x1F\xF1\x11\xD8\xBE\x4B\x74\x01\x41\xB7\x77\x03\x36\xBC\xEF\x1F\xF1\x17\xD8\xB7\xC2\x76\x01\x41\xB6\x79\x03\xE1\xB1\xF2\x13\xC1\xA0\xB8\x78\x03\x41\xB6\xF6\x01\x75\xB9\x06\xBA\x69\x91\xB4\xBA\x07\x32\x73\x9E\xB8\x3D\x2E\x7E\x01\xD0\xB6\x1F\x07\xCF\xA4\xE1\xB7\xC2\x7E\x01\x41\xB6\x01\x03\x4F\x45\xEA\xAE\xF8\x0B\xE1\xB7\xC2\x00\x00\x2A\x38\xC4\x25\x01\x03\xA0\xBF\x7C\x31\x7C\x14\x38\xFA\x75\x09\xBB\x8D\x00\x43\xBD\xF0\x18\x43\x69\xC5\x04\x00\x11\xBA\x3D\x03\x89\xBB\xE7\x1D\x69\xBD\x5C\xB8\xE8\x85\x05\x1A\xBA\xA1\x1E\x12\x9F\xBE\x38\x01\x0E\xD1\xA7\x0B\x20\x74\x85\xBA\x29\x9D\x7D\x3E\x02\x05\xA4\xBA\xAF\x27\xE9\x9C\x73\x8B\x6E\xAC\x42\x06\x00\x4B\xBE\xDE\x83\xD0\xA0\xB3\x11\x3E\x64\xA6\x0E\x01\x99\xB8\x42\xBE\xA5\xB4\xCE\xBD\xAA\xB9\xB9\x10\x00\x3A\xBA\x13\x03\x40\xBE\x1E\x21\xF9\x15\xDB\x87",
			"\xA3\x3A\xBA\x29\x01\x9A\xB8\x45\xBB\x6F\xBB\xEF\x34\x00\x3A\x74\xAE\x00\x3C\xBA\xB3\x2F\xC7\x1B\x8D\xB2\x5C\x3A\xE9\xB2\x00\x51\xBA\x91\x1F\x38\xB8\x72\x2A\xA7\xB6\x03\x0A\xEA\x9B\x74\xDD\xAC\xFB\x3C\x0D\x02\x4E\xBB\x07\x08\xD5\xBF\x78\x3D\x71\xBC\x2A\x1B\x70\x44\xA5\x59\xBD\x8A\x96\x4F\x5E\x00\x3A\x74\xC3\x00\x5E\xBB\x90\xB8\x22\xB9\xCC\x6A\xD3\xA8\x02\x31\x75\xA8\xBA\x8D\xB9\x3C\x5E\x08\x02\xA7\xBD\x04\x17\xEB\xAF\x74\x81\x8C\xE1\x40\x12\x02\x4E\xBA\x0A\x0E\xD7\xBD\xE9\xBB\x2C\xEF\x2D\x26\x00\x9D\xBB\x15\x03\xAD\xB8\x74\xAC\x0D\x68\x00\x3A\xBA\x5B\x00\xC6\xBB\x1F\x9C\x35\x4A\x02\x1A\xE9\x9F\x01\x12\xBB\x07\x7A\x92\x52\x4E\xBB\x0C\x08\xD9\xBA\x86\x2B\xA4\x3A\xBA\x67\x01\xCE\xBA\xD9\xAA\x26\x5A\xD3\xAB\x03\x05\x76\x99\x35\xDE\xB7\x5C\x7E\x0A\x38\x2E\x9C\x22\x32\xB5\x11\x73\x86\x02\x38\x00\x15\x3B\xBD\xB3\x45\x2F\xF1\x07\x00\x2F\x76\xAA\x3F\xB2\xBA\x2B\x2D\xF0\x2F\xB6\xB2\x10\x08\x02\x39\x76\xF0\x2C\x1F\x1E\x24\x3E\x68\x57\xB7\xB4\x66\x26\x00\x1F\x3C\x07\xB5\x9D\x4C\x2C\x02\x0A\x3C\xB9\x66\xDB\xA8\xB5\x0A\x43",
			"\xCB\xBB\xB1\x20\x04\x00\xDB\x1C\xB7\xB0\x13\x50\xEE\xBE\x4B\x42\xBB\x72\xBA\x09\x5E\x75\xBC\xCC\x28\x7C\x3F\x74\x08\xDB\x5B\xBB\x3D\x2F\xEE\xB9\xBB\x2C\xBA\xB0\x00\x1D\x02\x2A\x70\x5B\xB2\xD7\x03\xDA\xB8\x79\xB8\x0C\x07\xDE\xB1\x85\x22\x77\x82\x02\xD2\xBA\x72\x6D\x7B\xBE\x5F\x2F\xDE\xB5\x0E\x24\x77\xE6\x00\xF3\xBA\xC3\x85\x35\xB9\x15\x3B\x83\x79\x72\x91\x75\x8B\x00\xDD\xB8\x84\x7A\x4E\xBC\x0E\x0F\xDF\xA5\xE7\x8D\x9D\x3A\xBA\x78\x01\xD3\xB8\x80\xBF\xF2\xA6\xD1\x7A\xE9\xBD\x01\x0A\xBC\xF3\xB8\x1E\x5E\x4E\xBA\x10\x00\xE1\xB8\xE7\x9F\xBF\x3A\xBA\x87\x01\x0A\xBE\x3F\xBA\x23\xAA\xD3\xAC\x04\x05\x78\x86\xBA\x00\x6F\x3B\x02\x4E\xB8\x12\x0A\xE1\xB1\xE1\x80\xDC\x42\x70\xEB\x53\x12\xBF\x0D\xBC\x25\xAA\xD3\xBA\x04\x2A\x78\xBD\xB8\xB7\x61\x3E\x02\x4E\xBF\x13\x0F\xE2\xA3\xE2\xAD\xCA\x7F\x00\x3A\xBA\x52\x01\x8D\xB9\x89\xB2\x30\x3A\xE9\xA9\x02\x35\xBC\x4E\xB8\xDC\x2B\x20\x02\xA7\xBE\x0A\x03\xE8\x8D\x5B\x1F\x1E\x64\xA7\x42\x02\x4E\xBC\x16\x05\xE3\xB9\xE2\x88\x55\x07\x01\x3A\xBB\x5C\x03\x87\xBE\xE0\xA4\xE5\x5A\xE9\xBD\x02\x46",
			"\xBC\x1F\x03\x32\xB9\x2A\x33\x11\x0A\xD3\xA3\x06\x35\x78\xD4\xBA\x3C\x2B\x46\x02\x4E\xB8\x19\x05\xE3\xBA\xEA\x94\xED\x3A\xBA\xCD\x00\x2C\xBD\x4E\x07\xE3\x10\xB9\xA1\xD5\x11\x02\x3A\xBA\xD3\x01\x1A\xBF\x59\xBA\xB5\x23\x09\x1A\xE9\x98\x03\x35\xBC\x82\xB8\x05\x25\x25\x02\xA7\xBD\x0D\x0A\xF3\x8D\x5F\x12\xAB\xA4\x7A\x9D\xBB\x38\x06\xCF\xB9\x19\x1F\x78\x2B\x6E\x80\x6E\x4F\x71\x71\x2D\x3A\x04\xD0\xB4\x1B\x1F\x78\x32\x6E\xB7\x61\x9B\x00\x9D\xBB\x3B\x04\xD1\xB9\x1D\x1F\x78\x39\x6E\xB3\x74\x3A\xBB\x7A\x01\x8D\xBE\x93\xB5\x10\x3F\x04\x3A\x74\xFA\x01\x35\xBD\x51\xBB\xFB\x29\x14\x0A\xD3\xBF\x07\x35\x78\xA8\xB9\xEF\x2F\x51\x02\x4E\xBC\x00\x07\x15\x59\xD4\x19\x79\x8C\x99\xD2\x7A\x9D\xB9\x02\x05\xD5\xB0\x66\x2B\xF0\x9D\x2D\xAC\x43\xA7\x00\x9D\xBA\x03\x05\xD5\xB3\x6B\x2D\x00\x3B\x77\xD0\x35\xA9\x00\x9D\xB8\x05\x05\xD5\xBF\x7C\x3E\xF5\xAE\x65\xAC\x43\xAB\x00\x9D\xB8\x06\x04\xD8\xB3\x12\x06\xF0\x90\x6B\x2D\x01\x3A\xBA\x0E\x00\xAD\xBD\xD9\xBC\xE0\xBD\x34\x6F\x02\x3A\xBA\x21\x01\x69\xBD\x4F\x01\xC2\xBC\x81\x41\xEA\x9A\x7B\xD7\x02",
			"\x1F\x1F\xFF\x9A\xA7\x8A\xA7\xBB\x02\x1F\xF6\x9D\x06\x1F\x1E\x41\x9E\x32\x2D\x2D\x02\xA7\xB0\x03\x0C\xF6\x9B\x7B\xA0\xBC\xCA\x71\x2E\x73\xB8\x2C\x06\x06\xEE\xB8\x0D\x1F\x3C\x0F\xBA\x7D\x33\x5C\x02\x4E\xB9\x07\x05\xEF\xBD\x0E\x1F\x3C\x46\xB6\xD3\x90\x9D\xBA\x0F\x05\xDF\xBE\x20\x1F\x78\x08\x5F\xEF\x2F\xBD\x01\xB7\xB8\xC1\xBE\xD8\xBC\xAD\x9C\x13\xB5\x75\x8B\xBE\x1F\x1E\x1E\xBC\xBD\x3C\xAF\xB0\xF1\xB0\xE9\x92\x33\x83\xBB\xBC\xBC\x6A\xBE\xB2\x9D\x9B\x9A\xD3\xB8\x02\x15\x7C\x99\x6E\xB6\x44\x9D\xB9\x17\x06\xDD\xB0\xEE\xA0\xE3\x83\x64\x49\x01\x3A\xBB\x30\x01\xC6\xBF\xDD\xBB\x56\xBA\xD5\x60\x76\x9F\xBE\x03\x02\x30\xBE\x6A\x2D\x19\x0A\xD3\xAC\x03\x30\x7C\x82\x02\x66\xBC\xA4\x2B\x33\x02\xA7\xB1\x07\x0B\xF9\xA5\x7C\xFE\xAA\x03\x33\x68\x02\x4E\xBF\x0E\x07\xF3\xA1\x08\x33\x79\xC8\x2A\xD3\x00\x9D\xB8\x1F\x05\xE8\xB9\x31\x33\x75\x6B\xE1\x6B\x4F\x3E\xBF\x73\xBC\xA0\xBC\x8A\x58\xE1\xB1\xFA\xB6\x7B\xA3\x84\xEF\x2D\x6C\x02\x4E\xBD\x11\x06\xF5\xBE\xF7\xAA\x31\x80\x6E\xDB\x00\x9D\xBB\x24\x05\xEB\xB5\xF0\xA6\xAD\x9F\x0B\xBA\xBA\x99",
			"\x00\xA6\xBC\xA7\xBE\x36\x2F\x0D\x1A\xE9\x9E\x02\x4C\xBE\xA2\xBC\xF0\x31\x38\x02\xA7\xB3\x0A\x0C\xFA\xA8\x7A\xE0\x33\xE3\x00\x9D\xB8\x2A\x04\xE9\xBE\xCA\xA5\x88\x25\x03\x3A\xBA\xAD\x00\xA6\xBF\x2C\xBC\xA7\x27\x0E\x1A\xE9\xB2\x02\x64\xBE\x32\x25\x9D\x00\x79\xB9\x1D\x0B\xDA\xB1\x85\x09\x7E\xC5\x02\xE4\xBB\x77\x00\x71\xBD\xE7\x2F\xF8\xA1\x0B\x24\x77\xF7\x01\x93\xBF\xF7\x2E\xF5\x2C\x46\xBD\x2A\x7F\x07\x3A\x74\xB8\x01\x24\xBF\xAD\x01\x80\xB8\x71\x44\xD5\x31\xE1\x61\x7E\x87\x02\xCE\xBD\x7D\x3F\x00\x05\xF4\xB6\x86\x04\xF8\x9B\x7E\xF9\xB2\x5A\x62\xD6\xBF\xD3\x26\xF5\xBC\xED\xA1\x8B\x72\x7E\xFE\x14\xB4\xBE\x0B\xBC\x78\x31\x01\x07\xFB\xA9\x56\x39\x7E\x9B\xBC\xCA\x71\x05\x01\xEF\xBC\x34\x87\xFA\xA1\x0D\x1F\x3C\x30\x83\xCC\x43\x06\x03\xF0\xB9\x20\x08\x0D\x1F\xFD\xA6\x78\xCA\x71\x0F\x01\xE5\xBC\x15\x1E\xF9\xBB\xE2\xB7\x85\x51\x00\x52\xBF\xE2\x00\xEA\xBC\x8C\xB8\xE0\x63\x01\x12\xFE\xA7\x03\x5A\xBF\x36\xBD\x7D\xA6\xF4\xBC\x1D\x00\xFE\xB2\xF8\xB0\x11\x52\xBF\xF1\x00\xF0\xBD\x90\xBF\xF9\x19\x01\x12\xFE\xB6\x03\x64\xBE\xAF\xBF",
			"\x68\x9E\xF0\x5A\xFA\xBC\x0F\x00\xFF\x8E\x79\xB8\x2B\x1D\x00\xE9\xBD\x00\x06\x29\x4F\x7C\x31\xFF\xA9\x7F\x33\x5D\x90\x71\x71\x2D\x01\x06\x29\x43\x6B\x3E\xFF\x8D\x63\x29\x31\x21\x00\xE9\xBF\x02\x06\x29\x40\x66\x26\x00\xCD\xD7\x53\x5A\xD2\xBE\x08\x00\x03\xC5\x30\x0F\xF1\x19\xF9\x88\x90\x52\xBF\x15\x00\x02\xC0\x05\xC7\x8E\xBD\x73\x27\x01\x12\x7F\x9B\x00\x13\xC1\x93\x02\x59\xBF\xCA\x42\xFD\xA0\x01\x21\x80\xC1\x02\x9D\xB7\x59\x5F\x0A\x02\xFA\xB5\x02\x1A\x00\xE2\x80\xD3\xBE\x23\x3A\xE9\xBF\x0A\x06\x05\xC8\x02\xD8\xFA\xB4\xAB\x52\xBF\x31\x00\x1A\xC2\xE8\xBF\xEB\xBA\x8C\x71\x01\x12\x7F\xB7\x00\x3A\xC0\xD4\xBE\xD9\xBC\x39\x43\x03\x12\xFE\xBD\x00\x27\xC0\x3B\xC1\xC6\xBA\xD4\xA2\xFA\xB2\x04\x08\x02\xC2\x81\xC4\xB7\xF6\x49\x1B\x02\xF4\xBF\x08\x0E\x04\xC6\xFE\xA2\x68\x9D\x4D\x39\x00\xE9\xBC\x13\x05\x0A\xCC\x1B\x1F\x78\x3D\x7D\xB6\x23\x3B\x00\xE9\xBD\x14\x04\x0B\xCE\x00\xC3\xFC\xAA\x56\x20\x71\x03\xAD\x20\xC2\x42\x07\xE3\x1C\x00\x04\xEF\xBF\x00\x54\x3A\x70\x92\x08\x03\xC7\x19\x02\x04\xDE\xA5\x02\x14\x75\x33\xBB\x5D\x03\x8F",
			"\x1E\x04\x04\xBC\xBD\x04\x17\x03\xF1\x42\x74\xC0\x2C\xBF\x70\x41\x15\x04\xAA\x3C\x5C\x7B\x03\xEF\x80\xFB\x3D\x56\x00\x42\xC1\x2C\x26\x07\x2A\xF8\xB0\xD6\x17\x01\x0A\xC1\xFE\x24\x46\xC0\xE4\xB8\x5A\x38\x05\x14\xEA\x28\x77\xA8\x03\x7A\xC0\xF2\xBB\x16\x06\x12\xC1\x0B\x34\x00\x3F\x7A\xFB\x3D\x5E\x00\xE9\xBC\x17\x04\x0B\xCE\x09\xC7\xF6\x9C\xA7\x52\xBF\x61\x00\x52\xC1\xEA\xBF\x93\x62\xFD\xA6\x03\x2A\x81\xAA\x03\x1F\x1F\x76\xBA\x32\x74\x0C\x02\xFD\xAC\x03\x2F\x82\xA5\xC1\x9E\xAE\x7B\x4A\x19\x02\xFA\xB2\x07\x17\x05\xE1\x7B\xF9\x37\xD2\xBE\x3C\x02\x2F\xC6\x0C\x81\x0E\x4A\x03\x12\x7F\xFE\x00\xAA\xC0\x78\xBD\x2C\x24\x0D\x02\xFD\xA3\x04\x03\x83\xEE\x67\xD7\x3A\xE9\xBD\x22\x07\x19\xC5\xD1\xB0\xD6\x30\x01\x52\xBF\x8F\x00\x6A\xC2\x40\x07\xE0\xB0\x9E\x32\x03\x12\x7F\x95\x01\xDA\xC1\x75\xA5\x7A\x3A\xFA\xBB\x09\x01\x07\xEA\x62\x0E\x9C\xD2\xBF\x50\x02\x39\xC3\xFD\xB3\xF0\x1D\xC5\x4B\x08\xCE\x42\x65\x2E\x5C\xC2\xFC\xBC\x78\x92\xFD\xAE\x05\x26\x83\xF7\xBF\xF3\xB6\xE9\xBC\x2D\x01\x19\xC4\xE5\xB9\x73\x7E\x01\x52\xBF\xB9\x00\x78\xC3",
			"\x44\x02\xCB\xBE\xE0\x32\xFE\x80\x03\x66\xC1\x32\xBE\xA4\x2A\x20\x02\xFA\xB6\x0C\x06\x07\xD6\x80\xC8\x6C\xD2\xBE\x66\x02\x40\xC1\x26\x0C\xE6\xB9\x52\x92\x7F\xD3\x01\xE6\xC1\xA3\xBC\x6E\x28\x11\x02\xFD\xB9\x06\x26\x83\xF9\xBC\x3C\x2A\x45\x02\xF4\xBF\x1B\x03\x11\xCB\x0A\x1F\x3C\x25\xB7\x55\x64\xE9\xBE\x39\x05\x24\xC5\x16\x06\xF4\xA9\x62\x0E\x01\xD2\xBF\x76\x00\x4B\xC2\x2F\x0E\xE8\xA9\xC5\x10\x02\x52\xBF\xF4\x01\x99\xC3\x63\x06\xD2\xB9\x8A\x32\x04\x12\x7F\xFB\x01\xE6\xC1\xB5\xBE\x82\x24\x12\x0A\xFF\xBE\xC9\x28\x77\x14\xC2\x20\x87\x90\x66\xF4\xBF\x00\x06\x14\xDB\xB5\x03\x84\xD7\xC0\x62\x3C\xE9\xBD\x03\x05\x29\xC3\x6B\x32\x07\xCF\x6F\xE8\x3C\xD2\xBF\x09\x00\x55\xC7\x29\xC7\xEB\xB6\x27\x5C\x02\x52\xBF\x19\x01\xA6\xC1\xD9\x2E\x02\x0F\x09\xC1\x07\x5E\x02\x25\xC0\x4D\xC2\x30\x2C\x59\xC6\x14\xCA\xC4\x8C\x01\xE9\x85\x97\x02\xAB\xC0\xE3\x6E\xF4\xBA\x05\x0B\x15\xD4\x16\x31\x82\xA9\x31\xA4\x00\xE9\xBC\x0C\x05\x2E\xCD\x5B\x15\xFD\xB6\x93\x26\x01\xD2\xBE\x1B\x00\x5F\xC6\xA9\x1F\x0B\xD0\xD6\x28\x02\x52\xBF\x3C\x01\xC1\xC0\x13",
			"\x08\xDD\xB1\xC5\x2C\x02\xEF\x85\xF6\xC2\xCA\xC0\x7F\x24\x2B\x03\x0A\xCA\x18\xD9\x1F\x37\x7B\xD5\x32\xD2\xBF\x26\x01\x65\xC4\x91\x0F\xEF\xBA\xF5\x12\x7F\xD3\x00\x9B\xC3\xB5\xC1\xBE\x6C\x23\x92\xFD\xB9\x02\x21\x86\x9F\x1E\x53\xB7\xBE\x32\x36\x75\x57\x37\x1A\xD3\xBE\xA6\x1B\xD2\xBF\x65\x01\xD6\xC1\xF6\xAD\x26\x92\xFD\xAB\x03\x22\x85\xF0\xC2\xDF\xAE\xCA\x68\x2F\xC2\x36\xC4\x7E\xBF\xC0\x41\x83\x8F\xC3\x7D\xC2\x93\xBE\x51\x92\xFA\xBD\x07\x17\x0D\xD0\x86\xAD\xBE\xCC\x42\x60\x02\xF4\xBC\x10\x0C\x1B\xD8\xBF\xA9\x62\x42\x01\xD2\xBE\x45\x01\x73\xC7\xFF\xA6\xCA\x32\xFE\x90\x02\x46\xC3\xC1\xC2\xA0\xBD\xA8\x36\x18\x02\xFD\xB7\x04\x13\x87\x8D\xB0\xA9\x30\x64\x02\xF4\xBD\x13\x0F\x1D\xC0\x09\xC2\x12\xD2\xBF\xA3\x00\xEC\xC0\x61\xC0\x06\xC9\x73\x92\xFE\xAA\x02\x6A\xC3\x8B\xC2\x1B\xC1\x15\x92\xFA\xB1\x0B\x10\x0F\xD6\x86\xBC\xC0\xB1\x20\x68\x02\xF4\xB8\x17\x06\x1F\xDC\x0C\xC3\x81\xB5\x9E\xD2\xBF\x5F\x03\x77\xC2\x28\xCC\x53\x34\x06\x12\x7F\xC5\x01\xDF\xC3\xB8\xBE\x5A\x9A\xFA\xBB\x0C\x1F\x0E\xF7\x7D\xFD\x32\xD8\x00\xE9\xBD\x34\x07",
			"\x3B\xCF\x05\xCA\x90\x1A\x03\x52\xBF\xD7\x01\xEF\xC2\x19\xC0\xA9\x2C\x0D\x12\xFE\x9D\x03\x7D\xC3\x50\x3C\x01\x04\x79\xBE\x1B\x00\x07\xD1\x85\x21\x88\xD3\x27\xE4\xBA\x72\x02\x1F\xC1\x60\xAF\xF1\x03\x01\x24\x77\xEC\x01\x2B\xC4\x32\x2F\x89\xC2\x20\x04\x02\x04\xEF\xB4\x03\x31\xC4\x3D\x2F\x19\xC5\x40\x06\xCA\x30\xAD\x3C\x07\x38\x88\xEF\x2F\x3A\xC4\x00\x02\x09\x04\xBC\xB4\x00\x17\xC7\x78\x81\x9F\x08\x1F\x1E\xFA\x2F\x4C\x76\x48\xC4\xAD\x25\x0B\xEC\x86\x14\x00\xF7\x71\x86\xB4\x70\xC3\x20\x08\x01\x03\xFD\xBB\x7B\x16\x00\x51\xC5\x54\x1B\x94\xC2\x20\x05\x25\xC4\xA2\x90\x6B\x18\x00\x59\xC5\x68\x1B\x66\xC5\x4B\xC0\xFB\xB6\x27\x5A\x00\x61\xC4\x9C\xAF\x31\xC6\x5F\xC5\xD3\x4C\x01\x08\x13\xC3\x04\x7A\x01\x6A\xC4\xDD\xBD\x5F\x36\x03\x0E\x26\xD9\x11\x7B\x3B\x81\x02\x64\xC4\x5C\x95\x8A\x4D\x4E\xC9\x6A\x35\x0B\x60\x59\x79\xC4\x61\xB5\x7D\x3E\x08\x04\x4F\xCA\x20\x15\x0B\x73\x5A\x00\xC5\xBB\xAF\xC0\xB8\xA1\xC1\x02\x06\x28\xCC\x08\x08\x8A\xC2\xAF\x10\x52\x42\xC7\x05\x05\x51\xC2\xAF\x26\xF8\x9D\x74\x04\xC5\x1D\x00\x4A\xC5\xE7\x58\x35",
			"\xCE\x66\x64\x14\xE3\x00\x1A\xC5\x54\xC5\x88\xBD\x2A\x34\x05\x04\x28\xC9\x01\x20\x8A\xDC\xC4\x1F\x1E\x76\xC0\x8F\x0C\x50\xCF\x02\x15\x0B\x65\x5D\x0F\xC5\x64\xA6\x18\x00\xA1\xC6\x06\x07\x2A\xD8\x13\xDF\x3C\x78\xC1\xAA\x36\x42\xC4\x0F\x06\x4F\xCE\x28\xDF\x78\x06\x75\xCC\x43\x34\x00\x42\xC5\x10\x06\x55\xCD\x2B\xD2\xBF\x8C\x87\x36\x00\x84\xC4\x24\x01\xAD\xC0\x00\x0F\x28\xC9\x08\xE5\x68\x04\xC5\x4E\x01\x65\xC7\xA3\xC7\x21\xC3\xF0\x1A\x01\x04\x8A\xD4\x00\xC4\xC5\x4A\xC4\x07\xC7\xFD\x2C\x03\x04\x14\xDB\x01\x52\xC5\x23\xC0\xB3\x50\xA1\xC1\x0C\x00\x2E\xCC\xEB\x9D\x9A\x40\x00\x84\xC5\x33\x01\xB6\xC3\x53\xCC\x1E\xCC\x0E\x42\x01\x04\xC5\x6E\x01\x75\xC5\xA8\xC2\x3E\xCC\x1C\x44\x02\x04\x8A\xF5\x00\xF2\xC4\x54\xC4\x7E\xC3\x69\x74\x28\xDC\x03\x39\x8B\xB6\xC5\xFF\xC3\x56\x64\x12\x04\x50\xC3\x08\x05\x17\xCA\x81\x9D\x4D\x4A\x00\x42\xC5\x22\x06\x60\xC3\xD9\xB2\xF8\x44\x8A\x8F\x01\x0C\xC7\xCC\xBB\xBE\x3E\x09\x04\x28\xD5\x04\x11\x8C\x9E\xBB\xA2\x52\x42\xC7\x26\x07\x62\xC3\xDA\xBB\xF7\x12\x01\x04\xC5\xA1\x01\x7F\xC4\x00\x03\x48\x21",
			"\x1D\x04\xEF\x94\x01\x77\x71\x70\x92\x92\xC4\xF7\x24\xBC\xBA\x05\x0C\x12\xFE\x4B\x2A\xC6\xD9\x26\xF2\xBA\x18\x06\x65\xC4\x66\x30\x19\xF4\x88\xE4\xBB\x6A\x00\x9A\xC5\xCF\x2E\x66\xCB\x23\xC4\xEF\xB2\x01\x3A\xC6\xF0\x35\x8F\x1F\x90\xC6\x2B\xB0\x34\xC0\xCF\x3C\x8C\x89\x27\xE4\xBA\x41\x01\xD1\xC5\x2F\x3A\x01\x0E\x12\xD5\xB0\x04\xC5\xA8\x00\x5E\xC5\x42\x05\x69\xCC\x16\xCF\xB7\x37\xE4\x47\x8E\x52\xC6\x83\x00\xD5\xC4\x81\xBC\x1A\x4E\x04\x04\x8A\xB2\x01\xCB\xC5\xAD\xC4\x92\xB7\x16\x60\x09\x04\x14\xF8\x02\x61\xC6\x6B\xC5\x7A\x30\xA1\xC6\x17\x08\x36\xD2\x13\xC5\x44\x14\x01\x84\xC4\x62\x01\xDB\xC0\xF8\xB1\x0B\x36\x04\x04\x8A\xCA\x01\x59\xC7\x81\x02\xD8\xC1\x50\xC1\x0E\x58\x04\x04\x8A\xCF\x01\x73\xC7\xE7\xBE\xD4\x7C\x50\xC5\x0D\x01\x1C\xD5\x7F\x86\xA3\x84\xC5\x6D\x02\xE1\xC3\xFB\xBA\x8C\x7E\x04\x04\x8A\xE1\x01\x8B\xC7\xF0\xBC\xC0\x68\x14\x04\x28\xC7\x07\x11\x8E\xE6\xBF\xA2\x00\x42\xC5\x3B\x01\x72\xCA\x2A\xD1\x27\x04\x8A\xF3\x01\x22\xC7\xBD\xC4\xA2\xB1\x1C\x46\x0A\x04\x14\xFA\x03\x11\xC7\xB8\xC4\x7E\x08\xA1\xC0\x00\x01\x24",
			"\x4C\xE4\x1D\x3F\x3E\xC5\xB3\x5C\x55\x00\xA1\xC5\x00\x0D\x3A\xC7\xBC\x3A\x8D\x84\xC2\x67\x80\x42\xC4\x03\x05\x76\xCE\x14\xD3\x1A\xD3\x75\xD5\x32\x84\xC4\x09\x00\xEF\xC3\xD6\x22\x3A\xC9\xDC\x89\xD6\x04\xC5\x18\x00\xDE\xC5\xD9\x2D\x78\xCD\xE6\xAC\x0E\x72\x02\x04\xC5\x1F\x01\xE1\xC7\xEB\xC7\xB6\x7E\x38\x64\x14\xE5\x00\x52\xC7\xBE\xC6\x73\xC7\x5B\x34\x50\xCB\x02\x0A\x1E\xD3\x8F\xF3\xBA\xCC\x42\x5C\x00\xA1\xC2\x06\x0E\x3D\xD9\x1E\xD6\x4B\x8D\x5D\x84\xC5\x1C\x01\xF9\xC2\x6B\xC5\x13\xD0\xD6\x3C\x02\x04\xC5\x40\x01\xF5\xC7\xED\xC1\x60\xC8\x4D\xA4\x14\xC7\x01\x58\xC7\xEC\xC6\xDF\xB5\xA8\x30\x18\x04\x28\xCD\x02\x38\x8F\xF3\xC7\x50\xC1\x4E\x4E\x30\x04\x50\xC3\x05\x1F\x1F\xC2\x68\x1F\x1E\x0F\xC4\xC5\x94\xA1\xC1\x0B\x06\x40\xC1\x08\x05\x8F\x95\xC4\x3C\x2A\x63\x00\xA1\xC7\x0B\x0D\x40\xC0\x00\x05\x8F\x9B\xC4\xB8\x2B\xA9\x70\xF7\x4A\x7E\xC4\x75\x3F\x78\x1F\x5F\x53\x5D\x28\xC6\x80\x37\xC7\x1A\x04\x04\xDE\xB0\x06\x0B\x8D\x85\x22\xE6\x2F\xCB\x34\x79\xBB\x38\x79\xB8\x96\x8D\x29\x90\x83\x02\x35\xC4\x68\x34\x38\x07\x84\xCE\x42\xDF",
			"\x78\x3C\x88\x83\x59\x34\xC9\xF2\x2E\xD0\xC4\xBC\xB0\x0F\x19\x21\xFC\x54\x2F\xC8\xB1\x50\xF2\xB8\x3E\x06\x87\xCA\x5A\x3C\x00\x0E\x8D\x87\x72\xB3\x38\xC4\x24\x1B\x04\x77\xC0\x66\x26\x22\xD5\x8D\x86\x4C\x49\xC9\xD1\x38\x13\xC8\x7A\x21\x17\xD6\x27\x44\x00\x51\xC8\x8B\x63\x0A\xCA\x13\xCD\x4C\xCB\x43\x78\x22\xF6\xAD\x5A\xC8\x69\xC7\x81\x30\x02\x06\x8B\xC1\xF3\xA0\x23\xEE\x8D\xB6\x23\x0A\x00\x32\xC9\xF6\x6E\x8C\xC4\x37\xDE\x97\x0C\x00\x6A\xC8\xA0\x29\x29\xCA\xE0\x27\xF8\xB9\x8A\x2E\x00\x30\x91\xA6\x79\x6C\xC8\xC1\xC4\x62\x37\x8E\xC9\x09\x19\x23\xC7\x8E\xCA\x71\xED\x73\x71\x2F\x27\x06\x8F\xCC\x38\xDD\x04\xF7\x91\xA5\x01\x84\xC8\xC9\xC6\x32\x76\x02\x07\x47\xCB\x05\x09\x92\xE6\xBF\x18\x01\x3B\xC9\x2C\x01\x91\xCD\x39\xDA\x1A\xF7\x91\xB7\x01\x1C\xC9\x9D\x2C\x92\xBF\x02\xA7\x47\xDE\x05\x09\x92\xA9\xC7\x09\x02\x0F\x03\x1D\xCC\x18\x02\x47\xCB\xD9\x30\x8E\xA2\xA0\x77\xC9\x64\x01\x26\xCA\x69\x38\x3B\xC1\x07\x62\x00\x77\xC8\xD0\x01\x44\xCA\xB3\xC7\xF9\x14\x02\x17\x23\xD6\x03\x09\xC9\xD4\xC4\x86\x02\x09\x07\x8E\xCC\x0D\x0B\x25",
			"\xDB\x91\xD9\xA5\x1D\x3B\x3B\xCB\x38\x01\x91\xCA\x11\xCF\x7E\x2A\x00\x77\xC8\xE9\x01\x44\xCA\x79\xC0\xA9\x2C\x02\x17\x23\xEF\x03\x3E\xC9\x27\xC3\x59\x5E\x0B\x07\x8E\xC6\x0F\x10\x26\xF4\x8B\xF9\x5C\x02\x75\x71\x2D\x3F\x06\x9A\xC0\xD8\xB9\x49\x77\x91\x84\x00\x47\x45\xBB\x2F\x1C\xCC\x7E\xC0\x70\x74\x01\x37\x91\x8B\x00\xE1\xC9\xA3\xC2\x29\xCA\x7F\xC7\x2C\xD7\x23\xD1\x00\x69\xC9\xBD\xC7\x75\xC9\x00\xCF\x89\x77\x47\xD7\x00\x30\x93\xBC\x2D\x08\xC8\xAB\x53\x1D\xCD\x03\x07\x4F\xD4\x22\xF0\x7A\xF9\x5C\x3C\x01\x3B\xCB\x08\x05\x9F\xC3\x4E\xDD\x0A\xDD\x9A\x09\x74\x7C\x30\x78\xC9\xD9\x2F\x49\x25\x32\xD0\xD6\x00\x01\x33\x39\x70\x92\x86\xCB\xCA\xC5\x87\x83\xCB\x27\x12\xF6\x1B\xAD\xC4\xE4\xBA\x27\x01\x45\xCA\x6F\x3F\xF1\x11\x21\xC8\x82\x9B\xCA\x5F\x36\x1B\xC8\x79\xBE\x0B\x00\x52\xC4\xB3\x12\x94\x83\x02\x43\xC6\xE1\x8D\x49\xCD\xE7\x27\x52\xC1\x22\xC0\x86\x2B\xCA\xEF\x2E\x0F\x03\x11\xCD\x12\x37\x47\xD0\x01\x30\x93\xE0\x2C\x32\xCB\x27\xC8\xED\x7F\x8E\xC5\x03\x17\x29\xCF\x64\x55\xC8\x9D\x4C\x14\x77\xB8\x2A\x07\x04\x50\xDE\x9D\x37",
			"\x85\x80\x3C\x77\xC8\x20\x01\x51\xCC\x63\x21\x46\xC1\xA8\x77\x91\xC6\x00\x4B\xCB\xBD\x31\x61\xC3\xDF\x30\x08\x17\x23\xCC\x01\x51\xCA\xAB\x38\xC6\xC1\x85\x3F\x8E\xC2\x05\x1E\x29\xE1\x92\xF4\xC8\xD0\x34\x42\x03\x1D\xCF\x0A\x08\x55\xC2\xB8\x17\x86\xD0\x35\x86\x01\x3B\xC9\x17\x05\xAC\xC9\x53\xD2\xB7\x63\xE7\x77\xC8\x63\x00\xB6\xCA\xA5\xC1\x3D\x47\x47\xC9\x03\x32\x95\xA2\xBA\xF7\x7F\x3B\xCB\x1B\x07\xAE\xC9\xD2\xBA\xA9\x77\x91\xF5\x00\x7C\xCA\x17\x9D\x03\xBF\x8E\xCB\x07\x0A\x28\xFF\x94\xB9\xC3\xE7\x49\x3B\xCA\x20\x01\xB0\xCA\xE3\x93\xF2\x37\x91\x88\x01\x5E\xCA\xA3\xCA\x70\xC4\x39\x46\x09\x17\x23\xCD\x02\x06\xCB\x5F\xCA\x63\xC5\x9E\x9F\x8E\xC4\x09\x0C\x2C\xCE\x39\xE8\x3C\x77\xC8\x4D\x02\x67\xCE\x78\xCB\xEF\x3C\x04\x37\x91\xA0\x01\x98\xCA\xC9\xCA\x76\xC3\x88\x97\x47\xC7\x05\x23\x96\xC5\xC9\x03\x1E\x50\x03\x1D\xCD\x15\x03\x5A\xCB\x26\xD0\x5B\x77\xC8\xB3\x01\xD4\xC8\x53\xCD\x5D\xC9\xE7\x44\x05\x37\x91\xBA\x01\xBA\xCA\xA9\xCB\x35\xCC\xFA\x67\x47\xC1\x06\x01\x97\xD9\xCA\xFB\xC4\x32\x2E\x8F\x73\xDC\x28\x0C\x07\x2E\xE6\x95",
			"\xE4\xC9\xCA\x70\x55\x03\x1D\xCF\x19\x03\x5A\xC4\x10\xEA\x56\x2C\x01\x77\xC9\x6A\x03\x68\xCA\x41\xCD\x4F\x97\x23\xDB\x03\x23\xCB\x09\xC8\x36\xBB\x1D\xC9\x1C\x03\x5A\xD0\x20\xEA\x56\x32\x01\x77\xC9\x73\x03\x68\xC8\x83\xCF\xFC\x14\x05\x37\x91\xED\x01\xCE\xCA\x2A\x25\x43\xCE\xDC\x80\x51\xD9\xDD\x23\x90\xE4\xBB\xBC\x00\x98\xC9\xF0\x30\xA3\xC0\xAD\x24\x06\x3A\x97\xC9\x37\x1D\xCA\xF2\xB8\x33\x07\xBF\xCF\xBC\x22\x29\xE7\x21\x84\xCC\xD5\x37\x1D\xC9\xD7\x88\xC1\xCB\xBD\x29\x12\xE9\x88\x8C\xCC\xE1\x37\x99\xCB\x40\x34\x1D\x07\x47\xD4\x07\x11\x96\x83\x02\x20\x00\x2B\xC4\x7C\x4F\x8E\xC9\x0F\x17\x30\xFF\x15\xC0\xCA\xD7\x71\x3B\xCA\x3F\x05\xAC\xC9\x61\xD5\xF6\xAF\x5B\x72\x01\xDF\xC8\xA8\x47\xAC\x2D\xC4\xC9\x0B\xC3\xC7\x77\x91\x8A\x00\x2A\xCC\x86\x00\x8B\xCD\xF4\xAC\x1A\x56\x07\x37\x91\x90\x00\x31\xCC\xE4\x26\x56\xCB\xDF\x38\x0F\x17\x23\xD6\x00\x50\x46\x60\x2D\x19\xCC\xDF\xC4\x35\x4A\x0F\x17\x23\xDB\x00\x39\xCC\x06\x02\x21\xCD\xA2\xC1\x6A\x97\x47\xC1\x01\x08\x99\x98\xCC\x9D\xC2\x68\x36\x3F\x07\x8E\xC7\x02\x0F\x32\xDF\x98\x84",
			"\x98\xEE\xB5\x7E\x38\xE2\x25\x05\x06\x65\xC1\x08\x0A\x99\x8A\xC9\xB1\x20\x01\x02\x96\xCC\xBC\x1D\x65\xC0\x00\x1F\x99\xE6\xBF\x04\x01\x31\xCF\x04\x45\xCC\xCF\x65\xD5\x24\xED\x5B\x6A\xCC\x1B\x42\xA8\x45\xD9\x2F\xCB\xC4\x36\xA8\x00\x30\x99\xA9\x43\x6C\xCD\x5B\xC5\x2A\x32\x01\x07\x67\xDF\xA0\x00\x99\xB2\xCC\xA7\xC9\x25\x6D\x9F\xCA\x8C\x42\x67\xC0\x34\xDA\x96\xAD\x65\x0E\x01\x41\xCC\xA4\x31\xCF\xC9\xB0\x9E\x45\x4A\x9A\xDE\x00\x8C\xCC\x87\x95\x38\x42\x02\x0A\x68\xC4\x03\x05\x9A\xBA\xCC\xDB\xC4\xF0\x30\x05\x02\xD1\xCB\x06\x11\x34\xD9\x2C\xD7\xC4\x8A\xCD\x38\x02\xA7\xCB\x4D\x7F\x25\xCA\x34\xF7\x01\x17\xCD\x49\xCD\x68\xC9\x04\xA2\xD1\xCE\x07\x08\x35\xD0\x99\xC3\xCB\xB7\x60\x0E\x02\xA2\xCD\x10\x0E\x6A\xD7\x32\xDD\x93\xED\xBA\x8A\xCC\x46\x01\xAD\xCE\xCB\xCC\x13\xC2\x81\x8A\x9A\x93\x01\xA3\xCD\x07\x8D\x2A\x32\x04\x0A\x68\xD9\x04\x01\x9B\xC9\x96\x0A\x52\x45\xCF\x27\x07\xD8\xC1\x5E\xCA\x90\x26\x00\x0A\xCD\xA5\x01\x63\xCE\x79\xC8\xA9\x28\x02\x0A\x34\xEB\x02\x47\xCD\xEC\xCB\x81\x1E\x0A\x02\xD1\xC1\x0B\x1B\x35\xCE\xDE\x1E\xC8",
			"\xE4\xBA\x16\x01\x3F\x38\x2E\x9D\x7E\x33\x28\xFB\x7B\x32\x00\xFD\x38\x8B\xCB\xB7\xC9\x80\x44\xDE\xBA\x01\x29\x9B\xB1\x21\xE5\xCC\x18\xC8\x79\xBA\x08\x0F\x6E\xDE\x97\x31\x9B\xB2\x39\xE4\xBA\x25\x01\xBD\xC9\xC0\xAA\x60\xDE\x18\xFB\x9B\xF6\x37\x0E\xCD\x4B\x8F\xBF\xCF\xFD\x24\x42\xC7\x0E\xDF\xD2\x7D\x39\xCC\x6A\x17\xC6\xB6\xC4\x77\x58\x70\xD1\x85\x1E\x94\x80\xC8\xD6\x91\x86\xCC\x2E\x3F\xE3\x1F\x4B\xCC\x0D\x65\x01\x12\xCE\xE8\x39\x8F\x1D\x5B\xC9\x1C\x46\x06\x18\x38\xDD\x80\x9F\x1E\x5F\xCC\x7D\x7A\xC7\xCF\xFD\x26\x03\x33\x2F\xE1\x83\x68\x00\x23\xCE\xF0\x31\xC9\xCE\xDC\xC1\x0E\x49\x03\x3D\x73\x17\xC1\x2B\xCF\x98\xC4\xB4\x34\x0D\x0F\x72\xDA\x81\x81\x98\xD4\x4E\x35\xCE\x7F\x25\xCC\xC8\xDF\xC3\xDE\x39\x39\xDD\x6E\x7D\xCD\x23\x6E\x9F\xCD\xCF\x2B\xE7\xC0\x3F\x24\xEF\xB8\x01\x42\xCE\xEF\x2F\x14\x02\x84\xC9\x54\x3B\x07\x0A\x34\xF8\x02\x65\xCC\x4A\xCE\x9D\xC8\x73\x45\x0F\x0A\x68\xDE\x05\x10\x9D\xA0\xCC\x2A\x60\x45\xCC\x31\x06\xDB\xC1\x75\xDC\x22\xEF\x5B\x01\x01\x8A\xCD\x65\x00\xD7\xCD\xA9\xCC\x1C\x43\x04\x0A\x9A\xD2\x01\x63",
			"\xCF\x33\xC9\x52\x8A\xD1\xC9\x0D\x09\x3B\xED\x91\xE4\x2C\x87\x00\x45\xCC\x38\x07\xEA\xC1\x19\xC4\xB3\x09\x02\x0A\xCD\xE6\x00\xB7\xCE\x1E\xCF\x2F\x7A\x68\xCD\x07\x3A\x9D\xFF\xC8\x60\xA2\x45\xCC\x3D\x07\xEF\xC5\x48\xD4\xD8\x4A\x9A\xFB\x01\x84\xCE\x30\xCD\xEB\x72\xD1\xC2\x00\x12\x12\x65\x5D\x5D\xCE\xE2\x94\x68\x37\x24\x02\xD1\xC9\x00\x0E\x3C\xF9\x4F\x29\xC5\xA9\x31\x4A\x02\xA2\xC8\x02\x02\x25\x42\xBE\x10\x9E\x99\xA5\xEE\x48\x45\xCC\x06\x06\xF2\xC9\x10\x1F\x3C\xC1\x04\x20\xC9\xBB\x28\x45\xCF\x07\x02\x4A\x43\x6B\x26\x3D\xF9\x3D\xF0\x4F\x8A\xCD\x12\x01\xE7\xCF\xF2\xC7\x68\xD7\x85\x64\xEA\x63\x2D\x2D\x00\xD2\xCF\x89\x2F\x77\xCA\x7B\x6A\x34\xF4\x00\x3A\xCF\x1C\x39\x0A\xC0\xEC\x72\xD1\xCB\x03\x13\x3D\xE5\x9E\x95\xC2\xD0\x35\x51\x02\xA2\xCB\x08\x00\x7C\xDB\xDD\x21\x8B\xFB\x3D\xA5\x00\x45\xCE\x12\x05\xF9\xC8\x65\x29\x01\xD0\x6B\x27\x01\x8A\xCD\x28\x02\xF1\xCB\xF7\xCC\x5B\xCB\x11\x8A\x9A\xD9\x00\xDB\xCF\xE0\xCC\xAC\xC8\xE0\x6B\x0A\x0A\x34\xE1\x01\x61\xCF\xCE\xCF\xE4\xCB\x39\x8A\xD1\xC9\x06\x08\x3F\xD5\x9F\xD0\xCB\xB1\x21",
			"\x57\x01\xA8\xCC\xFA\xC1\xB6\x3F\x78\x16\x97\xC8\x2A\xB1\x00\x45\xCC\x1E\x04\xFE\xCE\x7A\xDC\x2E\xC3\x1B\x8A\xCD\x7F\x00\xFE\xCD\x3E\xCE\x77\x7A\x68\xC6\x04\x02\xA0\xFF\xC9\xAD\x65\x5B\x02\xA2\xCD\x11\x07\x80\xC6\x28\xDD\x6C\x0A\xCD\x94\x00\xF7\xCE\x94\x0B\xE9\xCC\x1C\x5B\x05\x0A\x9A\x9C\x01\xAC\xCF\x15\x0E\x86\xC8\x05\x5A\x68\xC2\x05\x19\xA0\xB0\x0C\x58\xCF\x50\x37\x2F\x02\xD1\xC8\x0A\x14\x3F\xEB\x00\x47\xCA\xFB\x3D\x60\x02\xA2\xCF\x15\x06\x82\xC4\x3B\xF9\xB9\x43\x01\x8A\xCC\x5B\x01\x0B\xD2\xED\xCC\x53\x25\x06\x0A\x9A\xBD\x01\x33\xD1\xB7\xCD\xCF\x2F\x18\x0A\x75\xDF\x40\xF5\x18\x60\xCA\x02\x8C\x45\xCE\x32\x01\x07\xDB\x77\xD1\x65\x8A\x9A\xD1\x01\x44\xD0\xC0\xCE\xBF\x25\x19\x0A\x68\xD8\x06\x09\xA1\x85\xCF\x64\x2D\x67\x02\xA2\xCF\x1B\x0F\x84\xCA\x3C\xF6\x0A\xF8\xCE\x55\xD0\xF3\xBF\x34\x05\xEF\xC5\x85\xCE\x33\xC6\x2E\x02\xCF\x12\xD1\x13\xD0\x62\xCE\x9E\x47\x0D\x0A\x34\xFC\x03\x55\xD0\xA8\xCF\xF9\x16\xA2\xCB\x00\x00\x2E\x53\xB5\x22\xA1\xFD\xC1\xAD\x65\x6D\x00\xE5\xC8\x5C\x42\x7C\x2F\x43\xD0\x17\xF6\x49\xDD\x00\x45",
			"\xCD\x04\x00\x5C\x45\x76\x36\x43\xCE\x87\x8D\x46\xA2\xCE\x3E\xD2\x06\xD5\x5C\x8A\x84\x4A\x3D\xF4\xA1\x83\xD1\xAB\xCB\x3C\x5F\x38\x02\xD1\xC7\x02\x02\x44\xE0\xA0\xD4\xC7\x9D\x4D\x72\x02\xA2\xCE\x05\x0E\x88\xDF\x41\xDA\x8F\xD3\x39\x8A\xCD\x1A\x03\x21\xD7\x11\xD0\x3E\xD9\x73\x69\x03\x0A\xCD\x3D\x01\x4D\xD2\x25\xD7\x7C\xC3\x90\x2B\x07\x0A\x9A\xC5\x00\xA2\xD1\x1F\x0D\xFB\xC3\xDF\x3D\x0E\x0A\x34\xCD\x01\x29\xD1\x44\x0D\x5E\xCF\xBE\x3F\x1D\x0A\x68\xD5\x02\x15\xA2\xAA\xD1\xEC\xC9\x3C\x5D\x3C\x02\xD1\xCC\x05\x17\x45\xF1\xA2\xC9\xC2\xCC\x43\x79\x02\xA2\xCB\x0C\x0E\x8B\xC9\x32\x03\xA0\xFB\x3D\xF5\x00\x45\xCE\x1A\x05\x18\xD3\x81\xC8\x40\xF7\xC2\x77\x01\xA1\xCC\x66\xD2\x1F\xD6\x7A\xB2\xFC\x3A\x3F\xF0\xA2\xCB\x0C\x36\x1E\xF2\xBB\x3E\x03\xDC\xC1\x0B\x3F\x92\x32\x18\x64\xBB\x01\x01\x90\x3A\xBA\xCB\xFF\x2C\x89\xD7\x67\x61\x74\x4C\x6B\x2E\x20\x7F\x1C\x79\xBA\x01\x07\x8E\xD1\x85\x29\xA3\xB7\x0C\xE4\xBB\x05\x01\x48\x3F\x12\xCF\x02\x14\x40\xED\x3F\xA1\x3A\x88\x26\x40\x00\x33\xD5\x1E\xD2\x75\xDF\xE9\xB8\xA3\xDC\x47\xFB\xD1\x10\xD0",
			"\x73\x42\x02\x0F\x8F\xC5\x86\x17\xA3\xAE\x65\x28\xD0\xEC\xA9\x41\xD6\x20\x06\x09\x07\x48\xFC\xA3\xAD\xCC\xEF\x2C\x0B\x03\x42\xD5\x26\x2E\x90\xD3\x2A\xE1\x83\x18\x00\x13\xD2\x17\x89\x45\xD4\x18\xC7\x8E\x59\x48\xC1\x04\x2E\x01\x01\xD3\xBA\xCE\xCC\x36\x23\xD4\x72\x9B\x48\xD0\x83\xD6\x9A\x24\xD3\x5E\x02\x49\xD5\x1A\xCC\x8F\x44\x49\xC5\x03\x2B\xD2\xDB\xC1\x61\xCC\x49\xD5\x19\x00\x93\xC2\x07\xD0\x6B\x24\x00\x24\xD3\x6A\x01\x4D\xD7\x1C\xC0\xAD\x26\x01\x24\xA4\xDD\x01\x3B\xD2\x2F\xD1\x40\x00\x05\x04\x92\xC5\x07\x20\x8B\x07\x04\x0F\xD3\x79\xC0\x65\xBC\x24\xDE\x0E\x1B\x49\xE9\xA1\x82\x02\x2C\x00\x92\xD2\x3D\x01\x24\xD0\x87\xCD\xF5\x64\xA4\xFD\x01\x47\xD2\x86\x01\x52\xD4\xA9\xB1\x0E\x50\x01\x24\xA4\x86\x00\xB4\x46\xDB\x2D\x42\x03\x2B\xDF\x59\xC5\x58\x64\xA4\x8E\x00\x61\xD2\x41\x53\xA3\x0A\xF8\xC8\xB3\xA4\x49\xD6\x00\x69\xD2\x48\xD2\xE4\xCC\xC6\x54\x24\xDF\x01\x09\x4B\xC2\x5F\x64\xD2\xE0\xC2\x68\x34\x0E\x04\x24\xD7\x02\x16\x4B\xDA\xA5\xD6\xCF\xFB\x3C\x1D\x00\x49\xD7\x05\x00\x97\xDF\x4B\xDD\x9F\xB7\x61\x3C\x00\x92\xD0\x0E",
			"\x05\x30\xD3\x96\xCE\x09\xE6\xA5\x24\xD2\x41\x00\xC6\xD3\x5A\xD2\xFD\xCF\x7E\x20\x02\x24\xA4\xCA\x00\x92\xD3\x20\x0E\x2C\xD6\x2E\x54\x92\xD3\x02\x3E\xA5\x8D\xD3\xB9\xD1\xD2\x8C\x49\xD3\x0B\x0F\x99\xD3\x4C\xF3\x93\xFE\x7D\x24\xD3\x31\x01\x69\xD2\x33\xD0\x15\xC3\xC8\x08\x01\x24\xD2\x6B\x01\xD5\xD2\xC7\x16\x0B\xC9\x8A\x2A\x02\x24\xA4\xF3\x00\xB2\xD3\x80\x00\x5E\xD1\xDB\xCA\x3A\x44\x49\xFB\x01\x19\xD3\xA1\x0C\x7B\xD0\x57\x84\x24\xD4\x08\x09\x4B\xE5\x5D\x31\x00\x1B\xD0\x7B\x48\x14\x04\x24\xDB\x08\x06\x4E\xCF\x19\x02\xD2\x79\x5C\x29\x00\x49\xD2\x12\x09\x9B\xD4\x32\x09\xA4\xAC\x7E\x24\xD2\x4D\x01\x75\xD0\x39\xD1\x51\xA1\xD5\x16\x01\x24\xD2\xA2\x01\xED\xD2\x45\xD4\x35\x48\x05\x04\x49\xEA\x02\x62\xD3\x1C\xD3\xE3\x50\x49\xD2\x16\x0E\x9C\xDD\x34\x00\xA1\xE1\x41\x5C\x00\x92\xD1\x2E\x00\x3D\xD7\x92\xC0\x05\xE4\xA4\xC1\x01\xF4\xD2\x96\xD1\x8F\x64\x24\xD9\x0C\x19\x4F\xF1\xA4\xD0\x35\x62\x00\x92\xD1\x34\x06\x3F\xD6\x93\xCE\xFB\x64\xA4\xD9\x01\x04\xD4\x9E\xD2\xF0\x8C\x24\xD1\x0E\x09\x50\xC2\xA5\x80\x00\x68\x00\x92\xD1\x3A\x00",
			"\x38\xD1\x10\x1C\x4E\xDB\x7C\x81\x7F\x24\xD2\x79\x01\x82\xD7\x29\xD1\x10\x0C\x03\x24\xA4\xFA\x01\xED\xD2\x83\x02\x85\xD2\x92\xA0\x18\x44\x49\xC1\x00\x32\x47\xCB\x09\x11\xD4\x57\xD4\x35\x40\x07\x04\x49\xCA\x00\x28\xD4\x62\xD2\x11\xD4\xEF\xCB\xDF\x32\x07\x04\x49\xD2\x00\x30\xD4\x6A\xD2\x48\x2C\x5B\xD3\xDF\x34\x07\x04\x49\xDA\x00\x38\xD4\x07\x04\x15\xD4\x02\x66\xC1\x94\x92\xC3\x01\x38\xA8\xC2\x2F\x42\xD5\xBC\xD3\xBE\x38\x0F\x04\x92\xCB\x01\x07\xA9\xCF\xD3\x97\xD1\x50\x36\x1E\x04\x24\xD3\x03\x00\x52\xD0\xA9\x9D\xD1\xAD\x64\x3E\x00\x49\xD4\x07\x06\xA5\xCE\x4F\xE3\x9F\xCA\x71\xA4\x79\x71\x2D\x11\x05\x4B\xD2\xA3\xD4\x4C\xD7\xD6\x24\xD2\x4E\x00\x32\xD6\x8E\xD0\xFE\xCE\x2F\x22\x04\x24\xA4\xD7\x00\x4F\xD4\x2F\xD7\xC1\xC7\xDD\x24\x08\x04\x49\xDF\x01\x71\xD4\x65\xD5\xD3\xD2\xF8\x7C\x24\xD7\x06\x18\x53\xEB\xA9\x99\x9D\x03\x32\x44\x00\x49\xD7\x0D\x0E\xA7\xC1\x4E\xCE\xA3\x80\x6E\x8A\x00\x92\xD3\x1D\x05\x50\xD5\xA1\xDF\x78\x3C\xA6\x89\x02\xAC\x79\x71\x2F\x1F\x02\x4D\xD5\x6A\x1F\x78\x30\x00\x64\xBB\x8E\x01\x90\x38\x5C\x95\x4C",
			"\x27\x40\x24\xEF\x94\x02\x62\xD1\xB1\x20\x2F\x3D\x9E\xD6\x37\xBD\x8E\xC8\xA3\x56\xAA\xE4\xBB\x9D\x01\x52\xD4\x99\x2D\x04\x2D\xA9\xD8\xF3\x33\xA3\xB1\x21\x35\x00\xE1\xD3\x2D\x61\x14\x04\x92\xC8\x04\x0C\xAA\xC1\x3E\xC9\xD3\x4E\x4F\x28\x04\x24\xD0\x09\x17\x55\xF1\xAA\xDE\xC4\xD0\xCE\x92\xD0\x26\x04\x52\xD0\xAF\x17\x4E\xF6\x93\x27\x01\x24\xD3\x50\x00\xB1\xD0\x57\xDD\x9D\xCC\x0E\x69\x02\x66\xD3\xCB\xD5\x5F\xD6\xA4\x9C\xBC\x74\x92\xD3\x05\x11\xAB\xBB\xCC\xE1\x41\x56\x00\x49\xD4\x17\x0E\xAB\xCF\x4F\xEC\x86\x2F\x01\x24\xD2\x62\x03\xB5\xD7\x58\x9B\xEF\x31\x05\x33\xA4\xE3\xD5\x6E\xCB\x7D\x3F\x2C\x04\x24\xD6\x0D\x08\x57\xDC\x74\xD9\x4A\x24\xD3\x6F\x02\xBB\xD0\x8E\x39\x8A\x37\x05\x24\xA4\xE8\x01\xF3\xD5\x80\x02\xF9\xB9\x17\x04\x92\xD1\x07\x39\xAB\x8E\x45\x93\x5D\x0F\xD4\x8E\xD1\x41\x02\xAD\xCA\x4A\xF4\x32\xA4\xD2\x04\x00\xDD\x46\x27\x0D\x60\xDD\x58\xC2\xD9\x24\xA4\x8D\x00\x0A\xD6\xF8\xBA\x0F\x19\xD0\xC6\x7A\xA4\x49\xD5\x00\x11\xD6\xFD\x0A\x86\xD7\x01\xC4\x55\x44\x97\xD8\x58\xCD\x23\x1A\xD6\x0F\xC1\x81\x3C\x49\xD0\x05\x0E",
			"\xB1\xC7\x10\x20\xAC\xB9\xC9\x48\x14\x92\xD1\x0C\x06\x63\xD4\xB0\xD2\x4B\xE1\x83\x49\x01\x24\xD3\x1D\x01\xC9\xD3\x62\xD0\x89\xD7\xF8\x24\xA4\xC4\x00\x33\xD7\x30\x0C\x60\xD7\xB5\x44\x92\xCD\x02\x2C\xAC\xB4\xD6\x58\xD5\x5B\x63\x33\x07\x4D\xDF\xB3\xDA\x59\xDF\xA9\xB1\x21\xD1\x00\x92\xD1\x18\x05\x68\xD0\x6B\x0B\x45\xE7\xC2\x30\xD3\x4C\xD6\x8A\x3F\x66\xD1\x53\x54\x92\xD5\x03\x39\xAC\xCD\xD6\xA1\xD2\x65\x84\x49\xD6\x0F\x07\xB5\xD2\x5A\xC0\xA3\xBF\x61\x24\xD3\x43\x01\xD7\xD6\x7F\x27\x8C\xC4\x42\x7C\xAA\xE3\xD6\xC5\xD5\x43\xD6\x32\x75\x1B\x04\x92\xD9\x04\x28\xAD\xCC\xD5\x0E\xD1\x81\x33\x37\x00\x3C\xD1\xB5\xC9\x05\x72\xAA\x80\x6E\xD2\x79\xA0\x8E\xC7\xD2\xF8\x27\x80\x3D\x47\xED\xCA\x63\x01\x24\xD2\x5A\x03\xDE\xD4\x21\x0D\xB7\xDC\x1A\xFB\x0B\xDB\xD5\x6F\xD7\xC2\xD7\xD8\xC0\xE0\x67\x0E\x0E\x49\xC9\xAE\xAE\xD0\xAD\x65\x74\x00\x49\xD6\x19\x0F\xB8\xD4\x41\xEA\x56\x6B\x01\x24\xD3\x6B\x01\xE5\xD2\x07\xDF\x7E\x2D\x07\x24\xA4\xE0\x01\x83\xD6\x3B\x0E\xB7\xD5\x93\x57\xAF\xDB\x5C\xC5\xA1\xEF\x2F\xF1\x01\x7E\xD6\xE9\xD2\x09\xD7\x84",
			"\xBF\x50\xEB\xAE\xD0\xD0\x5A\xB0\x92\xD3\x00\x00\x78\x4B\x4C\x0A\x5C\xF4\xAB\xBB\x3F\x24\xD2\x06\x00\xED\xD4\xA8\x06\xBB\xDA\x57\xC2\x7F\x16\xD6\xBB\xD7\x66\x11\xEF\xD0\x60\xD4\x13\x64\x49\xDE\x00\x41\xD7\x09\x05\xE1\xD4\xD9\xA5\x1F\x03\xB2\xC1\x5E\xC7\x08\x43\xD7\x1C\xD4\x36\x22\xCA\xD1\x78\xDC\xB7\xD4\x58\xEC\x86\x01\x00\xF6\x78\xC4\x25\x0E\x00\x79\xD4\xB8\xCD\x25\xD5\xCA\x59\xD7\x56\x42\xE7\xD5\xF7\xD5\xD1\xC3\x90\x25\x00\x20\xAF\xC8\x4C\xE2\xD6\xD1\xD4\x21\xD0\x60\x77\xBE\xD5\x1E\x5C\xAF\xEA\xD7\x89\xD1\x56\x65\x02\x05\x7D\xD9\x9D\x49\x5F\xC6\x04\x43\xD7\xB0\xCB\x8F\x00\xFD\xD2\x20\x08\x06\x16\x5F\xE3\x2F\x3B\xD6\x63\xB1\xFD\xD4\xB6\x5F\x7D\xD7\xBF\xCA\x35\xFB\x7B\x0F\x00\x02\xD8\x8B\x64\x01\xDF\x7F\xD7\xB4\xDE\x97\x11\x00\x09\xD8\x85\x01\x05\xDA\xDD\xD6\x4C\xDD\x97\x33\x00\x09\xB0\x8F\x01\x12\xD8\x1F\x1F\xD4\xD6\x9E\x45\x01\x09\x60\xD9\x02\x7E\xD7\x13\xD9\x39\xD7\x40\x37\x02\x09\xC0\xC2\x05\x20\xB0\x9A\xD8\x5F\xD7\x56\x65\x06\x01\x81\xDB\x0A\x07\x61\xC7\x1B\x65\xD6\x23\x4D\x04\xD8\x2D\x06\x85\xD3\xBC\xD3",
			"\x36\xF8\x7F\x89\xD8\xBD\x00\x1A\xDA\xA3\xD1\x15\x3F\x01\x09\x60\xC6\x03\x19\xD8\xE9\x17\x8F\x1E\x0D\x04\xBC\xB1\x02\x16\xE7\x70\x25\xEA\x24\x13\x40\xF2\xBB\x09\x06\x9E\x7A\x6E\xD9\x01\x1F\x3C\x43\xD7\xE9\x62\x7B\x78\x73\x6D\x03\x2B\xF9\x04\xEF\xB0\x00\x52\xD8\x6E\x68\x5F\xC4\x79\xB9\x06\x06\xCF\x77\x04\xFB\x00\x77\xD6\xCA\x70\x1A\x01\x02\xD8\x1A\x0E\xC2\xDF\x62\xFE\xAD\xB7\x61\x36\x01\x04\xD9\x36\x05\x8C\xD0\x9D\xCD\x95\x78\x00\x09\xD8\xE2\x00\x20\xDA\x19\xDE\xEB\xC3\x90\x3A\x01\x09\xB0\xEC\x01\x72\xD8\xC8\xD4\x62\xD1\x81\xD6\x0F\x19\x63\xD6\xAE\xC8\x2A\x3E\x01\x04\xD9\xC7\xC4\xAC\x03\xC7\xDA\x13\xCE\x94\x89\xD8\x0A\x01\x1D\x47\x81\x05\x90\xD3\x64\xD6\x27\x42\x01\x09\xD8\x13\x01\x1D\x45\x82\x04\x91\xDB\x64\xD6\x27\x44\x01\x09\xD8\x1D\x00\x49\xDB\xE4\x39\xCA\xCB\xEF\x26\x02\x09\xB0\xA7\x00\x9A\xD9\xB1\x47\x5C\xCB\xDF\x38\x04\x09\x60\xF1\x00\x21\xD9\x96\x40\x4E\xC7\xC2\x79\x81\xDB\x03\x08\x65\xC0\x88\x22\xC5\x97\x53\x04\xD9\x11\x06\x95\xD9\xD0\x58\x3C\xD1\x92\x09\xD8\x4F\x01\x1D\x47\x82\x04\x92\xDD\x9B\xAC\x0D",
			"\x50\x01\x09\xD8\x5A\x00\x5A\xDA\x62\xAA\xCF\xC0\xAD\x32\x02\x09\xB0\xE4\x00\x8A\xD9\x4D\xDB\x64\xC9\xCF\x54\x05\x09\x60\xED\x01\x3A\xD9\xCA\xD8\xE4\xC1\x9E\x5E\x0A\x09\xC0\xD8\x03\x02\xB3\x99\x26\x33\xD5\x70\x40\x16\x01\x81\xD2\x08\x17\x66\xFC\xB2\xA8\xD6\x51\x4D\x04\xD8\x23\x00\x9A\xD2\xCA\xD9\x34\xFD\x65\x5C\x00\x09\xD9\x4B\x02\x37\xDF\xF9\xC1\x0E\x5E\x02\x09\xB0\xA1\x01\xEB\xD9\x28\xD4\x73\x40\x0C\x0C\xC2\xC4\x67\xE9\xB2\x87\xD3\x00\x6E\x31\x01\x02\xDE\x16\x06\xCF\xCF\x65\xCD\xB0\xE0\x55\x09\xD9\x60\x01\x3F\xDD\x96\xD4\xC1\xC1\x58\x49\xB0\xCC\x01\x03\xDB\x61\xD8\x9B\xD4\xCC\x28\x06\x09\x60\xD7\x03\x71\xD9\x22\xD9\x50\x36\x1A\x01\x81\xD1\x0E\x10\x68\xCD\x8C\x9D\x4D\x6C\x01\x04\xDB\x3A\x06\xA2\xD2\x31\xCC\x50\x49\xB0\xF5\x01\x1C\xDA\x8C\xC7\xBE\x38\x0E\x09\xC0\xDF\x07\x21\xB4\x83\xD9\x19\x55\x04\xD9\x02\x07\x7D\x4B\x20\x0E\xC0\x1C\x7E\xB7\x61\x74\x01\x04\xD8\x05\x07\x7D\x47\x20\x0E\x69\xFB\x68\x80\x6E\x76\x00\x4C\xD8\x4D\xDC\x21\x06\xD3\xC8\x79\xA8\x6A\x09\xD8\x26\x01\xF7\x45\x82\x05\xA7\xDA\x44\xB9\x73\x7A",
			"\x01\x09\xD8\x30\x00\xA1\xD8\x4F\xDA\x8F\xD0\x70\x7C\x03\x09\xB0\xBA\x00\x4A\xDB\x84\x00\x51\xDF\xBE\x9F\x6E\x3E\x03\x09\xB0\xC4\x00\x51\xDA\x91\x40\xB6\xD3\x7B\x99\xC0\xCE\x02\x3B\xB4\xD2\xDA\xA3\xD7\x4E\x4E\x20\x01\x81\xD7\x05\x19\x6A\xC3\x04\x53\xDA\xB3\x70\xEA\x41\x02\xD9\x0C\x06\xD6\xC2\x08\x28\xB5\x80\xBE\x64\x2C\x43\x01\x02\xDB\x0D\x0D\xD6\xCF\x0A\x63\xB2\xE1\x41\x88\x01\x04\xD9\x1D\x05\xAE\xD6\x3C\x4A\x65\xC9\x39\x89\xD8\x7F\x00\xBE\xD8\x5A\xDE\xFC\xBC\x08\x09\x60\xC9\x02\x02\xDB\xB6\xD9\x80\x65\x02\xDB\x12\x0C\xD2\xCB\x6A\xE3\xA1\x9D\x4D\x90\x01\x04\xDA\x27\x00\xB1\xDE\xD3\xB9\x60\x89\xB0\xA8\x01\x5F\xDA\xAD\xDB\x32\xDD\x55\x64\x09\x09\x60\xF1\x02\x0D\xDB\x60\xDB\xDA\xCC\xC0\x6E\x12\x09\xC0\xDC\x05\x14\xB6\xF1\xAA\x5B\x6A\x1F\xDB\x69\xDF\xAE\xA6\x02\x83\x63\xE0\xB6\x9A\xDB\xF1\xD6\x19\xB9\x02\xDB\x1B\x0B\xDA\xC4\xAC\xB8\x79\x09\xD8\xE5\x01\xDA\xDA\x62\xAB\xD6\x50\x0A\x09\x60\xEF\x03\x2F\xDB\x67\xDA\x03\xD9\x38\x42\x14\x09\xC0\xDA\x07\x00\xB7\xEE\xDA\x8E\xD3\x7D\x3C\x29\x01\x81\xD5\x00\x04\x9F\x6D\xB4",
			"\xCE\xD6\xB4\x77\x04\xD8\x04\x06\xB9\xDE\xD8\xC7\xEC\x83\x64\x28\x01\x09\xD9\x0D\x00\xF9\x63\xA8\xD6\x7F\xD1\xE2\x09\xB0\xA5\x00\xDB\xDB\xEA\xDB\x45\xDE\xDE\x29\xC0\xCF\x01\x21\xB7\xA1\xDB\x80\xD5\x50\x36\x2B\x01\x81\xD9\x03\x07\x6F\xF0\xB6\x83\x6F\x89\x6B\x04\xDB\x10\x06\xBD\xD1\xDC\xD3\x64\xBB\x01\x89\xD8\x4D\x00\xEA\xD9\x42\x07\x4D\x24\x0F\x44\xEF\xB4\x02\x46\xD8\xB1\x20\xFE\xDB\x46\x44\xBC\xBA\x0B\x0C\x62\xE0\x84\x1F\x1E\x68\xDA\x50\x38\x16\xDE\x5F\x25\x01\x3D\x6F\xEC\x8A\x0B\xDC\x64\x2D\x06\xDF\x80\xDD\xBF\xCD\xC5\xD1\x85\x01\x01\x60\xD8\x97\x85\x04\xD8\x16\x04\xBE\xD4\x10\x59\x55\xFB\x72\x09\xD8\x62\x00\x0E\xDC\x9E\x75\x8D\xD9\x60\x89\x60\xEC\x01\x7A\xDB\x10\x28\x63\xD5\xA7\x4D\x19\x09\xC0\xD7\x03\x28\xB8\xEF\x63\x4C\xDA\x65\x73\x33\x04\x9B\xDF\xE2\xDD\x70\xFF\xB1\xB8\x2B\xD1\x01\x04\xD9\x23\x05\xC6\xD3\xE2\xC9\x4F\xE5\x18\x89\xD8\x98\x00\x11\xDC\x00\x07\xC2\xD2\x92\xCF\x68\xA5\xB0\xBC\xDC\x43\xDD\xB3\xC8\xD1\x39\x81\xDD\x0A\x08\x72\xC4\xB9\xE9\xD5\xF8\x45\x04\xD8\x2E\x06\xC9\xD7\xD7\xCC\x0D\x5B\x03\x09",
			"\xD8\xC3\x00\x2A\xDC\x5E\xCC\x35\x4D\x0D\x09\x60\xCE\x03\x5A\xDC\x7D\xCA\x68\x76\x1A\xD8\xCC\xD2\x58\xCC\x0D\x61\x03\x09\xD8\xE4\x00\xF2\x65\x83\x07\xC9\xD6\xB0\xDD\x34\x63\x03\x09\xD8\xF0\x00\x32\xDD\xC3\xD5\x64\x49\xC0\xDB\x07\x02\xB9\xEC\xDC\xFF\xBE\x68\x37\x39\x04\xB9\xD7\x48\x4B\x73\xDE\xAF\xF6\x49\xE9\x01\x04\xD9\x04\x07\x90\x4B\x20\x18\x73\xE5\xA5\xDD\x6B\x09\xD8\x0E\x00\xA1\xDB\x6E\x4B\xA3\xC4\x88\x5F\xB2\xFD\xDC\x8C\xDC\x73\xDB\x76\xA9\x81\xD3\x03\x0B\x74\xE6\x82\x6C\xD9\x12\x63\x04\xDA\x0F\x06\xD2\xD9\xE2\xD2\x67\xE8\x0C\x89\xD8\x49\x00\x48\xDF\xA5\xD8\x9F\xDA\x8C\x75\x07\x09\xB0\xD5\x00\xA2\xDD\x4E\xDC\x29\xD4\x66\x8B\xD6\xC9\x75\xF0\xB8\x85\xDA\xB6\x23\x7C\x02\x33\xDE\xD5\xD6\xE3\xD6\x6E\xE1\x6A\x69\x7A\xE3\x2D\x3C\x00\xA7\xDF\xD5\xD1\xD1\xCC\x0E\x7D\x03\x09\xD8\x84\x01\x5D\xDD\xAD\xDB\xBC\xD9\x35\x97\x60\xC2\xBB\xBD\xDC\xE9\xDA\xE6\x41\x00\x04\xF3\x28\x38\x3A\x04\x07\xBB\xC9\xDC\x6A\xD6\xFB\x28\xB3\xDD\xFE\x8F\xEC\xC6\x74\xE8\xB4\xF6\x49\x05\x01\x69\xDF\xB3\x0C\xD6\xD1\x10\x05\xF3\x06\x04\x15\x30",
			"\x9D\x46\x6D\xDC\x99\x2E\xDB\xD3\x10\x08\x02\x24\x77\xEE\x7A\x7E\x48\xDB\x20\x11\x00\xC3\xD6\x7F\x22\x77\xC9\x1D\x4F\xDD\xEB\xDD\x33\xDB\xE3\x86\xDD\xD3\x8C\x90\x77\xE4\xB8\xE8\xA5\xF4\xDD\x80\x02\x34\x04\xDB\xD0\x00\x11\x77\xF4\xB1\xA1\x35\x11\x01\x7C\xDC\x3B\x4C\xDF\xDE\xEF\xD4\xC4\x61\x83\x13\x00\x02\xDE\x75\x00\xC1\xDB\x3C\xDC\xC1\xC2\x78\xF6\x03\x0B\xDE\x3E\xDD\x77\x2E\x5D\x7C\x9D\x59\x4A\x4B\x10\x05\xBC\x8D\xD9\xE9\xAA\x81\xDD\x03\x01\x95\x4D\x20\x17\x78\xD5\xB2\xBF\x87\x02\xDF\x0C\x00\xC7\xDC\x10\x2C\xC9\xC1\x07\x5D\x00\x02\xDE\x25\x01\x91\xDD\x05\x2D\xCA\xD6\x4F\x5F\x00\x02\xBC\xB1\x00\x2A\xDE\x83\x02\xC7\xDE\x0A\xD6\xBF\x22\x78\xFD\x00\x31\xDE\x03\x03\x99\xDE\xF9\xBB\x04\x02\xF0\xC9\x02\x38\xBC\x82\x02\x33\xDF\x07\xD5\x5F\x7B\xDC\x25\x05\x09\x25\x5E\x07\x33\xDE\x64\xA7\x13\x02\xC0\xDA\x0C\x0F\xF3\xCD\x0A\x44\xB3\xFB\x3D\x29\x00\x81\xDE\x1B\x05\xE2\xD4\xF2\xDB\x6C\xF7\xC2\x2B\x00\x02\xDF\x3C\x02\xD1\xDD\xEA\xD2\xCD\xCD\x95\x6D\x00\x02\xDE\x86\x01\xA6\xDD\xBF\xD9\x9B\xDC\x1A\x4F\x01\x02\xBC\x92\x01\x62",
			"\xDF\x99\xDC\x38\xD8\xD2\x22\xF0\xDE\x04\x1B\xBD\xAB\xDE\x92\xDC\xDB\x20\x61\x7B\xDC\x2B\x0A\x09\x7B\xD8\xBA\xD2\xA6\x02\xDF\x5B\x02\xDD\xDE\xD3\xDD\x2A\x77\x01\x02\xBC\xC3\x01\x6F\xDE\x99\xDE\x70\xDC\x35\x49\x03\x02\x78\xD0\x03\x01\xDF\x39\xDF\xE4\xD9\x38\x43\x07\x02\xF0\xDD\x06\x08\xBE\xC0\xDE\xD0\xDA\x7B\x49\x0F\x01\xE1\xDF\xF8\xCE\x7A\xCB\xB4\xD7\xAC\x02\xDF\x7B\x03\xDE\xDD\xD7\xD9\xE7\x41\x02\x02\xBC\x83\x00\xD6\x47\x8E\xDF\xC7\x1E\xFF\xCA\x20\x23\x02\x02\xBC\x8F\x00\xA1\xDE\xAE\xDD\xF2\xB7\xDD\x25\x04\x02\x78\xDB\x00\x29\xDF\x70\xDF\x13\xB5\xD7\x52\xE0\xD7\x02\x10\x7D\xC2\xBE\xF6\xDB\xA1\x35\x24\x02\xC0\xDB\x06\x06\x3D\x5E\x0E\x05\x01\x6C\xDD\x64\x2D\x25\x02\xC0\xD8\x08\x06\x3D\x4B\x10\x3F\xBE\xF2\xDD\xCA\x71\x26\x02\xC0\xDB\x09\x05\xFC\xCC\x08\x07\xBF\x86\xD7\x9D\x4D\x27\x02\xC0\xDE\x0A\x06\xFB\xC3\x08\x0F\xBF\x8B\xD7\x93\xAD\xA5\xDD\xF5\xDA\xA5\x21\xE3\xD1\x85\x13\x01\x52\xDE\xDB\xDF\x80\x03\xF5\xD8\xBE\x9E\xB5\x62\x78\xFA\x01\x61\xDF\xE2\x41\xAD\xD8\x81\x58\xEC\xDD\xFC\xDB\x95\x61\xB5\xCA\xA1\x02\xDF",
			"\x48\x00\xFA\xDB\xFC\xDF\xF1\xD2\xEC\x02\xBC\x9D\x01\xF3\xDF\x92\xDD\x86\x5A\xE0\xD9\x0A\x19\x7F\xD8\x99\x98\x4E\x02\xDF\x5A\x02\xFF\xDD\xE1\xB8\xE2\x42\x78\xC1\x03\x03\xE0\x91\xCE\xDE\x56\xC0\xDD\x19\x08\x00\xFB\x15\xAF\xB8\x02\xDE\xD9\x01\xDE\xDE\xF3\xDB\x93\xC0\xAD\x27\x03\x02\xBC\xE6\x01\x0D\xE1\xD3\xCC\x7F\xBA\xE0\xD2\x0F\x0D\x7F\xF0\xBF\x56\xD7\xF6\x49\x35\x02\xC0\xDD\x1F\x02\x01\xEE\x7F\xE2\xB6\xCA\x71\x6D\x00\x81\xDE\x02\x00\xBD\x4D\x20\x14\x7F\xE1\xAC\x8C\x6E\x02\xDE\x0B\x00\x0B\xE3\x02\xEB\xBE\xCC\x0E\x71\x01\x02\xDE\x22\x00\xF4\x4A\xEF\xDE\x65\xDC\x1A\x53\x03\x02\xBC\xAF\x00\x33\xE0\x13\xE2\x32\x87\xDD\x25\x07\x02\x78\xFB\x00\x41\xE0\x1F\xE0\xBE\xDF\x2D\x67\x0E\x02\xF0\xC7\x02\x3A\xC0\xB4\xE0\x41\xD7\x13\xBE\xC0\xDC\x0A\x0F\x04\xE2\x82\xF9\x75\xAC\xA2\x02\xDF\x30\x01\x15\xE1\x09\xE7\x6B\xCB\xEA\x52\xBD\xDB\xE0\xD6\xDF\x0D\xD9\xA7\x4F\x0F\x02\xF0\xDB\x03\x08\xC1\xE1\xE0\x59\xD6\x8F\xAE\xC0\xDF\x10\x07\x06\xFC\x7E\xE9\xB0\xA9\x83\x02\xDF\x49\x01\x1B\xE2\xFC\xD0\xC3\xD6\x27\x45\x02\x02\xDE\x9F\x01\x39",
			"\xE1\xFA\xD9\xDA\xD2\x6D\x62\x78\xEB\x02\x7A\xE0\x2E\xE1\x47\xD6\x28\x71\xEF\xD0\x06\xF2\x0D\x5F\x3C\x60\xDD\xB7\x4E\xCE\x2D\xBF\x75\x4E\x26\x05\xE9\x98\x5C\x5E\x4C\x6B\xE6\xDD\xD8\xDD\x38\x41\x12\x0F\x08\xF1\xE4\x40\xBF\x9B\x78\x02\xDE\x62\x00\x7A\x4B\x41\x0C\x81\x28\x7E\xF1\x42\x14\x01\x02\xDF\x67\x03\x26\xE0\x10\x47\xEF\xCA\xC6\x56\x02\x02\xDE\xDA\x00\x3D\xE1\x27\xE7\xDF\xDC\x1C\x58\x04\x17\xC0\xAA\xE1\xDD\xDE\x7F\x26\x26\x04\x03\xE0\x0B\xF7\x71\xCF\x3F\x1C\x01\x02\xDE\x7F\x01\x2D\xE4\x73\xDF\x15\x8A\x81\xE7\x98\x4D\x09\xAB\xE1\x71\x6C\x10\x82\xE0\xD5\x01\x1F\x85\xE6\x15\x41\xE1\x5E\x21\x1A\x46\xC0\xD9\x04\x06\x0C\xF5\x2F\x08\xC3\x81\x02\x70\xDB\xA2\x86\xC0\xDD\x05\x0D\x0C\xED\x10\x0F\xC3\x80\x79\x43\x44\x81\xDD\x0E\x05\x1A\xE4\x0A\xFB\x72\xD9\x52\x82\xDE\x45\x00\x6E\xE2\x7B\x40\x96\xDB\xEF\x2A\x05\x02\xBC\xD1\x00\xE2\xE0\xBE\x3D\x62\xD9\x1C\x4C\x0A\x02\x78\xDD\x01\x4D\xE1\xDE\x03\x6B\xE0\xD9\xA6\x15\x02\xF0\xCA\x03\x29\xC3\x84\x3D\x4F\xDE\x40\x9A\xC0\xDE\x0E\x0D\x0C\xFC\x84\xE0\xC0\x9D\x4D\xB2\x00\x81\xDD",
			"\x20\x00\x1E\xED\x0D\xFD\x7A\xF6\x11\x82\xDE\x8E\x01\x7B\xE0\xCE\xBC\xEC\xD2\x4C\xA2\x78\xDA\x02\x0A\xE2\xFF\xAF\x46\xDD\x04\x72\xE0\xD6\x0A\x04\x88\xE3\xC3\xF1\xDE\x81\x90\x81\xDF\x2C\x00\x22\xE5\xE5\x97\x7B\xDD\x9A\x3C\x01\x02\xDF\x5F\x00\x47\xE7\x1A\xE6\x5B\xCF\x7E\x3E\x02\x02\xDE\xCB\x00\x8B\xE2\x3A\xE4\xD4\xD3\x9B\x82\x78\xD8\x03\x2A\xE2\xF8\xE1\x7F\xD8\x97\x92\xE0\xD5\x0E\x10\x89\xCB\xC4\xB0\xDD\xAC\x96\x0E\xE2\x4D\xE1\x22\xE7\xF9\xCF\xBF\x06\x03\x02\xDE\xFF\x01\x91\xE1\x77\xDC\xD9\x52\xF0\xCB\x00\x0C\x99\x56\xE1\xA3\xDF\x54\x32\x32\x02\xE0\xD7\x01\x07\x8A\xC5\xC4\xAB\xDF\x03\x32\x66\x02\xC0\xDB\x04\x0E\x14\xF7\x88\xF2\xBE\xF7\x92\x3F\xE1\xAA\xE3\x4A\xE1\x6E\xD5\x74\x86\x82\xCC\x99\x5E\x03\x07\x21\x7A\x44\x79\xBA\x1A\x00\x14\xF1\x12\x5F\x3C\x4E\x00\xE4\xBA\x6A\x01\x59\xE2\x41\x2C\x04\x17\x84\xDE\x35\x82\xDE\x48\x00\xAD\xE2\x06\x2E\xC3\xD3\x90\x38\x06\x13\xC1\xF2\xE2\x1F\x29\x52\xE1\x2C\x22\x1B\x02\xF0\xC0\x03\x1F\xC5\xAA\x47\x2A\xDD\x77\x2C\x37\x02\xE0\xDD\x06\x1F\x8B\xC8\x99\x31\xE1\x64\x2C\x6F\x02\xF9",
			"\xDE\x30\xE3\x3B\x4C\x78\xDD\x9A\x55\x7B\xFD\x84\xC6\xE3\x5C\xE1\xE2\xD3\x87\x82\x78\xD4\x02\x78\xE2\x19\x41\xF7\xDF\x40\x34\x1C\x02\xF0\xC0\x05\x12\xC6\xF9\xE2\xE4\xD5\x70\x42\x39\x02\xE0\xDD\x0A\x1F\x8C\xD9\xC6\xFE\x97\x6C\xAA\x81\xDE\x2E\x06\x34\xE0\x00\x0D\x8B\xFF\xBF\xA1\x35\xEA\x00\x81\xDF\x31\x04\x35\xEE\x1A\xE4\x80\xF8\x55\x82\xDE\xD4\x00\xDA\xE0\x39\xE0\xBE\x42\xF0\xC1\x07\x3A\xC6\x96\xBE\x9D\x4C\x78\x02\xC0\xDE\x1D\x0C\x64\x5B\x0D\x35\xC6\xED\xDC\x27\xCC\x81\xDC\x3F\x07\x37\xE0\xF2\xB1\xDF\x42\xBC\x89\x00\x4B\x4F\x06\x07\x71\xE1\xCF\xDB\xEF\x36\x07\x04\xC3\xCB\x4E\xC6\xE3\x3F\xDD\xA7\x48\x1F\x03\x15\xEB\x3A\x5E\x07\x53\xE3\x87\xDC\x7A\x72\xC0\xD8\x06\x0E\x1D\xE0\x8C\xF5\xC0\xF9\x5C\xFC\x00\x9B\xDC\x76\xE6\x3C\xE1\xDB\xD2\xAD\x8B\xBF\xE5\xE3\x87\xE3\x9A\xD7\x40\x37\x59\x36\x80\x84\x33\x70\xC7\x8D\xE3\x4A\xE1\x65\x8B\xF6\x28\x71\x25\x06\x0B\x8F\xF1\xC7\xD1\xE0\xCA\x70\x02\x03\x7E\xE1\xD6\x5E\x1F\xF8\x8F\xEB\xBA\xCC\x43\x06\x01\x01\xE5\x42\x01\x10\x05\x20\xF3\x8C\xDD\xC1\xEF\x2D\x08\x00\x05\xE6\x32\x25",
			"\x41\xE0\x1A\xF6\x75\xCC\x87\x0A\x00\x12\xE5\x81\x01\x27\x07\x3E\xEE\x20\xF0\x00\x8B\xD9\x19\xE4\x02\x02\x55\x00\x87\xE5\x42\xE4\xEC\xD6\x26\xA0\xC8\x81\x02\xB7\x01\x11\xE7\x69\xE1\xD9\xDF\xD3\xA7\x91\xFE\x26\x2A\xE4\xAD\xE2\xDA\xD0\xB4\x32\x02\x0E\x22\xF1\x06\x30\xC8\xE0\xE3\xD7\xDC\x00\xA2\x8B\xE6\x1B\x04\x21\xE1\x08\x3F\x49\x62\xE2\xD0\x34\x0B\x03\xF6\x28\x2E\x98\x16\xFF\x8F\xE1\x83\x1C\x00\xDB\x2E\xE6\x6B\x08\x37\xA5\xD0\x70\x7D\x00\x2E\xC8\xEC\x01\xD1\xE2\x86\x03\x92\xE7\xA6\xDA\x8C\x7F\x00\x2E\xC8\xF8\x01\x51\xE5\x84\x03\x94\xE6\xA7\xD4\x89\xAE\x91\xC4\x00\x25\x50\xDE\x03\x2D\xE5\x51\xDF\xC0\xAE\x22\xF1\x00\x20\xC9\xD2\xE4\x88\xE2\x6E\x3A\x8B\xE6\x03\x07\x26\xFA\x92\xCE\xC6\xEF\x2D\xF5\x7B\x71\x2F\x0A\x05\x4D\xE6\x10\x02\x93\xD9\x4C\xEE\x55\x2E\xE4\x1C\x01\x09\x55\x41\x06\x27\xF9\xEA\x70\xB5\x2E\xE4\x44\x00\x3A\xE7\x40\x05\x4F\xE8\xEF\xA5\x88\x2D\x00\x2E\xE4\x51\x00\x41\xE6\x40\x05\x4F\xE1\x0D\xE9\xEC\x2E\xC8\xDE\x00\x8A\xE5\x80\x01\x9F\xE4\x1B\xCD\x97\x31\x01\x2E\xC8\xEB\x00\x91\xE4\x00\x01\x9F\xE1\x35",
			"\xC9\x60\x2E\x91\xF8\x01\x19\xE5\x7D\xE4\xF3\xBC\x7F\x7E\xFA\x60\x2A\xEB\x87\xEC\x86\x37\x00\x2E\xE4\x49\x01\x09\x53\x37\x0D\x27\xE4\x9B\xB9\x00\x2E\xE4\xA0\x01\x52\xE5\x65\xDF\x16\x6B\x03\x0E\x91\xED\x02\x7B\xE4\x68\xE4\xAB\xDC\xC0\x6D\x07\x0E\x22\xF9\x05\x2B\xCA\xB9\xE5\x06\xE2\x80\x6F\x0F\x06\x45\xE7\x0C\x12\x95\xE8\xB6\xBC\x3A\x2E\xE4\x6A\x02\xB1\xE4\xB5\xD9\x8F\xAE\x91\xE1\x03\x3F\xE5\x6E\xE4\x8C\xE0\x4F\x2D\x08\x0E\x22\xEF\x07\x0B\xCB\xB6\xDB\xC1\x4C\x17\xE4\x3F\x07\x5A\xEB\xDB\xD0\xD6\x09\x01\x2E\xE4\x09\x01\x2F\x51\x4C\x0D\x4F\xE8\x12\xD9\xE4\x6E\xC8\x97\x00\xE2\xE4\xA9\x09\x9F\xE7\xD0\xB9\xFC\xCE\x91\xE5\x00\x69\xE5\x49\x0B\x3E\xE7\xA3\xB8\xE0\x6F\x04\x0E\x91\xF3\x00\x70\xE5\xAC\xE4\x31\xE3\xBB\x29\x0A\x0E\x22\xE1\x02\x30\xCB\xE1\xE4\x43\xE3\x5B\x7A\x8B\xE6\x09\x0F\x2F\xE0\x96\xE5\xC8\xBC\x9B\x2E\xE5\x2D\x01\xC1\xE1\x5A\xEC\x22\xF4\x9D\xAE\xC8\xE8\x00\x0B\xE7\x3A\xE6\x8C\xE3\xDF\x39\x05\x0E\x91\xF5\x01\x11\xE6\x83\xE5\x1D\xDA\xC2\x4E\x45\xE2\x08\x18\x97\xDF\x69\x0E\xD5\xE4\xBB\x2E\x01\x92\xE1\x16\x22",
			"\x05\x1F\x78\x14\x01\x23\xCA\x2E\xE4\x69\x4A\x5B\xE4\x4C\x5E\x22\xF0\x04\x18\xCC\x82\x02\x27\xE6\x4F\xE2\xBF\x22\x0C\x0E\x22\xFD\x04\x2F\xCC\x88\x49\x7A\xE2\x6D\x56\x8B\xE2\x15\x0E\x31\xE9\x08\x31\xCC\xAC\xE1\xCE\x64\x17\xE4\x2E\x05\x67\xE3\xA7\x29\x93\xEF\x5F\x68\x00\x2E\xE4\x63\x00\xD1\xE3\x20\x0F\x33\xF4\x31\xC1\xFE\x49\xE5\x4B\xE6\x98\xE6\xFA\xD8\xA3\xDE\x22\xE2\x07\x37\xCC\x80\x00\x4D\xE6\x8C\xDD\xA1\x35\x5A\xE1\x35\xF8\x99\xE1\xC6\xAC\xD4\x2E\xE5\x7E\x01\xD7\xE0\x6B\xEA\xFF\xD6\x27\x72\x01\x2E\xE4\x0B\x00\x32\x51\x4C\x09\x6B\xE0\xBB\xCF\xBF\x34\x01\x2E\xE4\x19\x00\xB5\xE6\x54\x0C\x6D\xE4\xF3\xCF\xBF\x36\x01\x2E\xE4\x27\x00\xB9\xE5\x52\x0C\x6E\xE6\xFE\xB8\x03\x2E\xC8\xB5\x00\x7A\xE7\xDD\x00\xDD\xE7\x41\xDA\x07\x0E\x91\xC3\x01\x7A\xE6\xBD\x02\xBA\xE4\xD9\xA4\x0F\x0E\x22\xF2\x02\x01\xCE\x96\x42\xF9\xE0\xD6\x42\x1F\x06\x45\xE0\x06\x1A\x9B\xDE\x07\x74\xE6\xBF\xC5\x3C\x5C\x20\x06\x45\xED\x06\x08\x9C\xD0\xCE\xA7\xE0\xB1\x20\x41\x02\x8B\xE4\x0F\x0F\x38\xFE\x99\xCC\xC4\xCF\x73\x2E\xE4\x45\x01\xE9\xE5\x68\xE7\x1E",
			"\xED\x95\x46\x02\x2E\xE4\x98\x00\xCF\xE6\xE9\xE2\x5A\xEA\x5A\x28\x04\x2E\xC8\xA7\x01\xAB\xE6\xA6\xE6\x47\xE1\x1B\x3E\x22\xF5\x05\x39\xCE\xD2\xE6\xF9\xE2\x65\x70\x23\x06\x45\xE3\x0C\x12\x9D\xEC\xCE\x80\xE4\xB7\x74\x17\xE6\x34\x06\x78\xEA\x3B\xF2\x89\xEF\x5F\x10\x01\xCE\xE4\xE6\xE4\xF0\xE7\x41\xE3\x90\x32\x04\x2E\xC8\xF0\x01\xD2\xE6\xAF\xE6\x85\xE1\xCF\x54\x09\x09\x99\xFF\xCE\xDA\xE7\x1E\xE4\xAA\x6A\x8B\xE5\x01\x0E\x73\x62\x9C\xC9\xC5\xB2\x38\x2E\xE5\x0D\x01\xF9\xE7\x73\xED\x30\xF7\x85\x5A\x02\x2E\xE4\x29\x01\xF5\xE7\xEC\xE7\x2A\xE9\xE7\x5C\x04\x2E\xC8\xB7\x00\xF2\xE7\xE3\xE4\x8B\xB6\x67\x6E\x22\xE5\x02\x3E\xDC\x4F\x4A\x1F\x1F\xA3\x40\x10\x86\x45\xE4\x05\x1E\xB9\x6E\x3C\x08\x25\xCE\x46\xF2\xBA\x28\x03\xFB\x2A\x96\x83\x94\x21\x94\x64\xBB\xA6\x01\x91\xE6\xF7\x31\x80\xE4\xDE\xA7\x05\x29\xCC\xC7\x50\x2B\xE7\xBE\x31\x2A\x06\x45\xE5\x05\x19\x9F\xC6\x85\x74\xE2\x83\x6A\x17\xE7\x18\x06\x83\xE2\x10\x02\xA0\xDC\xC9\xEB\x7B\x2E\xE5\x38\x03\xFF\xE4\x21\x06\x42\xE3\x93\xF7\xC2\x2F\x01\x2E\xE4\x40\x03\x0A\xE9\x21\x0D\x42\xE2",
			"\x14\x85\x09\xAE\xE4\x8F\x01\x19\xE9\x94\x4C\x82\xE0\xAD\x33\x05\x2E\xC8\x9E\x01\x3E\x6E\xE2\x9C\x9B\xBC\xBC\xB5\x0B\x12\xA0\xE4\xA0\x6F\xE4\x7A\x38\x58\xE6\x0E\xEF\x83\xE4\x19\xE1\xD5\x38\x02\x2E\xE4\xAF\x00\x12\xE8\x4C\x42\x33\xE1\xAA\x3A\x05\x2E\xC8\xBD\x01\x4B\xE9\x12\xEA\x92\xDE\x95\x9E\x22\xEC\x06\x19\xD1\xD3\xE8\xA8\xE2\xA3\x92\x8B\xE3\x1B\x0F\x45\xE2\x01\x6C\xBC\x99\xB9\x2E\xE4\x75\x01\x19\xED\x86\xE5\x37\xEC\x53\xAE\xC8\xF9\x01\x6B\xE9\xDD\xE3\x35\x9E\x45\xE8\x00\x07\x44\x7D\x06\x6C\xE8\x0F\xD4\x63\x03\xB9\xE7\x10\x5F\x1B\x0C\xA3\xE4\x4D\xC8\x01\x78\xE6\x3B\xE8\x0B\xE9\x72\xE6\x4F\x4A\x06\x2E\xC8\xB6\x00\x87\x51\xDD\x00\x1B\xE9\x73\xED\x2A\x6C\x06\x00\xCA\xFC\xE8\x83\xE8\xD0\xE6\xBF\x26\x19\x04\x40\xE2\xA4\xF4\xD0\xA7\xE7\x61\x70\x11\xEA\x25\xEB\x87\xED\x3A\xF7\x85\x52\x03\x2E\xE4\x72\x00\x48\xEB\x25\xEC\x76\xE0\xCE\x9C\x98\xDB\xD2\xCC\xE8\x43\xE1\xFB\x66\x8B\xE1\x12\x07\x4A\xFA\xA2\xFE\x2C\x2B\xC8\xB0\xE5\x43\x52\xCB\x1C\x8D\xE1\x8E\x25\xE6\xAE\xC8\xA1\x01\x87\x50\x21\xEB\x7E\xD9\xE2\x5E\x22\xE3\x05",
			"\x39\xD2\x91\xE9\x1E\x25\x11\xC6\x8B\xE5\x14\x02\x4B\xE0\xA6\xDE\x2A\x64\xBB\xE0\x00\x17\xE6\x29\x05\x98\xE3\x4A\xF6\x5D\x24\x77\xE2\x01\xB7\xE6\x66\xE8\x27\xEE\x55\x19\x22\xCE\x91\xE8\x02\x52\xE9\xA8\xE9\xB0\x14\x79\xBE\x1C\x0E\x22\xE9\x05\x18\xD3\xAE\xE9\xC0\x5C\xF2\xB8\x3A\x03\x67\xEF\x4B\xED\xA6\xC5\x52\x64\xBB\xEA\x00\x17\xE4\x2B\x05\x9C\xE3\x4D\xE3\x08\x05\x67\x1A\x96\x2E\xE4\x57\x03\x37\xE8\x8C\xE6\xB7\x44\xEF\xAE\x03\x50\xE8\xEC\xE9\x6C\xE9\x04\x1C\x87\xCE\x22\xF1\x05\x33\xD3\xE6\xE8\xC1\xE7\x58\x22\x3C\x06\x45\xE2\x0B\x02\xA5\xED\xD3\xED\x87\xFB\x3C\x7A\x02\x8B\xE2\x18\x06\x50\xFA\xA7\xD2\x1C\xE4\xBB\xF6\x00\xE5\xE7\x21\x56\x1E\x2C\x46\xF0\xCB\x10\x6B\x78\x01\x2E\xE5\x6A\x01\x3E\xE8\x9C\xED\x74\x04\xEF\xBA\x03\x2E\xE4\xD7\x01\x8D\xE8\x3D\xEF\x0A\xE7\x0B\x7C\x07\x2E\xC8\xD9\x01\x0D\xEA\x8E\xEA\x40\x03\x11\x04\xDE\xBE\x07\x2E\xC8\xE9\x01\x22\xEA\x80\xEA\x31\x44\xBC\xB2\xC7\x08\x9C\x2B\x03\x31\xEA\x6C\xE9\x79\xE7\x6F\xAA\xC9\x08\x38\x2D\x07\x29\xD4\xA3\xEA\xE2\xA4\x8B\x70\x4F\xE8\xD5\x1D\x4A\xE0\xAA\xFA",
			"\xA5\x64\xBB\xCE\x7D\x15\x8A\x04\x51\x60\xE1\x0E\x47\x00\x03\xD5\xBB\x02\x7B\x53\x3B\xEB\xF9\xE3\xDF\x39\x00\x0F\xAA\xF7\x61\x51\xEA\xC6\xE9\x8E\xD9\xB7\xA6\xAA\xE1\xCF\x38\xAA\xE6\xD3\xD7\xC2\x78\x62\xAE\xE9\xFA\x3E\xAB\xE7\x50\xF4\x46\xCD\x80\x62\xEA\xBB\x6D\xBD\x53\x6F\x07\x05\x38\x86\xBF\x1C\xA8\xD5\x90\x35\x7B\x53\xDD\x00\x5B\xED\x80\xBF\x6E\x33\x00\x2F\xD5\xE6\x00\x71\xEA\x60\x24\xB0\xD1\x1C\x45\x01\x0F\xAB\xF4\x01\x64\xEA\x03\x03\xB9\xEA\x0B\xE8\xE0\x67\x01\x0F\xAB\xC3\x02\x00\xEB\xA9\x20\xA3\xE6\xD1\xC7\xAD\xE2\x09\x08\xAC\xC1\x04\x02\xEB\x46\xEB\xDF\x87\x5B\xE9\x14\x0B\x97\x48\x9C\x10\xD6\xE5\xBB\xE4\xBB\x0E\x02\x92\x0C\xB9\x67\x59\xE2\xF7\x84\x6E\x6F\xEA\xA3\x00\xC7\xE8\x00\x07\xB2\xE9\xEE\xBD\xB9\x20\x00\x6F\xEA\xB2\x01\xBC\xE9\x42\x07\xB2\xE8\xFC\xBA\xEB\xAF\xD5\xC0\x01\xA2\xEB\xCB\xE9\xA1\xE6\x36\x24\x02\x0F\xAB\xCF\x03\x31\xEB\x65\xE7\x4E\x4E\x09\x07\xAD\xEE\x0D\x18\xAD\xEF\xC6\xA9\x76\x6F\xEB\x76\x02\x6F\xEE\x36\xE6\x4F\x4A\x01\x2F\xD5\xFC\x01\xC3\xEB\x04\xE1\x38\x44\x05\x0F\x56\xEB\x00\x11\xA9",
			"\x3D\x03\x97\xEB\x07\xD6\x0B\x07\xAD\xEA\x01\x11\x52\x6B\xD5\x94\xE0\x2E\x79\xB7\xEA\x0A\x07\xB9\xEA\x57\xED\x8E\xE7\x9B\xEF\xEA\x39\x01\x28\x56\x5C\xEF\x1F\xEF\x6E\x34\x01\x2F\xD5\xC7\x00\xD6\xEB\xEE\xEB\x1D\xD7\x88\x7F\x56\xF7\x02\x1C\xD7\xAB\xEB\x98\xE9\x65\x7F\x5D\xEF\xBD\xE8\x2C\x72\x88\xD7\xF1\x6F\xEA\x75\x01\xF4\xE8\x7C\xEC\x94\xE8\x5B\x3C\x01\x2F\xD5\x85\x01\xF4\xEB\xC0\xEB\xEE\xE3\x20\x3C\xEE\x64\x13\x41\xD8\x89\xEB\xAF\xE8\x87\xC8\x68\xE9\x4A\x5E\xF2\x17\xAC\xF5\xD2\xFB\x3D\x42\x01\xB7\xE8\x29\x01\x4A\x56\x59\xFF\x78\x15\xBD\x7B\x3D\x44\x01\xB7\xEA\x29\x04\xC2\xEA\x5E\xFF\xB2\x64\x77\xC6\x00\x6F\xEA\x54\x00\x83\xED\xC3\xE6\xAA\x04\xEF\x88\x01\x6F\xEA\xA9\x01\x11\xEF\x7E\xEE\x99\xEB\xF0\x6F\xAB\xEA\x02\x2A\xEC\xF5\xEA\x56\x14\x79\xBB\xDE\x74\xF7\xD0\xB1\xC2\xD8\xE5\x16\x19\xCB\xB7\xE8\x2B\x06\xC6\xE8\x60\xE1\xA7\xE2\xA6\x6F\xEA\xAD\x00\x0E\xEF\x8A\xEF\x9C\xE5\xCC\xCF\xAB\xEF\x02\x42\xEC\x31\xEC\x83\x03\x3B\xE9\x36\x5F\x56\xF1\x05\x3C\xD8\x8F\xEB\x11\xBE\xF2\xBA\x15\x00\xB5\xE8\x64\xF7\xB1\xC9\x30\x64",
			"\xBB\x58\x01\xB7\xE8\x2D\x07\xC9\xE3\x5A\xE0\x60\xC7\xA7\x6F\xEA\xB5\x00\xFD\xE9\x92\xEE\xFE\x7C\x1A\x5C\x02\x2F\xD5\xC5\x01\x62\xEC\x2B\xEF\x40\x00\xD3\x35\xF5\x6F\xAB\xD5\x03\x51\x54\xF6\x21\xCB\xEA\x45\xEB\xDF\x30\x06\x0F\xAB\xD8\x03\x55\xEC\x3D\xED\x8E\xE8\x80\xD7\xAD\xEA\x0D\x18\xB3\xD0\xD9\xCE\xE7\xE0\x32\x32\x03\x5B\xEC\x1B\x09\x66\xF9\xB3\xEB\xD4\xF7\xBB\x6F\xEA\x76\x02\x9F\xED\xCB\xE5\x0C\x24\xEF\xA8\x01\x6F\xEA\xEE\x01\x45\xEF\x65\xEA\xA7\xE3\x65\x2F\xAB\xF0\x03\x05\xED\x7F\xED\xED\xE5\xAB\x64\x0D\x0F\x56\xF5\x85\x19\x0E\x17\xEB\x3F\x30\xC0\x43\x66\xEE\x05\x3C\x54\xEC\x0D\x6F\x01\x6F\xEA\x0F\x01\x47\x55\x1E\x0F\xB2\xE4\xFA\xDC\xA9\x31\x01\x6F\xEA\x1E\x00\x55\xED\x34\x0F\xB2\xED\x6C\xCB\x80\x6F\xD5\xAD\x00\xB2\xED\xA9\x0B\x65\xEE\x86\xDF\xFC\x15\x03\x2F\xD5\xBC\x00\xB9\xEC\xE8\xEA\xC6\xE3\xDF\x37\xF0\x63\xC0\xB9\xDA\xBF\x03\x5C\x01\x21\xE8\xB4\x31\x0F\x03\x6A\xFE\x97\x34\x79\x4A\x4E\xE4\xBA\x3D\x02\x92\x0A\x2D\x9E\x05\x1F\x78\x09\xDB\x87\x3C\xCD\xEC\x32\x2D\xA8\xEC\x18\x54\xDE\xBF\x03\x19\xDB\xDA\x54",
			"\x3C\xE8\xAA\xCB\x5B\xEB\x0B\x09\x6B\xEE\x79\x06\x61\x38\x5D\x49\xC7\xB7\xE8\x17\x05\xDC\xEC\x10\x0F\xC2\x06\x04\x61\x00\xE4\xBA\x42\x03\xB7\xEF\xFD\x2C\x2C\x32\x0A\x64\x77\x85\x01\xF3\xED\x40\xEF\xC7\x19\x0E\x04\xDE\xAE\xF8\x69\xBB\x8A\x24\x5E\x30\x26\xE6\x32\x70\x11\x0F\x56\xFD\x02\x39\xDA\xDE\x03\x01\xEE\x2A\xE5\x2C\x22\x11\x0F\x56\xEA\x03\x07\xDC\x8C\x02\x09\xEF\x13\xE8\x94\x9F\xAD\xE7\x07\x19\xB5\xFB\x06\x11\xEE\x83\xEA\x65\x72\x23\x07\xBF\xE6\x71\xF0\xB8\xCA\xD6\xFD\x32\x90\x01\xB7\xEB\x24\x05\xE3\xEC\x0B\x28\xA2\xDA\x66\x93\xEB\x24\xEF\x2E\x33\xD4\xE4\x2D\xA6\x64\xEF\xB8\xE5\xDC\xC5\xDC\xE0\x32\x4B\x03\x5B\xEC\x17\x09\x72\xE3\x08\x18\xDC\xF5\xDF\x0A\x33\xB7\xEA\x32\x05\xE6\xE2\x10\x17\xB9\xD0\x8A\xAF\x66\x76\xEC\x9E\xEE\x1D\x3F\x8C\xED\x02\x8F\xAB\xE6\x03\x42\xEE\x2E\x28\xBF\xDA\x59\xC7\xAD\xE4\x0F\x08\xBA\xFE\xDC\xE6\xBF\xA0\x01\xB7\xEA\x00\x07\x52\x50\x4B\x1E\xB9\xCF\xA8\xA2\x01\x6F\xEA\x08\x00\xD5\xE9\x8F\x0E\x73\xE4\x9B\x9B\xFC\x64\x7F\x5B\xEE\xA9\x0A\xCF\xE9\x7A\xD6\x0A\x17\xB5\xE1\xDD\xF6\x0B\x3E",
			"\xEE\x46\xEB\x2D\x60\x15\x0F\x56\xFA\x01\x27\xDD\xBD\x03\x3E\xEE\x33\xB8\xC0\x6A\x15\x0F\x56\xE9\x02\x27\xDD\x97\xEE\xF1\xEA\x5F\x9D\x7B\xEF\xEE\xEE\x71\xFD\xA4\xF2\xDF\x6F\xEA\x65\x01\xB7\xED\xDF\xED\x3D\xEA\x8C\x70\x05\x3E\xD5\xFC\xEE\x2F\xEF\x54\xEA\x71\xA7\xAD\xE2\x08\x08\xBC\xEA\xDC\x89\x02\x67\x00\xFF\xD9\xBE\xED\x7B\xAE\x65\xE3\x2E\xAF\xD5\x90\x01\x82\xEF\xC4\xEC\x99\xEA\xB9\x8F\x56\xFF\x04\x19\xDE\x8F\xEF\x07\xE5\x3C\x5D\x2E\x07\xAD\xEE\x0A\x1F\xBC\xF6\xDC\x91\xDF\x60\x61\xB7\xE9\x2F\x06\xF4\xED\x73\xFA\x97\xDA\xEA\x6F\xEA\xCC\x00\xC7\xEF\xE9\xE9\x0D\xEA\x8C\x7F\x05\x3C\xD9\xB2\xEF\xAD\xEF\x37\xE0\xC0\x68\xE5\x70\xF7\x58\xBD\xC3\xDD\xAD\xD3\xA1\x35\x61\x03\x5B\xEE\x1E\x0E\x7B\xE9\xBA\xFC\xC1\xE4\x2C\xC5\x01\xB7\xE8\x01\x05\x71\x68\x77\xF8\x7D\xCC\x87\x47\x01\x6F\xEA\x09\x01\xE3\x65\x37\x01\x79\xE9\x08\x03\x62\x50\x35\xC9\x01\xC9\xED\x41\x26\x0C\x3F\x6F\xEC\x0E\x4A\x03\x6F\xEA\x21\x01\xC6\x66\xCB\x1C\xFB\xE2\xA2\xC9\xC5\x0C\x03\x6F\xEA\x22\x00\xF1\xEE\x30\x27\xE3\x1D\xEB\x97\x4B\xAF\xD5\xA3\x00\xEA\xEF",
			"\x84\x00\xF9\xEC\xBD\x60\xAD\x30\x06\x2F\xD5\xA4\x00\xF1\xEE\x83\x03\xFC\xEB\xBE\x61\x3F\x6F\xAB\xE5\x00\x79\xEF\x68\x43\x8F\x1E\xC3\x8D\x55\x64\x0D\x0F\xAB\xE6\x00\x00\xF0\xFC\xD6\x8A\xCD\x2A\x36\x1A\x0F\x56\xE7\x01\x08\xE0\xAF\x97\x6C\xC1\x3F\x73\x5B\xE8\x05\x0F\x80\xF0\x50\xDF\x3C\x26\x8E\xFE\x24\x6D\x03\x5B\xE9\x05\x05\x81\xFB\xBF\xC1\x04\x10\xA8\xEA\x94\xED\xE9\x07\xF7\xE3\x15\x41\xAA\xAD\x1E\x03\x6F\xEA\x2B\x01\x11\xF1\xBD\x99\xCF\x50\x0E\x0F\xAB\xEC\x00\x2A\xF0\x77\xC5\x4E\x4E\x38\x07\xD6\xE0\x83\xFF\x77\xAC\xE2\x6F\xEA\x2E\x01\x1A\xF1\xC1\x9C\x35\x46\x0E\x0F\xAB\xEF\x00\x3A\xF0\x0B\x9E\x5D\x73\x5B\xE8\x06\x05\x81\xE9\x03\x19\xD0\xB1\xB5\x6F\xEB\x18\x01\xE3\x63\x64\x50\x42\xE1\x7C\xAF\xD5\xBE\x00\x4B\xF1\x95\x55\xCE\xE4\xCC\x2E\x0E\x0F\xAB\xCB\x01\x4C\xEF\x52\xF0\x13\xCF\x40\x30\x1E\x0F\x56\xF9\x02\x18\xE1\xD2\x56\x1F\xEE\x21\x7F\x5B\xEF\x0C\x0F\x85\xF2\x59\x66\xDC\xCC\x43\xF4\x00\xFC\xE9\x19\xF2\x67\x5B\x72\xFA\xAC\x86\xD6\xD1\xF0\x60\xF0\x98\xED\x5F\x30\x1F\x07\x79\xEB\xC3\xC2\xAD\x5B\xE8\x44\xCD\xB7",
			"\xEA\x27\x06\x0E\xFA\xB4\x59\xAD\xEF\x5B\x7C\x01\x3A\xEC\x3E\xF2\xD6\x54\xE8\xE3\x90\x3E\x07\x2F\xD5\xBA\x01\x82\xF0\x23\xF2\x37\xE7\x20\x7D\xAD\x08\x9C\x08\x03\x09\xF1\x72\xE8\x7B\x4A\x00\x05\x11\xFC\x10\x16\x06\x10\xE2\xC0\xE3\xCE\x9E\x4A\xF1\x93\xA3\xFA\xE9\x85\xF7\x50\xFB\xD0\x1A\xF1\xCE\x1B\x4B\xF2\x77\xED\x24\x70\x8A\xFE\x78\x3F\x8F\x4C\xF0\xBA\xE4\x65\x72\x02\x05\x14\xFF\x19\x1F\x1F\x57\xAE\x5A\xE3\xF9\x38\x56\xF2\xBD\x8F\x7F\x48\xB8\x59\xBB\xCC\x87\x0E\x00\xB2\xF0\x29\x0C\x2D\xF5\x13\xFC\x2C\xFE\x45\x79\xE2\xB9\x00\xAE\xF0\x5E\xF0\x58\xBB\xD2\xC9\x8B\xE8\x02\x3B\xE2\xF1\xF0\x8A\xEE\xE6\x40\x05\x01\x17\xF6\x05\x07\xC6\xE6\xE1\x81\xEA\xFE\x24\x0B\x01\x2E\xF4\x0C\x01\x8C\xE8\xC6\xDB\xDE\x9D\x4D\x18\x01\x5C\xF3\x1C\x05\x1A\xFF\x8C\xE1\xBD\xED\xCA\x1A\x00\xB9\xF0\x41\x00\x37\xF4\x0D\xF8\x13\xE8\xEB\xB9\xE2\x91\x01\xE3\xF1\x3B\xF1\x4F\xE0\x3C\x3E\x01\x19\xC5\xE0\x02\x4E\xF1\xE4\xF0\xCE\xDD\xAB\x60\x04\x09\x8B\xEE\x05\x30\xE3\xEA\xF1\x7A\xD4\xE6\x41\xDA\x7B\xDC\x2C\x0B\x17\xC7\xFD\xE1\xC0\xEF\xCC\x42\x12\x01",
			"\x2E\xF2\x19\x0E\x8F\xE3\xC4\xC7\xDF\x87\x3A\xB9\xF0\x6C\x01\x41\xF2\x11\xFC\x15\xE9\xD9\x79\xE2\xE6\x01\xE9\xF1\xFE\x55\xB8\xED\x23\x59\x8B\xF5\x07\x3F\x8F\x2E\x1E\x6B\x01\x89\xF0\x6B\x44\x05\x09\x8B\xF6\x07\x3F\x8F\x08\x27\x19\xF2\x74\xEC\xB4\x36\x05\x09\x8B\xF8\x07\x1F\xE4\x8C\x02\x7B\x3D\x9C\x4A\x15\xDD\x5B\x18\x8C\x87\x64\x68\x86\x9F\x26\x84\xD6\x96\xF1\x2C\x25\x5B\x2F\xFB\x04\x92\x2E\x3C\x2E\x1E\x3E\x01\x6E\x14\x73\x6B\x0F\x34\xC0\x4E\x03\xFA\xE4\xB9\x5C\x1F\x1E\x86\xF1\x38\x40\x08\x0F\x93\xFE\x97\x17\xDF\xFA\xEF\xE4\xBB\x20\x01\x51\xF4\xCC\x2C\x6F\xFA\xBC\xEC\x86\x42\x00\x4B\xF3\x9E\x2E\x1C\x05\x8C\xB4\xDE\xA3\x02\x39\xE2\x85\x22\x53\xF3\xA4\x3D\x1D\xC7\x2A\xFF\x88\x3F\x78\x3B\x01\x64\xBB\x47\x01\xA8\xF3\xFB\x2D\x0E\x07\x84\xF6\x8D\x08\x01\x39\xF1\xFA\x01\x53\xF2\x1C\x65\x09\xFE\x8B\x99\xC5\xC7\x00\x14\x46\x6A\x61\x29\xF1\xCF\x2C\x09\x09\x8B\xF4\x00\x14\x8C\x79\x60\x81\xE3\xC8\xB5\x2E\xF2\x04\x07\x97\xEB\xCB\xCD\xAB\xF9\x5C\x50\x01\x5C\xF0\x0C\x05\x2F\xF8\x08\x67\xC3\xD1\xA7\xB9\xF1\x3E\x00\xC2\xF1\x08",
			"\x25\x0D\xF1\xAA\x34\x02\x39\xE2\xCC\x00\x70\xF2\xBF\xF3\x17\xA8\x11\xC9\x8B\xF9\x02\x0A\xE6\x9D\x61\x78\xF0\x7B\x48\x16\x01\x17\xF7\x06\x17\xCC\xC1\x77\x7E\xF0\x03\x32\xC2\x7F\xB5\x6E\x33\xFC\x0A\x64\xC4\xE1\x6A\x5C\x00\xB9\xF1\x41\x00\x69\xF4\x16\x6A\x74\xEA\x6E\xA7\xE3\xAB\xF3\x64\xF2\xD7\xC1\x8F\x61\x17\xFF\x09\x10\xCD\xE6\xCA\xF6\x49\x62\x01\x5C\xF1\x2B\x04\x62\x4A\x0C\x78\xAE\xD6\x23\xB9\xF1\xBC\x00\xDB\xF3\xAC\xE0\xE0\x66\x06\x03\xC8\xD1\xE6\x85\xF3\xA9\xF1\x58\x20\x1A\x01\x17\xF7\x0D\x1C\xCD\xD2\xE6\xEB\xEB\x77\x35\x87\xF2\x70\xF7\x58\xE1\xDD\x39\xC5\xF4\x03\x53\xF3\xBD\xF1\xFF\x35\x2E\xF2\x00\x02\xB0\x52\x87\x7C\xC0\xF9\x9B\xB9\xF1\x08\x01\x77\xF2\x1F\x63\x60\xE1\xD5\x32\x01\x39\xF1\x1F\x01\xF1\xF0\x5E\xF0\x1A\xF7\xFA\x79\xC5\xED\x00\x63\xF3\xBD\xF2\x96\xE2\xEB\x79\x17\xFC\x03\x10\xCF\xCF\xE7\xFA\x8B\xBB\x97\x5C\xF3\x12\x06\x3E\xF8\x9C\xF4\x9E\xD2\xA9\xB9\xF1\x5A\x00\xFE\xF3\x62\xF3\x1D\xFD\x97\x3C\x03\x39\xE2\xE9\x00\xEA\xF3\xFB\xF2\xB0\xCF\xC0\x39\x8B\xF7\x03\x09\xE8\xFD\xF3\x07\xE6\xCD\xE5\x2E\xF5",
			"\x10\x0F\xA0\xE3\xD0\xED\xCF\xAD\xA8\xB9\xF1\x49\x01\x85\xF0\x33\xF7\x90\xEB\xB3\x79\xE2\xA1\x01\x1B\xF5\xCF\xF2\xF3\xE9\xCF\x56\x08\x19\xC5\xEF\x02\x02\xF4\x46\x62\x8D\xF1\xFA\x79\x17\xFE\x0B\x03\xCF\xEE\x3C\x6B\x25\x03\x20\xF2\xBA\x22\x02\x26\xF9\x2A\x7F\x78\x16\x62\x4C\x4F\x62\xF2\xF0\x31\x1E\x05\x2C\xF5\xC1\x79\xC5\xFF\x02\x63\xF3\xDE\x03\x1D\xF6\xCC\xE0\xA4\x79\x8B\xEC\x06\x00\xE9\x8C\x02\x42\xF4\xE8\xDC\x06\x81\x17\xF9\x0D\x01\xD1\xE4\xCB\x79\xF2\xA1\x34\x4C\x01\x2E\xF7\x1C\x0E\xA4\xE0\x00\x09\xE9\x86\xDE\x2F\x67\x8A\xF1\x95\xF7\x4A\xF4\xFE\xC3\xC8\x1C\x02\x39\xF1\x03\x01\x88\x56\x54\x0C\x4B\xF7\x27\xFF\xC8\x21\xE7\xE2\xF4\xF6\x0A\x32\xF6\x9F\xE5\x68\x69\x8B\xFE\x00\x28\xE9\xBB\x03\x6A\xF5\xD9\xEA\x82\x22\x14\x09\x8B\xEC\x01\x2F\xE9\xC8\xF4\xA0\xF3\x50\x34\x29\x01\x17\xFA\x03\x17\xD3\xC1\x41\x26\xF3\xCC\x42\x53\x01\x31\xF6\x4F\xF6\x10\x0A\xD3\xDC\xCA\x9E\x3D\xCC\xF0\x42\xF7\x40\x02\x4D\xF6\xFE\xAA\x05\x13\xE3\x8A\xF5\x02\x02\x35\xF7\x83\xD4\x15\x09\x8B\xF2\x03\x28\xE9\xBD\x03\x6A\xF5\x79\xE1\x2E\xF1\x10",
			"\x00\xA9\xEF\xD2\xC3\xE7\x85\xEF\xB9\xF1\x47\x00\x9A\xF1\x48\xF4\x5E\xFB\x03\xB9\xE2\x9C\x01\x97\xF4\x3C\xF6\x24\xE8\x8F\xB9\x8B\xEB\x05\x1D\xEA\xD6\xF4\xB6\xF1\x6F\x9D\x2E\xF1\x17\x0F\xAA\xEA\xD3\xEB\xBD\xF6\x29\xB9\xF1\x63\x01\xAA\xF7\x4F\xFC\x5F\xEF\x7E\x3A\x02\x39\xF1\xD6\x01\x5A\xF5\x79\xF6\x91\xB9\x8B\xE4\x07\x02\xEB\xEC\xF3\x3D\x2E\x5F\x01\x2E\xF2\x1E\x0B\xAB\xE5\xD4\xC3\xBE\xF6\x49\xC0\x01\x5C\xF1\x00\x05\x62\x59\x47\x0A\xD3\xEC\xCB\xCC\x94\xB9\xF0\x08\x00\xB5\xF1\x9A\x0A\xA6\xF4\xB4\xF9\x2D\xE8\xF3\xDB\xF5\xA9\x0A\x9A\xF7\xD2\xB9\xA4\xB9\xC5\xEE\x00\x61\xF5\x70\xF5\x52\xEE\x3D\x48\x19\x04\x9F\xE8\xD7\xEA\xEA\xF9\xF1\x1D\xA5\x5C\xF2\x12\x06\x5D\xFC\xAB\xF7\xD0\xCA\xE3\x4C\x01\xB9\xF0\x2C\x00\xBD\xF6\x59\xFD\xA1\xE0\xCF\x0E\x03\x39\xF1\x66\x01\x7D\xF7\xA2\xF3\xD8\xE1\x0E\x50\x06\x39\xE2\xF4\x00\xE1\xF5\xDE\x00\x29\x35\x5E\xF1\x0E\x52\x06\x39\xE8\xFD\x32\x5F\xF2\x08\xF4\x6B\x43\x1A\x0F\xB0\xE5\x88\x11\xEC\x86\x02\x0B\xF7\xA8\x8D\xC5\xF4\x83\xA7\xFC\xA4\xEF\x95\x03\x1B\xF6\x2D\x68\x1E\xF7\x5F\x99\x35\xF1",
			"\xAE\xFE\x0E\x3D\x01\x6C\xF2\xAD\x64\xE2\x7F\xB8\x28\x12\x05\xB2\xF4\xF1\x32\xE5\xEF\x2F\xDA\x01\x5C\xF1\x27\x02\x60\xFE\x05\x30\xD2\xCC\x87\x5C\x01\xAD\xF4\x9A\xF4\xFC\x41\x0C\xF6\x1B\x3E\x06\x33\xEA\xBA\xF6\x2E\x40\xC3\xF1\xAB\x60\x1C\x09\xAB\xE0\xDA\xE7\xEC\xCD\xE8\xCC\x42\x71\x01\x2E\xF5\x1A\x0D\xB2\xEA\xB7\x54\xD1\xDE\xAA\xB9\xF0\x71\x02\xD1\xF1\x33\xFA\xB0\x99\xC5\xF0\x03\x53\xF6\x61\xE8\xE6\x40\x3A\x01\x17\xFE\x0F\x18\xDA\xE3\x86\x9D\x4D\xEA\x01\x5C\xF0\x03\x03\x67\x5B\x1B\x07\xDA\xC4\xD7\x9D\x4D\xEC\x01\x5C\xF2\x06\x04\x6C\xFE\xB2\xF2\xCD\xEC\x86\x6E\x01\xB9\xF0\x14\x00\xDB\xF6\x69\xF8\x89\xFB\xC2\xF9\xE2\xB6\x00\x3B\x57\xDE\x02\xD9\xF0\x39\xE4\x9D\x39\xC5\xC5\x01\x73\xF6\xEE\x66\x42\xEB\x38\x71\x17\xF3\x05\x1B\x59\x66\xEC\xA5\xF5\x24\x69\x5C\xF0\x18\x01\x6F\xFD\xB6\xE1\x96\xCA\xE3\x78\x01\xB9\xF1\x37\x00\xE0\xF6\x25\x71\xAB\xEA\xA1\x79\xE2\xFD\x00\x93\xF7\x9A\xF6\xDF\xED\x98\x89\x8B\xEB\x04\x0C\xEE\xF4\xF6\x84\xEE\x18\x69\x2E\xF2\x13\x09\xB9\xFB\xD9\xF2\xC7\xA1\x35\x00\x00\x8A\x14\xE2\x20\x15\x05\xBA",
			"\xE1\xDA\xC8\xEB\xEF\x2F\xD7\x7F\x71\x2E\x2D\x07\x73\xF1\xB8\xF2\xCF\xE4\x59\x04\x00\xAA\xF6\xA4\x24\xED\xF4\x72\xF0\x68\xFD\xCB\x06\x00\x39\xF7\x65\x17\xDD\xF6\xE6\xF6\x3F\xFC\x1C\x48\x00\x00\xEF\xEB\x23\xC2\xF6\xD3\xF6\xA6\xEF\x16\x6A\x00\x07\xDE\xF8\x36\x2D\xF7\x7B\xF7\x46\x9F\x4C\x76\x79\xF3\x10\x19\x60\x65\xED\xD3\xEA\xE1\x40\x07\x00\xF5\xF2\x37\x06\xBD\xED\xDC\xD0\xC5\xA1\x35\xDE\x7E\xBA\x2D\xF7\xF0\x74\xF0\xDF\xDB\xF7\x12\x00\x5B\xF7\x61\x2D\xF1\xF5\xED\xF5\x21\xF9\xE7\x54\x00\x28\xEF\xB8\x00\x19\x59\xDE\x02\x2C\x35\xCF\x34\xDE\xB6\x00\x14\x2C\x4C\x6B\xF3\xF6\xFD\xE4\x6B\x47\x02\x08\xBE\xE7\x02\x19\xB0\x2E\x1E\xF9\xF7\xFC\x68\x79\xB9\x03\x07\xBF\xF1\x85\x3D\x4B\x21\x4F\xE4\xBA\x0D\x01\x01\xFE\x5F\x27\xC0\xED\x9E\xC2\xBF\x68\xF7\x48\x01\xFF\xF4\xBF\x27\xE3\x13\x08\x19\xAC\xCB\xF0\x91\x38\x2A\xF5\x4E\x4E\x07\x00\x7D\xF9\x04\x12\xE0\xCB\xC8\xD3\xBA\xE4\xBA\x10\x03\x05\xFD\xE7\x20\x8C\x31\xD1\xCB\xB5\x14\x16\xFD\x75\x0A\xF8\x72\x6C\xBC\xB6\x02\x03\xE1\xEB\xD9\x7F\xBD\x4A\xD8\x17\xF8\x78\x33\x5E\x2B\x69\x64",
			"\xEF\xA8\x00\x32\xF8\x7D\x32\x67\x30\xF9\xF4\x35\x49\x02\x18\xE1\xC5\x44\x07\x01\x1F\x1F\x07\xED\x47\x50\x7D\xFF\xC3\xFF\x78\x2C\xD4\xA4\x52\x44\xF8\xDB\x20\x10\xFD\xD1\xE3\x92\xE9\xE2\xCA\x48\x09\x01\x1F\x1F\x44\x3E\x0B\x7C\x62\x17\x09\xDA\xC6\x00\x46\x64\xBB\x33\x00\x2A\xFA\x58\x77\xE3\x10\xC5\xE4\xF6\x7E\xF0\xA2\x73\x19\xF8\x03\x30\xFA\xF2\x09\x0E\xC1\xFD\xCA\x5E\x81\xE4\xBB\x39\x01\x2F\xFA\x82\x25\x11\x03\xFA\xCD\x37\xEA\xF1\xF1\x75\x22\xF6\xD5\x2B\xFC\x7B\x00\xB9\xC1\x5E\x0E\x28\x63\x43\xF4\x6A\xA6\xF4\xF4\x16\x05\x8E\xFE\x46\x4F\xD9\xED\x63\xE8\xF7\x65\x00\xF5\xF4\xEF\x66\xD2\xB9\x94\xEF\xE3\xF7\xEB\x36\xF6\x79\x5C\x21\x00\xFA\xF3\x0E\x02\xC8\xFF\x49\x7C\xEC\x8A\x24\x44\x00\xF4\xF5\x20\x05\x91\xF0\x4A\x22\xDA\xF7\xC2\x46\x00\xE8\xF7\x47\x00\x25\xFA\x95\x2C\x98\xEC\x0E\x48\x01\x68\xF7\x9D\x00\x3E\xF8\x13\xFB\x32\xF1\x0E\x5A\xFF\x65\xBB\x1B\xF9\x77\xF9\xFA\xD1\x38\x44\x09\x08\xBE\xF8\x05\x28\xF2\xF9\xF4\xCC\x42\x27\x00\xFA\xF6\x18\x0F\xCA\xFF\xAD\xC0\xE6\xE8\xF7\xD4\x01\x5A\xFB\xD9\xF5\xD3\x68\xBE\xE2\x07",
			"\x3A\xF2\xCA\xEB\x2C\x7E\xF4\xF4\x3C\x07\x97\xFE\x00\xE8\x04\xE8\xEF\xFE\x01\xF1\xF7\x3E\xFB\x63\xDA\xE7\x78\xBE\xED\x00\x18\xB1\x31\x0A\xA9\xF9\xDE\xC1\x38\x42\x0B\x08\xBE\xFB\x00\x0F\xF3\xC8\x0A\xD1\xF8\xEA\xE0\x7C\xD0\x7D\xF8\x02\x17\xE6\xD3\x15\x59\xF9\x1B\xD6\x50\xC0\xFA\xF7\x06\x0E\xCD\xFB\x0D\x20\xF3\xAF\xE0\xAC\x42\x30\x00\xFA\xF5\x08\x05\xCE\xEA\xE6\xD2\x9A\xAC\x43\x62\x00\xF4\xF7\x14\x06\x9B\xFD\x1B\x07\xE7\xCD\x8F\xAA\x94\xE8\xF6\x31\x01\x3B\xFB\x94\xFF\x69\xDC\x38\xE8\xEF\xF0\x00\xFB\xF9\x99\xEB\xEB\xF0\x3C\x37\x00\x83\xB7\x3E\x01\x74\xF9\xEE\xF9\x6B\xF3\x9D\x30\x7D\xFD\x08\x08\xE8\xFC\xF3\xF8\xF3\xF6\x48\x36\x00\xFA\xF4\x13\x0E\xD0\xE2\xE8\xC4\xEF\xF4\xA7\xE8\xF7\x55\x01\x45\xFB\x90\xF4\xA0\xE5\x88\x30\x01\x68\xF7\xBA\x01\x80\xF8\x47\xFA\x1E\xF6\x45\x88\xDF\xC8\x03\x22\xFA\x8E\xF8\xDD\xEE\x32\x74\x0E\x08\xBE\xF6\x06\x28\xF4\x95\xF9\x00\xF3\x05\xA8\xFA\xF4\x1C\x0F\xD2\xFC\xE4\xFD\xEB\xCB\x65\xE8\xF6\x79\x01\x4D\xFF\x9C\xF2\x08\xE8\x82\x28\xEF\x80\x00\x5E\x59\x68\x0B\x23\x01\x8E\xF8\x54\x3C\x03\x28",
			"\xEF\x8F\x00\x41\xFA\xFB\x0B\x50\xF8\x8F\xFF\x45\x68\xDF\xDC\x00\x49\xFA\xDE\x03\xA5\xFA\x92\xF3\x20\x30\x08\x08\xDF\xE9\x00\x49\xFA\xBB\x02\xA9\xF8\xF6\xD9\x74\xE3\xCE\xF8\xEA\xF4\x91\x0F\xF9\x8D\x6D\x75\xFA\x57\xFE\x19\x46\xC9\xFC\x71\xB2\xF3\xE3\xFA\xCA\x21\x4E\xF9\x9E\x58\x11\x08\xBE\xE1\x03\x10\xF5\xDF\xFA\x72\xF1\x82\x22\x22\x00\x7D\xFE\x06\x08\xEB\xE5\x52\x54\xF6\x56\xC6\xF4\xF4\x1F\x06\xAE\xFF\x4A\x30\xE5\xD7\x39\xE8\xF7\x8A\x00\xBE\xF9\x40\x02\xAB\xFF\x9F\xDB\xF7\x10\x02\x68\xF7\x98\x00\xC1\xF8\x00\x04\xB0\xF5\xA0\xC2\x10\x68\xEF\xA6\x01\x8A\xFA\xC6\xFA\x82\xD1\x63\x68\xBE\xF4\x05\x11\xF6\xB7\xF3\x65\xA8\xF4\xF6\x30\x01\xA9\xFD\x1B\x12\xEC\xE4\x4D\x98\x01\xE8\xF7\x68\x03\x65\xFF\x53\xF2\xF5\x68\xDF\xDF\x03\x6F\xFA\x64\xFB\xE4\xF1\x46\x30\x7D\xFC\x0E\x1C\xEC\xF0\xF5\x8E\xF7\x2D\x82\xF4\xF7\x3E\x03\xB4\xF4\x9D\xE1\xD5\x20\x02\x68\xF7\x09\x00\x44\x59\x56\xFE\xBE\xE6\x19\xA8\xDF\xD7\x00\x08\x59\x9D\xFB\xEF\xF1\xA8\x98\x7D\xF6\x02\x1A\xED\xEF\xF6\xFD\xF9\xB4\x76\xF4\xF4\x0D\x06\xB8\xF9\xDA\xE6\x1F\xAF\x5B",
			"\x28\x01\xE8\xF6\x21\x00\x70\xFF\xB8\xF8\x50\xED\x8D\xA8\xEF\xD1\x00\xD3\xFB\xE6\xF8\x49\xEA\x8E\x98\xBE\xE0\x03\x19\xF7\xE9\xFA\xE5\xF0\xD5\x2A\x2B\x00\x7D\xFF\x06\x1F\xEE\xF7\xF5\x9D\xFA\x6C\xB8\xF4\xF6\x1F\x04\xB9\xF0\xDE\xE4\xE9\xC0\xDC\x32\x01\xE8\xF6\x46\x00\x7B\xFF\xBC\xF0\xAF\xED\x95\x74\x02\x68\xF7\x9A\x01\xF9\xF9\x5F\xF9\xA6\xF6\x1D\xA8\xDF\xE8\x02\x7A\xFB\x83\xFB\x89\xE5\x4D\x90\x7D\xF6\x0B\x00\xF0\xCB\xF6\x84\xF6\x12\x7C\xF4\xF4\x31\x06\xBC\xF5\xE4\x31\xE2\xF8\x97\xA8\xF8\xB1\x20\x86\x26\xEC\x3C\xBC\xB1\x0C\x06\xE4\xC8\x55\x12\xFC\xED\xFA\x5A\x82\x85\xF8\xB7\x26\x8F\x3C\xCF\x64\x77\xC3\x01\x1B\xFD\xF0\x83\xC7\x18\xD2\x3D\x5F\xCE\xE2\xFC\x54\x13\x01\x1F\x1F\x4A\x00\x79\xBE\x18\x06\xE2\xEA\xAD\x2A\xF8\xDF\xEA\xEB\xF4\xF4\xF7\x34\x00\x91\x5E\xF2\x17\x98\x09\x04\x7D\x31\xD3\x5C\x8A\x16\x5A\x94\xC4\xF5\x56\xE9\x79\xB8\xF2\xB4\xFC\x71\x7D\x8F\x1C\x9B\xEA\xDD\x5D\xE2\xE8\xAA\x13\x64\x34\x29\x63\xE2\x1D\xFD\x2C\x23\x13\x0F\xF1\x19\x04\x24\x77\xD6\x01\x4A\xFD\x8C\x31\x93\xFC\xBC\xBA\x0D\x11\xF2\xE4\x59\x1D",
			"\x01\x1F\x1E\x8D\x30\xB4\x36\x1B\x01\xE2\xE3\x78\x20\x64\x09\x02\x58\xFD\x86\x45\x97\xFF\x67\x03\xE5\xF2\x21\xD6\xF9\xBD\x2E\x28\x32\xAD\x05\x8A\xC3\xCC\xF1\x6F\x85\xF3\xE5\x8C\x67\xFC\xEF\x2E\x51\x03\xC7\x19\x14\x0B\xF8\xAC\xF3\xCB\x24\x9F\x1E\x5F\xFD\x7D\x3E\x3A\x06\xCE\xF1\x70\x9F\x78\x0C\xF9\xBC\x46\x7C\xFC\xC6\x87\xC7\x1F\xC8\xFB\xEF\x2C\x07\x01\xFA\x94\x87\x1F\x1F\x51\x00\x79\xBD\x1D\x07\xE8\xFC\x8A\x1F\x3C\x72\xFC\xD0\x34\x77\x01\xA3\xFD\x26\x3E\x1A\x91\xFC\x8D\xFA\xC3\xFC\x83\x86\x1E\xC9\xA3\xFE\x14\x0F\xF1\x05\xCA\x16\xBD\x45\xFC\xE8\x2D\x8F\x1F\x29\x04\xBC\xB3\x0F\x1A\xE2\xD4\x12\x9F\x1E\xAB\x00\x88\xE8\xA8\xFF\xF9\x19\xEA\xF1\x38\x02\x91\x8D\xFD\xAC\x01\x8F\x1C\x59\x36\xED\x50\xEB\xFD\xF4\xDE\xD4\xE8\xF7\xD5\x00\x20\xFF\x4A\x0F\xE3\x16\x95\x3D\x11\xCD\xFA\xAD\x01\xB2\xFC\xF2\xB9\x3F\x05\xD1\xFD\xEB\xFB\x24\xAD\xD4\xAD\xFA\xBA\xFC\x41\x0C\xAF\xFC\xA6\xE5\xAF\x04\x28\x81\xFB\x88\x47\xCD\xFD\x58\x21\x57\x30\xC6\xFD\x69\x42\x00\x35\x2B\x08\x27\xD7\x01\x64\xFE\xCA\x22\x31\x84\x24\xD5\x57\x30\x25\xB3\xFD",
			"\x90\x8B\x75\xD1\xB4\xFE\xD3\x8F\xF1\x11\xF5\xED\x8E\x63\xFD\x78\xB8\x21\xFC\x79\xBC\x01\x07\xED\xEC\x08\x18\x03\x5A\xFD\x02\x02\xB5\x32\xBD\x0C\xBC\xBE\x00\x0D\xF7\xD2\x68\x9F\x1E\xBD\x00\xF2\xB8\x04\x06\xDE\xF0\x76\x9F\x78\x3C\x02\x64\xBB\x12\x00\x74\xFF\xF2\x8C\xA8\xF8\x5B\x33\x00\x3C\xFB\xF3\x17\x88\x58\xEF\x03\x2D\x00\x65\xFB\x2F\xA7\xF8\xD1\x4C\x89\xFE\xFF\x8E\x3F\xF9\x5F\x37\x02\x0E\xF0\xE1\x08\x33\x03\x06\xFC\x0B\xFE\x2D\xF0\xEE\x85\xE2\xFC\xEF\x00\x6B\x7B\x06\x19\xFE\x10\xD3\x81\x33\x06\x04\xE3\xFF\x00\x1E\xF8\xD1\xFC\xB6\xE1\x03\x1F\x0E\x00\xC7\xFD\x03\x06\xF2\xEA\x38\x1F\x3C\x7F\x32\xD0\x35\x0F\x02\xC0\xF8\xFA\x8A\xD6\xF3\xC7\xDC\xFC\xAB\x00\x60\x5A\x85\xFF\xD3\xF2\xAF\xBC\xF1\xF8\x01\x2D\xFC\x86\x02\x20\xFF\xD3\xD4\x78\x34\x04\x0C\xF1\xE6\x02\x3F\xFC\x83\x02\x41\xFE\xD6\xD7\x41\x3C\xE3\xF4\x05\x07\xFA\xC2\x04\x49\xFE\x6D\xE6\x95\xCC\xC7\xFA\x0C\x0E\xF4\xE8\x91\xED\xE6\xC5\xEB\x1C\xFE\x38\x01\xD5\xF9\x99\x61\x89\xFD\x34\x6C\x00\x1C\xFE\x7E\x01\xAD\xFC\xD4\xFC\x78\xDB\xEF\x2E\x01\x1C\xFC\x8C\x01\x60",
			"\x5B\xDE\x03\xD8\xF9\x56\xCC\xF1\xFB\x04\x22\xFD\x82\xF7\x5A\xA0\x8E\xFD\x2A\x01\xE7\xF7\xF2\xF5\x4A\xE5\x93\x9C\xFE\xB6\x01\xB4\xFD\xDD\xF8\x3A\xF3\x90\x36\x01\x1C\xFC\xC5\x01\x6F\xFE\xF2\xD5\xA8\x30\x07\x0C\xF1\xF3\x06\x01\xFE\xEF\xF9\x57\x78\x8E\xFD\x38\x02\xEF\xFE\xF2\xFD\xD5\xE0\x1E\x9C\xFE\xF0\x01\xC3\xFC\x72\xFE\x9E\x4E\x03\x1C\xF8\xFE\x03\x12\xFF\xA4\xCD\xC3\x70\xC7\xFC\x01\x00\xE4\x4A\xFB\xCF\xEB\xB7\x91\x1C\xFF\x0D\x01\xE7\xFB\xEF\xF0\xD1\xFD\x34\x44\x01\x1C\xFE\x2A\x01\xD1\xFD\xE3\xFF\xA2\xFD\x2A\x66\x02\x1C\xFC\xB9\x00\xAA\xFE\xA0\xFE\xEB\xE9\x54\x38\x04\x1C\xF8\xC8\x01\x40\x5C\x1F\xFE\x75\xF4\xC2\xC4\xE3\xF6\x05\x18\xFD\xE4\xFE\xD0\xAE\xAB\xF8\x8E\xFC\x19\x06\xF7\xFB\xFA\xFF\xDE\xF1\xF2\x9C\xFE\x72\x00\xE2\xFE\xEC\xFF\xA6\xF5\x10\x30\x02\x1C\xFC\x80\x01\xCA\xFE\xA4\xFC\x82\xFD\xE4\x7C\xF1\xEE\x04\x31\xFE\xEF\x29\x04\xFF\xE7\x1C\x15\x04\xE3\xFD\x09\x00\x72\x5E\x07\x77\x32\x4C\xFA\xF0\x32\x15\x04\xE3\xFA\x0A\x1E\xFE\xCC\x04\x60\xFF\x53\xFB\xB2\x74\xC7\xFF\x16\x01\xFD\xF6\xA7\x08\xF2\xAD\x65\x5A\x01",
			"\xBF\xFD\xFB\xFE\xE2\x00\xD6\xEA\xAD\x1C\x01\x05\xFF\xF3\xFE\x00\x00\xFA\xFE\x69\xED\x69\x5E\x02\x0A\xFE\xF9\xFF\xFB\x7F\xAD\x57\x74\x76\x1C\x7F\xEF\x00\xE6\x7F\x13\x07\x3B\x7F\xAD\x32\x62\x00\x1C\x7F\xFC\x00\x00\x80\x78\x7D\x03\x19\x64\x00\x1C\x7F\x0A\x00\x8A\x2E\x52\x05\x01\x80\xD0\x70\x5E\x21\x1C\x7F\x18\x00\x13\x80\x49\x05\x15\x80\xD8\x70\xF7\x29\x1C\x7F\x26\x00\x1A\x80\xBB\x01\x1C\x80\x87\x7A\x46\x2C\x1C\x7F\x34\x00\x21\x80\xE7\x7F\x5D\x7F\x72\x18\x1C\x7F\x42\x00\x28\x80\x07\x80\x75\x7B\xA1\x1A\x6E\x00\x1C\x7F\x50\x00\x1A\x80\xBD\x01\x1C\x80\x64\x53\x70\x00\x1C\x7F\x5F\x00\x2E\x80\x93\x41\x70\x7F\x03\x19\x72\x00\x1C\x7F\x6D\x00\x1A\x80\xDF\x7F\x88\x7B\xCC\x21\x74\x00\x1C\x7F\x7A\x00\x35\x80\x29\x80\xAB\x7A\x3D\x17\x76\x00\x1C\x7F\x89\x00\x3C\x80\xD8\x7F\x82\x7F\xCC\x21\x78\x00\x1C\x7F\x97\x00\x51\x80\xEE\x7F\x9B\x7B\xE9\x32\x1C\x7F\xA5\x00\x4A\x80\x2F\x80\xA1\x7B\xFE\x12\x7C\x00\x1C\x7F\xB4\x00\x58\x80\xF4\x7F\xA7\x7B\xCC\x21\x7E\x00\x1C\x7F\xC2\x00\x65\x80\xFA\x7F\x95\x77\xC2\x1A\x1C\x7F\xD0\x00\x5E\x80",
			"\x3D\x80\xB6\x7B\x24\x7C\x1C\x7F\xDF\x00\x72\x80\x52\x80\xDE\x78\xB7\x30\x84\x00\x1C\x7F\xEE\x00\x78\x80\x59\x80\xAC\x7F\xB7\x30\x86\x00\x1C\x7F\xFD\x00\x7F\x80\x66\x80\xCB\x7B\x00\x37\x88\x00\x9B\x7F\xB9\x2E\x22\x80\xBA\x7F\xD9\x18\x1C\x7F\x1A\x00\x8C\x80\x4B\x80\xF5\x7D\xB7\x30\x8C\x00\x1C\x7F\x28\x00\x92\x80\x5F\x80\xC6\x7F\x57\x4E\x1C\x7F\x36\x00\x99\x80\x73\x80\xF4\x73\xAD\x32\x90\x00\x1C\x7F\x44\x00\x9F\x80\x79\x80\xFB\x73\x02\x22\x1C\x7F\x52\x00\xB9\x2E\xBD\x01\xB9\x00\x1F\x0F\xB5\x00\x9E\x6A\xDE\x7E\x93\x48\x1F\x0F\xAE\x80\xB6\x59\x33\x7F\xEB\x48\x1F\x0F\x1C\x80\xAA\x37\xB7\x80\xF1\x48\x2F\x7F\xE4\x5D\xAA\x40\x4A\x75\xA0\x40\x1F\x0F\x63\x7F\xEF\x16\x9D\x00\xBC\x80\x05\x11\xF9\x7E\xA5\x08\xE4\x5D\x9E\x00\xC7\x80\xB6\x11\xBE\x00\xD9\x7F\x03\x0F\x9F\x00\x1C\x7F\x61\x00\xB9\x2E\xDE\x01\xCF\x80\xE1\x7F\x7D\x19\xA1\x00\x1C\x7F\x6E\x00\xD5\x80\x3E\x08\x12\x7F\x05\x11\xA3\x00\x1C\x7F\x7B\x00\xA6\x80\xA2\x2E\xEF\x7F\xB7\x30\xA5\x00\x4F\x80\xE4\x80\x01\x01\xD7\x80\x21\x7F\xA1\x1A\xA7\x00\x56\x80\xEA\x80\x00\x00",
			"\xEC\x80\xFC\x7F\xEF\x16\xB0\x40\xE3\x16\xA5\x00\xF1\x80\xF3\x80\x02\x01\xC1\x00\xE4\x5D\xAB\x00\xCD\x80\x0A\x12\xFA\x80\x65\x7A\x03\x19\xAC\x00\x1C\x7F\xB3\x00\xDD\x80\x40\x08\x08\x80\xAB\x54\x1C\x7F\xC0\x00\xF9\x80\x0E\x80\xCC\x4E\x1C\x7F\xCE\x00\x0D\x81\x59\x7B\x79\x2E\xB2\x00\x1C\x7F\xDC\x00\x12\x81\x5F\x7B\x13\x17\x1C\x7F\xEA\x00\x18\x81\xA7\x59\xE6\x46\x1C\x7F\xF8\x00\x1D\x81\xAE\x59\xD8\x1E\x1C\x7F\x06\x00\xA0\x2F\xBB\x01\x01\x81\x64\x7F\x94\x35\x1C\x7F\x14\x00\xA0\x2F\xBD\x01\x29\x81\x64\x53\xBC\x00\x1C\x7F\x23\x00\x27\x81\xDE\x80\xA4\x7D\xFE\x12\xBE\x00\x1C\x7F\x31\x00\xA0\x2F\xD6\x80\x45\x80\x0F\x47\x1C\x7F\x3E\x00\x2E\x81\x36\x81\xB0\x7D\x52\x4A\x1C\x7F\x4D\x00\x35\x81\x08\x81\x53\x80\xEC\x54\x1C\x7F\x5B\x00\x48\x81\x3C\x08\xBC\x7D\x91\x19\x1C\x7F\x69\x00\x42\x81\x49\x81\x60\x80\x64\x16\xC8\x00\x1C\x7F\x78\x00\x4E\x81\x4C\x08\xC3\x7A\x1D\x52\x1C\x7F\x86\x00\x5B\x81\xE5\x80\x03\x7D\x71\x49\x1C\x7F\x94\x00\x54\x81\x4F\x81\x74\x80\xEF\x17\xCE\x00\x1C\x7F\xA3\x00\x67\x81\x5C\x81\xBD\x7B\x05\x11\xD0\x00",
			"\x1C\x7F\xB2\x00\x6E\x81\x62\x81\x81\x80\x00\x37\xD2\x00\x1C\x7F\xC1\x00\x75\x81\xEB\x80\xB3\x7F\xCC\x21\xC2\x40\xE3\x16\xD0\x00\x61\x81\x7D\x81\xB4\x77\x49\x4D\x1C\x7F\xDE\x00\x83\x81\xF2\x80\xD8\x7B\xAC\x21\xD8\x00\x1C\x7F\xEC\x00\x89\x81\x29\x81\xB5\x76\xAA\x15\xDA\x00\x1C\x7F\xFA\x00\x90\x81\x02\x7E\x05\x41\x1C\x7F\x08\x00\xE0\x2F\x28\x81\xD3\x7F\x03\x34\x1C\x7F\x16\x00\xE0\x2F\xBD\x01\xBF\x00\xD0\x80\x8C\x0C\x1C\x7F\x25\x00\xE0\x2F\xDE\x01\xA4\x81\xD8\x80\xA5\x17\x1C\x7F\x32\x00\xA9\x81\x52\x08\xDF\x80\xB6\x11\xE4\x00\x1C\x7F\x3F\x00\x9C\x81\xB1\x81\x1A\x7F\xAE\x44\x46\x81\xB7\x81\x54\x08\xF5\x7F\x48\x15\xE8\x00\x4C\x81\xBC\x81\x56\x08\x65\x7D\xCA\x38\xEA\x00\x52\x81\xC2\x81\x50\x08\x35\x7F\xB7\x30\xEC\x00\x1C\x7F\x77\x00\xB0\x81\xBD\x81\x71\x7D\xB6\x11\xEE\x00\x1C\x7F\x84\x00\xC8\x81\x9B\x35\x0E\x81\xCC\x21\xF0\x00\x1C\x7F\x92\x00\xD6\x81\x01\x01\xAB\x81\x50\x6E\xAC\x21\xF2\x00\x1C\x7F\xA0\x00\xDD\x81\x00\x00\xDF\x81\xEF\x6A\xE1\x20\xF4\x00\x1C\x7F\xAE\x00\xE5\x81\xE7\x81\xB7\x6B\xD5\x71\x1C\x7F\xBC\x00",
			"\xED\x81\x2A\x80\x03\x19\xF8\x00\x1C\x7F\xCA\x00\xF3\x81\x30\x80\xCC\x21\xFA\x00\x1C\x7F\xD8\x00\xA2\x81\xB8\x81\x9E\x78\x7F\x78\x1C\x7F\xE7\x00\xF9\x81\xA3\x78\xAC\x21\xFE\x00\x1C\x7F\xF5\x00\xCF\x81\xC3\x81\xAA\x7D\x07\x5B\x63\x0C\x7F\x15\x23\x25\xA3\x81\xB0\x78\x06\x26\x0F\x82\xA4\x01\x23\x25\xBB\x01\xEE\x81\xE1\x71\xAC\x21\x04\x00\x15\x82\x4D\x13\x17\x82\x00\x82\xD9\x79\xD4\x4F\x1D\x82\x37\x06\x11\x82\x20\x82\xC3\x78\xAC\x21\x08\x00\x23\x82\x03\x01\x3C\x00\x1F\x82\xD0\x81\xC9\x78\x79\x2E\x0A\x00\x2A\x82\x7F\x22\x2D\x82\x0C\x82\xCE\x7D\xAE\x28\x32\x82\x75\x26\x25\x82\x2E\x82\x0A\x7D\x03\x19\xD9\x40\xE3\x16\x67\x00\x3A\x82\x35\x82\xDB\x7D\xCA\x38\x10\x00\x38\x82\xA2\x1A\x41\x82\xC9\x81\xE1\x7D\x48\x15\x12\x00\x46\x82\x85\x00\x48\x82\xD7\x81\xE8\x7D\x0A\x12\x14\x00\x46\x82\x94\x00\x34\x82\x49\x82\xEE\x7D\x8B\x64\x46\x82\xA2\x00\x56\x82\x50\x82\x94\x80\x00\x37\x18\x00\x46\x82\xB0\x00\x5C\x82\xDE\x81\x75\x70\x9D\x26\x1A\x00\x46\x82\xBE\x00\x63\x82\xE6\x81\x98\x81\x41\x41\x46\x82\xCC\x00\x6A\x82\x19\x82\x39\x72",
			"\xEF\x16\x1E\x00\x46\x82\xDA\x00\x4F\x82\xAB\x2E\xAF\x80\x21\x7C\x63\x0C\x70\x49\xFC\x80\x68\x08\x2C\x7C\x63\x0C\xCC\x35\xAA\x1E\x42\x82\xAC\x21\x27\x00\x80\x82\x4C\x4A\x1F\x0F\x7D\x82\x5C\x34\x86\x82\xFE\x12\xC3\x00\x1F\x0F\x29\x81\x15\x24\x8B\x82\xA1\x35\x1F\x0F\x92\x19\xD0\x1A\x2A\x00\x91\x82\x84\x4B\xA8\x7E\xE4\x5D\x2B\x00\x46\x82\xE9\x00\x23\x25\x2E\x0F\x50\x13\x06\x01\x94\x82\x23\x24\x97\x82\xEF\x17\xA0\x82\x03\x01\xAD\x7E\x65\x7F\x46\x82\xEA\x00\x9E\x82\x98\x4C\x79\x82\x32\x29\x46\x82\x05\x11\xBB\x12\x6D\x09\xE4\x5D\x32\x00\xA4\x82\xE0\x19\xC8\x00\xA5\x81\x07\x14\x46\x82\xEB\x00\x23\x25\xDE\x01\xB8\x82\xAC\x81\xF0\x1E\x46\x82\xF8\x00\xBD\x82\x4A\x0A\xB2\x81\x0A\x12\x37\x00\x46\x82\x05\x00\x89\x30\xBB\x01\xBF\x82\x40\x73\x7E\x36\x46\x82\x13\x00\xCB\x82\xC5\x82\x7F\x79\xAD\x32\x3B\x00\x46\x82\x21\x00\xD2\x82\x53\x0A\x61\x7C\x03\x19\x3D\x00\x46\x82\x2F\x00\x89\x30\x2E\x0F\xCD\x82\xF4\x80\x03\x19\x3F\x00\x46\x82\x30\x00\xD9\x82\x5A\x0A\xCA\x81\x00\x37\x41\x00\x46\x82\x3E\x00\x89\x30\xBE\x82\x09\x81\x00\x37",
			"\x43\x00\x46\x82\x4B\x00\xE8\x82\x5F\x0A\xD8\x81\x79\x2E\x45\x00\x46\x82\x59\x00\xF6\x82\x0D\x2C\x7E\x7D\x88\x53\x46\x82\x67\x00\xFD\x82\x01\x01\xE2\x82\x85\x7D\xE1\x20\xF4\x40\xD7\x36\x03\x83\x6A\x3B\x57\x7F\x9D\x26\x4B\x00\x46\x82\x83\x00\x0A\x83\x05\x83\xBE\x6B\x8A\x24\x46\x82\x91\x00\x11\x83\x98\x7D\xEF\x16\x4F\x00\x46\x82\x9F\x00\x89\x30\xBD\x01\x12\x83\xBD\x6C\xF6\x24\x51\x00\x46\x82\xAE\x00\x17\x83\x37\x81\x64\x16\x53\x00\x46\x82\xBC\x00\xEF\x82\xD3\x82\x76\x7F\xAE\x53\x46\x82\xC9\x00\x1D\x83\x2C\x83\x7C\x7F\x01\x30\x46\x82\xD8\x00\x25\x83\xB5\x7D\xCC\x21\x59\x00\x46\x82\xE6\x00\x37\x83\x21\x82\xCC\x21\x5B\x00\x46\x82\xF4\x00\x31\x83\xDA\x82\x8E\x7F\x36\x18\x46\x82\x03\x00\x76\x31\xCC\x82\x5D\x81\xD5\x36\x46\x82\x11\x00\x49\x83\x32\x83\x02\x01\xAF\x1E\xE0\x50\xB0\x82\xB5\x1C\x41\x7C\xE4\x5D\x63\x00\x46\x82\x1F\x00\x76\x31\xE1\x82\x16\x76\xB3\x2E\x01\x41\x30\x18\x5B\x83\x50\x83\x26\x28\xE4\x5D\x67\x00\x54\x83\x0A\x12\x1F\x83\xCD\x00\xE4\x5D\x69\x00\x66\x83\x3C\x15\x1F\x83\xD7\x00\xE4\x5D\x6B\x00\x6C\x83",
			"\xAA\x15\x1F\x83\xCE\x00\xE4\x5D\x6D\x00\x72\x83\x48\x15\x1F\x83\xD4\x00\xE4\x5D\x6F\x00\x78\x83\x19\x64\xFB\x76\xE4\x5D\x71\x00\xD7\x82\x61\x83\x44\x83\x7B\x16\xE4\x5D\x08\x41\xE3\x16\x22\x00\x84\x83\xE9\x82\xA1\x0C\xE4\x5D\x75\x00\x7E\x83\xCF\x0F\x1F\x83\xAB\x18\x2A\x37\x46\x82\x23\x00\x8B\x83\xF7\x82\x05\x0C\xE4\x5D\x79\x00\x90\x83\x03\x0F\x1F\x83\x25\x71\x03\x0F\x7B\x00\x46\x82\x24\x00\x76\x31\x1E\x83\x9F\x7F\x90\x41\x46\x82\x33\x00\xA4\x83\x62\x83\x00\x00\x98\x7E\x52\x3D\x46\x82\x42\x00\x76\x31\x8E\x78\x1F\x0F\x73\x76\xE1\x20\x0F\x41\xE3\x16\x44\x00\x97\x83\xFE\x82\x8B\x07\xE4\x5D\x83\x00\x46\x82\x45\x00\xB9\x83\x04\x83\x8A\x6F\xA3\x27\x46\x82\x46\x00\xAA\x83\x85\x83\x03\x01\x47\x7C\x62\x37\x46\x82\x55\x00\xC0\x83\x0B\x83\x0F\x7D\xF6\x24\x89\x00\x46\x82\x56\x00\xCD\x83\x1F\x83\xDE\x7A\x7F\x39\x46\x82\x57\x00\xC6\x83\x8C\x83\x88\x80\xCA\x38\x8D\x00\x46\x82\x66\x00\x4F\x83\xC7\x83\xD2\x7B\xC5\x27\x46\x82\x74\x00\xE1\x83\xDB\x83\x11\x7A\x06\x3A\x46\x82\x82\x00\xE7\x83\x98\x83\xF6\x7A\xB1\x10\x93\x00\x46\x82",
			"\x90\x00\xED\x83\xBA\x83\xA1\x80\xB7\x30\x95\x00\x46\x82\x9E\x00\xF4\x83\xC1\x83\x23\x7A\xAD\x32\x97\x00\x46\x82\xAC\x00\xDA\x83\x7B\x0A\x1F\x0F\xC9\x00\xE4\x5D\x99\x00\x9C\x83\xAF\x24\x1F\x0F\xCA\x00\xE4\x5D\x9B\x00\xB6\x82\x71\x49\x04\x84\xBF\x80\x08\x84\x96\x0A\x1F\x0F\x99\x19\x78\x1E\x0E\x84\x05\x11\x75\x83\x02\x77\xB1\x10\x9F\x00\x46\x82\xBB\x00\x76\x31\xDE\x01\x19\x84\x0A\x77\xFE\x12\xA1\x00\x46\x82\xC8\x00\x1F\x84\xAA\x0A\xC6\x82\x3C\x15\xA3\x00\x46\x82\xD5\x00\xFB\x83\xE6\x2F\xE6\x80\x00\x37\xA5\x00\x46\x82\xE3\x00\x2E\x84\x21\x84\x58\x7A\xC7\x6A\x46\x82\xF1\x00\x35\x84\xC4\x81\xB1\x10\xA9\x00\xB0\x82\x3B\x84\x48\x7B\x79\x2E\xAB\x00\x46\x82\x0D\x00\x41\x32\x20\x84\xF1\x82\xCA\x38\xAD\x00\x46\x82\x1A\x00\x41\x32\xBB\x01\x36\x84\xC9\x70\xD0\x1A\xAF\x00\x46\x82\x28\x00\x4D\x84\x28\x84\x13\x81\xAD\x32\xB1\x00\x46\x82\x36\x00\x55\x84\x32\x76\xB6\x7C\xAD\x32\xB3\x00\x46\x82\x44\x00\x5C\x84\xD4\x74\x8B\x78\xE0\x46\x46\x82\x52\x00\x63\x84\xB0\x0A\xF4\x81\x84\x57\x46\x82\x60\x00\x69\x84\xB2\x0A\x18\x83\x03\x19",
			"\xB9\x00\x46\x82\x6E\x00\x41\x32\xBD\x01\x4F\x84\xA3\x63\xAC\x21\xBB\x00\x46\x82\x7D\x00\x6F\x84\xA8\x0A\x3E\x80\xA1\x1A\xBD\x00\x46\x82\x8B\x00\x46\x84\x56\x84\x2D\x83\xB1\x10\xBF\x00\x46\x82\x98\x00\x76\x84\x86\x84\x33\x83\xCC\x21\xC1\x00\x46\x82\xA7\x00\x7E\x84\x2F\x84\x4A\x81\xAD\x32\xC3\x00\x46\x82\xB5\x00\x93\x84\x78\x84\xA4\x65\x91\x25\x46\x82\xC3\x00\x8C\x84\x5D\x84\x56\x81\x3B\x68\x46\x82\xD2\x00\x9A\x84\x4B\x83\xB7\x30\xC9\x00\x46\x82\xE0\x00\xA6\x84\x63\x81\x05\x11\xCB\x00\x46\x82\xEE\x00\xA0\x84\x64\x84\xC8\x73\x4B\x68\x46\x82\xFD\x00\xB2\x84\x6A\x84\x70\x81\xB6\x11\xCF\x00\x46\x82\x0C\x00\x99\x32\x77\x84\xA8\x77\xEF\x16\xD1\x00\x46\x82\x1B\x00\xBF\x84\x8D\x84\x41\x75\xA7\x30\x46\x82\x2A\x00\x99\x32\x4E\x84\x8E\x80\x03\x19\xD5\x00\x46\x82\x38\x00\xCC\x84\xC7\x84\xC0\x7F\xAC\x21\xD7\x00\xC4\x83\xD3\x84\xA1\x84\x9B\x80\xAD\x32\xD9\x00\x46\x82\x54\x00\xD9\x84\xB3\x84\xE5\x7B\x44\x28\x46\x82\x62\x00\xE0\x84\xB9\x84\xEC\x7B\xAD\x32\xDD\x00\x46\x82\x70\x00\xC6\x84\xC1\x0A\x10\x84\x0D\x23\x63\x0C\x97\x60",
			"\x55\x13\xEE\x84\x08\x34\x17\x84\xB6\x11\x52\x83\x53\x0B\xE4\x5D\xE3\x00\xF6\x84\x0A\x12\x9F\x19\xC7\x2F\x29\x62\xF1\x84\xB1\x10\xD3\x00\x1F\x0F\xFE\x84\x7E\x1F\xFC\x84\x05\x62\xB9\x82\xAF\x12\x46\x82\x7F\x00\x99\x32\xDE\x01\x7B\x83\xC0\x82\x0A\x12\xEA\x00\x46\x82\x8C\x00\x0D\x85\x63\x0B\x29\x84\xAA\x15\xEC\x00\x46\x82\x99\x00\xE6\x84\xA4\x41\x1F\x0F\xD6\x00\xF6\x74\x07\x85\xAA\x15\x0F\x85\xCE\x82\xB7\x30\xB5\x41\x0B\x42\x1C\x85\x01\x01\x23\x85\x37\x84\x9D\x26\xF1\x00\x98\x84\x28\x85\x00\x00\x2A\x85\x5D\x7A\xA1\x1A\xF3\x00\x9E\x84\x2F\x85\x31\x85\x02\x81\xA1\x1A\xF5\x00\x46\x82\xD1\x00\x15\x85\x38\x76\xD1\x81\x0A\x12\xF7\x00\x46\x82\xDE\x00\x36\x85\xF8\x82\xAD\x32\xF9\x00\x46\x82\xEC\x00\x44\x85\x57\x84\xB7\x30\xFB\x00\x46\x82\xFA\x00\x4A\x85\x19\x81\x03\x19\xFD\x00\x46\x82\x08\x00\xE5\x32\x52\x05\x37\x85\x6D\x74\x3F\x1A\x46\x82\x16\x00\x56\x85\x49\x05\x58\x85\xE6\x5F\x01\x00\x67\x0C\x88\x13\x24\x00\x5D\x85\xBB\x01\x58\x85\x0F\x6A\x03\x00\x62\x85\xFF\x0D\x5D\x85\xBD\x01\x58\x85\x64\x53\x05\x00\x6A\x85\xA6\x20",
			"\x65\x85\x16\x85\x26\x83\x3D\x17\x07\x00\x71\x85\x75\x72\x5D\x85\x0E\x85\x3E\x81\xF2\x6B\x78\x85\xA3\x10\x6C\x85\x74\x85\x44\x81\x86\x43\x7E\x85\x02\x01\x6B\x00\x73\x85\x3E\x85\x38\x83\x79\x2E\x0D\x00\x84\x85\xE4\x32\x87\x85\x67\x0B\x50\x81\x80\x31\x8C\x85\x7E\x21\x80\x85\x88\x85\xC0\x64\x16\x20\x92\x85\x96\x00\x8E\x85\xDA\x74\x67\x80\xF5\x52\x92\x85\xA4\x00\x9A\x85\x1D\x85\xAD\x84\xF8\x19\x92\x85\xB2\x00\x94\x85\x8F\x85\x69\x81\xE0\x19\x17\x00\x92\x85\xC1\x00\xA6\x85\x9B\x85\x7A\x80\x00\x37\xC7\x41\x81\x81\xAD\x85\xA1\x85\x77\x81\xCA\x38\x1B\x00\x92\x85\xDF\x00\xB3\x85\x29\x85\x7E\x81\x79\x2E\x1D\x00\x92\x85\xEE\x00\xA0\x85\xBB\x85\x85\x81\xFE\x12\x1F\x00\x92\x85\xFC\x00\xC1\x85\x30\x85\x8B\x81\x30\x26\x92\x85\x0A\x00\xEA\x32\x57\x85\x65\x82\xEF\x16\x23\x00\x92\x85\x18\x00\xCE\x85\x5E\x85\x6C\x82\xCB\x31\x92\x85\x26\x00\xD5\x85\x66\x85\x9E\x81\x70\x72\x92\x85\x34\x00\xD5\x85\xBD\x01\x5A\x13\x41\x3C\xE4\x5D\x29\x00\x67\x0C\x3E\x4D\xEF\x84\xFB\x1E\x2A\x00\x67\x0C\x97\x60\x6F\x83\x1A\x84\xFE\x12\x2D\x00\x92\x85",
			"\x43\x00\xD5\x85\xDE\x01\xEE\x85\x22\x84\x7D\x1D\x92\x85\x50\x00\xF4\x85\xBE\x0B\x17\x85\x48\x15\x31\x00\x92\x85\x5D\x00\xDB\x85\xFC\x85\xEF\x0B\x58\x7C\xE7\x85\xC8\x1C\x30\x84\x61\x6C\x92\x85\x6B\x00\x02\x86\xB9\x0B\xBE\x81\xB8\x15\x36\x00\x92\x85\x79\x00\x0C\x86\x2C\x76\xD3\x6A\xAC\x21\x38\x00\x92\x85\x87\x00\x13\x86\x61\x12\xEA\x82\xCA\x38\x3A\x00\x92\x85\x95\x00\xFB\x85\x0D\x86\x3F\x85\x11\x21\x92\x85\xA2\x00\x1A\x86\xB1\x0B\x45\x85\xB7\x30\x3E\x00\x92\x85\xB0\x00\x27\x86\xD3\x0B\xFF\x82\xB7\x30\x40\x00\x92\x85\xBE\x00\x2E\x86\xB8\x30\x80\x7A\x89\x7C\x92\x85\xCC\x00\x35\x86\xF6\x85\x1E\x81\xE1\x20\x44\x00\x92\x85\xDA\x00\x3B\x86\x6B\x84\x98\x50\x92\x85\xE8\x00\x42\x86\xFA\x81\x79\x2E\x48\x00\x92\x85\xF6\x00\xE1\x85\x03\x86\x01\x82\xDE\x49\x92\x85\x05\x00\x17\x33\xBB\x01\x3C\x86\x73\x6E\xAB\x7C\x92\x85\x13\x00\x17\x33\xF5\x85\x7C\x85\xB7\x30\x4E\x00\x92\x85\x20\x00\x17\x33\xBD\x01\x55\x86\xE1\x7C\xE1\x20\x50\x00\x92\x85\x2F\x00\x53\x86\x4E\x86\x31\x5F\xA9\x18\xE4\x41\x05\x19\x69\x86\x22\x86\x88\x7F\x9D\x26",
			"\x54\x00\x92\x85\x4B\x00\x61\x86\x6A\x86\x27\x82\xF6\x24\x56\x00\x92\x85\x5A\x00\x6F\x86\x14\x86\x93\x7F\xC9\x5D\x92\x85\x68\x00\x7D\x86\x1B\x86\xA2\x85\x4D\x28\x92\x85\x76\x00\x76\x86\x70\x86\x3C\x82\xA7\x79\x92\x85\x85\x00\x89\x86\x7E\x86\xA5\x7F\xEC\x1B\x92\x85\x94\x00\x8F\x86\x84\x86\xB5\x85\x4B\x2A\x92\x85\xA3\x00\x95\x86\x28\x86\x51\x82\x67\x41\xA4\x85\x83\x86\x9C\x86\x58\x82\xA2\x2A\x92\x85\xC0\x00\xA0\x86\x2F\x86\x2A\x7D\xB1\x10\x66\x00\x92\x85\xCE\x00\xA6\x86\x36\x86\xFC\x7D\xB7\x30\x68\x00\x92\x85\xDC\x00\xAD\x86\x63\x86\x00\x00\xBC\x76\xB4\x0F\x92\x85\xEA\x00\xB4\x86\xDD\x85\xD1\x1D\x92\x85\xF8\x00\x9B\x86\xCC\x5F\xE1\x5E\xE4\x5D\x6E\x00\x06\x86\xDA\x4D\xE9\x85\x0C\x37\xEC\x85\x7B\x71\xDB\x82\xE6\x79\x92\x85\x07\x00\x0D\x24\x2E\x0F\xDB\x00\xC7\x86\xAC\x21\x74\x00\x67\x0C\x70\x49\xD1\x86\xE2\x51\xD1\x76\xC5\x86\x15\x4F\x1F\x0F\xDF\x00\xE4\x5D\x7B\x00\xDA\x86\x1A\x4F\x1F\x0F\xE1\x00\xE4\x5D\xF8\x41\xC1\x80\xCF\x0F\xDD\x00\xCB\x86\x53\x67\x92\x85\x08\x00\xCF\x86\x86\x0C\xD2\x86\xF6\x24\x7F\x00\xD5\x86",
			"\xB1\x10\xAD\x19\x06\x01\xDD\x86\x2F\x30\xE0\x86\xEF\x17\xF6\x86\x3D\x7E\x17\x1C\x92\x85\x09\x00\xED\x86\x26\x27\xEF\x86\x25\x35\xF2\x86\xFE\x12\xE3\x86\x70\x0C\x98\x6A\xF8\x86\xE0\x19\xE2\x00\x1F\x0F\xDC\x00\xE4\x5D\x8F\x00\x08\x87\x7D\x19\xE3\x00\x09\x85\xCF\x10\xCC\x85\x0D\x24\xDE\x01\x11\x87\x10\x85\x3C\x15\x92\x00\x92\x85\x17\x00\x15\x87\x92\x0C\xFD\x85\xB8\x15\x94\x00\x92\x85\x24\x00\x0D\x24\xBB\x01\x17\x87\x24\x85\xA3\x6D\x92\x85\x32\x00\x24\x87\x1E\x87\xD4\x82\x79\x51\x92\x85\x40\x00\x2B\x87\x09\x01\x26\x87\xE3\x82\x80\x51\x92\x85\x4E\x00\x31\x87\xEB\x11\x1C\x86\xB1\x10\x9C\x00\x92\x85\x5C\x00\x1D\x87\x32\x87\x48\x84\x2D\x41\x92\x85\x69\x00\x38\x87\x03\x01\x33\x87\x50\x84\x40\x40\x92\x85\x77\x00\x45\x87\x02\x01\x47\x87\x16\x80\x86\x1E\x8D\x86\x4C\x87\x3B\x52\x37\x86\xAD\x32\xA4\x00\x92\x85\x93\x00\x52\x87\x00\x00\x4E\x87\x59\x85\x6E\x44\x92\x85\xA1\x00\x59\x87\x5B\x87\xE6\x5F\xA8\x00\x92\x85\xAF\x00\x60\x87\x71\x84\x67\x2A\x92\x85\xBD\x00\x0D\x24\xBD\x01\x5B\x87\x64\x53\xAC\x00\x39\x86\x66\x87\x75\x85",
			"\xEF\x17\xAE\x00\x40\x86\x3F\x87\x39\x87\x0D\x82\x3D\x17\xB0\x00\x92\x85\xE7\x00\x6B\x87\x2C\x87\x82\x85\x3D\x17\xB2\x00\x4B\x86\x71\x87\x89\x85\xF6\x7D\x92\x85\x04\x00\xFE\x22\x25\x87\x90\x85\xA1\x1A\xB6\x00\x92\x85\x12\x00\xFE\x22\x6C\x87\xC2\x7D\x81\x1C\x92\x85\x21\x00\x88\x87\x7E\x87\x7F\x86\x8D\x2E\x67\x86\x95\x87\x40\x87\x85\x86\x3C\x15\xBC\x00\x92\x85\x3D\x00\x8F\x87\x96\x87\xD5\x7D\xAF\x33\x92\x85\x4C\x00\xA1\x87\x9B\x87\xAF\x85\xCA\x38\xC0\x00\x92\x85\x5B\x00\xA7\x87\x77\x87\x97\x86\x52\x4A\x92\x85\x6A\x00\xAE\x87\x46\x87\xBC\x85\xAD\x32\xC4\x00\x11\x86\x9A\x87\xAF\x87\xE1\x73\xAC\x21\xC6\x00\x18\x86\xBA\x87\xB5\x87\xA8\x86\xFE\x12\xC8\x00\x1F\x86\xC0\x87\x4D\x87\xD0\x85\xAC\x4A\x99\x86\xC6\x87\x53\x87\xCC\x7F\xB6\x11\xCC\x00\x92\x85\xB1\x00\xCB\x87\x5A\x87\xBC\x86\x55\x48\x92\x85\xBF\x00\xB4\x87\x02\x01\xB3\x19\xD4\x7E\x61\x38\xAB\x86\xFE\x22\x2E\x0F\xB9\x19\xFF\x84\xC8\x4A\x67\x0C\x6A\x49\xBF\x19\x4A\x3C\x4F\x7E\x0F\x87\x05\x11\x4B\x76\xC1\x87\x44\x1F\xE8\x87\xB6\x11\xCA\x19\xE1\x87\x03\x2F\xC9\x86",
			"\xFE\x12\x92\x12\x09\x01\xEF\x87\x52\x1F\xED\x87\x11\x85\x01\x87\x82\x71\xF2\x87\x64\x16\x98\x12\xF0\x87\xD3\x30\xF8\x87\x3C\x15\xCF\x19\xFF\x87\x9D\x38\x01\x88\xAA\x15\xED\x00\xFA\x87\x4A\x28\x06\x88\x48\x15\xB4\x12\x04\x88\xF6\x24\xE2\x00\x0B\x88\xB8\x15\xBD\x1E\x0E\x88\x6E\x6E\x11\x88\xCF\x0F\xF0\x00\x1F\x0F\xD5\x19\x2A\x2F\x92\x85\x42\x3E\x1F\x0F\xDC\x19\xD0\x1A\xE6\x00\x16\x88\x03\x0F\xF3\x00\x1F\x0F\xF6\x00\xE4\x5D\xE7\x00\x22\x88\xC7\x0D\x6C\x60\xB3\x2E\xE8\x00\x92\x85\xCF\x00\xFE\x22\x88\x13\x24\x88\x4D\x13\xB3\x2E\xEA\x00\x92\x85\xD1\x00\xDE\x87\x10\x0E\x2B\x88\x1A\x4B\x92\x85\xD2\x00\x30\x88\x39\x88\x33\x88\x91\x7E\x92\x85\xD4\x00\x38\x88\x15\x0E\x1F\x0F\xF1\x00\x3C\x64\xE3\x87\x66\x58\x1F\x0F\xF5\x00\x36\x62\x29\x88\x8B\x13\x95\x57\xE4\x5D\xF5\x00\x4E\x88\x14\x12\x25\x88\x10\x75\x53\x88\x03\x01\x1F\x88\xCE\x0D\x97\x5F\x57\x88\x02\x01\xF9\x00\x6C\x0F\xB3\x2E\xF8\x00\x1C\x88\xB6\x11\xFB\x00\x1F\x0F\xFC\x00\x1E\x75\x5C\x88\xEF\x59\xC7\x5D\xDA\x68\x68\x88\x89\x0E\x3A\x88\xFB\x1E\xFC\x00\x92\x85\xD5\x00",
			"\x3E\x88\xB3\x59\x1F\x0F\x1F\x00\xB3\x2E\xFE\x00\x92\x85\xD7\x00\x44\x88\x9F\x0E\x6E\x88\x5E\x4B\x28\x0B\x88\x13\xD8\x00\x73\x88\x7C\x88\x40\x88\xFB\x1E\x02\x00\x7F\x88\x01\x0C\x7B\x88\xC1\x0E\xE9\x86\x79\x2E\x04\x00\x87\x88\x24\x0C\x89\x88\xE9\x10\x1F\x0F\xFA\x00\x48\x75\x28\x0B\xFD\x3A\x7B\x17\xBA\x5C\xF1\x68\x28\x0B\xCC\x35\x97\x88\x5F\x5A\xEB\x7E\x9A\x88\xB1\x10\x01\x00\xFC\x10\x66\x88\x78\x31\x9F\x88\xFE\x12\x02\x00\xFC\x10\x64\x88\xD0\x1A\x0E\x00\xA5\x88\x64\x16\xA7\x88\x09\x0F\xB0\x2F\xAC\x88\x3D\x17\x03\x00\xFC\x10\x09\x00\xB3\x2E\x10\x00\x8E\x88\x64\x16\x05\x00\xFC\x10\x07\x00\xB3\x2E\x12\x00\xB1\x88\xEF\x17\xBA\x88\xB4\x0D\xE4\x5D\x13\x00\xB8\x88\xAB\x4F\x90\x88\x5D\x17\x56\x1A\xB3\x2E\x15\x00\xC5\x88\x5A\x0C\xC7\x88\xBB\x16\xBB\x88\xB3\x2E\x17\x00\xBF\x88\xE0\x19\xB6\x13\xB6\x0D\xE4\x5D\x18\x00\xCC\x88\x0F\x2F\xCE\x88\xD5\x88\x3F\x0F\xB3\x2E\x1A\x00\xD9\x88\xA3\x50\xCE\x88\xBC\x88\x7F\x0F\xB3\x2E\x1C\x00\x28\x0B\x6A\x49\xBC\x13\x44\x17\xB3\x2E\x20\x00\xD3\x88\x7D\x19\xE9\x88\xB8\x0D\x44\x6C\xE0\x88",
			"\xE0\x00\xCE\x88\xEF\x88\x42\x0F\xB3\x2E\x23\x00\xE0\x88\xE1\x00\xCE\x88\xB5\x88\x1A\x16\xB3\x2E\x25\x00\xED\x88\x05\x11\xF0\x19\x3B\x01\xB3\x2E\x26\x00\xE0\x88\xA1\x15\xFC\x10\x12\x00\xB3\x2E\x28\x00\x00\x89\x2B\x18\xCD\x1E\xB3\x2E\x48\x42\xE6\x86\x03\x0F\x0E\x00\xFC\x10\xCC\x1E\x95\x82\x95\x88\x8E\x5F\xFC\x10\x0F\x00\xB3\x2E\x2F\x00\x0C\x89\x0A\x12\x1A\x89\xEF\x85\x64\x16\x30\x00\xE0\x88\xE2\x00\xFE\x22\xDE\x01\x1F\x89\xF7\x85\x3D\x17\x32\x00\xE0\x88\xEF\x00\x25\x89\x85\x01\xFC\x10\xE6\x5C\xE5\x64\xE0\x88\xFC\x00\xD2\x87\x27\x89\x5B\x7D\xFE\x12\x36\x00\xE0\x88\x0A\x00\xF9\x23\x10\x02\xFC\x10\x24\x5B\xCC\x21\x38\x00\xE0\x88\x18\x00\x3B\x89\x2E\x89\x28\x7F\x08\x22\xE0\x88\x26\x00\x43\x89\x27\x01\xFC\x10\xA5\x75\xDC\x62\xE0\x88\x34\x00\xF9\x23\x26\x89\xFC\x10\xAD\x75\xAD\x32\x3E\x00\xE0\x88\x41\x00\x49\x89\x41\x01\xFC\x10\x72\x7A\x3C\x15\x40\x00\xE0\x88\x4F\x00\x58\x89\x5B\x01\xFC\x10\x8D\x72\xE0\x19\x42\x00\xE0\x88\x5D\x00\x60\x89\x07\x01\xFC\x10\x94\x72\x05\x11\x44\x00\xE0\x88\x6B\x00\x68\x89\xA1\x01\xFC\x10",
			"\x24\x80\x3C\x15\x46\x00\xE0\x88\x79\x00\x70\x89\xBC\x01\xFC\x10\xE6\x5F\x48\x00\xE0\x88\x87\x00\x78\x89\x35\x89\xC5\x7C\xA5\x7C\xE0\x88\x95\x00\xF9\x23\xBD\x01\x80\x89\x79\x84\x12\x3F\xE0\x88\xA4\x00\x7F\x89\xFC\x10\xD1\x6B\x4E\x00\xE0\x88\xB2\x00\x50\x89\x44\x89\x87\x84\xC4\x23\xE0\x88\xBF\x00\x85\x89\x93\x89\x8E\x84\xD1\x69\xE0\x88\xCE\x00\x8C\x89\x95\x84\xB7\x30\x69\x42\xE3\x16\xDC\x00\x9E\x89\x71\x86\xEF\x16\x56\x00\xE0\x88\xEA\x00\x98\x89\x4A\x89\x45\x83\x4B\x26\xE0\x88\xF9\x00\xA4\x89\x97\x87\xA1\x79\xE0\x88\x07\x00\xB4\x34\x3C\x89\x9C\x87\xF6\x7F\xE0\x88\x15\x00\xB4\x34\x86\x89\xFC\x10\xE5\x72\xB7\x30\x5E\x00\xE0\x88\x24\x00\xBB\x89\x99\x89\x91\x86\x03\x19\x60\x00\xE0\x88\x33\x00\xC3\x89\xAB\x89\xB0\x87\x64\x16\x62\x00\xE0\x88\x42\x00\xCA\x89\x59\x89\x9D\x86\xAA\x15\x64\x00\xE0\x88\x51\x00\xB5\x89\xC4\x89\x0B\x7A\xC2\x47\xE0\x88\x5F\x00\xD8\x89\xCB\x89\xE9\x83\xB0\x86\xE0\x88\x6D\x00\xDE\x89\xD2\x89\xEF\x83\x18\x2C\xE0\x88\x7B\x00\xE4\x89\x61\x89\xCD\x87\x0A\x12\x6C\x00\xE0\x88\x89\x00\xEA\x89\x69\x89",
			"\xFD\x83\x43\x4A\xE0\x88\x97\x00\xD1\x89\x5D\x01\x14\x89\xB3\x2E\x70\x00\x17\x89\x0E\x6C\xFC\x10\xF5\x19\xF8\x2B\x1D\x89\x3C\x15\x09\x89\x3D\x01\xB3\x2E\x76\x00\x01\x8A\xAA\x15\x13\x00\xFC\x10\x23\x2F\x2A\x37\x06\x89\xF8\x19\xFC\x10\xD3\x1E\xCB\x76\x07\x8A\x48\x15\x16\x00\xFC\x10\x18\x00\xB3\x2E\x7A\x00\x12\x8A\xB8\x15\x14\x8A\x03\x89\xD0\x1A\x7B\x00\xE0\x88\xA6\x00\xB4\x34\x88\x13\x1B\x8A\xD6\x1E\xB3\x2E\x7D\x00\xE0\x88\xA8\x00\xB4\x34\xF6\x10\x23\x8A\x3A\x2B\xB3\x2E\x7F\x00\xE0\x88\xAB\x00\x29\x8A\x17\x01\xFC\x10\xB2\x2E\x4D\x37\xE0\x88\xAE\x00\x31\x8A\xD4\x02\xFC\x10\x6A\x77\x60\x3D\xE0\x88\xB1\x00\x38\x8A\xBD\x05\xFC\x10\x17\x76\xE1\x20\x85\x00\xE0\x88\xB4\x00\x3F\x8A\x4E\x0D\xFC\x10\xCB\x2E\x62\x37\xE0\x88\xB7\x00\x47\x8A\x4C\x04\xFC\x10\xD2\x2E\xB0\x27\xE0\x88\xBA\x00\x4E\x8A\xF9\x03\xFC\x10\xDA\x2E\xD0\x1A\x8B\x00\xE0\x88\xBD\x00\x55\x8A\x8C\x04\xFC\x10\x6D\x2F\xFB\x1E\x8D\x00\xE0\x88\xC0\x00\x5D\x8A\x2B\x8A\x9B\x35\xB3\x2E\x8F\x00\xE0\x88\xC3\x00\x65\x8A\xFC\x10\x78\x2F\xCC\x27\xE0\x88\xC6\x00\x6C\x8A",
			"\xF5\x2E\xB3\x2E\x93\x00\xE0\x88\xC9\x00\x72\x8A\xFC\x2E\xD0\x1A\x95\x00\xE0\x88\xCC\x00\x78\x8A\xCF\x40\xEE\x24\xE0\x88\xCF\x00\x7E\x8A\x08\x2F\xB3\x2E\x99\x00\xE0\x88\xD2\x00\x83\x8A\x0F\x2F\xB3\x2E\x9B\x00\xE0\x88\xD5\x00\x89\x8A\x16\x2F\xB3\x2E\x9D\x00\xE0\x88\xD8\x00\x8F\x8A\x1D\x2F\xBA\x37\xE0\x88\xDB\x00\x8F\x8A\x0B\x8A\x07\x28\xE0\x88\xDE\x00\x8F\x8A\x29\x2F\x48\x3A\xF9\x88\x5D\x8A\x17\x00\x15\x8A\xB3\x2E\xA5\x00\x19\x8A\x31\x20\xFC\x10\x0C\x00\x93\x54\xE0\x88\xE4\x00\x21\x8A\xCB\x13\xD6\x20\xB3\x2E\xA8\x00\xE0\x88\xE6\x00\xA3\x8A\xFC\x10\x69\x00\xB1\x63\xE0\x88\xE9\x00\xB6\x8A\x4A\x2F\xD0\x1A\xAC\x00\xE0\x88\xEC\x00\xBC\x8A\x94\x89\xFF\x59\x2B\x89\xC2\x8A\x54\x2F\xB3\x2E\xB0\x00\xE0\x88\xF2\x00\xC6\x8A\x5B\x2F\xFF\x37\xE0\x88\xF5\x00\xCC\x8A\x61\x2F\x07\x3E\xE0\x88\xF8\x00\xD1\x8A\x67\x2F\x2F\x49\xE0\x88\xFB\x00\xD6\x8A\x60\x8A\x35\x49\xE0\x88\xFE\x00\xD6\x8A\x73\x2F\x12\x3E\xE0\x88\x01\x00\x80\x35\xF6\x10\xA4\x8A\xDF\x20\xB3\x2E\xBC\x00\xE0\x88\x04\x00\xE5\x8A\xB0\x8A\xA3\x4F\xB3\x2E\xBE\x00\xB3\x89",
			"\xED\x8A\xB4\x02\xFC\x10\x82\x2F\x9A\x1C\x39\x89\xF3\x8A\x0F\x0A\xFC\x10\x9F\x83\x7A\x08\xE0\x88\x0D\x00\xF9\x8A\xC6\x13\x8B\x1E\xBB\x2E\xE0\x88\x10\x00\x00\x8B\x1F\x04\xFC\x10\x94\x2F\xFB\x1E\xC6\x00\xE0\x88\x13\x00\x06\x8B\x80\x04\xBD\x89\xB3\x2E\xC8\x00\xE0\x88\x16\x00\x0E\x8B\x70\x04\xFC\x10\x96\x8A\xFB\x1E\xCA\x00\xE0\x88\x19\x00\x15\x8B\xE7\x8A\x02\x02\xDB\x2E\xE0\x88\x1C\x00\x1D\x8B\xFC\x10\xA0\x8A\x3F\x47\xE0\x88\x1F\x00\x15\x8B\x16\x8A\x31\x01\xB3\x2E\xD0\x00\xE7\x88\xB1\x10\x10\x8A\x40\x8A\x67\x48\xA8\x8A\x03\x0F\x03\x1A\x1C\x8A\xFB\x1E\xD5\x00\xE0\x88\x22\x00\x80\x35\x2E\x0F\x35\x8B\xFA\x2C\xB3\x2E\xD7\x00\x0D\x8A\x0A\x12\xD1\x13\x98\x2E\x4B\x1F\xE0\x88\x23\x00\x3B\x8B\xD0\x13\xFC\x10\x76\x88\xD0\x1A\xDB\x00\x33\x8B\x82\x15\x8F\x1A\x82\x71\xC1\x89\x48\x8B\xB8\x13\xFC\x10\xE3\x53\xB7\x30\xDE\x00\xE0\x88\x25\x00\x53\x8B\x4E\x12\xFC\x10\xED\x77\x2C\x78\x47\x89\x5B\x8B\x03\x01\x1D\x00\xFC\x10\x69\x22\xC3\x35\xE0\x88\x27\x00\x61\x8B\x99\x16\x0A\x8A\xE4\x25\xE0\x88\x28\x00\x69\x8B\xF6\x46\xFC\x10\x03\x78",
			"\x0E\x34\xE0\x88\x29\x00\x6F\x8B\x00\x00\x63\x8B\xD8\x4E\x83\x2C\xE0\x88\x2A\x00\x76\x8B\x78\x8B\xCA\x1D\x03\x19\xEA\x00\xE0\x88\x2B\x00\x7D\x8B\x14\x89\xCE\x19\xE0\x88\x2C\x00\x84\x8B\x25\x1B\xFB\x1E\xEE\x00\xE0\x88\x2D\x00\x89\x8B\xFD\x15\xFB\x1E\xF0\x00\xE0\x88\x2E\x00\x8F\x8B\x93\x1C\xE1\x20\xF2\x00\xE0\x88\x2F\x00\x95\x8B\x99\x1C\x09\x75\xE0\x88\x30\x00\x9B\x8B\x9F\x1C\x9A\x55\xE0\x88\x31\x00\xA0\x8B\xA5\x1C\x17\x75\xE0\x88\x32\x00\xA5\x8B\x32\x54\xB7\x30\xFA\x00\xC8\x89\x76\x8B\xD7\x13\x48\x12\xB3\x2E\xFC\x00\xFC\x89\x64\x16\x4B\x8B\x5C\x8B\x88\x23\x00\x0E\xCC\x35\x0A\x1A\xDB\x87\x06\x26\x00\x0E\x88\x13\x34\x00\x76\x8B\xBB\x8B\x06\x01\x3C\x7E\xE1\x20\x04\x00\xBE\x8B\x3E\x0C\xC1\x8B\xFC\x10\x2F\x7E\xFB\x1E\x06\x00\xC7\x8B\x9B\x0F\x76\x8B\xDD\x13\x58\x20\xB3\x2E\x08\x00\xB9\x8B\x4E\x1C\xFC\x10\x21\x00\xB3\x2E\x09\x00\xD5\x8B\x2D\x50\x3A\x8A\xB3\x2E\x0A\x00\xCE\x8B\x64\x16\x24\x00\xFB\x8A\xB3\x2E\x0C\x00\xE0\x8B\x3D\x17\xE2\x8B\xA8\x85\x7D\x19\x0E\x00\xE6\x8B\xE2\x1C\xFC\x10\x18\x1A\x42\x39\xDB\x8B\xE8\x1C",
			"\xAA\x8A\xB3\x2E\x11\x00\xEC\x8B\x3E\x0E\x80\x35\x88\x13\x11\x1A\x84\x88\x07\x6F\xF6\x8B\x4D\x20\x76\x8B\xDB\x1E\x36\x8B\x7C\x75\xFD\x8B\x3A\x00\xF8\x8B\x67\x4D\x4A\x8B\xD1\x88\xFD\x8B\x3C\x00\x76\x8B\x28\x00\x50\x8B\x03\x19\x19\x00\xFD\x8B\x3D\x00\x0B\x8C\x55\x8B\x0A\x1D\xFD\x8B\x3E\x00\x12\x8C\x61\x22\x26\x6F\xFD\x8B\x3F\x00\x17\x8C\xBD\x18\x2D\x6F\xFD\x8B\x40\x00\x1C\x8C\xCB\x4E\xCC\x21\x21\x00\xFD\x8B\x41\x00\x21\x8C\xCB\x18\x60\x20\xFD\x8B\x42\x00\x27\x8C\x45\x1B\xFB\x1E\x25\x00\xFD\x8B\x43\x00\x2C\x8C\xD8\x18\xA6\x58\xFD\x8B\x44\x00\x32\x8C\x18\x78\x64\x16\x29\x00\xFD\x8B\x45\x00\x32\x8C\x20\x78\xB1\x10\x2B\x00\xFD\x8B\x46\x00\x32\x8C\x25\x78\x48\x15\x2D\x00\xFD\x8B\x47\x00\x32\x8C\x1B\x54\xBD\x58\xFD\x8B\x48\x00\x32\x8C\x21\x54\x0A\x12\xD4\x42\xE3\x16\x49\x00\x32\x8C\x26\x54\xB7\x30\x33\x00\xFD\x8B\x4A\x00\x32\x8C\x2C\x54\xCA\x38\x35\x00\xFD\x8B\x4B\x00\x32\x8C\xAB\x8B\x00\x37\x37\x00\xFD\x8B\x4C\x00\x76\x8B\xFA\x13\xB9\x14\xB3\x2E\x39\x00\x00\x0E\x3E\x41\x3C\x15\x2A\x00\xFC\x10\x25\x00\xB3\x2E\x43\x00",
			"\x6B\x8C\x3F\x8C\xFC\x10\x6E\x8C\x8A\x24\xF1\x8B\x3D\x17\x2B\x00\xFC\x10\x6C\x74\xEF\x16\xE2\x42\xE3\x16\x4D\x00\x05\x8C\x30\x06\xFC\x10\xC4\x8B\xBE\x6C\xFD\x8B\x4F\x00\x81\x8C\x35\x06\xCA\x8B\xE4\x5D\x52\x00\xFD\x8B\x51\x00\x88\x8C\x98\x06\xFC\x10\x0C\x8C\xD0\x1A\x54\x00\x78\x8C\xEF\x17\x2D\x00\xFC\x10\x00\x8C\xF5\x26\x95\x8C\xE0\x19\x97\x8C\x80\x06\xB3\x2E\x56\x00\x9B\x8C\x7D\x19\x2E\x00\xFC\x10\x34\x00\xB3\x2E\x57\x00\xA1\x8C\x05\x11\xA3\x8C\x01\x8C\xE4\x69\xFD\x8B\x53\x00\x8F\x8C\xA6\x0B\x07\x8C\x97\x46\xFD\x8B\x55\x00\x76\x8B\x2F\x00\xF3\x8B\xD0\x1A\xE9\x42\x03\x56\xAF\x8C\xBA\x69\xB1\x8C\xA0\x60\xFD\x8B\x58\x00\x76\x8B\x30\x00\x0D\x8C\xA1\x1A\x60\x00\xFD\x8B\x59\x00\xC1\x8C\x13\x8C\x00\x6A\xFD\x8B\x5A\x00\xC8\x8C\x18\x8C\xAC\x21\x64\x00\xFD\x8B\x5B\x00\xCD\x8C\x1D\x8C\x9D\x26\x66\x00\xFD\x8B\x5C\x00\xD3\x8C\x22\x8C\x36\x4A\xFD\x8B\x5D\x00\xD9\x8C\x28\x8C\xCC\x21\x6A\x00\xFD\x8B\x5E\x00\xDE\x8C\x2D\x8C\x78\x21\xFD\x8B\x5F\x00\xE4\x8C\x33\x8C\x31\x80\xFD\x8B\x60\x00\xE9\x8C\x38\x8C\x3D\x17\x70\x00\xFD\x8B",
			"\x61\x00\xE9\x8C\x3E\x8C\xFE\x12\x72\x00\xFD\x8B\x62\x00\xE9\x8C\x44\x8C\x22\x30\xFD\x8B\x63\x00\xE9\x8C\x4A\x8C\x3C\x15\x76\x00\xFD\x8B\x64\x00\xE9\x8C\x4F\x8C\x3C\x15\x78\x00\xFD\x8B\x65\x00\xE9\x8C\x55\x8C\x00\x37\x7A\x00\xFD\x8B\x66\x00\xE9\x8C\x5B\x8C\xB1\x10\x7C\x00\xFD\x8B\x67\x00\xE9\x8C\x61\x8C\x60\x6A\xFD\x8B\x68\x00\x76\x8B\x31\x00\x6F\x8C\xB3\x2E\x80\x00\x00\x0E\xEF\x8C\xA5\x06\x1E\x8D\x59\x8A\x21\x8D\xA1\x6A\xFC\x10\x1F\x1A\x5B\x1E\xA8\x8C\x72\x6F\x7B\x8C\xE4\x5D\x97\x00\xFD\x8B\x69\x00\xBB\x8C\x00\x00\x08\x14\x00\x11\x06\x84\xFD\x8B\x6B\x00\x32\x8D\x34\x8D\x61\x2E\x0C\x84\xFD\x8B\x6D\x00\x32\x8D\xA5\x8C\xEE\x0F\x91\x8A\x2B\x8D\x0A\x12\xE3\x1E\x8F\x06\xB3\x2E\x9E\x00\x43\x8D\x3C\x15\x45\x8D\x6B\x06\xB3\x2E\x9F\x00\x49\x8D\xAA\x15\x36\x00\xFC\x10\xAA\x8C\x40\x40\x4F\x8D\xE2\x1F\xFC\x10\xFA\x8B\x07\x28\xFD\x8B\x05\x11\x37\x00\xFC\x10\x51\x8D\xC9\x67\x5A\x8D\xB6\x11\x26\x1A\x09\x01\x58\x8D\x1D\x42\x60\x8D\x0A\x12\x62\x8D\xB9\x0E\xB3\x2E\xA7\x00\x66\x8D\x3C\x15\xCF\x58\x64\x8D\xAC\x21\xA9\x00\x6C\x8D",
			"\x88\x4D\x5D\x8D\xB3\x2E\xAB\x00\x72\x8D\x48\x15\x99\x2F\x68\x8D\xD9\x6A\x55\x8D\xB8\x15\x89\x2F\x5C\x8D\xB4\x1E\x7C\x8D\x2C\x1A\x41\x8A\x6C\x3A\x77\x8D\xB8\x15\x42\x8A\x5D\x24\xB3\x2E\xB1\x00\x81\x8D\x03\x0F\x3F\x00\xFC\x10\x34\x1A\xFF\x37\x8B\x8D\x3E\x26\xFC\x10\x40\x00\xB3\x2E\xB3\x00\x91\x8D\xB2\x1E\xC3\x8C\xCC\x21\x11\x43\xE3\x16\x6F\x00\x76\x8B\x94\x8D\xDC\x35\x0F\x48\xFD\x8B\x70\x00\x9E\x8D\x5D\x8B\x60\x42\xFD\x8B\x71\x00\xA4\x8D\xEE\x53\xCC\x21\xBA\x00\xFD\x8B\x72\x00\xA9\x8D\xF3\x53\xAD\x32\xBC\x00\xFD\x8B\x73\x00\xAF\x8D\xF9\x53\xA7\x40\xFD\x8B\x74\x00\xB5\x8D\xFF\x53\xD0\x7A\xFD\x8B\x75\x00\xBA\x8D\x04\x54\xAD\x32\xC2\x00\xFD\x8B\x76\x00\xBF\x8D\x0A\x54\xB7\x87\xFD\x8B\x77\x00\xC5\x8D\xF5\x8C\x64\x16\xC6\x00\xFD\x8B\x78\x00\xC5\x8D\xFB\x8C\x91\x83\xFD\x8B\x79\x00\xC5\x8D\x00\x8D\x82\x44\xFD\x8B\x7A\x00\xC5\x8D\x06\x8D\xAA\x15\xCC\x00\xFD\x8B\x7B\x00\xC5\x8D\x0C\x8D\xBA\x4A\xFD\x8B\x7C\x00\xC5\x8D\x12\x8D\xFE\x12\xD0\x00\xFD\x8B\x7D\x00\xC5\x8D\x18\x8D\xB1\x10\xD2\x00\xFD\x8B\x7E\x00\x76\x8B\x11\x14",
			"\x39\x21\xF7\x2E\x97\x8D\x06\x01\x8F\x8D\x6D\x75\xEA\x22\xFD\x8B\x7F\x00\x80\x35\xDE\x01\xF7\x8D\x74\x75\x03\x19\xD7\x00\xFD\x8B\x8C\x00\xFC\x8D\x0C\x01\xFE\x8D\x7A\x58\xF6\x24\xD9\x00\xFD\x8B\x99\x00\x80\x35\xBB\x01\x06\x8E\x81\x58\x79\x2E\xDB\x00\xFD\x8B\xA7\x00\x0C\x8E\x05\x8E\x3D\x89\x06\x23\xFD\x8B\xB5\x00\x14\x8E\xF3\x8D\x45\x89\x8A\x0C\xFD\x8B\xC3\x00\x1A\x8E\xF6\x8D\x4B\x89\x18\x41\xFD\x8B\xD1\x00\x04\x8E\x1B\x8E\xA4\x7C\x1E\x23\xFD\x8B\xDE\x00\x20\x8E\x03\x01\x0E\x8E\x69\x6D\xAC\x21\xE5\x00\xFD\x8B\xEC\x00\x2C\x8E\x02\x01\x2E\x8E\x63\x89\x7D\x19\xE7\x00\xFD\x8B\xFA\x00\x34\x8E\xDD\x6E\x6A\x89\xA9\x18\xE9\x00\xFD\x8B\x08\x00\xC7\x35\xB0\x04\x2E\x8E\x73\x89\x97\x6B\xFD\x8B\x16\x00\x43\x8E\x31\x05\x2E\x8E\xE6\x5F\x2B\x43\xE3\x16\x24\x00\x4A\x8E\x52\x05\x2E\x8E\x0F\x6A\xEF\x00\xFD\x8B\x32\x00\x51\x8E\x53\x05\x2E\x8E\x64\x53\xF1\x00\x25\x8C\x58\x8E\x0D\x8E\x8D\x89\x59\x23\x86\x8C\x58\x8E\xFD\x8D\xDD\x8B\xD0\x1A\xF5\x00\xD7\x8C\x58\x8E\xBD\x01\x2E\x8E\x72\x77\xCA\x38\xF7\x00\x37\x8D\x5E\x8E\x15\x8E\x9F\x89",
			"\x00\x37\xF9\x00\xD3\x8D\x70\x8E\x27\x8E\x3E\x83\x79\x2E\x31\x43\xFD\x42\x69\x8E\x71\x8E\xA2\x84\xEF\x17\xFD\x00\xFD\x8B\x96\x00\x76\x8E\x21\x8E\x9C\x85\x9D\x5F\xFD\x8B\xA4\x00\x83\x8E\x2D\x8E\xE3\x8B\x88\x23\xE5\x0D\x88\x13\xB2\x00\x7C\x8E\x77\x8E\xA3\x87\x52\x31\x8D\x8E\x00\x15\x90\x8E\x84\x8E\xA9\x87\x56\x16\x94\x8E\x0B\x26\x96\x8E\x8A\x8E\x4A\x82\xB8\x15\x07\x00\x9A\x8E\xF5\x86\x9C\x8E\x35\x8E\xFC\x10\xE4\x7A\xB7\x30\x37\x43\x88\x51\x89\x8E\xA4\x8E\xC3\x85\x86\x43\xA1\x8E\xD9\x59\xAA\x8E\x3D\x8E\xC2\x87\x64\x16\x0D\x00\xAE\x8E\xB2\x01\xDB\x29\x5F\x8E\xAF\x86\xE8\x52\xB5\x8E\x78\x62\xB7\x8E\x7D\x8E\xE2\x84\xB7\x2F\xBB\x8E\x42\x62\xBD\x8E\x91\x8E\x66\x75\x1F\x20\xC1\x8E\x34\x00\xDB\x29\xBD\x01\x43\x00\xFC\x10\x3D\x00\xCA\x88\xE5\x0D\xFD\x3A\xF7\x1E\xDF\x6E\xDE\x88\xE5\x0D\xCC\x35\x45\x00\xF5\x8A\xB3\x2E\x1B\x00\xC1\x8E\x05\x11\xF6\x8A\x71\x2B\xB3\x2E\x1D\x00\xD4\x8E\x46\x22\x99\x8D\x79\x2E\x1E\x00\xC1\x8E\x43\x00\xDB\x29\x2E\x0F\x3B\x1A\xA0\x8D\xAC\x21\x20\x00\xC1\x8E\x44\x00\xE7\x8E\x8B\x10\xFC\x10\x4B\x00",
			"\xB3\x2E\x22\x00\xE0\x8E\xFE\x12\xE9\x8E\xE4\x35\x53\x2D\xC1\x8E\x45\x00\xEF\x8E\x09\x01\xF7\x8E\xF4\x77\x2E\x8C\xC1\x8E\x46\x00\xFC\x8E\x99\x4B\x6B\x8B\xD0\x1A\x27\x00\xC1\x8E\x47\x00\x03\x8F\xE5\x6E\x71\x8B\x57\x26\xC1\x8E\x48\x00\x0A\x8F\xBD\x5D\xFC\x10\x81\x22\xB2\x58\xC1\x8E\x49\x00\x10\x8F\xBB\x36\xAA\x8A\xD5\x2F\xC1\x8E\x4A\x00\x17\x8F\x00\x00\xFE\x8E\xCD\x04\xE9\x31\xC1\x8E\x4B\x00\x1D\x8F\x1F\x8F\x1F\x78\xA9\x18\x31\x00\xC1\x8E\x4C\x00\x24\x8F\xEF\x1A\x4C\x53\xC1\x8E\x4D\x00\x2B\x8F\x2B\x78\x14\x44\xC1\x8E\x4E\x00\x30\x8F\x31\x78\x06\x18\xC1\x8E\x4F\x00\x35\x8F\x36\x78\x7E\x36\xC1\x8E\x50\x00\x3A\x8F\x3B\x78\xF6\x24\x3B\x00\xC1\x8E\x51\x00\x3F\x8F\x41\x78\x92\x6F\xC1\x8E\x52\x00\x1D\x8F\x49\x00\xE2\x8E\xAD\x32\x3F\x00\xC1\x8E\x53\x00\x4A\x8F\xC9\x8C\x65\x24\xC1\x8E\x54\x00\x51\x8F\xCE\x8C\xB2\x26\xC1\x8E\x55\x00\x56\x8F\xD4\x8C\xAC\x6F\xC1\x8E\x56\x00\x5B\x8F\xDA\x8C\x88\x53\xC1\x8E\x57\x00\x60\x8F\xDF\x8C\x79\x2E\x49\x00\xC1\x8E\x58\x00\x65\x8F\xE5\x8C\xAC\x21\x4B\x00\xC1\x8E\x59\x00\x6B\x8F\xEA\x8C",
			"\xCC\x21\x4D\x00\xC1\x8E\x5A\x00\x71\x8F\x22\x8D\xE0\x19\x4F\x00\xC1\x8E\x5B\x00\x71\x8F\xCB\x8D\x20\x59\xC1\x8E\x5C\x00\x71\x8F\xD1\x8D\x03\x0F\x53\x00\xC1\x8E\x5D\x00\x71\x8F\xD6\x8D\x48\x15\x55\x00\xC1\x8E\x5E\x00\x71\x8F\xDB\x8D\x48\x15\x57\x00\xC1\x8E\x5F\x00\x71\x8F\xE1\x8D\xB1\x10\x59\x00\xC1\x8E\x60\x00\x71\x8F\xE6\x8D\x64\x16\x5B\x00\xC1\x8E\x61\x00\x71\x8F\xEC\x8D\xCE\x76\xC1\x8E\x62\x00\x1D\x8F\x4A\x00\xFC\x10\x46\x00\xB3\x2E\x5F\x00\xE5\x0D\x6A\x49\xF2\x8E\x67\x22\xB3\x2E\x63\x00\xF5\x8E\x74\x1D\xFC\x10\x4B\x8F\xE9\x29\xB1\x8F\x73\x79\xF1\x8E\x5E\x83\xB6\x8F\xEF\x17\x4D\x00\xFC\x10\x25\x8F\xD5\x8C\xBA\x8F\xE0\x19\x41\x1A\xE8\x8A\x15\x70\xDA\x8E\x98\x5B\x7B\x8C\xB3\x2E\x69\x00\xC0\x8F\xE1\x23\x4C\x8F\xB7\x30\x6A\x00\xC1\x8E\x63\x00\x1D\x8F\xFE\x1E\xEA\x8E\x11\x7D\xC1\x8E\x64\x00\xD1\x8F\xA5\x8D\x80\x21\xC1\x8E\x65\x00\xD7\x8F\xAA\x8D\xFA\x53\xC1\x8E\x66\x00\xDC\x8F\xB0\x8D\x56\x44\xC1\x8E\x67\x00\xE1\x8F\xB6\x8D\x30\x6D\xC1\x8E\x68\x00\xE6\x8F\xBB\x8D\x9D\x26\x76\x00\xC1\x8E\x69\x00\xEB\x8F\xC0\x8D",
			"\xB7\x30\x78\x00\xC1\x8E\x6A\x00\xF1\x8F\xC6\x8D\xB7\x30\x7A\x00\xC1\x8E\x6B\x00\xF7\x8F\x7E\x8F\xEF\x17\x7C\x00\xC1\x8E\x6C\x00\xF7\x8F\x83\x8F\x32\x1F\xC1\x8E\x6D\x00\xF7\x8F\x89\x8F\x73\x35\xC1\x8E\x6E\x00\xF7\x8F\x8F\x8F\xB8\x15\x82\x00\xC1\x8E\x6F\x00\xF7\x8F\x95\x8F\x58\x36\xC1\x8E\x70\x00\xF7\x8F\x9B\x8F\xF0\x4B\xC1\x8E\x71\x00\xF7\x8F\xA1\x8F\xBD\x37\xC1\x8E\x72\x00\x1D\x8F\x52\x00\x2F\x89\xB3\x2E\x8A\x00\xCA\x8F\x05\x11\x53\x00\xFC\x10\x56\x00\xB3\x2E\x8B\x00\x27\x90\xB6\x11\x29\x90\x3E\x73\xB3\x2E\x8C\x00\x2E\x90\x0A\x12\x30\x90\x54\x26\xB3\x2E\x8D\x00\x34\x90\x47\x1A\xFC\x10\x55\x00\xB3\x2E\x8E\x00\x3A\x90\xEA\x24\x2A\x90\x68\x8A\x40\x90\x8A\x8F\xFC\x10\x58\x00\xB3\x2E\x90\x00\x44\x90\xE1\x25\xFC\x10\x57\x00\xB3\x2E\x91\x00\x4A\x90\xCF\x0F\x4D\x90\x4B\x26\xB3\x2E\x92\x00\x50\x90\x03\x0F\x47\x90\x5A\x72\x74\x8A\xE5\x0D\x2D\x79\x4A\x27\xFC\x10\x23\x90\xB6\x59\x56\x90\x2C\x74\xFC\x10\xD2\x8F\xF0\x27\x61\x90\xAB\x75\xFC\x10\x8F\x2F\xA5\x65\xC5\x8F\xE6\x1B\x2D\x8D\x78\x1E\xC1\x8E\x73\x00\x1D\x8F\x06\x1F",
			"\x06\x01\x5C\x00\xBC\x6D\xE5\x0D\x97\x60\x5F\x00\xCC\x8F\x00\x37\xA3\x00\xC1\x8E\x74\x00\x1D\x8F\x78\x90\xD3\x8F\x9D\x26\xA5\x00\xC1\x8E\x75\x00\x7E\x90\xD8\x8F\xFB\x1E\xA7\x00\xC1\x8E\x76\x00\x85\x90\xDD\x8F\x2B\x42\xC1\x8E\x77\x00\x8B\x90\xE2\x8F\xE4\x67\xC1\x8E\x78\x00\x90\x90\xE7\x8F\x00\x37\xAD\x00\xC1\x8E\x79\x00\x95\x90\xEC\x8F\xEF\x16\xA2\x43\xE3\x16\x7A\x00\x9B\x90\xF2\x8F\xB6\x45\xC1\x8E\x7B\x00\xA1\x90\xF8\x8F\x00\x37\xB3\x00\xC1\x8E\x7C\x00\xA6\x90\xFE\x8F\xE0\x19\xB5\x00\xC1\x8E\x7D\x00\xA6\x90\x04\x90\x0A\x07\xC1\x8E\x7E\x00\xA6\x90\x09\x90\xCF\x0F\xB9\x00\xC1\x8E\x7F\x00\xA6\x90\x0E\x90\xCF\x0F\xBB\x00\xC1\x8E\x80\x00\xA6\x90\x14\x90\x64\x16\xA9\x43\xEB\x27\xA6\x90\x19\x90\xEF\x17\xBF\x00\xC1\x8E\x82\x00\xA6\x90\x1E\x90\x3D\x17\xC1\x00\xC1\x8E\x83\x00\x1D\x8F\x61\x00\x08\x8B\x2E\x28\xC1\x8E\x84\x00\xDB\x29\xDE\x01\xD5\x90\x18\x87\xB8\x4B\xC1\x8E\x91\x00\xDA\x90\x54\x1C\x2F\x89\xB6\x22\xC1\x8E\x9E\x00\xC3\x8E\xEF\x76\x3C\x90\x10\x1F\xC1\x8E\xAC\x00\xE7\x90\x03\x01\xDC\x90\xED\x80\xCC\x21\xAF\x43",
			"\xE3\x16\xBA\x00\xED\x90\x02\x01\xEF\x90\x34\x87\xCE\x57\xC1\x8E\xC8\x00\xF5\x90\xE9\x4F\x72\x89\xB3\x2E\xCF\x00\x66\x90\xE8\x90\x41\x84\x7D\x49\xC1\x8E\xD6\x00\xE1\x90\x52\x21\x52\x89\x21\x55\xC1\x8E\xE3\x00\xFC\x90\xB5\x10\x5A\x89\xA9\x18\xD4\x00\xC1\x8E\xF1\x00\x0D\x91\xF7\x90\x4A\x7F\x5E\x4D\xDA\x8E\x14\x91\x3E\x8E\xF8\x40\xC1\x8E\x0D\x00\xFA\x35\xBB\x01\x15\x91\x8D\x7D\xAC\x21\xB5\x43\x6C\x17\x1E\x91\xE2\x90\x6E\x7B\xF6\x24\xDC\x00\xC1\x8E\x29\x00\x25\x91\x08\x91\x48\x86\xAD\x32\xDE\x00\xC1\x8E\x37\x00\xFA\x35\xBD\x01\x20\x91\x20\x83\x8F\x71\x01\x8F\x2C\x91\x02\x91\x06\x82\x0F\x88\x54\x8F\xFA\x35\xDB\x90\x65\x8E\x75\x2C\x9E\x8F\x33\x91\x26\x91\x7F\x87\xEF\x17\xE6\x00\x16\x90\x39\x91\xEE\x90\xFC\x10\xB3\x64\x03\x0F\xBB\x43\x06\x7D\x49\x91\xF6\x90\xB3\x8F\x25\x41\xC1\x8E\x8C\x00\x43\x91\x2D\x91\x7E\x8E\xE0\x19\xEC\x00\xC1\x8E\x9B\x00\x50\x91\xFD\x90\x85\x8E\xB7\x30\xEE\x00\xC1\x8E\xA9\x00\x5D\x91\x0E\x91\xB7\x89\x48\x15\xF0\x00\xC1\x8E\xB7\x00\x56\x91\x3A\x91\x8B\x86\x1F\x34\xC1\x8E\xC6\x00\x6B\x91\x4A\x91",
			"\xBA\x84\x0A\x12\xF4\x00\xC1\x8E\xD5\x00\x71\x91\x51\x91\x9E\x8E\xCF\x0F\xF6\x00\xC1\x8E\xE4\x00\x78\x91\x5E\x91\xDC\x83\xB1\x10\xF8\x00\xC1\x8E\xF3\x00\x64\x91\x35\x91\xF7\x67\xB8\x15\xFA\x00\xC1\x8E\x01\x00\x65\x36\x1F\x91\xFC\x10\xAD\x76\xAA\x15\xFC\x00\xC1\x8E\x0F\x00\x8D\x91\x44\x91\xDB\x84\xFF\x5C\xC1\x8E\x1D\x00\x95\x91\x57\x91\xBF\x8E\xF6\x24\x04\x0E\xD2\x16\x2B\x00\x9B\x91\x6C\x91\xDE\x1E\xEB\x1C\x32\x0B\xDA\x6B\x65\x36\xBD\x01\x34\x14\xCB\x12\xB3\x2E\xC8\x43\x11\x89\xED\x76\xFE\x90\xCD\x2A\x32\x0B\xCC\x35\x63\x00\xD6\x90\xCD\x55\xA6\x91\x8B\x10\x65\x36\xDE\x01\xB4\x91\xDD\x90\x48\x15\x08\x00\xB7\x91\x21\x25\xB9\x91\x8E\x20\xE3\x90\xD0\x1A\x0A\x00\xBF\x91\xC4\x12\xA2\x91\xDF\x43\xE9\x90\x33\x39\xC6\x91\x82\x18\xC8\x91\x45\x37\x16\x8E\xAA\x88\xCC\x91\x50\x4F\xCE\x91\x46\x5F\xFC\x10\x9E\x75\x3D\x17\x10\x00\xD2\x91\xDB\x39\xD4\x91\x0D\x58\x22\x8E\x33\x72\xDA\x91\xA4\x3F\xC1\x91\xAB\x91\x23\x86\xAA\x15\x14\x00\xE0\x91\xA7\x00\xDC\x91\xBB\x91\xAA\x7C\xAC\x21\x16\x00\xE0\x91\xB5\x00\xE9\x91\x62\x89\xA9\x18",
			"\x18\x00\xE0\x91\xC3\x00\xF0\x91\x5E\x84\xB7\x30\x1A\x00\xE0\x91\xD1\x00\xF6\x91\xBB\x7C\x64\x3E\xE0\x91\xDF\x00\xFC\x91\xC0\x7C\x6D\x5D\xE0\x91\xED\x00\x01\x92\x81\x89\xEB\x8E\xE0\x91\xFB\x00\xA8\x91\xC2\x91\xCB\x7C\x7C\x3E\xE0\x91\x0A\x00\x9A\x36\xB0\x04\xEA\x91\xD2\x7C\x84\x3E\xE0\x91\x18\x00\x11\x92\xCF\x04\x13\x92\xDA\x7C\x8C\x3E\xE0\x91\x25\x00\x18\x92\xD1\x04\x1A\x92\x64\x86\x8E\x5D\xE0\x91\x34\x00\x1F\x92\x49\x05\x21\x92\xE8\x7C\xC5\x75\xE0\x91\x42\x00\x26\x92\xBB\x01\x28\x92\xB7\x7A\x4B\x06\xE0\x91\x50\x00\x26\x92\xBD\x01\x28\x92\xF7\x7C\x4D\x50\xE0\x91\x5F\x00\x2D\x92\x0C\x92\x2F\x82\xAD\x32\x30\x00\xE0\x91\x6D\x00\x3B\x92\xE3\x91\x36\x82\xA1\x1A\x32\x00\xE0\x91\x7B\x00\x34\x92\x3C\x92\x6D\x91\x79\x2E\x34\x00\xE0\x91\x8A\x00\x49\x92\x43\x92\x43\x82\xB1\x10\x36\x00\xE0\x91\x99\x00\x50\x92\x63\x1C\x93\x8D\xA9\x18\x38\x00\xE0\x91\xA8\x00\x57\x92\xC9\x91\xD3\x89\x78\x8D\xE0\x91\xB7\x00\x42\x92\x58\x92\xAC\x8E\x3D\x17\x3C\x00\xE0\x91\xC5\x00\x64\x92\x5F\x92\x5E\x82\xCA\x38\x3E\x00\xE0\x91\xD3\x00\x6B\x92",
			"\xCF\x91\xB9\x8E\x98\x4D\xE0\x91\xE1\x00\x72\x92\xD5\x91\xEC\x89\x3C\x15\x42\x00\xE0\x91\xEF\x00\x78\x92\xDD\x91\xF3\x89\x00\x37\x44\x00\xE0\x91\xFD\x00\x5E\x92\xDB\x60\xFC\x10\x28\x92\x5C\x1D\xB2\x91\xA2\x2A\xB0\x91\xC1\x26\x8B\x92\xFE\x12\x65\x00\xFC\x10\x55\x1A\x7C\x5B\x32\x0B\xFD\x3A\x6B\x1A\xA3\x91\xF6\x24\x4D\x00\x8F\x92\x64\x16\x67\x00\xB7\x8A\xB3\x2E\x4E\x00\xE0\x91\x05\x11\x9D\x92\xBD\x8A\xFB\x1E\x50\x00\xA1\x92\xB6\x11\xB8\x8A\x09\x01\x78\x1A\xC5\x6C\xA7\x92\x46\x2C\xFC\x10\x6C\x00\xB3\x2E\x54\x00\x9B\x92\x23\x2C\xB7\x8C\xF5\x26\xE0\x91\x0C\x00\xB1\x26\x88\x13\xAB\x92\x3E\x8B\x8E\x60\xE0\x91\x0E\x00\xB1\x26\x18\x79\xB5\x92\xE1\x20\x59\x00\xE0\x91\x0F\x00\xB9\x92\x0C\x01\x6B\x00\xBD\x8C\x12\x2E\xE0\x91\x11\x00\xC0\x92\x28\x79\xFC\x10\x6D\x00\xB3\x2E\x5D\x00\xB3\x92\xEF\x17\xB0\x92\xBC\x8B\xA1\x1A\x5E\x00\xE0\x91\x12\x00\xCE\x92\x87\x2C\x79\x90\xCA\x38\x60\x00\xE0\x91\x13\x00\xC7\x92\xDD\x92\xD7\x92\xCC\x21\x62\x00\xE0\x91\x15\x00\xDC\x92\x8E\x2C\x52\x8F\xD6\x48\xE0\x91\x16\x00\xE3\x92\xEB\x92\x57\x8F",
			"\xD5\x8C\x16\x92\xF0\x92\xDC\x12\x64\x8B\xF9\x1B\xE0\x91\x1A\x00\xF5\x92\xA8\x2C\x05\x8F\xFB\x1E\x6A\x00\xE0\x91\x1C\x00\xFB\x92\xB0\x2C\x0C\x8F\x33\x67\xE0\x91\x1E\x00\x02\x93\xB8\x2C\x12\x8F\xD7\x1D\xE0\x91\x20\x00\x08\x93\xD1\x92\x79\x1C\xA1\x1A\x70\x00\xE0\x91\x22\x00\x0E\x93\x85\x8B\xE3\x1D\xE0\x91\x24\x00\x15\x93\x8A\x8B\xE1\x20\x74\x00\xE0\x91\x26\x00\x1A\x93\x90\x8B\x25\x2A\xE0\x91\x28\x00\x20\x93\x96\x8B\xBB\x4B\xE0\x91\x2A\x00\x25\x93\x9C\x8B\xC4\x4B\xE0\x91\x2C\x00\x2A\x93\xA1\x8B\xB4\x1A\xE0\x91\x2E\x00\x2F\x93\xA6\x8B\xFB\x1E\x7E\x00\xE0\x91\x30\x00\x34\x93\xCF\x90\x86\x35\xE0\x91\x32\x00\x08\x93\x86\x1A\xDD\x77\x79\x2E\x82\x00\x24\x92\x3F\x93\xEC\x92\x16\x35\xE0\x91\x36\x00\x45\x93\xF2\x92\x17\x1C\xE0\x91\x38\x00\x4A\x93\x5C\x8F\x81\x6A\xE0\x91\x3A\x00\x4F\x93\x61\x8F\xB7\x30\x8A\x00\xE0\x91\x3C\x00\x54\x93\x66\x8F\xAD\x32\x8C\x00\xE0\x91\x3E\x00\x5A\x93\x6C\x8F\xFE\x3F\xE0\x91\x40\x00\x60\x93\x72\x8F\x55\x54\x2B\x92\x65\x93\x78\x8F\x7D\x19\x92\x00\xE0\x91\x44\x00\x65\x93\xAD\x90\x7D\x19\x94\x00",
			"\xE0\x91\x46\x00\x65\x93\xB3\x90\x0C\x69\xE0\x91\x48\x00\x65\x93\xB8\x90\x03\x0F\x98\x00\xE0\x91\x4A\x00\x65\x93\xBE\x90\x03\x0F\x9A\x00\xE0\x91\x4C\x00\x65\x93\xC4\x90\x3D\x17\x9C\x00\xE0\x91\x4E\x00\x65\x93\xC9\x90\x5F\x41\x32\x92\x65\x93\x3B\x93\xE0\x19\xA0\x00\xE0\x91\x52\x00\x08\x93\x52\x14\xFA\x77\xB3\x2E\xA2\x00\x32\x0B\x5C\x90\x82\x18\xFC\x10\x40\x93\xFB\x1E\xA9\x00\xD4\x92\xE0\x19\x58\x14\xFB\x86\x6B\x33\xE0\x91\x54\x00\xEA\x92\xC9\x2E\xFC\x10\xC9\x92\xBE\x8A\xA2\x93\x7D\x19\x42\x14\x16\x2B\xB3\x2E\xAD\x00\xAE\x93\x58\x79\xFC\x10\xBB\x92\xE1\x20\xAE\x00\xAD\x92\x0B\x30\xFC\x10\x95\x1A\x89\x35\xB4\x93\x8F\x18\x49\x8A\x89\x8D\xBA\x93\xAA\x15\x4A\x8A\x0E\x75\x9D\x26\xB3\x00\xE0\x91\x55\x00\xA9\x93\x02\x01\x60\x14\x88\x30\xB3\x2E\xB5\x00\x32\x0B\x97\x60\xA9\x1A\xB1\x8A\xD8\x1E\xC3\x93\x8C\x32\x50\x8A\xB3\x2E\xBA\x00\xD6\x93\xB8\x15\x51\x8A\x31\x5F\xE9\x8A\xBF\x93\x0A\x12\x7B\x00\xDE\x92\xB1\x10\xBD\x00\xE0\x91\x56\x00\xCB\x93\x0E\x33\x5A\x89\xB3\x2E\x1E\x44\xAE\x91\x26\x33\x46\x93\xD0\x7A\xE0\x91\x57\x00",
			"\xE8\x93\x16\x33\x86\x90\xB4\x40\xE0\x91\x58\x00\xF3\x93\xE2\x93\x8C\x90\xB7\x30\xC4\x00\xE0\x91\x59\x00\xF9\x93\xFD\x92\x9E\x4A\xE0\x91\x5A\x00\x00\x94\xD2\x4E\x85\x2A\xE0\x91\x5B\x00\x05\x94\x73\x1C\xD3\x2E\xE0\x91\x5C\x00\x0A\x94\x46\x17\x51\x71\xE0\x91\x5D\x00\x0F\x94\x20\x8F\x12\x55\xE0\x91\x5E\x00\x14\x94\x26\x8F\xF5\x77\x39\x92\x19\x94\xAE\x5E\xC8\x4A\xE0\x91\x60\x00\x1D\x94\x7B\x93\x63\x0B\xE0\x91\x61\x00\x1D\x94\x81\x93\x95\x78\xE0\x91\x62\x00\x1D\x94\x87\x93\xEF\x17\xD8\x00\xE0\x91\x63\x00\x1D\x94\x8D\x93\x7D\x19\xDA\x00\xE0\x91\x64\x00\x1D\x94\x91\x93\x7D\x19\x5C\x45\xDC\x27\xF3\x93\xB5\x1A\x41\x93\x2F\x91\xE0\x91\x66\x00\x3D\x94\xEF\x93\x8F\x71\xE0\x91\x67\x00\x43\x94\x4B\x93\x73\x48\xE0\x91\x68\x00\x48\x94\x50\x93\x04\x4B\xE0\x91\x69\x00\x4D\x94\x55\x93\x00\x37\xE6\x00\xE0\x91\x6A\x00\x52\x94\x5B\x93\xB7\x30\xE8\x00\xE0\x91\x6B\x00\x58\x94\x61\x93\x60\x7B\xE0\x91\x6C\x00\x5E\x94\x66\x93\xAD\x32\xEC\x00\x40\x92\x63\x94\x6A\x93\x05\x11\xEE\x00\xE0\x91\x6E\x00\x63\x94\x70\x93\x05\x11\xF0\x00\xE0\x91",
			"\x6F\x00\x63\x94\x76\x93\xB8\x0D\xE0\x91\x70\x00\x63\x94\x23\x94\x95\x57\xE0\x91\x71\x00\x63\x94\x28\x94\x6B\x45\xE3\x16\x72\x00\x63\x94\x2D\x94\xE0\x19\xF8\x00\xE0\x91\x73\x00\x63\x94\x33\x94\x05\x11\xFA\x00\xE0\x91\x74\x00\x63\x94\x39\x94\x05\x11\xFC\x00\xE0\x91\x75\x00\xF3\x93\x7D\x00\xFC\x10\xC3\x1A\x52\x66\xE0\x93\x3C\x15\x96\x94\xAB\x8C\xF6\x24\xFF\x00\xE0\x91\x76\x00\x08\x93\x9C\x94\x24\x8A\x88\x23\xD2\x0B\x6C\x58\xB1\x26\xF6\x10\xA3\x94\x2C\x8A\xE4\x2C\xA6\x94\x4F\x10\xA8\x94\x34\x1E\x33\x8A\xB3\x2E\x05\x00\xAD\x94\x67\x10\xAF\x94\xEA\x36\x40\x91\x4D\x75\xB4\x94\x06\x01\x81\x00\xB6\x94\xEE\x33\x83\x8D\xD0\x1A\x09\x00\xBA\x94\x35\x4E\xBD\x94\x2E\x39\xC1\x93\xAD\x23\xC2\x94\x10\x33\xC4\x94\x5E\x10\xD8\x93\x78\x31\xC8\x94\x07\x13\xCA\x94\xF0\x23\x57\x8A\xB0\x2F\xCE\x94\xD4\x39\xD0\x94\x2E\x20\x5F\x8A\xF4\x8B\xD4\x94\x90\x00\xD6\x94\xAA\x94\x67\x8A\xD0\x1A\x13\x00\xD4\x94\x93\x00\xDC\x94\x6D\x8A\xCA\x88\xD4\x94\x96\x00\xE3\x94\x73\x8A\x5F\x39\xD4\x94\x99\x00\xE8\x94\x79\x8A\xA1\x32\xD4\x94\x9C\x00\xED\x94",
			"\x7F\x8A\x36\x2D\xD4\x94\x9F\x00\xF2\x94\x84\x8A\x6B\x39\xD4\x94\xA2\x00\xF7\x94\x8A\x8A\x31\x7F\xD4\x94\xA5\x00\xFC\x94\x90\x8A\x4B\x2D\xD4\x94\xA8\x00\x01\x95\x18\x8B\x23\x3B\xD4\x94\xAB\x00\x01\x95\x9B\x8A\xE1\x20\x25\x00\xD4\x94\xAE\x00\x01\x95\xFC\x88\xFB\x1E\x27\x00\xD4\x94\xB1\x00\x95\x94\x24\x8B\x0F\x89\xD4\x94\xB2\x00\xD6\x94\xBC\x1A\xB8\x18\x2A\x60\xD2\x0B\xF8\x7B\xC2\x92\x1B\x79\xD4\x94\xB5\x00\x08\x93\x1D\x95\xA0\x2E\x23\x79\xD4\x94\xB7\x00\x1C\x95\x9E\x92\x32\x29\xD4\x94\xBA\x00\x2C\x95\xA4\x92\x7C\x39\xD4\x94\xBD\x00\x31\x95\xC3\x8A\x3D\x17\x34\x00\xD4\x94\xC0\x00\x36\x95\xC7\x8A\xC4\x3E\xD4\x94\xC3\x00\x3C\x95\xCD\x8A\xFB\x1E\x38\x00\xD4\x94\xC6\x00\x41\x95\xD2\x8A\x81\x69\xD4\x94\xC9\x00\x47\x95\xD7\x8A\x40\x3B\xD4\x94\xCC\x00\x4C\x95\xDC\x8A\x01\x45\xD4\x94\xCF\x00\x4C\x95\xE1\x8A\xF6\x24\x40\x00\xD4\x94\xD2\x00\x4C\x95\x6E\x8A\x10\x76\xD4\x94\xD5\x00\x4C\x95\x7E\x2F\x18\x76\xD4\x94\xD8\x00\x4C\x95\xDC\x8E\xE1\x20\x46\x00\xD4\x94\xDB\x00\x4C\x95\xFC\x8A\xFD\x8E\xD4\x94\xDE\x00\x4C\x95\x69\x90",
			"\xA5\x7C\xD4\x94\xE1\x00\x4C\x95\x09\x8B\xAB\x7C\xD4\x94\xE4\x00\x4C\x95\xBE\x89\x00\x37\x4E\x00\xD4\x94\xE7\x00\x4C\x95\x07\x95\xBE\x6C\xD4\x94\xEA\x00\x4C\x95\x0C\x95\xAC\x21\x52\x00\xD4\x94\xED\x00\x4C\x95\x12\x95\xE1\x20\x54\x00\xD4\x94\xF0\x00\xF3\x93\x27\x95\x02\x01\x25\x8B\xAC\x21\x56\x00\xD4\x94\xF1\x00\xD6\x94\x71\x14\xC8\x35\xB3\x2E\x58\x00\x20\x95\x7F\x35\xFC\x10\x79\x00\xB3\x2E\x59\x00\xD2\x0B\x6C\x8C\xAA\x15\x64\x14\x49\x1F\xAF\x8F\x9F\x95\xFE\x12\xA8\x95\xBE\x94\xE9\x29\xAB\x95\x64\x16\x82\x00\xFC\x10\xFA\x93\xB1\x24\xB0\x95\x24\x7C\xEA\x93\xD0\x1A\x66\x00\xB6\x95\xEF\x17\xCA\x1A\x3F\x94\xB7\x30\x67\x00\xD4\x94\xF4\x00\xF3\x93\xBD\x95\x06\x01\x85\x00\xC8\x8F\xBB\x95\xE0\x19\xC4\x95\xE4\x49\xFE\x92\xD4\x94\xF5\x00\xC3\x95\xF5\x93\xAC\x21\x6C\x00\xD4\x94\xF6\x00\xCF\x95\xFB\x93\x00\x37\x6E\x00\xD4\x94\xF7\x00\xD5\x95\x91\x90\xCA\x38\x70\x00\xD4\x94\xF8\x00\xDB\x95\x96\x90\x9F\x3F\xD4\x94\xF9\x00\xE1\x95\x9C\x90\x03\x19\x74\x00\xD4\x94\xFA\x00\xE6\x95\xA2\x90\xCA\x38\x76\x00\xD4\x94\xFB\x00\xEC\x95",
			"\xA7\x90\xCA\x38\x78\x00\xD4\x94\xFC\x00\xF2\x95\x6F\x94\xB6\x11\x7A\x00\xD4\x94\xFD\x00\xF2\x95\x75\x94\xE3\x34\xD4\x94\xFE\x00\xF2\x95\x7A\x94\x75\x14\xD4\x94\xFF\x00\xF2\x95\x7F\x94\xB8\x18\xD4\x94\xF8\x4D\xDA\x35\xFC\x10\x84\x94\x7D\x19\x82\x00\xD4\x94\x01\x00\xA6\x36\x0D\x96\x80\x17\x61\x65\xD4\x94\x02\x00\x14\x96\xE2\x35\xFC\x10\x90\x94\xB6\x11\x86\x00\xD4\x94\x03\x00\x1A\x96\x9B\x36\xE3\x93\xFE\x12\x88\x00\xD4\x94\x04\x00\x22\x96\x06\x01\x84\x00\x44\x94\xD9\x18\xD4\x94\x05\x00\x29\x96\x35\x4E\xD0\x95\xF6\x24\x8C\x00\xD4\x94\x06\x00\x30\x96\xC6\x18\xF7\x92\x3D\x1E\xD4\x94\x07\x00\x37\x96\x6A\x26\x01\x94\x09\x33\xD4\x94\x08\x00\x3D\x96\x00\x00\x2B\x96\x06\x94\x9A\x59\xD4\x94\x09\x00\x43\x96\x45\x96\x0B\x94\x0A\x22\xD4\x94\x0A\x00\x4A\x96\x19\x8F\x5B\x1E\xD4\x94\x0B\x00\x50\x96\x97\x32\xAD\x70\xD4\x94\x0C\x00\x55\x96\x86\x1C\xB6\x59\xD4\x94\x0D\x00\x5A\x96\xB9\x16\xD0\x1A\x9C\x00\xD4\x94\x0E\x00\x5F\x96\x41\x16\x78\x1E\xD4\x94\x0F\x00\x65\x96\xEA\x64\x45\x33\xD4\x94\x10\x00\x6A\x96\xEE\x1D\xD4\x59\xD4\x94",
			"\x11\x00\x6F\x96\x8A\x94\x74\x4A\xD4\x94\x12\x00\x6F\x96\x1D\x96\x79\x44\xD4\x94\x13\x00\x43\x96\xC6\x95\xB6\x37\xB2\x8A\xC8\x95\x7D\x19\x7F\x96\x44\x8B\xA0\x93\xD4\x94\x14\x00\xA6\x36\x88\x13\x84\x96\x28\x95\x15\x28\xD4\x94\x16\x00\xA6\x36\xF6\x10\x8B\x96\xA9\x2E\xCF\x5E\xD4\x94\x19\x00\x90\x96\x6C\x11\xB1\x94\x51\x84\xD4\x94\x1C\x00\x97\x96\x09\x01\x92\x96\xA7\x52\x1C\x28\xD4\x94\x1F\x00\x9D\x96\xC5\x95\xBF\x94\xEA\x6A\xD4\x94\x22\x00\xA4\x96\x90\x58\xC6\x94\x59\x25\xD4\x94\x25\x00\xAA\x96\x89\x43\xCC\x94\x60\x25\xD4\x94\x28\x00\xB0\x96\x01\x01\x9F\x96\x4D\x95\x66\x42\xD4\x94\x2B\x00\xB6\x96\x00\x00\xB8\x96\x52\x95\x3E\x2C\xD4\x94\x2E\x00\xBD\x96\xB8\x96\x57\x95\x9D\x26\xBD\x00\xD4\x94\x31\x00\xC4\x96\xE4\x94\x22\x1B\xD4\x94\x34\x00\xCB\x96\xE9\x94\x29\x68\xD4\x94\x37\x00\xD0\x96\xEE\x94\xE1\x20\xC3\x00\xD4\x94\x3A\x00\xD5\x96\xF3\x94\x9D\x26\xC5\x00\xD4\x94\x3D\x00\xDB\x96\xF8\x94\x0A\x1F\xD4\x94\x40\x00\xE1\x96\xFD\x94\x02\x46\xD4\x94\x43\x00\xE6\x96\x02\x95\x8B\x30\xD4\x94\x46\x00\xEB\x96\x82\x95\xF6\x24",
			"\xCD\x00\xD4\x94\x49\x00\xEB\x96\x87\x95\xF6\x24\xCF\x00\xD4\x94\x4C\x00\xEB\x96\x8D\x95\xDB\x22\xD4\x94\x4F\x00\x7E\x96\x18\x95\xD0\x1A\xD3\x00\xD4\x94\x50\x00\xBD\x96\x90\x14\x80\x11\x4E\x5F\x82\x96\x05\x11\x08\x97\x9B\x01\xFD\x2E\xD4\x94\x53\x00\x89\x96\x76\x1E\xFC\x10\xE0\x1A\xF8\x40\xD4\x94\x55\x00\x07\x97\x2D\x95\x6E\x48\xD4\x94\x58\x00\x19\x97\x32\x95\x05\x41\xD4\x94\x5B\x00\x1E\x97\x37\x95\xEF\x17\xDE\x00\xD4\x94\x5E\x00\x23\x97\x3D\x95\xFB\x1E\xE0\x00\xD4\x94\x61\x00\x29\x97\x42\x95\x6D\x2C\xD4\x94\x64\x00\x2F\x97\x48\x95\xE1\x20\xDE\x45\x3F\x82\x34\x97\xB9\x96\x3C\x78\xD4\x94\x6A\x00\x39\x97\xC0\x96\x9D\x26\xE8\x00\xD4\x94\x6D\x00\x39\x97\xC6\x96\xEF\x16\xEA\x00\xD4\x94\x70\x00\x39\x97\x5D\x95\xE1\x20\xEC\x00\xD4\x94\x73\x00\x39\x97\x62\x95\xF0\x25\xD4\x94\x76\x00\x39\x97\x67\x95\xAC\x21\xF0\x00\xD4\x94\x79\x00\x39\x97\x6D\x95\xB6\x0D\xD4\x94\x7C\x00\x39\x97\x72\x95\xAC\x21\xF4\x00\xD4\x94\x7F\x00\x39\x97\x77\x95\x35\x66\xD4\x94\x82\x00\x39\x97\x7C\x95\x8F\x7B\xD4\x94\x85\x00\x39\x97\xF1\x96\x9D\x26",
			"\xFA\x00\xD4\x94\x88\x00\x39\x97\xF7\x96\x9D\x26\xFC\x00\xD4\x94\x8B\x00\x39\x97\xFD\x96\xF6\x24\xFE\x00\xD4\x94\x8E\x00\x43\x96\x0D\x97\x94\x95\xB3\x2E\x82\x4D\xF2\x27\xBD\x96\x95\x14\x09\x97\xD0\x1A\x02\x00\x23\x47\x05\x11\xD2\x1A\x41\x10\xB3\x2E\x03\x00\x08\x0E\xA6\x95\x48\x15\x7E\x14\x23\x96\x78\x31\x8D\x97\xB6\x11\x96\x97\xA5\x96\xAA\x88\x99\x97\x0A\x12\x8A\x00\xFC\x10\xCA\x95\xAC\x21\xF0\x45\xED\x93\x06\x01\xA0\x97\x9E\x96\xB6\x88\x9E\x97\xAC\x39\x24\x96\x64\x16\x11\x00\x08\x0E\x88\x13\x92\x00\x43\x96\x8B\x00\xFC\x10\xD9\x1A\xDF\x94\xAA\x97\xB2\x39\x2C\x96\xDB\x44\xAF\x97\x3B\x3C\xB2\x97\x32\x96\x9D\x26\x16\x00\xBB\x97\x37\x7E\xBD\x97\xD6\x95\xCA\x38\x18\x00\xC1\x97\x61\x2E\xC3\x97\xDC\x95\xB1\x10\x1A\x00\xC7\x97\x03\x01\x96\x00\xC9\x97\xE2\x95\xB1\x10\x1C\x00\xCD\x97\x02\x01\x97\x00\xD0\x97\xE7\x95\xA1\x1A\xF7\x45\xE3\x16\x98\x00\xD7\x97\xED\x95\xB1\x10\x20\x00\xD4\x97\x45\x3F\xDD\x97\xF3\x95\xB1\x10\x22\x00\xE1\x97\xA4\x3F\xE3\x97\xF9\x95\x0A\x12\x24\x00\xE7\x97\x9B\x00\xE3\x97\xFF\x95\x01\x01\x26\x00",
			"\xE7\x97\x9C\x00\xE3\x97\x04\x96\x03\x01\x28\x00\xE7\x97\x9D\x00\xE3\x97\x09\x96\xF1\x1C\xE7\x97\x9E\x00\xE3\x97\x0F\x96\x05\x11\x2C\x00\xE7\x97\x9F\x00\xE3\x97\x75\x96\x0A\x12\x2E\x00\xE7\x97\xA0\x00\xE3\x97\x7A\x96\x3C\x15\x30\x00\xE7\x97\xA1\x00\x43\x96\x8C\x00\xAC\x97\x29\x89\xE7\x97\xA2\x00\x12\x98\xB9\x97\xA1\x1A\x34\x00\xE7\x97\xA3\x00\x18\x98\x49\x94\xA1\x1A\x36\x00\xE7\x97\xA4\x00\x1E\x98\x4E\x94\x3F\x89\xE7\x97\xA5\x00\x24\x98\x53\x94\x1D\x86\xE7\x97\xA6\x00\x29\x98\x59\x94\x8E\x4D\xE7\x97\xA7\x00\x2E\x98\x5F\x94\xE2\x3E\xE7\x97\xA8\x00\x33\x98\x64\x94\x31\x86\xE7\x97\xA9\x00\x38\x98\x69\x94\xD8\x49\xE7\x97\xAA\x00\x38\x98\xEA\x97\x6E\x5B\xE7\x97\xAB\x00\x38\x98\xF0\x97\x74\x21\xE7\x97\xAC\x00\x38\x98\xF6\x97\xBD\x5D\xE7\x97\xAD\x00\x38\x98\xFC\x97\x7F\x22\xE7\x97\xAE\x00\x38\x98\x01\x98\x30\x16\xE7\x97\xAF\x00\x38\x98\x07\x98\x3C\x15\x4E\x00\xE7\x97\xB0\x00\x38\x98\x0D\x98\xAA\x15\x50\x00\xE7\x97\xB1\x00\x43\x96\xB5\x97\xA6\x25\xB3\x2E\x52\x00\xB7\x97\x48\x15\x68\x98\x0E\x97\xA8\x53\xE7\x97\xB2\x00",
			"\x12\x97\xFC\x39\x14\x97\xB3\x2E\x55\x00\xE7\x97\xB4\x00\xBD\x96\x6E\x98\x93\x96\xFB\x1E\x57\x00\xE7\x97\xB7\x00\x7A\x98\x99\x96\x14\x73\xE7\x97\xBA\x00\x81\x98\x78\x87\xEF\x17\x5B\x00\xE7\x97\xBD\x00\x86\x98\x5A\x5B\xD2\x92\xE7\x97\xC0\x00\x8C\x98\x46\x31\xA9\x8F\xE7\x97\xC3\x00\x91\x98\x02\x01\xDD\x93\xE2\x3C\xE7\x97\xC6\x00\x96\x98\xC1\x34\xAF\x8F\xE7\x97\xC9\x00\x9C\x98\xAC\x45\x5E\x83\xE7\x97\xCC\x00\xA1\x98\x45\x97\x03\x19\x1A\x46\xE3\x16\xCF\x00\xA1\x98\x4B\x97\xD0\x2B\xE7\x97\xD2\x00\xA1\x98\x51\x97\xD7\x2B\xE7\x97\xD5\x00\xA1\x98\x56\x97\xF6\x24\x6D\x00\xE7\x97\xD8\x00\xA1\x98\x5C\x97\x8B\x2E\xE7\x97\xDB\x00\xA1\x98\x61\x97\xF6\x24\x71\x00\xE7\x97\xDE\x00\xA1\x98\x67\x97\xF2\x2B\xE7\x97\xE1\x00\xA1\x98\x6C\x97\xB1\x10\x21\x46\xE3\x16\xE4\x00\xA1\x98\x71\x97\xEF\x16\x77\x00\xE7\x97\xE7\x00\xA1\x98\x77\x97\xCA\x24\xE7\x97\xEA\x00\xA1\x98\x7D\x97\x0D\x57\xE7\x97\xED\x00\x67\x98\x02\x97\xFB\x1E\x7D\x00\xE7\x97\xEE\x00\xBD\x96\xAB\x14\x69\x98\x8E\x27\x6C\x98\x26\x1C\x22\x95\xF6\x24\x80\x00\xE7\x97\xF1\x00",
			"\x73\x98\xC6\x20\x75\x98\x15\x1E\xE7\x97\xF3\x00\xE8\x98\x1A\x97\xD4\x21\xE7\x97\xF6\x00\xF9\x98\x1F\x97\xF6\x24\x86\x00\xE7\x97\xF9\x00\xFE\x98\x24\x97\x62\x44\xE7\x97\xFC\x00\x04\x99\x2A\x97\xF0\x3F\xE7\x97\xFF\x00\x09\x99\x30\x97\xF0\x21\xE7\x97\x02\x00\xB7\x37\xF6\x10\xE9\x98\x48\x10\x3E\x90\xE7\x97\x05\x00\x13\x99\x6E\x24\xD2\x94\xFB\x21\xE7\x97\x08\x00\x1A\x99\xC5\x10\xD8\x94\x4D\x1E\xE7\x97\x0B\x00\x20\x99\xF4\x98\x54\x08\xB3\x2E\x94\x00\xE7\x97\x0E\x00\x26\x99\xBC\x33\xCC\x96\xFB\x1E\x96\x00\xE7\x97\x11\x00\x2D\x99\x3F\x29\xFC\x10\xB2\x98\x6B\x54\xE7\x97\x14\x00\x34\x99\xA0\x14\xD7\x8E\xB6\x59\xE7\x97\x17\x00\x3B\x99\xAA\x14\x8B\x8E\xA5\x65\xE7\x97\x1A\x00\x41\x99\x15\x99\xE2\x96\x66\x61\xE7\x97\x1D\x00\x47\x99\x08\x8B\xBC\x6D\xE7\x97\x20\x00\x4D\x99\xE9\x8B\x05\x11\xA2\x00\xE7\x97\x23\x00\x52\x99\x57\x0C\xB3\x2E\xA4\x00\xE7\x97\x26\x00\x58\x99\x67\x01\x93\x54\xE7\x97\x29\x00\x5E\x99\xB0\x01\xB2\x8A\xE7\x97\x2C\x00\xB7\x37\x2E\x0F\x48\x99\x01\x01\x95\x95\x61\x40\xE7\x97\x2D\x00\x41\x99\xB0\x14\xEA\x98",
			"\x67\x40\xEC\x98\xEF\x18\xA1\x95\xB2\x93\x93\x97\x11\x7E\xFC\x10\x13\x98\xD0\x1A\xB7\x00\x74\x99\x03\x0F\x99\x14\x74\x98\xD8\x1E\x7E\x99\x3E\x2F\x54\x3C\xB3\x2E\x40\x48\xA5\x97\x87\x3C\xFC\x10\xA7\x97\xA1\x33\x83\x99\x85\x99\xCE\x36\xB3\x2E\x4C\x48\x88\x99\x8E\x3C\xB4\x97\xE9\x8A\x8D\x99\x21\x4C\xFC\x10\x20\x1F\x74\x25\x0C\x99\xB6\x11\x99\x99\x61\x2E\xEB\x93\x08\x0E\x97\x60\xE7\x1A\x9D\x94\x02\x64\xE7\x97\x30\x00\x68\x99\x5D\x3C\xFC\x10\x9D\x00\xBB\x2E\x9B\x99\xC6\x46\xEE\x98\x0F\x52\xE7\x97\x31\x00\xA7\x99\xB4\x14\xA9\x99\x11\x8B\x96\x99\x8D\x3F\xFC\x10\x98\x00\xB3\x2E\x63\x49\xF0\x5A\xD3\x01\xFC\x10\x9A\x00\xFF\x90\xAC\x99\x3C\x15\xEE\x1A\x33\x01\xB3\x2E\xD1\x00\xB6\x99\x02\x01\xAA\x99\x39\x03\xF0\x2E\xC7\x99\x01\x01\x9E\x00\xAE\x99\x91\x17\xE7\x97\x32\x00\xB2\x99\x06\x01\xCE\x99\x09\x01\x0C\x1B\xE5\x57\xC1\x99\xAA\x15\xC7\x14\xA3\x99\x54\x2C\xE7\x97\x33\x00\xD3\x99\xC6\x14\xFC\x10\xD7\x99\xFB\x1E\x16\x4A\x92\x99\x49\x11\xFC\x10\xFE\x1A\xC5\x5C\xCC\x99\x9A\x43\xFC\x10\xA4\x00\xB3\x2E\x21\x4A\xBE\x95\xFD\x1A",
			"\x98\x99\xB3\x2E\x2D\x4A\xF3\x5E\xE0\x99\x02\x01\x28\x1F\x50\x11\xB3\x2E\x39\x4A\xE6\x99\xA0\x3E\xED\x99\x1E\x2F\xD9\x99\x48\x15\xEE\x99\x5A\x03\x24\x2F\x08\x0E\x39\x44\x0A\x12\xA5\x00\xFF\x99\x3C\x23\x01\x9A\xB8\x15\xA6\x00\xF3\x99\x95\x1F\xE7\x97\x35\x00\xF7\x99\x01\x01\x0E\x9A\xF3\x04\xB3\x2E\xEF\x00\xEB\x99\xE3\x99\x41\x43\xB3\x2E\xF0\x00\xEB\x99\xA8\x00\x1C\x99\xA4\x1F\x0C\x9A\xCF\x0F\x1F\x9A\xCF\x06\x5C\x2F\x22\x9A\x03\x0F\x58\x8A\x82\x06\x62\x2F\xEB\x99\xAB\x00\xCF\x99\x9A\x55\xE7\x97\x36\x00\xB7\x37\x88\x13\x2D\x9A\x60\x7E\x60\x88\xE7\x97\x38\x00\x13\x9A\x00\x00\xD5\x14\x39\x06\xB3\x2E\xA1\x4A\xFD\x99\x3B\x9A\x85\x96\x6B\x28\xE7\x97\x39\x00\x32\x9A\x04\x05\xB4\x99\xD0\x1A\xFD\x00\xE7\x97\x3B\x00\x39\x9A\x13\x1B\x3C\x9A\x81\x23\xEB\x99\x4D\x9A\x41\x9A\xAC\x21\xC7\x06\xE3\x16\x3C\x00\x45\x9A\xDD\x14\x35\x9A\x8B\x97\x4C\x0C\x88\x13\x3E\x00\x39\x9A\xAE\x00\xFC\x10\xA9\x00\xAC\x91\x4C\x0C\x9C\x93\xFF\x44\xFC\x10\x34\x9A\xFF\x2C\x4C\x0C\xCC\x35\x3F\x97\xB5\x00\xE4\x8B\x69\x9A\x41\x46\x2E\x9A\xA1\x1A\x0D\x00",
			"\x5B\x9A\x3E\x26\x57\x9A\xD9\x06\xE2\x99\xB0\x2F\x73\x9A\xA6\x20\x39\x9A\xE3\x14\x09\x01\xB4\x00\xF4\x8B\x6E\x9A\xFE\x12\x7C\x9A\x52\x9A\xF6\x24\x12\x00\x79\x9A\xF6\x8D\x75\x9A\x03\x01\x82\x9A\x03\x01\x1A\x9A\x4F\x62\x86\x9A\x39\x6F\x39\x9A\x19\x1B\x7D\x9A\xB3\x2E\xAF\x4A\xFD\x99\x91\x9A\x83\x9A\x9D\x26\x17\x00\x8E\x9A\x2A\x15\x88\x9A\x02\x01\x96\x9A\x8B\x9A\xB3\x2E\x19\x00\x9A\x9A\x01\x01\x47\x00\x39\x9A\x7E\x9A\xA1\x44\xD8\x8E\x63\x9A\xE3\x46\xFC\x10\x2F\x1F\xD0\x1A\x22\x00\x80\x9A\x60\x47\x70\x9A\xCC\x21\x23\x00\xA2\x9A\x1E\x8F\x39\x9A\xB6\x00\xFC\x10\xBC\x00\xFE\x88\xB4\x9A\x05\x11\xF7\x14\x97\x9A\x70\x72\xB4\x9A\x49\x00\x39\x9A\xBD\x9A\x49\x07\x0F\x89\xAF\x9A\x3D\x17\x1E\x1B\xF1\x99\xCA\x38\x2A\x00\xB4\x9A\x4A\x00\x39\x9A\xC8\x9A\xE5\x77\x24\x29\xB4\x9A\x4B\x00\xCE\x9A\xBE\x97\xEF\x16\x2E\x00\xB4\x9A\x4C\x00\xD4\x9A\xC4\x97\xB1\x10\x30\x00\xB4\x9A\x4D\x00\xDA\x9A\xCA\x97\xFE\x12\xBD\x4A\xB5\x52\xE0\x9A\xD1\x97\x68\x34\xB4\x9A\x4F\x00\xE5\x9A\xD8\x97\xC7\x62\xB4\x9A\x50\x00\xEA\x9A\xDE\x97\xFE\x12\x38\x00",
			"\xB4\x9A\x51\x00\xEF\x9A\xE4\x97\xFE\x12\x3A\x00\xB4\x9A\x52\x00\xF5\x9A\x43\x98\xAA\x15\x3C\x00\xB4\x9A\x53\x00\xF5\x9A\x48\x98\x3E\x00\xB4\x9A\x54\x00\xF5\x9A\x4D\x98\x0C\x21\xB4\x9A\x55\x00\xF5\x9A\x52\x98\xDD\x6E\xB4\x9A\x56\x00\xF5\x9A\x57\x98\x90\x7C\xB4\x9A\x57\x00\xF5\x9A\x5C\x98\xAA\x15\x46\x00\xB4\x9A\x58\x00\xF5\x9A\x62\x98\x48\x15\x48\x00\xB4\x9A\x59\x00\x39\x9A\xBA\x00\xFC\x10\xB7\x00\xB3\x2E\x4A\x00\x4C\x0C\xC1\x48\xFC\x10\x22\x9B\xB3\x4D\xC6\x9A\xEF\x17\xB9\x9A\x18\x07\xB3\x2E\x50\x00\x2C\x9B\xE0\x19\xBD\x00\xFC\x10\xA7\x98\xA1\x1A\x51\x00\xBB\x9A\xB6\x11\xC6\x96\xC3\x00\xB3\x2E\x53\x00\x32\x9B\xC4\x49\xFC\x10\xC2\x00\xB1\x92\x3F\x9B\x05\x11\xC0\x00\xB1\x9A\x79\x2E\x55\x00\xB4\x9A\x5A\x00\x9C\x9A\xAB\x2E\xB8\x9A\xA6\x8C\xB4\x9A\x5C\x00\x39\x9A\x01\x15\x7E\x08\xA3\x95\x44\x9B\xB6\x11\x53\x9B\xBE\x9A\xA1\x79\xB4\x9A\x5D\x00\x4C\x9B\x00\x00\x58\x9B\xC4\x9A\xB8\x8C\xB4\x9A\x5F\x00\x39\x9A\x42\x9B\x40\x08\xB3\x2E\x5E\x00\x4C\x0C\x6A\x49\x3C\x9B\x68\x08\xB3\x2E\x62\x00\x56\x9B\xAC\x4B\x36\x99\xAF\x8F",
			"\x39\x9B\x70\x9B\xEB\x1F\x5E\x83\x73\x9B\xB2\x4B\x17\x8B\xB3\x2E\x67\x00\x77\x9B\xAA\x15\xC6\x00\xFC\x10\x47\x1F\xFB\x1E\xD9\x4A\xC9\x9A\xBA\x12\x7F\x9B\xB3\x2E\x6B\x00\x7C\x9B\x79\x83\x14\x98\xEF\x17\x6D\x00\xB4\x9A\x60\x00\x39\x9A\xC8\x00\x19\x98\xCC\x21\x6F\x00\xB4\x9A\x61\x00\x8F\x9B\xD5\x9A\x03\x19\x71\x00\xB4\x9A\x62\x00\x96\x9B\xDB\x9A\xCC\x2F\xB4\x9A\x63\x00\x9C\x9B\xE1\x9A\x64\x16\x75\x00\xB4\x9A\x64\x00\xA1\x9B\xE6\x9A\x46\x32\xB4\x9A\x65\x00\xA7\x9B\xEB\x9A\x79\x2E\x79\x00\xB4\x9A\x66\x00\xAC\x9B\xF0\x9A\x64\x16\x7B\x00\xB4\x9A\x67\x00\xB2\x9B\xF6\x9A\x00\x34\xB4\x9A\x68\x00\xB8\x9B\xFC\x9A\x8E\x34\xB4\x9A\x69\x00\xB8\x9B\x48\x98\x81\x00\xB4\x9A\x6A\x00\xB8\x9B\x07\x9B\x10\x36\xB4\x9A\x6B\x00\xB8\x9B\x0C\x9B\xBE\x96\xB4\x9A\x6C\x00\xB8\x9B\x11\x9B\x3C\x15\x87\x00\xB4\x9A\x6D\x00\xB8\x9B\x16\x9B\x95\x97\xB4\x9A\x6E\x00\xB8\x9B\x1C\x9B\xB8\x15\x8B\x00\xB4\x9A\x6F\x00\x39\x9A\x09\x15\x18\x12\x38\x90\x6F\x9B\x3C\x15\xE3\x9B\x67\x0B\x3E\x90\xE6\x9B\xAA\x15\xE8\x9B\x61\x12\x68\x8A\xEB\x9B\x48\x15\xED\x9B",
			"\xF5\x0B\x48\x90\xF0\x9B\xB8\x15\xF2\x9B\x15\x0C\x4E\x90\xF5\x9B\xCF\x0F\xCA\x00\xB5\x91\xFB\x1E\x92\x00\xB4\x9A\x70\x00\xB7\x37\xDE\x01\xFC\x9B\xBC\x91\x20\x87\xB4\x9A\x7D\x00\x02\x9C\x81\x0A\xC3\x91\x30\x99\xB4\x9A\x8A\x00\xB7\x37\xBB\x01\x04\x9C\x27\x87\x2F\x4C\xB4\x9A\x98\x00\x0F\x9C\x0A\x9C\x2D\x87\x00\x37\x9A\x00\xB4\x9A\xA6\x00\x16\x9C\xE4\x9B\x1C\x8E\x26\x11\xB4\x9A\xB4\x00\x1D\x9C\x7E\x0A\xDE\x91\x3E\x33\xB4\x9A\xC2\x00\x09\x9C\x1E\x9C\x28\x8E\xF6\x24\xA0\x00\xB4\x9A\xCF\x00\x23\x9C\x7B\x0A\x0F\x91\x86\x1E\xB4\x9A\xDD\x00\x30\x9C\x6C\x0A\xF1\x91\x8D\x1E\xB4\x9A\xEB\x00\x36\x9C\x71\x0A\x1A\x91\xA2\x51\xB4\x9A\xF9\x00\x3C\x9C\x78\x0A\x72\x89\xA9\x18\xA8\x00\xB4\x9A\x07\x00\xA3\x38\x10\x9C\x7A\x89\x51\x1C\xB4\x9A\x15\x00\x49\x9C\x17\x9C\xB3\x61\xEB\x37\xB4\x9A\x23\x00\xA3\x38\xBD\x01\x11\x9C\x7C\x7B\xEA\x6D\xB4\x9A\x32\x00\x4F\x9C\x2A\x9C\x14\x92\xF6\x24\xFA\x4A\xE3\x16\x40\x00\xA3\x38\x03\x9C\xB8\x94\xAC\x21\xB2\x00\xDE\x9A\x55\x9C\x50\x9C\x9A\x89\xF6\x7D\x50\x9B\x5C\x9C\x24\x9C\x72\x8E\xCA\x38\xB6\x00",
			"\xC5\x9B\x6E\x9C\x31\x9C\x5A\x80\xFE\x12\xB8\x00\xB4\x9A\x78\x00\x69\x9C\x5D\x9C\x78\x86\x3B\x49\xB4\x9A\x87\x00\x74\x9C\x37\x9C\x5F\x91\x00\x37\xBC\x00\xB4\x9A\x95\x00\x81\x9C\x3D\x9C\x66\x91\xB8\x15\xBE\x00\xB4\x9A\xA3\x00\x7B\x9C\x6F\x9C\xB4\x84\xBE\x49\xB4\x9A\xB2\x00\x8F\x9C\x75\x9C\x98\x8E\x52\x4A\xB4\x9A\xC1\x00\x95\x9C\x82\x9C\xCC\x89\x84\x4B\xB4\x9A\xD0\x00\x9B\x9C\x89\x9C\x81\x91\xFE\x12\xC6\x00\xB4\x9A\xDF\x00\x88\x9C\x43\x9C\x66\x92\xEF\x17\xC8\x00\xB4\x9A\xED\x00\xA8\x9C\x57\x9C\x0B\x32\x19\x8B\xB4\x9A\xFB\x00\xAF\x9C\xFC\x10\x92\x81\x48\x15\x07\x4B\xE3\x16\x09\x00\x5C\x39\x31\x05\xB0\x9C\x22\x6D\x3F\x47\xB4\x9A\x17\x00\xBC\x9C\x52\x05\xBE\x9C\x72\x82\x19\x55\xB4\x9A\x25\x00\xC3\x9C\x53\x05\x30\x1B\xE9\x9B\xC8\x4A\xFA\x9B\x03\x0F\xCC\x9C\xEE\x9B\x03\x97\xCF\x9C\xAF\x24\xD6\x91\xF7\x2E\xD4\x9C\x09\x01\xD1\x9C\x11\x0C\x4E\x5F\xD8\x9C\xC2\x2A\xFC\x10\x29\x1B\x77\x38\x4C\x0C\xA7\x01\x05\x11\x3F\x1F\x4F\x13\x2C\x88\xE2\x9C\xCF\x3B\xDF\x9C\x3D\x9A\xE8\x9C\xC1\x1C\xEA\x9C\x33\x39\xEA\x0B\xE3\x9C\xCA\x4C",
			"\xFC\x10\x37\x1B\x56\x4D\xEA\x0B\xCC\x35\xD1\x00\xFC\x10\xD0\x00\x00\x60\xF6\x9C\xED\x8D\xFC\x10\xF8\x9C\x22\x50\xFC\x9C\xB1\x35\xFC\x10\xD2\x00\xB3\x2E\x21\x00\x01\x9D\x64\x16\xD4\x00\xFC\x10\xD3\x00\xF3\x8E\x07\x9D\xFE\x4C\xFC\x10\xCE\x00\xF7\x88\x0D\x9D\x5E\x4D\xFC\x10\x3E\x1B\x37\x69\x12\x9D\xE0\x19\xD7\x00\xFC\x10\xD6\x00\xFE\x88\x17\x9D\x10\x62\xFC\x10\xE5\x9C\xFB\x1E\x26\x00\x1D\x9D\x05\x11\xD9\x00\xFC\x10\xD8\x00\xB3\x2E\x27\x00\x23\x9D\x9F\x17\xFC\x10\xCC\x00\x0A\x89\x2A\x9D\x0A\x12\x80\x9B\x5F\x0A\x0F\x89\x2F\x9D\x44\x4F\x85\x9B\x95\x82\xEA\x0B\xDC\x53\x71\x97\xC7\x00\xB3\x2E\x2C\x00\x34\x9D\x26\x78\xFC\x10\x7E\x9B\xD0\x1A\x2D\x00\x3E\x9D\x48\x15\xDF\x00\xE3\x98\xE1\x20\x2E\x00\x38\x9D\xB1\x10\x6C\x99\x00\x00\xE8\x00\xB3\x2E\x30\x00\x44\x9D\xB8\x15\xE2\x00\x8A\x9B\xE0\x19\x31\x4B\xF3\x5E\xCA\x9C\xCB\x51\x91\x9B\x79\x2E\x33\x00\x4A\x9D\x61\x06\x58\x9D\x90\x0C\x97\x9B\x95\x2D\x5D\x9D\xB9\x0E\x5F\x9D\xE2\x51\x39\x96\x1E\x2B\x63\x9D\xE3\x0B\x65\x9D\xF1\x51\x3F\x96\xF6\x24\x39\x00\x69\x9D\x02\x01\x38\x00",
			"\x6B\x9D\xF9\x51\x04\x93\x29\x44\x70\x9D\x44\x14\x73\x9D\x14\x52\x0A\x93\x1A\x32\x77\x9D\x16\x2F\x79\x9D\x22\x52\x51\x96\x21\x32\x7D\x9D\x3B\x00\x7F\x9D\x29\x52\x16\x93\x65\x24\x7D\x9D\x3C\x00\x85\x9D\x53\x9D\x1B\x93\xAC\x21\x43\x00\x7D\x9D\x3D\x00\x8B\x9D\x2C\x8F\x55\x2B\x7D\x9D\x3E\x00\x92\x9D\x31\x8F\xB7\x30\x47\x00\x7D\x9D\x3F\x00\x97\x9D\x36\x8F\x03\x19\x49\x00\x7D\x9D\x40\x00\x9D\x9D\x3B\x8F\xB7\x30\x4B\x00\x7D\x9D\x41\x00\xA3\x9D\x40\x8F\x9D\x26\x4D\x00\x7D\x9D\x42\x00\xA9\x9D\x46\x8F\xD1\x6F\x7D\x9D\x43\x00\x85\x9D\xE3\x00\x54\x9D\xE1\x23\x7D\x9D\x44\x00\xB4\x9D\x5A\x9D\xB7\x50\x7D\x9D\x45\x00\xBA\x9D\x1F\x98\xBC\x4D\x7D\x9D\x46\x00\xBF\x9D\x25\x98\x79\x2E\x57\x00\x7D\x9D\x47\x00\xC4\x9D\x2A\x98\x96\x8F\x7D\x9D\x48\x00\xCA\x9D\x2F\x98\x22\x45\x7D\x9D\x49\x00\xCF\x9D\x34\x98\x03\x19\x46\x4B\xE3\x16\x4A\x00\xD4\x9D\x39\x98\x00\x37\x5F\x00\x7D\x9D\x4B\x00\xDA\x9D\x3E\x98\x0A\x12\x61\x00\x7D\x9D\x4C\x00\xDA\x9D\xBE\x9B\xB8\x15\x63\x00\x7D\x9D\x4D\x00\xDA\x9D\x48\x98\x65\x00\x7D\x9D\x4E\x00\xDA\x9D\xC8\x9B",
			"\x67\x00\x7D\x9D\x4F\x00\xDA\x9D\xCD\x9B\x69\x00\x7D\x9D\x50\x00\xDA\x9D\xD2\x9B\xAA\x15\x4D\x4B\xE3\x16\x51\x00\xDA\x9D\xD8\x9B\x93\x2C\x7D\x9D\x52\x00\xDA\x9D\xDD\x9B\xBD\x24\x7D\x9D\x53\x00\x85\x9D\xE4\x00\xFC\x10\xE0\x00\xB3\x2E\x71\x00\xEA\x0B\xFD\x3A\xE5\x00\xFC\x10\x0C\x9E\x71\x41\x51\x9D\xCF\x0F\x16\x15\x9A\x0C\xB3\x2E\x77\x00\x17\x9E\x03\x0F\x4F\x1B\xEB\x11\xB3\x2E\x78\x00\x1D\x9E\xA5\x0C\xFC\x10\x8C\x9D\xFB\x1E\x54\x4B\xFD\x99\x4E\x1F\xD4\x93\xFB\x1E\x7A\x00\x7D\x9D\x54\x00\x85\x9D\x2A\x9E\x32\x2B\xB3\x2E\x7C\x00\x7D\x9D\x55\x00\x30\x9E\x82\x98\xBD\x21\x7D\x9D\x56\x00\x37\x9E\x87\x98\x97\x35\x7D\x9D\x57\x00\x3C\x9E\x8D\x98\x15\x1E\x7D\x9D\x58\x00\x41\x9E\x92\x98\x61\x65\x7D\x9D\x59\x00\x46\x9E\x97\x98\xB3\x2E\x86\x00\x7D\x9D\x5A\x00\x4B\x9E\x9D\x98\xE3\x39\x7D\x9D\x5B\x00\x51\x9E\xA2\x98\xE9\x21\x7D\x9D\x5C\x00\x56\x9E\x36\x9B\x50\x4E\x7D\x9D\x5D\x00\x56\x9E\xAD\x98\xFE\x3F\x7D\x9D\x5E\x00\x56\x9E\x37\x99\x90\x6D\x7D\x9D\x5F\x00\x56\x9E\xB7\x98\x9D\x26\x92\x00\x7D\x9D\x60\x00\x56\x9E\xBD\x98\x02\x01",
			"\x94\x00\x7D\x9D\x61\x00\x56\x9E\xC2\x98\x65\x54\x7D\x9D\x62\x00\x56\x9E\xC8\x98\x5B\x35\x7D\x9D\x63\x00\x56\x9E\xCD\x98\xB2\x70\x7D\x9D\x64\x00\x56\x9E\xD3\x98\x5E\x7A\x7D\x9D\x65\x00\x56\x9E\xD9\x98\xAA\x3B\x7D\x9D\x66\x00\x56\x9E\x4C\x9D\xCD\x59\x7D\x9D\x67\x00\x85\x9D\xEB\x00\xFC\x10\xEA\x00\x99\x93\x23\x9E\xF2\x54\x96\x9E\xB3\x2E\xA3\x00\x99\x9E\xBF\x0C\x9B\x9E\x8D\x1E\x9E\x9E\xE2\x55\xA0\x9E\xD0\x67\xA2\x9E\x02\x01\x13\x11\xAE\x0C\x93\x54\xA6\x9E\x84\x56\xA4\x9E\x55\x3A\xAB\x9E\xF9\x0C\xAD\x9E\xAC\x21\xA8\x00\xAF\x9E\xF2\x00\xB1\x9E\x99\x45\xAF\x9E\x5D\x1B\xA9\x9E\xD0\x1A\xAA\x00\xAF\x9E\x2A\x11\xBA\x9E\x15\x28\xAF\x9E\x3F\x11\xBF\x9E\xEC\x70\xAF\x9E\xF6\x00\xB6\x9E\x9D\x26\xAD\x00\xAF\x9E\x55\x1F\x03\x01\x97\x9E\xB4\x1E\xAF\x9E\xF8\x00\x47\x9B\xAD\x32\xAF\x00\x7D\x9D\x68\x00\x85\x9D\xD0\x9E\x2B\x9E\x1C\x28\x7D\x9D\x69\x00\xCA\x9C\x88\x13\xD7\x9E\x32\x9E\x3D\x74\x7D\x9D\x6B\x00\xDC\x9E\x4C\x0E\x38\x9E\xAC\x21\xB5\x00\x7D\x9D\x6D\x00\xE3\x9E\x4A\x0E\x65\x9C\xCA\x45\x7D\x9D\x6F\x00\xEA\x9E\x64\x31\xA6\x96",
			"\x66\x42\x7D\x9D\x71\x00\xF0\x9E\x58\x88\xAC\x96\xE1\x20\xBB\x00\x7D\x9D\x73\x00\xF6\x9E\x32\x59\xB2\x96\xE1\x20\xBD\x00\x7D\x9D\x75\x00\xFD\x9E\x73\x57\x20\x9A\xE1\x20\xBF\x00\x7D\x9D\x77\x00\x04\x9F\x00\x00\xDE\x9E\x5C\x19\xB3\x2E\xC1\x00\x7D\x9D\x79\x00\x0B\x9F\x0D\x9F\xDE\x94\xFB\x1E\xC3\x00\x7D\x9D\x7B\x00\x13\x9F\x2F\x99\x91\x25\x7D\x9D\x7D\x00\x1A\x9F\xD1\x96\xFB\x45\x7D\x9D\x7F\x00\x1F\x9F\xD6\x96\x83\x30\x7D\x9D\x81\x00\x24\x9F\xDC\x96\x17\x1F\x7D\x9D\x83\x00\x29\x9F\x49\x99\xA9\x42\x7D\x9D\x85\x00\x2E\x9F\xE7\x96\xD2\x22\x7D\x9D\x87\x00\x33\x9F\xEC\x96\x1E\x46\x7D\x9D\x89\x00\x38\x9F\x86\x9E\xA1\x1A\xD3\x00\x7D\x9D\x8B\x00\x38\x9F\x8B\x9E\xEA\x22\x7D\x9D\x8D\x00\x38\x9F\x90\x9E\x00\x8E\x7D\x9D\x8F\x00\x0B\x9F\x1B\x15\xDC\x99\x42\x52\x7D\x9D\x91\x00\x85\x9D\x4E\x9F\xA4\x94\x52\x1F\x7D\x9D\x92\x00\x4D\x9F\xFA\x98\x5C\x6E\x7D\x9D\x94\x00\x59\x9F\xFF\x98\x9D\x26\xDF\x00\x7D\x9D\x96\x00\x5E\x9F\x05\x99\x7D\x19\xE1\x00\x7D\x9D\x98\x00\x64\x9F\x0A\x99\x1E\x23\x7D\x9D\x9A\x00\x6A\x9F\x0F\x99\xFB\x42\x7D\x9D",
			"\x9C\x00\x6F\x9F\x35\x97\x50\x28\x7D\x9D\x9E\x00\x74\x9F\x3A\x97\x80\x6E\x7D\x9D\xA0\x00\x79\x9F\x3F\x97\xEF\x16\xEB\x00\x7D\x9D\xA2\x00\x79\x9F\x5C\x9E\x15\x43\x7D\x9D\xA4\x00\x79\x9F\x61\x9E\x0B\x31\x7D\x9D\xA6\x00\x79\x9F\x66\x9E\xF4\x35\x7D\x9D\xA8\x00\x79\x9F\x6B\x9E\xFC\x35\x7D\x9D\xAA\x00\x79\x9F\x71\x9E\x01\x01\xF5\x00\x7D\x9D\xAC\x00\x79\x9F\x77\x9E\x53\x58\x7D\x9D\xAE\x00\x79\x9F\x7C\x9E\xEF\x16\xF9\x00\x7D\x9D\xB0\x00\x79\x9F\x81\x9E\x56\x59\x7D\x9D\xB2\x00\x79\x9F\x3E\x9F\xBE\x6E\x7D\x9D\xB4\x00\x79\x9F\x44\x9F\xCC\x21\xFF\x00\x7D\x9D\xB6\x00\x79\x9F\x49\x9F\xA1\x1A\x01\x00\x1C\x20\x88\x13\xB8\x00\x0B\x9F\xFB\x00\xFC\x10\xF9\x00\x91\x97\xBD\x9F\xB1\x10\xFC\x00\xFC\x10\xFE\x00\xB2\x94\xC5\x9F\x74\x47\x04\x11\xB3\x2E\x07\x00\xCB\x9F\x64\x16\xC9\x9F\xBA\x5C\xD9\x8B\xD0\x9F\x56\x17\xFC\x10\x6C\x1B\xAD\x23\x1C\x20\x97\x60\x04\x5D\x01\x01\xD2\x9F\xB6\x28\xD5\x9F\x02\x01\xBA\x00\x85\x9D\xDC\x9F\x6C\x10\xB6\x88\xE0\x9F\x01\x01\xBB\x00\x85\x9D\x02\x00\xE8\x1B\x6E\x15\x3D\x17\x12\x00\x1C\x20\x6A\x49\xEB\x9F",
			"\x9A\x28\x93\x9A\xE7\x9F\x00\x00\xBC\x00\xEA\x9F\x25\x15\xB3\x2E\x18\x00\xF5\x9F\xBD\x00\x85\x9D\x03\x00\xEC\x9F\x11\x50\xF0\x9F\xF6\x15\xEC\x10\xDE\x9F\xE1\x20\x1E\x00\xF5\x9F\xBE\x00\xFE\x9F\xF9\x9F\x22\x50\xF5\x9F\xBF\x00\x85\x9D\x04\x00\x71\x1B\xED\x9F\x04\x67\xF5\x9F\x8D\x15\x04\xA0\xB3\x2E\x24\x00\xF5\x9F\xC0\x00\x0B\x9F\x5C\x1F\xD1\x0E\x04\x89\xF5\x9F\xC2\x00\x0B\x9F\x3A\x15\xBB\x13\x12\xA0\x2A\x67\x1C\x20\xCC\x5D\xEC\x10\x0A\x00\x24\xA0\x7D\x19\x29\x00\x26\xA0\xD1\x5D\x16\xA0\x95\x82\xF5\x9F\xC4\x00\x0B\x9F\x08\x00\x0B\xA0\xFB\x1E\x2C\x00\xF5\x9F\xC6\x00\x0B\x9F\x78\x1B\x23\xA0\x23\x79\x2D\xA0\xD7\x5D\x28\xA0\x2A\xA0\x05\x11\x2F\x00\x3E\xA0\xDC\x5D\x92\x1B\x41\xA0\xB6\x11\x30\x00\x02\xA0\xF6\x17\xEC\x10\x11\x00\x47\xA0\x0A\x12\x34\x00\x14\xA0\xD9\x17\xEC\x10\x16\x00\x4E\xA0\x3C\x15\x36\x00\x51\xA0\x0A\x12\x0D\x00\xEC\x10\x0C\x00\x55\xA0\xAA\x15\x38\x00\x1C\x20\x64\x9A\xDD\x01\x5B\xA0\xB3\x2E\x3F\x00\xF5\x9F\xC8\x00\x0B\x9F\x5A\xA0\xD8\x9E\x77\x53\xF5\x9F\xCA\x00\xCA\x9C\xF6\x10\x69\xA0\xDF\x9E\x6A\x24",
			"\xF5\x9F\xCD\x00\x6E\xA0\x23\x01\xEC\x10\x34\x8A\x70\x24\xF5\x9F\xD0\x00\x75\xA0\x3D\x01\xEC\x10\x3B\x8A\xCA\x38\x47\x00\xF5\x9F\xD3\x00\x7C\xA0\x57\x01\xEC\x10\x87\x8D\xF6\x24\x15\x4C\x9C\x33\x84\xA0\x9D\x01\xEC\x10\xC5\x93\x6D\x8F\xF5\x9F\xD9\x00\x8B\xA0\xB8\x01\xEC\x10\x98\x98\x99\x92\xF5\x9F\xDC\x00\x92\xA0\x62\xA0\x8A\x41\xB3\x2E\x4F\x00\xF5\x9F\xDF\x00\x99\xA0\x0E\x02\xEC\x10\x7F\x9F\x03\x19\x51\x00\xF5\x9F\xE2\x00\xA0\xA0\x70\xA0\x50\x08\x3D\x9B\xF5\x9F\xE5\x00\xA8\xA0\xEC\x10\x8A\x9F\x5E\x3B\xF5\x9F\xE8\x00\xAE\xA0\x20\x9F\xAC\x21\x1C\x4C\xE3\x16\xEB\x00\xB4\xA0\x25\x9F\xF6\x24\x59\x00\xF5\x9F\xEE\x00\xBA\xA0\x2A\x9F\x03\x19\x5B\x00\xF5\x9F\xF1\x00\xC0\xA0\x2F\x9F\xD5\x50\xF5\x9F\xF4\x00\xC6\xA0\x34\x9F\xAC\x21\x5F\x00\xF5\x9F\xF7\x00\xCB\xA0\x39\x9F\xE2\x3C\xF5\x9F\xFA\x00\xD1\xA0\xAF\x9F\x79\x2E\x63\x00\xF5\x9F\xFD\x00\xD1\xA0\x1C\xA0\xB1\x24\xF5\x9F\x00\x00\x80\x39\x7E\x18\xEC\x10\xB4\x9F\x79\x2E\x67\x00\xF5\x9F\x01\x00\x80\x39\x6F\xA0\xEC\x10\xBA\x9F\xCC\x21\x69\x00\xF5\x9F\x04\x00\xE9\xA0\x58\x15",
			"\x55\x01\x5D\xA0\x57\x2C\x60\xA0\x8E\x5F\x63\xA0\xE3\x1D\xF5\x9F\x07\x00\x80\x39\x88\x13\x0E\x00\xEC\x10\x15\x97\x3C\x6A\xF5\x9F\x09\x00\xF1\xA0\x25\x01\xEC\x10\xA9\x92\x49\x32\xF5\x9F\x0C\x00\x04\xA1\x3F\x01\x77\xA0\x21\x9E\xF5\x9F\x0F\x00\x0B\xA1\x59\x01\x7E\xA0\x17\x8A\xF5\x9F\x12\x00\x11\xA1\x9F\x01\x86\xA0\x33\x9E\xF5\x9F\x15\x00\x17\xA1\xBA\x01\x8D\xA0\xB3\x2E\x7E\x00\xF5\x9F\x18\x00\x1D\xA1\x04\x01\x94\xA0\x1F\x8D\xF5\x9F\x1B\x00\x24\xA1\xFE\xA0\x9B\xA0\x15\x1E\xF5\x9F\x1E\x00\x2A\xA1\xA2\xA0\xB3\x2E\x84\x00\xF5\x9F\x21\x00\x30\xA1\x28\x99\x68\x65\xF5\x9F\x24\x00\x36\xA1\xFD\x27\xB3\x2E\x88\x00\xF5\x9F\x27\x00\x3B\xA1\xAB\x4F\x25\x90\xF5\x9F\x2A\x00\x41\xA1\x02\x01\x94\x9F\x03\x19\x8C\x00\xF5\x9F\x2D\x00\x46\xA1\xDD\x72\x01\x33\xF5\x9F\x30\x00\x4D\xA1\xE5\x5D\x48\x90\xF5\x9F\x33\x00\x52\xA1\xA4\x9F\xD5\x73\xF5\x9F\x36\x00\x52\xA1\xAA\x9F\x3D\x17\x94\x00\xF5\x9F\x39\x00\x52\xA1\xD7\xA0\xAD\x32\x96\x00\xF5\x9F\x3C\x00\x52\xA1\xDD\xA0\x7D\x63\xF5\x9F\x3F\x00\xE1\xA0\xF2\xA0\x5F\x99\xB6\x59\xF5\x9F\x40\x00",
			"\x52\xA1\xEC\xA0\xF5\x73\xF5\x9F\x43\x00\x24\xA1\x46\x15\x3B\x01\xF4\xA0\xB8\x15\x3F\x4C\xD4\x46\x7D\x1B\x4F\x9F\xA1\x1A\xA5\x00\xF5\x9F\x46\x00\xFC\xA0\x85\x01\xFF\xA0\x6A\x8D\xF5\x9F\x48\x00\x78\xA1\x06\xA1\xB3\x2E\xA9\x00\xF5\x9F\x4B\x00\x8B\xA1\x5F\x9F\xEF\x16\xAB\x00\xF5\x9F\x4E\x00\x91\xA1\x65\x9F\x05\x11\xAD\x00\xF5\x9F\x51\x00\x97\xA1\x6B\x9F\x3E\x42\xF5\x9F\x54\x00\x9D\xA1\x70\x9F\x45\x42\xF5\x9F\x57\x00\xA2\xA1\x75\x9F\x4C\x42\xF5\x9F\x5A\x00\xA7\xA1\x7A\x9F\xC3\x45\xF5\x9F\x5D\x00\xAC\xA1\xA3\xA0\x84\x57\xF5\x9F\x60\x00\xAC\xA1\x85\x9F\xAD\x32\xB9\x00\xF5\x9F\x63\x00\xAC\xA1\xB0\xA0\x03\x19\x4D\x4C\x23\x4C\xAC\xA1\x8F\x9F\x9A\x3A\xF5\x9F\x69\x00\xAC\xA1\x48\xA1\x22\x68\xF5\x9F\x6C\x00\xAC\xA1\x99\x9F\x5E\x9B\xF5\x9F\x6F\x00\xAC\xA1\x9F\x9F\x03\x19\xC3\x00\xF5\x9F\x72\x00\xAC\xA1\x58\xA1\xA1\x1A\xC5\x00\xF5\x9F\x75\x00\xAC\xA1\x5D\xA1\xEF\x17\xC7\x00\xF5\x9F\x78\x00\xAC\xA1\x63\xA1\xA8\x84\xF5\x9F\x7B\x00\xAC\xA1\xE4\xA0\xAD\x32\xCB\x00\xF5\x9F\x7E\x00\xAC\xA1\x74\xA1\xAD\x32\xCD\x00\xF5\x9F\x81\x00",
			"\x24\xA1\x10\x00\xEC\x10\xA9\xA0\xAC\x21\xCF\x00\x44\xA0\x3D\x17\x4D\xA0\x29\x01\x7B\xA1\xCF\x0F\xD0\x00\xF9\xA1\xEF\x17\x12\x00\x5B\xA0\xFD\xA1\x03\x0F\xD1\x00\xF6\xA0\xBB\x19\xF8\xA0\x03\x2F\xF5\x9F\x84\x00\x85\xA1\x2D\x01\x87\xA1\xC5\x5C\xF5\x9F\x86\x00\x24\xA1\x02\xA2\x52\x2B\x11\x2F\xF5\x9F\x89\x00\x13\xA2\x0D\xA1\x5B\x7E\xF5\x9F\x8C\x00\x19\xA2\x3D\x9E\x7D\x19\xE0\x00\xF5\x9F\x8F\x00\x1E\xA2\x42\x9E\xA5\x38\xF5\x9F\x92\x00\x24\xA2\x47\x9E\x75\x2C\xF5\x9F\x95\x00\x29\xA2\x4C\x9E\x20\x88\xF5\x9F\x98\x00\x2E\xA2\x52\x9E\x83\x2C\xF5\x9F\x9B\x00\x33\xA2\x57\x9E\x7A\x7E\xF5\x9F\x9E\x00\x38\xA2\xB7\xA1\xCB\x81\xF5\x9F\xA1\x00\x38\xA2\xBD\xA1\xA1\x1A\xEE\x00\xF5\x9F\xA4\x00\x38\xA2\xC2\xA1\xC1\x5A\xF5\x9F\xA7\x00\x38\xA2\xC7\xA1\x1F\x34\xF5\x9F\xAA\x00\x38\xA2\xCC\xA1\xF4\x00\xF5\x9F\xAD\x00\x38\xA2\xD1\xA1\x24\x34\xF5\x9F\xB0\x00\x38\xA2\xD7\xA1\x43\x4B\xF5\x9F\xB3\x00\x38\xA2\xDD\xA1\xA4\x49\xF5\x9F\xB6\x00\x38\xA2\xE3\xA1\x00\x37\xFC\x00\xF5\x9F\xB9\x00\x38\xA2\x69\xA1\x07\x82\xF5\x9F\xBC\x00\x6D\xA1\x0E\xA2",
			"\xA8\x2F\xD0\x1A\x16\x2F\x57\x48\x38\xA2\xEE\xA1\xB7\x30\x02\x00\x95\x12\xC0\x00\x24\xA1\x13\x00\x03\xA2\x91\x28\xE4\x0F\x61\xA0\xA8\x01\x09\xA2\xD3\x2A\x95\x12\xC3\x00\x0D\xA2\x6D\x15\x6A\xA0\xF6\x24\x0D\x00\x95\x12\xC5\x00\x7D\xA2\x8C\xA1\x0D\x20\x95\x12\xC8\x00\x8F\xA2\x92\xA1\x9F\x43\x95\x12\xCB\x00\x94\xA2\x98\xA1\xC1\x19\x95\x12\xCE\x00\x99\xA2\x9E\xA1\x9D\x26\x15\x00\x95\x12\xD1\x00\x9E\xA2\xA3\xA1\x12\x6F\x95\x12\xD4\x00\xA4\xA2\xA8\xA1\xE9\x55\x95\x12\xD7\x00\xA9\xA2\xAD\xA1\xEF\x16\x1B\x00\x95\x12\xDA\x00\xAE\xA2\xB2\xA1\xCC\x21\x1D\x00\x95\x12\xDD\x00\xAE\xA2\x3E\xA2\x8D\x58\x95\x12\xE0\x00\xAE\xA2\x43\xA2\x23\x8C\x95\x12\xE3\x00\xAE\xA2\x49\xA2\xB2\x9A\x95\x12\xE6\x00\xAE\xA2\x4E\xA2\x79\x2E\x25\x00\x95\x12\xE9\x00\xAE\xA2\xCC\xA1\x27\x00\x95\x12\xEC\x00\xAE\xA2\x58\xA2\x2D\x53\x95\x12\xEF\x00\xAE\xA2\x5D\xA2\x79\x2E\x2B\x00\x95\x12\xF2\x00\xAE\xA2\x62\xA2\x7D\x19\x2D\x00\x95\x12\xF5\x00\xAE\xA2\x67\xA2\xCA\x38\x83\x4C\xE3\x16\xF8\x00\xAE\xA2\x6D\xA2\xF6\x24\x31\x00\x95\x12\xFB\x00\x71\xA2\x89\xA2",
			"\x1F\x8B\x7F\x26\x95\x12\xFC\x00\xAE\xA2\x78\xA2\x00\x37\x35\x00\x95\x12\xFF\x00\x24\xA1\x64\x1F\xF3\xA0\x40\x24\x81\xA2\x9D\x60\x84\xA2\x01\x45\x95\x12\x02\x00\xDC\x39\xE9\x54\x65\x01\x0F\xA2\x87\x39\x95\x12\x04\x00\x07\xA3\xE4\x9F\xAA\x01\x90\xA2\x10\x76\x95\x12\x07\x00\x0E\xA3\xF6\x10\xFE\xA2\x30\x2F\xB3\x2E\x44\x00\x95\x12\x0A\x00\x15\xA3\x13\x01\x13\xA1\x3D\x44\x95\x12\x0D\x00\x1D\xA3\x31\x01\x19\xA1\x7C\x5B\x95\x12\x10\x00\x23\xA3\x4B\x01\x1F\xA1\x0B\x3F\x95\x12\x13\x00\x29\xA3\x09\xA3\xA3\x18\xB3\x2E\x4C\x00\xE9\x12\x2F\xA3\x7A\x01\xEC\x10\x29\x9A\xE1\x20\x4E\x00\x95\x12\x19\x00\x35\xA3\x8F\x01\x31\xA1\xA2\x29\x95\x12\x1C\x00\x3D\xA3\x10\xA3\x37\xA1\x1E\x63\x95\x12\x1F\x00\x43\xA3\x17\xA3\xDE\x1E\xB1\x92\x95\x12\x22\x00\x49\xA3\xEC\x10\xC5\xA2\xD3\x6C\x95\x12\x25\x00\x4F\xA3\x09\x01\xCA\xA2\xB3\x5B\x95\x12\x28\x00\x55\xA3\x44\x92\x0D\x4A\x95\x12\x2B\x00\x5B\xA3\xD9\x52\xB3\x2E\x5C\x00\x95\x12\x2E\x00\x60\xA3\x47\x43\x67\x9B\x95\x12\x31\x00\x66\xA3\x6C\x50\xAB\x24\x95\x12\x34\x00\x6B\xA3\x54\x0C\x6D\x9B",
			"\x95\x12\x37\x00\x70\xA3\xE8\xA1\xB7\x30\x64\x00\x95\x12\x3A\x00\x70\xA3\xF8\xA2\xCA\x38\x66\x00\x95\x12\x3D\x00\x43\xA3\x15\x00\xEC\x10\x14\xA2\xFB\x1E\xE0\x4D\xFD\x99\x54\xA0\xD1\x01\x04\xA2\x2B\x2B\x43\x10\x05\x11\x17\x00\x73\x5B\xD4\x0F\xBF\x15\xE1\x0F\x92\xA3\x93\xA3\x94\xA3\x95\xA3\x96\xA3\x97\xA3\x98\xA3\x99\xA3\x9A\xA3\x9B\xA3\x9C\xA3\x9D\xA3\x9E\xA3\x9F\xA3\xA0\xA3\xA1\xA3\xBE\x0F\xAD\x0F\xE9\x15\xA4\xA3\x7A\x5B\xF5\x71\xE2\x54\xD8\x0E\x88\x13\x9C\x88\xE3\x16\x0F\xA3\x0F\xA3\xE6\x1C\x41\x11\x0D\x16\x46\x57\x8A\x4D\xAE\xA3\x73\x5B\xB6\xA3\xB1\xA3\x2D\x11\xD7\x11\xB5\xA3\xB8\xA3\xB3\xA3\xB2\xA3\x4E\x57\xBA\xA3\x65\x17\x00\x00\xC6\x17\xC1\xA3\xC4\xA3\x03\x0F\xC5\xA3\x39\x15\xC6\xA3\xC9\xA3\xC8\xA3\xCB\xA3\x7E\xA1\xCC\xA3\x44\x17\xCA\xA3\xCD\xA3\xD1\xA3\xCF\xA3\xCE\xA3\x6F\x17\xD4\xA3\xE2\x64\xD2\xA3\xD5\xA3\xD8\xA3\xD7\xA3\xD3\xA3\xDA\xA3\xB6\x63\xD9\xA3\xDC\xA3\xE0\xA3\xDF\xA3\xE2\xA3\xDB\xA3\xE3\xA3\xDE\xA3\xE4\xA3\xE7\xA3\xE6\xA3\xE9\xA3\xC2\xA3\xD0\xA3\xE1\xA3\xE8\xA3\xEB\xA3\xD6\xA3\xEA\xA3\xC7\xA3",
			"\xDD\xA3\xEF\xA3\xF3\xA3\xF2\xA3\xED\xA3\xF1\xA3\xEC\xA3\xE5\xA3\xF4\xA3\xF7\xA3\xFB\xA3\xFA\xA3\xF6\xA3\xFE\xA3\xF9\xA3\xEE\xA3\xFF\xA3\x02\xA4\x01\xA4\xF8\xA3\xF0\xA3\xFD\xA3\x04\xA4\x07\xA4\x03\xA4\x06\xA4\xF5\xA3\x05\xA4\x08\xA4\x0C\xA4\xFC\xA3\x0B\xA4\x0F\xA4\x13\xA4\x12\xA4\x15\xA4\x0E\xA4\x16\xA4\x0A\xA4\x17\xA4\x1A\xA4\x19\xA4\x1C\xA4\x0D\xA4\x1D\xA4\x11\xA4\x1B\xA4\x1E\xA4\x22\xA4\x20\xA4\x1F\xA4\x00\xA4\x25\xA4\x09\xA4\xC3\x49\x39\x6A\xE9\x10\xC2\x17\x2A\xA4\x12\x6B\xA5\x13\x03\x0F\x2C\xA4\x31\xA4\x30\xA4\x33\xA4\x2F\xA4\x35\xA4\x29\xA4\x07\x02\xCD\x08\xFF\x00\x38\xA4\x3B\xA4\x03\x0F\x38\xA4\x09\x02\x16\x06\xFF\x00\x3F\xA4\x42\xA4\x03\x0F\x43\xA4\x9A\x02\x16\x06\x47\xA4\x45\xA4\xC8\x03\x4C\x17\x0B\x02\xF4\x05\x4D\xA4\x4C\xA4\x4F\xA4\xD1\x17\x51\xA4\x50\x03\x4E\xA4\x52\xA4\x4A\xA4\x0D\x02\xD8\x18\x57\xA4\x59\xA4\x03\x0F\x5A\xA4\x9C\x02\xF5\x05\xF6\x05\xF6\x05\xFF\x00\xDE\x01\x5F\xA4\x62\xA4\x64\xA4\x03\x0F\x65\xA4\x52\x03\x63\xA4\x66\xA4\x6A\xA4\x68\xA4\x67\xA4\xCA\x03\x69\xA4\x68\xA4\xBB\x01\x49\x05",
			"\x28\x36\x12\x89\x74\xA4\x8C\x03\x53\x05\x53\x05\xFF\x00\xBD\x01\x77\xA4\x7A\xA4\x7A\xA4\xBF\x01\xD5\x0F\x7E\xA4\x80\xA4\x03\x0F\x7E\xA4\xA5\x01\x34\x05\xFF\x00\x84\xA4\x87\xA4\x03\x0F\x84\xA4\xA7\x01\x35\x05\x35\x05\xFF\x00\x8B\xA4\x8F\xA4\x03\x0F\x90\xA4\x9D\x03\x36\x05\xEE\x1D\xA9\x01\x94\xA4\x96\xA4\xAB\x01\xB4\x16\x99\xA4\x03\x02\x06\x47\x9C\xA4\x9E\xA4\x03\x0F\x9C\xA4\x76\x15\x8B\x15\xA2\xA4\x8A\x15\xA5\xA4\x5E\x1C\x68\x13\x74\x19\x9A\x18\xD1\x0E\xA5\x05\x35\x93\x9D\x2F\xDF\x28\xC8\x0E\xCE\x1A\xCC\x62\xAF\xA4\x8E\x62\xB3\xA4\xF2\x1A\xB5\xA4\xAE\xA4\xB4\xA4\xB9\xA4\xB6\xA4\xBA\xA4\x5A\x63\x34\x8B\xC8\x0E\x6D\x31\x0E\x64\xBE\xA4\xDD\x0F\xC2\xA4\x53\x63\xC4\xA4\xBD\xA4\xC3\xA4\xC8\xA4\xC5\xA4\xC9\xA4\xC7\xA4\xCA\xA4\xCD\xA4\xCC\xA4\xCF\xA4\x7A\x63\xC6\xA4\x03\x01\xE5\x18\x5F\x4B\xD1\x0E\xD4\xA4\xD7\xA4\x1B\x1B\x20\x1B\x8D\x9D\xD6\x1D\xDA\xA4\x5B\x96\xDB\xA4\x5F\x94\x03\x36\xD1\x0E\x41\x19\xE1\xA4\x79\x8B\xF8\x8E\x4B\x93\x60\x1B\x77\x8B\x29\x7F\xEA\xA4\xE9\x53\xF6\x46\xEB\xA4\xF2\x92\xE9\xA4\xEC\xA4\xF0\xA4",
			"\xEF\xA4\x7C\x19\x02\x17\xC8\x0E\xF4\xA4\xCA\x1B\xB9\x55\xC8\x0E\xF8\xA4\xFB\xA4\x03\x0F\xFC\xA4\x46\x13\xFD\xA4\x00\xA5\xFF\xA4\x32\x66\x03\x0F\x1F\x37\x6C\x10\x05\xA5\x66\x66\x04\xA5\x09\xA5\x03\xA5\x0B\xA5\xC8\x13\x0A\xA5\x0D\xA5\x0C\xA5\x49\x66\x0E\xA5\x11\xA5\x10\xA5\x18\x66\x12\xA5\x15\xA5\x14\xA5\x58\x12\xEA\x1B\xD1\x0E\xFD\x1B\xEF\x5A\x39\x18\x1A\xA5\x58\x20\x1F\xA5\xCD\x13\x21\xA5\xE3\x1B\x23\xA5\x19\xA5\x1E\xA5\x27\xA5\x20\xA5\x28\xA5\x22\xA5\x2A\xA5\x24\xA5\x2C\xA5\x26\xA5\x29\xA5\x30\xA5\x2B\xA5\x31\xA5\x2D\xA5\x33\xA5\x2F\xA5\x32\xA5\x37\xA5\x34\xA5\x38\xA5\x36\xA5\x39\xA5\x3C\xA5\x3B\xA5\x3E\xA5\x01\x01\x1C\xA5\x1C\xA5\x30\x1C\x08\x5D\xC8\x0E\x43\xA5\x46\xA5\x3B\x1C\x48\xA5\x0C\x01\x47\xA5\x41\x1C\x4C\xA5\xD8\x0E\x54\x1D\x01\x01\x4F\xA5\x00\x00\x51\xA5\x53\xA5\x03\x0F\x54\xA5\x4D\xA5\x57\x18\x03\x0F\xF7\x38\x6C\x10\x5A\xA5\x00\x00\x5C\xA5\x5E\xA5\x59\xA5\x03\x0F\xB9\x1C\x00\x00\xB9\x1C\xFF\x00\x62\xA5\x66\xA5\x61\xA5\x68\xA5\xE6\x13\x69\xA5\x63\x8D\x03\x0F\x5B\x1D\x08\x1D\x42\x62\x6D\xA5\x71\xA5",
			"\xBA\x64\xF3\x17\x74\xA5\xD1\x0E\x27\x1D\x89\x13\x75\xA5\x3A\x1D\x03\x0F\xD3\x17\x61\x1B\xC8\x0E\x7C\xA5\x7C\xA5\x10\x0B\x28\x1D\xE0\x0E\x81\xA5\x84\xA5\x03\x0F\x85\xA5\x3E\x1A\x82\xA5\x3B\x16\x88\xA5\x87\xA5\x46\x1B\x8D\xA5\x06\x01\x8C\xA5\x8F\xA5\x86\xA5\x92\xA5\x8B\xA5\x93\xA5\x8E\xA5\x88\x06\x03\x0F\x79\x16\x5D\x0C\xA9\x7B\x98\xA5\x9C\xA5\x03\x1D\x97\xA5\x9E\xA5\xA6\x0B\x03\x0F\xF3\x0E\xFE\x0A\x09\x1D\x80\x1B\xD0\x0A\xA2\xA5\xA8\xA5\xA6\xA5\xAE\x32\x03\x0F\x91\x1D\xDE\x0D\xAB\xA5\x5A\x69\xAC\xA5\xB1\xA5\xB0\xA5\xB3\xA5\x63\x69\xB2\xA5\xB5\xA5\xB4\xA5\x20\x0E\xEE\x0F\xC8\x0E\xA2\x0E\xDF\x0D\xAF\x18\x2E\x49\xD8\x0E\x15\x0F\xC1\xA5\x03\x0F\xC2\xA5\xBE\xA5\x02\x0E\x33\x8D\xC8\x0E\xC6\xA5\xC9\xA5\x03\x0F\xCA\xA5\xB0\x0E\xCD\xA5\xDD\x1F\xCE\xA5\x56\x0F\xD0\xA5\x59\x0F\x69\x0F\xD1\x0E\x45\x0B\x9F\x91\x9B\x0F\x03\x0F\xEE\x0E\x34\x0E\x86\x97\x7D\x0C\xDD\xA5\xD8\xA5\xDE\xA5\xB9\x0E\xD9\xA5\xE2\xA5\xE0\xA5\x03\x01\xDB\xA5\xE6\xA5\xE3\xA5\xDF\xA5\xE9\xA5\xE1\xA5\xE4\xA5\xDC\x1F\xEA\xA5\xE5\xA5\xE8\xA5\xEB\xA5\xEE\xA5",
			"\xED\xA5\xF1\xA5\xB0\x5D\x8D\x4B\xC8\x0E\xFB\x0E\x78\x10\x75\xA2\xD1\x0E\xF9\xA5\xFC\xA5\xD5\x62\xFE\xA5\x93\x1F\x03\x0F\xE4\x1F\xE1\x14\x19\x13\x01\xA6\x05\xA6\x00\xA6\x07\xA6\x63\x23\x06\xA6\xF4\x20\xA0\x47\xC8\x0E\x12\x21\x54\x14\x0C\xA6\x0C\x01\x0E\xA6\x12\xA6\x10\xA6\x0B\xA6\x11\xA6\x14\xA6\x06\x01\x13\xA6\x3C\x6D\x18\x16\xC8\x0E\xC7\x23\x4F\x21\x1B\xA6\x1A\xA6\x20\xA6\xFB\x6D\x03\x0F\xF0\x54\x6C\x10\x24\xA6\xC2\x2E\x23\xA6\x28\xA6\x0C\x01\x26\xA6\x74\x23\x43\x6E\xC8\x0E\x2C\xA6\x2F\xA6\x03\x0F\x30\xA6\x63\x4C\x2D\xA6\x33\xA6\x32\xA6\x23\x42\x34\xA6\x37\xA6\x36\xA6\xD6\x52\x38\xA6\x3B\xA6\x3A\xA6\x76\x56\x3C\xA6\x3F\xA6\x3E\xA6\x35\x8E\x33\x1A\xC8\x0E\x03\x5D\xDD\x6E\x44\xA6\x05\x8E\x48\xA6\x39\x21\x4A\xA6\xF6\x8D\x03\x0F\xAD\x5E\xD9\x20\xC8\x0E\x4F\xA6\xC1\x28\x4E\xA6\x54\xA6\x56\x21\x55\xA6\xE5\x10\x57\xA6\xDF\x6E\x59\xA6\x03\x01\x52\xA6\x5D\xA6\x03\x0F\x4E\x21\x4D\x21\xC8\x0E\x60\xA6\xFD\x6E\x03\x0F\x4D\x61\xE2\x6F\xC8\x0E\x66\xA6\xE2\x20\x03\x0F\x7D\x21\xC2\x21\xD1\x0E\x6C\xA6\x6C\xA6\xBC\x63\xA3\x9A",
			"\xC8\x0E\x71\xA6\xAC\x63\x03\x0F\x74\xA6\x77\xA6\x03\x0F\x02\x29\x9C\x84\xE9\x10\x7A\xA6\x7D\xA6\x79\xA6\x7F\xA6\xAA\x3D\x7B\xA6\x38\x5F\x80\xA6\x02\x42\xB3\x0F",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}

	const wchar_t* ParserRuleName(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"_Type",
			L"_CtorFragment",
			L"_LetVariable",
			L"_VirtualExpression",
			L"_BeginBoundary",
			L"_EndBoundary",
			L"_SetTestingOperator",
			L"_ExpPrimitive",
			L"_Exp0",
			L"_Exp1",
			L"_Exp2",
			L"_Exp3",
			L"_Exp4",
			L"_Exp5",
			L"_Exp6",
			L"_Exp7",
			L"_Exp8",
			L"_Exp9",
			L"_Exp10",
			L"_Exp11",
			L"_Expression",
			L"_SwitchCase",
			L"_Block",
			L"_ElseStat",
			L"_If",
			L"_ForOperator",
			L"_VirtualStatement",
			L"_CoStatement",
			L"_CoProvider",
			L"_StateSwitchHead",
			L"_StateSwitchArgument",
			L"_StateSwitchCase",
			L"_StateStatement",
			L"_Statement",
			L"_StateInput",
			L"_StateDecl",
			L"_StateMachine",
			L"_Attribute",
			L"_Namespace",
			L"_FunctionArgument",
			L"_FunctionArgumentList",
			L"_FunctionStat",
			L"_FunctionBody",
			L"_FunctionKind",
			L"_Function",
			L"_Variable",
			L"_Event",
			L"_Property",
			L"_StaticInit",
			L"_BaseConstructorCall",
			L"_ConstructorType",
			L"_Constructor",
			L"_Destructor",
			L"_ClassBody",
			L"_Class",
			L"_EnumItemNumber",
			L"_EnumItemInt",
			L"_EnumItemFlags",
			L"_EnumItem",
			L"_EnumItemWithFlags",
			L"_Enum",
			L"_StructMember",
			L"_Struct",
			L"_APConfig",
			L"_AutoPropertyKind",
			L"_AutoProperty",
			L"_CastResultInterface",
			L"_DeclarationCandidates",
			L"_Declaration",
			L"_UsingFragment",
			L"_UsingItem",
			L"_UsingPath",
			L"_ModuleBody",
			L"_Module",
		};
		return results[index];
	}

	const wchar_t* ParserStateLabel(vl::vint index)
	{
		static const wchar_t* results[] = {
			L"[0][_Type] BEGIN ",
			L"[1][_Type] END [ENDING]",
			L"[2][_Type]< \"::\" @ NAME >",
			L"[3][_Type]< \"::\" NAME @ >",
			L"[4][_Type]< \"bool\" @ >",
			L"[5][_Type]< \"char\" @ >",
			L"[6][_Type]< \"const\" @ _Type \"[\" [ _Type ] \"]\" >",
			L"[7][_Type]< \"const\" _Type \"[\" @ [ _Type ] \"]\" >",
			L"[8][_Type]< \"const\" _Type \"[\" [ _Type @ ] \"]\" >",
			L"[9][_Type]< \"const\" _Type \"[\" [ _Type ] \"]\" @ >",
			L"[10][_Type]< \"const\" _Type @ \"[\" [ _Type ] \"]\" >",
			L"[11][_Type]< \"double\" @ >",
			L"[12][_Type]< \"float\" @ >",
			L"[13][_Type]< \"func\" \"(\" @ { _Type ; \",\" } \")\" \":\" _Type >",
			L"[14][_Type]< \"func\" \"(\" { _Type ; \",\" @ } \")\" \":\" _Type >",
			L"[15][_Type]< \"func\" \"(\" { _Type ; \",\" } \")\" \":\" @ _Type >",
			L"[16][_Type]< \"func\" \"(\" { _Type ; \",\" } \")\" \":\" _Type @ >",
			L"[17][_Type]< \"func\" \"(\" { _Type ; \",\" } \")\" @ \":\" _Type >",
			L"[18][_Type]< \"func\" \"(\" { _Type @ ; \",\" } \")\" \":\" _Type >",
			L"[19][_Type]< \"func\" @ \"(\" { _Type ; \",\" } \")\" \":\" _Type >",
			L"[20][_Type]< \"int\" @ >",
			L"[21][_Type]< \"interface\" @ >",
			L"[22][_Type]< \"object\" @ >",
			L"[23][_Type]< \"observe\" @ _Type \"[\" \"]\" >",
			L"[24][_Type]< \"observe\" _Type \"[\" \"]\" @ >",
			L"[25][_Type]< \"observe\" _Type \"[\" @ \"]\" >",
			L"[26][_Type]< \"observe\" _Type @ \"[\" \"]\" >",
			L"[27][_Type]< \"string\" @ >",
			L"[28][_Type]< \"uint\" @ >",
			L"[29][_Type]< \"void\" @ >",
			L"[30][_Type]< NAME @ >",
			L"[31][_Type]< _Type \"*\" @ >",
			L"[32][_Type]< _Type \"::\" @ NAME >",
			L"[33][_Type]< _Type \"::\" NAME @ >",
			L"[34][_Type]< _Type \"?\" @ >",
			L"[35][_Type]< _Type \"[\" @ [ _Type ] \"]\" >",
			L"[36][_Type]< _Type \"[\" [ _Type @ ] \"]\" >",
			L"[37][_Type]< _Type \"[\" [ _Type ] \"]\" @ >",
			L"[38][_Type]< _Type \"^\" @ >",
			L"[39][_Type]< _Type \"{\" \"}\" @ >",
			L"[40][_Type]< _Type \"{\" @ \"}\" >",
			L"[41][_Type]< _Type @ \"*\" >",
			L"[42][_Type]< _Type @ \"::\" NAME >",
			L"[43][_Type]< _Type @ \"?\" >",
			L"[44][_Type]< _Type @ \"[\" [ _Type ] \"]\" >",
			L"[45][_Type]< _Type @ \"^\" >",
			L"[46][_Type]< _Type @ \"{\" \"}\" >",
			L"[47][_Type]<! \"(\" !_Type \")\" @ !>",
			L"[48][_Type]<! \"(\" !_Type @ \")\" !>",
			L"[49][_Type]<! \"(\" @ !_Type \")\" !>",
			L"[50][_CtorFragment] BEGIN ",
			L"[51][_CtorFragment] END [ENDING]",
			L"[52][_CtorFragment]< _Expression @ [ \":\" _Expression ] >",
			L"[53][_CtorFragment]< _Expression [ \":\" @ _Expression ] >",
			L"[54][_CtorFragment]< _Expression [ \":\" _Expression @ ] >",
			L"[55][_LetVariable] BEGIN ",
			L"[56][_LetVariable] END [ENDING]",
			L"[57][_LetVariable]< NAME \"=\" @ _Expression >",
			L"[58][_LetVariable]< NAME \"=\" _Expression @ >",
			L"[59][_LetVariable]< NAME @ \"=\" _Expression >",
			L"[60][_VirtualExpression] BEGIN ",
			L"[61][_VirtualExpression] END [ENDING]",
			L"[62][_VirtualExpression]< \"$\" \".\" @ NAME >",
			L"[63][_VirtualExpression]< \"$\" \".\" NAME @ >",
			L"[64][_VirtualExpression]< \"$\" @ \".\" NAME >",
			L"[65][_VirtualExpression]< \"$coroutine\" @ [ \"(\" NAME \")\" ] _Block >",
			L"[66][_VirtualExpression]< \"$coroutine\" [ \"(\" @ NAME \")\" ] _Block >",
			L"[67][_VirtualExpression]< \"$coroutine\" [ \"(\" NAME \")\" @ ] _Block >",
			L"[68][_VirtualExpression]< \"$coroutine\" [ \"(\" NAME \")\" ] _Block @ >",
			L"[69][_VirtualExpression]< \"$coroutine\" [ \"(\" NAME @ \")\" ] _Block >",
			L"[70][_VirtualExpression]< \"bind\" \"(\" @ _Expression \")\" >",
			L"[71][_VirtualExpression]< \"bind\" \"(\" _Expression \")\" @ >",
			L"[72][_VirtualExpression]< \"bind\" \"(\" _Expression @ \")\" >",
			L"[73][_VirtualExpression]< \"bind\" @ \"(\" _Expression \")\" >",
			L"[74][_VirtualExpression]< \"new\" @ _Type \"(\" \"using\" _Expression \")\" >",
			L"[75][_VirtualExpression]< \"new\" _Type \"(\" \"using\" @ _Expression \")\" >",
			L"[76][_VirtualExpression]< \"new\" _Type \"(\" \"using\" _Expression \")\" @ >",
			L"[77][_VirtualExpression]< \"new\" _Type \"(\" \"using\" _Expression @ \")\" >",
			L"[78][_VirtualExpression]< \"new\" _Type \"(\" @ \"using\" _Expression \")\" >",
			L"[79][_VirtualExpression]< \"new\" _Type @ \"(\" \"using\" _Expression \")\" >",
			L"[80][_VirtualExpression]< FORMATSTRING @ >",
			L"[81][_ExpPrimitive] BEGIN ",
			L"[82][_ExpPrimitive] END [ENDING]",
			L"[83][_ExpPrimitive]< \"::\" @ NAME >",
			L"[84][_ExpPrimitive]< \"::\" NAME @ >",
			L"[85][_ExpPrimitive]< \"[\" @ _Expression \"]\" >",
			L"[86][_ExpPrimitive]< \"[\" _Expression \"]\" @ >",
			L"[87][_ExpPrimitive]< \"[\" _Expression @ \"]\" >",
			L"[88][_ExpPrimitive]< \"attach\" \"(\" @ _Expression \",\" _Expression \")\" >",
			L"[89][_ExpPrimitive]< \"attach\" \"(\" _Expression \",\" @ _Expression \")\" >",
			L"[90][_ExpPrimitive]< \"attach\" \"(\" _Expression \",\" _Expression \")\" @ >",
			L"[91][_ExpPrimitive]< \"attach\" \"(\" _Expression \",\" _Expression @ \")\" >",
			L"[92][_ExpPrimitive]< \"attach\" \"(\" _Expression @ \",\" _Expression \")\" >",
			L"[93][_ExpPrimitive]< \"attach\" @ \"(\" _Expression \",\" _Expression \")\" >",
			L"[94][_ExpPrimitive]< \"detach\" \"(\" @ _Expression \",\" _Expression \")\" >",
			L"[95][_ExpPrimitive]< \"detach\" \"(\" _Expression \",\" @ _Expression \")\" >",
			L"[96][_ExpPrimitive]< \"detach\" \"(\" _Expression \",\" _Expression \")\" @ >",
			L"[97][_ExpPrimitive]< \"detach\" \"(\" _Expression \",\" _Expression @ \")\" >",
			L"[98][_ExpPrimitive]< \"detach\" \"(\" _Expression @ \",\" _Expression \")\" >",
			L"[99][_ExpPrimitive]< \"detach\" @ \"(\" _Expression \",\" _Expression \")\" >",
			L"[100][_ExpPrimitive]< \"false\" @ >",
			L"[101][_ExpPrimitive]< \"let\" @ _LetVariable { \",\" _LetVariable } \"in\" \"(\" _Expression \")\" >",
			L"[102][_ExpPrimitive]< \"let\" _LetVariable @ { \",\" _LetVariable } \"in\" \"(\" _Expression \")\" >",
			L"[103][_ExpPrimitive]< \"let\" _LetVariable { \",\" @ _LetVariable } \"in\" \"(\" _Expression \")\" >",
			L"[104][_ExpPrimitive]< \"let\" _LetVariable { \",\" _LetVariable @ } \"in\" \"(\" _Expression \")\" >",
			L"[105][_ExpPrimitive]< \"let\" _LetVariable { \",\" _LetVariable } \"in\" \"(\" @ _Expression \")\" >",
			L"[106][_ExpPrimitive]< \"let\" _LetVariable { \",\" _LetVariable } \"in\" \"(\" _Expression \")\" @ >",
			L"[107][_ExpPrimitive]< \"let\" _LetVariable { \",\" _LetVariable } \"in\" \"(\" _Expression @ \")\" >",
			L"[108][_ExpPrimitive]< \"let\" _LetVariable { \",\" _LetVariable } \"in\" @ \"(\" _Expression \")\" >",
			L"[109][_ExpPrimitive]< \"new\" _Type \"(\" @ { _Expression ; \",\" } \")\" >",
			L"[110][_ExpPrimitive]< \"new\" _Type \"(\" { _Expression ; \",\" @ } \")\" >",
			L"[111][_ExpPrimitive]< \"new\" _Type \"(\" { _Expression ; \",\" } \")\" @ >",
			L"[112][_ExpPrimitive]< \"new\" _Type \"(\" { _Expression @ ; \",\" } \")\" >",
			L"[113][_ExpPrimitive]< \"new\" _Type \"{\" @ { _Declaration } \"}\" >",
			L"[114][_ExpPrimitive]< \"new\" _Type \"{\" { _Declaration @ } \"}\" >",
			L"[115][_ExpPrimitive]< \"new\" _Type \"{\" { _Declaration } \"}\" @ >",
			L"[116][_ExpPrimitive]< \"null\" @ >",
			L"[117][_ExpPrimitive]< \"range\" ( \"(\" @ | \"[\" ) _Expression \",\" _Expression ( \")\" | \"]\" ) >",
			L"[118][_ExpPrimitive]< \"range\" ( \"(\" | \"[\" ) _Expression \",\" @ _Expression ( \")\" | \"]\" ) >",
			L"[119][_ExpPrimitive]< \"range\" ( \"(\" | \"[\" ) _Expression \",\" _Expression ( \")\" @ | \"]\" ) >",
			L"[120][_ExpPrimitive]< \"range\" ( \"(\" | \"[\" ) _Expression \",\" _Expression ( \")\" | \"]\" @ ) >",
			L"[121][_ExpPrimitive]< \"range\" ( \"(\" | \"[\" ) _Expression \",\" _Expression @ ( \")\" | \"]\" ) >",
			L"[122][_ExpPrimitive]< \"range\" ( \"(\" | \"[\" ) _Expression @ \",\" _Expression ( \")\" | \"]\" ) >",
			L"[123][_ExpPrimitive]< \"range\" ( \"(\" | \"[\" @ ) _Expression \",\" _Expression ( \")\" | \"]\" ) >",
			L"[124][_ExpPrimitive]< \"range\" @ ( \"(\" | \"[\" ) _Expression \",\" _Expression ( \")\" | \"]\" ) >",
			L"[125][_ExpPrimitive]< \"this\" @ >",
			L"[126][_ExpPrimitive]< \"true\" @ >",
			L"[127][_ExpPrimitive]< \"type\" \"(\" @ _Expression \")\" >",
			L"[128][_ExpPrimitive]< \"type\" \"(\" _Expression \")\" @ >",
			L"[129][_ExpPrimitive]< \"type\" \"(\" _Expression @ \")\" >",
			L"[130][_ExpPrimitive]< \"type\" @ \"(\" _Expression \")\" >",
			L"[131][_ExpPrimitive]< \"typeof\" \"(\" @ _Type \")\" >",
			L"[132][_ExpPrimitive]< \"typeof\" \"(\" _Type \")\" @ >",
			L"[133][_ExpPrimitive]< \"typeof\" \"(\" _Type @ \")\" >",
			L"[134][_ExpPrimitive]< \"typeof\" @ \"(\" _Type \")\" >",
			L"[135][_ExpPrimitive]< \"{\" @ [ _CtorFragment ( { _CtorFragment } | { \";\" _CtorFragment } \";\" ) ] \"}\" >",
			L"[136][_ExpPrimitive]< \"{\" [ _CtorFragment ( { _CtorFragment @ } | { \";\" _CtorFragment } \";\" ) ] \"}\" >",
			L"[137][_ExpPrimitive]< \"{\" [ _CtorFragment ( { _CtorFragment } | { \";\" @ _CtorFragment } \";\" ) ] \"}\" >",
			L"[138][_ExpPrimitive]< \"{\" [ _CtorFragment ( { _CtorFragment } | { \";\" _CtorFragment @ } \";\" ) ] \"}\" >",
			L"[139][_ExpPrimitive]< \"{\" [ _CtorFragment ( { _CtorFragment } | { \";\" _CtorFragment } \";\" ) ] \"}\" @ >",
			L"[140][_ExpPrimitive]< \"{\" [ _CtorFragment ( { _CtorFragment } | { \";\" _CtorFragment } \";\" @ ) ] \"}\" >",
			L"[141][_ExpPrimitive]< \"{\" [ _CtorFragment @ ( { _CtorFragment } | { \";\" _CtorFragment } \";\" ) ] \"}\" >",
			L"[142][_ExpPrimitive]< FLOAT @ >",
			L"[143][_ExpPrimitive]< INTEGER @ >",
			L"[144][_ExpPrimitive]< NAME @ >",
			L"[145][_ExpPrimitive]< ORDERED_NAME @ >",
			L"[146][_ExpPrimitive]< STRING @ >",
			L"[147][_ExpPrimitive]< _ExpPrimitive \"(\" @ [ _Expression { \",\" _Expression } ] \")\" >",
			L"[148][_ExpPrimitive]< _ExpPrimitive \"(\" [ _Expression @ { \",\" _Expression } ] \")\" >",
			L"[149][_ExpPrimitive]< _ExpPrimitive \"(\" [ _Expression { \",\" @ _Expression } ] \")\" >",
			L"[150][_ExpPrimitive]< _ExpPrimitive \"(\" [ _Expression { \",\" _Expression @ } ] \")\" >",
			L"[151][_ExpPrimitive]< _ExpPrimitive \"(\" [ _Expression { \",\" _Expression } ] \")\" @ >",
			L"[152][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"(\" @ _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[153][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"(\" _Expression @ [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[154][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"(\" _Expression [ \"on\" @ _Expression { \",\" _Expression } ] \")\" >",
			L"[155][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"(\" _Expression [ \"on\" _Expression @ { \",\" _Expression } ] \")\" >",
			L"[156][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"(\" _Expression [ \"on\" _Expression { \",\" @ _Expression } ] \")\" >",
			L"[157][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"(\" _Expression [ \"on\" _Expression { \",\" _Expression @ } ] \")\" >",
			L"[158][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" @ >",
			L"[159][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" @ NAME \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[160][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME \"(\" @ _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[161][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME \"(\" _Expression @ [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[162][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME \"(\" _Expression [ \"on\" @ _Expression { \",\" _Expression } ] \")\" >",
			L"[163][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME \"(\" _Expression [ \"on\" _Expression @ { \",\" _Expression } ] \")\" >",
			L"[164][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME \"(\" _Expression [ \"on\" _Expression { \",\" @ _Expression } ] \")\" >",
			L"[165][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME \"(\" _Expression [ \"on\" _Expression { \",\" _Expression @ } ] \")\" >",
			L"[166][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" @ >",
			L"[167][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" \"as\" NAME @ \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[168][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" @ \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[169][_ExpPrimitive]< _ExpPrimitive \".\" \"observe\" @ \"as\" NAME \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[170][_ExpPrimitive]< _ExpPrimitive \".\" @ \"observe\" \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[171][_ExpPrimitive]< _ExpPrimitive \".\" @ \"observe\" \"as\" NAME \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[172][_ExpPrimitive]< _ExpPrimitive \".\" @ NAME >",
			L"[173][_ExpPrimitive]< _ExpPrimitive \".\" NAME @ >",
			L"[174][_ExpPrimitive]< _ExpPrimitive \"::\" @ NAME >",
			L"[175][_ExpPrimitive]< _ExpPrimitive \"::\" NAME @ >",
			L"[176][_ExpPrimitive]< _ExpPrimitive \"[\" @ _Expression \"]\" >",
			L"[177][_ExpPrimitive]< _ExpPrimitive \"[\" _Expression \"]\" @ >",
			L"[178][_ExpPrimitive]< _ExpPrimitive \"[\" _Expression @ \"]\" >",
			L"[179][_ExpPrimitive]< _ExpPrimitive \"as\" \"*\" @ >",
			L"[180][_ExpPrimitive]< _ExpPrimitive \"as\" @ \"*\" >",
			L"[181][_ExpPrimitive]< _ExpPrimitive \"as\" @ _Type >",
			L"[182][_ExpPrimitive]< _ExpPrimitive \"as\" _Type @ >",
			L"[183][_ExpPrimitive]< _ExpPrimitive \"is\" \"not\" \"null\" @ >",
			L"[184][_ExpPrimitive]< _ExpPrimitive \"is\" \"not\" @ \"null\" >",
			L"[185][_ExpPrimitive]< _ExpPrimitive \"is\" \"not\" @ _Type >",
			L"[186][_ExpPrimitive]< _ExpPrimitive \"is\" \"not\" _Type @ >",
			L"[187][_ExpPrimitive]< _ExpPrimitive \"is\" \"null\" @ >",
			L"[188][_ExpPrimitive]< _ExpPrimitive \"is\" @ \"not\" \"null\" >",
			L"[189][_ExpPrimitive]< _ExpPrimitive \"is\" @ \"not\" _Type >",
			L"[190][_ExpPrimitive]< _ExpPrimitive \"is\" @ \"null\" >",
			L"[191][_ExpPrimitive]< _ExpPrimitive \"is\" @ _Type >",
			L"[192][_ExpPrimitive]< _ExpPrimitive \"is\" _Type @ >",
			L"[193][_ExpPrimitive]< _ExpPrimitive \"of\" @ _Type >",
			L"[194][_ExpPrimitive]< _ExpPrimitive \"of\" _Type @ >",
			L"[195][_ExpPrimitive]< _ExpPrimitive ( \"in\" @ | \"not\" \"in\" ) _Expression >",
			L"[196][_ExpPrimitive]< _ExpPrimitive ( \"in\" | \"not\" \"in\" ) _Expression @ >",
			L"[197][_ExpPrimitive]< _ExpPrimitive ( \"in\" | \"not\" \"in\" @ ) _Expression >",
			L"[198][_ExpPrimitive]< _ExpPrimitive ( \"in\" | \"not\" @ \"in\" ) _Expression >",
			L"[199][_ExpPrimitive]< _ExpPrimitive @ \"(\" [ _Expression { \",\" _Expression } ] \")\" >",
			L"[200][_ExpPrimitive]< _ExpPrimitive @ \".\" \"observe\" \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[201][_ExpPrimitive]< _ExpPrimitive @ \".\" \"observe\" \"as\" NAME \"(\" _Expression [ \"on\" _Expression { \",\" _Expression } ] \")\" >",
			L"[202][_ExpPrimitive]< _ExpPrimitive @ \".\" NAME >",
			L"[203][_ExpPrimitive]< _ExpPrimitive @ \"::\" NAME >",
			L"[204][_ExpPrimitive]< _ExpPrimitive @ \"[\" _Expression \"]\" >",
			L"[205][_ExpPrimitive]< _ExpPrimitive @ \"as\" \"*\" >",
			L"[206][_ExpPrimitive]< _ExpPrimitive @ \"as\" _Type >",
			L"[207][_ExpPrimitive]< _ExpPrimitive @ \"is\" \"not\" \"null\" >",
			L"[208][_ExpPrimitive]< _ExpPrimitive @ \"is\" \"not\" _Type >",
			L"[209][_ExpPrimitive]< _ExpPrimitive @ \"is\" \"null\" >",
			L"[210][_ExpPrimitive]< _ExpPrimitive @ \"is\" _Type >",
			L"[211][_ExpPrimitive]< _ExpPrimitive @ \"of\" _Type >",
			L"[212][_ExpPrimitive]< _ExpPrimitive @ ( \"in\" | \"not\" \"in\" ) _Expression >",
			L"[213][_ExpPrimitive]< _Function @ >",
			L"[214][_ExpPrimitive]<! !_VirtualExpression @ !>",
			L"[215][_ExpPrimitive]<! \"(\" !_Expression \")\" @ !>",
			L"[216][_ExpPrimitive]<! \"(\" !_Expression @ \")\" !>",
			L"[217][_ExpPrimitive]<! \"(\" @ !_Expression \")\" !>",
			L"[218][_ExpPrimitive]{{< \"new\" @ _Type \"(\" { _Expression ; \",\" } \")\" > ; < \"new\" @ _Type \"{\" { _Declaration } \"}\" >}}",
			L"[219][_ExpPrimitive]{{< \"new\" _Type @ \"(\" { _Expression ; \",\" } \")\" > ; < \"new\" _Type @ \"{\" { _Declaration } \"}\" >}}",
			L"[220][_Exp0] BEGIN ",
			L"[221][_Exp0] END [ENDING]",
			L"[222][_Exp0]< \"+\" @ _Exp0 >",
			L"[223][_Exp0]< \"+\" _Exp0 @ >",
			L"[224][_Exp0]< \"-\" @ _Exp0 >",
			L"[225][_Exp0]< \"-\" _Exp0 @ >",
			L"[226][_Exp0]< \"cast\" \"*\" @ _Exp0 >",
			L"[227][_Exp0]< \"cast\" \"*\" _Exp0 @ >",
			L"[228][_Exp0]< \"cast\" _Type @ _Exp0 >",
			L"[229][_Exp0]< \"cast\" _Type _Exp0 @ >",
			L"[230][_Exp0]< \"not\" @ _Exp0 >",
			L"[231][_Exp0]< \"not\" _Exp0 @ >",
			L"[232][_Exp0]<! !_ExpPrimitive @ !>",
			L"[233][_Exp0]{{< \"cast\" @ \"*\" _Exp0 > ; < \"cast\" @ _Type _Exp0 >}}",
			L"[234][_Exp1] BEGIN ",
			L"[235][_Exp1] END [ENDING]",
			L"[236][_Exp1]< _Exp1 \"^\" @ _Exp0 >",
			L"[237][_Exp1]< _Exp1 \"^\" _Exp0 @ >",
			L"[238][_Exp1]< _Exp1 @ \"^\" _Exp0 >",
			L"[239][_Exp1]<! !_Exp0 @ !>",
			L"[240][_Exp2] BEGIN ",
			L"[241][_Exp2] END [ENDING]",
			L"[242][_Exp2]< _Exp2 \"%\" @ _Exp1 >",
			L"[243][_Exp2]< _Exp2 \"%\" _Exp1 @ >",
			L"[244][_Exp2]< _Exp2 \"*\" @ _Exp1 >",
			L"[245][_Exp2]< _Exp2 \"*\" _Exp1 @ >",
			L"[246][_Exp2]< _Exp2 \"/\" @ _Exp1 >",
			L"[247][_Exp2]< _Exp2 \"/\" _Exp1 @ >",
			L"[248][_Exp2]< _Exp2 @ \"%\" _Exp1 >",
			L"[249][_Exp2]< _Exp2 @ \"*\" _Exp1 >",
			L"[250][_Exp2]< _Exp2 @ \"/\" _Exp1 >",
			L"[251][_Exp2]<! !_Exp1 @ !>",
			L"[252][_Exp3] BEGIN ",
			L"[253][_Exp3] END [ENDING]",
			L"[254][_Exp3]< _Exp3 \"&\" @ _Exp2 >",
			L"[255][_Exp3]< _Exp3 \"&\" _Exp2 @ >",
			L"[256][_Exp3]< _Exp3 \"+\" @ _Exp2 >",
			L"[257][_Exp3]< _Exp3 \"+\" _Exp2 @ >",
			L"[258][_Exp3]< _Exp3 \"-\" @ _Exp2 >",
			L"[259][_Exp3]< _Exp3 \"-\" _Exp2 @ >",
			L"[260][_Exp3]< _Exp3 \"|\" @ _Exp2 >",
			L"[261][_Exp3]< _Exp3 \"|\" _Exp2 @ >",
			L"[262][_Exp3]< _Exp3 @ \"&\" _Exp2 >",
			L"[263][_Exp3]< _Exp3 @ \"+\" _Exp2 >",
			L"[264][_Exp3]< _Exp3 @ \"-\" _Exp2 >",
			L"[265][_Exp3]< _Exp3 @ \"|\" _Exp2 >",
			L"[266][_Exp3]<! !_Exp2 @ !>",
			L"[267][_Exp4] BEGIN ",
			L"[268][_Exp4] END [ENDING]",
			L"[269][_Exp4]< _Exp4 \"shl\" @ _Exp3 >",
			L"[270][_Exp4]< _Exp4 \"shl\" _Exp3 @ >",
			L"[271][_Exp4]< _Exp4 \"shr\" @ _Exp3 >",
			L"[272][_Exp4]< _Exp4 \"shr\" _Exp3 @ >",
			L"[273][_Exp4]< _Exp4 @ \"shl\" _Exp3 >",
			L"[274][_Exp4]< _Exp4 @ \"shr\" _Exp3 >",
			L"[275][_Exp4]<! !_Exp3 @ !>",
			L"[276][_Exp5] BEGIN ",
			L"[277][_Exp5] END [ENDING]",
			L"[278][_Exp5]< _Exp5 \"!=\" @ _Exp4 >",
			L"[279][_Exp5]< _Exp5 \"!=\" _Exp4 @ >",
			L"[280][_Exp5]< _Exp5 \"<\" @ _Exp4 >",
			L"[281][_Exp5]< _Exp5 \"<\" _Exp4 @ >",
			L"[282][_Exp5]< _Exp5 \"<=\" @ _Exp4 >",
			L"[283][_Exp5]< _Exp5 \"<=\" _Exp4 @ >",
			L"[284][_Exp5]< _Exp5 \"==\" @ _Exp4 >",
			L"[285][_Exp5]< _Exp5 \"==\" _Exp4 @ >",
			L"[286][_Exp5]< _Exp5 \">\" @ _Exp4 >",
			L"[287][_Exp5]< _Exp5 \">\" _Exp4 @ >",
			L"[288][_Exp5]< _Exp5 \">=\" @ _Exp4 >",
			L"[289][_Exp5]< _Exp5 \">=\" _Exp4 @ >",
			L"[290][_Exp5]< _Exp5 @ \"!=\" _Exp4 >",
			L"[291][_Exp5]< _Exp5 @ \"<\" _Exp4 >",
			L"[292][_Exp5]< _Exp5 @ \"<=\" _Exp4 >",
			L"[293][_Exp5]< _Exp5 @ \"==\" _Exp4 >",
			L"[294][_Exp5]< _Exp5 @ \">\" _Exp4 >",
			L"[295][_Exp5]< _Exp5 @ \">=\" _Exp4 >",
			L"[296][_Exp5]<! !_Exp4 @ !>",
			L"[297][_Exp6] BEGIN ",
			L"[298][_Exp6] END [ENDING]",
			L"[299][_Exp6]< _Exp6 \"xor\" @ _Exp5 >",
			L"[300][_Exp6]< _Exp6 \"xor\" _Exp5 @ >",
			L"[301][_Exp6]< _Exp6 @ \"xor\" _Exp5 >",
			L"[302][_Exp6]<! !_Exp5 @ !>",
			L"[303][_Exp7] BEGIN ",
			L"[304][_Exp7] END [ENDING]",
			L"[305][_Exp7]< _Exp7 \"and\" @ _Exp6 >",
			L"[306][_Exp7]< _Exp7 \"and\" _Exp6 @ >",
			L"[307][_Exp7]< _Exp7 @ \"and\" _Exp6 >",
			L"[308][_Exp7]<! !_Exp6 @ !>",
			L"[309][_Exp8] BEGIN ",
			L"[310][_Exp8] END [ENDING]",
			L"[311][_Exp8]< _Exp8 \"or\" @ _Exp7 >",
			L"[312][_Exp8]< _Exp8 \"or\" _Exp7 @ >",
			L"[313][_Exp8]< _Exp8 @ \"or\" _Exp7 >",
			L"[314][_Exp8]<! !_Exp7 @ !>",
			L"[315][_Exp9] BEGIN ",
			L"[316][_Exp9] END [ENDING]",
			L"[317][_Exp9]< _Exp9 \"??\" @ _Exp8 >",
			L"[318][_Exp9]< _Exp9 \"??\" _Exp8 @ >",
			L"[319][_Exp9]< _Exp9 @ \"??\" _Exp8 >",
			L"[320][_Exp9]<! !_Exp8 @ !>",
			L"[321][_Exp10] BEGIN ",
			L"[322][_Exp10] BEGIN [pm-lr]",
			L"[323][_Exp10] END [ENDING]",
			L"[324][_Exp10]< _Exp9 \"?\" @ _Exp10 \":\" _Exp10 >",
			L"[325][_Exp10]< _Exp9 \"?\" _Exp10 \":\" @ _Exp10 >",
			L"[326][_Exp10]< _Exp9 \"?\" _Exp10 \":\" _Exp10 @ >",
			L"[327][_Exp10]< _Exp9 \"?\" _Exp10 @ \":\" _Exp10 >",
			L"[328][_Exp10]< _Exp9 @ \"?\" _Exp10 \":\" _Exp10 >",
			L"[329][_Exp11] BEGIN ",
			L"[330][_Exp11] BEGIN [pm-lr]",
			L"[331][_Exp11] END [ENDING]",
			L"[332][_Exp11]< _Exp10 \"=\" @ _Exp11 >",
			L"[333][_Exp11]< _Exp10 \"=\" _Exp11 @ >",
			L"[334][_Exp11]< _Exp10 @ \"=\" _Exp11 >",
			L"[335][_Expression] BEGIN ",
			L"[336][_Expression] END [ENDING]",
			L"[337][_Expression]<! !_Exp11 @ !>",
			L"[338][_SwitchCase] BEGIN ",
			L"[339][_SwitchCase] END [ENDING]",
			L"[340][_SwitchCase]< \"case\" @ _Expression \":\" _Block >",
			L"[341][_SwitchCase]< \"case\" _Expression \":\" @ _Block >",
			L"[342][_SwitchCase]< \"case\" _Expression \":\" _Block @ >",
			L"[343][_SwitchCase]< \"case\" _Expression @ \":\" _Block >",
			L"[344][_Block] BEGIN ",
			L"[345][_Block] END [ENDING]",
			L"[346][_Block]< \"{\" @ { _Statement } [ NAME \":\" \";\" ] \"}\" >",
			L"[347][_Block]< \"{\" { _Statement @ } [ NAME \":\" \";\" ] \"}\" >",
			L"[348][_Block]< \"{\" { _Statement } [ NAME \":\" \";\" @ ] \"}\" >",
			L"[349][_Block]< \"{\" { _Statement } [ NAME \":\" \";\" ] \"}\" @ >",
			L"[350][_Block]< \"{\" { _Statement } [ NAME \":\" @ \";\" ] \"}\" >",
			L"[351][_Block]< \"{\" { _Statement } [ NAME @ \":\" \";\" ] \"}\" >",
			L"[352][_ElseStat] BEGIN ",
			L"[353][_ElseStat] END [ENDING]",
			L"[354][_ElseStat]<! !_Block @ !>",
			L"[355][_ElseStat]<! !_If @ !>",
			L"[356][_If] BEGIN ",
			L"[357][_If] END [ENDING]",
			L"[358][_If]< \"if\" \"(\" @ [ \"var\" NAME \":\" _Type \"=\" ] _Expression \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[359][_If]< \"if\" \"(\" [ \"var\" @ NAME \":\" _Type \"=\" ] _Expression \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[360][_If]< \"if\" \"(\" [ \"var\" NAME \":\" @ _Type \"=\" ] _Expression \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[361][_If]< \"if\" \"(\" [ \"var\" NAME \":\" _Type \"=\" @ ] _Expression \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[362][_If]< \"if\" \"(\" [ \"var\" NAME \":\" _Type \"=\" ] _Expression \")\" @ _Block +[ \"else\" _ElseStat ] >",
			L"[363][_If]< \"if\" \"(\" [ \"var\" NAME \":\" _Type \"=\" ] _Expression \")\" _Block +[ \"else\" @ _ElseStat ] >",
			L"[364][_If]< \"if\" \"(\" [ \"var\" NAME \":\" _Type \"=\" ] _Expression \")\" _Block +[ \"else\" _ElseStat @ ] >",
			L"[365][_If]< \"if\" \"(\" [ \"var\" NAME \":\" _Type \"=\" ] _Expression \")\" _Block @ +[ \"else\" _ElseStat ] >",
			L"[366][_If]< \"if\" \"(\" [ \"var\" NAME \":\" _Type \"=\" ] _Expression @ \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[367][_If]< \"if\" \"(\" [ \"var\" NAME \":\" _Type @ \"=\" ] _Expression \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[368][_If]< \"if\" \"(\" [ \"var\" NAME @ \":\" _Type \"=\" ] _Expression \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[369][_If]< \"if\" @ \"(\" [ \"var\" NAME \":\" _Type \"=\" ] _Expression \")\" _Block +[ \"else\" _ElseStat ] >",
			L"[370][_VirtualStatement] BEGIN ",
			L"[371][_VirtualStatement] END [ENDING]",
			L"[372][_VirtualStatement]< \"for\" \"(\" @ NAME ( \"in\" | \"in\" \"reversed\" ) _Expression \")\" _Block >",
			L"[373][_VirtualStatement]< \"for\" \"(\" NAME ( \"in\" @ | \"in\" \"reversed\" ) _Expression \")\" _Block >",
			L"[374][_VirtualStatement]< \"for\" \"(\" NAME ( \"in\" | \"in\" \"reversed\" ) _Expression \")\" @ _Block >",
			L"[375][_VirtualStatement]< \"for\" \"(\" NAME ( \"in\" | \"in\" \"reversed\" ) _Expression \")\" _Block @ >",
			L"[376][_VirtualStatement]< \"for\" \"(\" NAME ( \"in\" | \"in\" \"reversed\" ) _Expression @ \")\" _Block >",
			L"[377][_VirtualStatement]< \"for\" \"(\" NAME ( \"in\" | \"in\" \"reversed\" @ ) _Expression \")\" _Block >",
			L"[378][_VirtualStatement]< \"for\" \"(\" NAME ( \"in\" | \"in\" @ \"reversed\" ) _Expression \")\" _Block >",
			L"[379][_VirtualStatement]< \"for\" \"(\" NAME @ ( \"in\" | \"in\" \"reversed\" ) _Expression \")\" _Block >",
			L"[380][_VirtualStatement]< \"for\" @ \"(\" NAME ( \"in\" | \"in\" \"reversed\" ) _Expression \")\" _Block >",
			L"[381][_VirtualStatement]< \"switch\" \"(\" @ _Expression \")\" \"{\" { _SwitchCase } [ \"default\" \":\" _Block ] \"}\" >",
			L"[382][_VirtualStatement]< \"switch\" \"(\" _Expression \")\" \"{\" @ { _SwitchCase } [ \"default\" \":\" _Block ] \"}\" >",
			L"[383][_VirtualStatement]< \"switch\" \"(\" _Expression \")\" \"{\" { _SwitchCase @ } [ \"default\" \":\" _Block ] \"}\" >",
			L"[384][_VirtualStatement]< \"switch\" \"(\" _Expression \")\" \"{\" { _SwitchCase } [ \"default\" \":\" @ _Block ] \"}\" >",
			L"[385][_VirtualStatement]< \"switch\" \"(\" _Expression \")\" \"{\" { _SwitchCase } [ \"default\" \":\" _Block @ ] \"}\" >",
			L"[386][_VirtualStatement]< \"switch\" \"(\" _Expression \")\" \"{\" { _SwitchCase } [ \"default\" \":\" _Block ] \"}\" @ >",
			L"[387][_VirtualStatement]< \"switch\" \"(\" _Expression \")\" \"{\" { _SwitchCase } [ \"default\" @ \":\" _Block ] \"}\" >",
			L"[388][_VirtualStatement]< \"switch\" \"(\" _Expression \")\" @ \"{\" { _SwitchCase } [ \"default\" \":\" _Block ] \"}\" >",
			L"[389][_VirtualStatement]< \"switch\" \"(\" _Expression @ \")\" \"{\" { _SwitchCase } [ \"default\" \":\" _Block ] \"}\" >",
			L"[390][_VirtualStatement]< \"switch\" @ \"(\" _Expression \")\" \"{\" { _SwitchCase } [ \"default\" \":\" _Block ] \"}\" >",
			L"[391][_CoStatement] BEGIN ",
			L"[392][_CoStatement] END [ENDING]",
			L"[393][_CoStatement]< \"$pause\" ( \";\" @ | _Block ) >",
			L"[394][_CoStatement]< \"$pause\" ( \";\" | _Block @ ) >",
			L"[395][_CoStatement]< \"$pause\" @ ( \";\" | _Block ) >",
			L"[396][_CoStatement]< [ \"var\" @ NAME \"=\" ] COROUTINE_OPERATOR { _Expression ; \",\" } \";\" >",
			L"[397][_CoStatement]< [ \"var\" NAME \"=\" @ ] COROUTINE_OPERATOR { _Expression ; \",\" } \";\" >",
			L"[398][_CoStatement]< [ \"var\" NAME \"=\" ] COROUTINE_OPERATOR @ { _Expression ; \",\" } \";\" >",
			L"[399][_CoStatement]< [ \"var\" NAME \"=\" ] COROUTINE_OPERATOR { _Expression ; \",\" @ } \";\" >",
			L"[400][_CoStatement]< [ \"var\" NAME \"=\" ] COROUTINE_OPERATOR { _Expression ; \",\" } \";\" @ >",
			L"[401][_CoStatement]< [ \"var\" NAME \"=\" ] COROUTINE_OPERATOR { _Expression @ ; \",\" } \";\" >",
			L"[402][_CoStatement]< [ \"var\" NAME @ \"=\" ] COROUTINE_OPERATOR { _Expression ; \",\" } \";\" >",
			L"[403][_CoProvider] BEGIN ",
			L"[404][_CoProvider] END [ENDING]",
			L"[405][_CoProvider]< ( \"$\" @ | COROUTINE_OPERATOR ) _Block >",
			L"[406][_CoProvider]< ( \"$\" | COROUTINE_OPERATOR ) _Block @ >",
			L"[407][_CoProvider]< ( \"$\" | COROUTINE_OPERATOR @ ) _Block >",
			L"[408][_StateSwitchHead] BEGIN ",
			L"[409][_StateSwitchHead] END [ENDING]",
			L"[410][_StateSwitchHead]< \"$switch\" \"(\" \")\" @ >",
			L"[411][_StateSwitchHead]< \"$switch\" \"(\" \"continue\" \")\" @ >",
			L"[412][_StateSwitchHead]< \"$switch\" \"(\" \"continue\" \",\" \"return\" \")\" @ >",
			L"[413][_StateSwitchHead]< \"$switch\" \"(\" \"continue\" \",\" \"return\" @ \")\" >",
			L"[414][_StateSwitchHead]< \"$switch\" \"(\" \"continue\" \",\" @ \"return\" \")\" >",
			L"[415][_StateSwitchHead]< \"$switch\" \"(\" \"raise\" \")\" @ >",
			L"[416][_StateSwitchHead]< \"$switch\" \"(\" \"raise\" @ \")\" >",
			L"[417][_StateSwitchHead]< \"$switch\" \"(\" \"return\" \")\" @ >",
			L"[418][_StateSwitchHead]< \"$switch\" \"(\" \"return\" @ \")\" >",
			L"[419][_StateSwitchHead]{{< \"$switch\" \"(\" \"continue\" @ \")\" > ; < \"$switch\" \"(\" \"continue\" @ \",\" \"return\" \")\" >}}",
			L"[420][_StateSwitchHead]{{< \"$switch\" \"(\" @ \")\" > ; < \"$switch\" \"(\" @ \"continue\" \")\" > ; < \"$switch\" \"(\" @ \"continue\" \",\" \"return\" \")\" > ; < \"$switch\" \"(\" @ \"raise\" \")\" > ; < \"$switch\" \"(\" @ \"return\" \")\" >}}",
			L"[421][_StateSwitchHead]{{< \"$switch\" @ \"(\" \")\" > ; < \"$switch\" @ \"(\" \"continue\" \")\" > ; < \"$switch\" @ \"(\" \"continue\" \",\" \"return\" \")\" > ; < \"$switch\" @ \"(\" \"raise\" \")\" > ; < \"$switch\" @ \"(\" \"return\" \")\" >}}",
			L"[422][_StateSwitchArgument] BEGIN ",
			L"[423][_StateSwitchArgument] END [ENDING]",
			L"[424][_StateSwitchArgument]< NAME @ >",
			L"[425][_StateSwitchCase] BEGIN ",
			L"[426][_StateSwitchCase] END [ENDING]",
			L"[427][_StateSwitchCase]< \"case\" @ NAME \"(\" [ _StateSwitchArgument { \",\" _StateSwitchArgument } ] \")\" \":\" _Block >",
			L"[428][_StateSwitchCase]< \"case\" NAME \"(\" @ [ _StateSwitchArgument { \",\" _StateSwitchArgument } ] \")\" \":\" _Block >",
			L"[429][_StateSwitchCase]< \"case\" NAME \"(\" [ _StateSwitchArgument @ { \",\" _StateSwitchArgument } ] \")\" \":\" _Block >",
			L"[430][_StateSwitchCase]< \"case\" NAME \"(\" [ _StateSwitchArgument { \",\" @ _StateSwitchArgument } ] \")\" \":\" _Block >",
			L"[431][_StateSwitchCase]< \"case\" NAME \"(\" [ _StateSwitchArgument { \",\" _StateSwitchArgument @ } ] \")\" \":\" _Block >",
			L"[432][_StateSwitchCase]< \"case\" NAME \"(\" [ _StateSwitchArgument { \",\" _StateSwitchArgument } ] \")\" \":\" @ _Block >",
			L"[433][_StateSwitchCase]< \"case\" NAME \"(\" [ _StateSwitchArgument { \",\" _StateSwitchArgument } ] \")\" \":\" _Block @ >",
			L"[434][_StateSwitchCase]< \"case\" NAME \"(\" [ _StateSwitchArgument { \",\" _StateSwitchArgument } ] \")\" @ \":\" _Block >",
			L"[435][_StateSwitchCase]< \"case\" NAME @ \"(\" [ _StateSwitchArgument { \",\" _StateSwitchArgument } ] \")\" \":\" _Block >",
			L"[436][_StateStatement] BEGIN ",
			L"[437][_StateStatement] END [ENDING]",
			L"[438][_StateStatement]< \"$goto_state\" @ NAME \"(\" { _Expression ; \",\" } \")\" \";\" >",
			L"[439][_StateStatement]< \"$goto_state\" NAME \"(\" @ { _Expression ; \",\" } \")\" \";\" >",
			L"[440][_StateStatement]< \"$goto_state\" NAME \"(\" { _Expression ; \",\" @ } \")\" \";\" >",
			L"[441][_StateStatement]< \"$goto_state\" NAME \"(\" { _Expression ; \",\" } \")\" \";\" @ >",
			L"[442][_StateStatement]< \"$goto_state\" NAME \"(\" { _Expression ; \",\" } \")\" @ \";\" >",
			L"[443][_StateStatement]< \"$goto_state\" NAME \"(\" { _Expression @ ; \",\" } \")\" \";\" >",
			L"[444][_StateStatement]< \"$goto_state\" NAME @ \"(\" { _Expression ; \",\" } \")\" \";\" >",
			L"[445][_StateStatement]< \"$push_state\" @ NAME \"(\" { _Expression ; \",\" } \")\" \";\" >",
			L"[446][_StateStatement]< \"$push_state\" NAME \"(\" @ { _Expression ; \",\" } \")\" \";\" >",
			L"[447][_StateStatement]< \"$push_state\" NAME \"(\" { _Expression ; \",\" @ } \")\" \";\" >",
			L"[448][_StateStatement]< \"$push_state\" NAME \"(\" { _Expression ; \",\" } \")\" \";\" @ >",
			L"[449][_StateStatement]< \"$push_state\" NAME \"(\" { _Expression ; \",\" } \")\" @ \";\" >",
			L"[450][_StateStatement]< \"$push_state\" NAME \"(\" { _Expression @ ; \",\" } \")\" \";\" >",
			L"[451][_StateStatement]< \"$push_state\" NAME @ \"(\" { _Expression ; \",\" } \")\" \";\" >",
			L"[452][_StateStatement]<! !_StateSwitchHead \"{\" @ { _StateSwitchCase } \"}\" !>",
			L"[453][_StateStatement]<! !_StateSwitchHead \"{\" { _StateSwitchCase @ } \"}\" !>",
			L"[454][_StateStatement]<! !_StateSwitchHead \"{\" { _StateSwitchCase } \"}\" @ !>",
			L"[455][_StateStatement]<! !_StateSwitchHead @ \"{\" { _StateSwitchCase } \"}\" !>",
			L"[456][_Statement] BEGIN ",
			L"[457][_Statement] END [ENDING]",
			L"[458][_Statement]< \"break\" \";\" @ >",
			L"[459][_Statement]< \"break\" @ \";\" >",
			L"[460][_Statement]< \"continue\" \";\" @ >",
			L"[461][_Statement]< \"continue\" @ \";\" >",
			L"[462][_Statement]< \"delete\" @ _Expression \";\" >",
			L"[463][_Statement]< \"delete\" _Expression \";\" @ >",
			L"[464][_Statement]< \"delete\" _Expression @ \";\" >",
			L"[465][_Statement]< \"goto\" @ NAME \";\" >",
			L"[466][_Statement]< \"goto\" NAME \";\" @ >",
			L"[467][_Statement]< \"goto\" NAME @ \";\" >",
			L"[468][_Statement]< \"raise\" @ [ _Expression ] \";\" >",
			L"[469][_Statement]< \"raise\" [ _Expression @ ] \";\" >",
			L"[470][_Statement]< \"raise\" [ _Expression ] \";\" @ >",
			L"[471][_Statement]< \"return\" @ [ _Expression ] \";\" >",
			L"[472][_Statement]< \"return\" [ _Expression @ ] \";\" >",
			L"[473][_Statement]< \"return\" [ _Expression ] \";\" @ >",
			L"[474][_Statement]< \"try\" @ _Block [ \"catch\" \"(\" NAME \")\" _Block ] [ \"finally\" _Block ] >",
			L"[475][_Statement]< \"try\" _Block @ [ \"catch\" \"(\" NAME \")\" _Block ] [ \"finally\" _Block ] >",
			L"[476][_Statement]< \"try\" _Block [ \"catch\" \"(\" @ NAME \")\" _Block ] [ \"finally\" _Block ] >",
			L"[477][_Statement]< \"try\" _Block [ \"catch\" \"(\" NAME \")\" @ _Block ] [ \"finally\" _Block ] >",
			L"[478][_Statement]< \"try\" _Block [ \"catch\" \"(\" NAME \")\" _Block @ ] [ \"finally\" _Block ] >",
			L"[479][_Statement]< \"try\" _Block [ \"catch\" \"(\" NAME \")\" _Block ] [ \"finally\" @ _Block ] >",
			L"[480][_Statement]< \"try\" _Block [ \"catch\" \"(\" NAME \")\" _Block ] [ \"finally\" _Block @ ] >",
			L"[481][_Statement]< \"try\" _Block [ \"catch\" \"(\" NAME @ \")\" _Block ] [ \"finally\" _Block ] >",
			L"[482][_Statement]< \"try\" _Block [ \"catch\" @ \"(\" NAME \")\" _Block ] [ \"finally\" _Block ] >",
			L"[483][_Statement]< \"while\" \"(\" @ _Expression \")\" _Block >",
			L"[484][_Statement]< \"while\" \"(\" _Expression \")\" @ _Block >",
			L"[485][_Statement]< \"while\" \"(\" _Expression \")\" _Block @ >",
			L"[486][_Statement]< \"while\" \"(\" _Expression @ \")\" _Block >",
			L"[487][_Statement]< \"while\" @ \"(\" _Expression \")\" _Block >",
			L"[488][_Statement]< _Expression \";\" @ >",
			L"[489][_Statement]< _Expression @ \";\" >",
			L"[490][_Statement]< _Variable @ >",
			L"[491][_Statement]<! !_Block @ !>",
			L"[492][_Statement]<! !_CoStatement @ !>",
			L"[493][_Statement]<! !_If @ !>",
			L"[494][_Statement]<! !_StateStatement @ !>",
			L"[495][_Statement]<! !_VirtualStatement @ !>",
			L"[496][_StateInput] BEGIN ",
			L"[497][_StateInput] END [ENDING]",
			L"[498][_StateInput]< \"$state_input\" @ NAME \"(\" { _FunctionArgument ; \",\" } \")\" \";\" >",
			L"[499][_StateInput]< \"$state_input\" NAME \"(\" @ { _FunctionArgument ; \",\" } \")\" \";\" >",
			L"[500][_StateInput]< \"$state_input\" NAME \"(\" { _FunctionArgument ; \",\" @ } \")\" \";\" >",
			L"[501][_StateInput]< \"$state_input\" NAME \"(\" { _FunctionArgument ; \",\" } \")\" \";\" @ >",
			L"[502][_StateInput]< \"$state_input\" NAME \"(\" { _FunctionArgument ; \",\" } \")\" @ \";\" >",
			L"[503][_StateInput]< \"$state_input\" NAME \"(\" { _FunctionArgument @ ; \",\" } \")\" \";\" >",
			L"[504][_StateInput]< \"$state_input\" NAME @ \"(\" { _FunctionArgument ; \",\" } \")\" \";\" >",
			L"[505][_StateDecl] BEGIN ",
			L"[506][_StateDecl] END [ENDING]",
			L"[507][_StateDecl]< \"$state\" ( \"default\" @ | NAME ) \"(\" { _FunctionArgument ; \",\" } \")\" _Block >",
			L"[508][_StateDecl]< \"$state\" ( \"default\" | NAME ) \"(\" @ { _FunctionArgument ; \",\" } \")\" _Block >",
			L"[509][_StateDecl]< \"$state\" ( \"default\" | NAME ) \"(\" { _FunctionArgument ; \",\" @ } \")\" _Block >",
			L"[510][_StateDecl]< \"$state\" ( \"default\" | NAME ) \"(\" { _FunctionArgument ; \",\" } \")\" @ _Block >",
			L"[511][_StateDecl]< \"$state\" ( \"default\" | NAME ) \"(\" { _FunctionArgument ; \",\" } \")\" _Block @ >",
			L"[512][_StateDecl]< \"$state\" ( \"default\" | NAME ) \"(\" { _FunctionArgument @ ; \",\" } \")\" _Block >",
			L"[513][_StateDecl]< \"$state\" ( \"default\" | NAME @ ) \"(\" { _FunctionArgument ; \",\" } \")\" _Block >",
			L"[514][_StateDecl]< \"$state\" @ ( \"default\" | NAME ) \"(\" { _FunctionArgument ; \",\" } \")\" _Block >",
			L"[515][_StateMachine] BEGIN ",
			L"[516][_StateMachine] END [ENDING]",
			L"[517][_StateMachine]< \"$state_machine\" \"{\" @ { ( _StateInput | _StateDecl ) } \"}\" >",
			L"[518][_StateMachine]< \"$state_machine\" \"{\" { ( _StateInput @ | _StateDecl ) } \"}\" >",
			L"[519][_StateMachine]< \"$state_machine\" \"{\" { ( _StateInput | _StateDecl ) } \"}\" @ >",
			L"[520][_StateMachine]< \"$state_machine\" \"{\" { ( _StateInput | _StateDecl @ ) } \"}\" >",
			L"[521][_StateMachine]< \"$state_machine\" @ \"{\" { ( _StateInput | _StateDecl ) } \"}\" >",
			L"[522][_Attribute] BEGIN ",
			L"[523][_Attribute] END [ENDING]",
			L"[524][_Attribute]< \"@\" @ NAME \":\" NAME [ \"(\" _Expression \")\" ] >",
			L"[525][_Attribute]< \"@\" NAME \":\" @ NAME [ \"(\" _Expression \")\" ] >",
			L"[526][_Attribute]< \"@\" NAME \":\" NAME @ [ \"(\" _Expression \")\" ] >",
			L"[527][_Attribute]< \"@\" NAME \":\" NAME [ \"(\" @ _Expression \")\" ] >",
			L"[528][_Attribute]< \"@\" NAME \":\" NAME [ \"(\" _Expression \")\" @ ] >",
			L"[529][_Attribute]< \"@\" NAME \":\" NAME [ \"(\" _Expression @ \")\" ] >",
			L"[530][_Attribute]< \"@\" NAME @ \":\" NAME [ \"(\" _Expression \")\" ] >",
			L"[531][_Namespace] BEGIN ",
			L"[532][_Namespace] END [ENDING]",
			L"[533][_Namespace]< \"namespace\" @ NAME \"{\" { _Declaration } \"}\" >",
			L"[534][_Namespace]< \"namespace\" NAME \"{\" @ { _Declaration } \"}\" >",
			L"[535][_Namespace]< \"namespace\" NAME \"{\" { _Declaration @ } \"}\" >",
			L"[536][_Namespace]< \"namespace\" NAME \"{\" { _Declaration } \"}\" @ >",
			L"[537][_Namespace]< \"namespace\" NAME @ \"{\" { _Declaration } \"}\" >",
			L"[538][_FunctionArgument] BEGIN ",
			L"[539][_FunctionArgument] END [ENDING]",
			L"[540][_FunctionArgument]< { _Attribute @ } NAME \":\" _Type >",
			L"[541][_FunctionArgument]< { _Attribute } NAME \":\" @ _Type >",
			L"[542][_FunctionArgument]< { _Attribute } NAME \":\" _Type @ >",
			L"[543][_FunctionArgument]< { _Attribute } NAME @ \":\" _Type >",
			L"[544][_FunctionStat] BEGIN ",
			L"[545][_FunctionStat] END [ENDING]",
			L"[546][_FunctionStat]<! !_Block @ !>",
			L"[547][_FunctionStat]<! !_CoProvider @ !>",
			L"[548][_Function] BEGIN ",
			L"[549][_Function] END [ENDING]",
			L"[550][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" @ { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[551][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" @ } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[552][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" @ _Type ( _FunctionStat | \";\" ) ) >",
			L"[553][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat @ | \";\" ) ) >",
			L"[554][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" @ ) ) >",
			L"[555][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type @ ( _FunctionStat | \";\" ) ) >",
			L"[556][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" @ \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[557][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument @ ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[558][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" @ { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[559][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" @ } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[560][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" @ _Type ( _FunctionStat | \";\" ) ) >",
			L"[561][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat @ | \";\" ) ) >",
			L"[562][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" @ ) ) >",
			L"[563][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type @ ( _FunctionStat | \";\" ) ) >",
			L"[564][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" @ \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[565][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument @ ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[566][_Function]< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" ) NAME @ ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >",
			L"[567][_Function]{{< ( \"static\" \"func\" @ | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) > ; < ( \"static\" \"func\" @ | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >}}",
			L"[568][_Function]{{< ( \"static\" \"func\" | \"override\" \"func\" @ | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) > ; < ( \"static\" \"func\" | \"override\" \"func\" @ | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >}}",
			L"[569][_Function]{{< ( \"static\" \"func\" | \"override\" \"func\" | \"func\" @ ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) > ; < ( \"static\" \"func\" | \"override\" \"func\" | \"func\" @ ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >}}",
			L"[570][_Function]{{< ( \"static\" \"func\" | \"override\" @ \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) > ; < ( \"static\" \"func\" | \"override\" @ \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >}}",
			L"[571][_Function]{{< ( \"static\" @ \"func\" | \"override\" \"func\" | \"func\" ) ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) > ; < ( \"static\" @ \"func\" | \"override\" \"func\" | \"func\" ) NAME ( \"(\" { _FunctionArgument ; \",\" } \")\" \":\" _Type ( _FunctionStat | \";\" ) ) >}}",
			L"[572][_Variable] BEGIN ",
			L"[573][_Variable] END [ENDING]",
			L"[574][_Variable]< \"var\" @ NAME [ \":\" _Type ] \"=\" _Expression \";\" >",
			L"[575][_Variable]< \"var\" NAME @ [ \":\" _Type ] \"=\" _Expression \";\" >",
			L"[576][_Variable]< \"var\" NAME [ \":\" @ _Type ] \"=\" _Expression \";\" >",
			L"[577][_Variable]< \"var\" NAME [ \":\" _Type @ ] \"=\" _Expression \";\" >",
			L"[578][_Variable]< \"var\" NAME [ \":\" _Type ] \"=\" @ _Expression \";\" >",
			L"[579][_Variable]< \"var\" NAME [ \":\" _Type ] \"=\" _Expression \";\" @ >",
			L"[580][_Variable]< \"var\" NAME [ \":\" _Type ] \"=\" _Expression @ \";\" >",
			L"[581][_Event] BEGIN ",
			L"[582][_Event] END [ENDING]",
			L"[583][_Event]< \"event\" @ NAME \"(\" { _Type ; \",\" } \")\" \";\" >",
			L"[584][_Event]< \"event\" NAME \"(\" @ { _Type ; \",\" } \")\" \";\" >",
			L"[585][_Event]< \"event\" NAME \"(\" { _Type ; \",\" @ } \")\" \";\" >",
			L"[586][_Event]< \"event\" NAME \"(\" { _Type ; \",\" } \")\" \";\" @ >",
			L"[587][_Event]< \"event\" NAME \"(\" { _Type ; \",\" } \")\" @ \";\" >",
			L"[588][_Event]< \"event\" NAME \"(\" { _Type @ ; \",\" } \")\" \";\" >",
			L"[589][_Event]< \"event\" NAME @ \"(\" { _Type ; \",\" } \")\" \";\" >",
			L"[590][_Property] BEGIN ",
			L"[591][_Property] END [ENDING]",
			L"[592][_Property]< \"prop\" @ NAME \":\" _Type \"{\" NAME [ \",\" NAME ] [ \":\" NAME ] \"}\" >",
			L"[593][_Property]< \"prop\" NAME \":\" @ _Type \"{\" NAME [ \",\" NAME ] [ \":\" NAME ] \"}\" >",
			L"[594][_Property]< \"prop\" NAME \":\" _Type \"{\" @ NAME [ \",\" NAME ] [ \":\" NAME ] \"}\" >",
			L"[595][_Property]< \"prop\" NAME \":\" _Type \"{\" NAME @ [ \",\" NAME ] [ \":\" NAME ] \"}\" >",
			L"[596][_Property]< \"prop\" NAME \":\" _Type \"{\" NAME [ \",\" @ NAME ] [ \":\" NAME ] \"}\" >",
			L"[597][_Property]< \"prop\" NAME \":\" _Type \"{\" NAME [ \",\" NAME @ ] [ \":\" NAME ] \"}\" >",
			L"[598][_Property]< \"prop\" NAME \":\" _Type \"{\" NAME [ \",\" NAME ] [ \":\" @ NAME ] \"}\" >",
			L"[599][_Property]< \"prop\" NAME \":\" _Type \"{\" NAME [ \",\" NAME ] [ \":\" NAME @ ] \"}\" >",
			L"[600][_Property]< \"prop\" NAME \":\" _Type \"{\" NAME [ \",\" NAME ] [ \":\" NAME ] \"}\" @ >",
			L"[601][_Property]< \"prop\" NAME \":\" _Type @ \"{\" NAME [ \",\" NAME ] [ \":\" NAME ] \"}\" >",
			L"[602][_Property]< \"prop\" NAME @ \":\" _Type \"{\" NAME [ \",\" NAME ] [ \":\" NAME ] \"}\" >",
			L"[603][_StaticInit] BEGIN ",
			L"[604][_StaticInit] END [ENDING]",
			L"[605][_StaticInit]< \"static\" @ _Block >",
			L"[606][_StaticInit]< \"static\" _Block @ >",
			L"[607][_BaseConstructorCall] BEGIN ",
			L"[608][_BaseConstructorCall] END [ENDING]",
			L"[609][_BaseConstructorCall]< _Type \"(\" @ [ _Expression { \",\" _Expression } ] \")\" >",
			L"[610][_BaseConstructorCall]< _Type \"(\" [ _Expression @ { \",\" _Expression } ] \")\" >",
			L"[611][_BaseConstructorCall]< _Type \"(\" [ _Expression { \",\" @ _Expression } ] \")\" >",
			L"[612][_BaseConstructorCall]< _Type \"(\" [ _Expression { \",\" _Expression @ } ] \")\" >",
			L"[613][_BaseConstructorCall]< _Type \"(\" [ _Expression { \",\" _Expression } ] \")\" @ >",
			L"[614][_BaseConstructorCall]< _Type @ \"(\" [ _Expression { \",\" _Expression } ] \")\" >",
			L"[615][_Constructor] BEGIN ",
			L"[616][_Constructor] END [ENDING]",
			L"[617][_Constructor]< ( \"new\" @ | \"new\" \"*\" ) \"(\" { _FunctionArgument ; \",\" } \")\" [ \":\" { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[618][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" @ { _FunctionArgument ; \",\" } \")\" [ \":\" { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[619][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" { _FunctionArgument ; \",\" @ } \")\" [ \":\" { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[620][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" { _FunctionArgument ; \",\" } \")\" @ [ \":\" { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[621][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" { _FunctionArgument ; \",\" } \")\" [ \":\" @ { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[622][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" { _FunctionArgument ; \",\" } \")\" [ \":\" { _BaseConstructorCall ; \",\" @ } ] _Block >",
			L"[623][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" { _FunctionArgument ; \",\" } \")\" [ \":\" { _BaseConstructorCall ; \",\" } ] _Block @ >",
			L"[624][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" { _FunctionArgument ; \",\" } \")\" [ \":\" { _BaseConstructorCall @ ; \",\" } ] _Block >",
			L"[625][_Constructor]< ( \"new\" | \"new\" \"*\" ) \"(\" { _FunctionArgument @ ; \",\" } \")\" [ \":\" { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[626][_Constructor]< ( \"new\" | \"new\" \"*\" @ ) \"(\" { _FunctionArgument ; \",\" } \")\" [ \":\" { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[627][_Constructor]< ( \"new\" | \"new\" @ \"*\" ) \"(\" { _FunctionArgument ; \",\" } \")\" [ \":\" { _BaseConstructorCall ; \",\" } ] _Block >",
			L"[628][_Destructor] BEGIN ",
			L"[629][_Destructor] END [ENDING]",
			L"[630][_Destructor]< \"delete\" @ _Block >",
			L"[631][_Destructor]< \"delete\" _Block @ >",
			L"[632][_Class] BEGIN ",
			L"[633][_Class] END [ENDING]",
			L"[634][_Class]< \"class\" @ NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[635][_Class]< \"class\" NAME ( [ \":\" @ { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[636][_Class]< \"class\" NAME ( [ \":\" { _Type ; \",\" @ } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[637][_Class]< \"class\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" @ { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[638][_Class]< \"class\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration @ } [ _StateMachine ] \"}\" ) >",
			L"[639][_Class]< \"class\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine @ ] \"}\" ) >",
			L"[640][_Class]< \"class\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" @ ) >",
			L"[641][_Class]< \"class\" NAME ( [ \":\" { _Type @ ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[642][_Class]< \"class\" NAME @ ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[643][_Class]< \"interface\" NAME \"*\" ( [ \":\" @ { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[644][_Class]< \"interface\" NAME \"*\" ( [ \":\" { _Type ; \",\" @ } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[645][_Class]< \"interface\" NAME \"*\" ( [ \":\" { _Type ; \",\" } ] \"{\" @ { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[646][_Class]< \"interface\" NAME \"*\" ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration @ } [ _StateMachine ] \"}\" ) >",
			L"[647][_Class]< \"interface\" NAME \"*\" ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine @ ] \"}\" ) >",
			L"[648][_Class]< \"interface\" NAME \"*\" ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" @ ) >",
			L"[649][_Class]< \"interface\" NAME \"*\" ( [ \":\" { _Type @ ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[650][_Class]< \"interface\" NAME \"*\" @ ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[651][_Class]< \"interface\" NAME ( [ \":\" @ { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[652][_Class]< \"interface\" NAME ( [ \":\" { _Type ; \",\" @ } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[653][_Class]< \"interface\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" @ { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[654][_Class]< \"interface\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration @ } [ _StateMachine ] \"}\" ) >",
			L"[655][_Class]< \"interface\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine @ ] \"}\" ) >",
			L"[656][_Class]< \"interface\" NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" @ ) >",
			L"[657][_Class]< \"interface\" NAME ( [ \":\" { _Type @ ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >",
			L"[658][_Class]{{< \"interface\" @ NAME \"*\" ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) > ; < \"interface\" @ NAME ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >}}",
			L"[659][_Class]{{< \"interface\" NAME @ \"*\" ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) > ; < \"interface\" NAME @ ( [ \":\" { _Type ; \",\" } ] \"{\" { _Declaration } [ _StateMachine ] \"}\" ) >}}",
			L"[660][_EnumItemInt] BEGIN ",
			L"[661][_EnumItemInt] END [ENDING]",
			L"[662][_EnumItemInt]< NAME @ >",
			L"[663][_EnumItem] BEGIN ",
			L"[664][_EnumItem] END [ENDING]",
			L"[665][_EnumItem]< { _Attribute @ } NAME \"=\" ( INTEGER ) \",\" >",
			L"[666][_EnumItem]< { _Attribute } NAME \"=\" ( INTEGER ) \",\" @ >",
			L"[667][_EnumItem]< { _Attribute } NAME \"=\" ( INTEGER @ ) \",\" >",
			L"[668][_EnumItem]< { _Attribute } NAME \"=\" @ ( INTEGER ) \",\" >",
			L"[669][_EnumItem]< { _Attribute } NAME @ \"=\" ( INTEGER ) \",\" >",
			L"[670][_EnumItemWithFlags] BEGIN ",
			L"[671][_EnumItemWithFlags] END [ENDING]",
			L"[672][_EnumItemWithFlags]< { _Attribute @ } NAME \"=\" ( ( INTEGER ) | ( _EnumItemInt { \"|\" _EnumItemInt } ) ) \",\" >",
			L"[673][_EnumItemWithFlags]< { _Attribute } NAME \"=\" ( ( INTEGER ) | ( _EnumItemInt @ { \"|\" _EnumItemInt } ) ) \",\" >",
			L"[674][_EnumItemWithFlags]< { _Attribute } NAME \"=\" ( ( INTEGER ) | ( _EnumItemInt { \"|\" @ _EnumItemInt } ) ) \",\" >",
			L"[675][_EnumItemWithFlags]< { _Attribute } NAME \"=\" ( ( INTEGER ) | ( _EnumItemInt { \"|\" _EnumItemInt @ } ) ) \",\" >",
			L"[676][_EnumItemWithFlags]< { _Attribute } NAME \"=\" ( ( INTEGER ) | ( _EnumItemInt { \"|\" _EnumItemInt } ) ) \",\" @ >",
			L"[677][_EnumItemWithFlags]< { _Attribute } NAME \"=\" ( ( INTEGER @ ) | ( _EnumItemInt { \"|\" _EnumItemInt } ) ) \",\" >",
			L"[678][_EnumItemWithFlags]< { _Attribute } NAME \"=\" @ ( ( INTEGER ) | ( _EnumItemInt { \"|\" _EnumItemInt } ) ) \",\" >",
			L"[679][_EnumItemWithFlags]< { _Attribute } NAME @ \"=\" ( ( INTEGER ) | ( _EnumItemInt { \"|\" _EnumItemInt } ) ) \",\" >",
			L"[680][_Enum] BEGIN ",
			L"[681][_Enum] END [ENDING]",
			L"[682][_Enum]< \"enum\" @ NAME \"{\" _EnumItem { _EnumItem } \"}\" >",
			L"[683][_Enum]< \"enum\" NAME \"{\" @ _EnumItem { _EnumItem } \"}\" >",
			L"[684][_Enum]< \"enum\" NAME \"{\" _EnumItem @ { _EnumItem } \"}\" >",
			L"[685][_Enum]< \"enum\" NAME \"{\" _EnumItem { _EnumItem @ } \"}\" >",
			L"[686][_Enum]< \"enum\" NAME \"{\" _EnumItem { _EnumItem } \"}\" @ >",
			L"[687][_Enum]< \"enum\" NAME @ \"{\" _EnumItem { _EnumItem } \"}\" >",
			L"[688][_Enum]< \"flagenum\" @ NAME \"{\" _EnumItemWithFlags { _EnumItemWithFlags } \"}\" >",
			L"[689][_Enum]< \"flagenum\" NAME \"{\" @ _EnumItemWithFlags { _EnumItemWithFlags } \"}\" >",
			L"[690][_Enum]< \"flagenum\" NAME \"{\" _EnumItemWithFlags @ { _EnumItemWithFlags } \"}\" >",
			L"[691][_Enum]< \"flagenum\" NAME \"{\" _EnumItemWithFlags { _EnumItemWithFlags @ } \"}\" >",
			L"[692][_Enum]< \"flagenum\" NAME \"{\" _EnumItemWithFlags { _EnumItemWithFlags } \"}\" @ >",
			L"[693][_Enum]< \"flagenum\" NAME @ \"{\" _EnumItemWithFlags { _EnumItemWithFlags } \"}\" >",
			L"[694][_StructMember] BEGIN ",
			L"[695][_StructMember] END [ENDING]",
			L"[696][_StructMember]< { _Attribute @ } NAME \":\" _Type \";\" >",
			L"[697][_StructMember]< { _Attribute } NAME \":\" @ _Type \";\" >",
			L"[698][_StructMember]< { _Attribute } NAME \":\" _Type \";\" @ >",
			L"[699][_StructMember]< { _Attribute } NAME \":\" _Type @ \";\" >",
			L"[700][_StructMember]< { _Attribute } NAME @ \":\" _Type \";\" >",
			L"[701][_Struct] BEGIN ",
			L"[702][_Struct] END [ENDING]",
			L"[703][_Struct]< \"struct\" @ NAME \"{\" { _StructMember } \"}\" >",
			L"[704][_Struct]< \"struct\" NAME \"{\" @ { _StructMember } \"}\" >",
			L"[705][_Struct]< \"struct\" NAME \"{\" { _StructMember @ } \"}\" >",
			L"[706][_Struct]< \"struct\" NAME \"{\" { _StructMember } \"}\" @ >",
			L"[707][_Struct]< \"struct\" NAME @ \"{\" { _StructMember } \"}\" >",
			L"[708][_AutoProperty] BEGIN ",
			L"[709][_AutoProperty] END [ENDING]",
			L"[710][_AutoProperty]< ( \"static\" \"prop\" @ | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[711][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" @ | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[712][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" @ _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[713][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type @ [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[714][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" @ _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[715][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression @ ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[716][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" @ | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[717][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" @ | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[718][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" @ | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[719][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" @ ) >",
			L"[720][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" @ \"}\" ) >",
			L"[721][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" @ \"observe\" \"}\" ) >",
			L"[722][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" @ \"not\" \"observe\" \"}\" ) >",
			L"[723][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" @ \",\" \"not\" \"observe\" \"}\" ) >",
			L"[724][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" @ \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[725][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" @ \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[726][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" @ \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[727][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" @ \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[728][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" @ \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[729][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" @ \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[730][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" @ \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[731][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME @ \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[732][_AutoProperty]< ( \"static\" \"prop\" | \"override\" \"prop\" | \"prop\" @ ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[733][_AutoProperty]< ( \"static\" \"prop\" | \"override\" @ \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[734][_AutoProperty]< ( \"static\" @ \"prop\" | \"override\" \"prop\" | \"prop\" ) NAME \":\" _Type [ \"=\" _Expression ] ( \"{\" \"}\" | \"{\" \"const\" \"}\" | \"{\" \"not\" \"observe\" \"}\" | \"{\" \"const\" \",\" \"not\" \"observe\" \"}\" ) >",
			L"[735][_CastResultInterface] BEGIN ",
			L"[736][_CastResultInterface] END [ENDING]",
			L"[737][_CastResultInterface]< \"$interface\" @ NAME \":\" _Type \"<\" _Type \">\" \";\" >",
			L"[738][_CastResultInterface]< \"$interface\" NAME \":\" @ _Type \"<\" _Type \">\" \";\" >",
			L"[739][_CastResultInterface]< \"$interface\" NAME \":\" _Type \"<\" @ _Type \">\" \";\" >",
			L"[740][_CastResultInterface]< \"$interface\" NAME \":\" _Type \"<\" _Type \">\" \";\" @ >",
			L"[741][_CastResultInterface]< \"$interface\" NAME \":\" _Type \"<\" _Type \">\" @ \";\" >",
			L"[742][_CastResultInterface]< \"$interface\" NAME \":\" _Type \"<\" _Type @ \">\" \";\" >",
			L"[743][_CastResultInterface]< \"$interface\" NAME \":\" _Type @ \"<\" _Type \">\" \";\" >",
			L"[744][_CastResultInterface]< \"$interface\" NAME @ \":\" _Type \"<\" _Type \">\" \";\" >",
			L"[745][_DeclarationCandidates] BEGIN ",
			L"[746][_DeclarationCandidates] END [ENDING]",
			L"[747][_DeclarationCandidates]<! !_AutoProperty @ !>",
			L"[748][_DeclarationCandidates]<! !_CastResultInterface @ !>",
			L"[749][_DeclarationCandidates]<! !_Class @ !>",
			L"[750][_DeclarationCandidates]<! !_Constructor @ !>",
			L"[751][_DeclarationCandidates]<! !_Destructor @ !>",
			L"[752][_DeclarationCandidates]<! !_Enum @ !>",
			L"[753][_DeclarationCandidates]<! !_Event @ !>",
			L"[754][_DeclarationCandidates]<! !_Function @ !>",
			L"[755][_DeclarationCandidates]<! !_Namespace @ !>",
			L"[756][_DeclarationCandidates]<! !_Property @ !>",
			L"[757][_DeclarationCandidates]<! !_StaticInit @ !>",
			L"[758][_DeclarationCandidates]<! !_Struct @ !>",
			L"[759][_DeclarationCandidates]<! !_Variable @ !>",
			L"[760][_Declaration] BEGIN ",
			L"[761][_Declaration] END [ENDING]",
			L"[762][_Declaration]<! { _Attribute @ } !_DeclarationCandidates !>",
			L"[763][_Declaration]<! { _Attribute } !_DeclarationCandidates @ !>",
			L"[764][_UsingFragment] BEGIN ",
			L"[765][_UsingFragment] END [ENDING]",
			L"[766][_UsingFragment]< \"*\" @ >",
			L"[767][_UsingFragment]< NAME @ >",
			L"[768][_UsingItem] BEGIN ",
			L"[769][_UsingItem] END [ENDING]",
			L"[770][_UsingItem]< _UsingFragment @ { _UsingFragment } >",
			L"[771][_UsingItem]< _UsingFragment { _UsingFragment @ } >",
			L"[772][_UsingPath] BEGIN ",
			L"[773][_UsingPath] END [ENDING]",
			L"[774][_UsingPath]< \"using\" @ _UsingItem { \"::\" _UsingItem } \";\" >",
			L"[775][_UsingPath]< \"using\" _UsingItem @ { \"::\" _UsingItem } \";\" >",
			L"[776][_UsingPath]< \"using\" _UsingItem { \"::\" @ _UsingItem } \";\" >",
			L"[777][_UsingPath]< \"using\" _UsingItem { \"::\" _UsingItem @ } \";\" >",
			L"[778][_UsingPath]< \"using\" _UsingItem { \"::\" _UsingItem } \";\" @ >",
			L"[779][_Module] BEGIN ",
			L"[780][_Module] END [ENDING]",
			L"[781][_Module]< \"module\" ( NAME \";\" @ { _UsingPath } { _Declaration } ) >",
			L"[782][_Module]< \"module\" ( NAME \";\" { _UsingPath @ } { _Declaration } ) >",
			L"[783][_Module]< \"module\" ( NAME \";\" { _UsingPath } { _Declaration @ } ) >",
			L"[784][_Module]< \"module\" ( NAME @ \";\" { _UsingPath } { _Declaration } ) >",
			L"[785][_Module]< \"module\" @ ( NAME \";\" { _UsingPath } { _Declaration } ) >",
			L"[786][_Module]< \"unit\" ( NAME \";\" @ { _UsingPath } { _Declaration } ) >",
			L"[787][_Module]< \"unit\" ( NAME \";\" { _UsingPath @ } { _Declaration } ) >",
			L"[788][_Module]< \"unit\" ( NAME \";\" { _UsingPath } { _Declaration @ } ) >",
			L"[789][_Module]< \"unit\" ( NAME @ \";\" { _UsingPath } { _Declaration } ) >",
			L"[790][_Module]< \"unit\" @ ( NAME \";\" { _UsingPath } { _Declaration } ) >",
		};
		return results[index];
	}

	Parser::Parser()
		: vl::glr::ParserBase<WorkflowTokens, ParserStates, WorkflowAstInsReceiver>(&WorkflowTokenDeleter, &WorkflowLexerData, &WorkflowParserData)
	{
	}

	vl::WString Parser::GetClassName(vl::vint32_t classIndex) const
	{
		return vl::WString::Unmanaged(WorkflowTypeName((WorkflowClasses)classIndex));
	}

	vl::vint32_t Parser::FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const
	{
		return -1;
	}

	vl::Ptr<vl::workflow::WfType> Parser::Parse_Type(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<vl::workflow::WfType, ParserStates::_Type>(input, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfType> Parser::Parse_Type(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<vl::workflow::WfType, ParserStates::_Type>(tokens, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfExpression> Parser::Parse_Expression(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<vl::workflow::WfExpression, ParserStates::_Expression>(input, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfExpression> Parser::Parse_Expression(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<vl::workflow::WfExpression, ParserStates::_Expression>(tokens, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfCoProviderStatement> Parser::Parse_CoProvider(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<vl::workflow::WfCoProviderStatement, ParserStates::_CoProvider>(input, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfCoProviderStatement> Parser::Parse_CoProvider(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<vl::workflow::WfCoProviderStatement, ParserStates::_CoProvider>(tokens, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfStatement> Parser::Parse_Statement(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<vl::workflow::WfStatement, ParserStates::_Statement>(input, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfStatement> Parser::Parse_Statement(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<vl::workflow::WfStatement, ParserStates::_Statement>(tokens, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfDeclaration> Parser::Parse_Declaration(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<vl::workflow::WfDeclaration, ParserStates::_Declaration>(input, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfDeclaration> Parser::Parse_Declaration(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<vl::workflow::WfDeclaration, ParserStates::_Declaration>(tokens, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfModule> Parser::Parse_Module(const vl::WString& input, vl::vint codeIndex) const
	{
		 return ParseWithString<vl::workflow::WfModule, ParserStates::_Module>(input, this, codeIndex);
	}

	vl::Ptr<vl::workflow::WfModule> Parser::Parse_Module(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex) const
	{
		 return ParseWithTokens<vl::workflow::WfModule, ParserStates::_Module>(tokens, this, codeIndex);
	}
}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOW_ASSEMBLER.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Workflow
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow
{

/***********************************************************************
WorkflowAstInsReceiver : public vl::glr::AstInsReceiverBase
***********************************************************************/

	vl::Ptr<vl::glr::ParsingAstBase> WorkflowAstInsReceiver::CreateAstNode(vl::vint32_t type)
	{
		auto cppTypeName = WorkflowCppTypeName((WorkflowClasses)type);
		switch((WorkflowClasses)type)
		{
		case WorkflowClasses::AttachEventExpression:
			return vl::Ptr(new vl::workflow::WfAttachEventExpression);
		case WorkflowClasses::Attribute:
			return vl::Ptr(new vl::workflow::WfAttribute);
		case WorkflowClasses::AutoPropertyDeclaration:
			return vl::Ptr(new vl::workflow::WfAutoPropertyDeclaration);
		case WorkflowClasses::BaseConstructorCall:
			return vl::Ptr(new vl::workflow::WfBaseConstructorCall);
		case WorkflowClasses::BinaryExpression:
			return vl::Ptr(new vl::workflow::WfBinaryExpression);
		case WorkflowClasses::BindExpression:
			return vl::Ptr(new vl::workflow::WfBindExpression);
		case WorkflowClasses::BlockStatement:
			return vl::Ptr(new vl::workflow::WfBlockStatement);
		case WorkflowClasses::BreakStatement:
			return vl::Ptr(new vl::workflow::WfBreakStatement);
		case WorkflowClasses::CallExpression:
			return vl::Ptr(new vl::workflow::WfCallExpression);
		case WorkflowClasses::CastResultInterfaceDeclaration:
			return vl::Ptr(new vl::workflow::WfCastResultInterfaceDeclaration);
		case WorkflowClasses::ChildExpression:
			return vl::Ptr(new vl::workflow::WfChildExpression);
		case WorkflowClasses::ChildType:
			return vl::Ptr(new vl::workflow::WfChildType);
		case WorkflowClasses::ClassDeclaration:
			return vl::Ptr(new vl::workflow::WfClassDeclaration);
		case WorkflowClasses::CoOperatorExpression:
			return vl::Ptr(new vl::workflow::WfCoOperatorExpression);
		case WorkflowClasses::CoOperatorStatement:
			return vl::Ptr(new vl::workflow::WfCoOperatorStatement);
		case WorkflowClasses::CoPauseStatement:
			return vl::Ptr(new vl::workflow::WfCoPauseStatement);
		case WorkflowClasses::CoProviderStatement:
			return vl::Ptr(new vl::workflow::WfCoProviderStatement);
		case WorkflowClasses::ConstructorArgument:
			return vl::Ptr(new vl::workflow::WfConstructorArgument);
		case WorkflowClasses::ConstructorDeclaration:
			return vl::Ptr(new vl::workflow::WfConstructorDeclaration);
		case WorkflowClasses::ConstructorExpression:
			return vl::Ptr(new vl::workflow::WfConstructorExpression);
		case WorkflowClasses::ContinueStatement:
			return vl::Ptr(new vl::workflow::WfContinueStatement);
		case WorkflowClasses::DeleteStatement:
			return vl::Ptr(new vl::workflow::WfDeleteStatement);
		case WorkflowClasses::DestructorDeclaration:
			return vl::Ptr(new vl::workflow::WfDestructorDeclaration);
		case WorkflowClasses::DetachEventExpression:
			return vl::Ptr(new vl::workflow::WfDetachEventExpression);
		case WorkflowClasses::EnumDeclaration:
			return vl::Ptr(new vl::workflow::WfEnumDeclaration);
		case WorkflowClasses::EnumItem:
			return vl::Ptr(new vl::workflow::WfEnumItem);
		case WorkflowClasses::EnumItemIntersection:
			return vl::Ptr(new vl::workflow::WfEnumItemIntersection);
		case WorkflowClasses::EnumerableType:
			return vl::Ptr(new vl::workflow::WfEnumerableType);
		case WorkflowClasses::EventDeclaration:
			return vl::Ptr(new vl::workflow::WfEventDeclaration);
		case WorkflowClasses::ExpectedTypeCastExpression:
			return vl::Ptr(new vl::workflow::WfExpectedTypeCastExpression);
		case WorkflowClasses::ExpressionStatement:
			return vl::Ptr(new vl::workflow::WfExpressionStatement);
		case WorkflowClasses::FloatingExpression:
			return vl::Ptr(new vl::workflow::WfFloatingExpression);
		case WorkflowClasses::ForEachStatement:
			return vl::Ptr(new vl::workflow::WfForEachStatement);
		case WorkflowClasses::FormatExpression:
			return vl::Ptr(new vl::workflow::WfFormatExpression);
		case WorkflowClasses::FunctionArgument:
			return vl::Ptr(new vl::workflow::WfFunctionArgument);
		case WorkflowClasses::FunctionDeclaration:
			return vl::Ptr(new vl::workflow::WfFunctionDeclaration);
		case WorkflowClasses::FunctionExpression:
			return vl::Ptr(new vl::workflow::WfFunctionExpression);
		case WorkflowClasses::FunctionType:
			return vl::Ptr(new vl::workflow::WfFunctionType);
		case WorkflowClasses::GotoStatement:
			return vl::Ptr(new vl::workflow::WfGotoStatement);
		case WorkflowClasses::IfExpression:
			return vl::Ptr(new vl::workflow::WfIfExpression);
		case WorkflowClasses::IfStatement:
			return vl::Ptr(new vl::workflow::WfIfStatement);
		case WorkflowClasses::InferExpression:
			return vl::Ptr(new vl::workflow::WfInferExpression);
		case WorkflowClasses::IntegerExpression:
			return vl::Ptr(new vl::workflow::WfIntegerExpression);
		case WorkflowClasses::LetExpression:
			return vl::Ptr(new vl::workflow::WfLetExpression);
		case WorkflowClasses::LetVariable:
			return vl::Ptr(new vl::workflow::WfLetVariable);
		case WorkflowClasses::LiteralExpression:
			return vl::Ptr(new vl::workflow::WfLiteralExpression);
		case WorkflowClasses::MapType:
			return vl::Ptr(new vl::workflow::WfMapType);
		case WorkflowClasses::MemberExpression:
			return vl::Ptr(new vl::workflow::WfMemberExpression);
		case WorkflowClasses::MixinCastExpression:
			return vl::Ptr(new vl::workflow::WfMixinCastExpression);
		case WorkflowClasses::Module:
			return vl::Ptr(new vl::workflow::WfModule);
		case WorkflowClasses::ModuleUsingItem:
			return vl::Ptr(new vl::workflow::WfModuleUsingItem);
		case WorkflowClasses::ModuleUsingNameFragment:
			return vl::Ptr(new vl::workflow::WfModuleUsingNameFragment);
		case WorkflowClasses::ModuleUsingPath:
			return vl::Ptr(new vl::workflow::WfModuleUsingPath);
		case WorkflowClasses::ModuleUsingWildCardFragment:
			return vl::Ptr(new vl::workflow::WfModuleUsingWildCardFragment);
		case WorkflowClasses::NamespaceDeclaration:
			return vl::Ptr(new vl::workflow::WfNamespaceDeclaration);
		case WorkflowClasses::NewClassExpression:
			return vl::Ptr(new vl::workflow::WfNewClassExpression);
		case WorkflowClasses::NewCoroutineExpression:
			return vl::Ptr(new vl::workflow::WfNewCoroutineExpression);
		case WorkflowClasses::NewInterfaceExpression:
			return vl::Ptr(new vl::workflow::WfNewInterfaceExpression);
		case WorkflowClasses::NullableType:
			return vl::Ptr(new vl::workflow::WfNullableType);
		case WorkflowClasses::ObservableListType:
			return vl::Ptr(new vl::workflow::WfObservableListType);
		case WorkflowClasses::ObserveExpression:
			return vl::Ptr(new vl::workflow::WfObserveExpression);
		case WorkflowClasses::OrderedLambdaExpression:
			return vl::Ptr(new vl::workflow::WfOrderedLambdaExpression);
		case WorkflowClasses::OrderedNameExpression:
			return vl::Ptr(new vl::workflow::WfOrderedNameExpression);
		case WorkflowClasses::PredefinedType:
			return vl::Ptr(new vl::workflow::WfPredefinedType);
		case WorkflowClasses::PropertyDeclaration:
			return vl::Ptr(new vl::workflow::WfPropertyDeclaration);
		case WorkflowClasses::RaiseExceptionStatement:
			return vl::Ptr(new vl::workflow::WfRaiseExceptionStatement);
		case WorkflowClasses::RangeExpression:
			return vl::Ptr(new vl::workflow::WfRangeExpression);
		case WorkflowClasses::RawPointerType:
			return vl::Ptr(new vl::workflow::WfRawPointerType);
		case WorkflowClasses::ReferenceExpression:
			return vl::Ptr(new vl::workflow::WfReferenceExpression);
		case WorkflowClasses::ReferenceType:
			return vl::Ptr(new vl::workflow::WfReferenceType);
		case WorkflowClasses::ReturnStatement:
			return vl::Ptr(new vl::workflow::WfReturnStatement);
		case WorkflowClasses::SetTestingExpression:
			return vl::Ptr(new vl::workflow::WfSetTestingExpression);
		case WorkflowClasses::SharedPointerType:
			return vl::Ptr(new vl::workflow::WfSharedPointerType);
		case WorkflowClasses::StateDeclaration:
			return vl::Ptr(new vl::workflow::WfStateDeclaration);
		case WorkflowClasses::StateInput:
			return vl::Ptr(new vl::workflow::WfStateInput);
		case WorkflowClasses::StateInvokeStatement:
			return vl::Ptr(new vl::workflow::WfStateInvokeStatement);
		case WorkflowClasses::StateMachineDeclaration:
			return vl::Ptr(new vl::workflow::WfStateMachineDeclaration);
		case WorkflowClasses::StateSwitchArgument:
			return vl::Ptr(new vl::workflow::WfStateSwitchArgument);
		case WorkflowClasses::StateSwitchCase:
			return vl::Ptr(new vl::workflow::WfStateSwitchCase);
		case WorkflowClasses::StateSwitchStatement:
			return vl::Ptr(new vl::workflow::WfStateSwitchStatement);
		case WorkflowClasses::StaticInitDeclaration:
			return vl::Ptr(new vl::workflow::WfStaticInitDeclaration);
		case WorkflowClasses::StringExpression:
			return vl::Ptr(new vl::workflow::WfStringExpression);
		case WorkflowClasses::StructDeclaration:
			return vl::Ptr(new vl::workflow::WfStructDeclaration);
		case WorkflowClasses::StructMember:
			return vl::Ptr(new vl::workflow::WfStructMember);
		case WorkflowClasses::SwitchCase:
			return vl::Ptr(new vl::workflow::WfSwitchCase);
		case WorkflowClasses::SwitchStatement:
			return vl::Ptr(new vl::workflow::WfSwitchStatement);
		case WorkflowClasses::ThisExpression:
			return vl::Ptr(new vl::workflow::WfThisExpression);
		case WorkflowClasses::TopQualifiedExpression:
			return vl::Ptr(new vl::workflow::WfTopQualifiedExpression);
		case WorkflowClasses::TopQualifiedType:
			return vl::Ptr(new vl::workflow::WfTopQualifiedType);
		case WorkflowClasses::TryStatement:
			return vl::Ptr(new vl::workflow::WfTryStatement);
		case WorkflowClasses::TypeCastingExpression:
			return vl::Ptr(new vl::workflow::WfTypeCastingExpression);
		case WorkflowClasses::TypeOfExpressionExpression:
			return vl::Ptr(new vl::workflow::WfTypeOfExpressionExpression);
		case WorkflowClasses::TypeOfTypeExpression:
			return vl::Ptr(new vl::workflow::WfTypeOfTypeExpression);
		case WorkflowClasses::TypeTestingExpression:
			return vl::Ptr(new vl::workflow::WfTypeTestingExpression);
		case WorkflowClasses::UnaryExpression:
			return vl::Ptr(new vl::workflow::WfUnaryExpression);
		case WorkflowClasses::VariableDeclaration:
			return vl::Ptr(new vl::workflow::WfVariableDeclaration);
		case WorkflowClasses::VariableStatement:
			return vl::Ptr(new vl::workflow::WfVariableStatement);
		case WorkflowClasses::WhileStatement:
			return vl::Ptr(new vl::workflow::WfWhileStatement);
		default:
			return vl::glr::AssemblyThrowCannotCreateAbstractType(type, cppTypeName);
		}
	}

	void WorkflowAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value)
	{
		auto cppFieldName = WorkflowCppFieldName((WorkflowFields)field);
		switch((WorkflowFields)field)
		{
		case WorkflowFields::AttachEventExpression_event:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfAttachEventExpression::event, object, field, value, cppFieldName);
		case WorkflowFields::AttachEventExpression_function:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfAttachEventExpression::function, object, field, value, cppFieldName);
		case WorkflowFields::Attribute_value:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfAttribute::value, object, field, value, cppFieldName);
		case WorkflowFields::AutoPropertyDeclaration_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfAutoPropertyDeclaration::expression, object, field, value, cppFieldName);
		case WorkflowFields::AutoPropertyDeclaration_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfAutoPropertyDeclaration::type, object, field, value, cppFieldName);
		case WorkflowFields::BaseConstructorCall_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfBaseConstructorCall::arguments, object, field, value, cppFieldName);
		case WorkflowFields::BaseConstructorCall_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfBaseConstructorCall::type, object, field, value, cppFieldName);
		case WorkflowFields::BinaryExpression_first:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfBinaryExpression::first, object, field, value, cppFieldName);
		case WorkflowFields::BinaryExpression_second:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfBinaryExpression::second, object, field, value, cppFieldName);
		case WorkflowFields::BindExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfBindExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::BlockStatement_statements:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfBlockStatement::statements, object, field, value, cppFieldName);
		case WorkflowFields::CallExpression_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfCallExpression::arguments, object, field, value, cppFieldName);
		case WorkflowFields::CallExpression_function:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfCallExpression::function, object, field, value, cppFieldName);
		case WorkflowFields::CastResultInterfaceDeclaration_baseType:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfCastResultInterfaceDeclaration::baseType, object, field, value, cppFieldName);
		case WorkflowFields::CastResultInterfaceDeclaration_elementType:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfCastResultInterfaceDeclaration::elementType, object, field, value, cppFieldName);
		case WorkflowFields::ChildExpression_parent:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfChildExpression::parent, object, field, value, cppFieldName);
		case WorkflowFields::ChildType_parent:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfChildType::parent, object, field, value, cppFieldName);
		case WorkflowFields::ClassDeclaration_baseTypes:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfClassDeclaration::baseTypes, object, field, value, cppFieldName);
		case WorkflowFields::ClassDeclaration_declarations:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfClassDeclaration::declarations, object, field, value, cppFieldName);
		case WorkflowFields::CoOperatorStatement_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfCoOperatorStatement::arguments, object, field, value, cppFieldName);
		case WorkflowFields::CoPauseStatement_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfCoPauseStatement::statement, object, field, value, cppFieldName);
		case WorkflowFields::CoProviderStatement_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfCoProviderStatement::statement, object, field, value, cppFieldName);
		case WorkflowFields::ConstructorArgument_key:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfConstructorArgument::key, object, field, value, cppFieldName);
		case WorkflowFields::ConstructorArgument_value:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfConstructorArgument::value, object, field, value, cppFieldName);
		case WorkflowFields::ConstructorDeclaration_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfConstructorDeclaration::arguments, object, field, value, cppFieldName);
		case WorkflowFields::ConstructorDeclaration_baseConstructorCalls:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfConstructorDeclaration::baseConstructorCalls, object, field, value, cppFieldName);
		case WorkflowFields::ConstructorDeclaration_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfConstructorDeclaration::statement, object, field, value, cppFieldName);
		case WorkflowFields::ConstructorExpression_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfConstructorExpression::arguments, object, field, value, cppFieldName);
		case WorkflowFields::Declaration_attributes:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfDeclaration::attributes, object, field, value, cppFieldName);
		case WorkflowFields::DeleteStatement_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfDeleteStatement::expression, object, field, value, cppFieldName);
		case WorkflowFields::DestructorDeclaration_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfDestructorDeclaration::statement, object, field, value, cppFieldName);
		case WorkflowFields::DetachEventExpression_event:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfDetachEventExpression::event, object, field, value, cppFieldName);
		case WorkflowFields::DetachEventExpression_handler:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfDetachEventExpression::handler, object, field, value, cppFieldName);
		case WorkflowFields::EnumDeclaration_items:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfEnumDeclaration::items, object, field, value, cppFieldName);
		case WorkflowFields::EnumItem_attributes:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfEnumItem::attributes, object, field, value, cppFieldName);
		case WorkflowFields::EnumItem_intersections:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfEnumItem::intersections, object, field, value, cppFieldName);
		case WorkflowFields::EnumerableType_element:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfEnumerableType::element, object, field, value, cppFieldName);
		case WorkflowFields::EventDeclaration_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfEventDeclaration::arguments, object, field, value, cppFieldName);
		case WorkflowFields::ExpectedTypeCastExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfExpectedTypeCastExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::ExpressionStatement_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfExpressionStatement::expression, object, field, value, cppFieldName);
		case WorkflowFields::ForEachStatement_collection:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfForEachStatement::collection, object, field, value, cppFieldName);
		case WorkflowFields::ForEachStatement_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfForEachStatement::statement, object, field, value, cppFieldName);
		case WorkflowFields::FunctionArgument_attributes:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionArgument::attributes, object, field, value, cppFieldName);
		case WorkflowFields::FunctionArgument_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionArgument::type, object, field, value, cppFieldName);
		case WorkflowFields::FunctionDeclaration_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionDeclaration::arguments, object, field, value, cppFieldName);
		case WorkflowFields::FunctionDeclaration_returnType:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionDeclaration::returnType, object, field, value, cppFieldName);
		case WorkflowFields::FunctionDeclaration_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionDeclaration::statement, object, field, value, cppFieldName);
		case WorkflowFields::FunctionExpression_function:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionExpression::function, object, field, value, cppFieldName);
		case WorkflowFields::FunctionType_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionType::arguments, object, field, value, cppFieldName);
		case WorkflowFields::FunctionType_result:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfFunctionType::result, object, field, value, cppFieldName);
		case WorkflowFields::IfExpression_condition:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfIfExpression::condition, object, field, value, cppFieldName);
		case WorkflowFields::IfExpression_falseBranch:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfIfExpression::falseBranch, object, field, value, cppFieldName);
		case WorkflowFields::IfExpression_trueBranch:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfIfExpression::trueBranch, object, field, value, cppFieldName);
		case WorkflowFields::IfStatement_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfIfStatement::expression, object, field, value, cppFieldName);
		case WorkflowFields::IfStatement_falseBranch:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfIfStatement::falseBranch, object, field, value, cppFieldName);
		case WorkflowFields::IfStatement_trueBranch:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfIfStatement::trueBranch, object, field, value, cppFieldName);
		case WorkflowFields::IfStatement_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfIfStatement::type, object, field, value, cppFieldName);
		case WorkflowFields::InferExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfInferExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::InferExpression_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfInferExpression::type, object, field, value, cppFieldName);
		case WorkflowFields::LetExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfLetExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::LetExpression_variables:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfLetExpression::variables, object, field, value, cppFieldName);
		case WorkflowFields::LetVariable_value:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfLetVariable::value, object, field, value, cppFieldName);
		case WorkflowFields::MapType_key:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfMapType::key, object, field, value, cppFieldName);
		case WorkflowFields::MapType_value:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfMapType::value, object, field, value, cppFieldName);
		case WorkflowFields::MemberExpression_parent:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfMemberExpression::parent, object, field, value, cppFieldName);
		case WorkflowFields::MixinCastExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfMixinCastExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::MixinCastExpression_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfMixinCastExpression::type, object, field, value, cppFieldName);
		case WorkflowFields::Module_declarations:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfModule::declarations, object, field, value, cppFieldName);
		case WorkflowFields::Module_paths:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfModule::paths, object, field, value, cppFieldName);
		case WorkflowFields::ModuleUsingItem_fragments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfModuleUsingItem::fragments, object, field, value, cppFieldName);
		case WorkflowFields::ModuleUsingPath_items:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfModuleUsingPath::items, object, field, value, cppFieldName);
		case WorkflowFields::NamespaceDeclaration_declarations:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfNamespaceDeclaration::declarations, object, field, value, cppFieldName);
		case WorkflowFields::NewClassExpression_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfNewClassExpression::arguments, object, field, value, cppFieldName);
		case WorkflowFields::NewClassExpression_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfNewClassExpression::type, object, field, value, cppFieldName);
		case WorkflowFields::NewCoroutineExpression_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfNewCoroutineExpression::statement, object, field, value, cppFieldName);
		case WorkflowFields::NewInterfaceExpression_declarations:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfNewInterfaceExpression::declarations, object, field, value, cppFieldName);
		case WorkflowFields::NewInterfaceExpression_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfNewInterfaceExpression::type, object, field, value, cppFieldName);
		case WorkflowFields::NullableType_element:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfNullableType::element, object, field, value, cppFieldName);
		case WorkflowFields::ObservableListType_element:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfObservableListType::element, object, field, value, cppFieldName);
		case WorkflowFields::ObserveExpression_events:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfObserveExpression::events, object, field, value, cppFieldName);
		case WorkflowFields::ObserveExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfObserveExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::ObserveExpression_parent:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfObserveExpression::parent, object, field, value, cppFieldName);
		case WorkflowFields::OrderedLambdaExpression_body:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfOrderedLambdaExpression::body, object, field, value, cppFieldName);
		case WorkflowFields::PropertyDeclaration_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfPropertyDeclaration::type, object, field, value, cppFieldName);
		case WorkflowFields::RaiseExceptionStatement_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfRaiseExceptionStatement::expression, object, field, value, cppFieldName);
		case WorkflowFields::RangeExpression_begin:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfRangeExpression::begin, object, field, value, cppFieldName);
		case WorkflowFields::RangeExpression_end:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfRangeExpression::end, object, field, value, cppFieldName);
		case WorkflowFields::RawPointerType_element:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfRawPointerType::element, object, field, value, cppFieldName);
		case WorkflowFields::ReturnStatement_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfReturnStatement::expression, object, field, value, cppFieldName);
		case WorkflowFields::SetTestingExpression_collection:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSetTestingExpression::collection, object, field, value, cppFieldName);
		case WorkflowFields::SetTestingExpression_element:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSetTestingExpression::element, object, field, value, cppFieldName);
		case WorkflowFields::SharedPointerType_element:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSharedPointerType::element, object, field, value, cppFieldName);
		case WorkflowFields::StateDeclaration_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateDeclaration::arguments, object, field, value, cppFieldName);
		case WorkflowFields::StateDeclaration_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateDeclaration::statement, object, field, value, cppFieldName);
		case WorkflowFields::StateInput_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateInput::arguments, object, field, value, cppFieldName);
		case WorkflowFields::StateInvokeStatement_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateInvokeStatement::arguments, object, field, value, cppFieldName);
		case WorkflowFields::StateMachineDeclaration_inputs:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateMachineDeclaration::inputs, object, field, value, cppFieldName);
		case WorkflowFields::StateMachineDeclaration_states:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateMachineDeclaration::states, object, field, value, cppFieldName);
		case WorkflowFields::StateSwitchCase_arguments:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateSwitchCase::arguments, object, field, value, cppFieldName);
		case WorkflowFields::StateSwitchCase_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateSwitchCase::statement, object, field, value, cppFieldName);
		case WorkflowFields::StateSwitchStatement_caseBranches:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStateSwitchStatement::caseBranches, object, field, value, cppFieldName);
		case WorkflowFields::StaticInitDeclaration_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStaticInitDeclaration::statement, object, field, value, cppFieldName);
		case WorkflowFields::StructDeclaration_members:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStructDeclaration::members, object, field, value, cppFieldName);
		case WorkflowFields::StructMember_attributes:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStructMember::attributes, object, field, value, cppFieldName);
		case WorkflowFields::StructMember_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfStructMember::type, object, field, value, cppFieldName);
		case WorkflowFields::SwitchCase_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSwitchCase::expression, object, field, value, cppFieldName);
		case WorkflowFields::SwitchCase_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSwitchCase::statement, object, field, value, cppFieldName);
		case WorkflowFields::SwitchStatement_caseBranches:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSwitchStatement::caseBranches, object, field, value, cppFieldName);
		case WorkflowFields::SwitchStatement_defaultBranch:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSwitchStatement::defaultBranch, object, field, value, cppFieldName);
		case WorkflowFields::SwitchStatement_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfSwitchStatement::expression, object, field, value, cppFieldName);
		case WorkflowFields::TryStatement_catchStatement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTryStatement::catchStatement, object, field, value, cppFieldName);
		case WorkflowFields::TryStatement_finallyStatement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTryStatement::finallyStatement, object, field, value, cppFieldName);
		case WorkflowFields::TryStatement_protectedStatement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTryStatement::protectedStatement, object, field, value, cppFieldName);
		case WorkflowFields::TypeCastingExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTypeCastingExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::TypeCastingExpression_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTypeCastingExpression::type, object, field, value, cppFieldName);
		case WorkflowFields::TypeOfExpressionExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTypeOfExpressionExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::TypeOfTypeExpression_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTypeOfTypeExpression::type, object, field, value, cppFieldName);
		case WorkflowFields::TypeTestingExpression_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTypeTestingExpression::expression, object, field, value, cppFieldName);
		case WorkflowFields::TypeTestingExpression_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfTypeTestingExpression::type, object, field, value, cppFieldName);
		case WorkflowFields::UnaryExpression_operand:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfUnaryExpression::operand, object, field, value, cppFieldName);
		case WorkflowFields::VariableDeclaration_expression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVariableDeclaration::expression, object, field, value, cppFieldName);
		case WorkflowFields::VariableDeclaration_type:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVariableDeclaration::type, object, field, value, cppFieldName);
		case WorkflowFields::VariableStatement_variable:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVariableStatement::variable, object, field, value, cppFieldName);
		case WorkflowFields::VirtualCfeDeclaration_expandedDeclarations:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVirtualCfeDeclaration::expandedDeclarations, object, field, value, cppFieldName);
		case WorkflowFields::VirtualCfeExpression_expandedExpression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVirtualCfeExpression::expandedExpression, object, field, value, cppFieldName);
		case WorkflowFields::VirtualCseDeclaration_expandedDeclarations:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVirtualCseDeclaration::expandedDeclarations, object, field, value, cppFieldName);
		case WorkflowFields::VirtualCseExpression_expandedExpression:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVirtualCseExpression::expandedExpression, object, field, value, cppFieldName);
		case WorkflowFields::VirtualCseStatement_expandedStatement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfVirtualCseStatement::expandedStatement, object, field, value, cppFieldName);
		case WorkflowFields::WhileStatement_condition:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfWhileStatement::condition, object, field, value, cppFieldName);
		case WorkflowFields::WhileStatement_statement:
			return vl::glr::AssemblerSetObjectField(&vl::workflow::WfWhileStatement::statement, object, field, value, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotObject(field, cppFieldName);
		}
	}

	void WorkflowAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token, vl::vint32_t tokenIndex)
	{
		auto cppFieldName = WorkflowCppFieldName((WorkflowFields)field);
		switch((WorkflowFields)field)
		{
		case WorkflowFields::Attribute_category:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfAttribute::category, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::Attribute_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfAttribute::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::BlockStatement_endLabel:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfBlockStatement::endLabel, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::ChildExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfChildExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::ChildType_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfChildType::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::CoOperatorExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfCoOperatorExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::CoOperatorStatement_opName:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfCoOperatorStatement::opName, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::CoOperatorStatement_varName:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfCoOperatorStatement::varName, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::CoProviderStatement_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfCoProviderStatement::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::Declaration_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfDeclaration::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::EnumItem_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfEnumItem::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::EnumItem_number:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfEnumItem::number, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::EnumItemIntersection_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfEnumItemIntersection::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::FloatingExpression_value:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfFloatingExpression::value, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::ForEachStatement_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfForEachStatement::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::FormatExpression_value:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfFormatExpression::value, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::FunctionArgument_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfFunctionArgument::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::GotoStatement_label:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfGotoStatement::label, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::IfStatement_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfIfStatement::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::IntegerExpression_value:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfIntegerExpression::value, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::LetVariable_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfLetVariable::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::MemberExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfMemberExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::Module_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfModule::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::ModuleUsingNameFragment_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfModuleUsingNameFragment::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::NewCoroutineExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfNewCoroutineExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::ObserveExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfObserveExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::OrderedNameExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfOrderedNameExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::PropertyDeclaration_getter:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfPropertyDeclaration::getter, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::PropertyDeclaration_setter:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfPropertyDeclaration::setter, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::PropertyDeclaration_valueChangedEvent:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfPropertyDeclaration::valueChangedEvent, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::ReferenceExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfReferenceExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::ReferenceType_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfReferenceType::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::StateDeclaration_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfStateDeclaration::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::StateInput_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfStateInput::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::StateInvokeStatement_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfStateInvokeStatement::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::StateSwitchArgument_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfStateSwitchArgument::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::StateSwitchCase_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfStateSwitchCase::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::StringExpression_value:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfStringExpression::value, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::StructMember_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfStructMember::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::TopQualifiedExpression_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfTopQualifiedExpression::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::TopQualifiedType_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfTopQualifiedType::name, object, field, token, tokenIndex, cppFieldName);
		case WorkflowFields::TryStatement_name:
			return vl::glr::AssemblerSetTokenField(&vl::workflow::WfTryStatement::name, object, field, token, tokenIndex, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotToken(field, cppFieldName);
		}
	}

	void WorkflowAstInsReceiver::SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem, bool weakAssignment)
	{
		auto cppFieldName = WorkflowCppFieldName((WorkflowFields)field);
		switch((WorkflowFields)field)
		{
		case WorkflowFields::AutoPropertyDeclaration_configConst:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfAutoPropertyDeclaration::configConst, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::AutoPropertyDeclaration_configObserve:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfAutoPropertyDeclaration::configObserve, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::AutoPropertyDeclaration_functionKind:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfAutoPropertyDeclaration::functionKind, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::BinaryExpression_op:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfBinaryExpression::op, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::ClassDeclaration_constructorType:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfClassDeclaration::constructorType, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::ClassDeclaration_kind:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfClassDeclaration::kind, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::ConstructorDeclaration_constructorType:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfConstructorDeclaration::constructorType, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::EnumDeclaration_kind:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfEnumDeclaration::kind, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::EnumItem_kind:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfEnumItem::kind, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::ExpectedTypeCastExpression_strategy:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfExpectedTypeCastExpression::strategy, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::ForEachStatement_direction:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfForEachStatement::direction, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::FunctionDeclaration_anonymity:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfFunctionDeclaration::anonymity, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::FunctionDeclaration_functionKind:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfFunctionDeclaration::functionKind, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::LiteralExpression_value:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfLiteralExpression::value, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::MapType_writability:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfMapType::writability, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::Module_moduleType:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfModule::moduleType, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::ObserveExpression_observeType:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfObserveExpression::observeType, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::PredefinedType_name:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfPredefinedType::name, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::RangeExpression_beginBoundary:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfRangeExpression::beginBoundary, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::RangeExpression_endBoundary:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfRangeExpression::endBoundary, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::SetTestingExpression_test:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfSetTestingExpression::test, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::StateInvokeStatement_type:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfStateInvokeStatement::type, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::StateSwitchStatement_type:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfStateSwitchStatement::type, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::TypeCastingExpression_strategy:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfTypeCastingExpression::strategy, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::TypeTestingExpression_test:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfTypeTestingExpression::test, object, field, enumItem, weakAssignment, cppFieldName);
		case WorkflowFields::UnaryExpression_op:
			return vl::glr::AssemblerSetEnumField(&vl::workflow::WfUnaryExpression::op, object, field, enumItem, weakAssignment, cppFieldName);
		default:
			return vl::glr::AssemblyThrowFieldNotEnum(field, cppFieldName);
		}
	}

	const wchar_t* WorkflowTypeName(WorkflowClasses type)
	{
		const wchar_t* results[] = {
			L"AttachEventExpression",
			L"Attribute",
			L"AutoPropertyDeclaration",
			L"BaseConstructorCall",
			L"BinaryExpression",
			L"BindExpression",
			L"BlockStatement",
			L"BreakStatement",
			L"CallExpression",
			L"CastResultInterfaceDeclaration",
			L"ChildExpression",
			L"ChildType",
			L"ClassDeclaration",
			L"CoOperatorExpression",
			L"CoOperatorStatement",
			L"CoPauseStatement",
			L"CoProviderStatement",
			L"ConstructorArgument",
			L"ConstructorDeclaration",
			L"ConstructorExpression",
			L"ContinueStatement",
			L"CoroutineStatement",
			L"Declaration",
			L"DeleteStatement",
			L"DestructorDeclaration",
			L"DetachEventExpression",
			L"EnumDeclaration",
			L"EnumItem",
			L"EnumItemIntersection",
			L"EnumerableType",
			L"EventDeclaration",
			L"ExpectedTypeCastExpression",
			L"Expression",
			L"ExpressionStatement",
			L"FloatingExpression",
			L"ForEachStatement",
			L"FormatExpression",
			L"FunctionArgument",
			L"FunctionDeclaration",
			L"FunctionExpression",
			L"FunctionType",
			L"GotoStatement",
			L"IfExpression",
			L"IfStatement",
			L"InferExpression",
			L"IntegerExpression",
			L"LetExpression",
			L"LetVariable",
			L"LiteralExpression",
			L"MapType",
			L"MemberExpression",
			L"MixinCastExpression",
			L"Module",
			L"ModuleUsingFragment",
			L"ModuleUsingItem",
			L"ModuleUsingNameFragment",
			L"ModuleUsingPath",
			L"ModuleUsingWildCardFragment",
			L"NamespaceDeclaration",
			L"NewClassExpression",
			L"NewCoroutineExpression",
			L"NewInterfaceExpression",
			L"NullableType",
			L"ObservableListType",
			L"ObserveExpression",
			L"OrderedLambdaExpression",
			L"OrderedNameExpression",
			L"PredefinedType",
			L"PropertyDeclaration",
			L"RaiseExceptionStatement",
			L"RangeExpression",
			L"RawPointerType",
			L"ReferenceExpression",
			L"ReferenceType",
			L"ReturnStatement",
			L"SetTestingExpression",
			L"SharedPointerType",
			L"StateDeclaration",
			L"StateInput",
			L"StateInvokeStatement",
			L"StateMachineDeclaration",
			L"StateMachineStatement",
			L"StateSwitchArgument",
			L"StateSwitchCase",
			L"StateSwitchStatement",
			L"Statement",
			L"StaticInitDeclaration",
			L"StringExpression",
			L"StructDeclaration",
			L"StructMember",
			L"SwitchCase",
			L"SwitchStatement",
			L"ThisExpression",
			L"TopQualifiedExpression",
			L"TopQualifiedType",
			L"TryStatement",
			L"Type",
			L"TypeCastingExpression",
			L"TypeOfExpressionExpression",
			L"TypeOfTypeExpression",
			L"TypeTestingExpression",
			L"UnaryExpression",
			L"VariableDeclaration",
			L"VariableStatement",
			L"VirtualCfeDeclaration",
			L"VirtualCfeExpression",
			L"VirtualCseDeclaration",
			L"VirtualCseExpression",
			L"VirtualCseStatement",
			L"WhileStatement",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 110 ? results[index] : nullptr;
	}

	const wchar_t* WorkflowCppTypeName(WorkflowClasses type)
	{
		const wchar_t* results[] = {
			L"vl::workflow::WfAttachEventExpression",
			L"vl::workflow::WfAttribute",
			L"vl::workflow::WfAutoPropertyDeclaration",
			L"vl::workflow::WfBaseConstructorCall",
			L"vl::workflow::WfBinaryExpression",
			L"vl::workflow::WfBindExpression",
			L"vl::workflow::WfBlockStatement",
			L"vl::workflow::WfBreakStatement",
			L"vl::workflow::WfCallExpression",
			L"vl::workflow::WfCastResultInterfaceDeclaration",
			L"vl::workflow::WfChildExpression",
			L"vl::workflow::WfChildType",
			L"vl::workflow::WfClassDeclaration",
			L"vl::workflow::WfCoOperatorExpression",
			L"vl::workflow::WfCoOperatorStatement",
			L"vl::workflow::WfCoPauseStatement",
			L"vl::workflow::WfCoProviderStatement",
			L"vl::workflow::WfConstructorArgument",
			L"vl::workflow::WfConstructorDeclaration",
			L"vl::workflow::WfConstructorExpression",
			L"vl::workflow::WfContinueStatement",
			L"vl::workflow::WfCoroutineStatement",
			L"vl::workflow::WfDeclaration",
			L"vl::workflow::WfDeleteStatement",
			L"vl::workflow::WfDestructorDeclaration",
			L"vl::workflow::WfDetachEventExpression",
			L"vl::workflow::WfEnumDeclaration",
			L"vl::workflow::WfEnumItem",
			L"vl::workflow::WfEnumItemIntersection",
			L"vl::workflow::WfEnumerableType",
			L"vl::workflow::WfEventDeclaration",
			L"vl::workflow::WfExpectedTypeCastExpression",
			L"vl::workflow::WfExpression",
			L"vl::workflow::WfExpressionStatement",
			L"vl::workflow::WfFloatingExpression",
			L"vl::workflow::WfForEachStatement",
			L"vl::workflow::WfFormatExpression",
			L"vl::workflow::WfFunctionArgument",
			L"vl::workflow::WfFunctionDeclaration",
			L"vl::workflow::WfFunctionExpression",
			L"vl::workflow::WfFunctionType",
			L"vl::workflow::WfGotoStatement",
			L"vl::workflow::WfIfExpression",
			L"vl::workflow::WfIfStatement",
			L"vl::workflow::WfInferExpression",
			L"vl::workflow::WfIntegerExpression",
			L"vl::workflow::WfLetExpression",
			L"vl::workflow::WfLetVariable",
			L"vl::workflow::WfLiteralExpression",
			L"vl::workflow::WfMapType",
			L"vl::workflow::WfMemberExpression",
			L"vl::workflow::WfMixinCastExpression",
			L"vl::workflow::WfModule",
			L"vl::workflow::WfModuleUsingFragment",
			L"vl::workflow::WfModuleUsingItem",
			L"vl::workflow::WfModuleUsingNameFragment",
			L"vl::workflow::WfModuleUsingPath",
			L"vl::workflow::WfModuleUsingWildCardFragment",
			L"vl::workflow::WfNamespaceDeclaration",
			L"vl::workflow::WfNewClassExpression",
			L"vl::workflow::WfNewCoroutineExpression",
			L"vl::workflow::WfNewInterfaceExpression",
			L"vl::workflow::WfNullableType",
			L"vl::workflow::WfObservableListType",
			L"vl::workflow::WfObserveExpression",
			L"vl::workflow::WfOrderedLambdaExpression",
			L"vl::workflow::WfOrderedNameExpression",
			L"vl::workflow::WfPredefinedType",
			L"vl::workflow::WfPropertyDeclaration",
			L"vl::workflow::WfRaiseExceptionStatement",
			L"vl::workflow::WfRangeExpression",
			L"vl::workflow::WfRawPointerType",
			L"vl::workflow::WfReferenceExpression",
			L"vl::workflow::WfReferenceType",
			L"vl::workflow::WfReturnStatement",
			L"vl::workflow::WfSetTestingExpression",
			L"vl::workflow::WfSharedPointerType",
			L"vl::workflow::WfStateDeclaration",
			L"vl::workflow::WfStateInput",
			L"vl::workflow::WfStateInvokeStatement",
			L"vl::workflow::WfStateMachineDeclaration",
			L"vl::workflow::WfStateMachineStatement",
			L"vl::workflow::WfStateSwitchArgument",
			L"vl::workflow::WfStateSwitchCase",
			L"vl::workflow::WfStateSwitchStatement",
			L"vl::workflow::WfStatement",
			L"vl::workflow::WfStaticInitDeclaration",
			L"vl::workflow::WfStringExpression",
			L"vl::workflow::WfStructDeclaration",
			L"vl::workflow::WfStructMember",
			L"vl::workflow::WfSwitchCase",
			L"vl::workflow::WfSwitchStatement",
			L"vl::workflow::WfThisExpression",
			L"vl::workflow::WfTopQualifiedExpression",
			L"vl::workflow::WfTopQualifiedType",
			L"vl::workflow::WfTryStatement",
			L"vl::workflow::WfType",
			L"vl::workflow::WfTypeCastingExpression",
			L"vl::workflow::WfTypeOfExpressionExpression",
			L"vl::workflow::WfTypeOfTypeExpression",
			L"vl::workflow::WfTypeTestingExpression",
			L"vl::workflow::WfUnaryExpression",
			L"vl::workflow::WfVariableDeclaration",
			L"vl::workflow::WfVariableStatement",
			L"vl::workflow::WfVirtualCfeDeclaration",
			L"vl::workflow::WfVirtualCfeExpression",
			L"vl::workflow::WfVirtualCseDeclaration",
			L"vl::workflow::WfVirtualCseExpression",
			L"vl::workflow::WfVirtualCseStatement",
			L"vl::workflow::WfWhileStatement",
		};
		vl::vint index = (vl::vint)type;
		return 0 <= index && index < 110 ? results[index] : nullptr;
	}

	const wchar_t* WorkflowFieldName(WorkflowFields field)
	{
		const wchar_t* results[] = {
			L"AttachEventExpression::event",
			L"AttachEventExpression::function",
			L"Attribute::category",
			L"Attribute::name",
			L"Attribute::value",
			L"AutoPropertyDeclaration::configConst",
			L"AutoPropertyDeclaration::configObserve",
			L"AutoPropertyDeclaration::expression",
			L"AutoPropertyDeclaration::functionKind",
			L"AutoPropertyDeclaration::type",
			L"BaseConstructorCall::arguments",
			L"BaseConstructorCall::type",
			L"BinaryExpression::first",
			L"BinaryExpression::op",
			L"BinaryExpression::second",
			L"BindExpression::expression",
			L"BlockStatement::endLabel",
			L"BlockStatement::statements",
			L"CallExpression::arguments",
			L"CallExpression::function",
			L"CastResultInterfaceDeclaration::baseType",
			L"CastResultInterfaceDeclaration::elementType",
			L"ChildExpression::name",
			L"ChildExpression::parent",
			L"ChildType::name",
			L"ChildType::parent",
			L"ClassDeclaration::baseTypes",
			L"ClassDeclaration::constructorType",
			L"ClassDeclaration::declarations",
			L"ClassDeclaration::kind",
			L"CoOperatorExpression::name",
			L"CoOperatorStatement::arguments",
			L"CoOperatorStatement::opName",
			L"CoOperatorStatement::varName",
			L"CoPauseStatement::statement",
			L"CoProviderStatement::name",
			L"CoProviderStatement::statement",
			L"ConstructorArgument::key",
			L"ConstructorArgument::value",
			L"ConstructorDeclaration::arguments",
			L"ConstructorDeclaration::baseConstructorCalls",
			L"ConstructorDeclaration::constructorType",
			L"ConstructorDeclaration::statement",
			L"ConstructorExpression::arguments",
			L"Declaration::attributes",
			L"Declaration::name",
			L"DeleteStatement::expression",
			L"DestructorDeclaration::statement",
			L"DetachEventExpression::event",
			L"DetachEventExpression::handler",
			L"EnumDeclaration::items",
			L"EnumDeclaration::kind",
			L"EnumItem::attributes",
			L"EnumItem::intersections",
			L"EnumItem::kind",
			L"EnumItem::name",
			L"EnumItem::number",
			L"EnumItemIntersection::name",
			L"EnumerableType::element",
			L"EventDeclaration::arguments",
			L"ExpectedTypeCastExpression::expression",
			L"ExpectedTypeCastExpression::strategy",
			L"ExpressionStatement::expression",
			L"FloatingExpression::value",
			L"ForEachStatement::collection",
			L"ForEachStatement::direction",
			L"ForEachStatement::name",
			L"ForEachStatement::statement",
			L"FormatExpression::value",
			L"FunctionArgument::attributes",
			L"FunctionArgument::name",
			L"FunctionArgument::type",
			L"FunctionDeclaration::anonymity",
			L"FunctionDeclaration::arguments",
			L"FunctionDeclaration::functionKind",
			L"FunctionDeclaration::returnType",
			L"FunctionDeclaration::statement",
			L"FunctionExpression::function",
			L"FunctionType::arguments",
			L"FunctionType::result",
			L"GotoStatement::label",
			L"IfExpression::condition",
			L"IfExpression::falseBranch",
			L"IfExpression::trueBranch",
			L"IfStatement::expression",
			L"IfStatement::falseBranch",
			L"IfStatement::name",
			L"IfStatement::trueBranch",
			L"IfStatement::type",
			L"InferExpression::expression",
			L"InferExpression::type",
			L"IntegerExpression::value",
			L"LetExpression::expression",
			L"LetExpression::variables",
			L"LetVariable::name",
			L"LetVariable::value",
			L"LiteralExpression::value",
			L"MapType::key",
			L"MapType::value",
			L"MapType::writability",
			L"MemberExpression::name",
			L"MemberExpression::parent",
			L"MixinCastExpression::expression",
			L"MixinCastExpression::type",
			L"Module::declarations",
			L"Module::moduleType",
			L"Module::name",
			L"Module::paths",
			L"ModuleUsingItem::fragments",
			L"ModuleUsingNameFragment::name",
			L"ModuleUsingPath::items",
			L"NamespaceDeclaration::declarations",
			L"NewClassExpression::arguments",
			L"NewClassExpression::type",
			L"NewCoroutineExpression::name",
			L"NewCoroutineExpression::statement",
			L"NewInterfaceExpression::declarations",
			L"NewInterfaceExpression::type",
			L"NullableType::element",
			L"ObservableListType::element",
			L"ObserveExpression::events",
			L"ObserveExpression::expression",
			L"ObserveExpression::name",
			L"ObserveExpression::observeType",
			L"ObserveExpression::parent",
			L"OrderedLambdaExpression::body",
			L"OrderedNameExpression::name",
			L"PredefinedType::name",
			L"PropertyDeclaration::getter",
			L"PropertyDeclaration::setter",
			L"PropertyDeclaration::type",
			L"PropertyDeclaration::valueChangedEvent",
			L"RaiseExceptionStatement::expression",
			L"RangeExpression::begin",
			L"RangeExpression::beginBoundary",
			L"RangeExpression::end",
			L"RangeExpression::endBoundary",
			L"RawPointerType::element",
			L"ReferenceExpression::name",
			L"ReferenceType::name",
			L"ReturnStatement::expression",
			L"SetTestingExpression::collection",
			L"SetTestingExpression::element",
			L"SetTestingExpression::test",
			L"SharedPointerType::element",
			L"StateDeclaration::arguments",
			L"StateDeclaration::name",
			L"StateDeclaration::statement",
			L"StateInput::arguments",
			L"StateInput::name",
			L"StateInvokeStatement::arguments",
			L"StateInvokeStatement::name",
			L"StateInvokeStatement::type",
			L"StateMachineDeclaration::inputs",
			L"StateMachineDeclaration::states",
			L"StateSwitchArgument::name",
			L"StateSwitchCase::arguments",
			L"StateSwitchCase::name",
			L"StateSwitchCase::statement",
			L"StateSwitchStatement::caseBranches",
			L"StateSwitchStatement::type",
			L"StaticInitDeclaration::statement",
			L"StringExpression::value",
			L"StructDeclaration::members",
			L"StructMember::attributes",
			L"StructMember::name",
			L"StructMember::type",
			L"SwitchCase::expression",
			L"SwitchCase::statement",
			L"SwitchStatement::caseBranches",
			L"SwitchStatement::defaultBranch",
			L"SwitchStatement::expression",
			L"TopQualifiedExpression::name",
			L"TopQualifiedType::name",
			L"TryStatement::catchStatement",
			L"TryStatement::finallyStatement",
			L"TryStatement::name",
			L"TryStatement::protectedStatement",
			L"TypeCastingExpression::expression",
			L"TypeCastingExpression::strategy",
			L"TypeCastingExpression::type",
			L"TypeOfExpressionExpression::expression",
			L"TypeOfTypeExpression::type",
			L"TypeTestingExpression::expression",
			L"TypeTestingExpression::test",
			L"TypeTestingExpression::type",
			L"UnaryExpression::op",
			L"UnaryExpression::operand",
			L"VariableDeclaration::expression",
			L"VariableDeclaration::type",
			L"VariableStatement::variable",
			L"VirtualCfeDeclaration::expandedDeclarations",
			L"VirtualCfeExpression::expandedExpression",
			L"VirtualCseDeclaration::expandedDeclarations",
			L"VirtualCseExpression::expandedExpression",
			L"VirtualCseStatement::expandedStatement",
			L"WhileStatement::condition",
			L"WhileStatement::statement",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 198 ? results[index] : nullptr;
	}

	const wchar_t* WorkflowCppFieldName(WorkflowFields field)
	{
		const wchar_t* results[] = {
			L"vl::workflow::WfAttachEventExpression::event",
			L"vl::workflow::WfAttachEventExpression::function",
			L"vl::workflow::WfAttribute::category",
			L"vl::workflow::WfAttribute::name",
			L"vl::workflow::WfAttribute::value",
			L"vl::workflow::WfAutoPropertyDeclaration::configConst",
			L"vl::workflow::WfAutoPropertyDeclaration::configObserve",
			L"vl::workflow::WfAutoPropertyDeclaration::expression",
			L"vl::workflow::WfAutoPropertyDeclaration::functionKind",
			L"vl::workflow::WfAutoPropertyDeclaration::type",
			L"vl::workflow::WfBaseConstructorCall::arguments",
			L"vl::workflow::WfBaseConstructorCall::type",
			L"vl::workflow::WfBinaryExpression::first",
			L"vl::workflow::WfBinaryExpression::op",
			L"vl::workflow::WfBinaryExpression::second",
			L"vl::workflow::WfBindExpression::expression",
			L"vl::workflow::WfBlockStatement::endLabel",
			L"vl::workflow::WfBlockStatement::statements",
			L"vl::workflow::WfCallExpression::arguments",
			L"vl::workflow::WfCallExpression::function",
			L"vl::workflow::WfCastResultInterfaceDeclaration::baseType",
			L"vl::workflow::WfCastResultInterfaceDeclaration::elementType",
			L"vl::workflow::WfChildExpression::name",
			L"vl::workflow::WfChildExpression::parent",
			L"vl::workflow::WfChildType::name",
			L"vl::workflow::WfChildType::parent",
			L"vl::workflow::WfClassDeclaration::baseTypes",
			L"vl::workflow::WfClassDeclaration::constructorType",
			L"vl::workflow::WfClassDeclaration::declarations",
			L"vl::workflow::WfClassDeclaration::kind",
			L"vl::workflow::WfCoOperatorExpression::name",
			L"vl::workflow::WfCoOperatorStatement::arguments",
			L"vl::workflow::WfCoOperatorStatement::opName",
			L"vl::workflow::WfCoOperatorStatement::varName",
			L"vl::workflow::WfCoPauseStatement::statement",
			L"vl::workflow::WfCoProviderStatement::name",
			L"vl::workflow::WfCoProviderStatement::statement",
			L"vl::workflow::WfConstructorArgument::key",
			L"vl::workflow::WfConstructorArgument::value",
			L"vl::workflow::WfConstructorDeclaration::arguments",
			L"vl::workflow::WfConstructorDeclaration::baseConstructorCalls",
			L"vl::workflow::WfConstructorDeclaration::constructorType",
			L"vl::workflow::WfConstructorDeclaration::statement",
			L"vl::workflow::WfConstructorExpression::arguments",
			L"vl::workflow::WfDeclaration::attributes",
			L"vl::workflow::WfDeclaration::name",
			L"vl::workflow::WfDeleteStatement::expression",
			L"vl::workflow::WfDestructorDeclaration::statement",
			L"vl::workflow::WfDetachEventExpression::event",
			L"vl::workflow::WfDetachEventExpression::handler",
			L"vl::workflow::WfEnumDeclaration::items",
			L"vl::workflow::WfEnumDeclaration::kind",
			L"vl::workflow::WfEnumItem::attributes",
			L"vl::workflow::WfEnumItem::intersections",
			L"vl::workflow::WfEnumItem::kind",
			L"vl::workflow::WfEnumItem::name",
			L"vl::workflow::WfEnumItem::number",
			L"vl::workflow::WfEnumItemIntersection::name",
			L"vl::workflow::WfEnumerableType::element",
			L"vl::workflow::WfEventDeclaration::arguments",
			L"vl::workflow::WfExpectedTypeCastExpression::expression",
			L"vl::workflow::WfExpectedTypeCastExpression::strategy",
			L"vl::workflow::WfExpressionStatement::expression",
			L"vl::workflow::WfFloatingExpression::value",
			L"vl::workflow::WfForEachStatement::collection",
			L"vl::workflow::WfForEachStatement::direction",
			L"vl::workflow::WfForEachStatement::name",
			L"vl::workflow::WfForEachStatement::statement",
			L"vl::workflow::WfFormatExpression::value",
			L"vl::workflow::WfFunctionArgument::attributes",
			L"vl::workflow::WfFunctionArgument::name",
			L"vl::workflow::WfFunctionArgument::type",
			L"vl::workflow::WfFunctionDeclaration::anonymity",
			L"vl::workflow::WfFunctionDeclaration::arguments",
			L"vl::workflow::WfFunctionDeclaration::functionKind",
			L"vl::workflow::WfFunctionDeclaration::returnType",
			L"vl::workflow::WfFunctionDeclaration::statement",
			L"vl::workflow::WfFunctionExpression::function",
			L"vl::workflow::WfFunctionType::arguments",
			L"vl::workflow::WfFunctionType::result",
			L"vl::workflow::WfGotoStatement::label",
			L"vl::workflow::WfIfExpression::condition",
			L"vl::workflow::WfIfExpression::falseBranch",
			L"vl::workflow::WfIfExpression::trueBranch",
			L"vl::workflow::WfIfStatement::expression",
			L"vl::workflow::WfIfStatement::falseBranch",
			L"vl::workflow::WfIfStatement::name",
			L"vl::workflow::WfIfStatement::trueBranch",
			L"vl::workflow::WfIfStatement::type",
			L"vl::workflow::WfInferExpression::expression",
			L"vl::workflow::WfInferExpression::type",
			L"vl::workflow::WfIntegerExpression::value",
			L"vl::workflow::WfLetExpression::expression",
			L"vl::workflow::WfLetExpression::variables",
			L"vl::workflow::WfLetVariable::name",
			L"vl::workflow::WfLetVariable::value",
			L"vl::workflow::WfLiteralExpression::value",
			L"vl::workflow::WfMapType::key",
			L"vl::workflow::WfMapType::value",
			L"vl::workflow::WfMapType::writability",
			L"vl::workflow::WfMemberExpression::name",
			L"vl::workflow::WfMemberExpression::parent",
			L"vl::workflow::WfMixinCastExpression::expression",
			L"vl::workflow::WfMixinCastExpression::type",
			L"vl::workflow::WfModule::declarations",
			L"vl::workflow::WfModule::moduleType",
			L"vl::workflow::WfModule::name",
			L"vl::workflow::WfModule::paths",
			L"vl::workflow::WfModuleUsingItem::fragments",
			L"vl::workflow::WfModuleUsingNameFragment::name",
			L"vl::workflow::WfModuleUsingPath::items",
			L"vl::workflow::WfNamespaceDeclaration::declarations",
			L"vl::workflow::WfNewClassExpression::arguments",
			L"vl::workflow::WfNewClassExpression::type",
			L"vl::workflow::WfNewCoroutineExpression::name",
			L"vl::workflow::WfNewCoroutineExpression::statement",
			L"vl::workflow::WfNewInterfaceExpression::declarations",
			L"vl::workflow::WfNewInterfaceExpression::type",
			L"vl::workflow::WfNullableType::element",
			L"vl::workflow::WfObservableListType::element",
			L"vl::workflow::WfObserveExpression::events",
			L"vl::workflow::WfObserveExpression::expression",
			L"vl::workflow::WfObserveExpression::name",
			L"vl::workflow::WfObserveExpression::observeType",
			L"vl::workflow::WfObserveExpression::parent",
			L"vl::workflow::WfOrderedLambdaExpression::body",
			L"vl::workflow::WfOrderedNameExpression::name",
			L"vl::workflow::WfPredefinedType::name",
			L"vl::workflow::WfPropertyDeclaration::getter",
			L"vl::workflow::WfPropertyDeclaration::setter",
			L"vl::workflow::WfPropertyDeclaration::type",
			L"vl::workflow::WfPropertyDeclaration::valueChangedEvent",
			L"vl::workflow::WfRaiseExceptionStatement::expression",
			L"vl::workflow::WfRangeExpression::begin",
			L"vl::workflow::WfRangeExpression::beginBoundary",
			L"vl::workflow::WfRangeExpression::end",
			L"vl::workflow::WfRangeExpression::endBoundary",
			L"vl::workflow::WfRawPointerType::element",
			L"vl::workflow::WfReferenceExpression::name",
			L"vl::workflow::WfReferenceType::name",
			L"vl::workflow::WfReturnStatement::expression",
			L"vl::workflow::WfSetTestingExpression::collection",
			L"vl::workflow::WfSetTestingExpression::element",
			L"vl::workflow::WfSetTestingExpression::test",
			L"vl::workflow::WfSharedPointerType::element",
			L"vl::workflow::WfStateDeclaration::arguments",
			L"vl::workflow::WfStateDeclaration::name",
			L"vl::workflow::WfStateDeclaration::statement",
			L"vl::workflow::WfStateInput::arguments",
			L"vl::workflow::WfStateInput::name",
			L"vl::workflow::WfStateInvokeStatement::arguments",
			L"vl::workflow::WfStateInvokeStatement::name",
			L"vl::workflow::WfStateInvokeStatement::type",
			L"vl::workflow::WfStateMachineDeclaration::inputs",
			L"vl::workflow::WfStateMachineDeclaration::states",
			L"vl::workflow::WfStateSwitchArgument::name",
			L"vl::workflow::WfStateSwitchCase::arguments",
			L"vl::workflow::WfStateSwitchCase::name",
			L"vl::workflow::WfStateSwitchCase::statement",
			L"vl::workflow::WfStateSwitchStatement::caseBranches",
			L"vl::workflow::WfStateSwitchStatement::type",
			L"vl::workflow::WfStaticInitDeclaration::statement",
			L"vl::workflow::WfStringExpression::value",
			L"vl::workflow::WfStructDeclaration::members",
			L"vl::workflow::WfStructMember::attributes",
			L"vl::workflow::WfStructMember::name",
			L"vl::workflow::WfStructMember::type",
			L"vl::workflow::WfSwitchCase::expression",
			L"vl::workflow::WfSwitchCase::statement",
			L"vl::workflow::WfSwitchStatement::caseBranches",
			L"vl::workflow::WfSwitchStatement::defaultBranch",
			L"vl::workflow::WfSwitchStatement::expression",
			L"vl::workflow::WfTopQualifiedExpression::name",
			L"vl::workflow::WfTopQualifiedType::name",
			L"vl::workflow::WfTryStatement::catchStatement",
			L"vl::workflow::WfTryStatement::finallyStatement",
			L"vl::workflow::WfTryStatement::name",
			L"vl::workflow::WfTryStatement::protectedStatement",
			L"vl::workflow::WfTypeCastingExpression::expression",
			L"vl::workflow::WfTypeCastingExpression::strategy",
			L"vl::workflow::WfTypeCastingExpression::type",
			L"vl::workflow::WfTypeOfExpressionExpression::expression",
			L"vl::workflow::WfTypeOfTypeExpression::type",
			L"vl::workflow::WfTypeTestingExpression::expression",
			L"vl::workflow::WfTypeTestingExpression::test",
			L"vl::workflow::WfTypeTestingExpression::type",
			L"vl::workflow::WfUnaryExpression::op",
			L"vl::workflow::WfUnaryExpression::operand",
			L"vl::workflow::WfVariableDeclaration::expression",
			L"vl::workflow::WfVariableDeclaration::type",
			L"vl::workflow::WfVariableStatement::variable",
			L"vl::workflow::WfVirtualCfeDeclaration::expandedDeclarations",
			L"vl::workflow::WfVirtualCfeExpression::expandedExpression",
			L"vl::workflow::WfVirtualCseDeclaration::expandedDeclarations",
			L"vl::workflow::WfVirtualCseExpression::expandedExpression",
			L"vl::workflow::WfVirtualCseStatement::expandedStatement",
			L"vl::workflow::WfWhileStatement::condition",
			L"vl::workflow::WfWhileStatement::statement",
		};
		vl::vint index = (vl::vint)field;
		return 0 <= index && index < 198 ? results[index] : nullptr;
	}

	vl::Ptr<vl::glr::ParsingAstBase> WorkflowAstInsReceiver::ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates)
	{
		auto cppTypeName = WorkflowCppTypeName((WorkflowClasses)type);
		return vl::glr::AssemblyThrowTypeNotAllowAmbiguity(type, cppTypeName);
	}
}


/***********************************************************************
.\PARSER\GENERATED\WORKFLOW_LEXER.CPP
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Workflow
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/


namespace vl::workflow
{
	bool WorkflowTokenDeleter(vl::vint token)
	{
		switch((WorkflowTokens)token)
		{
		case WorkflowTokens::COMMENT:
		case WorkflowTokens::SPACE:
			return true;
		default:
			return false;
		}
	}

	const wchar_t* WorkflowTokenId(WorkflowTokens token)
	{
		static const wchar_t* results[] = {
			L"EXP",
			L"ADD",
			L"SUB",
			L"MUL",
			L"DIV",
			L"MOD",
			L"JOIN",
			L"INTERSECTION",
			L"LE",
			L"GE",
			L"LT",
			L"GT",
			L"EQ",
			L"NE",
			L"ASSIGN",
			L"FAILED_THEN",
			L"QUESTION_MARK",
			L"SCOPE_DELIMITER",
			L"COLON",
			L"SEMICOLON",
			L"COMMA",
			L"DOT",
			L"OPEN_ARRAY",
			L"CLOSE_ARRAY",
			L"OPEN_BRACE",
			L"CLOSE_BRACE",
			L"OPEN_BRACKET",
			L"CLOSE_BRACKET",
			L"AT",
			L"TYPE_VOID",
			L"TYPE_OBJECT",
			L"TYPE_INTERFACE",
			L"TYPE_INT",
			L"TYPE_UINT",
			L"TYPE_FLOAT",
			L"TYPE_DOUBLE",
			L"TYPE_STRING",
			L"TYPE_CHAR",
			L"TYPE_BOOL",
			L"KEYWORD_CONST",
			L"KEYWORD_SHL",
			L"KEYWORD_SHR",
			L"KEYWORD_XOR",
			L"KEYWORD_AND",
			L"KEYWORD_OR",
			L"KEYWORD_NOT",
			L"KEYWORD_NULL",
			L"KEYWORD_THIS",
			L"KEYWORD_TRUE",
			L"KEYWORD_FALSE",
			L"KEYWORD_LET",
			L"KEYWORD_IN",
			L"KEYWORD_RANGE",
			L"KEYWORD_NEW",
			L"KEYWORD_OF",
			L"KEYWORD_AS",
			L"KEYWORD_IS",
			L"KEYWORD_CAST",
			L"KEYWORD_FUNC",
			L"KEYWORD_TYPEOF",
			L"KEYWORD_TYPE",
			L"KEYWORD_BIND",
			L"KEYWORD_OBSERVE",
			L"KEYWORD_ON",
			L"KEYWORD_ATTACH",
			L"KEYWORD_DETACH",
			L"KEYWORD_GOTO",
			L"KEYWORD_VAR",
			L"KEYWORD_BREAK",
			L"KEYWORD_CONTINUE",
			L"KEYWORD_RETURN",
			L"KEYWORD_DELETE",
			L"KEYWORD_RAISE",
			L"KEYWORD_IF",
			L"KEYWORD_ELSE",
			L"KEYWORD_SWITCH",
			L"KEYWORD_CASE",
			L"KEYWORD_DEFAULT",
			L"KEYWORD_WHILE",
			L"KEYWORD_FOR",
			L"KEYWORD_REVERSED",
			L"KEYWORD_TRY",
			L"KEYWORD_CATCH",
			L"KEYWORD_FINALLY",
			L"KEYWORD_CLASS",
			L"KEYWORD_ENUM",
			L"KEYWORD_FLAGENUM",
			L"KEYWORD_STRUCT",
			L"KEYWORD_PROP",
			L"KEYWORD_EVENT",
			L"KEYWORD_STATIC",
			L"KEYWORD_OVERRIDE",
			L"KEYWORD_USING",
			L"KEYWORD_NAMESPACE",
			L"KEYWORD_MODULE",
			L"KEYWORD_UNIT",
			L"STATE_MACHINE",
			L"STATE_INPUT",
			L"STATE_SWITCH",
			L"STATE_GOTO",
			L"STATE_PUSH",
			L"STATE_DECL",
			L"COROUTINE_COROUTINE",
			L"COROUTINE_PAUSE",
			L"COROUTINE_INTERFACE",
			L"COROUTINE_OPERATOR",
			L"COROUTINE_SIGN",
			L"NAME",
			L"ORDERED_NAME",
			L"FLOAT",
			L"INTEGER",
			L"STRING",
			L"FORMATSTRING",
			L"SPACE",
			L"COMMENT",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < WorkflowTokenCount ? results[index] : nullptr;
	}

	const wchar_t* WorkflowTokenDisplayText(WorkflowTokens token)
	{
		static const wchar_t* results[] = {
			L"^",
			L"+",
			L"-",
			L"*",
			L"/",
			L"%",
			L"&",
			L"|",
			L"<=",
			L">=",
			L"<",
			L">",
			L"==",
			L"!=",
			L"=",
			L"??",
			L"?",
			L"::",
			L":",
			L";",
			L",",
			L".",
			L"[",
			L"]",
			L"{",
			L"}",
			L"(",
			L")",
			L"@",
			L"void",
			L"object",
			L"interface",
			L"int",
			L"uint",
			L"float",
			L"double",
			L"string",
			L"char",
			L"bool",
			L"const",
			L"shl",
			L"shr",
			L"xor",
			L"and",
			L"or",
			L"not",
			L"null",
			L"this",
			L"true",
			L"false",
			L"let",
			L"in",
			L"range",
			L"new",
			L"of",
			L"as",
			L"is",
			L"cast",
			L"func",
			L"typeof",
			L"type",
			L"bind",
			L"observe",
			L"on",
			L"attach",
			L"detach",
			L"goto",
			L"var",
			L"break",
			L"continue",
			L"return",
			L"delete",
			L"raise",
			L"if",
			L"else",
			L"switch",
			L"case",
			L"default",
			L"while",
			L"for",
			L"reversed",
			L"try",
			L"catch",
			L"finally",
			L"class",
			L"enum",
			L"flagenum",
			L"struct",
			L"prop",
			L"event",
			L"static",
			L"override",
			L"using",
			L"namespace",
			L"module",
			L"unit",
			L"$state_machine",
			L"$state_input",
			L"$switch",
			L"$goto_state",
			L"$push_state",
			L"$state",
			L"$coroutine",
			L"$pause",
			L"$interface",
			nullptr,
			L"$",
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
			nullptr,
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < WorkflowTokenCount ? results[index] : nullptr;
	}

	const wchar_t* WorkflowTokenRegex(WorkflowTokens token)
	{
		static const wchar_t* results[] = {
			L"/^",
			L"/+",
			L"-",
			L"/*",
			L"//",
			L"%",
			L"&",
			L"/|",
			L"/</=",
			L"/>/=",
			L"/<",
			L"/>",
			L"/=/=",
			L"/!/=",
			L"/=",
			L"/?/?",
			L"/?",
			L"::",
			L":",
			L";",
			L",",
			L".",
			L"/[",
			L"/]",
			L"/{",
			L"/}",
			L"/(",
			L"/)",
			L"@",
			L"void",
			L"object",
			L"interface",
			L"int",
			L"uint",
			L"float",
			L"double",
			L"string",
			L"char",
			L"bool",
			L"const",
			L"shl",
			L"shr",
			L"xor",
			L"and",
			L"or",
			L"not",
			L"null",
			L"this",
			L"true",
			L"false",
			L"let",
			L"in",
			L"range",
			L"new",
			L"of",
			L"as",
			L"is",
			L"cast",
			L"func",
			L"typeof",
			L"type",
			L"bind",
			L"observe",
			L"on",
			L"attach",
			L"detach",
			L"goto",
			L"var",
			L"break",
			L"continue",
			L"return",
			L"delete",
			L"raise",
			L"if",
			L"else",
			L"switch",
			L"case",
			L"default",
			L"while",
			L"for",
			L"reversed",
			L"try",
			L"catch",
			L"finally",
			L"class",
			L"enum",
			L"flagenum",
			L"struct",
			L"prop",
			L"event",
			L"static",
			L"override",
			L"using",
			L"namespace",
			L"module",
			L"unit",
			L"/$state_machine",
			L"/$state_input",
			L"/$switch",
			L"/$goto_state",
			L"/$push_state",
			L"/$state",
			L"/$coroutine",
			L"/$pause",
			L"/$interface",
			L"/$[A-Z]/w*",
			L"/$",
			L"[a-zA-Z_]/w*",
			L"/$[0-9]*",
			L"/d+./d+",
			L"/d+",
			L"\'([^\'\\\\]|\\\\\\.)*\'|\"([^\"\\\\]|\\\\\\.)*\"",
			L"/$(\'([^\'\\\\]|\\\\\\.)*\'|\"([^\"\\\\]|\\\\\\.)*\")",
			L"/s+",
			L"///*([^*]|/*+[^//])*/*+//",
		};
		vl::vint index = (vl::vint)token;
		return 0 <= index && index < WorkflowTokenCount ? results[index] : nullptr;
	}

	void WorkflowLexerData(vl::stream::IStream& outputStream)
	{
		static const vl::vint dataLength = 5338; // 106036 bytes before compressing
		static const vl::vint dataBlock = 256;
		static const vl::vint dataRemain = 218;
		static const vl::vint dataSolidRows = 20;
		static const vl::vint dataRows = 21;
		static const char* compressed[] = {
			"\x34\x9E\x01\x00\xD2\x14\x00\x00\x7E\x01\x00\x00\x04\x22\x85\x82\x81\x21\x05\x81\x82\x88\x05\x81\x05\x87\x82\x0A\x10\x85\x8B\x05\x84\x05\x83\x06\x17\x85\x8E\x05\x8F\x0D\x80\x10\x8F\x05\xA1\x21\x85\x82\x14\x91\x83\x11\x27\x85\xA4\x0A\x95\x85\x11\x97\x82\x26\x30\x85\x87\x13\x9D\x80\x14\x9B\x05\xA9\x39\x85\x8A\x14\x9D\x83\x15\x3F\x85\xAC\x02\xA5\x85\x15\xA3\x82\x2E\x48\x85\x8F\x1B\xA5\x80\x19\x82\x39\x05\xBA\x12\xA5\x83\x1D\xAB\x82\x3C\x58\x85\x9D\x1B\xAD\x82\x1E\xAF\x05\xBF\x21\xA5\x80\x24\xB1\x83\x20\x05\xDA\x05\x9B\x2B\xB5\x80\x2E\xB7\x05\xDD\x31\xA5\x8E\x2C\xB9\x83\x2F\x77\x85\xA0\x3A\xB5\x81\x31\xBF\x82\x62\x00\xC5\x83\x33\xC5\x80\x32\xC3\x05\xE5\x09\xC5\x86\x34\xC5\x83\x33\x8F\x85\xA8\x32\xC5\x81\x35\xCB\x82\x6A\x18\xC5\x8B\x3B\xCD\x80\x36\xCF\x05\xED\x21\xC5\x8E\x34\xD1\x83\x37\xA7\x85\xB0\x2A\xD5\x81\x39\xD7\x82\x72\x30\xC5\x93\x33\xDD\x80\x3A\xDB\x05\xF5\x39\xC5\x86\x3C\xDD\x83\x3B\xBF\x85\xB8\x22\xE5\x81\x3D\xE3\x82\x7A\x48\xC5\x9B\x3B\xE5\x80\x3E\xE7\x05\xFD\x11\xE5\x8E\x3D\x83\x7F\x7F\x10\x00\x17\xF7",
			"\xE2\x1D\x81\xEE\x81\xDB\xFF\x5F\xFA\xEB\xEB\xF2\x8A\x81\x31\x56\xDB\xE6\xA2\x86\x01\x83\x03\x4E\x85\x96\x05\x87\x0D\x80\x03\x82\x02\x05\x99\xE2\x83\x05\x81\x09\x82\x05\x0D\x52\x43\x46\x02\x4F\x0F\x42\x40\x14\x42\x41\x46\x40\x18\x42\x48\x06\x52\x02\x52\x0A\x7B\x75\x13\x09\x40\x84\x79\xD7\x68\x42\x42\x48\x02\x5F\x42\x42\x07\x3B\x42\x4D\x04\x4E\x02\x49\x52\x43\x06\x17\xA6\x80\x01\x4C\x02\x43\x52\x43\x4A\x02\x5A\x01\x51\x89\x35\x42\x4D\x46\x40\x2E\x42\x4C\x05\x41\x19\x3E\x42\x41\x49\x34\x81\x90\x00\x05\x05\x4C\x42\x41\x05\x13\xA1\x7A\x93\x92\x4C\x8D\x9E\x93\x93\x50\x91\x92\x97\x94\x54\x95\x96\x97\x95\x58\x99\x9A\x97\x96\x5C\x9D\x9E\x97\x97\x60\xA1\x92\x9B\x98\x64\xA5\x96\x9B\x99\x68\xA9\x9A\x9B\x9A\x6C\xAD\x9E\x9B\x9B\x70\xB1\x92\x9F\x9C\x74\xA8\x93\x0D\x92\x75\xB9\x9A\x9F\x9E\x7C\xBD\x9E\x9F\x9F\x80\x81\xA2\xA3\xA0\x84\x85\xA6\xA3\xA1\x88\x89\xAA\xA2\x9A\x34\x38\x9B\xA3\xA3\x90\x83\xA5\x0E\xA3\x91\x95\xA6\xA5\x9E\x36\x14\xA7\xA7\xA6\x9C\xAC\x97\x0E\xA6\x9D\xA1\xA2\xAA\x9A\x38\x20\xA3\xAB\xA9\xA7\x91\x50\x78\xAA",
			"\xAC\xAD\xAE\xAB\xAB\xB0\xB1\xA2\xAF\xAC\xB4\xB5\xA6\xAF\xAD\xB8\xB9\xAA\xAF\xAE\xBC\xBD\xAE\xAF\xAF\xC0\x81\xB2\xB3\xB0\xC4\x85\xB6\xB3\xB1\xC8\x89\xBC\x91\x56\xAB\x9F\x9C\xB0\x86\x52\x8F\xB1\x7A\x55\x02\x4F\xB6\xB6\x56\xD5\x98\xB0\x03\xB5\xD9\x9D\xBB\xB6\xB6\xCF\x93\x5E\xB4\xB7\xDF\xA3\xB0\xBB\xB9\xDE\x86\xB2\xB4\x98\xEB\x93\x9D\xBB\x3F\xCF\x9C\x56\xBA\xB7\x62\x73\xB5\xBB\xBD\xE4\x8F\xB5\x5A\xBD\xCF\x9F\x5C\xBF\x59\xE8\xB8\xB6\xA8\xAF\xEF\x9D\x95\xC0\x94\xEF\xB9\xB1\xC0\x41\xFF\x8D\xC7\xBE\x10\x01\xE4\xB8\x42\xC3\x0A\xE9\xB5\xB3\xC1\x5B\x98\xCE\x91\xC2\x11\xDD\xCE\xB5\x11\x1E\xF7\xB7\x11\xC8\xCF\x86\x14\xC9\xC8\xEA\x83\xC6\x96\xC6\x4D\xAF\xB9\x13\xC9\x0E\xCC\x11\xC0\x12\x01\xCB\x10\xCF\xBD\x4A\x37\xCC\xC9\xAF\x3B\xD7\x9D\xCE\x92\x1C\xCE\xCE\x12\xCE\x37\xCD\x14\xD0\xC5\x01\xE9\xCD\xB2\x97\x3F\xE1\x71\xD2\xC0\x48\xC2\x40\x17\xD1\x50\xD5\xD4\xBB\x13\x01\xD1\x18\xCB\xC5\x2A\xD5\x9D\xD3\x76\xEF\x94\x14\xD7\xB3\x52\x21\xC5\x15\xC0\x53\x23\xD4\xD6\xD2\xD0\x86\xCD\xD4\xD8\x49\x95\xC6\xD5\xC0\x57\x14\xD6\x15\xC0\x58",
			"\x2A\xD6\xBC\xDB\x61\x9F\xD7\x77\xD3\x72\xC1\xEA\xDC\x00\x59\x03\xE2\xE2\xC5\xC4\xBE\xD1\xB7\xDB\x7F\xF1\xD6\xE0\xD5\x6A\x51\xD0\x00\x5B\x02\x6F\x52\xE4\xB9\x7C\xEC\xBC\xE0\xBC\x49\xBB\x5E\xC0\x5E\x97\xF7\xC2\x5D\xE8\x02\x75\x54\xE9\xDB\xC1\x8A\xE1\x96\xE2\x80\xD4\xDE\x5F\xE9\x87\xC0\x01\x60\xEC\x85\x48\xE3\xB2\xEA\x08\xDB\xED\xEA\xBD\x87\x74\xEE\xEF\xDC\xBF\xD9\xEE\xB2\xEE\x49\x8A\x6E\xC1\x63\xBF\xF1\xEA\xF3\xE0\xC2\xCC\xD4\xF3\xD2\xCB\xC9\xF1\xC0\x64\xD2\xD2\xED\xF2\xDB\x4B\xEB\xEE\xE1\xF5\xC0\xC0\x03\x66\xB7\x96\x5C\xF9\x66\xF5\x5C\xD9\xFC\x94\xEB\xDB\xDD\xF2\xDC\x67\xDC\xD1\xFA\xF9\xD2\xE5\xE8\xE9\xC7\xF3\xD0\xAE\xF6\xFF\xE0\x9F\x6D\xFB\xE6\xAD\xB8\xCF\x98\xF8\xF4\x8F\x7F\x76\x68\x7A\x7E\x60\x3E\x7D\x36\x7C\x4F\x5A\x34\x02\xDE\x47\x37\x05\x99\x4C\x36\x0E\x9C\x4A\x6B\x11\x87\x3A\xD4\x0B\x69\x36\x14\x92\x4B\x6A\x0B\x85\x35\x0C\x8A\x5A\x7B\x1E\x94\x4B\xFF\x75\x71\x81\xF7\x44\x86\x84\x55\x7E\x57\x70\x4B\x60\x39\x10\x9F\x85\x4F\xC6\x22\x21\x0C\x80\x03\x87\x1A\x87\x3A\x86\x37\x94\x85\x0E\xB6\x88\x86\x81\x0C\x3D",
			"\x87\x3A\x80\x88\x0F\xC1\x84\x89\x21\x86\x8B\x87\x48\x82\x8A\x72\x4A\x8C\x89\x22\x89\x8E\x89\x4D\x87\x89\x14\xCF\x82\x8A\x28\x96\x8D\x8A\x58\x89\x4B\x73\x02\x2B\x8A\x00\x1D\x8F\x8B\xD0\x3C\x89\x18\x80\x05\x3A\x31\xA6\x8E\x8B\x63\x80\x8F\x19\xEA\x88\x8D\x35\xA9\x8F\x8D\x6E\x91\x8D\x1B\xF3\x8D\x8A\xE9\x32\x8C\x8D\x78\x90\x8C\x1D\xFA\x89\x8F\x3B\xBC\x8F\x8F\x7E\x81\x93\x1E\xE7\x8D\x49\x3F\x05\x26\x90\x4B\x68\x90\xB4\x0A\x9F\x85\x46\x94\x48\x10\x05\x30\x92\x40\x12\x90\x00\x4A\x96\x91\x92\x98\x93\x91\x26\x95\x9B\x93\x4B\x9A\x97\x93\x00\x01\x11\x27\xA3\x90\x94\x4F\x9C\x95\x94\xA4\x87\x96\x2A\xA6\x9C\x95\x54\xAD\x90\x95\xB0\x8B\x96\x2B\xB3\x91\x97\x57\xB2\x95\x96\xB4\x8A\x96\x23\xBB\x9C\x97\x5E\xBE\x97\x97\xC0\x81\x9A\x30\xC3\x94\x99\x62\x86\x9F\x98\x1B\x7B\x7D\xEE\x2E\x8C\x72\x00\x9C\x7A\x10\x25\x97\x7C\xF9\x09\x7A\x98\xFF\x74\x7E\x69\xD1\x99\x9A\x40\x03\x1A\x9A\xF9\x7F\x55\x7F\xC9\x8C\x9B\xEE\x28\x82\x9A\x72\x9D\x98\x9C\xB2\x48\x9F\xB2\x57\x90\x6F\x13\x84\x15\x9B\x85\x05\x87\xF5\x67\x7C\x9D\xC6\x67\x85\x9C\xF8\x97",
			"\x67\x3C\xF3\x72\x9D\xF4\x79\x9F\x9E\xE7\x95\x9B\xAC\x6A\x9B\x49\x11\x98\x98\xA0\x08\xA6\x9F\xDE\x71\x7D\x6F\x7A\x8D\x9D\x7B\x86\x01\xA1\x42\xF2\x6B\x9E\x2D\x46\xA5\x9D\x0A\xB9\xA3\x3F\xF7\x57\x10\xE6\x4C\xA2\x73\xFD\x8E\x9A\x46\x92\xA3\xA5\x69\xB7\x72\xA0\x2D\x6E\xA3\x46\xAB\xA4\xA4\xCC\x5F\xA3\x78\x21\xA4\x87\x44\x81\x68\x11\x96\xB0\x7C\x9A\xCC\x80\x86\x37\xA9\xA2\xA5\x8D\x89\x16\xA6\xDC\x75\xA1\x96\x17\xA6\x9F\x92\xB7\x5A\x11\x40\xA6\xA8\x41\xAF\x5B\xA9\x83\xBB\xA3\x9D\x4B\x6C\x11\x52\xF2\x6B\x11\xA9\xA8\xA1\x56\x4D\xB8\xA2\xD7\x7E\x94\xA5\x46\x16\xAD\x80\x2F\xAE\x79\x4C\xCE\xAC\xA4\xC9\x4E\x17\xAB\xF7\x42\xA8\x96\x44\xAF\xA1\xB2\x8A\xAA\x5B\x8F\x1D\x9A\x5A\xBE\x6A\xA4\xB4\x8F\x58\x12\x76\xB7\xA8\xAC\x59\xA5\xA9\xAD\xBD\xA1\xAF\xBF\x71\x13\xDA\x61\xA8\x7B\xA7\x85\xA4\xAB\x0E\x74\x10\xD5\x13\x15\x84\x49\x1E\xA0\xA7\x86\xAB\x66\x43\x96\x10\xB0\x14\x95\x12\xAE\x84\xB4\x9F\x58\x98\xAE\xAC\x72\x57\x14\x6A\x98\x18\xB0\x64\x8D\xAB\xB3\xA2\x9B\xA1\x13\x95\xAE\x7F\x5C\x92\xB5\xB5\x7F\x1A\x11\xB5\x95\xAB\xB6\x5F\x91",
			"\xBE\xA8\xB2\xA8\xAB\x13\xB1\xB9\xB0\x3F\xB4\xBA\xAA\xCE\xB0\xB6\x61\x9C\x05\x21\x27\x0F\xB7\xA5\x9C\x8B\x9C\xB7\x7D\xBB\x3A\x27\x3F\xBF\xAD\xD3\x72\xB2\x84\x75\xB3\xA6\xC3\x1F\x18\xAD\xE7\xAE\x59\xBA\xCD\xB9\xA0\x28\x39\xB3\xB4\x90\x88\xBF\xA1\xB6\xB6\x5D\x28\x4C\xBE\xAC\xEB\x8B\x75\xB5\x9D\xBD\x9A\x28\x22\xB5\xB9\xEF\xBA\xA3\xB6\xE1\xB7\x5F\x28\x64\xBC\xBC\x61\x7C\xA8\xBC\xD0\xBF\xAE\x74\xD9\xBB\xA2\xF3\xAF\xB9\xBF\x32\xBC\xBD\x52\xA4\x14\xB8\xFB\xBA\xA8\x68\xD8\xA9\xBD\x42\xA5\x15\xC1\xD4\x47\xC5\xB6\x00\xD1\xBE\x82\x80\x06\x14\xFA\x86\xBC\x56\xF7\xAC\xAF\x84\x9B\xC1\x65\x53\x1B\x6D\xBB\x30\xBF\xBB\x38\x9C\xC2\x20\x54\x0C\xBE\xBF\xC7\xB0\xBE\x6F\xBF\x79\x14\x0B\xDD\x78\xC5\xD6\x88\xBE\x8B\xEE\x7A\x15\x90\x6B\x12\x5B\x30\xC1\x9E\x88\x88\xB2\xC1\xD3\x6C\x11\xA9\x39\xDC\xA7\x8E\xFA\xBD\xC7\x22\xCF\x5D\x15\x0D\xC0\x59\x86\x89\xC3\x71\x57\x37\x66\x15\xDC\xAD\xBC\x69\xC3\xC1\xC0\x12\xC5\xC8\x16\xDA\x51\x16\x3E\xBA\xB6\xA2\x26\xFB\xBB\xA3\xB2\x09\xCB\x37\x8F\xCD\xB7\xEB\x84\xCE\xCA\xE5\x93\x16\x3C\xDC\xC3\xA8\x2F",
			"\xC6\xCC\xA4\xB4\x03\xB0\x88\xE2\xA4\xCA\x09\xDA\x5D\x16\x33\xC2\xCE\xAF\x4B\xC2\xC6\xEE\x76\x11\xCF\x0B\xB3\xCD\x61\xAA\xC6\xB5\xCA\xB7\x15\xBA\x6C\xCB\xAE\x9B\xCF\x58\x16\x40\xD9\xB8\x99\x2F\x99\x16\xA6\x3A\x14\xCC\x48\xE3\x53\x17\x95\xD6\xD1\x9F\x3D\x19\xD3\x3A\x7C\x15\xD3\x9A\xCC\x56\x2F\x20\xD1\xD4\x5F\x7F\x14\xD4\xC3\x80\x19\xA6\xAA\xDC\x98\x56\xD0\x5E\xD5\xB0\xC5\x21\xAC\x82\x23\xD6\x00\x35\xD7\xD6\xB2\xD9\xD4\xAD\xBA\xD6\xD6\x5E\xF8\xD3\xD7\xC0\xDD\xD5\xB0\xAE\xD6\x59\x06\xAE\xBD\xD4\x61\x41\x19\x41\x4A\xD2\x20\x66\xC0\x06\xD9\xD0\xCB\xDA\xB4\xCD\xD3\xDB\x67\xD5\xDE\xD9\xC3\x17\xDA\xB6\xD4\xDC\xDA\x6B\xDD\xD9\xDA\xDF\xDB\xDA\xB7\xE3\xD0\xDC\x00\x02\x1A\xDC\xE5\xC9\xDC\xBA\xEB\xD1\xDD\x76\xE4\xDC\xDD\xEF\xCE\xDE\xBA\xF2\xD2\xDD\xF0\x04\x1D\x20\xF7\xC2\x21\xBE\x80\x0B\xDF\x7E\xF8\xDF\xDF\x02\x26\x18\xC0\xFC\xD3\xE0\x7F\xFA\xDD\xE0\x08\xE7\xE2\xC2\x84\xEB\xE0\x83\xCC\xE7\xE1\x0E\xF1\xE1\x41\x45\x19\xE0\x88\xD5\xE2\xE2\x0D\xF7\xE2\xC6\x99\xEC\xE2\x8B\xDD\xE0\xE3\x1E\xE1\xE6\xC3\xAE\x5B\x84\x68\x6D\x87\xD8",
			"\xC8\xCF\x87\x31\x28\xD9\xE4\x28\x59\x8B\x8A\x30\xF7\x89\x73\x31\xEF\xE4\x99\xF4\xE4\x8A\x39\x89\x3B\xCD\xBB\xE6\xE7\x9E\xF5\xE7\xE7\x38\xFC\xE5\xCD\xE1\x38\x19\x82\x05\xEA\x20\x47\xE0\x01\xD2\xCB\xE6\xE9\xA6\xC8\xEE\xE9\x4A\xF0\xE8\xD3\xCF\xE4\xEB\xA8\xD5\xEB\xEA\x56\xF9\xE8\xD6\xDB\xE2\xEB\xAE\xD7\xEE\xEB\x5A\xE0\xEC\xD7\xDF\xE4\xED\xB0\xE5\xEB\xEC\x66\xE9\xEC\xDA\xEB\xE2\xEC\x96\xED\xE3\x58\x7D\x83\x92\xDC\xDD\x85\x8D\xB9\xC0\x96\xEE\x82\x91\xEE\xDE\xF7\xE5\x8E\xBE\xFE\xE9\xEF\x7F\xF8\xEE\xE0\xFB\xE0\xF1\xC2\xD0\x59\x19\x05\x28\xF2\x40\x0A\xF0\x00\xC6\xCE\xF1\xF1\x90\xEB\xF1\xE4\x8D\xF3\xF3\xC7\xD2\xF7\xF2\x94\xF8\xF2\xE5\x99\xFC\xF3\xCD\xDE\xF5\xF2\xA0\xFA\xF1\xE8\x9D\xF3\xF5\xCF\xE2\xF7\xF4\xA4\xE8\xF6\xE9\xA9\xFC\xF5\xD5\xEE\xF5\xF4\x6E\xEF\xED\xB1\x0A\x9C\x91\xED\x35\xF7\x3A\xB7\xF2\xF7\xAF\x36\x9C\xF7\x5C\xBD\xF1\x96\xA2\x98\x96\xF0\xB7\x94\xF9\xDF\xC5\xFE\xF7\xC8\xE3\xFA\xF1\xCB\xF9\xF9\xE3\xCA\xF9\x95\xE1\x2B\x19\x41\x52\xF2\x20\xEA\xC0\x06\xFA\xD8\xF3\xFA\xF6\xD5\xFB\xFB\xEB\xDD\xF9\xFB\xDC\xE1\xFC",
			"\x00\x4A\x1F\xFB\xF2\xC2\x24\x19\xE6\xFE\xFA\xF8\xE0\xFA\xFD\xF6\xEC\xFF\xFD\xE9\xF0\xFF\xFA\xF1\xF4\xFF\xF9\xF6\xFE\xFD\xF5\xF8\xFF\xFD\xF2\xFA\xFF\xF6\xFC\x79\xD3\x1A\x61\x30\xCD\x0E\x68\xFD\x59\x68\x74\x5D\x67\x6F\x6F\x65\x72\x62\x65\xDE\x54\x68\x6D\x51\x30\xCE\x04\x80\x0B\x86\x60\x17\x6A\x63\x0E\x81\x3B\xCF\x02\x81\xCE\x56\x80\xAC\x55\x67\x2B\x69\x80\x46\x50\x0D\xF5\x5E\x60\x15\x82\x64\x17\x81\x32\xD1\x0A\x81\x19\x51\x64\x50\x5E\x81\x85\x6A\x80\xBF\x32\x0D\x7A\x6C\x33\x00\x8B\x68\x49\x53\x0D\x51\x64\x81\x28\x76\x81\x11\x6F\x81\x68\x63\x38\xD4\x03\x83\x04\x35\x83\xAD\x55\x0D\x2A\x83\x61\x2C\x87\x58\x08\x8E\x3E\xD6\x07\x84\x37\x5C\x80\x21\x67\x82\x30\x86\x54\xD7\x0B\x66\x82\x6A\x59\x2E\x8F\x80\x02\x18\x0D\x4E\x81\x3C\x1C\x8E\x80\xFF\x5F\x82\x20\x8F\x83\x26\x5A\x83\x53\x6E\x80\xD9\x0D\x85\x45\x69\x84\x08\x68\x80\xDA\x0A\x86\x05\x87\x85\xBB\x5E\x80\xDB\x00\x87\x56\x80\x85\x74\x62\x85\xDD\x3C\x0D\x76\x80\x56\x72\x8D\x65\xAD\x5D\x0D\x7D\x8F\x68\x5F\x8D\x83\x66\x65\x65\x83\x3E\x0D\x68\x5F\x0D\x13\x84\x82\x3B\x86",
			"\x82\x86\x8A\x85\x63\x85\x42\xE0\x02\x84\xBB\x2C\x67\x59\x84\x86\x93\x8B\x81\x7F\x8D\x66\x4B\x83\x88\xE5\x4C\x86\x10\x67\x88\x76\x63\x85\xEE\x31\x0E\x96\x8A\x2B\x98\x8A\x87\x9A\x8E\x3E\xE2\x03\x82\x4A\x64\x84\x99\x8A\x86\xE3\x05\x10\xE4\x09\x8A\xB9\x2B\x8A\x91\x81\x3B\xE6\x0E\x62\xE5\x08\x8B\xB8\x2A\x8B\xA4\x8F\x81\xE7\x00\x8A\x5B\x6D\x89\x8A\x6F\x89\xA6\x87\x33\xE8\x07\x87\x66\x8D\x80\xBB\x89\x54\xE9\x0E\x62\xA2\x85\x66\xE7\x58\x88\xDE\x2A\x0E\xC6\x8E\x87\x78\x83\x68\x91\x8B\x0E\xDB\x86\x54\xD5\x89\x5C\xC3\x82\x86\xAD\x89\x83\x8E\x87\x86\xD1\x8B\x8C\xEC\x89\x56\x85\x85\x8E\xD7\x81\x1E\xEC\x01\x8E\xA1\x8F\x8E\xF1\x8B\x8E\x9B\x89\x8F\xAA\x56\x8F\x61\x87\x8F\xE6\x8D\x4D\xED\x04\x8D\xFC\x89\x62\xF8\x87\x8E\xED\x87\x5F\xA7\x22\x8C\xFE\x82\x89\xE4\x2E\x0E\xF4\x88\x63\x03\x91\x63\xB3\x87\x90\x37\x3F\x0E\xCE\x89\x8E\xD0\x80\x8F\xB1\x30\x0F\x0F\x96\x3B\xCF\x81\x85\x05\x9D\x91\x28\x43\x8E\xF8\x5A\x91\x21\x31\x0F\x22\x98\x90\xA3\x2A\x90\xFD\x86\x90\xFA\x8F\x61\xDD\x88\x85\xAC\x87\x33\xF2\x01\x8E\x24\x91\x80\x14\x92\x39",
			"\xF3\x07\x91\xB1\x85\x82\x2D\x83\x93\x39\x99\x51\xF4\x0D\x88\x3D\x9F\x88\x3F\x91\x92\xF6\x25\x0F\x29\x91\x7B\x97\x2C\x92\x04\x9F\x8F\x53\x86\x0F\x88\x68\x8C\x07\x83\x91\xDD\x37\x0F\x4B\x9E\x93\x7B\x52\x8B\x40\x99\x8F\xF8\x07\x62\x11\x9C\x83\x26\x9D\x8E\xF9\x08\x8E\x45\x9A\x8E\x63\x99\x8F\xFA\x02\x90\x54\x9D\x81\x5D\x9E\x92\xCF\x2B\x0F\x40\x61\x96\x90\x89\x96\x70\x93\x38\xFC\x04\x94\xBA\x79\x25\xFD\x0C\x94\x7B\x90\x4C\xFE\x0E\x97\x7F\x9A\x69\x82\x93\x98\xAC\x20\x00\x0A\x16\x98\x90\x61\x00\x89\x9A\x98\xC7\x22\x00\x8D\x9E\x98\xC5\x43\x00\x91\x97\x4C\xC4\x60\x26\x97\x93\x25\x99\x9F\x0F\xBF\x62\x6C\x9E\x9D\x99\xA0\x9E\x6B\xA2\x93\x6C\xA3\x9F\x99\xA5\x95\x6B\x59\x23\x6F\xF1\x6B\x9A\xAA\x9A\x9A\xD9\x64\x6F\xB0\x9C\x9A\xF0\x6D\x9A\xE2\x67\x6E\xB1\x94\x9B\xB7\x93\x9B\xBA\x99\x9B\xBC\x92\x9B\xBD\x91\x1E\x04\x0A\x10\xC1\x92\x10\xC3\x90\x00\xC5\x97\x9C\xC2\x99\x9C\xC4\x9A\x9C\xC6\x9C\x9C\xC8\x9B\x9C\xD0\x9D\x9C\xD1\x9F\x9C\xD2\x95\x9D\xD4\x97\x9D\xCE\x99\x9D\xD3\x9A\x9D\xD6\x9C\x9D\xD8\x9B\x9D\xE0\x9D\x9D\xE1\x9F\x9D\xE2",
			"\x95\x9E\xE4\x97\x9E\xDE\x95\x99\x92\x92\x4C\x20\x7D\x9E\x03\x72\x70\x1F\x7B\x71\x22\x72\x9F\xEE\x91\x9F\xF6\x9F\x70\x14\x77\x9F\xF5\x93\x9F\xFA\x94\x9F\xFE\x9D\x9F\x00\xAC\x9F\x0F\x71\x1E\x05\x0A\x10\x05\xA2\x10\x07\xA0\x00\x09\xAB\xA0\x06\xAD\xA0\x08\xAE\xA0\x0A\xA0\xA1\x0C\xAF\xA0\x14\xA1\xA1\x15\xA3\xA1\x16\xA9\xA1\x18\xAB\xA1\x12\xAD\xA1\x17\xAE\xA1\x1A\xA0\xA2\x1C\xAF\xA1\x24\xA1\xA2\x25\xA3\xA2\x26\xA9\xA2\x28\xAB\xA2\x22\xAA\x9E\xEB\x9F\xA2\x84\x26\x00\x2E\xA0\xA3\x5C\x20\x74\x42\x71\x74\x00\x0F\x43\x3E\x78\xA3\x36\xAB\xA3\x4D\x4A\x73\x3E\xA1\xA4\x3D\xA3\xA4\x3C\xA5\xA4\x37\xAD\x44\xE1\x14\x78\x83\x74\x1D\x81\x7A\xA4\x4E\xAD\xA4\x50\xA2\x10\x76\x4B\xA4\x86\x7F\xA4\x55\xA1\xA5\x54\xA9\xA5\x71\x71\x1E\x08\x0A\x10\x5D\xAB\x10\x5E\xA1\xA6\x60\xA3\xA6\x00\x0F\xA5\x65\xA2\xA6\x67\xA4\xA6\x66\xAB\xA6\x68\xA7\x00\x68\xAC\xA6\x64\xA9\x00\x6F\xA3\xA7\x6A\xA4\xA7\x69\xA7\xA7\x70\xA8\xA7\x76\xA9\xA7\x7C\xAB\xA7\x7E\xA5\xA7\x80\xAA\xA7\x81\xAD\xA7\x83\xAF\xA7\x77\xA1\x1E\xCC\x7F\x7C\x8A\xAE\x7C\xA1\x4D\x7C\x89\xAC",
			"\xA8\x8F\xA1\xA9\x8E\xA3\xA9\x8B\xA2\xA9\x95\xA0\x7D\x34\xA9\xA9\x82\x2E\x94\x12\x95\x8A\x2F\x9D\x8E\x37\x9E\x66\x0A\x0A\x10\x77\x9B\x5F\xA1\xAA\x8C\x9F\xA8\x42\x0B\x04\xAA\x3C\x93\x66\x5A\x9D\x86\x56\x95\xAA\xDD\x3C\x00\xAC\xA1\x54\x74\x97\x94\x76\x9E\x68\x0D\x05\xAB\x84\x8D\x96\x60\x8F\x94\x0C\x99\x95\x29\x47\xAB\x4A\x81\xAB\x37\x3E\x00\xBC\xA2\xAB\xFB\x8E\xAB\x91\x8D\x92\xC2\xA1\x3B\xA7\xA6\xAC\x41\x91\x3B\x0F\x09\xAC\xC7\x81\x93\x73\x88\x94\x55\x30\x01\xD6\xA3\xAD\x7A\x9B\x67\x5C\x9A\xAD\xE4\x21\x01\xDD\xA9\xAA\xE5\x54\xAC\xB0\xAF\x96\xCF\xA0\x91\xCC\xA0\x8F\xCE\xAB\x5F\x12\x05\xAE\x2E\x91\xAD\xEA\xA7\x42\x13\x02\xAF\x53\x98\xAD\x80\x82\xAD\x43\x28\xAF\xDE\xAE\x85\xED\xAB\x90\xEF\xA6\xAE\x83\x35\x01\xFE\xAF\x62\xE8\xA3\x8A\x0B\x9A\xAC\x83\x36\x01\x07\xBE\x52\x01\xBD\x8F\x03\xBE\x92\x17\x0F\xB0\xB0\x8E\xAA\x46\x95\xAC\x5D\x98\x01\x16\xBF\xAF\x2B\x89\xB0\xD6\x83\xB1\x83\x39\x01\x1D\xB4\xB0\x1E\x98\x91\x20\x99\xAB\x31\x25\xB2\x0C\xBC\x89\xFA\xAE\x89\xFC\xAD\xB2\xF9\x84\xAF\xE2\xAA\x82\x1B\x0C\xB2\xEC\xAF\xB2",
			"\xC9\x81\xB3\x54\x3C\x01\x38\xB0\xAA\x20\xB4\x8E\x0B\xBB\xAE\xDC\x8F\x91\x79\x85\xB3\x1E\xB8\x84\x41\xB5\x92\x43\xBF\x3B\x1D\x0F\xB3\x26\xBE\x8E\x11\xB0\xAC\x22\xB9\xB4\xDA\x2E\x01\x50\xB0\xB1\x3A\xB5\x95\xF5\xA1\xB5\x9A\x84\xB3\x2A\xBE\xB5\xF9\xA6\xB4\xDE\x81\xB6\x6E\x5F\x01\x59\xB4\x52\x60\xBD\xB4\xF7\x20\x02\x69\xB6\xB5\x81\x6B\xB5\x6E\x98\xB4\x62\xB6\xAA\x4B\xB8\x93\x75\xB8\x42\x21\x0F\xB6\x52\xB2\xB7\xBF\xAD\xA9\x3E\x84\xB4\x7D\xB4\xB6\x32\x94\xB7\x32\xBA\xB4\x53\xB0\xB8\x66\xB8\x56\x22\x0C\xB7\xCB\xAE\xB7\xCD\xA0\xAC\xB1\x33\x02\x8E\xBC\x96\x90\xBE\xAE\x92\xB1\x32\x24\x05\xB9\x1E\xBB\xB6\x55\xB9\xB7\xE4\x25\x02\x9C\xB3\xB8\x28\xB7\xB4\x8B\xBE\xB1\x26\x03\xBA\x2A\x92\x2A\x9C\xA2\x96\xC1\xA0\xB7\x6B\x87\xB7\x36\x80\xBB\xE7\xA9\xB8\xAE\xBF\xB9\x87\xBA\xB6\xB2\xB8\xAA\xB9\xB6\x2F\x27\x0C\xB7\x9E\xB9\xB9\x0E\x38\x02\xAA\xB0\x96\xB6\xB5\x97\x6C\xBD\xBB\x33\xBB\xBB\x3C\xB7\x42\x29\x05\xBC\x00\xBA\xA9\xB1\x2A\x02\x33\xA2\xBD\xC4\x2B\x02\xD5\xB6\xBD\xAE\x2C\x02\xD9\xBA\xBD\x9B\x2D\x02\xDD\xBE\xBD\x83\x9E\x02\xE1",
			"\xB2\xBE\xAC\x2F\x02\xE5\xB6\xBE\x80\x20\x03\xE9\xB5\x2B\xB8\x9E\x9B\xF0\xBE\x9A\xBB\x91\xBF\xF3\xBF\xBE\xE5\x66\x9B\xF4\xBD\x9B\xF6\xB5\xBF\xFC\xBA\xBF\xFD\xB3\x6E\xF6\x6F\x9F\x02\xA0\x9F\x02\xAB\x9F\x06\xC2\xC0\x07\xCD\x71\xF9\x95\xC0\x08\xCD\xC0\x01\xA9\xC0\x0C\xCF\xC0\x15\x76\x2B\x32\xAF\xAA\xD6\xB4\xA8\x82\xA9\xC1\x18\xCB\xC1\x76\xAE\xA6\x85\xA1\xA7\x86\xAC\xC1\x1F\xCA\xC1\x21\xC5\xC2\x23\xC2\xC2\x24\xC7\xC2\x26\xC9\xC2\x2C\xC8\xA8\x94\xA0\xA9\x2F\xC4\x49\xC1\x70\xC3\x97\xA5\xC3\x34\xC7\xC3\x96\xA8\xC3\x31\xCB\xC3\x36\xCE\xC2\x36\xC9\xC3\xC6\x73\xC3\x40\xCC\xC3\x3A\xCF\xC3\x44\xC3\xC4\x46\xC9\xC4\xBA\x45\x2B\xAD\xB8\xBC\xCA\xB1\x3B\x31\x00\xBC\xCC\xBD\xB5\x4F\xC1\x30\x32\x05\xB2\xC1\xBA\xB8\xAF\xB9\x51\x33\x00\xBD\x20\x89\xC5\xAE\xBE\x3E\x34\x0E\xC5\xF3\xA3\xC5\x86\xB2\xB8\x60\xCE\xC4\x82\xB4\x51\x66\xC7\xBA\xF9\x85\x03\x64\xC0\x93\x84\xB9\xAD\x6E\xC5\xC5\xB6\xA7\xBC\xB8\xA9\xBC\x24\x56\x03\x71\xCE\xB2\x73\xCB\xAF\x54\xC5\x10\x37\x0D\xC7\x51\xB9\xC6\x79\xCB\x51\x38\x04\xC8\x88\xB7\xB9\x02\xB2\xBC\xDD\x39",
			"\x03\x8A\xC3\xB6\xA5\xB5\xB6\x7A\xC9\x50\x3A\x01\xC9\x65\x83\xC9\x85\xB5\xC7\x01\x3B\x03\x98\xCF\xC5\x6D\xC5\xC9\xA0\xB4\x32\x52\xC8\xC7\x1A\xBA\xAD\x3D\x0F\xC9\xB2\xA6\xC8\xA7\xC0\x95\x28\x4E\x03\xAA\xCD\xAA\xE0\xA6\xC1\x21\xBE\xC8\x76\xC0\xCA\xA6\xC9\xAE\x67\xC9\x50\x3F\x01\xCB\x27\xB7\x96\x19\x92\xCA\xB7\xC5\xBB\x8C\xC2\xB1\xB6\xCB\xC6\x39\xBF\xC7\x30\xB1\xC8\xB4\xB0\x8C\xB7\x2D\xC4\x87\xC3\x38\x40\x0E\xCB\xBD\xA5\xCC\x54\xB7\xCC\x41\x91\x04\x9F\xCC\xCA\xBA\xCE\xCA\xE4\x22\x04\xD4\xCB\xC8\xCA\xCB\xB3\xCC\xC3\xCA\x27\x4C\xCD\x0A\xB3\xCC\xBA\xB9\xCB\x0A\xB8\xBB\x49\x53\x04\xE1\xC5\x98\x90\x20\xCD\xAD\xCB\xC5\xCA\xB4\x04\xA3\xB8\xCE\xD6\x8A\xCE\x09\x5A\xCF\x42\xBC\xCF\xB8\xC6\xCD\x5A\xCE\xCE\x1F\x31\xCF\xFD\xCA\xBE\x5B\x26\x04\xED\xB8\xD0\xAE\x27\x04\x0B\xDC\xD0\x9B\x28\x04\x0F\xD0\xD1\xB2\x29\x04\x13\xD4\xD1\xC8\x2A\x04\x17\xD8\xD1\x92\x9B\x04\x1B\xDC\xD1\x91\x2C\x04\x1F\xDE\x4B\xF4\xCD\xCD\xF6\xC8\xC6\xA1\xC4\xD0\xF7\x2D\x04\x06\xD1\xD0\xE3\xCC\xB5\x74\xBE\x04\x2D\xD6\x65\xFE\xCC\xB4\x4F\x03\xD3\x66\x98\xB1",
			"\x68\x92\xCC\x6A\x80\x05\x50\xB5\xD3\x23\x62\xAC\x51\x0C\xAB\x40\xDC\x63\x00\xD1\x87\x02\xD7\xBB\xD8\xC6\xCE\xCB\xBC\xCE\xB5\xCA\xC5\x47\xD7\xB1\xB3\xC9\xB1\x26\xDA\xD2\xB7\xC2\x05\xA5\xC9\xD4\xC8\xB6\xD5\x28\xDE\xD4\x42\xBC\xD5\xCD\xC1\xBD\x2F\xD3\xB7\x9C\xC1\xD6\xE2\x89\xD2\x4B\xD1\xD5\x62\xDA\xC9\x74\xCC\xD3\x66\xDF\x2C\x53\x0F\xD3\x68\xD0\xD5\xC8\xC1\xB7\x63\xDF\xB7\xAE\xB4\x05\x38\xD0\xB4\x5E\xDC\xB4\x60\xDC\xD4\xC4\xC7\xD7\x91\xB4\xD7\x6F\xD2\xD5\x34\x84\xCB\x5F\xD9\xD6\xDA\x25\x05\x7B\xD1\xBB\x7D\xD8\xB7\x6A\xD5\xCD\xD6\xB6\x05\x23\xD0\xD2\x8D\x47\x05\x95\xD6\xD9\xBF\x48\x05\x99\xDA\xD9\x9C\x29\x05\x9D\xDE\xD9\xA2\xD3\xDA\xE1\x1A\x05\xA1\xD4\xDA\x52\x2B\x05\xA7\xD8\xD0\x25\xD9\xCE\x75\xD3\xAC\x8F\xD3\xBB\xF7\x2C\x05\x8D\xD1\xD8\x6C\xD0\xC8\xDA\xAD\x05\xB5\xDB\xCE\x5A\xD9\xC7\x7F\xDE\x56\x5E\x0D\xD8\x45\xD7\x66\xAF\xD3\xDC\xD8\x80\xD8\xBC\xD2\xD8\x98\xB4\xD8\xDD\x3F\x05\xBB\xD7\xC7\xBD\xD5\xCF\x9F\xB0\x06\xCF\xDE\xD2\xB7\xDB\xCC\x74\xB1\x06\xD5\xD6\xDB\xA8\xD8\x25\x63\x05\xBE\x62\x0B\xDA\xDD\xD3\xDE\xE4",
			"\xDF\x24\x64\x02\xDE\xE5\xD5\x28\x65\x08\xDE\xE9\xD4\x25\x66\x0C\xDE\xED\xDE\x25\x67\x00\xDF\xE3\xDD\xDA\xFB\xCF\xDA\x5A\xBA\xDC\x8D\xCC\xDC\x72\x38\x06\xDB\xDE\xCC\xFF\x78\xD8\x7E\xDA\xD8\x85\xDB\xD6\xC0\xC9\xB2\x6E\xD8\xDC\xE7\xC3\xD7\x61\xC1\x32\x69\x0F\xDF\x06\xEA\xD3\xC1\xCF\xDB\xC2\xA0\xD2\x6A\x04\xDF\xF1\xD4\x2C\x6B\x08\xE1\x19\xEC\x06\x1C\xE9\xE1\x7B\x2D\x06\x1F\xE0\xE2\xBF\x2E\x06\x23\xE4\xE2\xDB\x1F\x06\x27\xEC\xD0\xF6\xDF\xCF\xF8\xD9\xCC\xD7\xD4\xCE\xBB\xCA\xE0\x92\xDE\xD9\x70\x0B\xE2\x28\xEA\x2B\x71\x08\xE3\x39\xE2\x28\x72\x0C\xE3\x3D\xED\x26\x73\x00\xE4\x1C\xD4\x07\x44\xE1\xE4\x6A\x25\x07\x47\xE8\xE4\x74\x26\x07\x4B\xEC\xE4\xAF\x27\x07\x4F\xE2\xBE\x78\x03\xE5\x50\xE3\x26\x79\x06\xE5\x57\xEB\xE5\x5C\xED\xE5\xDB\x1A\x07\x5A\xEE\xE5\x8B\x2B\x07\x61\xE2\xE6\x66\xE7\xE6\x7B\x9C\x07\x65\xE8\xE6\x6C\xEB\x27\x7D\x0B\xE6\x6D\xE0\x98\xEF\x01\x1E\xF4\x0B\x24\x3F\x08\x09\xC8\x0C\x0F\x4B\x21\x00\xC9\x00\x0F\x4A\x2F\x01\x40\x0E\x0F\xDB\x13\x00\x82\xEF\x07\xE4\x0F\x0B\xF0\x03\x00\x03\x00\x03\x2B\x00\x10\x06\x1F",
			"\xE8\x88\x98\x1F\x05\x1D\x1F\xC4\x90\x20\x05\x1E\x1E\x02\x10\x1F\x0A\x23\x11\x1A\x15\x1B\x02\x1B\x1F\x00\x02\x21\x02\x15\x21\x02\x14\x24\x47\x22\x1F\xF4\x15\x10\x0F\x22\x10\x3D\x21\x23\x05\x18\x22\x3A\x2D\x19\x02\x1C\x3E\x00\x04\xEB\xB6\xE2\xEB\xB5\xE8\xEB\xB7\xE3\xEB\xBA\xED\xEB\xBC\xEF\xEB\xB9\xE0\xEC\xB4\xE3\x3E\xC1\xE0\x00\x1D\x40\x00\x10\x48\xEC\xAF\x12\x10\xC9\xE6\x24\x00\x0E\x10\x02\x17\x1E\x00\x0D\x20\x00\x06\x20\x02\x1F\x1F\xC2\xEE\xEB\x00\x0E\x22\x00\x09\x29\x02\x15\x2F\xC5\xE7\x27\x02\x15\x2A\x02\x1F\x32\xD9\xE7\xEE\xC5\xEB\xEB\xE9\xEA\xED\xEA\xED\xEE\xEC\xEF\xEE\x02\x1F\x29\xE8\xEE\xEE\xF3\xE0\xEF\xEB\xE5\xEF\xE8\xE9\xEC\xFA\xEE\xE9\xCA\xE2\x10\xE1\x30\x00\xF9\x3D\xEF\x02\xF7\xEC\xFB\xEC\xEC\xA9\x16\xF0\x08\xF0\x00\x16\x40\x00\x13\x42\xF0\xC9\xE4\xEB\x13\x37\xEF\xC5\xEE\x21\x12\xF4\xEF\x12\xF8\x35\xF8\xE5\xF1\xB8\xE7\x13\x02\x1A\x13\x19\xF6\xF1\x16\xFD\x13\x02\x10\x14\xC0\xEC\x1E\xC5\xE3\x29\x19\xFA\x35\xC0\xE3\x1E\x20\xF6\xEF\x2D\xF9\xF0\x05\xFE\xF0\xFC\xE9\xEC\xFF\xE1\xF3\x1B\x42\xF3\x02\x17\xF3",
			"\x03\x48\xF3\x3C\xF8\x41\x00\x03\x22\x1F\xF3\x12\xC0\xE0\x3A\x1A\xF2\x10\xE2\x25\xF4\x48\xF6\xF1\x39\x22\xF1\xAA\x20\x00\x32\x38\xEE\x2C\x20\x00\xF2\x22\xF1\x2A\x24\xEB\x4C\x12\x10\x4F\x1E\x2D\x2F\xF0\x00\x10\x32\x10\x39\x32\x10\x67\x38\xEE\x79\x30\xEC\x31\xF5\xF6\x33\xF7\xF6\x02\x1B\xF3\x31\xFE\xF3\x5B\xF6\x39\x00\x00\x24\xC5\xE9\x1E\x41\xF3\xF7\xC5\xE4\x13\xC0\xE5\x36\x02\x12\x36\x02\x1C\x30\x48\xFD\x28\x02\x14\x33\xE8\xE5\x38\x02\x13\x34\x64\xF8\xF6\x3C\xF1\xF3\x20\x24\xF7\xB4\xEA\x21\x00\x08\x16\x02\x13\x32\xC0\xE0\x23\x00\x05\x37\x02\x11\x39\x00\x06\x33\xC0\xEB\x2F\xC5\xE4\x2D\x00\x06\x32\xC0\xE6\x3A\x00\x06\x3C\x87\xF1\x19\x30\xF0\x16\x19\xF9\x36\x02\x16\x34\x19\xF9\xEC\xB3\x33\xFA\x09\xF4\x39\xC5\xE7\x37\x02\x10\x32\xC0\xE3\x35\xA5\xF7\xFB\x3C\xF7\x23\x00\x03\x3A\xAE\xFD\xFB\x66\xF9\xF0\xC8\x3E\x3D\x86\xF4\x18\x02\x1D\x3B\x02\xFF\x3A\x02\xFE\x39\x00\x00",
		};
		vl::glr::DecompressSerializedData(compressed, true, dataSolidRows, dataRows, dataBlock, dataRemain, outputStream);
	}
}

