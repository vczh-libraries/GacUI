/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "VlppWorkflowLibrary.h"
#include "VlppWorkflowRuntime.h"
#include "VlppReflection.h"
#include "VlppOS.h"
#include "Vlpp.h"
#include "VlppRegex.h"
#include "VlppGlrParser.h"

/***********************************************************************
.\CPP\WFMERGECPP.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::C++ Code Generator

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_CPP_WFMERGECPP
#define VCZH_WORKFLOW_CPP_WFMERGECPP


namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{

/***********************************************************************
MergeCpp
***********************************************************************/

			class MergeCppMultiPlatformException : public Exception
			{
			public:
				vint											row32;
				vint											column32;
				vint											row64;
				vint											column64;

				MergeCppMultiPlatformException(vint _row32, vint _column32, vint _row64, vint _column64);
			};

			extern WString				MergeCppMultiPlatform(const WString& code32, const WString& code64);
			extern WString				MergeCppFileContent(const WString& dst, const WString& src);
		}
	}
}

#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_AST_AST
#define VCZH_WORKFLOW_PARSER_AST_AST


namespace vl::workflow
{
	class WfAttachEventExpression;
	class WfAttribute;
	class WfAutoPropertyDeclaration;
	class WfBaseConstructorCall;
	class WfBinaryExpression;
	class WfBindExpression;
	class WfBlockStatement;
	class WfBreakStatement;
	class WfCallExpression;
	class WfCastResultInterfaceDeclaration;
	class WfChildExpression;
	class WfChildType;
	class WfClassDeclaration;
	class WfCoOperatorExpression;
	class WfCoOperatorStatement;
	class WfCoPauseStatement;
	class WfCoProviderStatement;
	class WfConstructorArgument;
	class WfConstructorDeclaration;
	class WfConstructorExpression;
	class WfContinueStatement;
	class WfCoroutineStatement;
	class WfDeclaration;
	class WfDeleteStatement;
	class WfDestructorDeclaration;
	class WfDetachEventExpression;
	class WfEnumDeclaration;
	class WfEnumItem;
	class WfEnumItemIntersection;
	class WfEnumerableType;
	class WfEventDeclaration;
	class WfExpectedTypeCastExpression;
	class WfExpression;
	class WfExpressionStatement;
	class WfFloatingExpression;
	class WfForEachStatement;
	class WfFormatExpression;
	class WfFunctionArgument;
	class WfFunctionDeclaration;
	class WfFunctionExpression;
	class WfFunctionType;
	class WfGotoStatement;
	class WfIfExpression;
	class WfIfStatement;
	class WfInferExpression;
	class WfIntegerExpression;
	class WfLetExpression;
	class WfLetVariable;
	class WfLiteralExpression;
	class WfMapType;
	class WfMemberExpression;
	class WfMixinCastExpression;
	class WfModule;
	class WfModuleUsingFragment;
	class WfModuleUsingItem;
	class WfModuleUsingNameFragment;
	class WfModuleUsingPath;
	class WfModuleUsingWildCardFragment;
	class WfNamespaceDeclaration;
	class WfNewClassExpression;
	class WfNewCoroutineExpression;
	class WfNewInterfaceExpression;
	class WfNullableType;
	class WfObservableListType;
	class WfObserveExpression;
	class WfOrderedLambdaExpression;
	class WfOrderedNameExpression;
	class WfPredefinedType;
	class WfPropertyDeclaration;
	class WfRaiseExceptionStatement;
	class WfRangeExpression;
	class WfRawPointerType;
	class WfReferenceExpression;
	class WfReferenceType;
	class WfReturnStatement;
	class WfSetTestingExpression;
	class WfSharedPointerType;
	class WfStateDeclaration;
	class WfStateInput;
	class WfStateInvokeStatement;
	class WfStateMachineDeclaration;
	class WfStateMachineStatement;
	class WfStateSwitchArgument;
	class WfStateSwitchCase;
	class WfStateSwitchStatement;
	class WfStatement;
	class WfStaticInitDeclaration;
	class WfStringExpression;
	class WfStructDeclaration;
	class WfStructMember;
	class WfSwitchCase;
	class WfSwitchStatement;
	class WfThisExpression;
	class WfTopQualifiedExpression;
	class WfTopQualifiedType;
	class WfTryStatement;
	class WfType;
	class WfTypeCastingExpression;
	class WfTypeOfExpressionExpression;
	class WfTypeOfTypeExpression;
	class WfTypeTestingExpression;
	class WfUnaryExpression;
	class WfVariableDeclaration;
	class WfVariableStatement;
	class WfVirtualCfeDeclaration;
	class WfVirtualCfeExpression;
	class WfVirtualCseDeclaration;
	class WfVirtualCseExpression;
	class WfVirtualCseStatement;
	class WfWhileStatement;

	enum class WfFunctionKind
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Static = 0,
		Override = 1,
		Normal = 2,
	};

	enum class WfPredefinedTypeName
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Void = 0,
		Object = 1,
		Interface = 2,
		Int = 3,
		UInt = 4,
		Float = 5,
		Double = 6,
		String = 7,
		Char = 8,
		Bool = 9,
	};

	enum class WfMapWritability
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Readonly = 0,
		Writable = 1,
	};

	enum class WfFunctionAnonymity
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Named = 0,
		Anonymous = 1,
	};

	enum class WfClassKind
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Class = 0,
		Interface = 1,
	};

	enum class WfConstructorType
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Undefined = 0,
		SharedPtr = 1,
		RawPtr = 2,
	};

	enum class WfEnumKind
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Normal = 0,
		Flag = 1,
	};

	enum class WfEnumItemKind
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Constant = 0,
		Intersection = 1,
	};

	enum class WfAPConst
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Readonly = 0,
		Writable = 1,
	};

	enum class WfAPObserve
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Observable = 0,
		NotObservable = 1,
	};

	enum class WfForEachDirection
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Normal = 0,
		Reversed = 1,
	};

	enum class WfStateSwitchType
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Default = 0,
		Pass = 1,
		PassAndReturn = 2,
		Ignore = 3,
		IgnoreAndReturn = 4,
	};

	enum class WfStateInvokeType
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Goto = 0,
		Push = 1,
	};

	enum class WfLiteralValue
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Null = 0,
		True = 1,
		False = 2,
	};

	enum class WfUnaryOperator
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Positive = 0,
		Negative = 1,
		Not = 2,
	};

	enum class WfBinaryOperator
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Assign = 0,
		Index = 1,
		FlagAnd = 2,
		FlagOr = 3,
		FailedThen = 4,
		Exp = 5,
		Add = 6,
		Sub = 7,
		Mul = 8,
		Div = 9,
		Mod = 10,
		Shl = 11,
		Shr = 12,
		LT = 13,
		GT = 14,
		LE = 15,
		GE = 16,
		EQ = 17,
		NE = 18,
		Xor = 19,
		And = 20,
		Or = 21,
	};

	enum class WfRangeBoundary
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Inclusive = 0,
		Exclusive = 1,
	};

	enum class WfSetTesting
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		In = 0,
		NotIn = 1,
	};

	enum class WfTypeCastingStrategy
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Strong = 0,
		Weak = 1,
	};

	enum class WfTypeTesting
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		IsType = 0,
		IsNotType = 1,
		IsNull = 2,
		IsNotNull = 3,
	};

	enum class WfObserveType
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		SimpleObserve = 0,
		ExtendedObserve = 1,
	};

	enum class WfModuleType
	{
		UNDEFINED_ENUM_ITEM_VALUE = -1,
		Module = 0,
		Unit = 1,
	};

	class WfType abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<WfType>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfPredefinedType* node) = 0;
			virtual void Visit(WfTopQualifiedType* node) = 0;
			virtual void Visit(WfReferenceType* node) = 0;
			virtual void Visit(WfRawPointerType* node) = 0;
			virtual void Visit(WfSharedPointerType* node) = 0;
			virtual void Visit(WfNullableType* node) = 0;
			virtual void Visit(WfEnumerableType* node) = 0;
			virtual void Visit(WfMapType* node) = 0;
			virtual void Visit(WfObservableListType* node) = 0;
			virtual void Visit(WfFunctionType* node) = 0;
			virtual void Visit(WfChildType* node) = 0;
		};

		virtual void Accept(WfType::IVisitor* visitor) = 0;

	};

	class WfExpression abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<WfExpression>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfThisExpression* node) = 0;
			virtual void Visit(WfTopQualifiedExpression* node) = 0;
			virtual void Visit(WfReferenceExpression* node) = 0;
			virtual void Visit(WfOrderedNameExpression* node) = 0;
			virtual void Visit(WfOrderedLambdaExpression* node) = 0;
			virtual void Visit(WfMemberExpression* node) = 0;
			virtual void Visit(WfChildExpression* node) = 0;
			virtual void Visit(WfLiteralExpression* node) = 0;
			virtual void Visit(WfFloatingExpression* node) = 0;
			virtual void Visit(WfIntegerExpression* node) = 0;
			virtual void Visit(WfStringExpression* node) = 0;
			virtual void Visit(WfUnaryExpression* node) = 0;
			virtual void Visit(WfBinaryExpression* node) = 0;
			virtual void Visit(WfLetExpression* node) = 0;
			virtual void Visit(WfIfExpression* node) = 0;
			virtual void Visit(WfRangeExpression* node) = 0;
			virtual void Visit(WfSetTestingExpression* node) = 0;
			virtual void Visit(WfConstructorExpression* node) = 0;
			virtual void Visit(WfInferExpression* node) = 0;
			virtual void Visit(WfTypeCastingExpression* node) = 0;
			virtual void Visit(WfTypeTestingExpression* node) = 0;
			virtual void Visit(WfTypeOfTypeExpression* node) = 0;
			virtual void Visit(WfTypeOfExpressionExpression* node) = 0;
			virtual void Visit(WfAttachEventExpression* node) = 0;
			virtual void Visit(WfDetachEventExpression* node) = 0;
			virtual void Visit(WfObserveExpression* node) = 0;
			virtual void Visit(WfCallExpression* node) = 0;
			virtual void Visit(WfFunctionExpression* node) = 0;
			virtual void Visit(WfNewClassExpression* node) = 0;
			virtual void Visit(WfNewInterfaceExpression* node) = 0;
			virtual void Visit(WfVirtualCfeExpression* node) = 0;
			virtual void Visit(WfVirtualCseExpression* node) = 0;
		};

		virtual void Accept(WfExpression::IVisitor* visitor) = 0;

	};

	class WfStatement abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<WfStatement>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfBreakStatement* node) = 0;
			virtual void Visit(WfContinueStatement* node) = 0;
			virtual void Visit(WfReturnStatement* node) = 0;
			virtual void Visit(WfDeleteStatement* node) = 0;
			virtual void Visit(WfRaiseExceptionStatement* node) = 0;
			virtual void Visit(WfIfStatement* node) = 0;
			virtual void Visit(WfWhileStatement* node) = 0;
			virtual void Visit(WfTryStatement* node) = 0;
			virtual void Visit(WfBlockStatement* node) = 0;
			virtual void Visit(WfGotoStatement* node) = 0;
			virtual void Visit(WfVariableStatement* node) = 0;
			virtual void Visit(WfExpressionStatement* node) = 0;
			virtual void Visit(WfVirtualCseStatement* node) = 0;
			virtual void Visit(WfCoroutineStatement* node) = 0;
			virtual void Visit(WfStateMachineStatement* node) = 0;
		};

		virtual void Accept(WfStatement::IVisitor* visitor) = 0;

	};

	class WfAttribute : public vl::glr::ParsingAstBase, vl::reflection::Description<WfAttribute>
	{
	public:
		vl::glr::ParsingToken category;
		vl::glr::ParsingToken name;
		vl::Ptr<WfExpression> value;
	};

	class WfDeclaration abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<WfDeclaration>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfNamespaceDeclaration* node) = 0;
			virtual void Visit(WfFunctionDeclaration* node) = 0;
			virtual void Visit(WfVariableDeclaration* node) = 0;
			virtual void Visit(WfEventDeclaration* node) = 0;
			virtual void Visit(WfPropertyDeclaration* node) = 0;
			virtual void Visit(WfStaticInitDeclaration* node) = 0;
			virtual void Visit(WfConstructorDeclaration* node) = 0;
			virtual void Visit(WfDestructorDeclaration* node) = 0;
			virtual void Visit(WfClassDeclaration* node) = 0;
			virtual void Visit(WfEnumDeclaration* node) = 0;
			virtual void Visit(WfStructDeclaration* node) = 0;
			virtual void Visit(WfVirtualCfeDeclaration* node) = 0;
			virtual void Visit(WfVirtualCseDeclaration* node) = 0;
		};

		virtual void Accept(WfDeclaration::IVisitor* visitor) = 0;

		vl::collections::List<vl::Ptr<WfAttribute>> attributes;
		vl::glr::ParsingToken name;
	};

	class WfPredefinedType : public WfType, vl::reflection::Description<WfPredefinedType>
	{
	public:
		WfPredefinedTypeName name = WfPredefinedTypeName::UNDEFINED_ENUM_ITEM_VALUE;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfTopQualifiedType : public WfType, vl::reflection::Description<WfTopQualifiedType>
	{
	public:
		vl::glr::ParsingToken name;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfReferenceType : public WfType, vl::reflection::Description<WfReferenceType>
	{
	public:
		vl::glr::ParsingToken name;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfRawPointerType : public WfType, vl::reflection::Description<WfRawPointerType>
	{
	public:
		vl::Ptr<WfType> element;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfSharedPointerType : public WfType, vl::reflection::Description<WfSharedPointerType>
	{
	public:
		vl::Ptr<WfType> element;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfNullableType : public WfType, vl::reflection::Description<WfNullableType>
	{
	public:
		vl::Ptr<WfType> element;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfEnumerableType : public WfType, vl::reflection::Description<WfEnumerableType>
	{
	public:
		vl::Ptr<WfType> element;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfMapType : public WfType, vl::reflection::Description<WfMapType>
	{
	public:
		WfMapWritability writability = WfMapWritability::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfType> key;
		vl::Ptr<WfType> value;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfObservableListType : public WfType, vl::reflection::Description<WfObservableListType>
	{
	public:
		vl::Ptr<WfType> element;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfFunctionType : public WfType, vl::reflection::Description<WfFunctionType>
	{
	public:
		vl::Ptr<WfType> result;
		vl::collections::List<vl::Ptr<WfType>> arguments;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfChildType : public WfType, vl::reflection::Description<WfChildType>
	{
	public:
		vl::Ptr<WfType> parent;
		vl::glr::ParsingToken name;

		void Accept(WfType::IVisitor* visitor) override;
	};

	class WfNamespaceDeclaration : public WfDeclaration, vl::reflection::Description<WfNamespaceDeclaration>
	{
	public:
		vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfFunctionArgument : public vl::glr::ParsingAstBase, vl::reflection::Description<WfFunctionArgument>
	{
	public:
		vl::collections::List<vl::Ptr<WfAttribute>> attributes;
		vl::glr::ParsingToken name;
		vl::Ptr<WfType> type;
	};

	class WfFunctionDeclaration : public WfDeclaration, vl::reflection::Description<WfFunctionDeclaration>
	{
	public:
		WfFunctionKind functionKind = WfFunctionKind::UNDEFINED_ENUM_ITEM_VALUE;
		WfFunctionAnonymity anonymity = WfFunctionAnonymity::UNDEFINED_ENUM_ITEM_VALUE;
		vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
		vl::Ptr<WfType> returnType;
		vl::Ptr<WfStatement> statement;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfVariableDeclaration : public WfDeclaration, vl::reflection::Description<WfVariableDeclaration>
	{
	public:
		vl::Ptr<WfType> type;
		vl::Ptr<WfExpression> expression;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfEventDeclaration : public WfDeclaration, vl::reflection::Description<WfEventDeclaration>
	{
	public:
		vl::collections::List<vl::Ptr<WfType>> arguments;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfPropertyDeclaration : public WfDeclaration, vl::reflection::Description<WfPropertyDeclaration>
	{
	public:
		vl::Ptr<WfType> type;
		vl::glr::ParsingToken getter;
		vl::glr::ParsingToken setter;
		vl::glr::ParsingToken valueChangedEvent;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfStaticInitDeclaration : public WfDeclaration, vl::reflection::Description<WfStaticInitDeclaration>
	{
	public:
		vl::Ptr<WfStatement> statement;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfBaseConstructorCall : public vl::glr::ParsingAstBase, vl::reflection::Description<WfBaseConstructorCall>
	{
	public:
		vl::Ptr<WfType> type;
		vl::collections::List<vl::Ptr<WfExpression>> arguments;
	};

	class WfConstructorDeclaration : public WfDeclaration, vl::reflection::Description<WfConstructorDeclaration>
	{
	public:
		WfConstructorType constructorType = WfConstructorType::UNDEFINED_ENUM_ITEM_VALUE;
		vl::collections::List<vl::Ptr<WfBaseConstructorCall>> baseConstructorCalls;
		vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
		vl::Ptr<WfStatement> statement;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfDestructorDeclaration : public WfDeclaration, vl::reflection::Description<WfDestructorDeclaration>
	{
	public:
		vl::Ptr<WfStatement> statement;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfClassDeclaration : public WfDeclaration, vl::reflection::Description<WfClassDeclaration>
	{
	public:
		WfClassKind kind = WfClassKind::UNDEFINED_ENUM_ITEM_VALUE;
		WfConstructorType constructorType = WfConstructorType::UNDEFINED_ENUM_ITEM_VALUE;
		vl::collections::List<vl::Ptr<WfType>> baseTypes;
		vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfEnumItemIntersection : public vl::glr::ParsingAstBase, vl::reflection::Description<WfEnumItemIntersection>
	{
	public:
		vl::glr::ParsingToken name;
	};

	class WfEnumItem : public vl::glr::ParsingAstBase, vl::reflection::Description<WfEnumItem>
	{
	public:
		vl::collections::List<vl::Ptr<WfAttribute>> attributes;
		vl::glr::ParsingToken name;
		WfEnumItemKind kind = WfEnumItemKind::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken number;
		vl::collections::List<vl::Ptr<WfEnumItemIntersection>> intersections;
	};

	class WfEnumDeclaration : public WfDeclaration, vl::reflection::Description<WfEnumDeclaration>
	{
	public:
		WfEnumKind kind = WfEnumKind::UNDEFINED_ENUM_ITEM_VALUE;
		vl::collections::List<vl::Ptr<WfEnumItem>> items;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfStructMember : public vl::glr::ParsingAstBase, vl::reflection::Description<WfStructMember>
	{
	public:
		vl::collections::List<vl::Ptr<WfAttribute>> attributes;
		vl::glr::ParsingToken name;
		vl::Ptr<WfType> type;
	};

	class WfStructDeclaration : public WfDeclaration, vl::reflection::Description<WfStructDeclaration>
	{
	public:
		vl::collections::List<vl::Ptr<WfStructMember>> members;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfVirtualCfeDeclaration abstract : public WfDeclaration, vl::reflection::Description<WfVirtualCfeDeclaration>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfAutoPropertyDeclaration* node) = 0;
			virtual void Visit(WfCastResultInterfaceDeclaration* node) = 0;
		};

		virtual void Accept(WfVirtualCfeDeclaration::IVisitor* visitor) = 0;

		vl::collections::List<vl::Ptr<WfDeclaration>> expandedDeclarations;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfAutoPropertyDeclaration : public WfVirtualCfeDeclaration, vl::reflection::Description<WfAutoPropertyDeclaration>
	{
	public:
		WfFunctionKind functionKind = WfFunctionKind::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfType> type;
		WfAPConst configConst = WfAPConst::UNDEFINED_ENUM_ITEM_VALUE;
		WfAPObserve configObserve = WfAPObserve::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> expression;

		void Accept(WfVirtualCfeDeclaration::IVisitor* visitor) override;
	};

	class WfCastResultInterfaceDeclaration : public WfVirtualCfeDeclaration, vl::reflection::Description<WfCastResultInterfaceDeclaration>
	{
	public:
		vl::Ptr<WfType> baseType;
		vl::Ptr<WfType> elementType;

		void Accept(WfVirtualCfeDeclaration::IVisitor* visitor) override;
	};

	class WfVirtualCseDeclaration abstract : public WfDeclaration, vl::reflection::Description<WfVirtualCseDeclaration>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfStateMachineDeclaration* node) = 0;
		};

		virtual void Accept(WfVirtualCseDeclaration::IVisitor* visitor) = 0;

		vl::collections::List<vl::Ptr<WfDeclaration>> expandedDeclarations;

		void Accept(WfDeclaration::IVisitor* visitor) override;
	};

	class WfStateInput : public vl::glr::ParsingAstBase, vl::reflection::Description<WfStateInput>
	{
	public:
		vl::glr::ParsingToken name;
		vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
	};

	class WfStateDeclaration : public vl::glr::ParsingAstBase, vl::reflection::Description<WfStateDeclaration>
	{
	public:
		vl::glr::ParsingToken name;
		vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
		vl::Ptr<WfStatement> statement;
	};

	class WfStateMachineDeclaration : public WfVirtualCseDeclaration, vl::reflection::Description<WfStateMachineDeclaration>
	{
	public:
		vl::collections::List<vl::Ptr<WfStateInput>> inputs;
		vl::collections::List<vl::Ptr<WfStateDeclaration>> states;

		void Accept(WfVirtualCseDeclaration::IVisitor* visitor) override;
	};

	class WfBreakStatement : public WfStatement, vl::reflection::Description<WfBreakStatement>
	{
	public:

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfContinueStatement : public WfStatement, vl::reflection::Description<WfContinueStatement>
	{
	public:

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfReturnStatement : public WfStatement, vl::reflection::Description<WfReturnStatement>
	{
	public:
		vl::Ptr<WfExpression> expression;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfDeleteStatement : public WfStatement, vl::reflection::Description<WfDeleteStatement>
	{
	public:
		vl::Ptr<WfExpression> expression;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfRaiseExceptionStatement : public WfStatement, vl::reflection::Description<WfRaiseExceptionStatement>
	{
	public:
		vl::Ptr<WfExpression> expression;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfIfStatement : public WfStatement, vl::reflection::Description<WfIfStatement>
	{
	public:
		vl::Ptr<WfType> type;
		vl::glr::ParsingToken name;
		vl::Ptr<WfExpression> expression;
		vl::Ptr<WfStatement> trueBranch;
		vl::Ptr<WfStatement> falseBranch;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfWhileStatement : public WfStatement, vl::reflection::Description<WfWhileStatement>
	{
	public:
		vl::Ptr<WfExpression> condition;
		vl::Ptr<WfStatement> statement;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfTryStatement : public WfStatement, vl::reflection::Description<WfTryStatement>
	{
	public:
		vl::Ptr<WfStatement> protectedStatement;
		vl::glr::ParsingToken name;
		vl::Ptr<WfStatement> catchStatement;
		vl::Ptr<WfStatement> finallyStatement;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfBlockStatement : public WfStatement, vl::reflection::Description<WfBlockStatement>
	{
	public:
		vl::collections::List<vl::Ptr<WfStatement>> statements;
		vl::glr::ParsingToken endLabel;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfGotoStatement : public WfStatement, vl::reflection::Description<WfGotoStatement>
	{
	public:
		vl::glr::ParsingToken label;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfVariableStatement : public WfStatement, vl::reflection::Description<WfVariableStatement>
	{
	public:
		vl::Ptr<WfVariableDeclaration> variable;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfExpressionStatement : public WfStatement, vl::reflection::Description<WfExpressionStatement>
	{
	public:
		vl::Ptr<WfExpression> expression;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfVirtualCseStatement abstract : public WfStatement, vl::reflection::Description<WfVirtualCseStatement>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfForEachStatement* node) = 0;
			virtual void Visit(WfSwitchStatement* node) = 0;
			virtual void Visit(WfCoProviderStatement* node) = 0;
		};

		virtual void Accept(WfVirtualCseStatement::IVisitor* visitor) = 0;

		vl::Ptr<WfStatement> expandedStatement;

		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfForEachStatement : public WfVirtualCseStatement, vl::reflection::Description<WfForEachStatement>
	{
	public:
		vl::glr::ParsingToken name;
		WfForEachDirection direction = WfForEachDirection::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> collection;
		vl::Ptr<WfStatement> statement;

		void Accept(WfVirtualCseStatement::IVisitor* visitor) override;
	};

	class WfSwitchCase : public vl::glr::ParsingAstBase, vl::reflection::Description<WfSwitchCase>
	{
	public:
		vl::Ptr<WfExpression> expression;
		vl::Ptr<WfStatement> statement;
	};

	class WfSwitchStatement : public WfVirtualCseStatement, vl::reflection::Description<WfSwitchStatement>
	{
	public:
		vl::Ptr<WfExpression> expression;
		vl::collections::List<vl::Ptr<WfSwitchCase>> caseBranches;
		vl::Ptr<WfStatement> defaultBranch;

		void Accept(WfVirtualCseStatement::IVisitor* visitor) override;
	};

	class WfCoProviderStatement : public WfVirtualCseStatement, vl::reflection::Description<WfCoProviderStatement>
	{
	public:
		vl::glr::ParsingToken name;
		vl::Ptr<WfStatement> statement;

		void Accept(WfVirtualCseStatement::IVisitor* visitor) override;
	};

	class WfCoroutineStatement abstract : public WfStatement, vl::reflection::Description<WfCoroutineStatement>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfCoPauseStatement* node) = 0;
			virtual void Visit(WfCoOperatorStatement* node) = 0;
		};

		virtual void Accept(WfCoroutineStatement::IVisitor* visitor) = 0;


		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfCoPauseStatement : public WfCoroutineStatement, vl::reflection::Description<WfCoPauseStatement>
	{
	public:
		vl::Ptr<WfStatement> statement;

		void Accept(WfCoroutineStatement::IVisitor* visitor) override;
	};

	class WfCoOperatorStatement : public WfCoroutineStatement, vl::reflection::Description<WfCoOperatorStatement>
	{
	public:
		vl::glr::ParsingToken varName;
		vl::glr::ParsingToken opName;
		vl::collections::List<vl::Ptr<WfExpression>> arguments;

		void Accept(WfCoroutineStatement::IVisitor* visitor) override;
	};

	class WfStateMachineStatement abstract : public WfStatement, vl::reflection::Description<WfStateMachineStatement>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfStateSwitchStatement* node) = 0;
			virtual void Visit(WfStateInvokeStatement* node) = 0;
		};

		virtual void Accept(WfStateMachineStatement::IVisitor* visitor) = 0;


		void Accept(WfStatement::IVisitor* visitor) override;
	};

	class WfStateSwitchArgument : public vl::glr::ParsingAstBase, vl::reflection::Description<WfStateSwitchArgument>
	{
	public:
		vl::glr::ParsingToken name;
	};

	class WfStateSwitchCase : public vl::glr::ParsingAstBase, vl::reflection::Description<WfStateSwitchCase>
	{
	public:
		vl::glr::ParsingToken name;
		vl::collections::List<vl::Ptr<WfStateSwitchArgument>> arguments;
		vl::Ptr<WfStatement> statement;
	};

	class WfStateSwitchStatement : public WfStateMachineStatement, vl::reflection::Description<WfStateSwitchStatement>
	{
	public:
		WfStateSwitchType type = WfStateSwitchType::UNDEFINED_ENUM_ITEM_VALUE;
		vl::collections::List<vl::Ptr<WfStateSwitchCase>> caseBranches;

		void Accept(WfStateMachineStatement::IVisitor* visitor) override;
	};

	class WfStateInvokeStatement : public WfStateMachineStatement, vl::reflection::Description<WfStateInvokeStatement>
	{
	public:
		WfStateInvokeType type = WfStateInvokeType::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken name;
		vl::collections::List<vl::Ptr<WfExpression>> arguments;

		void Accept(WfStateMachineStatement::IVisitor* visitor) override;
	};

	class WfThisExpression : public WfExpression, vl::reflection::Description<WfThisExpression>
	{
	public:

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfTopQualifiedExpression : public WfExpression, vl::reflection::Description<WfTopQualifiedExpression>
	{
	public:
		vl::glr::ParsingToken name;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfReferenceExpression : public WfExpression, vl::reflection::Description<WfReferenceExpression>
	{
	public:
		vl::glr::ParsingToken name;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfOrderedNameExpression : public WfExpression, vl::reflection::Description<WfOrderedNameExpression>
	{
	public:
		vl::glr::ParsingToken name;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfOrderedLambdaExpression : public WfExpression, vl::reflection::Description<WfOrderedLambdaExpression>
	{
	public:
		vl::Ptr<WfExpression> body;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfMemberExpression : public WfExpression, vl::reflection::Description<WfMemberExpression>
	{
	public:
		vl::Ptr<WfExpression> parent;
		vl::glr::ParsingToken name;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfChildExpression : public WfExpression, vl::reflection::Description<WfChildExpression>
	{
	public:
		vl::Ptr<WfExpression> parent;
		vl::glr::ParsingToken name;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfLiteralExpression : public WfExpression, vl::reflection::Description<WfLiteralExpression>
	{
	public:
		WfLiteralValue value = WfLiteralValue::UNDEFINED_ENUM_ITEM_VALUE;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfFloatingExpression : public WfExpression, vl::reflection::Description<WfFloatingExpression>
	{
	public:
		vl::glr::ParsingToken value;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfIntegerExpression : public WfExpression, vl::reflection::Description<WfIntegerExpression>
	{
	public:
		vl::glr::ParsingToken value;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfStringExpression : public WfExpression, vl::reflection::Description<WfStringExpression>
	{
	public:
		vl::glr::ParsingToken value;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfUnaryExpression : public WfExpression, vl::reflection::Description<WfUnaryExpression>
	{
	public:
		WfUnaryOperator op = WfUnaryOperator::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> operand;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfBinaryExpression : public WfExpression, vl::reflection::Description<WfBinaryExpression>
	{
	public:
		WfBinaryOperator op = WfBinaryOperator::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> first;
		vl::Ptr<WfExpression> second;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfLetVariable : public vl::glr::ParsingAstBase, vl::reflection::Description<WfLetVariable>
	{
	public:
		vl::glr::ParsingToken name;
		vl::Ptr<WfExpression> value;
	};

	class WfLetExpression : public WfExpression, vl::reflection::Description<WfLetExpression>
	{
	public:
		vl::collections::List<vl::Ptr<WfLetVariable>> variables;
		vl::Ptr<WfExpression> expression;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfIfExpression : public WfExpression, vl::reflection::Description<WfIfExpression>
	{
	public:
		vl::Ptr<WfExpression> condition;
		vl::Ptr<WfExpression> trueBranch;
		vl::Ptr<WfExpression> falseBranch;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfRangeExpression : public WfExpression, vl::reflection::Description<WfRangeExpression>
	{
	public:
		vl::Ptr<WfExpression> begin;
		WfRangeBoundary beginBoundary = WfRangeBoundary::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> end;
		WfRangeBoundary endBoundary = WfRangeBoundary::UNDEFINED_ENUM_ITEM_VALUE;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfSetTestingExpression : public WfExpression, vl::reflection::Description<WfSetTestingExpression>
	{
	public:
		WfSetTesting test = WfSetTesting::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> element;
		vl::Ptr<WfExpression> collection;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfConstructorArgument : public vl::glr::ParsingAstBase, vl::reflection::Description<WfConstructorArgument>
	{
	public:
		vl::Ptr<WfExpression> key;
		vl::Ptr<WfExpression> value;
	};

	class WfConstructorExpression : public WfExpression, vl::reflection::Description<WfConstructorExpression>
	{
	public:
		vl::collections::List<vl::Ptr<WfConstructorArgument>> arguments;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfInferExpression : public WfExpression, vl::reflection::Description<WfInferExpression>
	{
	public:
		vl::Ptr<WfExpression> expression;
		vl::Ptr<WfType> type;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfTypeCastingExpression : public WfExpression, vl::reflection::Description<WfTypeCastingExpression>
	{
	public:
		WfTypeCastingStrategy strategy = WfTypeCastingStrategy::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> expression;
		vl::Ptr<WfType> type;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfTypeTestingExpression : public WfExpression, vl::reflection::Description<WfTypeTestingExpression>
	{
	public:
		WfTypeTesting test = WfTypeTesting::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> expression;
		vl::Ptr<WfType> type;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfTypeOfTypeExpression : public WfExpression, vl::reflection::Description<WfTypeOfTypeExpression>
	{
	public:
		vl::Ptr<WfType> type;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfTypeOfExpressionExpression : public WfExpression, vl::reflection::Description<WfTypeOfExpressionExpression>
	{
	public:
		vl::Ptr<WfExpression> expression;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfAttachEventExpression : public WfExpression, vl::reflection::Description<WfAttachEventExpression>
	{
	public:
		vl::Ptr<WfExpression> event;
		vl::Ptr<WfExpression> function;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfDetachEventExpression : public WfExpression, vl::reflection::Description<WfDetachEventExpression>
	{
	public:
		vl::Ptr<WfExpression> event;
		vl::Ptr<WfExpression> handler;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfObserveExpression : public WfExpression, vl::reflection::Description<WfObserveExpression>
	{
	public:
		vl::Ptr<WfExpression> parent;
		WfObserveType observeType = WfObserveType::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken name;
		vl::Ptr<WfExpression> expression;
		vl::collections::List<vl::Ptr<WfExpression>> events;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfCallExpression : public WfExpression, vl::reflection::Description<WfCallExpression>
	{
	public:
		vl::Ptr<WfExpression> function;
		vl::collections::List<vl::Ptr<WfExpression>> arguments;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfFunctionExpression : public WfExpression, vl::reflection::Description<WfFunctionExpression>
	{
	public:
		vl::Ptr<WfFunctionDeclaration> function;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfNewClassExpression : public WfExpression, vl::reflection::Description<WfNewClassExpression>
	{
	public:
		vl::Ptr<WfType> type;
		vl::collections::List<vl::Ptr<WfExpression>> arguments;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfNewInterfaceExpression : public WfExpression, vl::reflection::Description<WfNewInterfaceExpression>
	{
	public:
		vl::Ptr<WfType> type;
		vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfVirtualCfeExpression abstract : public WfExpression, vl::reflection::Description<WfVirtualCfeExpression>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfFormatExpression* node) = 0;
		};

		virtual void Accept(WfVirtualCfeExpression::IVisitor* visitor) = 0;

		vl::Ptr<WfExpression> expandedExpression;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfFormatExpression : public WfVirtualCfeExpression, vl::reflection::Description<WfFormatExpression>
	{
	public:
		vl::glr::ParsingToken value;

		void Accept(WfVirtualCfeExpression::IVisitor* visitor) override;
	};

	class WfVirtualCseExpression abstract : public WfExpression, vl::reflection::Description<WfVirtualCseExpression>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfBindExpression* node) = 0;
			virtual void Visit(WfNewCoroutineExpression* node) = 0;
			virtual void Visit(WfMixinCastExpression* node) = 0;
			virtual void Visit(WfExpectedTypeCastExpression* node) = 0;
			virtual void Visit(WfCoOperatorExpression* node) = 0;
		};

		virtual void Accept(WfVirtualCseExpression::IVisitor* visitor) = 0;

		vl::Ptr<WfExpression> expandedExpression;

		void Accept(WfExpression::IVisitor* visitor) override;
	};

	class WfBindExpression : public WfVirtualCseExpression, vl::reflection::Description<WfBindExpression>
	{
	public:
		vl::Ptr<WfExpression> expression;

		void Accept(WfVirtualCseExpression::IVisitor* visitor) override;
	};

	class WfNewCoroutineExpression : public WfVirtualCseExpression, vl::reflection::Description<WfNewCoroutineExpression>
	{
	public:
		vl::glr::ParsingToken name;
		vl::Ptr<WfStatement> statement;

		void Accept(WfVirtualCseExpression::IVisitor* visitor) override;
	};

	class WfMixinCastExpression : public WfVirtualCseExpression, vl::reflection::Description<WfMixinCastExpression>
	{
	public:
		vl::Ptr<WfType> type;
		vl::Ptr<WfExpression> expression;

		void Accept(WfVirtualCseExpression::IVisitor* visitor) override;
	};

	class WfExpectedTypeCastExpression : public WfVirtualCseExpression, vl::reflection::Description<WfExpectedTypeCastExpression>
	{
	public:
		WfTypeCastingStrategy strategy = WfTypeCastingStrategy::UNDEFINED_ENUM_ITEM_VALUE;
		vl::Ptr<WfExpression> expression;

		void Accept(WfVirtualCseExpression::IVisitor* visitor) override;
	};

	class WfCoOperatorExpression : public WfVirtualCseExpression, vl::reflection::Description<WfCoOperatorExpression>
	{
	public:
		vl::glr::ParsingToken name;

		void Accept(WfVirtualCseExpression::IVisitor* visitor) override;
	};

	class WfModuleUsingFragment abstract : public vl::glr::ParsingAstBase, vl::reflection::Description<WfModuleUsingFragment>
	{
	public:
		class IVisitor : public virtual vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
		{
		public:
			virtual void Visit(WfModuleUsingNameFragment* node) = 0;
			virtual void Visit(WfModuleUsingWildCardFragment* node) = 0;
		};

		virtual void Accept(WfModuleUsingFragment::IVisitor* visitor) = 0;

	};

	class WfModuleUsingNameFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingNameFragment>
	{
	public:
		vl::glr::ParsingToken name;

		void Accept(WfModuleUsingFragment::IVisitor* visitor) override;
	};

	class WfModuleUsingWildCardFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingWildCardFragment>
	{
	public:

		void Accept(WfModuleUsingFragment::IVisitor* visitor) override;
	};

	class WfModuleUsingItem : public vl::glr::ParsingAstBase, vl::reflection::Description<WfModuleUsingItem>
	{
	public:
		vl::collections::List<vl::Ptr<WfModuleUsingFragment>> fragments;
	};

	class WfModuleUsingPath : public vl::glr::ParsingAstBase, vl::reflection::Description<WfModuleUsingPath>
	{
	public:
		vl::collections::List<vl::Ptr<WfModuleUsingItem>> items;
	};

	class WfModule : public vl::glr::ParsingAstBase, vl::reflection::Description<WfModule>
	{
	public:
		WfModuleType moduleType = WfModuleType::UNDEFINED_ENUM_ITEM_VALUE;
		vl::glr::ParsingToken name;
		vl::collections::List<vl::Ptr<WfModuleUsingPath>> paths;
		vl::collections::List<vl::Ptr<WfDeclaration>> declarations;
	};
}
namespace vl::reflection::description
{
#ifndef VCZH_DEBUG_NO_REFLECTION
	DECL_TYPE_INFO(vl::workflow::WfType)
	DECL_TYPE_INFO(vl::workflow::WfType::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfExpression)
	DECL_TYPE_INFO(vl::workflow::WfExpression::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfStatement)
	DECL_TYPE_INFO(vl::workflow::WfStatement::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfAttribute)
	DECL_TYPE_INFO(vl::workflow::WfDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfDeclaration::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfFunctionKind)
	DECL_TYPE_INFO(vl::workflow::WfPredefinedTypeName)
	DECL_TYPE_INFO(vl::workflow::WfPredefinedType)
	DECL_TYPE_INFO(vl::workflow::WfTopQualifiedType)
	DECL_TYPE_INFO(vl::workflow::WfReferenceType)
	DECL_TYPE_INFO(vl::workflow::WfRawPointerType)
	DECL_TYPE_INFO(vl::workflow::WfSharedPointerType)
	DECL_TYPE_INFO(vl::workflow::WfNullableType)
	DECL_TYPE_INFO(vl::workflow::WfEnumerableType)
	DECL_TYPE_INFO(vl::workflow::WfMapWritability)
	DECL_TYPE_INFO(vl::workflow::WfMapType)
	DECL_TYPE_INFO(vl::workflow::WfObservableListType)
	DECL_TYPE_INFO(vl::workflow::WfFunctionType)
	DECL_TYPE_INFO(vl::workflow::WfChildType)
	DECL_TYPE_INFO(vl::workflow::WfNamespaceDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfFunctionArgument)
	DECL_TYPE_INFO(vl::workflow::WfFunctionAnonymity)
	DECL_TYPE_INFO(vl::workflow::WfFunctionDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfVariableDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfEventDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfPropertyDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfStaticInitDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfClassKind)
	DECL_TYPE_INFO(vl::workflow::WfConstructorType)
	DECL_TYPE_INFO(vl::workflow::WfBaseConstructorCall)
	DECL_TYPE_INFO(vl::workflow::WfConstructorDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfDestructorDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfClassDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfEnumKind)
	DECL_TYPE_INFO(vl::workflow::WfEnumItemKind)
	DECL_TYPE_INFO(vl::workflow::WfEnumItemIntersection)
	DECL_TYPE_INFO(vl::workflow::WfEnumItem)
	DECL_TYPE_INFO(vl::workflow::WfEnumDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfStructMember)
	DECL_TYPE_INFO(vl::workflow::WfStructDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfAPConst)
	DECL_TYPE_INFO(vl::workflow::WfAPObserve)
	DECL_TYPE_INFO(vl::workflow::WfAutoPropertyDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfCastResultInterfaceDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfStateInput)
	DECL_TYPE_INFO(vl::workflow::WfStateDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfStateMachineDeclaration)
	DECL_TYPE_INFO(vl::workflow::WfBreakStatement)
	DECL_TYPE_INFO(vl::workflow::WfContinueStatement)
	DECL_TYPE_INFO(vl::workflow::WfReturnStatement)
	DECL_TYPE_INFO(vl::workflow::WfDeleteStatement)
	DECL_TYPE_INFO(vl::workflow::WfRaiseExceptionStatement)
	DECL_TYPE_INFO(vl::workflow::WfIfStatement)
	DECL_TYPE_INFO(vl::workflow::WfWhileStatement)
	DECL_TYPE_INFO(vl::workflow::WfTryStatement)
	DECL_TYPE_INFO(vl::workflow::WfBlockStatement)
	DECL_TYPE_INFO(vl::workflow::WfGotoStatement)
	DECL_TYPE_INFO(vl::workflow::WfVariableStatement)
	DECL_TYPE_INFO(vl::workflow::WfExpressionStatement)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCseStatement)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCseStatement::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfForEachDirection)
	DECL_TYPE_INFO(vl::workflow::WfForEachStatement)
	DECL_TYPE_INFO(vl::workflow::WfSwitchCase)
	DECL_TYPE_INFO(vl::workflow::WfSwitchStatement)
	DECL_TYPE_INFO(vl::workflow::WfCoProviderStatement)
	DECL_TYPE_INFO(vl::workflow::WfCoroutineStatement)
	DECL_TYPE_INFO(vl::workflow::WfCoroutineStatement::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfCoPauseStatement)
	DECL_TYPE_INFO(vl::workflow::WfCoOperatorStatement)
	DECL_TYPE_INFO(vl::workflow::WfStateSwitchType)
	DECL_TYPE_INFO(vl::workflow::WfStateInvokeType)
	DECL_TYPE_INFO(vl::workflow::WfStateMachineStatement)
	DECL_TYPE_INFO(vl::workflow::WfStateMachineStatement::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfStateSwitchArgument)
	DECL_TYPE_INFO(vl::workflow::WfStateSwitchCase)
	DECL_TYPE_INFO(vl::workflow::WfStateSwitchStatement)
	DECL_TYPE_INFO(vl::workflow::WfStateInvokeStatement)
	DECL_TYPE_INFO(vl::workflow::WfThisExpression)
	DECL_TYPE_INFO(vl::workflow::WfTopQualifiedExpression)
	DECL_TYPE_INFO(vl::workflow::WfReferenceExpression)
	DECL_TYPE_INFO(vl::workflow::WfOrderedNameExpression)
	DECL_TYPE_INFO(vl::workflow::WfOrderedLambdaExpression)
	DECL_TYPE_INFO(vl::workflow::WfMemberExpression)
	DECL_TYPE_INFO(vl::workflow::WfChildExpression)
	DECL_TYPE_INFO(vl::workflow::WfLiteralValue)
	DECL_TYPE_INFO(vl::workflow::WfLiteralExpression)
	DECL_TYPE_INFO(vl::workflow::WfFloatingExpression)
	DECL_TYPE_INFO(vl::workflow::WfIntegerExpression)
	DECL_TYPE_INFO(vl::workflow::WfStringExpression)
	DECL_TYPE_INFO(vl::workflow::WfUnaryOperator)
	DECL_TYPE_INFO(vl::workflow::WfUnaryExpression)
	DECL_TYPE_INFO(vl::workflow::WfBinaryOperator)
	DECL_TYPE_INFO(vl::workflow::WfBinaryExpression)
	DECL_TYPE_INFO(vl::workflow::WfLetVariable)
	DECL_TYPE_INFO(vl::workflow::WfLetExpression)
	DECL_TYPE_INFO(vl::workflow::WfIfExpression)
	DECL_TYPE_INFO(vl::workflow::WfRangeBoundary)
	DECL_TYPE_INFO(vl::workflow::WfRangeExpression)
	DECL_TYPE_INFO(vl::workflow::WfSetTesting)
	DECL_TYPE_INFO(vl::workflow::WfSetTestingExpression)
	DECL_TYPE_INFO(vl::workflow::WfConstructorArgument)
	DECL_TYPE_INFO(vl::workflow::WfConstructorExpression)
	DECL_TYPE_INFO(vl::workflow::WfInferExpression)
	DECL_TYPE_INFO(vl::workflow::WfTypeCastingStrategy)
	DECL_TYPE_INFO(vl::workflow::WfTypeCastingExpression)
	DECL_TYPE_INFO(vl::workflow::WfTypeTesting)
	DECL_TYPE_INFO(vl::workflow::WfTypeTestingExpression)
	DECL_TYPE_INFO(vl::workflow::WfTypeOfTypeExpression)
	DECL_TYPE_INFO(vl::workflow::WfTypeOfExpressionExpression)
	DECL_TYPE_INFO(vl::workflow::WfAttachEventExpression)
	DECL_TYPE_INFO(vl::workflow::WfDetachEventExpression)
	DECL_TYPE_INFO(vl::workflow::WfObserveType)
	DECL_TYPE_INFO(vl::workflow::WfObserveExpression)
	DECL_TYPE_INFO(vl::workflow::WfCallExpression)
	DECL_TYPE_INFO(vl::workflow::WfFunctionExpression)
	DECL_TYPE_INFO(vl::workflow::WfNewClassExpression)
	DECL_TYPE_INFO(vl::workflow::WfNewInterfaceExpression)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCfeExpression)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCfeExpression::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfFormatExpression)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCseExpression)
	DECL_TYPE_INFO(vl::workflow::WfVirtualCseExpression::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfBindExpression)
	DECL_TYPE_INFO(vl::workflow::WfNewCoroutineExpression)
	DECL_TYPE_INFO(vl::workflow::WfMixinCastExpression)
	DECL_TYPE_INFO(vl::workflow::WfExpectedTypeCastExpression)
	DECL_TYPE_INFO(vl::workflow::WfCoOperatorExpression)
	DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment)
	DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment::IVisitor)
	DECL_TYPE_INFO(vl::workflow::WfModuleUsingNameFragment)
	DECL_TYPE_INFO(vl::workflow::WfModuleUsingWildCardFragment)
	DECL_TYPE_INFO(vl::workflow::WfModuleUsingItem)
	DECL_TYPE_INFO(vl::workflow::WfModuleUsingPath)
	DECL_TYPE_INFO(vl::workflow::WfModuleType)
	DECL_TYPE_INFO(vl::workflow::WfModule)

#ifdef VCZH_DESCRIPTABLEOBJECT_WITH_METADATA

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfType::IVisitor)
		void Visit(vl::workflow::WfPredefinedType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfTopQualifiedType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfReferenceType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfRawPointerType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfSharedPointerType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfNullableType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfEnumerableType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfMapType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfObservableListType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfFunctionType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfChildType* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfType::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfExpression::IVisitor)
		void Visit(vl::workflow::WfThisExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfTopQualifiedExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfReferenceExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfOrderedNameExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfOrderedLambdaExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfMemberExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfChildExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfLiteralExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfFloatingExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfIntegerExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfStringExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfUnaryExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfBinaryExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfLetExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfIfExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfRangeExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfSetTestingExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfConstructorExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfInferExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfTypeCastingExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfTypeTestingExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfTypeOfTypeExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfTypeOfExpressionExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfAttachEventExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfDetachEventExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfObserveExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfCallExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfFunctionExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfNewClassExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfNewInterfaceExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfVirtualCfeExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfVirtualCseExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfExpression::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfStatement::IVisitor)
		void Visit(vl::workflow::WfBreakStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfContinueStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfReturnStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfDeleteStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfRaiseExceptionStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfIfStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfWhileStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfTryStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfBlockStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfGotoStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfVariableStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfExpressionStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfVirtualCseStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfCoroutineStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfStateMachineStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfStatement::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfDeclaration::IVisitor)
		void Visit(vl::workflow::WfNamespaceDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfFunctionDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfVariableDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfEventDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfPropertyDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfStaticInitDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfConstructorDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfDestructorDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfClassDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfEnumDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfStructDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfVirtualCfeDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfVirtualCseDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfDeclaration::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
		void Visit(vl::workflow::WfAutoPropertyDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfCastResultInterfaceDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfVirtualCfeDeclaration::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseDeclaration::IVisitor)
		void Visit(vl::workflow::WfStateMachineDeclaration* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfVirtualCseDeclaration::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseStatement::IVisitor)
		void Visit(vl::workflow::WfForEachStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfSwitchStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfCoProviderStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfVirtualCseStatement::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfCoroutineStatement::IVisitor)
		void Visit(vl::workflow::WfCoPauseStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfCoOperatorStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfCoroutineStatement::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfStateMachineStatement::IVisitor)
		void Visit(vl::workflow::WfStateSwitchStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfStateInvokeStatement* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfStateMachineStatement::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCfeExpression::IVisitor)
		void Visit(vl::workflow::WfFormatExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfVirtualCfeExpression::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseExpression::IVisitor)
		void Visit(vl::workflow::WfBindExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfNewCoroutineExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfMixinCastExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfExpectedTypeCastExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfCoOperatorExpression* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfVirtualCseExpression::IVisitor)

	BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfModuleUsingFragment::IVisitor)
		void Visit(vl::workflow::WfModuleUsingNameFragment* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

		void Visit(vl::workflow::WfModuleUsingWildCardFragment* node) override
		{
			INVOKE_INTERFACE_PROXY(Visit, node);
		}

	END_INTERFACE_PROXY(vl::workflow::WfModuleUsingFragment::IVisitor)

#endif
#endif
	/// <summary>Load all reflectable AST types, only available when <b>VCZH_DEBUG_NO_REFLECTION</b> is off.</summary>
	/// <returns>Returns true if this operation succeeded.</returns>
	extern bool WorkflowAstLoadTypes();
}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_BUILDER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_AST_AST_BUILDER
#define VCZH_WORKFLOW_PARSER_AST_AST_BUILDER


namespace vl::workflow::builder
{
	class MakeAttachEventExpression : public vl::glr::ParsingAstBuilder<WfAttachEventExpression>
	{
	public:
		MakeAttachEventExpression& event(const vl::Ptr<WfExpression>& value);
		MakeAttachEventExpression& function(const vl::Ptr<WfExpression>& value);
	};

	class MakeAttribute : public vl::glr::ParsingAstBuilder<WfAttribute>
	{
	public:
		MakeAttribute& category(const vl::WString& value);
		MakeAttribute& name(const vl::WString& value);
		MakeAttribute& value(const vl::Ptr<WfExpression>& value);
	};

	class MakeAutoPropertyDeclaration : public vl::glr::ParsingAstBuilder<WfAutoPropertyDeclaration>
	{
	public:
		MakeAutoPropertyDeclaration& configConst(WfAPConst value);
		MakeAutoPropertyDeclaration& configObserve(WfAPObserve value);
		MakeAutoPropertyDeclaration& expression(const vl::Ptr<WfExpression>& value);
		MakeAutoPropertyDeclaration& functionKind(WfFunctionKind value);
		MakeAutoPropertyDeclaration& type(const vl::Ptr<WfType>& value);
		MakeAutoPropertyDeclaration& expandedDeclarations(const vl::Ptr<WfDeclaration>& value);
		MakeAutoPropertyDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeAutoPropertyDeclaration& name(const vl::WString& value);
	};

	class MakeBaseConstructorCall : public vl::glr::ParsingAstBuilder<WfBaseConstructorCall>
	{
	public:
		MakeBaseConstructorCall& arguments(const vl::Ptr<WfExpression>& value);
		MakeBaseConstructorCall& type(const vl::Ptr<WfType>& value);
	};

	class MakeBinaryExpression : public vl::glr::ParsingAstBuilder<WfBinaryExpression>
	{
	public:
		MakeBinaryExpression& first(const vl::Ptr<WfExpression>& value);
		MakeBinaryExpression& op(WfBinaryOperator value);
		MakeBinaryExpression& second(const vl::Ptr<WfExpression>& value);
	};

	class MakeBindExpression : public vl::glr::ParsingAstBuilder<WfBindExpression>
	{
	public:
		MakeBindExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeBindExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeBlockStatement : public vl::glr::ParsingAstBuilder<WfBlockStatement>
	{
	public:
		MakeBlockStatement& endLabel(const vl::WString& value);
		MakeBlockStatement& statements(const vl::Ptr<WfStatement>& value);
	};

	class MakeCallExpression : public vl::glr::ParsingAstBuilder<WfCallExpression>
	{
	public:
		MakeCallExpression& arguments(const vl::Ptr<WfExpression>& value);
		MakeCallExpression& function(const vl::Ptr<WfExpression>& value);
	};

	class MakeCastResultInterfaceDeclaration : public vl::glr::ParsingAstBuilder<WfCastResultInterfaceDeclaration>
	{
	public:
		MakeCastResultInterfaceDeclaration& baseType(const vl::Ptr<WfType>& value);
		MakeCastResultInterfaceDeclaration& elementType(const vl::Ptr<WfType>& value);
		MakeCastResultInterfaceDeclaration& expandedDeclarations(const vl::Ptr<WfDeclaration>& value);
		MakeCastResultInterfaceDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeCastResultInterfaceDeclaration& name(const vl::WString& value);
	};

	class MakeChildExpression : public vl::glr::ParsingAstBuilder<WfChildExpression>
	{
	public:
		MakeChildExpression& name(const vl::WString& value);
		MakeChildExpression& parent(const vl::Ptr<WfExpression>& value);
	};

	class MakeChildType : public vl::glr::ParsingAstBuilder<WfChildType>
	{
	public:
		MakeChildType& name(const vl::WString& value);
		MakeChildType& parent(const vl::Ptr<WfType>& value);
	};

	class MakeClassDeclaration : public vl::glr::ParsingAstBuilder<WfClassDeclaration>
	{
	public:
		MakeClassDeclaration& baseTypes(const vl::Ptr<WfType>& value);
		MakeClassDeclaration& constructorType(WfConstructorType value);
		MakeClassDeclaration& declarations(const vl::Ptr<WfDeclaration>& value);
		MakeClassDeclaration& kind(WfClassKind value);
		MakeClassDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeClassDeclaration& name(const vl::WString& value);
	};

	class MakeCoOperatorExpression : public vl::glr::ParsingAstBuilder<WfCoOperatorExpression>
	{
	public:
		MakeCoOperatorExpression& name(const vl::WString& value);
		MakeCoOperatorExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeCoOperatorStatement : public vl::glr::ParsingAstBuilder<WfCoOperatorStatement>
	{
	public:
		MakeCoOperatorStatement& arguments(const vl::Ptr<WfExpression>& value);
		MakeCoOperatorStatement& opName(const vl::WString& value);
		MakeCoOperatorStatement& varName(const vl::WString& value);
	};

	class MakeCoPauseStatement : public vl::glr::ParsingAstBuilder<WfCoPauseStatement>
	{
	public:
		MakeCoPauseStatement& statement(const vl::Ptr<WfStatement>& value);
	};

	class MakeCoProviderStatement : public vl::glr::ParsingAstBuilder<WfCoProviderStatement>
	{
	public:
		MakeCoProviderStatement& name(const vl::WString& value);
		MakeCoProviderStatement& statement(const vl::Ptr<WfStatement>& value);
		MakeCoProviderStatement& expandedStatement(const vl::Ptr<WfStatement>& value);
	};

	class MakeConstructorArgument : public vl::glr::ParsingAstBuilder<WfConstructorArgument>
	{
	public:
		MakeConstructorArgument& key(const vl::Ptr<WfExpression>& value);
		MakeConstructorArgument& value(const vl::Ptr<WfExpression>& value);
	};

	class MakeConstructorDeclaration : public vl::glr::ParsingAstBuilder<WfConstructorDeclaration>
	{
	public:
		MakeConstructorDeclaration& arguments(const vl::Ptr<WfFunctionArgument>& value);
		MakeConstructorDeclaration& baseConstructorCalls(const vl::Ptr<WfBaseConstructorCall>& value);
		MakeConstructorDeclaration& constructorType(WfConstructorType value);
		MakeConstructorDeclaration& statement(const vl::Ptr<WfStatement>& value);
		MakeConstructorDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeConstructorDeclaration& name(const vl::WString& value);
	};

	class MakeConstructorExpression : public vl::glr::ParsingAstBuilder<WfConstructorExpression>
	{
	public:
		MakeConstructorExpression& arguments(const vl::Ptr<WfConstructorArgument>& value);
	};

	class MakeDeclaration : public vl::glr::ParsingAstBuilder<WfDeclaration>
	{
	public:
		MakeDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeDeclaration& name(const vl::WString& value);
	};

	class MakeDeleteStatement : public vl::glr::ParsingAstBuilder<WfDeleteStatement>
	{
	public:
		MakeDeleteStatement& expression(const vl::Ptr<WfExpression>& value);
	};

	class MakeDestructorDeclaration : public vl::glr::ParsingAstBuilder<WfDestructorDeclaration>
	{
	public:
		MakeDestructorDeclaration& statement(const vl::Ptr<WfStatement>& value);
		MakeDestructorDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeDestructorDeclaration& name(const vl::WString& value);
	};

	class MakeDetachEventExpression : public vl::glr::ParsingAstBuilder<WfDetachEventExpression>
	{
	public:
		MakeDetachEventExpression& event(const vl::Ptr<WfExpression>& value);
		MakeDetachEventExpression& handler(const vl::Ptr<WfExpression>& value);
	};

	class MakeEnumDeclaration : public vl::glr::ParsingAstBuilder<WfEnumDeclaration>
	{
	public:
		MakeEnumDeclaration& items(const vl::Ptr<WfEnumItem>& value);
		MakeEnumDeclaration& kind(WfEnumKind value);
		MakeEnumDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeEnumDeclaration& name(const vl::WString& value);
	};

	class MakeEnumItem : public vl::glr::ParsingAstBuilder<WfEnumItem>
	{
	public:
		MakeEnumItem& attributes(const vl::Ptr<WfAttribute>& value);
		MakeEnumItem& intersections(const vl::Ptr<WfEnumItemIntersection>& value);
		MakeEnumItem& kind(WfEnumItemKind value);
		MakeEnumItem& name(const vl::WString& value);
		MakeEnumItem& number(const vl::WString& value);
	};

	class MakeEnumItemIntersection : public vl::glr::ParsingAstBuilder<WfEnumItemIntersection>
	{
	public:
		MakeEnumItemIntersection& name(const vl::WString& value);
	};

	class MakeEnumerableType : public vl::glr::ParsingAstBuilder<WfEnumerableType>
	{
	public:
		MakeEnumerableType& element(const vl::Ptr<WfType>& value);
	};

	class MakeEventDeclaration : public vl::glr::ParsingAstBuilder<WfEventDeclaration>
	{
	public:
		MakeEventDeclaration& arguments(const vl::Ptr<WfType>& value);
		MakeEventDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeEventDeclaration& name(const vl::WString& value);
	};

	class MakeExpectedTypeCastExpression : public vl::glr::ParsingAstBuilder<WfExpectedTypeCastExpression>
	{
	public:
		MakeExpectedTypeCastExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeExpectedTypeCastExpression& strategy(WfTypeCastingStrategy value);
		MakeExpectedTypeCastExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeExpressionStatement : public vl::glr::ParsingAstBuilder<WfExpressionStatement>
	{
	public:
		MakeExpressionStatement& expression(const vl::Ptr<WfExpression>& value);
	};

	class MakeFloatingExpression : public vl::glr::ParsingAstBuilder<WfFloatingExpression>
	{
	public:
		MakeFloatingExpression& value(const vl::WString& value);
	};

	class MakeForEachStatement : public vl::glr::ParsingAstBuilder<WfForEachStatement>
	{
	public:
		MakeForEachStatement& collection(const vl::Ptr<WfExpression>& value);
		MakeForEachStatement& direction(WfForEachDirection value);
		MakeForEachStatement& name(const vl::WString& value);
		MakeForEachStatement& statement(const vl::Ptr<WfStatement>& value);
		MakeForEachStatement& expandedStatement(const vl::Ptr<WfStatement>& value);
	};

	class MakeFormatExpression : public vl::glr::ParsingAstBuilder<WfFormatExpression>
	{
	public:
		MakeFormatExpression& value(const vl::WString& value);
		MakeFormatExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeFunctionArgument : public vl::glr::ParsingAstBuilder<WfFunctionArgument>
	{
	public:
		MakeFunctionArgument& attributes(const vl::Ptr<WfAttribute>& value);
		MakeFunctionArgument& name(const vl::WString& value);
		MakeFunctionArgument& type(const vl::Ptr<WfType>& value);
	};

	class MakeFunctionDeclaration : public vl::glr::ParsingAstBuilder<WfFunctionDeclaration>
	{
	public:
		MakeFunctionDeclaration& anonymity(WfFunctionAnonymity value);
		MakeFunctionDeclaration& arguments(const vl::Ptr<WfFunctionArgument>& value);
		MakeFunctionDeclaration& functionKind(WfFunctionKind value);
		MakeFunctionDeclaration& returnType(const vl::Ptr<WfType>& value);
		MakeFunctionDeclaration& statement(const vl::Ptr<WfStatement>& value);
		MakeFunctionDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeFunctionDeclaration& name(const vl::WString& value);
	};

	class MakeFunctionExpression : public vl::glr::ParsingAstBuilder<WfFunctionExpression>
	{
	public:
		MakeFunctionExpression& function(const vl::Ptr<WfFunctionDeclaration>& value);
	};

	class MakeFunctionType : public vl::glr::ParsingAstBuilder<WfFunctionType>
	{
	public:
		MakeFunctionType& arguments(const vl::Ptr<WfType>& value);
		MakeFunctionType& result(const vl::Ptr<WfType>& value);
	};

	class MakeGotoStatement : public vl::glr::ParsingAstBuilder<WfGotoStatement>
	{
	public:
		MakeGotoStatement& label(const vl::WString& value);
	};

	class MakeIfExpression : public vl::glr::ParsingAstBuilder<WfIfExpression>
	{
	public:
		MakeIfExpression& condition(const vl::Ptr<WfExpression>& value);
		MakeIfExpression& falseBranch(const vl::Ptr<WfExpression>& value);
		MakeIfExpression& trueBranch(const vl::Ptr<WfExpression>& value);
	};

	class MakeIfStatement : public vl::glr::ParsingAstBuilder<WfIfStatement>
	{
	public:
		MakeIfStatement& expression(const vl::Ptr<WfExpression>& value);
		MakeIfStatement& falseBranch(const vl::Ptr<WfStatement>& value);
		MakeIfStatement& name(const vl::WString& value);
		MakeIfStatement& trueBranch(const vl::Ptr<WfStatement>& value);
		MakeIfStatement& type(const vl::Ptr<WfType>& value);
	};

	class MakeInferExpression : public vl::glr::ParsingAstBuilder<WfInferExpression>
	{
	public:
		MakeInferExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeInferExpression& type(const vl::Ptr<WfType>& value);
	};

	class MakeIntegerExpression : public vl::glr::ParsingAstBuilder<WfIntegerExpression>
	{
	public:
		MakeIntegerExpression& value(const vl::WString& value);
	};

	class MakeLetExpression : public vl::glr::ParsingAstBuilder<WfLetExpression>
	{
	public:
		MakeLetExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeLetExpression& variables(const vl::Ptr<WfLetVariable>& value);
	};

	class MakeLetVariable : public vl::glr::ParsingAstBuilder<WfLetVariable>
	{
	public:
		MakeLetVariable& name(const vl::WString& value);
		MakeLetVariable& value(const vl::Ptr<WfExpression>& value);
	};

	class MakeLiteralExpression : public vl::glr::ParsingAstBuilder<WfLiteralExpression>
	{
	public:
		MakeLiteralExpression& value(WfLiteralValue value);
	};

	class MakeMapType : public vl::glr::ParsingAstBuilder<WfMapType>
	{
	public:
		MakeMapType& key(const vl::Ptr<WfType>& value);
		MakeMapType& value(const vl::Ptr<WfType>& value);
		MakeMapType& writability(WfMapWritability value);
	};

	class MakeMemberExpression : public vl::glr::ParsingAstBuilder<WfMemberExpression>
	{
	public:
		MakeMemberExpression& name(const vl::WString& value);
		MakeMemberExpression& parent(const vl::Ptr<WfExpression>& value);
	};

	class MakeMixinCastExpression : public vl::glr::ParsingAstBuilder<WfMixinCastExpression>
	{
	public:
		MakeMixinCastExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeMixinCastExpression& type(const vl::Ptr<WfType>& value);
		MakeMixinCastExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeModule : public vl::glr::ParsingAstBuilder<WfModule>
	{
	public:
		MakeModule& declarations(const vl::Ptr<WfDeclaration>& value);
		MakeModule& moduleType(WfModuleType value);
		MakeModule& name(const vl::WString& value);
		MakeModule& paths(const vl::Ptr<WfModuleUsingPath>& value);
	};

	class MakeModuleUsingItem : public vl::glr::ParsingAstBuilder<WfModuleUsingItem>
	{
	public:
		MakeModuleUsingItem& fragments(const vl::Ptr<WfModuleUsingFragment>& value);
	};

	class MakeModuleUsingNameFragment : public vl::glr::ParsingAstBuilder<WfModuleUsingNameFragment>
	{
	public:
		MakeModuleUsingNameFragment& name(const vl::WString& value);
	};

	class MakeModuleUsingPath : public vl::glr::ParsingAstBuilder<WfModuleUsingPath>
	{
	public:
		MakeModuleUsingPath& items(const vl::Ptr<WfModuleUsingItem>& value);
	};

	class MakeNamespaceDeclaration : public vl::glr::ParsingAstBuilder<WfNamespaceDeclaration>
	{
	public:
		MakeNamespaceDeclaration& declarations(const vl::Ptr<WfDeclaration>& value);
		MakeNamespaceDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeNamespaceDeclaration& name(const vl::WString& value);
	};

	class MakeNewClassExpression : public vl::glr::ParsingAstBuilder<WfNewClassExpression>
	{
	public:
		MakeNewClassExpression& arguments(const vl::Ptr<WfExpression>& value);
		MakeNewClassExpression& type(const vl::Ptr<WfType>& value);
	};

	class MakeNewCoroutineExpression : public vl::glr::ParsingAstBuilder<WfNewCoroutineExpression>
	{
	public:
		MakeNewCoroutineExpression& name(const vl::WString& value);
		MakeNewCoroutineExpression& statement(const vl::Ptr<WfStatement>& value);
		MakeNewCoroutineExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeNewInterfaceExpression : public vl::glr::ParsingAstBuilder<WfNewInterfaceExpression>
	{
	public:
		MakeNewInterfaceExpression& declarations(const vl::Ptr<WfDeclaration>& value);
		MakeNewInterfaceExpression& type(const vl::Ptr<WfType>& value);
	};

	class MakeNullableType : public vl::glr::ParsingAstBuilder<WfNullableType>
	{
	public:
		MakeNullableType& element(const vl::Ptr<WfType>& value);
	};

	class MakeObservableListType : public vl::glr::ParsingAstBuilder<WfObservableListType>
	{
	public:
		MakeObservableListType& element(const vl::Ptr<WfType>& value);
	};

	class MakeObserveExpression : public vl::glr::ParsingAstBuilder<WfObserveExpression>
	{
	public:
		MakeObserveExpression& events(const vl::Ptr<WfExpression>& value);
		MakeObserveExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeObserveExpression& name(const vl::WString& value);
		MakeObserveExpression& observeType(WfObserveType value);
		MakeObserveExpression& parent(const vl::Ptr<WfExpression>& value);
	};

	class MakeOrderedLambdaExpression : public vl::glr::ParsingAstBuilder<WfOrderedLambdaExpression>
	{
	public:
		MakeOrderedLambdaExpression& body(const vl::Ptr<WfExpression>& value);
	};

	class MakeOrderedNameExpression : public vl::glr::ParsingAstBuilder<WfOrderedNameExpression>
	{
	public:
		MakeOrderedNameExpression& name(const vl::WString& value);
	};

	class MakePredefinedType : public vl::glr::ParsingAstBuilder<WfPredefinedType>
	{
	public:
		MakePredefinedType& name(WfPredefinedTypeName value);
	};

	class MakePropertyDeclaration : public vl::glr::ParsingAstBuilder<WfPropertyDeclaration>
	{
	public:
		MakePropertyDeclaration& getter(const vl::WString& value);
		MakePropertyDeclaration& setter(const vl::WString& value);
		MakePropertyDeclaration& type(const vl::Ptr<WfType>& value);
		MakePropertyDeclaration& valueChangedEvent(const vl::WString& value);
		MakePropertyDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakePropertyDeclaration& name(const vl::WString& value);
	};

	class MakeRaiseExceptionStatement : public vl::glr::ParsingAstBuilder<WfRaiseExceptionStatement>
	{
	public:
		MakeRaiseExceptionStatement& expression(const vl::Ptr<WfExpression>& value);
	};

	class MakeRangeExpression : public vl::glr::ParsingAstBuilder<WfRangeExpression>
	{
	public:
		MakeRangeExpression& begin(const vl::Ptr<WfExpression>& value);
		MakeRangeExpression& beginBoundary(WfRangeBoundary value);
		MakeRangeExpression& end(const vl::Ptr<WfExpression>& value);
		MakeRangeExpression& endBoundary(WfRangeBoundary value);
	};

	class MakeRawPointerType : public vl::glr::ParsingAstBuilder<WfRawPointerType>
	{
	public:
		MakeRawPointerType& element(const vl::Ptr<WfType>& value);
	};

	class MakeReferenceExpression : public vl::glr::ParsingAstBuilder<WfReferenceExpression>
	{
	public:
		MakeReferenceExpression& name(const vl::WString& value);
	};

	class MakeReferenceType : public vl::glr::ParsingAstBuilder<WfReferenceType>
	{
	public:
		MakeReferenceType& name(const vl::WString& value);
	};

	class MakeReturnStatement : public vl::glr::ParsingAstBuilder<WfReturnStatement>
	{
	public:
		MakeReturnStatement& expression(const vl::Ptr<WfExpression>& value);
	};

	class MakeSetTestingExpression : public vl::glr::ParsingAstBuilder<WfSetTestingExpression>
	{
	public:
		MakeSetTestingExpression& collection(const vl::Ptr<WfExpression>& value);
		MakeSetTestingExpression& element(const vl::Ptr<WfExpression>& value);
		MakeSetTestingExpression& test(WfSetTesting value);
	};

	class MakeSharedPointerType : public vl::glr::ParsingAstBuilder<WfSharedPointerType>
	{
	public:
		MakeSharedPointerType& element(const vl::Ptr<WfType>& value);
	};

	class MakeStateDeclaration : public vl::glr::ParsingAstBuilder<WfStateDeclaration>
	{
	public:
		MakeStateDeclaration& arguments(const vl::Ptr<WfFunctionArgument>& value);
		MakeStateDeclaration& name(const vl::WString& value);
		MakeStateDeclaration& statement(const vl::Ptr<WfStatement>& value);
	};

	class MakeStateInput : public vl::glr::ParsingAstBuilder<WfStateInput>
	{
	public:
		MakeStateInput& arguments(const vl::Ptr<WfFunctionArgument>& value);
		MakeStateInput& name(const vl::WString& value);
	};

	class MakeStateInvokeStatement : public vl::glr::ParsingAstBuilder<WfStateInvokeStatement>
	{
	public:
		MakeStateInvokeStatement& arguments(const vl::Ptr<WfExpression>& value);
		MakeStateInvokeStatement& name(const vl::WString& value);
		MakeStateInvokeStatement& type(WfStateInvokeType value);
	};

	class MakeStateMachineDeclaration : public vl::glr::ParsingAstBuilder<WfStateMachineDeclaration>
	{
	public:
		MakeStateMachineDeclaration& inputs(const vl::Ptr<WfStateInput>& value);
		MakeStateMachineDeclaration& states(const vl::Ptr<WfStateDeclaration>& value);
		MakeStateMachineDeclaration& expandedDeclarations(const vl::Ptr<WfDeclaration>& value);
		MakeStateMachineDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeStateMachineDeclaration& name(const vl::WString& value);
	};

	class MakeStateSwitchArgument : public vl::glr::ParsingAstBuilder<WfStateSwitchArgument>
	{
	public:
		MakeStateSwitchArgument& name(const vl::WString& value);
	};

	class MakeStateSwitchCase : public vl::glr::ParsingAstBuilder<WfStateSwitchCase>
	{
	public:
		MakeStateSwitchCase& arguments(const vl::Ptr<WfStateSwitchArgument>& value);
		MakeStateSwitchCase& name(const vl::WString& value);
		MakeStateSwitchCase& statement(const vl::Ptr<WfStatement>& value);
	};

	class MakeStateSwitchStatement : public vl::glr::ParsingAstBuilder<WfStateSwitchStatement>
	{
	public:
		MakeStateSwitchStatement& caseBranches(const vl::Ptr<WfStateSwitchCase>& value);
		MakeStateSwitchStatement& type(WfStateSwitchType value);
	};

	class MakeStaticInitDeclaration : public vl::glr::ParsingAstBuilder<WfStaticInitDeclaration>
	{
	public:
		MakeStaticInitDeclaration& statement(const vl::Ptr<WfStatement>& value);
		MakeStaticInitDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeStaticInitDeclaration& name(const vl::WString& value);
	};

	class MakeStringExpression : public vl::glr::ParsingAstBuilder<WfStringExpression>
	{
	public:
		MakeStringExpression& value(const vl::WString& value);
	};

	class MakeStructDeclaration : public vl::glr::ParsingAstBuilder<WfStructDeclaration>
	{
	public:
		MakeStructDeclaration& members(const vl::Ptr<WfStructMember>& value);
		MakeStructDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeStructDeclaration& name(const vl::WString& value);
	};

	class MakeStructMember : public vl::glr::ParsingAstBuilder<WfStructMember>
	{
	public:
		MakeStructMember& attributes(const vl::Ptr<WfAttribute>& value);
		MakeStructMember& name(const vl::WString& value);
		MakeStructMember& type(const vl::Ptr<WfType>& value);
	};

	class MakeSwitchCase : public vl::glr::ParsingAstBuilder<WfSwitchCase>
	{
	public:
		MakeSwitchCase& expression(const vl::Ptr<WfExpression>& value);
		MakeSwitchCase& statement(const vl::Ptr<WfStatement>& value);
	};

	class MakeSwitchStatement : public vl::glr::ParsingAstBuilder<WfSwitchStatement>
	{
	public:
		MakeSwitchStatement& caseBranches(const vl::Ptr<WfSwitchCase>& value);
		MakeSwitchStatement& defaultBranch(const vl::Ptr<WfStatement>& value);
		MakeSwitchStatement& expression(const vl::Ptr<WfExpression>& value);
		MakeSwitchStatement& expandedStatement(const vl::Ptr<WfStatement>& value);
	};

	class MakeTopQualifiedExpression : public vl::glr::ParsingAstBuilder<WfTopQualifiedExpression>
	{
	public:
		MakeTopQualifiedExpression& name(const vl::WString& value);
	};

	class MakeTopQualifiedType : public vl::glr::ParsingAstBuilder<WfTopQualifiedType>
	{
	public:
		MakeTopQualifiedType& name(const vl::WString& value);
	};

	class MakeTryStatement : public vl::glr::ParsingAstBuilder<WfTryStatement>
	{
	public:
		MakeTryStatement& catchStatement(const vl::Ptr<WfStatement>& value);
		MakeTryStatement& finallyStatement(const vl::Ptr<WfStatement>& value);
		MakeTryStatement& name(const vl::WString& value);
		MakeTryStatement& protectedStatement(const vl::Ptr<WfStatement>& value);
	};

	class MakeTypeCastingExpression : public vl::glr::ParsingAstBuilder<WfTypeCastingExpression>
	{
	public:
		MakeTypeCastingExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeTypeCastingExpression& strategy(WfTypeCastingStrategy value);
		MakeTypeCastingExpression& type(const vl::Ptr<WfType>& value);
	};

	class MakeTypeOfExpressionExpression : public vl::glr::ParsingAstBuilder<WfTypeOfExpressionExpression>
	{
	public:
		MakeTypeOfExpressionExpression& expression(const vl::Ptr<WfExpression>& value);
	};

	class MakeTypeOfTypeExpression : public vl::glr::ParsingAstBuilder<WfTypeOfTypeExpression>
	{
	public:
		MakeTypeOfTypeExpression& type(const vl::Ptr<WfType>& value);
	};

	class MakeTypeTestingExpression : public vl::glr::ParsingAstBuilder<WfTypeTestingExpression>
	{
	public:
		MakeTypeTestingExpression& expression(const vl::Ptr<WfExpression>& value);
		MakeTypeTestingExpression& test(WfTypeTesting value);
		MakeTypeTestingExpression& type(const vl::Ptr<WfType>& value);
	};

	class MakeUnaryExpression : public vl::glr::ParsingAstBuilder<WfUnaryExpression>
	{
	public:
		MakeUnaryExpression& op(WfUnaryOperator value);
		MakeUnaryExpression& operand(const vl::Ptr<WfExpression>& value);
	};

	class MakeVariableDeclaration : public vl::glr::ParsingAstBuilder<WfVariableDeclaration>
	{
	public:
		MakeVariableDeclaration& expression(const vl::Ptr<WfExpression>& value);
		MakeVariableDeclaration& type(const vl::Ptr<WfType>& value);
		MakeVariableDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeVariableDeclaration& name(const vl::WString& value);
	};

	class MakeVariableStatement : public vl::glr::ParsingAstBuilder<WfVariableStatement>
	{
	public:
		MakeVariableStatement& variable(const vl::Ptr<WfVariableDeclaration>& value);
	};

	class MakeVirtualCfeDeclaration : public vl::glr::ParsingAstBuilder<WfVirtualCfeDeclaration>
	{
	public:
		MakeVirtualCfeDeclaration& expandedDeclarations(const vl::Ptr<WfDeclaration>& value);
		MakeVirtualCfeDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeVirtualCfeDeclaration& name(const vl::WString& value);
	};

	class MakeVirtualCfeExpression : public vl::glr::ParsingAstBuilder<WfVirtualCfeExpression>
	{
	public:
		MakeVirtualCfeExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeVirtualCseDeclaration : public vl::glr::ParsingAstBuilder<WfVirtualCseDeclaration>
	{
	public:
		MakeVirtualCseDeclaration& expandedDeclarations(const vl::Ptr<WfDeclaration>& value);
		MakeVirtualCseDeclaration& attributes(const vl::Ptr<WfAttribute>& value);
		MakeVirtualCseDeclaration& name(const vl::WString& value);
	};

	class MakeVirtualCseExpression : public vl::glr::ParsingAstBuilder<WfVirtualCseExpression>
	{
	public:
		MakeVirtualCseExpression& expandedExpression(const vl::Ptr<WfExpression>& value);
	};

	class MakeVirtualCseStatement : public vl::glr::ParsingAstBuilder<WfVirtualCseStatement>
	{
	public:
		MakeVirtualCseStatement& expandedStatement(const vl::Ptr<WfStatement>& value);
	};

	class MakeWhileStatement : public vl::glr::ParsingAstBuilder<WfWhileStatement>
	{
	public:
		MakeWhileStatement& condition(const vl::Ptr<WfExpression>& value);
		MakeWhileStatement& statement(const vl::Ptr<WfStatement>& value);
	};

}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_COPY.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_AST_AST_COPY_VISITOR
#define VCZH_WORKFLOW_PARSER_AST_AST_COPY_VISITOR


namespace vl::workflow::copy_visitor
{
	/// <summary>A copy visitor, overriding all abstract methods with AST copying code.</summary>
	class AstVisitor
		: public virtual vl::glr::CopyVisitorBase
		, protected virtual WfType::IVisitor
		, protected virtual WfExpression::IVisitor
		, protected virtual WfStatement::IVisitor
		, protected virtual WfDeclaration::IVisitor
		, protected virtual WfVirtualCfeDeclaration::IVisitor
		, protected virtual WfVirtualCseDeclaration::IVisitor
		, protected virtual WfVirtualCseStatement::IVisitor
		, protected virtual WfCoroutineStatement::IVisitor
		, protected virtual WfStateMachineStatement::IVisitor
		, protected virtual WfVirtualCfeExpression::IVisitor
		, protected virtual WfVirtualCseExpression::IVisitor
		, protected virtual WfModuleUsingFragment::IVisitor
	{
	protected:
		void CopyFields(WfAttachEventExpression* from, WfAttachEventExpression* to);
		void CopyFields(WfAttribute* from, WfAttribute* to);
		void CopyFields(WfAutoPropertyDeclaration* from, WfAutoPropertyDeclaration* to);
		void CopyFields(WfBaseConstructorCall* from, WfBaseConstructorCall* to);
		void CopyFields(WfBinaryExpression* from, WfBinaryExpression* to);
		void CopyFields(WfBindExpression* from, WfBindExpression* to);
		void CopyFields(WfBlockStatement* from, WfBlockStatement* to);
		void CopyFields(WfBreakStatement* from, WfBreakStatement* to);
		void CopyFields(WfCallExpression* from, WfCallExpression* to);
		void CopyFields(WfCastResultInterfaceDeclaration* from, WfCastResultInterfaceDeclaration* to);
		void CopyFields(WfChildExpression* from, WfChildExpression* to);
		void CopyFields(WfChildType* from, WfChildType* to);
		void CopyFields(WfClassDeclaration* from, WfClassDeclaration* to);
		void CopyFields(WfCoOperatorExpression* from, WfCoOperatorExpression* to);
		void CopyFields(WfCoOperatorStatement* from, WfCoOperatorStatement* to);
		void CopyFields(WfCoPauseStatement* from, WfCoPauseStatement* to);
		void CopyFields(WfCoProviderStatement* from, WfCoProviderStatement* to);
		void CopyFields(WfConstructorArgument* from, WfConstructorArgument* to);
		void CopyFields(WfConstructorDeclaration* from, WfConstructorDeclaration* to);
		void CopyFields(WfConstructorExpression* from, WfConstructorExpression* to);
		void CopyFields(WfContinueStatement* from, WfContinueStatement* to);
		void CopyFields(WfCoroutineStatement* from, WfCoroutineStatement* to);
		void CopyFields(WfDeclaration* from, WfDeclaration* to);
		void CopyFields(WfDeleteStatement* from, WfDeleteStatement* to);
		void CopyFields(WfDestructorDeclaration* from, WfDestructorDeclaration* to);
		void CopyFields(WfDetachEventExpression* from, WfDetachEventExpression* to);
		void CopyFields(WfEnumDeclaration* from, WfEnumDeclaration* to);
		void CopyFields(WfEnumItem* from, WfEnumItem* to);
		void CopyFields(WfEnumItemIntersection* from, WfEnumItemIntersection* to);
		void CopyFields(WfEnumerableType* from, WfEnumerableType* to);
		void CopyFields(WfEventDeclaration* from, WfEventDeclaration* to);
		void CopyFields(WfExpectedTypeCastExpression* from, WfExpectedTypeCastExpression* to);
		void CopyFields(WfExpression* from, WfExpression* to);
		void CopyFields(WfExpressionStatement* from, WfExpressionStatement* to);
		void CopyFields(WfFloatingExpression* from, WfFloatingExpression* to);
		void CopyFields(WfForEachStatement* from, WfForEachStatement* to);
		void CopyFields(WfFormatExpression* from, WfFormatExpression* to);
		void CopyFields(WfFunctionArgument* from, WfFunctionArgument* to);
		void CopyFields(WfFunctionDeclaration* from, WfFunctionDeclaration* to);
		void CopyFields(WfFunctionExpression* from, WfFunctionExpression* to);
		void CopyFields(WfFunctionType* from, WfFunctionType* to);
		void CopyFields(WfGotoStatement* from, WfGotoStatement* to);
		void CopyFields(WfIfExpression* from, WfIfExpression* to);
		void CopyFields(WfIfStatement* from, WfIfStatement* to);
		void CopyFields(WfInferExpression* from, WfInferExpression* to);
		void CopyFields(WfIntegerExpression* from, WfIntegerExpression* to);
		void CopyFields(WfLetExpression* from, WfLetExpression* to);
		void CopyFields(WfLetVariable* from, WfLetVariable* to);
		void CopyFields(WfLiteralExpression* from, WfLiteralExpression* to);
		void CopyFields(WfMapType* from, WfMapType* to);
		void CopyFields(WfMemberExpression* from, WfMemberExpression* to);
		void CopyFields(WfMixinCastExpression* from, WfMixinCastExpression* to);
		void CopyFields(WfModule* from, WfModule* to);
		void CopyFields(WfModuleUsingFragment* from, WfModuleUsingFragment* to);
		void CopyFields(WfModuleUsingItem* from, WfModuleUsingItem* to);
		void CopyFields(WfModuleUsingNameFragment* from, WfModuleUsingNameFragment* to);
		void CopyFields(WfModuleUsingPath* from, WfModuleUsingPath* to);
		void CopyFields(WfModuleUsingWildCardFragment* from, WfModuleUsingWildCardFragment* to);
		void CopyFields(WfNamespaceDeclaration* from, WfNamespaceDeclaration* to);
		void CopyFields(WfNewClassExpression* from, WfNewClassExpression* to);
		void CopyFields(WfNewCoroutineExpression* from, WfNewCoroutineExpression* to);
		void CopyFields(WfNewInterfaceExpression* from, WfNewInterfaceExpression* to);
		void CopyFields(WfNullableType* from, WfNullableType* to);
		void CopyFields(WfObservableListType* from, WfObservableListType* to);
		void CopyFields(WfObserveExpression* from, WfObserveExpression* to);
		void CopyFields(WfOrderedLambdaExpression* from, WfOrderedLambdaExpression* to);
		void CopyFields(WfOrderedNameExpression* from, WfOrderedNameExpression* to);
		void CopyFields(WfPredefinedType* from, WfPredefinedType* to);
		void CopyFields(WfPropertyDeclaration* from, WfPropertyDeclaration* to);
		void CopyFields(WfRaiseExceptionStatement* from, WfRaiseExceptionStatement* to);
		void CopyFields(WfRangeExpression* from, WfRangeExpression* to);
		void CopyFields(WfRawPointerType* from, WfRawPointerType* to);
		void CopyFields(WfReferenceExpression* from, WfReferenceExpression* to);
		void CopyFields(WfReferenceType* from, WfReferenceType* to);
		void CopyFields(WfReturnStatement* from, WfReturnStatement* to);
		void CopyFields(WfSetTestingExpression* from, WfSetTestingExpression* to);
		void CopyFields(WfSharedPointerType* from, WfSharedPointerType* to);
		void CopyFields(WfStateDeclaration* from, WfStateDeclaration* to);
		void CopyFields(WfStateInput* from, WfStateInput* to);
		void CopyFields(WfStateInvokeStatement* from, WfStateInvokeStatement* to);
		void CopyFields(WfStateMachineDeclaration* from, WfStateMachineDeclaration* to);
		void CopyFields(WfStateMachineStatement* from, WfStateMachineStatement* to);
		void CopyFields(WfStateSwitchArgument* from, WfStateSwitchArgument* to);
		void CopyFields(WfStateSwitchCase* from, WfStateSwitchCase* to);
		void CopyFields(WfStateSwitchStatement* from, WfStateSwitchStatement* to);
		void CopyFields(WfStatement* from, WfStatement* to);
		void CopyFields(WfStaticInitDeclaration* from, WfStaticInitDeclaration* to);
		void CopyFields(WfStringExpression* from, WfStringExpression* to);
		void CopyFields(WfStructDeclaration* from, WfStructDeclaration* to);
		void CopyFields(WfStructMember* from, WfStructMember* to);
		void CopyFields(WfSwitchCase* from, WfSwitchCase* to);
		void CopyFields(WfSwitchStatement* from, WfSwitchStatement* to);
		void CopyFields(WfThisExpression* from, WfThisExpression* to);
		void CopyFields(WfTopQualifiedExpression* from, WfTopQualifiedExpression* to);
		void CopyFields(WfTopQualifiedType* from, WfTopQualifiedType* to);
		void CopyFields(WfTryStatement* from, WfTryStatement* to);
		void CopyFields(WfType* from, WfType* to);
		void CopyFields(WfTypeCastingExpression* from, WfTypeCastingExpression* to);
		void CopyFields(WfTypeOfExpressionExpression* from, WfTypeOfExpressionExpression* to);
		void CopyFields(WfTypeOfTypeExpression* from, WfTypeOfTypeExpression* to);
		void CopyFields(WfTypeTestingExpression* from, WfTypeTestingExpression* to);
		void CopyFields(WfUnaryExpression* from, WfUnaryExpression* to);
		void CopyFields(WfVariableDeclaration* from, WfVariableDeclaration* to);
		void CopyFields(WfVariableStatement* from, WfVariableStatement* to);
		void CopyFields(WfVirtualCfeDeclaration* from, WfVirtualCfeDeclaration* to);
		void CopyFields(WfVirtualCfeExpression* from, WfVirtualCfeExpression* to);
		void CopyFields(WfVirtualCseDeclaration* from, WfVirtualCseDeclaration* to);
		void CopyFields(WfVirtualCseExpression* from, WfVirtualCseExpression* to);
		void CopyFields(WfVirtualCseStatement* from, WfVirtualCseStatement* to);
		void CopyFields(WfWhileStatement* from, WfWhileStatement* to);

	protected:
		virtual void Visit(WfAttribute* node);
		virtual void Visit(WfFunctionArgument* node);
		virtual void Visit(WfBaseConstructorCall* node);
		virtual void Visit(WfEnumItemIntersection* node);
		virtual void Visit(WfEnumItem* node);
		virtual void Visit(WfStructMember* node);
		virtual void Visit(WfStateInput* node);
		virtual void Visit(WfStateDeclaration* node);
		virtual void Visit(WfSwitchCase* node);
		virtual void Visit(WfStateSwitchArgument* node);
		virtual void Visit(WfStateSwitchCase* node);
		virtual void Visit(WfLetVariable* node);
		virtual void Visit(WfConstructorArgument* node);
		virtual void Visit(WfModuleUsingItem* node);
		virtual void Visit(WfModuleUsingPath* node);
		virtual void Visit(WfModule* node);

		void Visit(WfPredefinedType* node) override;
		void Visit(WfTopQualifiedType* node) override;
		void Visit(WfReferenceType* node) override;
		void Visit(WfRawPointerType* node) override;
		void Visit(WfSharedPointerType* node) override;
		void Visit(WfNullableType* node) override;
		void Visit(WfEnumerableType* node) override;
		void Visit(WfMapType* node) override;
		void Visit(WfObservableListType* node) override;
		void Visit(WfFunctionType* node) override;
		void Visit(WfChildType* node) override;

		void Visit(WfThisExpression* node) override;
		void Visit(WfTopQualifiedExpression* node) override;
		void Visit(WfReferenceExpression* node) override;
		void Visit(WfOrderedNameExpression* node) override;
		void Visit(WfOrderedLambdaExpression* node) override;
		void Visit(WfMemberExpression* node) override;
		void Visit(WfChildExpression* node) override;
		void Visit(WfLiteralExpression* node) override;
		void Visit(WfFloatingExpression* node) override;
		void Visit(WfIntegerExpression* node) override;
		void Visit(WfStringExpression* node) override;
		void Visit(WfUnaryExpression* node) override;
		void Visit(WfBinaryExpression* node) override;
		void Visit(WfLetExpression* node) override;
		void Visit(WfIfExpression* node) override;
		void Visit(WfRangeExpression* node) override;
		void Visit(WfSetTestingExpression* node) override;
		void Visit(WfConstructorExpression* node) override;
		void Visit(WfInferExpression* node) override;
		void Visit(WfTypeCastingExpression* node) override;
		void Visit(WfTypeTestingExpression* node) override;
		void Visit(WfTypeOfTypeExpression* node) override;
		void Visit(WfTypeOfExpressionExpression* node) override;
		void Visit(WfAttachEventExpression* node) override;
		void Visit(WfDetachEventExpression* node) override;
		void Visit(WfObserveExpression* node) override;
		void Visit(WfCallExpression* node) override;
		void Visit(WfFunctionExpression* node) override;
		void Visit(WfNewClassExpression* node) override;
		void Visit(WfNewInterfaceExpression* node) override;
		void Visit(WfVirtualCfeExpression* node) override;
		void Visit(WfVirtualCseExpression* node) override;

		void Visit(WfBreakStatement* node) override;
		void Visit(WfContinueStatement* node) override;
		void Visit(WfReturnStatement* node) override;
		void Visit(WfDeleteStatement* node) override;
		void Visit(WfRaiseExceptionStatement* node) override;
		void Visit(WfIfStatement* node) override;
		void Visit(WfWhileStatement* node) override;
		void Visit(WfTryStatement* node) override;
		void Visit(WfBlockStatement* node) override;
		void Visit(WfGotoStatement* node) override;
		void Visit(WfVariableStatement* node) override;
		void Visit(WfExpressionStatement* node) override;
		void Visit(WfVirtualCseStatement* node) override;
		void Visit(WfCoroutineStatement* node) override;
		void Visit(WfStateMachineStatement* node) override;

		void Visit(WfNamespaceDeclaration* node) override;
		void Visit(WfFunctionDeclaration* node) override;
		void Visit(WfVariableDeclaration* node) override;
		void Visit(WfEventDeclaration* node) override;
		void Visit(WfPropertyDeclaration* node) override;
		void Visit(WfStaticInitDeclaration* node) override;
		void Visit(WfConstructorDeclaration* node) override;
		void Visit(WfDestructorDeclaration* node) override;
		void Visit(WfClassDeclaration* node) override;
		void Visit(WfEnumDeclaration* node) override;
		void Visit(WfStructDeclaration* node) override;
		void Visit(WfVirtualCfeDeclaration* node) override;
		void Visit(WfVirtualCseDeclaration* node) override;

		void Visit(WfAutoPropertyDeclaration* node) override;
		void Visit(WfCastResultInterfaceDeclaration* node) override;

		void Visit(WfStateMachineDeclaration* node) override;

		void Visit(WfForEachStatement* node) override;
		void Visit(WfSwitchStatement* node) override;
		void Visit(WfCoProviderStatement* node) override;

		void Visit(WfCoPauseStatement* node) override;
		void Visit(WfCoOperatorStatement* node) override;

		void Visit(WfStateSwitchStatement* node) override;
		void Visit(WfStateInvokeStatement* node) override;

		void Visit(WfFormatExpression* node) override;

		void Visit(WfBindExpression* node) override;
		void Visit(WfNewCoroutineExpression* node) override;
		void Visit(WfMixinCastExpression* node) override;
		void Visit(WfExpectedTypeCastExpression* node) override;
		void Visit(WfCoOperatorExpression* node) override;

		void Visit(WfModuleUsingNameFragment* node) override;
		void Visit(WfModuleUsingWildCardFragment* node) override;

	public:
		virtual vl::Ptr<WfType> CopyNode(WfType* node);
		virtual vl::Ptr<WfExpression> CopyNode(WfExpression* node);
		virtual vl::Ptr<WfStatement> CopyNode(WfStatement* node);
		virtual vl::Ptr<WfDeclaration> CopyNode(WfDeclaration* node);
		virtual vl::Ptr<WfModuleUsingFragment> CopyNode(WfModuleUsingFragment* node);
		virtual vl::Ptr<WfAttribute> CopyNode(WfAttribute* node);
		virtual vl::Ptr<WfFunctionArgument> CopyNode(WfFunctionArgument* node);
		virtual vl::Ptr<WfBaseConstructorCall> CopyNode(WfBaseConstructorCall* node);
		virtual vl::Ptr<WfEnumItemIntersection> CopyNode(WfEnumItemIntersection* node);
		virtual vl::Ptr<WfEnumItem> CopyNode(WfEnumItem* node);
		virtual vl::Ptr<WfStructMember> CopyNode(WfStructMember* node);
		virtual vl::Ptr<WfStateInput> CopyNode(WfStateInput* node);
		virtual vl::Ptr<WfStateDeclaration> CopyNode(WfStateDeclaration* node);
		virtual vl::Ptr<WfSwitchCase> CopyNode(WfSwitchCase* node);
		virtual vl::Ptr<WfStateSwitchArgument> CopyNode(WfStateSwitchArgument* node);
		virtual vl::Ptr<WfStateSwitchCase> CopyNode(WfStateSwitchCase* node);
		virtual vl::Ptr<WfLetVariable> CopyNode(WfLetVariable* node);
		virtual vl::Ptr<WfConstructorArgument> CopyNode(WfConstructorArgument* node);
		virtual vl::Ptr<WfModuleUsingItem> CopyNode(WfModuleUsingItem* node);
		virtual vl::Ptr<WfModuleUsingPath> CopyNode(WfModuleUsingPath* node);
		virtual vl::Ptr<WfModule> CopyNode(WfModule* node);

		vl::Ptr<WfAttachEventExpression> CopyNode(WfAttachEventExpression* node);
		vl::Ptr<WfAutoPropertyDeclaration> CopyNode(WfAutoPropertyDeclaration* node);
		vl::Ptr<WfBinaryExpression> CopyNode(WfBinaryExpression* node);
		vl::Ptr<WfBindExpression> CopyNode(WfBindExpression* node);
		vl::Ptr<WfBlockStatement> CopyNode(WfBlockStatement* node);
		vl::Ptr<WfBreakStatement> CopyNode(WfBreakStatement* node);
		vl::Ptr<WfCallExpression> CopyNode(WfCallExpression* node);
		vl::Ptr<WfCastResultInterfaceDeclaration> CopyNode(WfCastResultInterfaceDeclaration* node);
		vl::Ptr<WfChildExpression> CopyNode(WfChildExpression* node);
		vl::Ptr<WfChildType> CopyNode(WfChildType* node);
		vl::Ptr<WfClassDeclaration> CopyNode(WfClassDeclaration* node);
		vl::Ptr<WfCoOperatorExpression> CopyNode(WfCoOperatorExpression* node);
		vl::Ptr<WfCoOperatorStatement> CopyNode(WfCoOperatorStatement* node);
		vl::Ptr<WfCoPauseStatement> CopyNode(WfCoPauseStatement* node);
		vl::Ptr<WfCoProviderStatement> CopyNode(WfCoProviderStatement* node);
		vl::Ptr<WfConstructorDeclaration> CopyNode(WfConstructorDeclaration* node);
		vl::Ptr<WfConstructorExpression> CopyNode(WfConstructorExpression* node);
		vl::Ptr<WfContinueStatement> CopyNode(WfContinueStatement* node);
		vl::Ptr<WfCoroutineStatement> CopyNode(WfCoroutineStatement* node);
		vl::Ptr<WfDeleteStatement> CopyNode(WfDeleteStatement* node);
		vl::Ptr<WfDestructorDeclaration> CopyNode(WfDestructorDeclaration* node);
		vl::Ptr<WfDetachEventExpression> CopyNode(WfDetachEventExpression* node);
		vl::Ptr<WfEnumDeclaration> CopyNode(WfEnumDeclaration* node);
		vl::Ptr<WfEnumerableType> CopyNode(WfEnumerableType* node);
		vl::Ptr<WfEventDeclaration> CopyNode(WfEventDeclaration* node);
		vl::Ptr<WfExpectedTypeCastExpression> CopyNode(WfExpectedTypeCastExpression* node);
		vl::Ptr<WfExpressionStatement> CopyNode(WfExpressionStatement* node);
		vl::Ptr<WfFloatingExpression> CopyNode(WfFloatingExpression* node);
		vl::Ptr<WfForEachStatement> CopyNode(WfForEachStatement* node);
		vl::Ptr<WfFormatExpression> CopyNode(WfFormatExpression* node);
		vl::Ptr<WfFunctionDeclaration> CopyNode(WfFunctionDeclaration* node);
		vl::Ptr<WfFunctionExpression> CopyNode(WfFunctionExpression* node);
		vl::Ptr<WfFunctionType> CopyNode(WfFunctionType* node);
		vl::Ptr<WfGotoStatement> CopyNode(WfGotoStatement* node);
		vl::Ptr<WfIfExpression> CopyNode(WfIfExpression* node);
		vl::Ptr<WfIfStatement> CopyNode(WfIfStatement* node);
		vl::Ptr<WfInferExpression> CopyNode(WfInferExpression* node);
		vl::Ptr<WfIntegerExpression> CopyNode(WfIntegerExpression* node);
		vl::Ptr<WfLetExpression> CopyNode(WfLetExpression* node);
		vl::Ptr<WfLiteralExpression> CopyNode(WfLiteralExpression* node);
		vl::Ptr<WfMapType> CopyNode(WfMapType* node);
		vl::Ptr<WfMemberExpression> CopyNode(WfMemberExpression* node);
		vl::Ptr<WfMixinCastExpression> CopyNode(WfMixinCastExpression* node);
		vl::Ptr<WfModuleUsingNameFragment> CopyNode(WfModuleUsingNameFragment* node);
		vl::Ptr<WfModuleUsingWildCardFragment> CopyNode(WfModuleUsingWildCardFragment* node);
		vl::Ptr<WfNamespaceDeclaration> CopyNode(WfNamespaceDeclaration* node);
		vl::Ptr<WfNewClassExpression> CopyNode(WfNewClassExpression* node);
		vl::Ptr<WfNewCoroutineExpression> CopyNode(WfNewCoroutineExpression* node);
		vl::Ptr<WfNewInterfaceExpression> CopyNode(WfNewInterfaceExpression* node);
		vl::Ptr<WfNullableType> CopyNode(WfNullableType* node);
		vl::Ptr<WfObservableListType> CopyNode(WfObservableListType* node);
		vl::Ptr<WfObserveExpression> CopyNode(WfObserveExpression* node);
		vl::Ptr<WfOrderedLambdaExpression> CopyNode(WfOrderedLambdaExpression* node);
		vl::Ptr<WfOrderedNameExpression> CopyNode(WfOrderedNameExpression* node);
		vl::Ptr<WfPredefinedType> CopyNode(WfPredefinedType* node);
		vl::Ptr<WfPropertyDeclaration> CopyNode(WfPropertyDeclaration* node);
		vl::Ptr<WfRaiseExceptionStatement> CopyNode(WfRaiseExceptionStatement* node);
		vl::Ptr<WfRangeExpression> CopyNode(WfRangeExpression* node);
		vl::Ptr<WfRawPointerType> CopyNode(WfRawPointerType* node);
		vl::Ptr<WfReferenceExpression> CopyNode(WfReferenceExpression* node);
		vl::Ptr<WfReferenceType> CopyNode(WfReferenceType* node);
		vl::Ptr<WfReturnStatement> CopyNode(WfReturnStatement* node);
		vl::Ptr<WfSetTestingExpression> CopyNode(WfSetTestingExpression* node);
		vl::Ptr<WfSharedPointerType> CopyNode(WfSharedPointerType* node);
		vl::Ptr<WfStateInvokeStatement> CopyNode(WfStateInvokeStatement* node);
		vl::Ptr<WfStateMachineDeclaration> CopyNode(WfStateMachineDeclaration* node);
		vl::Ptr<WfStateMachineStatement> CopyNode(WfStateMachineStatement* node);
		vl::Ptr<WfStateSwitchStatement> CopyNode(WfStateSwitchStatement* node);
		vl::Ptr<WfStaticInitDeclaration> CopyNode(WfStaticInitDeclaration* node);
		vl::Ptr<WfStringExpression> CopyNode(WfStringExpression* node);
		vl::Ptr<WfStructDeclaration> CopyNode(WfStructDeclaration* node);
		vl::Ptr<WfSwitchStatement> CopyNode(WfSwitchStatement* node);
		vl::Ptr<WfThisExpression> CopyNode(WfThisExpression* node);
		vl::Ptr<WfTopQualifiedExpression> CopyNode(WfTopQualifiedExpression* node);
		vl::Ptr<WfTopQualifiedType> CopyNode(WfTopQualifiedType* node);
		vl::Ptr<WfTryStatement> CopyNode(WfTryStatement* node);
		vl::Ptr<WfTypeCastingExpression> CopyNode(WfTypeCastingExpression* node);
		vl::Ptr<WfTypeOfExpressionExpression> CopyNode(WfTypeOfExpressionExpression* node);
		vl::Ptr<WfTypeOfTypeExpression> CopyNode(WfTypeOfTypeExpression* node);
		vl::Ptr<WfTypeTestingExpression> CopyNode(WfTypeTestingExpression* node);
		vl::Ptr<WfUnaryExpression> CopyNode(WfUnaryExpression* node);
		vl::Ptr<WfVariableDeclaration> CopyNode(WfVariableDeclaration* node);
		vl::Ptr<WfVariableStatement> CopyNode(WfVariableStatement* node);
		vl::Ptr<WfVirtualCfeDeclaration> CopyNode(WfVirtualCfeDeclaration* node);
		vl::Ptr<WfVirtualCfeExpression> CopyNode(WfVirtualCfeExpression* node);
		vl::Ptr<WfVirtualCseDeclaration> CopyNode(WfVirtualCseDeclaration* node);
		vl::Ptr<WfVirtualCseExpression> CopyNode(WfVirtualCseExpression* node);
		vl::Ptr<WfVirtualCseStatement> CopyNode(WfVirtualCseStatement* node);
		vl::Ptr<WfWhileStatement> CopyNode(WfWhileStatement* node);
	};
}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_EMPTY.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_AST_AST_EMPTY_VISITOR
#define VCZH_WORKFLOW_PARSER_AST_AST_EMPTY_VISITOR


namespace vl::workflow::empty_visitor
{
	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class TypeVisitor : public vl::Object, public WfType::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfPredefinedType* node) override;
		void Visit(WfTopQualifiedType* node) override;
		void Visit(WfReferenceType* node) override;
		void Visit(WfRawPointerType* node) override;
		void Visit(WfSharedPointerType* node) override;
		void Visit(WfNullableType* node) override;
		void Visit(WfEnumerableType* node) override;
		void Visit(WfMapType* node) override;
		void Visit(WfObservableListType* node) override;
		void Visit(WfFunctionType* node) override;
		void Visit(WfChildType* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class ExpressionVisitor : public vl::Object, public WfExpression::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------
		virtual void Dispatch(WfVirtualCfeExpression* node) = 0;
		virtual void Dispatch(WfVirtualCseExpression* node) = 0;

	public:
		// Visitor Members -----------------------------------
		void Visit(WfThisExpression* node) override;
		void Visit(WfTopQualifiedExpression* node) override;
		void Visit(WfReferenceExpression* node) override;
		void Visit(WfOrderedNameExpression* node) override;
		void Visit(WfOrderedLambdaExpression* node) override;
		void Visit(WfMemberExpression* node) override;
		void Visit(WfChildExpression* node) override;
		void Visit(WfLiteralExpression* node) override;
		void Visit(WfFloatingExpression* node) override;
		void Visit(WfIntegerExpression* node) override;
		void Visit(WfStringExpression* node) override;
		void Visit(WfUnaryExpression* node) override;
		void Visit(WfBinaryExpression* node) override;
		void Visit(WfLetExpression* node) override;
		void Visit(WfIfExpression* node) override;
		void Visit(WfRangeExpression* node) override;
		void Visit(WfSetTestingExpression* node) override;
		void Visit(WfConstructorExpression* node) override;
		void Visit(WfInferExpression* node) override;
		void Visit(WfTypeCastingExpression* node) override;
		void Visit(WfTypeTestingExpression* node) override;
		void Visit(WfTypeOfTypeExpression* node) override;
		void Visit(WfTypeOfExpressionExpression* node) override;
		void Visit(WfAttachEventExpression* node) override;
		void Visit(WfDetachEventExpression* node) override;
		void Visit(WfObserveExpression* node) override;
		void Visit(WfCallExpression* node) override;
		void Visit(WfFunctionExpression* node) override;
		void Visit(WfNewClassExpression* node) override;
		void Visit(WfNewInterfaceExpression* node) override;
		void Visit(WfVirtualCfeExpression* node) override;
		void Visit(WfVirtualCseExpression* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class StatementVisitor : public vl::Object, public WfStatement::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------
		virtual void Dispatch(WfVirtualCseStatement* node) = 0;
		virtual void Dispatch(WfCoroutineStatement* node) = 0;
		virtual void Dispatch(WfStateMachineStatement* node) = 0;

	public:
		// Visitor Members -----------------------------------
		void Visit(WfBreakStatement* node) override;
		void Visit(WfContinueStatement* node) override;
		void Visit(WfReturnStatement* node) override;
		void Visit(WfDeleteStatement* node) override;
		void Visit(WfRaiseExceptionStatement* node) override;
		void Visit(WfIfStatement* node) override;
		void Visit(WfWhileStatement* node) override;
		void Visit(WfTryStatement* node) override;
		void Visit(WfBlockStatement* node) override;
		void Visit(WfGotoStatement* node) override;
		void Visit(WfVariableStatement* node) override;
		void Visit(WfExpressionStatement* node) override;
		void Visit(WfVirtualCseStatement* node) override;
		void Visit(WfCoroutineStatement* node) override;
		void Visit(WfStateMachineStatement* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class DeclarationVisitor : public vl::Object, public WfDeclaration::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------
		virtual void Dispatch(WfVirtualCfeDeclaration* node) = 0;
		virtual void Dispatch(WfVirtualCseDeclaration* node) = 0;

	public:
		// Visitor Members -----------------------------------
		void Visit(WfNamespaceDeclaration* node) override;
		void Visit(WfFunctionDeclaration* node) override;
		void Visit(WfVariableDeclaration* node) override;
		void Visit(WfEventDeclaration* node) override;
		void Visit(WfPropertyDeclaration* node) override;
		void Visit(WfStaticInitDeclaration* node) override;
		void Visit(WfConstructorDeclaration* node) override;
		void Visit(WfDestructorDeclaration* node) override;
		void Visit(WfClassDeclaration* node) override;
		void Visit(WfEnumDeclaration* node) override;
		void Visit(WfStructDeclaration* node) override;
		void Visit(WfVirtualCfeDeclaration* node) override;
		void Visit(WfVirtualCseDeclaration* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class VirtualCfeDeclarationVisitor : public vl::Object, public WfVirtualCfeDeclaration::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfAutoPropertyDeclaration* node) override;
		void Visit(WfCastResultInterfaceDeclaration* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class VirtualCseDeclarationVisitor : public vl::Object, public WfVirtualCseDeclaration::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfStateMachineDeclaration* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class VirtualCseStatementVisitor : public vl::Object, public WfVirtualCseStatement::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfForEachStatement* node) override;
		void Visit(WfSwitchStatement* node) override;
		void Visit(WfCoProviderStatement* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class CoroutineStatementVisitor : public vl::Object, public WfCoroutineStatement::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfCoPauseStatement* node) override;
		void Visit(WfCoOperatorStatement* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class StateMachineStatementVisitor : public vl::Object, public WfStateMachineStatement::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfStateSwitchStatement* node) override;
		void Visit(WfStateInvokeStatement* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class VirtualCfeExpressionVisitor : public vl::Object, public WfVirtualCfeExpression::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfFormatExpression* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class VirtualCseExpressionVisitor : public vl::Object, public WfVirtualCseExpression::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfBindExpression* node) override;
		void Visit(WfNewCoroutineExpression* node) override;
		void Visit(WfMixinCastExpression* node) override;
		void Visit(WfExpectedTypeCastExpression* node) override;
		void Visit(WfCoOperatorExpression* node) override;
	};

	/// <summary>An empty visitor, overriding all abstract methods with empty implementations.</summary>
	class ModuleUsingFragmentVisitor : public vl::Object, public WfModuleUsingFragment::IVisitor
	{
	protected:
		// Dispatch (virtual) --------------------------------

	public:
		// Visitor Members -----------------------------------
		void Visit(WfModuleUsingNameFragment* node) override;
		void Visit(WfModuleUsingWildCardFragment* node) override;
	};

}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_JSON.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_AST_AST_JSON_VISITOR
#define VCZH_WORKFLOW_PARSER_AST_AST_JSON_VISITOR


namespace vl::workflow::json_visitor
{
	/// <summary>A JSON visitor, overriding all abstract methods with AST to JSON serialization code.</summary>
	class AstVisitor
		: public vl::glr::JsonVisitorBase
		, protected virtual WfType::IVisitor
		, protected virtual WfExpression::IVisitor
		, protected virtual WfStatement::IVisitor
		, protected virtual WfDeclaration::IVisitor
		, protected virtual WfVirtualCfeDeclaration::IVisitor
		, protected virtual WfVirtualCseDeclaration::IVisitor
		, protected virtual WfVirtualCseStatement::IVisitor
		, protected virtual WfCoroutineStatement::IVisitor
		, protected virtual WfStateMachineStatement::IVisitor
		, protected virtual WfVirtualCfeExpression::IVisitor
		, protected virtual WfVirtualCseExpression::IVisitor
		, protected virtual WfModuleUsingFragment::IVisitor
	{
	protected:
		virtual void PrintFields(WfAttachEventExpression* node);
		virtual void PrintFields(WfAttribute* node);
		virtual void PrintFields(WfAutoPropertyDeclaration* node);
		virtual void PrintFields(WfBaseConstructorCall* node);
		virtual void PrintFields(WfBinaryExpression* node);
		virtual void PrintFields(WfBindExpression* node);
		virtual void PrintFields(WfBlockStatement* node);
		virtual void PrintFields(WfBreakStatement* node);
		virtual void PrintFields(WfCallExpression* node);
		virtual void PrintFields(WfCastResultInterfaceDeclaration* node);
		virtual void PrintFields(WfChildExpression* node);
		virtual void PrintFields(WfChildType* node);
		virtual void PrintFields(WfClassDeclaration* node);
		virtual void PrintFields(WfCoOperatorExpression* node);
		virtual void PrintFields(WfCoOperatorStatement* node);
		virtual void PrintFields(WfCoPauseStatement* node);
		virtual void PrintFields(WfCoProviderStatement* node);
		virtual void PrintFields(WfConstructorArgument* node);
		virtual void PrintFields(WfConstructorDeclaration* node);
		virtual void PrintFields(WfConstructorExpression* node);
		virtual void PrintFields(WfContinueStatement* node);
		virtual void PrintFields(WfCoroutineStatement* node);
		virtual void PrintFields(WfDeclaration* node);
		virtual void PrintFields(WfDeleteStatement* node);
		virtual void PrintFields(WfDestructorDeclaration* node);
		virtual void PrintFields(WfDetachEventExpression* node);
		virtual void PrintFields(WfEnumDeclaration* node);
		virtual void PrintFields(WfEnumItem* node);
		virtual void PrintFields(WfEnumItemIntersection* node);
		virtual void PrintFields(WfEnumerableType* node);
		virtual void PrintFields(WfEventDeclaration* node);
		virtual void PrintFields(WfExpectedTypeCastExpression* node);
		virtual void PrintFields(WfExpression* node);
		virtual void PrintFields(WfExpressionStatement* node);
		virtual void PrintFields(WfFloatingExpression* node);
		virtual void PrintFields(WfForEachStatement* node);
		virtual void PrintFields(WfFormatExpression* node);
		virtual void PrintFields(WfFunctionArgument* node);
		virtual void PrintFields(WfFunctionDeclaration* node);
		virtual void PrintFields(WfFunctionExpression* node);
		virtual void PrintFields(WfFunctionType* node);
		virtual void PrintFields(WfGotoStatement* node);
		virtual void PrintFields(WfIfExpression* node);
		virtual void PrintFields(WfIfStatement* node);
		virtual void PrintFields(WfInferExpression* node);
		virtual void PrintFields(WfIntegerExpression* node);
		virtual void PrintFields(WfLetExpression* node);
		virtual void PrintFields(WfLetVariable* node);
		virtual void PrintFields(WfLiteralExpression* node);
		virtual void PrintFields(WfMapType* node);
		virtual void PrintFields(WfMemberExpression* node);
		virtual void PrintFields(WfMixinCastExpression* node);
		virtual void PrintFields(WfModule* node);
		virtual void PrintFields(WfModuleUsingFragment* node);
		virtual void PrintFields(WfModuleUsingItem* node);
		virtual void PrintFields(WfModuleUsingNameFragment* node);
		virtual void PrintFields(WfModuleUsingPath* node);
		virtual void PrintFields(WfModuleUsingWildCardFragment* node);
		virtual void PrintFields(WfNamespaceDeclaration* node);
		virtual void PrintFields(WfNewClassExpression* node);
		virtual void PrintFields(WfNewCoroutineExpression* node);
		virtual void PrintFields(WfNewInterfaceExpression* node);
		virtual void PrintFields(WfNullableType* node);
		virtual void PrintFields(WfObservableListType* node);
		virtual void PrintFields(WfObserveExpression* node);
		virtual void PrintFields(WfOrderedLambdaExpression* node);
		virtual void PrintFields(WfOrderedNameExpression* node);
		virtual void PrintFields(WfPredefinedType* node);
		virtual void PrintFields(WfPropertyDeclaration* node);
		virtual void PrintFields(WfRaiseExceptionStatement* node);
		virtual void PrintFields(WfRangeExpression* node);
		virtual void PrintFields(WfRawPointerType* node);
		virtual void PrintFields(WfReferenceExpression* node);
		virtual void PrintFields(WfReferenceType* node);
		virtual void PrintFields(WfReturnStatement* node);
		virtual void PrintFields(WfSetTestingExpression* node);
		virtual void PrintFields(WfSharedPointerType* node);
		virtual void PrintFields(WfStateDeclaration* node);
		virtual void PrintFields(WfStateInput* node);
		virtual void PrintFields(WfStateInvokeStatement* node);
		virtual void PrintFields(WfStateMachineDeclaration* node);
		virtual void PrintFields(WfStateMachineStatement* node);
		virtual void PrintFields(WfStateSwitchArgument* node);
		virtual void PrintFields(WfStateSwitchCase* node);
		virtual void PrintFields(WfStateSwitchStatement* node);
		virtual void PrintFields(WfStatement* node);
		virtual void PrintFields(WfStaticInitDeclaration* node);
		virtual void PrintFields(WfStringExpression* node);
		virtual void PrintFields(WfStructDeclaration* node);
		virtual void PrintFields(WfStructMember* node);
		virtual void PrintFields(WfSwitchCase* node);
		virtual void PrintFields(WfSwitchStatement* node);
		virtual void PrintFields(WfThisExpression* node);
		virtual void PrintFields(WfTopQualifiedExpression* node);
		virtual void PrintFields(WfTopQualifiedType* node);
		virtual void PrintFields(WfTryStatement* node);
		virtual void PrintFields(WfType* node);
		virtual void PrintFields(WfTypeCastingExpression* node);
		virtual void PrintFields(WfTypeOfExpressionExpression* node);
		virtual void PrintFields(WfTypeOfTypeExpression* node);
		virtual void PrintFields(WfTypeTestingExpression* node);
		virtual void PrintFields(WfUnaryExpression* node);
		virtual void PrintFields(WfVariableDeclaration* node);
		virtual void PrintFields(WfVariableStatement* node);
		virtual void PrintFields(WfVirtualCfeDeclaration* node);
		virtual void PrintFields(WfVirtualCfeExpression* node);
		virtual void PrintFields(WfVirtualCseDeclaration* node);
		virtual void PrintFields(WfVirtualCseExpression* node);
		virtual void PrintFields(WfVirtualCseStatement* node);
		virtual void PrintFields(WfWhileStatement* node);

	protected:
		void Visit(WfPredefinedType* node) override;
		void Visit(WfTopQualifiedType* node) override;
		void Visit(WfReferenceType* node) override;
		void Visit(WfRawPointerType* node) override;
		void Visit(WfSharedPointerType* node) override;
		void Visit(WfNullableType* node) override;
		void Visit(WfEnumerableType* node) override;
		void Visit(WfMapType* node) override;
		void Visit(WfObservableListType* node) override;
		void Visit(WfFunctionType* node) override;
		void Visit(WfChildType* node) override;

		void Visit(WfThisExpression* node) override;
		void Visit(WfTopQualifiedExpression* node) override;
		void Visit(WfReferenceExpression* node) override;
		void Visit(WfOrderedNameExpression* node) override;
		void Visit(WfOrderedLambdaExpression* node) override;
		void Visit(WfMemberExpression* node) override;
		void Visit(WfChildExpression* node) override;
		void Visit(WfLiteralExpression* node) override;
		void Visit(WfFloatingExpression* node) override;
		void Visit(WfIntegerExpression* node) override;
		void Visit(WfStringExpression* node) override;
		void Visit(WfUnaryExpression* node) override;
		void Visit(WfBinaryExpression* node) override;
		void Visit(WfLetExpression* node) override;
		void Visit(WfIfExpression* node) override;
		void Visit(WfRangeExpression* node) override;
		void Visit(WfSetTestingExpression* node) override;
		void Visit(WfConstructorExpression* node) override;
		void Visit(WfInferExpression* node) override;
		void Visit(WfTypeCastingExpression* node) override;
		void Visit(WfTypeTestingExpression* node) override;
		void Visit(WfTypeOfTypeExpression* node) override;
		void Visit(WfTypeOfExpressionExpression* node) override;
		void Visit(WfAttachEventExpression* node) override;
		void Visit(WfDetachEventExpression* node) override;
		void Visit(WfObserveExpression* node) override;
		void Visit(WfCallExpression* node) override;
		void Visit(WfFunctionExpression* node) override;
		void Visit(WfNewClassExpression* node) override;
		void Visit(WfNewInterfaceExpression* node) override;
		void Visit(WfVirtualCfeExpression* node) override;
		void Visit(WfVirtualCseExpression* node) override;

		void Visit(WfBreakStatement* node) override;
		void Visit(WfContinueStatement* node) override;
		void Visit(WfReturnStatement* node) override;
		void Visit(WfDeleteStatement* node) override;
		void Visit(WfRaiseExceptionStatement* node) override;
		void Visit(WfIfStatement* node) override;
		void Visit(WfWhileStatement* node) override;
		void Visit(WfTryStatement* node) override;
		void Visit(WfBlockStatement* node) override;
		void Visit(WfGotoStatement* node) override;
		void Visit(WfVariableStatement* node) override;
		void Visit(WfExpressionStatement* node) override;
		void Visit(WfVirtualCseStatement* node) override;
		void Visit(WfCoroutineStatement* node) override;
		void Visit(WfStateMachineStatement* node) override;

		void Visit(WfNamespaceDeclaration* node) override;
		void Visit(WfFunctionDeclaration* node) override;
		void Visit(WfVariableDeclaration* node) override;
		void Visit(WfEventDeclaration* node) override;
		void Visit(WfPropertyDeclaration* node) override;
		void Visit(WfStaticInitDeclaration* node) override;
		void Visit(WfConstructorDeclaration* node) override;
		void Visit(WfDestructorDeclaration* node) override;
		void Visit(WfClassDeclaration* node) override;
		void Visit(WfEnumDeclaration* node) override;
		void Visit(WfStructDeclaration* node) override;
		void Visit(WfVirtualCfeDeclaration* node) override;
		void Visit(WfVirtualCseDeclaration* node) override;

		void Visit(WfAutoPropertyDeclaration* node) override;
		void Visit(WfCastResultInterfaceDeclaration* node) override;

		void Visit(WfStateMachineDeclaration* node) override;

		void Visit(WfForEachStatement* node) override;
		void Visit(WfSwitchStatement* node) override;
		void Visit(WfCoProviderStatement* node) override;

		void Visit(WfCoPauseStatement* node) override;
		void Visit(WfCoOperatorStatement* node) override;

		void Visit(WfStateSwitchStatement* node) override;
		void Visit(WfStateInvokeStatement* node) override;

		void Visit(WfFormatExpression* node) override;

		void Visit(WfBindExpression* node) override;
		void Visit(WfNewCoroutineExpression* node) override;
		void Visit(WfMixinCastExpression* node) override;
		void Visit(WfExpectedTypeCastExpression* node) override;
		void Visit(WfCoOperatorExpression* node) override;

		void Visit(WfModuleUsingNameFragment* node) override;
		void Visit(WfModuleUsingWildCardFragment* node) override;

	public:
		AstVisitor(vl::stream::StreamWriter& _writer);

		void Print(WfType* node);
		void Print(WfExpression* node);
		void Print(WfStatement* node);
		void Print(WfDeclaration* node);
		void Print(WfModuleUsingFragment* node);
		void Print(WfAttribute* node);
		void Print(WfFunctionArgument* node);
		void Print(WfBaseConstructorCall* node);
		void Print(WfEnumItemIntersection* node);
		void Print(WfEnumItem* node);
		void Print(WfStructMember* node);
		void Print(WfStateInput* node);
		void Print(WfStateDeclaration* node);
		void Print(WfSwitchCase* node);
		void Print(WfStateSwitchArgument* node);
		void Print(WfStateSwitchCase* node);
		void Print(WfLetVariable* node);
		void Print(WfConstructorArgument* node);
		void Print(WfModuleUsingItem* node);
		void Print(WfModuleUsingPath* node);
		void Print(WfModule* node);
	};
}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOWAST_TRAVERSE.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Ast
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_AST_AST_TRAVERSE_VISITOR
#define VCZH_WORKFLOW_PARSER_AST_AST_TRAVERSE_VISITOR


namespace vl::workflow::traverse_visitor
{
	/// <summary>A traverse visitor, overriding all abstract methods with AST visiting code.</summary>
	class AstVisitor
		: public vl::Object
		, protected virtual WfType::IVisitor
		, protected virtual WfExpression::IVisitor
		, protected virtual WfStatement::IVisitor
		, protected virtual WfDeclaration::IVisitor
		, protected virtual WfVirtualCfeDeclaration::IVisitor
		, protected virtual WfVirtualCseDeclaration::IVisitor
		, protected virtual WfVirtualCseStatement::IVisitor
		, protected virtual WfCoroutineStatement::IVisitor
		, protected virtual WfStateMachineStatement::IVisitor
		, protected virtual WfVirtualCfeExpression::IVisitor
		, protected virtual WfVirtualCseExpression::IVisitor
		, protected virtual WfModuleUsingFragment::IVisitor
	{
	protected:
		virtual void Traverse(vl::glr::ParsingToken& token);
		virtual void Traverse(vl::glr::ParsingAstBase* node);
		virtual void Traverse(WfAttachEventExpression* node);
		virtual void Traverse(WfAttribute* node);
		virtual void Traverse(WfAutoPropertyDeclaration* node);
		virtual void Traverse(WfBaseConstructorCall* node);
		virtual void Traverse(WfBinaryExpression* node);
		virtual void Traverse(WfBindExpression* node);
		virtual void Traverse(WfBlockStatement* node);
		virtual void Traverse(WfBreakStatement* node);
		virtual void Traverse(WfCallExpression* node);
		virtual void Traverse(WfCastResultInterfaceDeclaration* node);
		virtual void Traverse(WfChildExpression* node);
		virtual void Traverse(WfChildType* node);
		virtual void Traverse(WfClassDeclaration* node);
		virtual void Traverse(WfCoOperatorExpression* node);
		virtual void Traverse(WfCoOperatorStatement* node);
		virtual void Traverse(WfCoPauseStatement* node);
		virtual void Traverse(WfCoProviderStatement* node);
		virtual void Traverse(WfConstructorArgument* node);
		virtual void Traverse(WfConstructorDeclaration* node);
		virtual void Traverse(WfConstructorExpression* node);
		virtual void Traverse(WfContinueStatement* node);
		virtual void Traverse(WfCoroutineStatement* node);
		virtual void Traverse(WfDeclaration* node);
		virtual void Traverse(WfDeleteStatement* node);
		virtual void Traverse(WfDestructorDeclaration* node);
		virtual void Traverse(WfDetachEventExpression* node);
		virtual void Traverse(WfEnumDeclaration* node);
		virtual void Traverse(WfEnumItem* node);
		virtual void Traverse(WfEnumItemIntersection* node);
		virtual void Traverse(WfEnumerableType* node);
		virtual void Traverse(WfEventDeclaration* node);
		virtual void Traverse(WfExpectedTypeCastExpression* node);
		virtual void Traverse(WfExpression* node);
		virtual void Traverse(WfExpressionStatement* node);
		virtual void Traverse(WfFloatingExpression* node);
		virtual void Traverse(WfForEachStatement* node);
		virtual void Traverse(WfFormatExpression* node);
		virtual void Traverse(WfFunctionArgument* node);
		virtual void Traverse(WfFunctionDeclaration* node);
		virtual void Traverse(WfFunctionExpression* node);
		virtual void Traverse(WfFunctionType* node);
		virtual void Traverse(WfGotoStatement* node);
		virtual void Traverse(WfIfExpression* node);
		virtual void Traverse(WfIfStatement* node);
		virtual void Traverse(WfInferExpression* node);
		virtual void Traverse(WfIntegerExpression* node);
		virtual void Traverse(WfLetExpression* node);
		virtual void Traverse(WfLetVariable* node);
		virtual void Traverse(WfLiteralExpression* node);
		virtual void Traverse(WfMapType* node);
		virtual void Traverse(WfMemberExpression* node);
		virtual void Traverse(WfMixinCastExpression* node);
		virtual void Traverse(WfModule* node);
		virtual void Traverse(WfModuleUsingFragment* node);
		virtual void Traverse(WfModuleUsingItem* node);
		virtual void Traverse(WfModuleUsingNameFragment* node);
		virtual void Traverse(WfModuleUsingPath* node);
		virtual void Traverse(WfModuleUsingWildCardFragment* node);
		virtual void Traverse(WfNamespaceDeclaration* node);
		virtual void Traverse(WfNewClassExpression* node);
		virtual void Traverse(WfNewCoroutineExpression* node);
		virtual void Traverse(WfNewInterfaceExpression* node);
		virtual void Traverse(WfNullableType* node);
		virtual void Traverse(WfObservableListType* node);
		virtual void Traverse(WfObserveExpression* node);
		virtual void Traverse(WfOrderedLambdaExpression* node);
		virtual void Traverse(WfOrderedNameExpression* node);
		virtual void Traverse(WfPredefinedType* node);
		virtual void Traverse(WfPropertyDeclaration* node);
		virtual void Traverse(WfRaiseExceptionStatement* node);
		virtual void Traverse(WfRangeExpression* node);
		virtual void Traverse(WfRawPointerType* node);
		virtual void Traverse(WfReferenceExpression* node);
		virtual void Traverse(WfReferenceType* node);
		virtual void Traverse(WfReturnStatement* node);
		virtual void Traverse(WfSetTestingExpression* node);
		virtual void Traverse(WfSharedPointerType* node);
		virtual void Traverse(WfStateDeclaration* node);
		virtual void Traverse(WfStateInput* node);
		virtual void Traverse(WfStateInvokeStatement* node);
		virtual void Traverse(WfStateMachineDeclaration* node);
		virtual void Traverse(WfStateMachineStatement* node);
		virtual void Traverse(WfStateSwitchArgument* node);
		virtual void Traverse(WfStateSwitchCase* node);
		virtual void Traverse(WfStateSwitchStatement* node);
		virtual void Traverse(WfStatement* node);
		virtual void Traverse(WfStaticInitDeclaration* node);
		virtual void Traverse(WfStringExpression* node);
		virtual void Traverse(WfStructDeclaration* node);
		virtual void Traverse(WfStructMember* node);
		virtual void Traverse(WfSwitchCase* node);
		virtual void Traverse(WfSwitchStatement* node);
		virtual void Traverse(WfThisExpression* node);
		virtual void Traverse(WfTopQualifiedExpression* node);
		virtual void Traverse(WfTopQualifiedType* node);
		virtual void Traverse(WfTryStatement* node);
		virtual void Traverse(WfType* node);
		virtual void Traverse(WfTypeCastingExpression* node);
		virtual void Traverse(WfTypeOfExpressionExpression* node);
		virtual void Traverse(WfTypeOfTypeExpression* node);
		virtual void Traverse(WfTypeTestingExpression* node);
		virtual void Traverse(WfUnaryExpression* node);
		virtual void Traverse(WfVariableDeclaration* node);
		virtual void Traverse(WfVariableStatement* node);
		virtual void Traverse(WfVirtualCfeDeclaration* node);
		virtual void Traverse(WfVirtualCfeExpression* node);
		virtual void Traverse(WfVirtualCseDeclaration* node);
		virtual void Traverse(WfVirtualCseExpression* node);
		virtual void Traverse(WfVirtualCseStatement* node);
		virtual void Traverse(WfWhileStatement* node);

	protected:
		virtual void Finishing(vl::glr::ParsingAstBase* node);
		virtual void Finishing(WfAttachEventExpression* node);
		virtual void Finishing(WfAttribute* node);
		virtual void Finishing(WfAutoPropertyDeclaration* node);
		virtual void Finishing(WfBaseConstructorCall* node);
		virtual void Finishing(WfBinaryExpression* node);
		virtual void Finishing(WfBindExpression* node);
		virtual void Finishing(WfBlockStatement* node);
		virtual void Finishing(WfBreakStatement* node);
		virtual void Finishing(WfCallExpression* node);
		virtual void Finishing(WfCastResultInterfaceDeclaration* node);
		virtual void Finishing(WfChildExpression* node);
		virtual void Finishing(WfChildType* node);
		virtual void Finishing(WfClassDeclaration* node);
		virtual void Finishing(WfCoOperatorExpression* node);
		virtual void Finishing(WfCoOperatorStatement* node);
		virtual void Finishing(WfCoPauseStatement* node);
		virtual void Finishing(WfCoProviderStatement* node);
		virtual void Finishing(WfConstructorArgument* node);
		virtual void Finishing(WfConstructorDeclaration* node);
		virtual void Finishing(WfConstructorExpression* node);
		virtual void Finishing(WfContinueStatement* node);
		virtual void Finishing(WfCoroutineStatement* node);
		virtual void Finishing(WfDeclaration* node);
		virtual void Finishing(WfDeleteStatement* node);
		virtual void Finishing(WfDestructorDeclaration* node);
		virtual void Finishing(WfDetachEventExpression* node);
		virtual void Finishing(WfEnumDeclaration* node);
		virtual void Finishing(WfEnumItem* node);
		virtual void Finishing(WfEnumItemIntersection* node);
		virtual void Finishing(WfEnumerableType* node);
		virtual void Finishing(WfEventDeclaration* node);
		virtual void Finishing(WfExpectedTypeCastExpression* node);
		virtual void Finishing(WfExpression* node);
		virtual void Finishing(WfExpressionStatement* node);
		virtual void Finishing(WfFloatingExpression* node);
		virtual void Finishing(WfForEachStatement* node);
		virtual void Finishing(WfFormatExpression* node);
		virtual void Finishing(WfFunctionArgument* node);
		virtual void Finishing(WfFunctionDeclaration* node);
		virtual void Finishing(WfFunctionExpression* node);
		virtual void Finishing(WfFunctionType* node);
		virtual void Finishing(WfGotoStatement* node);
		virtual void Finishing(WfIfExpression* node);
		virtual void Finishing(WfIfStatement* node);
		virtual void Finishing(WfInferExpression* node);
		virtual void Finishing(WfIntegerExpression* node);
		virtual void Finishing(WfLetExpression* node);
		virtual void Finishing(WfLetVariable* node);
		virtual void Finishing(WfLiteralExpression* node);
		virtual void Finishing(WfMapType* node);
		virtual void Finishing(WfMemberExpression* node);
		virtual void Finishing(WfMixinCastExpression* node);
		virtual void Finishing(WfModule* node);
		virtual void Finishing(WfModuleUsingFragment* node);
		virtual void Finishing(WfModuleUsingItem* node);
		virtual void Finishing(WfModuleUsingNameFragment* node);
		virtual void Finishing(WfModuleUsingPath* node);
		virtual void Finishing(WfModuleUsingWildCardFragment* node);
		virtual void Finishing(WfNamespaceDeclaration* node);
		virtual void Finishing(WfNewClassExpression* node);
		virtual void Finishing(WfNewCoroutineExpression* node);
		virtual void Finishing(WfNewInterfaceExpression* node);
		virtual void Finishing(WfNullableType* node);
		virtual void Finishing(WfObservableListType* node);
		virtual void Finishing(WfObserveExpression* node);
		virtual void Finishing(WfOrderedLambdaExpression* node);
		virtual void Finishing(WfOrderedNameExpression* node);
		virtual void Finishing(WfPredefinedType* node);
		virtual void Finishing(WfPropertyDeclaration* node);
		virtual void Finishing(WfRaiseExceptionStatement* node);
		virtual void Finishing(WfRangeExpression* node);
		virtual void Finishing(WfRawPointerType* node);
		virtual void Finishing(WfReferenceExpression* node);
		virtual void Finishing(WfReferenceType* node);
		virtual void Finishing(WfReturnStatement* node);
		virtual void Finishing(WfSetTestingExpression* node);
		virtual void Finishing(WfSharedPointerType* node);
		virtual void Finishing(WfStateDeclaration* node);
		virtual void Finishing(WfStateInput* node);
		virtual void Finishing(WfStateInvokeStatement* node);
		virtual void Finishing(WfStateMachineDeclaration* node);
		virtual void Finishing(WfStateMachineStatement* node);
		virtual void Finishing(WfStateSwitchArgument* node);
		virtual void Finishing(WfStateSwitchCase* node);
		virtual void Finishing(WfStateSwitchStatement* node);
		virtual void Finishing(WfStatement* node);
		virtual void Finishing(WfStaticInitDeclaration* node);
		virtual void Finishing(WfStringExpression* node);
		virtual void Finishing(WfStructDeclaration* node);
		virtual void Finishing(WfStructMember* node);
		virtual void Finishing(WfSwitchCase* node);
		virtual void Finishing(WfSwitchStatement* node);
		virtual void Finishing(WfThisExpression* node);
		virtual void Finishing(WfTopQualifiedExpression* node);
		virtual void Finishing(WfTopQualifiedType* node);
		virtual void Finishing(WfTryStatement* node);
		virtual void Finishing(WfType* node);
		virtual void Finishing(WfTypeCastingExpression* node);
		virtual void Finishing(WfTypeOfExpressionExpression* node);
		virtual void Finishing(WfTypeOfTypeExpression* node);
		virtual void Finishing(WfTypeTestingExpression* node);
		virtual void Finishing(WfUnaryExpression* node);
		virtual void Finishing(WfVariableDeclaration* node);
		virtual void Finishing(WfVariableStatement* node);
		virtual void Finishing(WfVirtualCfeDeclaration* node);
		virtual void Finishing(WfVirtualCfeExpression* node);
		virtual void Finishing(WfVirtualCseDeclaration* node);
		virtual void Finishing(WfVirtualCseExpression* node);
		virtual void Finishing(WfVirtualCseStatement* node);
		virtual void Finishing(WfWhileStatement* node);

	protected:
		void Visit(WfPredefinedType* node) override;
		void Visit(WfTopQualifiedType* node) override;
		void Visit(WfReferenceType* node) override;
		void Visit(WfRawPointerType* node) override;
		void Visit(WfSharedPointerType* node) override;
		void Visit(WfNullableType* node) override;
		void Visit(WfEnumerableType* node) override;
		void Visit(WfMapType* node) override;
		void Visit(WfObservableListType* node) override;
		void Visit(WfFunctionType* node) override;
		void Visit(WfChildType* node) override;

		void Visit(WfThisExpression* node) override;
		void Visit(WfTopQualifiedExpression* node) override;
		void Visit(WfReferenceExpression* node) override;
		void Visit(WfOrderedNameExpression* node) override;
		void Visit(WfOrderedLambdaExpression* node) override;
		void Visit(WfMemberExpression* node) override;
		void Visit(WfChildExpression* node) override;
		void Visit(WfLiteralExpression* node) override;
		void Visit(WfFloatingExpression* node) override;
		void Visit(WfIntegerExpression* node) override;
		void Visit(WfStringExpression* node) override;
		void Visit(WfUnaryExpression* node) override;
		void Visit(WfBinaryExpression* node) override;
		void Visit(WfLetExpression* node) override;
		void Visit(WfIfExpression* node) override;
		void Visit(WfRangeExpression* node) override;
		void Visit(WfSetTestingExpression* node) override;
		void Visit(WfConstructorExpression* node) override;
		void Visit(WfInferExpression* node) override;
		void Visit(WfTypeCastingExpression* node) override;
		void Visit(WfTypeTestingExpression* node) override;
		void Visit(WfTypeOfTypeExpression* node) override;
		void Visit(WfTypeOfExpressionExpression* node) override;
		void Visit(WfAttachEventExpression* node) override;
		void Visit(WfDetachEventExpression* node) override;
		void Visit(WfObserveExpression* node) override;
		void Visit(WfCallExpression* node) override;
		void Visit(WfFunctionExpression* node) override;
		void Visit(WfNewClassExpression* node) override;
		void Visit(WfNewInterfaceExpression* node) override;
		void Visit(WfVirtualCfeExpression* node) override;
		void Visit(WfVirtualCseExpression* node) override;

		void Visit(WfBreakStatement* node) override;
		void Visit(WfContinueStatement* node) override;
		void Visit(WfReturnStatement* node) override;
		void Visit(WfDeleteStatement* node) override;
		void Visit(WfRaiseExceptionStatement* node) override;
		void Visit(WfIfStatement* node) override;
		void Visit(WfWhileStatement* node) override;
		void Visit(WfTryStatement* node) override;
		void Visit(WfBlockStatement* node) override;
		void Visit(WfGotoStatement* node) override;
		void Visit(WfVariableStatement* node) override;
		void Visit(WfExpressionStatement* node) override;
		void Visit(WfVirtualCseStatement* node) override;
		void Visit(WfCoroutineStatement* node) override;
		void Visit(WfStateMachineStatement* node) override;

		void Visit(WfNamespaceDeclaration* node) override;
		void Visit(WfFunctionDeclaration* node) override;
		void Visit(WfVariableDeclaration* node) override;
		void Visit(WfEventDeclaration* node) override;
		void Visit(WfPropertyDeclaration* node) override;
		void Visit(WfStaticInitDeclaration* node) override;
		void Visit(WfConstructorDeclaration* node) override;
		void Visit(WfDestructorDeclaration* node) override;
		void Visit(WfClassDeclaration* node) override;
		void Visit(WfEnumDeclaration* node) override;
		void Visit(WfStructDeclaration* node) override;
		void Visit(WfVirtualCfeDeclaration* node) override;
		void Visit(WfVirtualCseDeclaration* node) override;

		void Visit(WfAutoPropertyDeclaration* node) override;
		void Visit(WfCastResultInterfaceDeclaration* node) override;

		void Visit(WfStateMachineDeclaration* node) override;

		void Visit(WfForEachStatement* node) override;
		void Visit(WfSwitchStatement* node) override;
		void Visit(WfCoProviderStatement* node) override;

		void Visit(WfCoPauseStatement* node) override;
		void Visit(WfCoOperatorStatement* node) override;

		void Visit(WfStateSwitchStatement* node) override;
		void Visit(WfStateInvokeStatement* node) override;

		void Visit(WfFormatExpression* node) override;

		void Visit(WfBindExpression* node) override;
		void Visit(WfNewCoroutineExpression* node) override;
		void Visit(WfMixinCastExpression* node) override;
		void Visit(WfExpectedTypeCastExpression* node) override;
		void Visit(WfCoOperatorExpression* node) override;

		void Visit(WfModuleUsingNameFragment* node) override;
		void Visit(WfModuleUsingWildCardFragment* node) override;

	public:
		void InspectInto(WfType* node);
		void InspectInto(WfExpression* node);
		void InspectInto(WfStatement* node);
		void InspectInto(WfDeclaration* node);
		void InspectInto(WfModuleUsingFragment* node);
		void InspectInto(WfAttribute* node);
		void InspectInto(WfFunctionArgument* node);
		void InspectInto(WfBaseConstructorCall* node);
		void InspectInto(WfEnumItemIntersection* node);
		void InspectInto(WfEnumItem* node);
		void InspectInto(WfStructMember* node);
		void InspectInto(WfStateInput* node);
		void InspectInto(WfStateDeclaration* node);
		void InspectInto(WfSwitchCase* node);
		void InspectInto(WfStateSwitchArgument* node);
		void InspectInto(WfStateSwitchCase* node);
		void InspectInto(WfLetVariable* node);
		void InspectInto(WfConstructorArgument* node);
		void InspectInto(WfModuleUsingItem* node);
		void InspectInto(WfModuleUsingPath* node);
		void InspectInto(WfModule* node);
	};
}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOW_ASSEMBLER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Workflow
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_AST_ASSEMBLER
#define VCZH_WORKFLOW_PARSER_AST_ASSEMBLER


namespace vl::workflow
{
	enum class WorkflowClasses : vl::vint32_t
	{
		AttachEventExpression = 0,
		Attribute = 1,
		AutoPropertyDeclaration = 2,
		BaseConstructorCall = 3,
		BinaryExpression = 4,
		BindExpression = 5,
		BlockStatement = 6,
		BreakStatement = 7,
		CallExpression = 8,
		CastResultInterfaceDeclaration = 9,
		ChildExpression = 10,
		ChildType = 11,
		ClassDeclaration = 12,
		CoOperatorExpression = 13,
		CoOperatorStatement = 14,
		CoPauseStatement = 15,
		CoProviderStatement = 16,
		ConstructorArgument = 17,
		ConstructorDeclaration = 18,
		ConstructorExpression = 19,
		ContinueStatement = 20,
		CoroutineStatement = 21,
		Declaration = 22,
		DeleteStatement = 23,
		DestructorDeclaration = 24,
		DetachEventExpression = 25,
		EnumDeclaration = 26,
		EnumItem = 27,
		EnumItemIntersection = 28,
		EnumerableType = 29,
		EventDeclaration = 30,
		ExpectedTypeCastExpression = 31,
		Expression = 32,
		ExpressionStatement = 33,
		FloatingExpression = 34,
		ForEachStatement = 35,
		FormatExpression = 36,
		FunctionArgument = 37,
		FunctionDeclaration = 38,
		FunctionExpression = 39,
		FunctionType = 40,
		GotoStatement = 41,
		IfExpression = 42,
		IfStatement = 43,
		InferExpression = 44,
		IntegerExpression = 45,
		LetExpression = 46,
		LetVariable = 47,
		LiteralExpression = 48,
		MapType = 49,
		MemberExpression = 50,
		MixinCastExpression = 51,
		Module = 52,
		ModuleUsingFragment = 53,
		ModuleUsingItem = 54,
		ModuleUsingNameFragment = 55,
		ModuleUsingPath = 56,
		ModuleUsingWildCardFragment = 57,
		NamespaceDeclaration = 58,
		NewClassExpression = 59,
		NewCoroutineExpression = 60,
		NewInterfaceExpression = 61,
		NullableType = 62,
		ObservableListType = 63,
		ObserveExpression = 64,
		OrderedLambdaExpression = 65,
		OrderedNameExpression = 66,
		PredefinedType = 67,
		PropertyDeclaration = 68,
		RaiseExceptionStatement = 69,
		RangeExpression = 70,
		RawPointerType = 71,
		ReferenceExpression = 72,
		ReferenceType = 73,
		ReturnStatement = 74,
		SetTestingExpression = 75,
		SharedPointerType = 76,
		StateDeclaration = 77,
		StateInput = 78,
		StateInvokeStatement = 79,
		StateMachineDeclaration = 80,
		StateMachineStatement = 81,
		StateSwitchArgument = 82,
		StateSwitchCase = 83,
		StateSwitchStatement = 84,
		Statement = 85,
		StaticInitDeclaration = 86,
		StringExpression = 87,
		StructDeclaration = 88,
		StructMember = 89,
		SwitchCase = 90,
		SwitchStatement = 91,
		ThisExpression = 92,
		TopQualifiedExpression = 93,
		TopQualifiedType = 94,
		TryStatement = 95,
		Type = 96,
		TypeCastingExpression = 97,
		TypeOfExpressionExpression = 98,
		TypeOfTypeExpression = 99,
		TypeTestingExpression = 100,
		UnaryExpression = 101,
		VariableDeclaration = 102,
		VariableStatement = 103,
		VirtualCfeDeclaration = 104,
		VirtualCfeExpression = 105,
		VirtualCseDeclaration = 106,
		VirtualCseExpression = 107,
		VirtualCseStatement = 108,
		WhileStatement = 109,
	};

	enum class WorkflowFields : vl::vint32_t
	{
		AttachEventExpression_event = 0,
		AttachEventExpression_function = 1,
		Attribute_category = 2,
		Attribute_name = 3,
		Attribute_value = 4,
		AutoPropertyDeclaration_configConst = 5,
		AutoPropertyDeclaration_configObserve = 6,
		AutoPropertyDeclaration_expression = 7,
		AutoPropertyDeclaration_functionKind = 8,
		AutoPropertyDeclaration_type = 9,
		BaseConstructorCall_arguments = 10,
		BaseConstructorCall_type = 11,
		BinaryExpression_first = 12,
		BinaryExpression_op = 13,
		BinaryExpression_second = 14,
		BindExpression_expression = 15,
		BlockStatement_endLabel = 16,
		BlockStatement_statements = 17,
		CallExpression_arguments = 18,
		CallExpression_function = 19,
		CastResultInterfaceDeclaration_baseType = 20,
		CastResultInterfaceDeclaration_elementType = 21,
		ChildExpression_name = 22,
		ChildExpression_parent = 23,
		ChildType_name = 24,
		ChildType_parent = 25,
		ClassDeclaration_baseTypes = 26,
		ClassDeclaration_constructorType = 27,
		ClassDeclaration_declarations = 28,
		ClassDeclaration_kind = 29,
		CoOperatorExpression_name = 30,
		CoOperatorStatement_arguments = 31,
		CoOperatorStatement_opName = 32,
		CoOperatorStatement_varName = 33,
		CoPauseStatement_statement = 34,
		CoProviderStatement_name = 35,
		CoProviderStatement_statement = 36,
		ConstructorArgument_key = 37,
		ConstructorArgument_value = 38,
		ConstructorDeclaration_arguments = 39,
		ConstructorDeclaration_baseConstructorCalls = 40,
		ConstructorDeclaration_constructorType = 41,
		ConstructorDeclaration_statement = 42,
		ConstructorExpression_arguments = 43,
		Declaration_attributes = 44,
		Declaration_name = 45,
		DeleteStatement_expression = 46,
		DestructorDeclaration_statement = 47,
		DetachEventExpression_event = 48,
		DetachEventExpression_handler = 49,
		EnumDeclaration_items = 50,
		EnumDeclaration_kind = 51,
		EnumItem_attributes = 52,
		EnumItem_intersections = 53,
		EnumItem_kind = 54,
		EnumItem_name = 55,
		EnumItem_number = 56,
		EnumItemIntersection_name = 57,
		EnumerableType_element = 58,
		EventDeclaration_arguments = 59,
		ExpectedTypeCastExpression_expression = 60,
		ExpectedTypeCastExpression_strategy = 61,
		ExpressionStatement_expression = 62,
		FloatingExpression_value = 63,
		ForEachStatement_collection = 64,
		ForEachStatement_direction = 65,
		ForEachStatement_name = 66,
		ForEachStatement_statement = 67,
		FormatExpression_value = 68,
		FunctionArgument_attributes = 69,
		FunctionArgument_name = 70,
		FunctionArgument_type = 71,
		FunctionDeclaration_anonymity = 72,
		FunctionDeclaration_arguments = 73,
		FunctionDeclaration_functionKind = 74,
		FunctionDeclaration_returnType = 75,
		FunctionDeclaration_statement = 76,
		FunctionExpression_function = 77,
		FunctionType_arguments = 78,
		FunctionType_result = 79,
		GotoStatement_label = 80,
		IfExpression_condition = 81,
		IfExpression_falseBranch = 82,
		IfExpression_trueBranch = 83,
		IfStatement_expression = 84,
		IfStatement_falseBranch = 85,
		IfStatement_name = 86,
		IfStatement_trueBranch = 87,
		IfStatement_type = 88,
		InferExpression_expression = 89,
		InferExpression_type = 90,
		IntegerExpression_value = 91,
		LetExpression_expression = 92,
		LetExpression_variables = 93,
		LetVariable_name = 94,
		LetVariable_value = 95,
		LiteralExpression_value = 96,
		MapType_key = 97,
		MapType_value = 98,
		MapType_writability = 99,
		MemberExpression_name = 100,
		MemberExpression_parent = 101,
		MixinCastExpression_expression = 102,
		MixinCastExpression_type = 103,
		Module_declarations = 104,
		Module_moduleType = 105,
		Module_name = 106,
		Module_paths = 107,
		ModuleUsingItem_fragments = 108,
		ModuleUsingNameFragment_name = 109,
		ModuleUsingPath_items = 110,
		NamespaceDeclaration_declarations = 111,
		NewClassExpression_arguments = 112,
		NewClassExpression_type = 113,
		NewCoroutineExpression_name = 114,
		NewCoroutineExpression_statement = 115,
		NewInterfaceExpression_declarations = 116,
		NewInterfaceExpression_type = 117,
		NullableType_element = 118,
		ObservableListType_element = 119,
		ObserveExpression_events = 120,
		ObserveExpression_expression = 121,
		ObserveExpression_name = 122,
		ObserveExpression_observeType = 123,
		ObserveExpression_parent = 124,
		OrderedLambdaExpression_body = 125,
		OrderedNameExpression_name = 126,
		PredefinedType_name = 127,
		PropertyDeclaration_getter = 128,
		PropertyDeclaration_setter = 129,
		PropertyDeclaration_type = 130,
		PropertyDeclaration_valueChangedEvent = 131,
		RaiseExceptionStatement_expression = 132,
		RangeExpression_begin = 133,
		RangeExpression_beginBoundary = 134,
		RangeExpression_end = 135,
		RangeExpression_endBoundary = 136,
		RawPointerType_element = 137,
		ReferenceExpression_name = 138,
		ReferenceType_name = 139,
		ReturnStatement_expression = 140,
		SetTestingExpression_collection = 141,
		SetTestingExpression_element = 142,
		SetTestingExpression_test = 143,
		SharedPointerType_element = 144,
		StateDeclaration_arguments = 145,
		StateDeclaration_name = 146,
		StateDeclaration_statement = 147,
		StateInput_arguments = 148,
		StateInput_name = 149,
		StateInvokeStatement_arguments = 150,
		StateInvokeStatement_name = 151,
		StateInvokeStatement_type = 152,
		StateMachineDeclaration_inputs = 153,
		StateMachineDeclaration_states = 154,
		StateSwitchArgument_name = 155,
		StateSwitchCase_arguments = 156,
		StateSwitchCase_name = 157,
		StateSwitchCase_statement = 158,
		StateSwitchStatement_caseBranches = 159,
		StateSwitchStatement_type = 160,
		StaticInitDeclaration_statement = 161,
		StringExpression_value = 162,
		StructDeclaration_members = 163,
		StructMember_attributes = 164,
		StructMember_name = 165,
		StructMember_type = 166,
		SwitchCase_expression = 167,
		SwitchCase_statement = 168,
		SwitchStatement_caseBranches = 169,
		SwitchStatement_defaultBranch = 170,
		SwitchStatement_expression = 171,
		TopQualifiedExpression_name = 172,
		TopQualifiedType_name = 173,
		TryStatement_catchStatement = 174,
		TryStatement_finallyStatement = 175,
		TryStatement_name = 176,
		TryStatement_protectedStatement = 177,
		TypeCastingExpression_expression = 178,
		TypeCastingExpression_strategy = 179,
		TypeCastingExpression_type = 180,
		TypeOfExpressionExpression_expression = 181,
		TypeOfTypeExpression_type = 182,
		TypeTestingExpression_expression = 183,
		TypeTestingExpression_test = 184,
		TypeTestingExpression_type = 185,
		UnaryExpression_op = 186,
		UnaryExpression_operand = 187,
		VariableDeclaration_expression = 188,
		VariableDeclaration_type = 189,
		VariableStatement_variable = 190,
		VirtualCfeDeclaration_expandedDeclarations = 191,
		VirtualCfeExpression_expandedExpression = 192,
		VirtualCseDeclaration_expandedDeclarations = 193,
		VirtualCseExpression_expandedExpression = 194,
		VirtualCseStatement_expandedStatement = 195,
		WhileStatement_condition = 196,
		WhileStatement_statement = 197,
	};

	extern const wchar_t* WorkflowTypeName(WorkflowClasses type);
	extern const wchar_t* WorkflowCppTypeName(WorkflowClasses type);
	extern const wchar_t* WorkflowFieldName(WorkflowFields field);
	extern const wchar_t* WorkflowCppFieldName(WorkflowFields field);

	class WorkflowAstInsReceiver : public vl::glr::AstInsReceiverBase
	{
	protected:
		vl::Ptr<vl::glr::ParsingAstBase> CreateAstNode(vl::vint32_t type) override;
		void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::Ptr<vl::glr::ParsingAstBase> value) override;
		void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, const vl::regex::RegexToken& token, vl::vint32_t tokenIndex) override;
		void SetField(vl::glr::ParsingAstBase* object, vl::vint32_t field, vl::vint32_t enumItem, bool weakAssignment) override;
		vl::Ptr<vl::glr::ParsingAstBase> ResolveAmbiguity(vl::vint32_t type, vl::collections::Array<vl::Ptr<vl::glr::ParsingAstBase>>& candidates) override;
	};
}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOW_LEXER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Workflow
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_LEXER
#define VCZH_WORKFLOW_PARSER_LEXER


namespace vl::workflow
{
	enum class WorkflowTokens : vl::vint32_t
	{
		EXP = 0,
		ADD = 1,
		SUB = 2,
		MUL = 3,
		DIV = 4,
		MOD = 5,
		JOIN = 6,
		INTERSECTION = 7,
		LE = 8,
		GE = 9,
		LT = 10,
		GT = 11,
		EQ = 12,
		NE = 13,
		ASSIGN = 14,
		FAILED_THEN = 15,
		QUESTION_MARK = 16,
		SCOPE_DELIMITER = 17,
		COLON = 18,
		SEMICOLON = 19,
		COMMA = 20,
		DOT = 21,
		OPEN_ARRAY = 22,
		CLOSE_ARRAY = 23,
		OPEN_BRACE = 24,
		CLOSE_BRACE = 25,
		OPEN_BRACKET = 26,
		CLOSE_BRACKET = 27,
		AT = 28,
		TYPE_VOID = 29,
		TYPE_OBJECT = 30,
		TYPE_INTERFACE = 31,
		TYPE_INT = 32,
		TYPE_UINT = 33,
		TYPE_FLOAT = 34,
		TYPE_DOUBLE = 35,
		TYPE_STRING = 36,
		TYPE_CHAR = 37,
		TYPE_BOOL = 38,
		KEYWORD_CONST = 39,
		KEYWORD_SHL = 40,
		KEYWORD_SHR = 41,
		KEYWORD_XOR = 42,
		KEYWORD_AND = 43,
		KEYWORD_OR = 44,
		KEYWORD_NOT = 45,
		KEYWORD_NULL = 46,
		KEYWORD_THIS = 47,
		KEYWORD_TRUE = 48,
		KEYWORD_FALSE = 49,
		KEYWORD_LET = 50,
		KEYWORD_IN = 51,
		KEYWORD_RANGE = 52,
		KEYWORD_NEW = 53,
		KEYWORD_OF = 54,
		KEYWORD_AS = 55,
		KEYWORD_IS = 56,
		KEYWORD_CAST = 57,
		KEYWORD_FUNC = 58,
		KEYWORD_TYPEOF = 59,
		KEYWORD_TYPE = 60,
		KEYWORD_BIND = 61,
		KEYWORD_OBSERVE = 62,
		KEYWORD_ON = 63,
		KEYWORD_ATTACH = 64,
		KEYWORD_DETACH = 65,
		KEYWORD_GOTO = 66,
		KEYWORD_VAR = 67,
		KEYWORD_BREAK = 68,
		KEYWORD_CONTINUE = 69,
		KEYWORD_RETURN = 70,
		KEYWORD_DELETE = 71,
		KEYWORD_RAISE = 72,
		KEYWORD_IF = 73,
		KEYWORD_ELSE = 74,
		KEYWORD_SWITCH = 75,
		KEYWORD_CASE = 76,
		KEYWORD_DEFAULT = 77,
		KEYWORD_WHILE = 78,
		KEYWORD_FOR = 79,
		KEYWORD_REVERSED = 80,
		KEYWORD_TRY = 81,
		KEYWORD_CATCH = 82,
		KEYWORD_FINALLY = 83,
		KEYWORD_CLASS = 84,
		KEYWORD_ENUM = 85,
		KEYWORD_FLAGENUM = 86,
		KEYWORD_STRUCT = 87,
		KEYWORD_PROP = 88,
		KEYWORD_EVENT = 89,
		KEYWORD_STATIC = 90,
		KEYWORD_OVERRIDE = 91,
		KEYWORD_USING = 92,
		KEYWORD_NAMESPACE = 93,
		KEYWORD_MODULE = 94,
		KEYWORD_UNIT = 95,
		STATE_MACHINE = 96,
		STATE_INPUT = 97,
		STATE_SWITCH = 98,
		STATE_GOTO = 99,
		STATE_PUSH = 100,
		STATE_DECL = 101,
		COROUTINE_COROUTINE = 102,
		COROUTINE_PAUSE = 103,
		COROUTINE_INTERFACE = 104,
		COROUTINE_OPERATOR = 105,
		COROUTINE_SIGN = 106,
		NAME = 107,
		ORDERED_NAME = 108,
		FLOAT = 109,
		INTEGER = 110,
		STRING = 111,
		FORMATSTRING = 112,
		SPACE = 113,
		COMMENT = 114,
	};

	constexpr vl::vint WorkflowTokenCount = 115;
	extern bool WorkflowTokenDeleter(vl::vint token);
	extern const wchar_t* WorkflowTokenId(WorkflowTokens token);
	extern const wchar_t* WorkflowTokenDisplayText(WorkflowTokens token);
	extern const wchar_t* WorkflowTokenRegex(WorkflowTokens token);
	extern void WorkflowLexerData(vl::stream::IStream& outputStream);
}
#endif

/***********************************************************************
.\PARSER\GENERATED\WORKFLOWPARSER.H
***********************************************************************/
/***********************************************************************
This file is generated by: Vczh Parser Generator
From parser definition:Workflow
Licensed under https://github.com/vczh-libraries/License
***********************************************************************/

#ifndef VCZH_WORKFLOW_PARSER_PARSER_SYNTAX
#define VCZH_WORKFLOW_PARSER_PARSER_SYNTAX


namespace vl::workflow
{
	enum class ParserStates
	{
		_Type = 0,
		_CtorFragment = 50,
		_LetVariable = 55,
		_VirtualExpression = 60,
		_BeginBoundary = 81,
		_EndBoundary = 85,
		_SetTestingOperator = 89,
		_ExpPrimitive = 94,
		_Exp0 = 231,
		_Exp1 = 246,
		_Exp2 = 252,
		_Exp3 = 264,
		_Exp4 = 279,
		_Exp5 = 288,
		_Exp6 = 309,
		_Exp7 = 315,
		_Exp8 = 321,
		_Exp9 = 327,
		_Exp10 = 333,
		_Exp11 = 341,
		_Expression = 347,
		_SwitchCase = 350,
		_Block = 356,
		_ElseStat = 364,
		_If = 368,
		_ForOperator = 382,
		_VirtualStatement = 387,
		_CoStatement = 406,
		_CoProvider = 418,
		_StateSwitchHead = 423,
		_StateSwitchArgument = 446,
		_StateSwitchCase = 449,
		_StateStatement = 460,
		_Statement = 480,
		_StateInput = 520,
		_StateDecl = 529,
		_StateMachine = 539,
		_Attribute = 546,
		_Namespace = 555,
		_FunctionArgument = 562,
		_FunctionArgumentList = 568,
		_FunctionStat = 574,
		_FunctionBody = 578,
		_FunctionKind = 588,
		_Function = 595,
		_Variable = 602,
		_Event = 611,
		_Property = 620,
		_StaticInit = 633,
		_BaseConstructorCall = 637,
		_ConstructorType = 645,
		_Constructor = 650,
		_Destructor = 661,
		_ClassBody = 665,
		_Class = 674,
		_EnumItemInt = 686,
		_EnumItemA = 689,
		_EnumItemB = 696,
		_Enum = 705,
		_StructMember = 720,
		_Struct = 727,
		_APConfig = 734,
		_AutoPropertyKind = 751,
		_AutoProperty = 758,
		_CastResultInterface = 767,
		_DeclarationCandidates = 777,
		_Declaration = 792,
		_UsingFragment = 796,
		_UsingItem = 800,
		_UsingPath = 804,
		_ModuleBody = 811,
		_Module = 817,
	};

	const wchar_t* ParserRuleName(vl::vint index);
	const wchar_t* ParserStateLabel(vl::vint index);
	extern void WorkflowParserData(vl::stream::IStream& outputStream);

	class Parser
		: public vl::glr::ParserBase<WorkflowTokens, ParserStates, WorkflowAstInsReceiver>
		, protected vl::glr::automaton::IExecutor::ITypeCallback
	{
	protected:
		vl::WString GetClassName(vl::vint32_t classIndex) const override;
		vl::vint32_t FindCommonBaseClass(vl::vint32_t class1, vl::vint32_t class2) const override;
	public:
		Parser();

		vl::Ptr<vl::workflow::WfType> Parse_Type(const vl::WString& input, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfType> Parse_Type(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfExpression> Parse_Expression(const vl::WString& input, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfExpression> Parse_Expression(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfCoProviderStatement> Parse_CoProvider(const vl::WString& input, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfCoProviderStatement> Parse_CoProvider(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfStatement> Parse_Statement(const vl::WString& input, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfStatement> Parse_Statement(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfDeclaration> Parse_Declaration(const vl::WString& input, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfDeclaration> Parse_Declaration(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfModule> Parse_Module(const vl::WString& input, vl::vint codeIndex = -1) const;
		vl::Ptr<vl::workflow::WfModule> Parse_Module(vl::collections::List<vl::regex::RegexToken>& tokens, vl::vint codeIndex = -1) const;
	};
}
#endif

/***********************************************************************
.\PARSER\WFEXPRESSION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression

Interfaces:
***********************************************************************/

#ifdef VCZH_DEBUG_NO_REFLECTION
static_assert(false, "Don't use VlppWorkflow.(h|cpp) or VlppWorkflowCompiler.(h|cpp) if VCZH_DEBUG_NO_REFLECTION is defined.");
#endif

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSION
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSION


namespace vl
{
	namespace workflow
	{
		
/***********************************************************************
Parsing
***********************************************************************/

		extern Ptr<WfType>					ParseType(const WString& input, const Parser& parser, vint codeIndex = -1);
		extern Ptr<WfExpression>			ParseExpression(const WString& input, const Parser& parser, vint codeIndex = -1);
		extern Ptr<WfStatement>				ParseStatement(const WString& input, const Parser& parser, vint codeIndex = -1);
		extern Ptr<WfCoProviderStatement>	ParseCoProviderStatement(const WString& input, const Parser& parser, vint codeIndex = -1);
		extern Ptr<WfDeclaration>			ParseDeclaration(const WString& input, const Parser& parser, vint codeIndex = -1);
		extern Ptr<WfModule>				ParseModule(const WString& input, const Parser& parser, vint codeIndex = -1);
		
/***********************************************************************
Print to ParsingWriter
***********************************************************************/

		/// <summary>Print a Workflow attribute.</summary>
		/// <param name="node">The Workflow attribute.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfAttribute> node, const WString& indent, glr::ParsingWriter& writer);
		/// <summary>Print a Workflow type.</summary>
		/// <param name="node">The Workflow type.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfType> node, const WString& indent, glr::ParsingWriter& writer);
		/// <summary>Print a Workflow expression.</summary>
		/// <param name="node">The Workflow expression.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfExpression> node, const WString& indent, glr::ParsingWriter& writer);
		/// <summary>Print a Workflow statement.</summary>
		/// <param name="node">The Workflow statement.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfStatement> node, const WString& indent, glr::ParsingWriter& writer);
		/// <summary>Print a Workflow declaration.</summary>
		/// <param name="node">The Workflow declaration.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfDeclaration> node, const WString& indent, glr::ParsingWriter& writer);
		/// <summary>Print a Workflow module.</summary>
		/// <param name="node">The Workflow module.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfModule> node, const WString& indent, glr::ParsingWriter& writer);
		
/***********************************************************************
Print to TextWriter
***********************************************************************/

		/// <summary>Print a Workflow attribute.</summary>
		/// <param name="node">The Workflow attribute.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfAttribute> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow type.</summary>
		/// <param name="node">The Workflow type.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfType> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow expression.</summary>
		/// <param name="node">The Workflow expression.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfExpression> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow statement.</summary>
		/// <param name="node">The Workflow statement.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfStatement> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow declaration.</summary>
		/// <param name="node">The Workflow declaration.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfDeclaration> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow module.</summary>
		/// <param name="node">The Workflow module.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfModule> node, const WString& indent, stream::TextWriter& writer);
	}
}
#endif

/***********************************************************************
.\ANALYZER\WFANALYZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Analyzer

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_ANALYZER_WFANALYZER
#define VCZH_WORKFLOW_ANALYZER_WFANALYZER


namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			class WfLexicalSymbol;
			class WfLexicalScope;
			class WfLexicalScopeManager;
		}

/***********************************************************************
Callback
***********************************************************************/

		/// <summary>A callback for tracking compiling progress. This is used in <see cref="analyzer::WfLexicalScopeManager::Rebuild"/> and <see cref="emitter::GenerateAssembly"/>.</summary>
		class IWfCompilerCallback : public Interface
		{
		public:
			/// <summary>1st step: Called before loading global type information.</summary>
			virtual void								OnLoadEnvironment() = 0;

			/// <summary>2nd step: Called before compiling.</summary>
			/// <param name="manager">The scope manager object for storing all information generated from Workflow modules during compiling.</param>
			virtual void								OnInitialize(analyzer::WfLexicalScopeManager* manager) = 0;

			/// <summary>3rd step: Called before validating a Workflow module. This could be called multiple times for each module.</summary>
			/// <param name="module">The module for validating.</param>
			virtual void								OnValidateModule(Ptr<WfModule> module) = 0;

			/// <summary>4th step: Called before generating metadata for functions and types created by given Workflow modules.</summary>
			virtual void								OnGenerateMetadata() = 0;

			/// <summary>5th step: Called before generating instructions for a Workflow module. This could be called multiple times for each module.</summary>
			/// <param name="module">The module for generating code.</param>
			virtual void								OnGenerateCode(Ptr<WfModule> module) = 0;

			/// <summary>6th step: Called before generating debug information.</summary>
			virtual void								OnGenerateDebugInfo() = 0;
		};

		namespace analyzer
		{
/***********************************************************************
Scope
***********************************************************************/

			class WfLexicalSymbol : public Object
			{
			public:
				WString										name;				// name of this symbol
				Ptr<WfType>									type;				// type of this symbol
				Ptr<reflection::description::ITypeInfo>		typeInfo;			// reflection type info of this symbol, nullable
				Ptr<glr::ParsingAstBase>					creatorNode;		// nullable
				WfLexicalScope*								ownerScope;			// scope that contains this symbol

				WfLexicalSymbol(WfLexicalScope* _ownerScope);
				~WfLexicalSymbol();
				
				WString										GetFriendlyName();
			};

			class WfLexicalFunctionConfig : public Object
			{
			public:
				bool										lambda = false;
				bool										thisAccessable = false;
				bool										parentThisAccessable = false;
			};

			class WfLexicalScope : public Object
			{
				typedef collections::Group<WString, Ptr<WfLexicalSymbol>>		TypeGroup;
			public:
				WfLexicalScopeManager*						ownerManager;				// nullable
				Ptr<glr::ParsingAstBase>					ownerNode;					// nullable
				glr::ParsingAstBase*						ownerNodeSource = nullptr;	// nullable

				Ptr<WfLexicalFunctionConfig>				functionConfig;
				reflection::description::ITypeDescriptor*	typeOfThisExpr = nullptr;	// visible members to this scope

				Ptr<WfLexicalScope>							parentScope;				// null means that this is the root scope
				TypeGroup									symbols;					// all symbols in this scope

				WfLexicalScope(WfLexicalScopeManager* _ownerManager);
				WfLexicalScope(Ptr<WfLexicalScope> _parentScope);
				~WfLexicalScope();

				WfLexicalScopeManager*						FindManager();
				Ptr<WfModule>								FindModule();
				WfLexicalScope*								FindFunctionScope();
				WString										GetFriendlyName();
			};

/***********************************************************************
Scope Manager
***********************************************************************/

			class WfLexicalScopeName : public Object
			{
				typedef collections::Dictionary<WString, Ptr<WfLexicalScopeName>>		NameMap;
				typedef collections::List<Ptr<WfDeclaration>>							DeclarationList;
			public:
				WfLexicalScopeName*							parent = nullptr;
				bool										imported = true;
				NameMap										children;
				WString										name;
				reflection::description::ITypeDescriptor*	typeDescriptor = nullptr;	// type that form this name
				DeclarationList								declarations;				// declarations that form this name

				WfLexicalScopeName(bool _imported);
				~WfLexicalScopeName();

				Ptr<WfLexicalScopeName>						AccessChild(const WString& name, bool imported);
				void										RemoveNonTypeDescriptorNames(WfLexicalScopeManager* manager);
				WString										GetFriendlyName();
			};

			struct ResolveExpressionResult
			{
				Ptr<WfLexicalScopeName>						scopeName;
				Ptr<WfLexicalSymbol>						symbol;
				reflection::description::IPropertyInfo*		propertyInfo = nullptr;
				reflection::description::IMethodInfo*		methodInfo = nullptr;
				reflection::description::IMethodInfo*		constructorInfo = nullptr;
				reflection::description::IEventInfo*		eventInfo = nullptr;
				Ptr<reflection::description::ITypeInfo>		type;
				Ptr<reflection::description::ITypeInfo>		writableType;
				Ptr<reflection::description::ITypeInfo>		expectedType;

				WString										GetFriendlyName(bool upperCase = false)const;

				static ResolveExpressionResult				ScopeName(Ptr<WfLexicalScopeName> _scopeName);
				static ResolveExpressionResult				ReadonlySymbol(Ptr<WfLexicalSymbol> _symbol);
				static ResolveExpressionResult				Symbol(Ptr<WfLexicalSymbol> _symbol);
				static ResolveExpressionResult				ReadonlyType(Ptr<reflection::description::ITypeInfo> _type);
				static ResolveExpressionResult				WritableType(Ptr<reflection::description::ITypeInfo> _type);
				static ResolveExpressionResult				Property(reflection::description::IPropertyInfo* _propertyInfo);
				static ResolveExpressionResult				Method(reflection::description::IMethodInfo* _methodInfo);
				static ResolveExpressionResult				Constructor(reflection::description::IMethodInfo* _constructorInfo);
				static ResolveExpressionResult				Event(reflection::description::IEventInfo* _eventInfo);

				bool										operator==(const ResolveExpressionResult& result) const;
				bool										operator!=(const ResolveExpressionResult& result) const;
			};

			struct WfLexicalCapture
			{
				collections::List<Ptr<WfLexicalSymbol>>		symbols;
				collections::List<Ptr<WfLexicalSymbol>>		ctorArgumentSymbols;
			};

			struct WfStateMachineInfo
			{
				Ptr<typeimpl::WfClassMethod>				createCoroutineMethod;
				collections::Dictionary<WString, vint>		inputIds;
				collections::Dictionary<WString, vint>		stateIds;
			};

			/// <summary>
			/// CPU architecture
			/// </summary>
			enum class WfCpuArchitecture
			{
				x86,
				x64,
				AsExecutable,
			};

			/// <summary>Scope manager for storing all information generated from Workflow modules during compiling.</summary>
			class WfLexicalScopeManager : public Object
			{
				typedef reflection::description::ITypeDescriptor											ITypeDescriptor;
				typedef reflection::description::IMemberInfo												IMemberInfo;
				typedef reflection::description::IMethodInfo												IMethodInfo;
				typedef reflection::description::ITypeInfo													ITypeInfo;
				typedef reflection::description::Value														Value;

				typedef collections::List<Ptr<WfModule>>													ModuleList;
				typedef collections::List<WString>															ModuleCodeList;
				typedef collections::Pair<WString, WString>													AttributeKey;
				typedef collections::Dictionary<AttributeKey, Ptr<ITypeInfo>>								AttributeTypeMap;

				typedef collections::Dictionary<ITypeDescriptor*, Ptr<WfLexicalScopeName>>					TypeNameMap;

				typedef collections::List<glr::ParsingError>												ParsingErrorList;
				typedef collections::Dictionary<Ptr<WfNamespaceDeclaration>, Ptr<WfLexicalScopeName>>		NamespaceNameMap;
				typedef collections::Dictionary<glr::ParsingAstBase*, Ptr<WfLexicalScope>>					NodeScopeMap;
				typedef collections::SortedList<WfLexicalScope*>											AnalyzedScopeList;

				typedef collections::Dictionary<Ptr<WfExpression>, ResolveExpressionResult>					ExpressionResolvingMap;
				typedef collections::Dictionary<Ptr<WfStatement>, ResolveExpressionResult>					CoOperatorResolvingMap;
				typedef collections::Pair<WfConstructorDeclaration*, ITypeDescriptor*>						BaseConstructorCallKey;
				typedef collections::Pair<WfBaseConstructorCall*, IMethodInfo*>								BaseConstructorCallValue;
				typedef collections::Dictionary<BaseConstructorCallKey, BaseConstructorCallValue>			BaseConstructorCallResolvingMap;

				typedef collections::Dictionary<glr::ParsingAstBase*, Ptr<WfLexicalCapture>>				LambdaCaptureMap;
				typedef collections::Dictionary<WfFunctionDeclaration*, IMethodInfo*>						InterfaceMethodImplementationMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, glr::ParsingAstBase*>					DeclarationSourceMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, Ptr<ITypeDescriptor>>					DeclarationTypeMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, Ptr<IMemberInfo>>						DeclarationMemberInfoMap;

				typedef collections::Dictionary<Ptr<WfStateInput>, Ptr<typeimpl::WfClassMethod>>			StateInputMethodMap;
				typedef collections::Dictionary<Ptr<WfFunctionArgument>, Ptr<typeimpl::WfField>>			StateArgumentFieldMap;
				typedef collections::Dictionary<Ptr<WfStateMachineDeclaration>, Ptr<WfStateMachineInfo>>	StateMachineInfoMap;

			protected:
				ModuleList									modules;
				ModuleCodeList								moduleCodes;
				vint										usedCodeIndex = 0;

			public:
				WfCpuArchitecture							cpuArchitecture = WfCpuArchitecture::AsExecutable;
				ITypeDescriptor*							cputdSInt = nullptr;
				ITypeDescriptor*							cputdUInt = nullptr;
				Ptr<ITypeInfo>								cputiSInt;
				Ptr<ITypeInfo>								cputiUInt;

				workflow::Parser&							workflowParser;
				Ptr<EventHandler>							workflowParserHandler;
				AttributeTypeMap							attributes;

				Ptr<WfLexicalScopeName>						globalName;							// root scope
				TypeNameMap									typeNames;							// ITypeDescriptor* to scope name map

				vint										usedTempVars = 0;
				ParsingErrorList							errors;								// compile errors
				NamespaceNameMap							namespaceNames;						// namespace to scope name map
				NodeScopeMap								nodeScopes;							// the nearest scope for a AST
				AnalyzedScopeList							checkedScopes_DuplicatedSymbol;		// scopes that validated by CheckScopes_DuplicatedSymbol
				AnalyzedScopeList							checkedScopes_SymbolType;			// scopes that validated by CheckScopes_SymbolType

				ExpressionResolvingMap						expressionResolvings;				// the resolving result for the expression
				ExpressionResolvingMap						coNewCoroutineResolvings;			// the coroutine type for the WfNewCoroutineExpression (e.g. AsyncCoroutine)
				CoOperatorResolvingMap						coOperatorResolvings;				// the method for the co-operator statement (e.g. AwaitAndRead)
				CoOperatorResolvingMap						coProviderResolvings;				// the constructor for the co-provider statement (e.g. AsyncCoroutine::Create)
				CoOperatorResolvingMap						coCastResultResolvings;				// the method for the co-operator's type casting (e.g. IStringAsync::CastResult)
				BaseConstructorCallResolvingMap				baseConstructorCallResolvings;		// all base constructor call resolvings

				LambdaCaptureMap							lambdaCaptures;						// all captured symbols in a lambda AST
				InterfaceMethodImplementationMap			interfaceMethodImpls;				// the IMethodInfo* that implemented by a function
				DeclarationSourceMap						declaractionScopeSources;			// the source used to build the scope for a declaration
				DeclarationTypeMap							declarationTypes;					// ITypeDescriptor* for type declaration
				DeclarationMemberInfoMap					declarationMemberInfos;				// IMemberInfo* for type description
				StateInputMethodMap							stateInputMethods;					// IMethodInfo* for state input
				StateArgumentFieldMap						stateInputArguments;				// IPropertyInfo* for state input argument temporary cache
				StateArgumentFieldMap						stateDeclArguments;					// IPropertyInfo* for state argument temporary cache
				StateMachineInfoMap							stateMachineInfos;					// members of state machine

				/// <summary>Create a Workflow compiler.</summary>
				/// <param name="_parsingTable">The workflow parser table. It can be retrived from [M:vl.workflow.WfLoadTable].</param>
				/// <param name="_cpuArchitecture">The target CPU architecture.</param>
				WfLexicalScopeManager(workflow::Parser& _workflowParser, WfCpuArchitecture _cpuArchitecture);
				~WfLexicalScopeManager();
				
				/// <summary>Add a Workflow module. Syntax errors can be found at <see cref="errors"/>.</summary>
				/// <param name="moduleCode">The source code of a workflow module.</param>
				/// <returns>Returns the code index, which is a number representing a module in data structured used in Workflow compiler, runtime and debugger.</returns>
				vint										AddModule(const WString& moduleCode);
				/// <summary>Add a parsed Workflow module.</summary>
				/// <param name="module">The syntax tree of a workflow module.</param>
				/// <returns>Returns the code index, which is a number representing a module in data structured used in Workflow compiler, runtime and debugger.</returns>
				vint										AddModule(Ptr<WfModule> module);
				/// <summary>Get all added modules in adding order.</summary>
				/// <returns>All added modules in adding order.</returns>
				ModuleList&									GetModules();
				/// <summary>Get all module codes in adding order. For any added parsed module, the code is an empty string.</summary>
				/// <returns>All module codes in adding order.</returns>
				ModuleCodeList&								GetModuleCodes();

				/// <summary>Clean all generated information from the last called to <see cref="Rebuild"/>.</summary>
				/// <param name="keepTypeDescriptorNames">
				/// Set to true so that only scopes for types in Workflow modules are deleted.
				/// Set to false to also delete scopes for cached global types.
				/// If there is no new reflectable native type that is registered after the last call to <see cref="Rebuild"/>,
				/// using true for this argument saves times by reusing scopes created from global types.
				/// </param>
				/// <param name="deleteModules">Set to true to delete all added modules.</param>
				void										Clear(bool keepTypeDescriptorNames, bool deleteModules);
				/// <summary>Perform semantic analyzing for added modules.</summary>
				/// <param name="keepTypeDescriptorNames">The same to the argument in <see cref="Clear"/>.</param>
				/// <param name="callback">The callback to receive progress information (optional).</param>
				void										Rebuild(bool keepTypeDescriptorNames, IWfCompilerCallback* callback = nullptr);

				bool										ResolveMember(ITypeDescriptor* typeDescriptor, const WString& name, bool preferStatic, collections::SortedList<ITypeDescriptor*>& searchedTypes, collections::List<ResolveExpressionResult>& results);
				bool										ResolveName(WfLexicalScope* scope, const WString& name, collections::List<ResolveExpressionResult>& results);
				Ptr<WfLexicalSymbol>						GetDeclarationSymbol(WfLexicalScope* scope, WfDeclaration* node);
				void										CreateLambdaCapture(glr::ParsingAstBase* node, Ptr<WfLexicalCapture> capture = nullptr);
			};

/***********************************************************************
Type Analyzing
***********************************************************************/

			enum class TypeFlag
			{
				Bool,
				I1,
				I2,
				I4,
				I8,
				U1,
				U2,
				U4,
				U8,
				F4,
				F8,
				String,
				Enum,
				Struct,
				Others,
				Count,
				Unknown = -1,
			};

			extern TypeFlag									GetTypeFlag(reflection::description::ITypeDescriptor* typeDescriptor);
			extern TypeFlag									GetTypeFlag(reflection::description::ITypeInfo* typeInfo);
			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromTypeFlag(TypeFlag flag);

			extern void										GetTypeFragments(reflection::description::ITypeDescriptor* typeDescriptor, collections::List<WString>& fragments);
			extern Ptr<WfExpression>						GetExpressionFromTypeDescriptor(reflection::description::ITypeDescriptor* typeDescriptor);
			extern Ptr<WfType>								GetTypeFromTypeInfo(reflection::description::ITypeInfo* typeInfo);
			extern Ptr<WfLexicalScopeName>					GetScopeNameFromReferenceType(WfLexicalScope* scope, Ptr<WfType> type);
			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromType(WfLexicalScope* scope, Ptr<WfType> type, bool checkTypeForValue = true);

			extern Ptr<reflection::description::ITypeInfo>	CopyTypeInfo(reflection::description::ITypeInfo* typeInfo);
			extern bool										CanConvertToType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, bool explicitly);
			extern bool										IsSameType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
			extern Ptr<reflection::description::ITypeInfo>	GetMergedType(Ptr<reflection::description::ITypeInfo> firstType, Ptr<reflection::description::ITypeInfo> secondType);
			extern bool										IsNullAcceptableType(reflection::description::ITypeInfo* type);

			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromMethodInfo(reflection::description::IMethodInfo* info);

			extern bool										IsExpressionDependOnExpectedType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, bool hasExpectedType);
			extern WString									GetExpressionName(WfExpression* expression);
			extern WString									GetExpressionName(Ptr<WfExpression> expression);
			extern void										SearchOrderedName(WfLexicalScope* scope, WfExpression* expression, collections::SortedList<vint>& names);
			extern void										SearchOrderedName(WfLexicalScope* scope, Ptr<WfExpression> expression, collections::SortedList<vint>& names);

/***********************************************************************
Structure Analyzing
***********************************************************************/
			
			struct ValidateStructureContext
			{
				WfBindExpression*							currentBindExpression = nullptr;
				WfObserveExpression*						currentObserveExpression = nullptr;
				WfStatement*								currentLoopStatement = nullptr;
				WfStatement*								currentCatchStatement = nullptr;
				WfCoProviderStatement*						currentCoProviderStatement = nullptr;
				WfNewCoroutineExpression*					currentNewCoroutineExpression = nullptr;
				WfCoPauseStatement*							currentCoPauseStatement = nullptr;
				WfStateDeclaration*							currentStateDeclaration = nullptr;

				ValidateStructureContext();
			};

			enum class ValidateTypeStragety
			{
				Value,
				ReturnType,
				BaseType,
			};

			extern void										SetCodeRange(Ptr<WfType> node, glr::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfExpression> node, glr::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfStatement> node, glr::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfDeclaration> node, glr::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfModule> node, glr::ParsingTextRange codeRange, bool asOffset = false);

			extern void										ContextFreeModuleDesugar(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ContextFreeDeclarationDesugar(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration);
			extern void										ContextFreeStatementDesugar(WfLexicalScopeManager* manager, Ptr<WfStatement> statement);
			extern void										ContextFreeExpressionDesugar(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);

			extern void										ValidateTypeStructure(WfLexicalScopeManager* manager, Ptr<WfType> type, ValidateTypeStragety strategy = ValidateTypeStragety::Value, WfClassDeclaration* classDecl = nullptr);
			extern void										ValidateModuleStructure(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ValidateDeclarationStructure(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration, WfClassDeclaration* classDecl = nullptr , WfExpression* surroundingLambda = nullptr);
			extern void										ValidateStatementStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfStatement>& statement);
			extern void										ValidateExpressionStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfExpression>& expression);

/***********************************************************************
Global Name
***********************************************************************/

			extern void										BuildGlobalNameFromTypeDescriptors(WfLexicalScopeManager* manager);
			extern void										BuildNameForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name, Ptr<WfDeclaration> decl);
			extern void										BuildGlobalNameFromModules(WfLexicalScopeManager* manager);
			extern void										ValidateScopeName(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name);

/***********************************************************************
Scope Analyzing
***********************************************************************/
			
			extern void										CompleteScopeForClassMember(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, Ptr<WfDeclaration> memberDecl);
			extern void										CompleteScopeForDeclaration(WfLexicalScopeManager* manager, WfDeclaration* declaration);
			extern void										CompleteScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module);

			extern void										BuildScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										BuildScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfDeclaration> declaration, glr::ParsingAstBase* source);
			extern void										BuildScopeForStatement(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement);
			extern void										BuildScopeForExpression(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression);
			extern bool										CheckScopes_DuplicatedSymbol(WfLexicalScopeManager* manager);
			extern bool										CheckScopes_SymbolType(WfLexicalScopeManager* manager);
			extern bool										CheckScopes_CycleDependency(WfLexicalScopeManager* manager);

/***********************************************************************
Semantic Analyzing
***********************************************************************/

			extern reflection::description::IMethodInfo*	FindInterfaceConstructor(reflection::description::ITypeDescriptor* type);
			extern Ptr<reflection::description::ITypeInfo>	SelectFunction(WfLexicalScopeManager* manager, glr::ParsingAstBase* node, Ptr<WfExpression> functionExpression, collections::List<ResolveExpressionResult>& functions, collections::List<Ptr<WfExpression>>& arguments, vint& selectedFunctionIndex);

			extern void										ValidateModuleSemantic(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ValidateClassMemberSemantic(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, WfClassDeclaration* classDecl, Ptr<WfDeclaration> memberDecl);
			extern void										ValidateDeclarationSemantic(WfLexicalScopeManager* manager, WfDeclaration* declaration);
			extern void										ValidateDeclarationSemantic(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration);
			extern void										ValidateStatementSemantic(WfLexicalScopeManager* manager, WfStatement* statement);
			extern void										ValidateStatementSemantic(WfLexicalScopeManager* manager, Ptr<WfStatement> statement);
			extern void										ValidateExpressionSemantic(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results);
			extern void										ValidateExpressionSemantic(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results);
			extern void										ValidateConstantExpression(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType);
			extern void										ValidateConstantExpression(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);

			extern Ptr<WfLexicalScopeName>					GetExpressionScopeName(WfLexicalScopeManager* manager, WfExpression* expression);
			extern Ptr<WfLexicalScopeName>					GetExpressionScopeName(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern reflection::description::IEventInfo*		GetExpressionEventInfo(WfLexicalScopeManager* manager, WfExpression* expression);
			extern reflection::description::IEventInfo*		GetExpressionEventInfo(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern void										GetExpressionTypes(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType, bool allowEvent, collections::List<ResolveExpressionResult>& results);
			extern void										GetExpressionTypes(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, bool allowEvent, collections::List<ResolveExpressionResult>& results);
			extern Ptr<reflection::description::ITypeInfo>	GetExpressionType(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType);
			extern Ptr<reflection::description::ITypeInfo>	GetExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);
			extern Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, WfExpression* expression);
			extern Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, WfExpression* expression, Ptr<reflection::description::ITypeInfo> expectedType);
			extern Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);

/***********************************************************************
Expanding Virtual Nodes
***********************************************************************/

			class CopyWithExpandVirtualVisitor : public copy_visitor::AstVisitor
			{
			private:
				bool										expandVirtualAst;

				void										Expand(collections::List<Ptr<WfDeclaration>>& decls);

				void										Visit(WfVirtualCfeExpression* node)override;
				void										Visit(WfVirtualCseExpression* node)override;
				void										Visit(WfVirtualCseStatement* node)override;

				void										Visit(WfNamespaceDeclaration* node)override;
				void										Visit(WfClassDeclaration* node)override;
				void										Visit(WfNewInterfaceExpression* node)override;

			public:
				CopyWithExpandVirtualVisitor(bool _expandVirtualAst);
			};

			extern Ptr<WfStatement>							SearchUntilNonVirtualStatement(Ptr<WfStatement> statement);
			extern Ptr<WfExpression>						CreateDefaultValue(reflection::description::ITypeInfo* elementType);

			extern Ptr<WfType>								CopyType(Ptr<WfType> type);
			extern Ptr<WfExpression>						CopyExpression(Ptr<WfExpression> expression, bool expandVirtualExprStat);
			extern Ptr<WfStatement>							CopyStatement(Ptr<WfStatement> statement, bool expandVirtualExprStat);
			extern Ptr<WfDeclaration>						CopyDeclaration(Ptr<WfDeclaration> declaration, bool expandVirtualExprStat);
			extern Ptr<WfModule>							CopyModule(Ptr<WfModule> module, bool expandVirtualExprStat);

			extern Ptr<WfType>								CopyType(WfType* type);
			extern Ptr<WfExpression>						CopyExpression(WfExpression* expression, bool expandVirtualExprStat);
			extern Ptr<WfStatement>							CopyStatement(WfStatement* statement, bool expandVirtualExprStat);
			extern Ptr<WfDeclaration>						CopyDeclaration(WfDeclaration* declaration, bool expandVirtualExprStat);
			extern Ptr<WfModule>							CopyModule(WfModule* module, bool expandVirtualExprStat);

			extern void										ExpandBindExpression(WfLexicalScopeManager* manager, WfBindExpression* node);
			extern void										ExpandNewCoroutineExpression(WfLexicalScopeManager* manager, WfNewCoroutineExpression* node);
			extern void										ExpandCoOperatorExpression(WfLexicalScopeManager* manager, WfCoOperatorExpression* node);
			extern void										ExpandMixinCastExpression(WfLexicalScopeManager* manager, WfMixinCastExpression* node);
			extern void										ExpandSwitchStatement(WfLexicalScopeManager* manager, WfSwitchStatement* node);
			extern void										ExpandForEachStatement(WfLexicalScopeManager* manager, WfForEachStatement* node);
			extern void										ExpandCoProviderStatement(WfLexicalScopeManager* manager, WfCoProviderStatement* node);
			extern void										ExpandStateMachine(WfLexicalScopeManager* manager, WfStateMachineDeclaration* node);

/***********************************************************************
Error Messages
***********************************************************************/

			struct WfErrors
			{
				// A: Expression error
				static glr::ParsingError					WrongFormatStringSyntax(WfExpression* node);
				static glr::ParsingError					WrongSimpleObserveExpression(WfExpression* node);
				static glr::ParsingError					WrongSimpleObserveEvent(WfExpression* node);
				static glr::ParsingError					EmptyObserveEvent(WfExpression* node);
				static glr::ParsingError					ObserveNotInBind(WfExpression* node);
				static glr::ParsingError					ObserveInObserveEvent(WfExpression* node);
				static glr::ParsingError					BindInBind(WfExpression* node);
				static glr::ParsingError					AttachInBind(WfExpression* node);
				static glr::ParsingError					DetachInBind(WfExpression* node);
				static glr::ParsingError					ConstructorMixMapAndList(WfExpression* node);
				static glr::ParsingError					ConstructorMixStructAndList(WfExpression* node);
				static glr::ParsingError					DuplicatedConstructorField(WfReferenceExpression* node);
				static glr::ParsingError					ConstructorMixClassAndInterface(WfNewClassExpression* node);
				static glr::ParsingError					ConstructorMixClassAndInterface(WfNewInterfaceExpression* node);
				static glr::ParsingError					ScopeNameIsNotExpression(WfExpression* node, Ptr<WfLexicalScopeName> scopeName);
				static glr::ParsingError					EventIsNotExpression(WfExpression* node, reflection::description::IEventInfo* eventInfo);
				static glr::ParsingError					ExpressionIsNotScopeName(WfExpression* node);
				static glr::ParsingError					ExpressionIsNotEvent(WfExpression* node);
				static glr::ParsingError					ExpressionCannotResolveType(WfExpression* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					NullCannotResolveType(WfExpression* node);
				static glr::ParsingError					ConstructorCannotResolveType(WfExpression* node);
				static glr::ParsingError					OrderedLambdaCannotResolveType(WfExpression* node);
				static glr::ParsingError					NullCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					ConstructorCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					OrderedLambdaCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					ExpressionCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					ExpressionCannotExplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					CannotWeakCastToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					IntegerLiteralOutOfRange(WfIntegerExpression* node);
				static glr::ParsingError					FloatingLiteralOutOfRange(WfFloatingExpression* node);
				static glr::ParsingError					CannotMergeTwoType(WfExpression* node, reflection::description::ITypeInfo* firstType, reflection::description::ITypeInfo* secondType);
				static glr::ParsingError					RangeShouldBeInteger(WfExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					UnaryOperatorOnWrongType(WfUnaryExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					BinaryOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					IndexOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* containerType);
				static glr::ParsingError					ExpressionIsNotCollection(WfExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					ExpressionIsNotFunction(WfExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					FunctionArgumentCountMismatched(glr::ParsingAstBase* node, vint expectedCount, const ResolveExpressionResult& function);
				static glr::ParsingError					FunctionArgumentTypeMismatched(glr::ParsingAstBase* node, const ResolveExpressionResult& function, vint index, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					CannotPickOverloadedFunctions(glr::ParsingAstBase* node, collections::List<ResolveExpressionResult>& results);
				static glr::ParsingError					ClassContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					InterfaceContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					ConstructorReturnTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					ExpressionIsNotLeftValue(WfExpression* node, const ResolveExpressionResult& result);
				static glr::ParsingError					CannotCallMemberOutsideOfClass(WfExpression* node, const ResolveExpressionResult& result);
				static glr::ParsingError					CannotCallMemberInStaticFunction(WfExpression* node, const ResolveExpressionResult& result);
				static glr::ParsingError					FieldCannotInitializeUsingEachOther(WfExpression* node, const ResolveExpressionResult& result);
				static glr::ParsingError					WrongThisExpression(WfExpression* node);
				static glr::ParsingError					IncorrectTypeForUnion(WfExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					IncorrectTypeForIntersect(WfExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					ExpressionIsNotConstant(WfExpression* node);
				static glr::ParsingError					WrongMixinTargetType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static glr::ParsingError					ExpectedTypeCastCannotResolveType(WfExpression* node);

				// B: Type error
				static glr::ParsingError					WrongVoidType(WfType* node);
				static glr::ParsingError					WrongInterfaceType(WfType* node);
				static glr::ParsingError					RawPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static glr::ParsingError					SharedPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static glr::ParsingError					NullableToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static glr::ParsingError					ChildOfNonReferenceType(WfType* node);
				static glr::ParsingError					TypeNotExists(WfType* node, Ptr<WfLexicalScopeName> scopeName);
				static glr::ParsingError					TypeNotExists(WfType* node, const ResolveExpressionResult& result);
				static glr::ParsingError					TypeNotForValue(WfType* node, reflection::description::ITypeInfo* typeInfo);
				
				// C: Statement error
				static glr::ParsingError					BreakNotInLoop(WfStatement* node);
				static glr::ParsingError					ContinueNotInLoop(WfStatement* node);
				static glr::ParsingError					RethrowNotInCatch(WfStatement* node);
				static glr::ParsingError					TryMissCatchAndFinally(WfStatement* node);
				static glr::ParsingError					ReturnMissExpression(WfStatement* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					DeleteNonRawPointer(WfStatement* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					CannotReturnExpression(WfStatement* node);
				static glr::ParsingError					WrongCoPause(WfStatement* node);
				static glr::ParsingError					WrongCoOperator(WfStatement* node);
				static glr::ParsingError					WrongCoOperator(WfExpression* node);
				static glr::ParsingError					CoProviderNotExists(WfCoProviderStatement* node, collections::List<WString>& candidates);
				static glr::ParsingError					CoOperatorNotExists(WfReturnStatement* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					CoOperatorNotExists(WfCoOperatorStatement* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					CoOperatorNotExists(WfCoOperatorExpression* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					CoOperatorCannotResolveResultType(WfCoOperatorStatement* node, collections::List<reflection::description::ITypeInfo*>& types);
				static glr::ParsingError					CoProviderCreateNotExists(WfCoProviderStatement* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					CoProviderCreateAndRunNotExists(WfCoProviderStatement* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					GotoLabelNotExists(WfGotoStatement* node);
				static glr::ParsingError					TooManyGotoLabel(WfGotoStatement* node);
				static glr::ParsingError					WrongStateSwitchStatement(WfStateSwitchStatement* node);
				static glr::ParsingError					WrongStateInvokeStatement(WfStateInvokeStatement* node);
				static glr::ParsingError					StateInputNotExists(WfStateSwitchCase* node);
				static glr::ParsingError					StateSwitchArgumentCountNotMatch(WfStateSwitchCase* node);
				static glr::ParsingError					StateNotExists(WfStateInvokeStatement* node);
				static glr::ParsingError					StateArgumentCountNotMatch(WfStateInvokeStatement* node);

				// D: Declaration error
				static glr::ParsingError					FunctionShouldHaveName(WfDeclaration* node);
				static glr::ParsingError					FunctionShouldHaveImplementation(WfDeclaration* node);
				static glr::ParsingError					InterfaceMethodShouldNotHaveImplementation(WfDeclaration* node);
				static glr::ParsingError					DuplicatedDeclaration(WfDeclaration* node, const WString& firstDeclarationCategory);
				static glr::ParsingError					DuplicatedDeclaration(WfStateMachineDeclaration* node);
				static glr::ParsingError					DuplicatedSymbol(WfDeclaration* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					DuplicatedSymbol(WfFunctionArgument* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					DuplicatedSymbol(WfStatement* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					DuplicatedSymbol(WfExpression* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					DuplicatedSymbol(WfStateInput* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					DuplicatedSymbol(WfStateDeclaration* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					DuplicatedSymbol(WfStateSwitchArgument* node, Ptr<WfLexicalSymbol> symbol);
				static glr::ParsingError					InterfaceMethodNotImplemented(WfNewInterfaceExpression* node, reflection::description::IMethodInfo* method);
				static glr::ParsingError					InterfaceMethodNotFound(WfFunctionDeclaration* node, reflection::description::ITypeInfo* interfaceType, reflection::description::ITypeInfo* methodType);
				static glr::ParsingError					CannotPickOverloadedInterfaceMethods(WfExpression* node, collections::List<ResolveExpressionResult>& results);
				static glr::ParsingError					CannotPickOverloadedImplementMethods(WfFunctionDeclaration* node, reflection::description::ITypeInfo* type);
				static glr::ParsingError					WrongDeclaration(WfEventDeclaration* node);
				static glr::ParsingError					WrongDeclaration(WfPropertyDeclaration* node);
				static glr::ParsingError					WrongDeclaration(WfConstructorDeclaration* node);
				static glr::ParsingError					WrongDeclaration(WfDestructorDeclaration* node);
				static glr::ParsingError					WrongDeclaration(WfAutoPropertyDeclaration* node);
				static glr::ParsingError					WrongDeclaration(WfStateMachineDeclaration* node);
				static glr::ParsingError					WrongDeclaration(WfStaticInitDeclaration* node);
				static glr::ParsingError					WrongDeclarationInInterfaceConstructor(WfDeclaration* node);
				static glr::ParsingError					EnumValuesNotConsecutiveFromZero(WfEnumDeclaration* node);
				static glr::ParsingError					FlagValuesNotConsecutiveFromZero(WfEnumDeclaration* node);
				static glr::ParsingError					FlagValueNotExists(WfEnumItemIntersection* node, WfEnumDeclaration* owner);
				static glr::ParsingError					DuplicatedEnumValue(WfEnumItem* node, WfEnumDeclaration* owner);
				static glr::ParsingError					StructContainsNonValueType(WfStructMember* node, WfStructDeclaration* owner);
				static glr::ParsingError					StructRecursivelyIncludeItself(WfStructDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static glr::ParsingError					DuplicatedStructMember(WfStructMember* node, WfStructDeclaration* owner);
				static glr::ParsingError					AttributeNotExists(WfAttribute* node);
				static glr::ParsingError					AttributeMissValue(WfAttribute* node);
				static glr::ParsingError					StateMachineClassNotInheritFromStateMachine(WfClassDeclaration* node);
				static glr::ParsingError					MissingDefaultState(WfStateMachineDeclaration* node);

				// E: Module error
				static glr::ParsingError					WrongUsingPathWildCard(WfModuleUsingPath* node);

				// F: Symbol Error
				static glr::ParsingError					TopQualifiedSymbolNotExists(glr::ParsingAstBase* node, const WString& name);
				static glr::ParsingError					ChildSymbolNotExists(glr::ParsingAstBase* node, Ptr<WfLexicalScopeName> scopeName, const WString& name);
				static glr::ParsingError					MemberNotExists(glr::ParsingAstBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name);
				static glr::ParsingError					ReferenceNotExists(glr::ParsingAstBase* node, const WString& name);
				static glr::ParsingError					TooManyTargets(glr::ParsingAstBase* node, collections::List<ResolveExpressionResult>& results, const WString& name);
				static glr::ParsingError					EnumItemNotExists(glr::ParsingAstBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name);

				// G: Class error
				static glr::ParsingError					WrongClassMemberConfig(WfDeclaration* node);
				static glr::ParsingError					FunctionInNewTypeExpressionCannotBeStatic(WfDeclaration* node);
				static glr::ParsingError					AutoPropertyCannotBeNormalOutsideOfClass(WfDeclaration* node);
				static glr::ParsingError					AutoPropertyCannotBeStatic(WfDeclaration* node);
				static glr::ParsingError					WrongClassMember(WfNamespaceDeclaration* node);
				static glr::ParsingError					PropertyGetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					PropertySetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					PropertyEventNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					TooManyPropertyGetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					TooManyPropertySetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					TooManyPropertyEvent(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					PropertyGetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					PropertySetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					WrongBaseType(WfClassDeclaration* node, WfType* type);
				static glr::ParsingError					WrongBaseTypeOfClass(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static glr::ParsingError					WrongBaseTypeOfInterface(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static glr::ParsingError					WrongInterfaceBaseType(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static glr::ParsingError					ClassWithInterfaceConstructor(WfClassDeclaration* node);
				static glr::ParsingError					OverrideShouldImplementInterfaceMethod(WfFunctionDeclaration* node);
				static glr::ParsingError					OverrideShouldImplementInterfaceMethod(WfAutoPropertyDeclaration* node);
				static glr::ParsingError					MissingFieldType(WfVariableDeclaration* node);
				static glr::ParsingError					DuplicatedBaseClass(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static glr::ParsingError					ClassRecursiveInheritance(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static glr::ParsingError					InterfaceRecursiveInheritance(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static glr::ParsingError					WrongBaseConstructorCall(WfBaseConstructorCall* node, reflection::description::ITypeDescriptor* type);
				static glr::ParsingError					DuplicatedBaseConstructorCall(WfBaseConstructorCall* node, reflection::description::ITypeDescriptor* type);
				static glr::ParsingError					TooManyDestructor(WfDestructorDeclaration* node, WfClassDeclaration* classDecl);
				static glr::ParsingError					AutoPropertyShouldBeInitialized(WfAutoPropertyDeclaration* node);
				static glr::ParsingError					AutoPropertyCannotBeInitializedInInterface(WfAutoPropertyDeclaration* node, WfClassDeclaration* classDecl);

				// CPP: C++ code generation error
				static glr::ParsingError					CppUnableToDecideClassOrder(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static glr::ParsingError					CppUnableToSeparateCustomFile(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
			};
		}
	}
}

#endif

/***********************************************************************
.\EMITTER\WFEMITTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Analyzer

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_ANALYZER_WFEMITTER
#define VCZH_WORKFLOW_ANALYZER_WFEMITTER


namespace vl
{
	namespace workflow
	{
		namespace emitter
		{

/***********************************************************************
Attribute Evaluator
***********************************************************************/

			class WfAttributeEvaluator : public Object
			{
				typedef collections::Dictionary<Ptr<WfAttribute>, runtime::WfRuntimeValue>			AttributeValueMap;

			protected:
				analyzer::WfLexicalScopeManager*			manager;
				AttributeValueMap							attributeValues;				// cached value for attribute

			public:
				WfAttributeEvaluator(analyzer::WfLexicalScopeManager* _manager);

				Ptr<WfAttribute>							GetAttribute(collections::List<Ptr<WfAttribute>>& atts, const WString& category, const WString& name);
				collections::LazyList<Ptr<WfAttribute>>		GetAttributes(collections::List<Ptr<WfAttribute>>& atts, const WString& category, const WString& name);
				runtime::WfRuntimeValue						GetAttributeValue(Ptr<WfAttribute> att);
			};

/***********************************************************************
Code Generation
***********************************************************************/

			struct WfCodegenLambdaContext
			{
				WfFunctionDeclaration*				functionDeclaration = 0;
				WfFunctionExpression*				functionExpression = 0;
				WfOrderedLambdaExpression*			orderedLambdaExpression = 0;
			};

			enum class WfCodegenScopeType
			{
				Function,	// contains the whole function
				Loop,		// contains all loops
				TryCatch,	// contains try and catch, not finally
				Block,		// contains labeled blocks
			};

			class WfCodegenScopeContext : public Object
			{
				typedef collections::List<vint>										InstructionIndexList;
				typedef collections::List<runtime::WfInstruction>					InstructionList;
				typedef collections::List<glr::ParsingTextRange>					RangeMap;
			public:
				WfCodegenScopeType					type = WfCodegenScopeType::Function;
				InstructionIndexList				continueInstructions;
				InstructionIndexList				breakInstructions;
				WString								name;
				
				InstructionList						exitInstructions;
				RangeMap							instructionCodeMappingBeforeCodegen;
				RangeMap							instructionCodeMappingAfterCodegen;
				Ptr<WfStatement>					exitStatement;
			};

			class WfCodegenFunctionContext : public Object
			{
				typedef collections::Dictionary<analyzer::WfLexicalSymbol*, vint>	VariableIndexMap;
				typedef collections::Dictionary<vint, WfCodegenLambdaContext>		ClosureIndexMap;
				typedef collections::List<Ptr<WfCodegenScopeContext>>				ScopeContextList;
			public:
				Ptr<runtime::WfAssemblyFunction>	function;
				VariableIndexMap					capturedVariables;
				VariableIndexMap					arguments;
				VariableIndexMap					localVariables;
				ClosureIndexMap						closuresToCodegen;
				ScopeContextList					scopeContextStack;

				WfCodegenFunctionContext();
				
				Ptr<WfCodegenScopeContext>			GetCurrentScopeContext();
				Ptr<WfCodegenScopeContext>			GetCurrentScopeContext(WfCodegenScopeType type, const WString& name = WString::Empty);
				Ptr<WfCodegenScopeContext>			PushScopeContext(WfCodegenScopeType type, const WString& name = WString::Empty);
				void								PopScopeContext();
			};

			class WfCodegenContext : public Object
			{
				typedef collections::Dictionary<analyzer::WfLexicalSymbol*, vint>								SymbolIndexMap;
				typedef collections::Dictionary<WfConstructorDeclaration*, vint>								ConstructorIndexMap;
				typedef collections::Dictionary<WfDestructorDeclaration*, vint>									DestructorIndexMap;
				typedef collections::Dictionary<glr::ParsingAstBase*, glr::ParsingTextRange>					NodePositionMap;
				typedef collections::Dictionary<Ptr<analyzer::WfLexicalFunctionConfig>, vint>					ThisStackCountMap;
			public:
				Ptr<runtime::WfAssembly>			assembly;
				analyzer::WfLexicalScopeManager*	manager;
				SymbolIndexMap						globalVariables;
				SymbolIndexMap						globalFunctions;
				ConstructorIndexMap					constructors;
				DestructorIndexMap					destructors;
				SymbolIndexMap						closureFunctions;
				Ptr<WfCodegenFunctionContext>		functionContext;
				NodePositionMap						nodePositionsBeforeCodegen;
				NodePositionMap						nodePositionsAfterCodegen;
				ThisStackCountMap					thisStackCounts;

				WfCodegenContext(Ptr<runtime::WfAssembly> _assembly, analyzer::WfLexicalScopeManager* _manager);

				vint								AddInstruction(glr::ParsingAstBase* node, const runtime::WfInstruction& ins);
				void								AddExitInstruction(glr::ParsingAstBase* node, const runtime::WfInstruction& ins);
				void								ApplyExitInstructions(Ptr<WfCodegenScopeContext> scopeContext);
				vint								GetThisStackCount(analyzer::WfLexicalScope* scope);
			};

			extern void										GenerateFunctionDeclarationMetadata(WfCodegenContext& context, WfFunctionDeclaration* node, Ptr<runtime::WfAssemblyFunction> meta);
			extern void										GenerateGlobalDeclarationMetadata(WfCodegenContext& context, WfDeclaration* declaration, const WString& namePrefix = L"");
			extern void										GenerateClosureInstructions(WfCodegenContext& context, Ptr<WfCodegenFunctionContext> functionContext);
			extern void										GenerateInitializeInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration);
			extern void										GenerateDeclarationInstructions(WfCodegenContext& context, WfDeclaration* declaration);
			extern void										GenerateStatementInstructions(WfCodegenContext& context, Ptr<WfStatement> statement);
			extern Ptr<reflection::description::ITypeInfo>	GenerateExpressionInstructions(WfCodegenContext& context, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType = 0);
			extern void										GenerateTypeCastInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, bool strongCast, WfExpression* node);
			extern void										GenerateTypeTestingInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, WfExpression* node);
			extern runtime::WfInsType						GetInstructionTypeArgument(Ptr<reflection::description::ITypeInfo> expectedType);

			/// <summary>Generate an assembly from semantic analyzed modules. [M:vl.workflow.analyzer.WfLexicalScopeManager.Rebuild] should be called before using this function.</summary>
			/// <returns>The generated assembly.</returns>
			/// <param name="manager">The scope manager that is used to perform semantic analyzing.</param>
			/// <param name="callback">The callback to receive progress information (optional).</param>
			extern Ptr<runtime::WfAssembly>					GenerateAssembly(analyzer::WfLexicalScopeManager* manager, IWfCompilerCallback* callback = nullptr);

			/// <summary>Compile a Workflow program.</summary>
			/// <returns>The generated assembly. Return nullptr if failed to compile.</returns>
			/// <param name="manager">The scope manager. This is reusable, it is recommended to keep this object alive between multiple compiling to improve performance.</param>
			/// <param name="moduleCodes">All workflow module codes.</param>
			/// <param name="errors">Container to get all errors generated during compiling.</param>
			extern Ptr<runtime::WfAssembly>					Compile(analyzer::WfLexicalScopeManager* manager, collections::List<WString>& moduleCodes, collections::List<glr::ParsingError>& errors);
			
			/// <summary>Compile a Workflow program. Use the other one whenever possible, which alloes reusing <see cref="analyzer::WfLexicalScopeManager"/> to improve performance.</summary>
			/// <returns>The generated assembly. Return nullptr if failed to compile.</returns>
			/// <param name="workflowParser">The generated parser class.</param>
			/// <param name="cpuArchitecture">The target CPU architecture.</param>
			/// <param name="moduleCodes">All workflow module codes.</param>
			/// <param name="errors">Container to get all errors generated during compiling.</param>
			extern Ptr<runtime::WfAssembly>					Compile(workflow::Parser& workflowParser, analyzer::WfCpuArchitecture cpuArchitecture, collections::List<WString>& moduleCodes, collections::List<glr::ParsingError>& errors);
		}
	}
}

#endif

/***********************************************************************
.\CPP\WFCPP.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::C++ Code Generator

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_CPP_WFCPP
#define VCZH_WORKFLOW_CPP_WFCPP


namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			/*
			Vczh Workflow Special Name:
				__vwsn_not_exists__		: Represents all not supported code
				__vwsn_temp_(#|_)		: Temporary variable
				__vwsn_CATEGORY			: <CATEGORY>
				__vwsn_CATEGORY_NAME	: <CATEGORY>NAME
				__vwsno#_ASSEMBLY_*		: Ordered lambda class name
				__vwsnf#_ASSEMBLY_*		: Function expression class name
				__vwsnc#_ASSEMBLY_*		: Anonymous interface class name
				__vwsnthis_#			: Captured this pointer in fields
				__vwsnctor_*			: Captured symbol in constructor arguments, assigned to "this->*"
				__vwsnctorthis_#		: Captured this pointer in constructor arguments assigned to "this->__vwsnthis_#"?
				__vwsnt_#				: Temporary type
				__vwsne_#				: Temporary variable (not for lambda)
				__vwsnb_#				: Temporary block
				__vwnsl_#_LABEL_NAME	: Goto label
				__vwsn_structs::NAME	: Struct definition
				__vwsn_enums::NAME		: Struct definition
			*/

			class WfCppConfig : public Object
			{
				using ITypeInfo = reflection::description::ITypeInfo;
				using IMethodInfo = reflection::description::IMethodInfo;
				using ITypeDescriptor = reflection::description::ITypeDescriptor;

			public:
				class ClosureInfo : public Object
				{
					using SymbolMap = collections::Dictionary<WString, Ptr<analyzer::WfLexicalSymbol>>;
				public:
					WString											lambdaClassName;
					SymbolMap										symbols;
					SymbolMap										ctorArgumentSymbols;
					collections::List<ITypeDescriptor*>				thisTypes;				// nearer this pointer first
				};

			public:
				regex::Regex										regexSplitName;
				regex::Regex										regexSpecialName;
				regex::Regex										regexTemplate;
				const vint											specialName_category;
				const vint											specialName_name;

			protected:
				Ptr<ClosureInfo>									CollectClosureInfo(Ptr<WfExpression> closure);
				void												Collect();

				struct GlobalDep
				{
					collections::Dictionary<WString, ITypeDescriptor*>		allTds;				// Type name to type descriptor of class decls. Class index is the position in this map.
					collections::Group<vint, vint>							expandedClassDecls;	// Class index (-1 means top level) to all direct and indirect internal classes
					collections::Group<vint, vint>							dependencies;		// Class dependencies
					collections::SortedList<vint>							topLevelClasses;	// Class index
					collections::Group<vint, vint>							topLevelClassDep;	// Class dependencies for top level classes
				};

				struct ClassLevelDep
				{
					Ptr<WfClassDeclaration>									parentClass;
					vint													parentIndexKey = -1;
					collections::Group<vint, vint>							depGroup;			// A slice of GlobalDep::dependencies
					collections::Dictionary<vint, vint>						subClass;			// Classes to their ancestor, which are direct internal classes of the selected parent class
				};

				void												ExpandClassDeclGroup(Ptr<WfClassDeclaration> parent, GlobalDep& globalDep);
				void												GenerateClassDependencies(GlobalDep& globalDep);
				void												GenerateGlobalDep(GlobalDep& globalDep);

				void												CollectExpandedDepGroup(vint parentIndexKey, GlobalDep& globalDep, ClassLevelDep& classLevelDep);
				void												CollectExpandedSubClass(vint subDeclIndexKey, GlobalDep& globalDep, ClassLevelDep& classLevelDep);
				void												GenerateClassLevelDep(Ptr<WfClassDeclaration> parent, GlobalDep& globalDep, ClassLevelDep& classLevelDep);

				void												SortClassDecls(GlobalDep& globalDep);
				void												GenerateFileClassMaps(GlobalDep& globalDep);
				void												SortFileClassMaps(GlobalDep& globalDep);
				void												AssignClassDeclsToFiles();

				template<typename T>
				void SortDeclsByName(collections::List<Ptr<T>>& decls)
				{
					collections::SortLambda<Ptr<T>>(&decls[0], decls.Count(), [=](Ptr<T> a, Ptr<T> b)
					{
						auto tdA = manager->declarationTypes[a.Obj()].Obj();
						auto tdB = manager->declarationTypes[b.Obj()].Obj();
						return tdA->GetTypeName() <=> tdB->GetTypeName();
					});
				}

			public:
				analyzer::WfLexicalScopeManager*											manager;
				Ptr<emitter::WfAttributeEvaluator>											attributeEvaluator;
				WString																		assemblyNamespace;
				WString																		assemblyName;

				collections::Dictionary<ITypeDescriptor*, Ptr<WfDeclaration>>				tdDecls;			// type descriptor to declaration
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfEnumDeclaration>>			enumDecls;			// class (nullable) to direct internal enums
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfStructDeclaration>>		structDecls;		// class (nullable) to direct internal structs
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfClassDeclaration>>		classDecls;			// class (nullable) to direct internal classes
				collections::List<Ptr<WfVariableDeclaration>>								varDecls;			// global variables
				collections::List<Ptr<WfFunctionDeclaration>>								funcDecls;			// global functions
				collections::List<Ptr<WfStaticInitDeclaration>>								staticInitDecls;		// global static initialization declarations

				collections::Group<WString, Ptr<WfClassDeclaration>>						customFilesClasses;	// @cpp:File to top level classes, empty key means the default cpp
				collections::Group<vint, Ptr<WfClassDeclaration>>							headerFilesClasses;	// non-@cpp:File header file to top level classes, 0 means the default header
				collections::Group<vint, vint>												headerIncludes;		// 0:default header, positive:@cpp:File indexed in customFilesClasses, negative:non-@cpp:File headers

				collections::Dictionary<Ptr<WfExpression>, WString>							lambdaExprs;
				collections::Dictionary<Ptr<WfNewInterfaceExpression>, WString>				classExprs;
				collections::Dictionary<Ptr<WfExpression>, Ptr<ClosureInfo>>				closureInfos;
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfExpression>>				classClosures;

				WfCppConfig(analyzer::WfLexicalScopeManager* _manager, const WString& _assemblyName, const WString& _assemblyNamespace);
				~WfCppConfig();

				void					WriteFunctionBody(stream::StreamWriter& writer, Ptr<WfExpression> expr, const WString& prefix, ITypeInfo* expectedType);
				void					WriteFunctionBody(stream::StreamWriter& writer, Ptr<WfStatement> stat, const WString& prefix, ITypeInfo* expectedType);

				WString					CppNameToHeaderEnumStructName(const WString& fullName, const WString& type);
				WString					ConvertNameInternal(const WString& name, const WString& specialNameCategory, bool alwaysUseCategory);
				WString					ConvertName(const WString& name);
				WString					ConvertName(const WString& name, const WString& specialNameCategory);
				WString					ConvertFullName(const WString& fullName, WString delimiter = L"::");
				WString					ConvertFunctionType(IMethodInfo* methodInfo, WString name = WString::Empty);
				WString					ConvertFunctionType(ITypeInfo* typeInfo);
				bool					IsSpecialGenericType(ITypeInfo* typeInfo);
				WString					ConvertType(ITypeDescriptor* typeInfo, WString delimiter = L"::");
				WString					ConvertType(ITypeInfo* typeInfo, bool useHeaderEnumStructName = false);
				WString					ConvertArgumentType(ITypeInfo* typeInfo);
				WString					DefaultValue(ITypeInfo* typeInfo);
				bool					IsClassHasUserImplMethods(Ptr<WfClassDeclaration> decl, bool searchInternalClasses);

				vint					CountClassNamespace(Ptr<WfClassDeclaration> decl);
				void					GetClassNamespace(Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);
				WString					GetClassBaseName(Ptr<WfClassDeclaration> decl);
				WString					WriteNamespace(stream::StreamWriter& writer, collections::List<WString>& nss, collections::List<WString>& nss2);
				WString					WriteNamespace(stream::StreamWriter& writer, const WString& fullName, collections::List<WString>& nss, WString& name);
				void					WriteNamespaceEnd(stream::StreamWriter& writer, collections::List<WString>& nss);

				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, ITypeInfo* typeInfo, collections::List<WString>& arguments, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfOrderedLambdaExpression> ordered, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfFunctionExpression> funcExpr, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfFunctionDeclaration> decl, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, IMethodInfo* methodInfo, collections::List<WString>& arguments, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, IMethodInfo* methodInfo, const WString& name, bool writeReturnType);

				void					WriteHeader_Enum(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, const WString& name, const WString& prefix, bool mainHeaderDefinition);
				void					WriteHeader_EnumOp(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, const WString& name, const WString& prefix);
				void					WriteHeader_Enum(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, collections::List<WString>& nss, bool mainHeaderDefinition);
				void					WriteHeader_MainHeaderEnums(stream::StreamWriter& writer, collections::List<WString>& nss);

				void					WriteHeader_Struct(stream::StreamWriter& writer, Ptr<WfStructDeclaration> decl, const WString& name, const WString& prefix, bool mainHeaderDefinition);
				void					WriteHeader_Struct(stream::StreamWriter& writer, Ptr<WfStructDeclaration> decl, collections::List<WString>& nss, bool mainHeaderDefinition);
				void					WriteHeader_MainHeaderStructs(stream::StreamWriter& writer, collections::List<WString>& nss);

				void					WriteHeader_ClosurePreDecl(stream::StreamWriter& writer, Ptr<WfExpression> closure);
				void					WriteHeader_LambdaExprDecl(stream::StreamWriter& writer, Ptr<WfExpression> lambda);
				void					WriteHeader_ClassExprDecl(stream::StreamWriter& writer, Ptr<WfNewInterfaceExpression> lambda);
				bool					WriteCpp_ClosureMembers(stream::StreamWriter& writer, Ptr<WfExpression> closure);
				void					WriteCpp_ClosureCtor(stream::StreamWriter& writer, Ptr<WfExpression> closure, const WString& name);
				void					WriteCpp_ClosureCtorInitList(stream::StreamWriter& writer, Ptr<WfExpression> closure);
				void					WriteCpp_LambdaExprImpl(stream::StreamWriter& writer, Ptr<WfExpression> lambda);
				void					WriteCpp_ClassExprImpl(stream::StreamWriter& writer, Ptr<WfNewInterfaceExpression> lambda);

				void					WriteHeader_ClassPreDecl(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, const WString& name, const WString& prefix);
				void					WriteHeader_ClassPreDecl(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);
				void					WriteHeader_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, const WString& name, const WString& prefix);
				WString					WriteHeader_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);
				bool					WriteCpp_ClassMember(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, Ptr<WfDeclaration> memberDecl, collections::List<WString>& nss);
				void					WriteCpp_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);

				void					SortClosure(collections::Dictionary<WString, Ptr<WfExpression>>& reversedLambdaExprs, collections::Dictionary<WString, Ptr<WfNewInterfaceExpression>>& reversedClassExprs);
				void					WriteHeader_Global(stream::StreamWriter& writer);
				void					WriteCpp_Global(stream::StreamWriter& writer);

				void					WriteHeader_Reflection(stream::StreamWriter& writer);
				void					WriteCpp_Reflection(stream::StreamWriter& writer);

				void					WritePushCompileOptions(stream::StreamWriter& writer);
				void					WritePopCompileOptions(stream::StreamWriter& writer);
				void					WriteCpp_PushMacros(stream::StreamWriter& writer);
				void					WriteCpp_PopMacros(stream::StreamWriter& writer);

				void					WriteHeader(stream::StreamWriter& writer, bool multiFile);
				void					WriteNonCustomSubHeader(stream::StreamWriter& writer, vint fileIndex);
				void					WriteCpp(stream::StreamWriter& writer, bool multiFile);
				void					WriteSubHeader(stream::StreamWriter& writer, const WString& fileName);
				void					WriteSubCpp(stream::StreamWriter& writer, const WString& fileName);
				void					WriteReflectionHeader(stream::StreamWriter& writer, bool multiFile);
				void					WriteReflectionCpp(stream::StreamWriter& writer, bool multiFile);
			};

/***********************************************************************
WfCppConfig::Collect
***********************************************************************/

			extern void CollectModule(WfCppConfig* config, Ptr<WfModule> module);

/***********************************************************************
WfCppConfig::Write
***********************************************************************/

			class FunctionRecord : public Object
			{
				using LabelMap = collections::Dictionary<WString, WString>;
			public:
				vint					exprCounter = 0;
				vint					blockCounter = 0;
				vint					labelCounter = 0;
				LabelMap				labelNames;
			};

			extern void					GenerateExpression(WfCppConfig* config, stream::StreamWriter& writer, Ptr<WfExpression> node, reflection::description::ITypeInfo* expectedType, bool useReturnValue = true);
			extern void					GenerateStatement(WfCppConfig* config, Ptr<FunctionRecord> functionRecord, stream::StreamWriter& writer, Ptr<WfStatement> node, const WString& prefix, const WString& prefixDelta, reflection::description::ITypeInfo* returnType);
			extern void					GenerateClassMemberDecl(WfCppConfig* config, stream::StreamWriter& writer, const WString& className, Ptr<WfDeclaration> memberDecl, const WString& prefix, bool forClassExpr);
			extern bool					GenerateClassMemberImpl(WfCppConfig* config, stream::StreamWriter& writer, WfClassDeclaration* classDef, const WString& classBaseName, const WString& className, const WString& classFullName, Ptr<WfDeclaration> memberDecl, const WString& prefix);

			extern void					ConvertType(WfCppConfig* config, stream::StreamWriter& writer, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, const Func<void()>& writeExpression, bool strongCast);

/***********************************************************************
GenerateCppFiles
***********************************************************************/

			enum class WfCppFileSwitch
			{
				Enabled,
				Disabled,
				OnDemand,
			};

			class WfCppInput : public Object
			{
			public:
				WfCppFileSwitch									multiFile = WfCppFileSwitch::Enabled;
				WfCppFileSwitch									reflection = WfCppFileSwitch::Enabled;
				WString											comment;
				WString											headerGuardPrefix;
				WString											assemblyName;
				WString											assemblyNamespace;
				WString											includeFileName;
				WString											reflectionFileName;
				WString											defaultFileName;
				collections::List<WString>						normalIncludes;
				collections::List<WString>						reflectionIncludes;

				WfCppInput(const WString& _assemblyName);
			};

			class WfCppOutput : public Object
			{
			public:
				collections::Dictionary<WString, WString>		cppFiles;
				bool											containsReflectionInfo = false;
				bool											multiFile = false;
				bool											reflection = false;
				WString											entryFileName;
			};

			extern Ptr<WfCppOutput>		GenerateCppFiles(Ptr<WfCppInput> input, analyzer::WfLexicalScopeManager* manager);
		}
	}
}

#endif
