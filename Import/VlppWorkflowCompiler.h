/***********************************************************************
THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
DEVELOPER: Zihan Chen(vczh)
***********************************************************************/
#include "VlppWorkflowLibrary.h"
#include "VlppWorkflowRuntime.h"
#include "Vlpp.h"

/***********************************************************************
.\EXPRESSION\WFEXPRESSION_AST.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_AST
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_AST


namespace vl
{
	namespace workflow
	{
		enum class WfParserTokenIndex
		{
			EXP = 0,
			ADD = 1,
			SUB = 2,
			MUL = 3,
			DIV = 4,
			MOD = 5,
			UNION = 6,
			INTERSECTION = 7,
			LE = 8,
			GE = 9,
			LT = 10,
			GT = 11,
			EQ = 12,
			NE = 13,
			ASSIGN = 14,
			FAILED_THEN = 15,
			QUESTION_MARK = 16,
			SCOPE_DELIMITER = 17,
			COLON = 18,
			SEMICOLON = 19,
			COMMA = 20,
			DOT = 21,
			OPEN_ARRAY = 22,
			CLOSE_ARRAY = 23,
			OPEN_BRACE = 24,
			CLOSE_BRACE = 25,
			OPEN_BRACKET = 26,
			CLOSE_BRACKET = 27,
			AT = 28,
			TYPE_VOID = 29,
			TYPE_OBJECT = 30,
			TYPE_INTERFACE = 31,
			TYPE_INT = 32,
			TYPE_UINT = 33,
			TYPE_FLOAT = 34,
			TYPE_DOUBLE = 35,
			TYPE_STRING = 36,
			TYPE_CHAR = 37,
			TYPE_BOOL = 38,
			KEYWORD_CONST = 39,
			KEYWORD_SHL = 40,
			KEYWORD_SHR = 41,
			KEYWORD_XOR = 42,
			KEYWORD_AND = 43,
			KEYWORD_OR = 44,
			KEYWORD_NOT = 45,
			KEYWORD_NULL = 46,
			KEYWORD_THIS = 47,
			KEYWORD_TRUE = 48,
			KEYWORD_FALSE = 49,
			KEYWORD_LET = 50,
			KEYWORD_IN = 51,
			KEYWORD_RANGE = 52,
			KEYWORD_NEW = 53,
			KEYWORD_OF = 54,
			KEYWORD_AS = 55,
			KEYWORD_IS = 56,
			KEYWORD_CAST = 57,
			KEYWORD_FUNC = 58,
			KEYWORD_TYPEOF = 59,
			KEYWORD_TYPE = 60,
			KEYWORD_BIND = 61,
			KEYWORD_OBSERVE = 62,
			KEYWORD_ON = 63,
			KEYWORD_ATTACH = 64,
			KEYWORD_DETACH = 65,
			KEYWORD_GOTO = 66,
			KEYWORD_VAR = 67,
			KEYWORD_BREAK = 68,
			KEYWORD_CONTINUE = 69,
			KEYWORD_RETURN = 70,
			KEYWORD_DELETE = 71,
			KEYWORD_RAISE = 72,
			KEYWORD_IF = 73,
			KEYWORD_ELSE = 74,
			KEYWORD_SWITCH = 75,
			KEYWORD_CASE = 76,
			KEYWORD_DEFAULT = 77,
			KEYWORD_WHILE = 78,
			KEYWORD_FOR = 79,
			KEYWORD_REVERSED = 80,
			KEYWORD_TRY = 81,
			KEYWORD_CATCH = 82,
			KEYWORD_FINALLY = 83,
			KEYWORD_CLASS = 84,
			KEYWORD_ENUM = 85,
			KEYWORD_FLAGENUM = 86,
			KEYWORD_STRUCT = 87,
			KEYWORD_PROP = 88,
			KEYWORD_EVENT = 89,
			KEYWORD_STATIC = 90,
			KEYWORD_OVERRIDE = 91,
			KEYWORD_USING = 92,
			KEYWORD_NAMESPACE = 93,
			KEYWORD_MODULE = 94,
			KEYWORD_UNIT = 95,
			STATE_MACHINE = 96,
			STATE_INPUT = 97,
			STATE_SWITCH = 98,
			STATE_GOTO = 99,
			STATE_PUSH = 100,
			STATE_DECL = 101,
			COROUTINE_COROUTINE = 102,
			COROUTINE_PAUSE = 103,
			COROUTINE_INTERFACE = 104,
			COROUTINE_OPERATOR = 105,
			COROUTINE_SIGN = 106,
			NAME = 107,
			ORDERED_NAME = 108,
			FLOAT = 109,
			INTEGER = 110,
			STRING = 111,
			FORMATSTRING = 112,
			SPACE = 113,
			COMMENT = 114,
		};
		class WfClassMember;
		class WfType;
		class WfExpression;
		class WfStatement;
		class WfAttribute;
		class WfDeclaration;
		class WfPredefinedType;
		class WfTopQualifiedType;
		class WfReferenceType;
		class WfRawPointerType;
		class WfSharedPointerType;
		class WfNullableType;
		class WfEnumerableType;
		class WfMapType;
		class WfObservableListType;
		class WfFunctionType;
		class WfChildType;
		class WfNamespaceDeclaration;
		class WfFunctionArgument;
		class WfFunctionDeclaration;
		class WfVariableDeclaration;
		class WfEventDeclaration;
		class WfPropertyDeclaration;
		class WfBaseConstructorCall;
		class WfConstructorDeclaration;
		class WfDestructorDeclaration;
		class WfClassDeclaration;
		class WfEnumItemIntersection;
		class WfEnumItem;
		class WfEnumDeclaration;
		class WfStructMember;
		class WfStructDeclaration;
		class WfVirtualCfeDeclaration;
		class WfAutoPropertyDeclaration;
		class WfCastResultInterfaceDeclaration;
		class WfVirtualCseDeclaration;
		class WfStateInput;
		class WfStateDeclaration;
		class WfStateMachineDeclaration;
		class WfBreakStatement;
		class WfContinueStatement;
		class WfReturnStatement;
		class WfDeleteStatement;
		class WfRaiseExceptionStatement;
		class WfIfStatement;
		class WfWhileStatement;
		class WfTryStatement;
		class WfBlockStatement;
		class WfGotoStatement;
		class WfVariableStatement;
		class WfExpressionStatement;
		class WfVirtualCseStatement;
		class WfForEachStatement;
		class WfSwitchCase;
		class WfSwitchStatement;
		class WfCoProviderStatement;
		class WfCoroutineStatement;
		class WfCoPauseStatement;
		class WfCoOperatorStatement;
		class WfStateMachineStatement;
		class WfStateSwitchArgument;
		class WfStateSwitchCase;
		class WfStateSwitchStatement;
		class WfStateInvokeStatement;
		class WfThisExpression;
		class WfTopQualifiedExpression;
		class WfReferenceExpression;
		class WfOrderedNameExpression;
		class WfOrderedLambdaExpression;
		class WfMemberExpression;
		class WfChildExpression;
		class WfLiteralExpression;
		class WfFloatingExpression;
		class WfIntegerExpression;
		class WfStringExpression;
		class WfUnaryExpression;
		class WfBinaryExpression;
		class WfLetVariable;
		class WfLetExpression;
		class WfIfExpression;
		class WfRangeExpression;
		class WfSetTestingExpression;
		class WfConstructorArgument;
		class WfConstructorExpression;
		class WfInferExpression;
		class WfTypeCastingExpression;
		class WfTypeTestingExpression;
		class WfTypeOfTypeExpression;
		class WfTypeOfExpressionExpression;
		class WfAttachEventExpression;
		class WfDetachEventExpression;
		class WfObserveExpression;
		class WfCallExpression;
		class WfFunctionExpression;
		class WfNewClassExpression;
		class WfNewInterfaceExpression;
		class WfVirtualCfeExpression;
		class WfFormatExpression;
		class WfVirtualCseExpression;
		class WfBindExpression;
		class WfNewCoroutineExpression;
		class WfMixinCastExpression;
		class WfExpectedTypeCastExpression;
		class WfCoOperatorExpression;
		class WfModuleUsingFragment;
		class WfModuleUsingNameFragment;
		class WfModuleUsingWildCardFragment;
		class WfModuleUsingItem;
		class WfModuleUsingPath;
		class WfModule;

		enum class WfClassMemberKind
		{
			Static,
			Override,
			Normal,
		};

		class WfClassMember : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfClassMember>
		{
		public:
			WfClassMemberKind kind;

			static vl::Ptr<WfClassMember> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfType abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfType>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfPredefinedType* node)=0;
				virtual void Visit(WfTopQualifiedType* node)=0;
				virtual void Visit(WfReferenceType* node)=0;
				virtual void Visit(WfRawPointerType* node)=0;
				virtual void Visit(WfSharedPointerType* node)=0;
				virtual void Visit(WfNullableType* node)=0;
				virtual void Visit(WfEnumerableType* node)=0;
				virtual void Visit(WfMapType* node)=0;
				virtual void Visit(WfObservableListType* node)=0;
				virtual void Visit(WfFunctionType* node)=0;
				virtual void Visit(WfChildType* node)=0;
			};

			virtual void Accept(WfType::IVisitor* visitor)=0;

		};

		class WfExpression abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfExpression>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfThisExpression* node)=0;
				virtual void Visit(WfTopQualifiedExpression* node)=0;
				virtual void Visit(WfReferenceExpression* node)=0;
				virtual void Visit(WfOrderedNameExpression* node)=0;
				virtual void Visit(WfOrderedLambdaExpression* node)=0;
				virtual void Visit(WfMemberExpression* node)=0;
				virtual void Visit(WfChildExpression* node)=0;
				virtual void Visit(WfLiteralExpression* node)=0;
				virtual void Visit(WfFloatingExpression* node)=0;
				virtual void Visit(WfIntegerExpression* node)=0;
				virtual void Visit(WfStringExpression* node)=0;
				virtual void Visit(WfUnaryExpression* node)=0;
				virtual void Visit(WfBinaryExpression* node)=0;
				virtual void Visit(WfLetExpression* node)=0;
				virtual void Visit(WfIfExpression* node)=0;
				virtual void Visit(WfRangeExpression* node)=0;
				virtual void Visit(WfSetTestingExpression* node)=0;
				virtual void Visit(WfConstructorExpression* node)=0;
				virtual void Visit(WfInferExpression* node)=0;
				virtual void Visit(WfTypeCastingExpression* node)=0;
				virtual void Visit(WfTypeTestingExpression* node)=0;
				virtual void Visit(WfTypeOfTypeExpression* node)=0;
				virtual void Visit(WfTypeOfExpressionExpression* node)=0;
				virtual void Visit(WfAttachEventExpression* node)=0;
				virtual void Visit(WfDetachEventExpression* node)=0;
				virtual void Visit(WfObserveExpression* node)=0;
				virtual void Visit(WfCallExpression* node)=0;
				virtual void Visit(WfFunctionExpression* node)=0;
				virtual void Visit(WfNewClassExpression* node)=0;
				virtual void Visit(WfNewInterfaceExpression* node)=0;
				virtual void Visit(WfVirtualCfeExpression* node)=0;
				virtual void Visit(WfVirtualCseExpression* node)=0;
			};

			virtual void Accept(WfExpression::IVisitor* visitor)=0;

		};

		class WfStatement abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfBreakStatement* node)=0;
				virtual void Visit(WfContinueStatement* node)=0;
				virtual void Visit(WfReturnStatement* node)=0;
				virtual void Visit(WfDeleteStatement* node)=0;
				virtual void Visit(WfRaiseExceptionStatement* node)=0;
				virtual void Visit(WfIfStatement* node)=0;
				virtual void Visit(WfWhileStatement* node)=0;
				virtual void Visit(WfTryStatement* node)=0;
				virtual void Visit(WfBlockStatement* node)=0;
				virtual void Visit(WfGotoStatement* node)=0;
				virtual void Visit(WfVariableStatement* node)=0;
				virtual void Visit(WfExpressionStatement* node)=0;
				virtual void Visit(WfVirtualCseStatement* node)=0;
				virtual void Visit(WfCoroutineStatement* node)=0;
				virtual void Visit(WfStateMachineStatement* node)=0;
			};

			virtual void Accept(WfStatement::IVisitor* visitor)=0;

		};

		class WfAttribute : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfAttribute>
		{
		public:
			vl::parsing::ParsingToken category;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfAttribute> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDeclaration abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfDeclaration>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfNamespaceDeclaration* node)=0;
				virtual void Visit(WfFunctionDeclaration* node)=0;
				virtual void Visit(WfVariableDeclaration* node)=0;
				virtual void Visit(WfEventDeclaration* node)=0;
				virtual void Visit(WfPropertyDeclaration* node)=0;
				virtual void Visit(WfConstructorDeclaration* node)=0;
				virtual void Visit(WfDestructorDeclaration* node)=0;
				virtual void Visit(WfClassDeclaration* node)=0;
				virtual void Visit(WfEnumDeclaration* node)=0;
				virtual void Visit(WfStructDeclaration* node)=0;
				virtual void Visit(WfVirtualCfeDeclaration* node)=0;
				virtual void Visit(WfVirtualCseDeclaration* node)=0;
			};

			virtual void Accept(WfDeclaration::IVisitor* visitor)=0;

			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfClassMember> classMember;
		};

		enum class WfPredefinedTypeName
		{
			Void,
			Object,
			Interface,
			Int,
			UInt,
			Float,
			Double,
			String,
			Char,
			Bool,
		};

		class WfPredefinedType : public WfType, vl::reflection::Description<WfPredefinedType>
		{
		public:
			WfPredefinedTypeName name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfPredefinedType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTopQualifiedType : public WfType, vl::reflection::Description<WfTopQualifiedType>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfTopQualifiedType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReferenceType : public WfType, vl::reflection::Description<WfReferenceType>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfReferenceType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfRawPointerType : public WfType, vl::reflection::Description<WfRawPointerType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfRawPointerType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSharedPointerType : public WfType, vl::reflection::Description<WfSharedPointerType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfSharedPointerType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNullableType : public WfType, vl::reflection::Description<WfNullableType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfNullableType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEnumerableType : public WfType, vl::reflection::Description<WfEnumerableType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfEnumerableType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfMapWritability
		{
			Readonly,
			Writable,
		};

		class WfMapType : public WfType, vl::reflection::Description<WfMapType>
		{
		public:
			WfMapWritability writability;
			vl::Ptr<WfType> key;
			vl::Ptr<WfType> value;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfMapType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfObservableListType : public WfType, vl::reflection::Description<WfObservableListType>
		{
		public:
			vl::Ptr<WfType> element;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfObservableListType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionType : public WfType, vl::reflection::Description<WfFunctionType>
		{
		public:
			vl::Ptr<WfType> result;
			vl::collections::List<vl::Ptr<WfType>> arguments;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfChildType : public WfType, vl::reflection::Description<WfChildType>
		{
		public:
			vl::Ptr<WfType> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfType::IVisitor* visitor)override;

			static vl::Ptr<WfChildType> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNamespaceDeclaration : public WfDeclaration, vl::reflection::Description<WfNamespaceDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfNamespaceDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfFunctionArgument>
		{
		public:
			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfType> type;

			static vl::Ptr<WfFunctionArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfFunctionAnonymity
		{
			Named,
			Anonymous,
		};

		class WfFunctionDeclaration : public WfDeclaration, vl::reflection::Description<WfFunctionDeclaration>
		{
		public:
			WfFunctionAnonymity anonymity;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
			vl::Ptr<WfType> returnType;
			vl::Ptr<WfStatement> statement;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVariableDeclaration : public WfDeclaration, vl::reflection::Description<WfVariableDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			vl::Ptr<WfExpression> expression;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfVariableDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEventDeclaration : public WfDeclaration, vl::reflection::Description<WfEventDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfType>> arguments;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfEventDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfPropertyDeclaration : public WfDeclaration, vl::reflection::Description<WfPropertyDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			vl::parsing::ParsingToken getter;
			vl::parsing::ParsingToken setter;
			vl::parsing::ParsingToken valueChangedEvent;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfPropertyDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfClassKind
		{
			Class,
			Interface,
		};

		enum class WfConstructorType
		{
			Undefined,
			SharedPtr,
			RawPtr,
		};

		class WfBaseConstructorCall : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfBaseConstructorCall>
		{
		public:
			vl::Ptr<WfType> type;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			static vl::Ptr<WfBaseConstructorCall> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorDeclaration : public WfDeclaration, vl::reflection::Description<WfConstructorDeclaration>
		{
		public:
			WfConstructorType constructorType;
			vl::collections::List<vl::Ptr<WfBaseConstructorCall>> baseConstructorCalls;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
			vl::Ptr<WfStatement> statement;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfConstructorDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDestructorDeclaration : public WfDeclaration, vl::reflection::Description<WfDestructorDeclaration>
		{
		public:
			vl::Ptr<WfStatement> statement;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfDestructorDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfClassDeclaration : public WfDeclaration, vl::reflection::Description<WfClassDeclaration>
		{
		public:
			WfClassKind kind;
			WfConstructorType constructorType;
			vl::collections::List<vl::Ptr<WfType>> baseTypes;
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfClassDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfEnumKind
		{
			Normal,
			Flag,
		};

		enum class WfEnumItemKind
		{
			Constant,
			Intersection,
		};

		class WfEnumItemIntersection : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfEnumItemIntersection>
		{
		public:
			vl::parsing::ParsingToken name;

			static vl::Ptr<WfEnumItemIntersection> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEnumItem : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfEnumItem>
		{
		public:
			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			WfEnumItemKind kind;
			vl::parsing::ParsingToken number;
			vl::collections::List<vl::Ptr<WfEnumItemIntersection>> intersections;

			static vl::Ptr<WfEnumItem> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfEnumDeclaration : public WfDeclaration, vl::reflection::Description<WfEnumDeclaration>
		{
		public:
			WfEnumKind kind;
			vl::collections::List<vl::Ptr<WfEnumItem>> items;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfEnumDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStructMember : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStructMember>
		{
		public:
			vl::collections::List<vl::Ptr<WfAttribute>> attributes;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfType> type;

			static vl::Ptr<WfStructMember> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStructDeclaration : public WfDeclaration, vl::reflection::Description<WfStructDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfStructMember>> members;

			void Accept(WfDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfStructDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCfeDeclaration abstract : public WfDeclaration, vl::reflection::Description<WfVirtualCfeDeclaration>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfAutoPropertyDeclaration* node)=0;
				virtual void Visit(WfCastResultInterfaceDeclaration* node)=0;
			};

			virtual void Accept(WfVirtualCfeDeclaration::IVisitor* visitor)=0;

			vl::collections::List<vl::Ptr<WfDeclaration>> expandedDeclarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;
		};

		enum class WfAPConst
		{
			Readonly,
			Writable,
		};

		enum class WfAPObserve
		{
			Observable,
			NotObservable,
		};

		class WfAutoPropertyDeclaration : public WfVirtualCfeDeclaration, vl::reflection::Description<WfAutoPropertyDeclaration>
		{
		public:
			vl::Ptr<WfType> type;
			WfAPConst configConst;
			WfAPObserve configObserve;
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCfeDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfAutoPropertyDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCastResultInterfaceDeclaration : public WfVirtualCfeDeclaration, vl::reflection::Description<WfCastResultInterfaceDeclaration>
		{
		public:
			vl::Ptr<WfType> baseType;
			vl::Ptr<WfType> elementType;

			void Accept(WfVirtualCfeDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfCastResultInterfaceDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCseDeclaration abstract : public WfDeclaration, vl::reflection::Description<WfVirtualCseDeclaration>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfStateMachineDeclaration* node)=0;
			};

			virtual void Accept(WfVirtualCseDeclaration::IVisitor* visitor)=0;

			vl::collections::List<vl::Ptr<WfDeclaration>> expandedDeclarations;

			void Accept(WfDeclaration::IVisitor* visitor)override;
		};

		class WfStateInput : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateInput>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;

			static vl::Ptr<WfStateInput> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateDeclaration : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateDeclaration>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfFunctionArgument>> arguments;
			vl::Ptr<WfStatement> statement;

			static vl::Ptr<WfStateDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateMachineDeclaration : public WfVirtualCseDeclaration, vl::reflection::Description<WfStateMachineDeclaration>
		{
		public:
			vl::collections::List<vl::Ptr<WfStateInput>> inputs;
			vl::collections::List<vl::Ptr<WfStateDeclaration>> states;

			void Accept(WfVirtualCseDeclaration::IVisitor* visitor)override;

			static vl::Ptr<WfStateMachineDeclaration> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfBreakStatement : public WfStatement, vl::reflection::Description<WfBreakStatement>
		{
		public:

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfBreakStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfContinueStatement : public WfStatement, vl::reflection::Description<WfContinueStatement>
		{
		public:

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfContinueStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReturnStatement : public WfStatement, vl::reflection::Description<WfReturnStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfReturnStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDeleteStatement : public WfStatement, vl::reflection::Description<WfDeleteStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfDeleteStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfRaiseExceptionStatement : public WfStatement, vl::reflection::Description<WfRaiseExceptionStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfRaiseExceptionStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIfStatement : public WfStatement, vl::reflection::Description<WfIfStatement>
		{
		public:
			vl::Ptr<WfType> type;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfStatement> trueBranch;
			vl::Ptr<WfStatement> falseBranch;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfIfStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfWhileStatement : public WfStatement, vl::reflection::Description<WfWhileStatement>
		{
		public:
			vl::Ptr<WfExpression> condition;
			vl::Ptr<WfStatement> statement;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfWhileStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTryStatement : public WfStatement, vl::reflection::Description<WfTryStatement>
		{
		public:
			vl::Ptr<WfStatement> protectedStatement;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfStatement> catchStatement;
			vl::Ptr<WfStatement> finallyStatement;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfTryStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfBlockStatement : public WfStatement, vl::reflection::Description<WfBlockStatement>
		{
		public:
			vl::collections::List<vl::Ptr<WfStatement>> statements;
			vl::parsing::ParsingToken endLabel;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfBlockStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfGotoStatement : public WfStatement, vl::reflection::Description<WfGotoStatement>
		{
		public:
			vl::parsing::ParsingToken label;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfGotoStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVariableStatement : public WfStatement, vl::reflection::Description<WfVariableStatement>
		{
		public:
			vl::Ptr<WfVariableDeclaration> variable;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfVariableStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfExpressionStatement : public WfStatement, vl::reflection::Description<WfExpressionStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfStatement::IVisitor* visitor)override;

			static vl::Ptr<WfExpressionStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCseStatement abstract : public WfStatement, vl::reflection::Description<WfVirtualCseStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfForEachStatement* node)=0;
				virtual void Visit(WfSwitchStatement* node)=0;
				virtual void Visit(WfCoProviderStatement* node)=0;
			};

			virtual void Accept(WfVirtualCseStatement::IVisitor* visitor)=0;

			vl::Ptr<WfStatement> expandedStatement;

			void Accept(WfStatement::IVisitor* visitor)override;
		};

		enum class WfForEachDirection
		{
			Normal,
			Reversed,
		};

		class WfForEachStatement : public WfVirtualCseStatement, vl::reflection::Description<WfForEachStatement>
		{
		public:
			vl::parsing::ParsingToken name;
			WfForEachDirection direction;
			vl::Ptr<WfExpression> collection;
			vl::Ptr<WfStatement> statement;

			void Accept(WfVirtualCseStatement::IVisitor* visitor)override;

			static vl::Ptr<WfForEachStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSwitchCase : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfSwitchCase>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfStatement> statement;

			static vl::Ptr<WfSwitchCase> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfSwitchStatement : public WfVirtualCseStatement, vl::reflection::Description<WfSwitchStatement>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::collections::List<vl::Ptr<WfSwitchCase>> caseBranches;
			vl::Ptr<WfStatement> defaultBranch;

			void Accept(WfVirtualCseStatement::IVisitor* visitor)override;

			static vl::Ptr<WfSwitchStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoProviderStatement : public WfVirtualCseStatement, vl::reflection::Description<WfCoProviderStatement>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfStatement> statement;

			void Accept(WfVirtualCseStatement::IVisitor* visitor)override;

			static vl::Ptr<WfCoProviderStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoroutineStatement abstract : public WfStatement, vl::reflection::Description<WfCoroutineStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfCoPauseStatement* node)=0;
				virtual void Visit(WfCoOperatorStatement* node)=0;
			};

			virtual void Accept(WfCoroutineStatement::IVisitor* visitor)=0;


			void Accept(WfStatement::IVisitor* visitor)override;
		};

		class WfCoPauseStatement : public WfCoroutineStatement, vl::reflection::Description<WfCoPauseStatement>
		{
		public:
			vl::Ptr<WfStatement> statement;

			void Accept(WfCoroutineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfCoPauseStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoOperatorStatement : public WfCoroutineStatement, vl::reflection::Description<WfCoOperatorStatement>
		{
		public:
			vl::parsing::ParsingToken varName;
			vl::parsing::ParsingToken opName;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfCoroutineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfCoOperatorStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfStateSwitchType
		{
			Default,
			Pass,
			PassAndReturn,
			Ignore,
			IgnoreAndReturn,
		};

		enum class WfStateInvokeType
		{
			Goto,
			Push,
		};

		class WfStateMachineStatement abstract : public WfStatement, vl::reflection::Description<WfStateMachineStatement>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfStateSwitchStatement* node)=0;
				virtual void Visit(WfStateInvokeStatement* node)=0;
			};

			virtual void Accept(WfStateMachineStatement::IVisitor* visitor)=0;


			void Accept(WfStatement::IVisitor* visitor)override;
		};

		class WfStateSwitchArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateSwitchArgument>
		{
		public:
			vl::parsing::ParsingToken name;

			static vl::Ptr<WfStateSwitchArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateSwitchCase : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfStateSwitchCase>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfStateSwitchArgument>> arguments;
			vl::Ptr<WfStatement> statement;

			static vl::Ptr<WfStateSwitchCase> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateSwitchStatement : public WfStateMachineStatement, vl::reflection::Description<WfStateSwitchStatement>
		{
		public:
			WfStateSwitchType type;
			vl::collections::List<vl::Ptr<WfStateSwitchCase>> caseBranches;

			void Accept(WfStateMachineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfStateSwitchStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStateInvokeStatement : public WfStateMachineStatement, vl::reflection::Description<WfStateInvokeStatement>
		{
		public:
			WfStateInvokeType type;
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfStateMachineStatement::IVisitor* visitor)override;

			static vl::Ptr<WfStateInvokeStatement> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfThisExpression : public WfExpression, vl::reflection::Description<WfThisExpression>
		{
		public:

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfThisExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTopQualifiedExpression : public WfExpression, vl::reflection::Description<WfTopQualifiedExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTopQualifiedExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfReferenceExpression : public WfExpression, vl::reflection::Description<WfReferenceExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfReferenceExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfOrderedNameExpression : public WfExpression, vl::reflection::Description<WfOrderedNameExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfOrderedNameExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfOrderedLambdaExpression : public WfExpression, vl::reflection::Description<WfOrderedLambdaExpression>
		{
		public:
			vl::Ptr<WfExpression> body;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfOrderedLambdaExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfMemberExpression : public WfExpression, vl::reflection::Description<WfMemberExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfMemberExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfChildExpression : public WfExpression, vl::reflection::Description<WfChildExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			vl::parsing::ParsingToken name;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfChildExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfLiteralValue
		{
			Null,
			True,
			False,
		};

		class WfLiteralExpression : public WfExpression, vl::reflection::Description<WfLiteralExpression>
		{
		public:
			WfLiteralValue value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfLiteralExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFloatingExpression : public WfExpression, vl::reflection::Description<WfFloatingExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFloatingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIntegerExpression : public WfExpression, vl::reflection::Description<WfIntegerExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfIntegerExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfStringExpression : public WfExpression, vl::reflection::Description<WfStringExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfStringExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfUnaryOperator
		{
			Positive,
			Negative,
			Not,
		};

		class WfUnaryExpression : public WfExpression, vl::reflection::Description<WfUnaryExpression>
		{
		public:
			WfUnaryOperator op;
			vl::Ptr<WfExpression> operand;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfUnaryExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfBinaryOperator
		{
			Assign,
			Index,
			Union,
			Intersect,
			FailedThen,
			Exp,
			Add,
			Sub,
			Mul,
			Div,
			Mod,
			Shl,
			Shr,
			LT,
			GT,
			LE,
			GE,
			EQ,
			NE,
			Xor,
			And,
			Or,
		};

		class WfBinaryExpression : public WfExpression, vl::reflection::Description<WfBinaryExpression>
		{
		public:
			WfBinaryOperator op;
			vl::Ptr<WfExpression> first;
			vl::Ptr<WfExpression> second;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfBinaryExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfLetVariable : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfLetVariable>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfLetVariable> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfLetExpression : public WfExpression, vl::reflection::Description<WfLetExpression>
		{
		public:
			vl::collections::List<vl::Ptr<WfLetVariable>> variables;
			vl::Ptr<WfExpression> expression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfLetExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfIfExpression : public WfExpression, vl::reflection::Description<WfIfExpression>
		{
		public:
			vl::Ptr<WfExpression> condition;
			vl::Ptr<WfExpression> trueBranch;
			vl::Ptr<WfExpression> falseBranch;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfIfExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfRangeBoundary
		{
			Inclusive,
			Exclusive,
		};

		class WfRangeExpression : public WfExpression, vl::reflection::Description<WfRangeExpression>
		{
		public:
			vl::Ptr<WfExpression> begin;
			WfRangeBoundary beginBoundary;
			vl::Ptr<WfExpression> end;
			WfRangeBoundary endBoundary;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfRangeExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfSetTesting
		{
			In,
			NotIn,
		};

		class WfSetTestingExpression : public WfExpression, vl::reflection::Description<WfSetTestingExpression>
		{
		public:
			WfSetTesting test;
			vl::Ptr<WfExpression> element;
			vl::Ptr<WfExpression> collection;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfSetTestingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorArgument : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfConstructorArgument>
		{
		public:
			vl::Ptr<WfExpression> key;
			vl::Ptr<WfExpression> value;

			static vl::Ptr<WfConstructorArgument> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfConstructorExpression : public WfExpression, vl::reflection::Description<WfConstructorExpression>
		{
		public:
			vl::collections::List<vl::Ptr<WfConstructorArgument>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfConstructorExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfInferExpression : public WfExpression, vl::reflection::Description<WfInferExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfInferExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfTypeCastingStrategy
		{
			Strong,
			Weak,
		};

		class WfTypeCastingExpression : public WfExpression, vl::reflection::Description<WfTypeCastingExpression>
		{
		public:
			WfTypeCastingStrategy strategy;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeCastingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfTypeTesting
		{
			IsType,
			IsNotType,
			IsNull,
			IsNotNull,
		};

		class WfTypeTestingExpression : public WfExpression, vl::reflection::Description<WfTypeTestingExpression>
		{
		public:
			WfTypeTesting test;
			vl::Ptr<WfExpression> expression;
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeTestingExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTypeOfTypeExpression : public WfExpression, vl::reflection::Description<WfTypeOfTypeExpression>
		{
		public:
			vl::Ptr<WfType> type;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeOfTypeExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfTypeOfExpressionExpression : public WfExpression, vl::reflection::Description<WfTypeOfExpressionExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfTypeOfExpressionExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfAttachEventExpression : public WfExpression, vl::reflection::Description<WfAttachEventExpression>
		{
		public:
			vl::Ptr<WfExpression> event;
			vl::Ptr<WfExpression> function;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfAttachEventExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfDetachEventExpression : public WfExpression, vl::reflection::Description<WfDetachEventExpression>
		{
		public:
			vl::Ptr<WfExpression> event;
			vl::Ptr<WfExpression> handler;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfDetachEventExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfObserveType
		{
			SimpleObserve,
			ExtendedObserve,
		};

		class WfObserveExpression : public WfExpression, vl::reflection::Description<WfObserveExpression>
		{
		public:
			vl::Ptr<WfExpression> parent;
			WfObserveType observeType;
			vl::parsing::ParsingToken name;
			vl::Ptr<WfExpression> expression;
			vl::collections::List<vl::Ptr<WfExpression>> events;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfObserveExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCallExpression : public WfExpression, vl::reflection::Description<WfCallExpression>
		{
		public:
			vl::Ptr<WfExpression> function;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfCallExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfFunctionExpression : public WfExpression, vl::reflection::Description<WfFunctionExpression>
		{
		public:
			vl::Ptr<WfFunctionDeclaration> function;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFunctionExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNewClassExpression : public WfExpression, vl::reflection::Description<WfNewClassExpression>
		{
		public:
			vl::Ptr<WfType> type;
			vl::collections::List<vl::Ptr<WfExpression>> arguments;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfNewClassExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNewInterfaceExpression : public WfExpression, vl::reflection::Description<WfNewInterfaceExpression>
		{
		public:
			vl::Ptr<WfType> type;
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			void Accept(WfExpression::IVisitor* visitor)override;

			static vl::Ptr<WfNewInterfaceExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCfeExpression abstract : public WfExpression, vl::reflection::Description<WfVirtualCfeExpression>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfFormatExpression* node)=0;
			};

			virtual void Accept(WfVirtualCfeExpression::IVisitor* visitor)=0;

			vl::Ptr<WfExpression> expandedExpression;

			void Accept(WfExpression::IVisitor* visitor)override;
		};

		class WfFormatExpression : public WfVirtualCfeExpression, vl::reflection::Description<WfFormatExpression>
		{
		public:
			vl::parsing::ParsingToken value;

			void Accept(WfVirtualCfeExpression::IVisitor* visitor)override;

			static vl::Ptr<WfFormatExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfVirtualCseExpression abstract : public WfExpression, vl::reflection::Description<WfVirtualCseExpression>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfBindExpression* node)=0;
				virtual void Visit(WfNewCoroutineExpression* node)=0;
				virtual void Visit(WfMixinCastExpression* node)=0;
				virtual void Visit(WfExpectedTypeCastExpression* node)=0;
				virtual void Visit(WfCoOperatorExpression* node)=0;
			};

			virtual void Accept(WfVirtualCseExpression::IVisitor* visitor)=0;

			vl::Ptr<WfExpression> expandedExpression;

			void Accept(WfExpression::IVisitor* visitor)override;
		};

		class WfBindExpression : public WfVirtualCseExpression, vl::reflection::Description<WfBindExpression>
		{
		public:
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfBindExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfNewCoroutineExpression : public WfVirtualCseExpression, vl::reflection::Description<WfNewCoroutineExpression>
		{
		public:
			vl::parsing::ParsingToken name;
			vl::Ptr<WfStatement> statement;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfNewCoroutineExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfMixinCastExpression : public WfVirtualCseExpression, vl::reflection::Description<WfMixinCastExpression>
		{
		public:
			vl::Ptr<WfType> type;
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfMixinCastExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfExpectedTypeCastExpression : public WfVirtualCseExpression, vl::reflection::Description<WfExpectedTypeCastExpression>
		{
		public:
			WfTypeCastingStrategy strategy;
			vl::Ptr<WfExpression> expression;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfExpectedTypeCastExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfCoOperatorExpression : public WfVirtualCseExpression, vl::reflection::Description<WfCoOperatorExpression>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfVirtualCseExpression::IVisitor* visitor)override;

			static vl::Ptr<WfCoOperatorExpression> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingFragment abstract : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingFragment>
		{
		public:
			class IVisitor : public vl::reflection::IDescriptable, vl::reflection::Description<IVisitor>
			{
			public:
				virtual void Visit(WfModuleUsingNameFragment* node)=0;
				virtual void Visit(WfModuleUsingWildCardFragment* node)=0;
			};

			virtual void Accept(WfModuleUsingFragment::IVisitor* visitor)=0;

		};

		class WfModuleUsingNameFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingNameFragment>
		{
		public:
			vl::parsing::ParsingToken name;

			void Accept(WfModuleUsingFragment::IVisitor* visitor)override;

			static vl::Ptr<WfModuleUsingNameFragment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingWildCardFragment : public WfModuleUsingFragment, vl::reflection::Description<WfModuleUsingWildCardFragment>
		{
		public:

			void Accept(WfModuleUsingFragment::IVisitor* visitor)override;

			static vl::Ptr<WfModuleUsingWildCardFragment> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingItem : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingItem>
		{
		public:
			vl::collections::List<vl::Ptr<WfModuleUsingFragment>> fragments;

			static vl::Ptr<WfModuleUsingItem> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		class WfModuleUsingPath : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModuleUsingPath>
		{
		public:
			vl::collections::List<vl::Ptr<WfModuleUsingItem>> items;

			static vl::Ptr<WfModuleUsingPath> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

		enum class WfModuleType
		{
			Module,
			Unit,
		};

		class WfModule : public vl::parsing::ParsingTreeCustomBase, vl::reflection::Description<WfModule>
		{
		public:
			WfModuleType moduleType;
			vl::parsing::ParsingToken name;
			vl::collections::List<vl::Ptr<WfModuleUsingPath>> paths;
			vl::collections::List<vl::Ptr<WfDeclaration>> declarations;

			static vl::Ptr<WfModule> Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		};

	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			DECL_TYPE_INFO(vl::workflow::WfClassMemberKind)
			DECL_TYPE_INFO(vl::workflow::WfClassMember)
			DECL_TYPE_INFO(vl::workflow::WfType)
			DECL_TYPE_INFO(vl::workflow::WfExpression)
			DECL_TYPE_INFO(vl::workflow::WfStatement)
			DECL_TYPE_INFO(vl::workflow::WfAttribute)
			DECL_TYPE_INFO(vl::workflow::WfDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfPredefinedTypeName)
			DECL_TYPE_INFO(vl::workflow::WfPredefinedType)
			DECL_TYPE_INFO(vl::workflow::WfTopQualifiedType)
			DECL_TYPE_INFO(vl::workflow::WfReferenceType)
			DECL_TYPE_INFO(vl::workflow::WfRawPointerType)
			DECL_TYPE_INFO(vl::workflow::WfSharedPointerType)
			DECL_TYPE_INFO(vl::workflow::WfNullableType)
			DECL_TYPE_INFO(vl::workflow::WfEnumerableType)
			DECL_TYPE_INFO(vl::workflow::WfMapWritability)
			DECL_TYPE_INFO(vl::workflow::WfMapType)
			DECL_TYPE_INFO(vl::workflow::WfObservableListType)
			DECL_TYPE_INFO(vl::workflow::WfFunctionType)
			DECL_TYPE_INFO(vl::workflow::WfChildType)
			DECL_TYPE_INFO(vl::workflow::WfNamespaceDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfFunctionArgument)
			DECL_TYPE_INFO(vl::workflow::WfFunctionAnonymity)
			DECL_TYPE_INFO(vl::workflow::WfFunctionDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfVariableDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfEventDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfPropertyDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfClassKind)
			DECL_TYPE_INFO(vl::workflow::WfConstructorType)
			DECL_TYPE_INFO(vl::workflow::WfBaseConstructorCall)
			DECL_TYPE_INFO(vl::workflow::WfConstructorDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfDestructorDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfClassDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfEnumKind)
			DECL_TYPE_INFO(vl::workflow::WfEnumItemKind)
			DECL_TYPE_INFO(vl::workflow::WfEnumItemIntersection)
			DECL_TYPE_INFO(vl::workflow::WfEnumItem)
			DECL_TYPE_INFO(vl::workflow::WfEnumDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfStructMember)
			DECL_TYPE_INFO(vl::workflow::WfStructDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfAPConst)
			DECL_TYPE_INFO(vl::workflow::WfAPObserve)
			DECL_TYPE_INFO(vl::workflow::WfAutoPropertyDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfCastResultInterfaceDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfStateInput)
			DECL_TYPE_INFO(vl::workflow::WfStateDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfStateMachineDeclaration)
			DECL_TYPE_INFO(vl::workflow::WfBreakStatement)
			DECL_TYPE_INFO(vl::workflow::WfContinueStatement)
			DECL_TYPE_INFO(vl::workflow::WfReturnStatement)
			DECL_TYPE_INFO(vl::workflow::WfDeleteStatement)
			DECL_TYPE_INFO(vl::workflow::WfRaiseExceptionStatement)
			DECL_TYPE_INFO(vl::workflow::WfIfStatement)
			DECL_TYPE_INFO(vl::workflow::WfWhileStatement)
			DECL_TYPE_INFO(vl::workflow::WfTryStatement)
			DECL_TYPE_INFO(vl::workflow::WfBlockStatement)
			DECL_TYPE_INFO(vl::workflow::WfGotoStatement)
			DECL_TYPE_INFO(vl::workflow::WfVariableStatement)
			DECL_TYPE_INFO(vl::workflow::WfExpressionStatement)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseStatement)
			DECL_TYPE_INFO(vl::workflow::WfForEachDirection)
			DECL_TYPE_INFO(vl::workflow::WfForEachStatement)
			DECL_TYPE_INFO(vl::workflow::WfSwitchCase)
			DECL_TYPE_INFO(vl::workflow::WfSwitchStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoProviderStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoroutineStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoPauseStatement)
			DECL_TYPE_INFO(vl::workflow::WfCoOperatorStatement)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchType)
			DECL_TYPE_INFO(vl::workflow::WfStateInvokeType)
			DECL_TYPE_INFO(vl::workflow::WfStateMachineStatement)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchArgument)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchCase)
			DECL_TYPE_INFO(vl::workflow::WfStateSwitchStatement)
			DECL_TYPE_INFO(vl::workflow::WfStateInvokeStatement)
			DECL_TYPE_INFO(vl::workflow::WfThisExpression)
			DECL_TYPE_INFO(vl::workflow::WfTopQualifiedExpression)
			DECL_TYPE_INFO(vl::workflow::WfReferenceExpression)
			DECL_TYPE_INFO(vl::workflow::WfOrderedNameExpression)
			DECL_TYPE_INFO(vl::workflow::WfOrderedLambdaExpression)
			DECL_TYPE_INFO(vl::workflow::WfMemberExpression)
			DECL_TYPE_INFO(vl::workflow::WfChildExpression)
			DECL_TYPE_INFO(vl::workflow::WfLiteralValue)
			DECL_TYPE_INFO(vl::workflow::WfLiteralExpression)
			DECL_TYPE_INFO(vl::workflow::WfFloatingExpression)
			DECL_TYPE_INFO(vl::workflow::WfIntegerExpression)
			DECL_TYPE_INFO(vl::workflow::WfStringExpression)
			DECL_TYPE_INFO(vl::workflow::WfUnaryOperator)
			DECL_TYPE_INFO(vl::workflow::WfUnaryExpression)
			DECL_TYPE_INFO(vl::workflow::WfBinaryOperator)
			DECL_TYPE_INFO(vl::workflow::WfBinaryExpression)
			DECL_TYPE_INFO(vl::workflow::WfLetVariable)
			DECL_TYPE_INFO(vl::workflow::WfLetExpression)
			DECL_TYPE_INFO(vl::workflow::WfIfExpression)
			DECL_TYPE_INFO(vl::workflow::WfRangeBoundary)
			DECL_TYPE_INFO(vl::workflow::WfRangeExpression)
			DECL_TYPE_INFO(vl::workflow::WfSetTesting)
			DECL_TYPE_INFO(vl::workflow::WfSetTestingExpression)
			DECL_TYPE_INFO(vl::workflow::WfConstructorArgument)
			DECL_TYPE_INFO(vl::workflow::WfConstructorExpression)
			DECL_TYPE_INFO(vl::workflow::WfInferExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeCastingStrategy)
			DECL_TYPE_INFO(vl::workflow::WfTypeCastingExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeTesting)
			DECL_TYPE_INFO(vl::workflow::WfTypeTestingExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeOfTypeExpression)
			DECL_TYPE_INFO(vl::workflow::WfTypeOfExpressionExpression)
			DECL_TYPE_INFO(vl::workflow::WfAttachEventExpression)
			DECL_TYPE_INFO(vl::workflow::WfDetachEventExpression)
			DECL_TYPE_INFO(vl::workflow::WfObserveType)
			DECL_TYPE_INFO(vl::workflow::WfObserveExpression)
			DECL_TYPE_INFO(vl::workflow::WfCallExpression)
			DECL_TYPE_INFO(vl::workflow::WfFunctionExpression)
			DECL_TYPE_INFO(vl::workflow::WfNewClassExpression)
			DECL_TYPE_INFO(vl::workflow::WfNewInterfaceExpression)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeExpression)
			DECL_TYPE_INFO(vl::workflow::WfFormatExpression)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseExpression)
			DECL_TYPE_INFO(vl::workflow::WfBindExpression)
			DECL_TYPE_INFO(vl::workflow::WfNewCoroutineExpression)
			DECL_TYPE_INFO(vl::workflow::WfMixinCastExpression)
			DECL_TYPE_INFO(vl::workflow::WfExpectedTypeCastExpression)
			DECL_TYPE_INFO(vl::workflow::WfCoOperatorExpression)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingNameFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingWildCardFragment)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingItem)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingPath)
			DECL_TYPE_INFO(vl::workflow::WfModuleType)
			DECL_TYPE_INFO(vl::workflow::WfModule)
			DECL_TYPE_INFO(vl::workflow::WfType::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfExpression::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfDeclaration::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseDeclaration::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfCoroutineStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfStateMachineStatement::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCfeExpression::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfVirtualCseExpression::IVisitor)
			DECL_TYPE_INFO(vl::workflow::WfModuleUsingFragment::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfType::IVisitor)
				void Visit(vl::workflow::WfPredefinedType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTopQualifiedType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfReferenceType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfRawPointerType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfSharedPointerType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNullableType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfEnumerableType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfMapType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfObservableListType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFunctionType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfChildType* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfType::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfExpression::IVisitor)
				void Visit(vl::workflow::WfThisExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTopQualifiedExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfReferenceExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfOrderedNameExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfOrderedLambdaExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfMemberExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfChildExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfLiteralExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFloatingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfIntegerExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStringExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfUnaryExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfBinaryExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfLetExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfIfExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfRangeExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfSetTestingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfConstructorExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfInferExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeCastingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeTestingExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeOfTypeExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTypeOfExpressionExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfAttachEventExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfDetachEventExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfObserveExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCallExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFunctionExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNewClassExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNewInterfaceExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCfeExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCseExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfExpression::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfStatement::IVisitor)
				void Visit(vl::workflow::WfBreakStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfContinueStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfReturnStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfDeleteStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfRaiseExceptionStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfIfStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfWhileStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfTryStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfBlockStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfGotoStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVariableStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfExpressionStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCseStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoroutineStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStateMachineStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfDeclaration::IVisitor)
				void Visit(vl::workflow::WfNamespaceDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfFunctionDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVariableDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfEventDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfPropertyDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfConstructorDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfDestructorDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfClassDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfEnumDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStructDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCfeDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfVirtualCseDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfDeclaration::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCfeDeclaration::IVisitor)
				void Visit(vl::workflow::WfAutoPropertyDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCastResultInterfaceDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCfeDeclaration::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseDeclaration::IVisitor)
				void Visit(vl::workflow::WfStateMachineDeclaration* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCseDeclaration::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseStatement::IVisitor)
				void Visit(vl::workflow::WfForEachStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfSwitchStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoProviderStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCseStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfCoroutineStatement::IVisitor)
				void Visit(vl::workflow::WfCoPauseStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoOperatorStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfCoroutineStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfStateMachineStatement::IVisitor)
				void Visit(vl::workflow::WfStateSwitchStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfStateInvokeStatement* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfStateMachineStatement::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCfeExpression::IVisitor)
				void Visit(vl::workflow::WfFormatExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCfeExpression::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfVirtualCseExpression::IVisitor)
				void Visit(vl::workflow::WfBindExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfNewCoroutineExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfMixinCastExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfExpectedTypeCastExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfCoOperatorExpression* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfVirtualCseExpression::IVisitor)

			BEGIN_INTERFACE_PROXY_NOPARENT_SHAREDPTR(vl::workflow::WfModuleUsingFragment::IVisitor)
				void Visit(vl::workflow::WfModuleUsingNameFragment* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

				void Visit(vl::workflow::WfModuleUsingWildCardFragment* node)override
				{
					INVOKE_INTERFACE_PROXY(Visit, node);
				}

			END_INTERFACE_PROXY(vl::workflow::WfModuleUsingFragment::IVisitor)

#endif
			extern bool WfLoadTypes();
		}
	}
}
#endif

/***********************************************************************
.\EXPRESSION\WFEXPRESSION_PARSER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_PARSER
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_PARSER


namespace vl
{
	namespace workflow
	{
		extern vl::WString WfGetParserTextBuffer();
		extern vl::Ptr<vl::parsing::ParsingTreeCustomBase> WfConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens);
		extern vl::Ptr<vl::parsing::tabling::ParsingTable> WfLoadTable();

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseCoProviderStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseCoProviderStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfStatement> WfParseCoProviderStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfStatement> WfParseCoProviderStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseDeclarationAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfDeclaration> WfParseDeclaration(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseExpressionAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfExpression> WfParseExpression(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseModuleAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfModule> WfParseModule(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseStatementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfStatement> WfParseStatement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);

		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<vl::parsing::ParsingTreeNode> WfParseTypeAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
		extern vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex = -1);
		extern vl::Ptr<WfType> WfParseType(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex = -1);
	}
}
#endif

/***********************************************************************
.\EXPRESSION\WFEXPRESSION_COPY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_COPY
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_COPY


namespace vl
{
	namespace workflow
	{
		namespace copy_visitor
		{
			class VisitorBase : public Object
			{
			public:
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> result;
			};

			class TypeVisitor : public virtual VisitorBase, public WfType::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfPredefinedType* from, WfPredefinedType* to);
				void CopyFields(WfType* from, WfType* to);
				void CopyFields(WfTopQualifiedType* from, WfTopQualifiedType* to);
				void CopyFields(WfReferenceType* from, WfReferenceType* to);
				void CopyFields(WfRawPointerType* from, WfRawPointerType* to);
				void CopyFields(WfSharedPointerType* from, WfSharedPointerType* to);
				void CopyFields(WfNullableType* from, WfNullableType* to);
				void CopyFields(WfEnumerableType* from, WfEnumerableType* to);
				void CopyFields(WfMapType* from, WfMapType* to);
				void CopyFields(WfObservableListType* from, WfObservableListType* to);
				void CopyFields(WfFunctionType* from, WfFunctionType* to);
				void CopyFields(WfChildType* from, WfChildType* to);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfPredefinedType* node)override;
				void Visit(WfTopQualifiedType* node)override;
				void Visit(WfReferenceType* node)override;
				void Visit(WfRawPointerType* node)override;
				void Visit(WfSharedPointerType* node)override;
				void Visit(WfNullableType* node)override;
				void Visit(WfEnumerableType* node)override;
				void Visit(WfMapType* node)override;
				void Visit(WfObservableListType* node)override;
				void Visit(WfFunctionType* node)override;
				void Visit(WfChildType* node)override;
			};

			class ExpressionVisitor : public virtual VisitorBase, public WfExpression::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfThisExpression* from, WfThisExpression* to);
				void CopyFields(WfExpression* from, WfExpression* to);
				void CopyFields(WfTopQualifiedExpression* from, WfTopQualifiedExpression* to);
				void CopyFields(WfReferenceExpression* from, WfReferenceExpression* to);
				void CopyFields(WfOrderedNameExpression* from, WfOrderedNameExpression* to);
				void CopyFields(WfOrderedLambdaExpression* from, WfOrderedLambdaExpression* to);
				void CopyFields(WfMemberExpression* from, WfMemberExpression* to);
				void CopyFields(WfChildExpression* from, WfChildExpression* to);
				void CopyFields(WfLiteralExpression* from, WfLiteralExpression* to);
				void CopyFields(WfFloatingExpression* from, WfFloatingExpression* to);
				void CopyFields(WfIntegerExpression* from, WfIntegerExpression* to);
				void CopyFields(WfStringExpression* from, WfStringExpression* to);
				void CopyFields(WfUnaryExpression* from, WfUnaryExpression* to);
				void CopyFields(WfBinaryExpression* from, WfBinaryExpression* to);
				void CopyFields(WfLetExpression* from, WfLetExpression* to);
				void CopyFields(WfLetVariable* from, WfLetVariable* to);
				void CopyFields(WfIfExpression* from, WfIfExpression* to);
				void CopyFields(WfRangeExpression* from, WfRangeExpression* to);
				void CopyFields(WfSetTestingExpression* from, WfSetTestingExpression* to);
				void CopyFields(WfConstructorExpression* from, WfConstructorExpression* to);
				void CopyFields(WfConstructorArgument* from, WfConstructorArgument* to);
				void CopyFields(WfInferExpression* from, WfInferExpression* to);
				void CopyFields(WfTypeCastingExpression* from, WfTypeCastingExpression* to);
				void CopyFields(WfTypeTestingExpression* from, WfTypeTestingExpression* to);
				void CopyFields(WfTypeOfTypeExpression* from, WfTypeOfTypeExpression* to);
				void CopyFields(WfTypeOfExpressionExpression* from, WfTypeOfExpressionExpression* to);
				void CopyFields(WfAttachEventExpression* from, WfAttachEventExpression* to);
				void CopyFields(WfDetachEventExpression* from, WfDetachEventExpression* to);
				void CopyFields(WfObserveExpression* from, WfObserveExpression* to);
				void CopyFields(WfCallExpression* from, WfCallExpression* to);
				void CopyFields(WfFunctionExpression* from, WfFunctionExpression* to);
				void CopyFields(WfFunctionDeclaration* from, WfFunctionDeclaration* to);
				void CopyFields(WfDeclaration* from, WfDeclaration* to);
				void CopyFields(WfAttribute* from, WfAttribute* to);
				void CopyFields(WfClassMember* from, WfClassMember* to);
				void CopyFields(WfFunctionArgument* from, WfFunctionArgument* to);
				void CopyFields(WfNewClassExpression* from, WfNewClassExpression* to);
				void CopyFields(WfNewInterfaceExpression* from, WfNewInterfaceExpression* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfLetVariable> CreateField(vl::Ptr<WfLetVariable> from);
				vl::Ptr<WfConstructorArgument> CreateField(vl::Ptr<WfConstructorArgument> from);
				vl::Ptr<WfFunctionDeclaration> CreateField(vl::Ptr<WfFunctionDeclaration> from);
				vl::Ptr<WfAttribute> CreateField(vl::Ptr<WfAttribute> from);
				vl::Ptr<WfClassMember> CreateField(vl::Ptr<WfClassMember> from);
				vl::Ptr<WfFunctionArgument> CreateField(vl::Ptr<WfFunctionArgument> from);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;
				virtual vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from) = 0;
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;
				virtual vl::Ptr<WfDeclaration> CreateField(vl::Ptr<WfDeclaration> from) = 0;

				// Dispatch (virtual) --------------------------------
				virtual vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCfeExpression* node) = 0;
				virtual vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCseExpression* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfThisExpression* node)override;
				void Visit(WfTopQualifiedExpression* node)override;
				void Visit(WfReferenceExpression* node)override;
				void Visit(WfOrderedNameExpression* node)override;
				void Visit(WfOrderedLambdaExpression* node)override;
				void Visit(WfMemberExpression* node)override;
				void Visit(WfChildExpression* node)override;
				void Visit(WfLiteralExpression* node)override;
				void Visit(WfFloatingExpression* node)override;
				void Visit(WfIntegerExpression* node)override;
				void Visit(WfStringExpression* node)override;
				void Visit(WfUnaryExpression* node)override;
				void Visit(WfBinaryExpression* node)override;
				void Visit(WfLetExpression* node)override;
				void Visit(WfIfExpression* node)override;
				void Visit(WfRangeExpression* node)override;
				void Visit(WfSetTestingExpression* node)override;
				void Visit(WfConstructorExpression* node)override;
				void Visit(WfInferExpression* node)override;
				void Visit(WfTypeCastingExpression* node)override;
				void Visit(WfTypeTestingExpression* node)override;
				void Visit(WfTypeOfTypeExpression* node)override;
				void Visit(WfTypeOfExpressionExpression* node)override;
				void Visit(WfAttachEventExpression* node)override;
				void Visit(WfDetachEventExpression* node)override;
				void Visit(WfObserveExpression* node)override;
				void Visit(WfCallExpression* node)override;
				void Visit(WfFunctionExpression* node)override;
				void Visit(WfNewClassExpression* node)override;
				void Visit(WfNewInterfaceExpression* node)override;
				void Visit(WfVirtualCfeExpression* node)override;
				void Visit(WfVirtualCseExpression* node)override;
			};

			class StatementVisitor : public virtual VisitorBase, public WfStatement::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfBreakStatement* from, WfBreakStatement* to);
				void CopyFields(WfStatement* from, WfStatement* to);
				void CopyFields(WfContinueStatement* from, WfContinueStatement* to);
				void CopyFields(WfReturnStatement* from, WfReturnStatement* to);
				void CopyFields(WfDeleteStatement* from, WfDeleteStatement* to);
				void CopyFields(WfRaiseExceptionStatement* from, WfRaiseExceptionStatement* to);
				void CopyFields(WfIfStatement* from, WfIfStatement* to);
				void CopyFields(WfWhileStatement* from, WfWhileStatement* to);
				void CopyFields(WfTryStatement* from, WfTryStatement* to);
				void CopyFields(WfBlockStatement* from, WfBlockStatement* to);
				void CopyFields(WfGotoStatement* from, WfGotoStatement* to);
				void CopyFields(WfVariableStatement* from, WfVariableStatement* to);
				void CopyFields(WfVariableDeclaration* from, WfVariableDeclaration* to);
				void CopyFields(WfDeclaration* from, WfDeclaration* to);
				void CopyFields(WfAttribute* from, WfAttribute* to);
				void CopyFields(WfClassMember* from, WfClassMember* to);
				void CopyFields(WfExpressionStatement* from, WfExpressionStatement* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfVariableDeclaration> CreateField(vl::Ptr<WfVariableDeclaration> from);
				vl::Ptr<WfAttribute> CreateField(vl::Ptr<WfAttribute> from);
				vl::Ptr<WfClassMember> CreateField(vl::Ptr<WfClassMember> from);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;
				virtual vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from) = 0;
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;

				// Dispatch (virtual) --------------------------------
				virtual vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCseStatement* node) = 0;
				virtual vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfCoroutineStatement* node) = 0;
				virtual vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfStateMachineStatement* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfBreakStatement* node)override;
				void Visit(WfContinueStatement* node)override;
				void Visit(WfReturnStatement* node)override;
				void Visit(WfDeleteStatement* node)override;
				void Visit(WfRaiseExceptionStatement* node)override;
				void Visit(WfIfStatement* node)override;
				void Visit(WfWhileStatement* node)override;
				void Visit(WfTryStatement* node)override;
				void Visit(WfBlockStatement* node)override;
				void Visit(WfGotoStatement* node)override;
				void Visit(WfVariableStatement* node)override;
				void Visit(WfExpressionStatement* node)override;
				void Visit(WfVirtualCseStatement* node)override;
				void Visit(WfCoroutineStatement* node)override;
				void Visit(WfStateMachineStatement* node)override;
			};

			class DeclarationVisitor : public virtual VisitorBase, public WfDeclaration::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfNamespaceDeclaration* from, WfNamespaceDeclaration* to);
				void CopyFields(WfDeclaration* from, WfDeclaration* to);
				void CopyFields(WfAttribute* from, WfAttribute* to);
				void CopyFields(WfClassMember* from, WfClassMember* to);
				void CopyFields(WfFunctionDeclaration* from, WfFunctionDeclaration* to);
				void CopyFields(WfFunctionArgument* from, WfFunctionArgument* to);
				void CopyFields(WfVariableDeclaration* from, WfVariableDeclaration* to);
				void CopyFields(WfEventDeclaration* from, WfEventDeclaration* to);
				void CopyFields(WfPropertyDeclaration* from, WfPropertyDeclaration* to);
				void CopyFields(WfConstructorDeclaration* from, WfConstructorDeclaration* to);
				void CopyFields(WfBaseConstructorCall* from, WfBaseConstructorCall* to);
				void CopyFields(WfDestructorDeclaration* from, WfDestructorDeclaration* to);
				void CopyFields(WfClassDeclaration* from, WfClassDeclaration* to);
				void CopyFields(WfEnumDeclaration* from, WfEnumDeclaration* to);
				void CopyFields(WfEnumItem* from, WfEnumItem* to);
				void CopyFields(WfEnumItemIntersection* from, WfEnumItemIntersection* to);
				void CopyFields(WfStructDeclaration* from, WfStructDeclaration* to);
				void CopyFields(WfStructMember* from, WfStructMember* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfAttribute> CreateField(vl::Ptr<WfAttribute> from);
				vl::Ptr<WfClassMember> CreateField(vl::Ptr<WfClassMember> from);
				vl::Ptr<WfFunctionArgument> CreateField(vl::Ptr<WfFunctionArgument> from);
				vl::Ptr<WfBaseConstructorCall> CreateField(vl::Ptr<WfBaseConstructorCall> from);
				vl::Ptr<WfEnumItem> CreateField(vl::Ptr<WfEnumItem> from);
				vl::Ptr<WfEnumItemIntersection> CreateField(vl::Ptr<WfEnumItemIntersection> from);
				vl::Ptr<WfStructMember> CreateField(vl::Ptr<WfStructMember> from);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;
				virtual vl::Ptr<WfDeclaration> CreateField(vl::Ptr<WfDeclaration> from) = 0;
				virtual vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from) = 0;
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;

				// Dispatch (virtual) --------------------------------
				virtual vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCfeDeclaration* node) = 0;
				virtual vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCseDeclaration* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfNamespaceDeclaration* node)override;
				void Visit(WfFunctionDeclaration* node)override;
				void Visit(WfVariableDeclaration* node)override;
				void Visit(WfEventDeclaration* node)override;
				void Visit(WfPropertyDeclaration* node)override;
				void Visit(WfConstructorDeclaration* node)override;
				void Visit(WfDestructorDeclaration* node)override;
				void Visit(WfClassDeclaration* node)override;
				void Visit(WfEnumDeclaration* node)override;
				void Visit(WfStructDeclaration* node)override;
				void Visit(WfVirtualCfeDeclaration* node)override;
				void Visit(WfVirtualCseDeclaration* node)override;
			};

			class VirtualCfeDeclarationVisitor : public virtual VisitorBase, public WfVirtualCfeDeclaration::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfAutoPropertyDeclaration* from, WfAutoPropertyDeclaration* to);
				void CopyFields(WfVirtualCfeDeclaration* from, WfVirtualCfeDeclaration* to);
				void CopyFields(WfDeclaration* from, WfDeclaration* to);
				void CopyFields(WfAttribute* from, WfAttribute* to);
				void CopyFields(WfClassMember* from, WfClassMember* to);
				void CopyFields(WfCastResultInterfaceDeclaration* from, WfCastResultInterfaceDeclaration* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfAttribute> CreateField(vl::Ptr<WfAttribute> from);
				vl::Ptr<WfClassMember> CreateField(vl::Ptr<WfClassMember> from);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;
				virtual vl::Ptr<WfDeclaration> CreateField(vl::Ptr<WfDeclaration> from) = 0;
				virtual vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfAutoPropertyDeclaration* node)override;
				void Visit(WfCastResultInterfaceDeclaration* node)override;
			};

			class VirtualCseDeclarationVisitor : public virtual VisitorBase, public WfVirtualCseDeclaration::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfStateMachineDeclaration* from, WfStateMachineDeclaration* to);
				void CopyFields(WfVirtualCseDeclaration* from, WfVirtualCseDeclaration* to);
				void CopyFields(WfDeclaration* from, WfDeclaration* to);
				void CopyFields(WfAttribute* from, WfAttribute* to);
				void CopyFields(WfClassMember* from, WfClassMember* to);
				void CopyFields(WfStateInput* from, WfStateInput* to);
				void CopyFields(WfFunctionArgument* from, WfFunctionArgument* to);
				void CopyFields(WfStateDeclaration* from, WfStateDeclaration* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfAttribute> CreateField(vl::Ptr<WfAttribute> from);
				vl::Ptr<WfClassMember> CreateField(vl::Ptr<WfClassMember> from);
				vl::Ptr<WfStateInput> CreateField(vl::Ptr<WfStateInput> from);
				vl::Ptr<WfFunctionArgument> CreateField(vl::Ptr<WfFunctionArgument> from);
				vl::Ptr<WfStateDeclaration> CreateField(vl::Ptr<WfStateDeclaration> from);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;
				virtual vl::Ptr<WfDeclaration> CreateField(vl::Ptr<WfDeclaration> from) = 0;
				virtual vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from) = 0;
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfStateMachineDeclaration* node)override;
			};

			class VirtualCseStatementVisitor : public virtual VisitorBase, public WfVirtualCseStatement::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfForEachStatement* from, WfForEachStatement* to);
				void CopyFields(WfVirtualCseStatement* from, WfVirtualCseStatement* to);
				void CopyFields(WfStatement* from, WfStatement* to);
				void CopyFields(WfSwitchStatement* from, WfSwitchStatement* to);
				void CopyFields(WfSwitchCase* from, WfSwitchCase* to);
				void CopyFields(WfCoProviderStatement* from, WfCoProviderStatement* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfSwitchCase> CreateField(vl::Ptr<WfSwitchCase> from);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfForEachStatement* node)override;
				void Visit(WfSwitchStatement* node)override;
				void Visit(WfCoProviderStatement* node)override;
			};

			class CoroutineStatementVisitor : public virtual VisitorBase, public WfCoroutineStatement::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfCoPauseStatement* from, WfCoPauseStatement* to);
				void CopyFields(WfCoroutineStatement* from, WfCoroutineStatement* to);
				void CopyFields(WfStatement* from, WfStatement* to);
				void CopyFields(WfCoOperatorStatement* from, WfCoOperatorStatement* to);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfCoPauseStatement* node)override;
				void Visit(WfCoOperatorStatement* node)override;
			};

			class StateMachineStatementVisitor : public virtual VisitorBase, public WfStateMachineStatement::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfStateSwitchStatement* from, WfStateSwitchStatement* to);
				void CopyFields(WfStateMachineStatement* from, WfStateMachineStatement* to);
				void CopyFields(WfStatement* from, WfStatement* to);
				void CopyFields(WfStateSwitchCase* from, WfStateSwitchCase* to);
				void CopyFields(WfStateSwitchArgument* from, WfStateSwitchArgument* to);
				void CopyFields(WfStateInvokeStatement* from, WfStateInvokeStatement* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfStateSwitchCase> CreateField(vl::Ptr<WfStateSwitchCase> from);
				vl::Ptr<WfStateSwitchArgument> CreateField(vl::Ptr<WfStateSwitchArgument> from);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfStateSwitchStatement* node)override;
				void Visit(WfStateInvokeStatement* node)override;
			};

			class VirtualCfeExpressionVisitor : public virtual VisitorBase, public WfVirtualCfeExpression::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfFormatExpression* from, WfFormatExpression* to);
				void CopyFields(WfVirtualCfeExpression* from, WfVirtualCfeExpression* to);
				void CopyFields(WfExpression* from, WfExpression* to);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfFormatExpression* node)override;
			};

			class VirtualCseExpressionVisitor : public virtual VisitorBase, public WfVirtualCseExpression::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfBindExpression* from, WfBindExpression* to);
				void CopyFields(WfVirtualCseExpression* from, WfVirtualCseExpression* to);
				void CopyFields(WfExpression* from, WfExpression* to);
				void CopyFields(WfNewCoroutineExpression* from, WfNewCoroutineExpression* to);
				void CopyFields(WfMixinCastExpression* from, WfMixinCastExpression* to);
				void CopyFields(WfExpectedTypeCastExpression* from, WfExpectedTypeCastExpression* to);
				void CopyFields(WfCoOperatorExpression* from, WfCoOperatorExpression* to);

				// CreateField (virtual) -----------------------------
				virtual vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from) = 0;
				virtual vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from) = 0;
				virtual vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfBindExpression* node)override;
				void Visit(WfNewCoroutineExpression* node)override;
				void Visit(WfMixinCastExpression* node)override;
				void Visit(WfExpectedTypeCastExpression* node)override;
				void Visit(WfCoOperatorExpression* node)override;
			};

			class ModuleUsingFragmentVisitor : public virtual VisitorBase, public WfModuleUsingFragment::IVisitor
			{
			public:

				// CopyFields ----------------------------------------
				void CopyFields(WfModuleUsingNameFragment* from, WfModuleUsingNameFragment* to);
				void CopyFields(WfModuleUsingFragment* from, WfModuleUsingFragment* to);
				void CopyFields(WfModuleUsingWildCardFragment* from, WfModuleUsingWildCardFragment* to);

				// Visitor Members -----------------------------------
				void Visit(WfModuleUsingNameFragment* node)override;
				void Visit(WfModuleUsingWildCardFragment* node)override;
			};

			class ModuleVisitor
				: public TypeVisitor
				, public ExpressionVisitor
				, public StatementVisitor
				, public DeclarationVisitor
				, public VirtualCfeDeclarationVisitor
				, public VirtualCseDeclarationVisitor
				, public VirtualCseStatementVisitor
				, public CoroutineStatementVisitor
				, public StateMachineStatementVisitor
				, public VirtualCfeExpressionVisitor
				, public VirtualCseExpressionVisitor
				, public ModuleUsingFragmentVisitor
			{
			public:
				vl::Ptr<WfModule> CreateField(vl::Ptr<WfModule> from);

				// CopyFields ----------------------------------------
				void CopyFields(WfModule* from, WfModule* to);
				void CopyFields(WfModuleUsingPath* from, WfModuleUsingPath* to);
				void CopyFields(WfModuleUsingItem* from, WfModuleUsingItem* to);

				// CreateField ---------------------------------------
				vl::Ptr<WfModuleUsingPath> CreateField(vl::Ptr<WfModuleUsingPath> from);
				vl::Ptr<WfModuleUsingItem> CreateField(vl::Ptr<WfModuleUsingItem> from);

				// CreateField (virtual) -----------------------------
				vl::Ptr<WfType> CreateField(vl::Ptr<WfType> from);
				vl::Ptr<WfExpression> CreateField(vl::Ptr<WfExpression> from);
				vl::Ptr<WfStatement> CreateField(vl::Ptr<WfStatement> from);
				vl::Ptr<WfDeclaration> CreateField(vl::Ptr<WfDeclaration> from);
				vl::Ptr<WfModuleUsingFragment> CreateField(vl::Ptr<WfModuleUsingFragment> from);

				// Dispatch (virtual) --------------------------------
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCfeExpression* node);
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCseExpression* node);
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCseStatement* node);
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfCoroutineStatement* node);
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfStateMachineStatement* node);
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCfeDeclaration* node);
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> Dispatch(WfVirtualCseDeclaration* node);
			};
		}
	}
}
#endif

/***********************************************************************
.\EXPRESSION\WFEXPRESSION_TRAVERSE.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_TRAVERSE
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_TRAVERSE


namespace vl
{
	namespace workflow
	{
		namespace traverse_visitor
		{
			class TypeVisitor : public Object, public WfType::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfPredefinedType* node);
				virtual void Traverse(WfType* node);
				virtual void Traverse(WfTopQualifiedType* node);
				virtual void Traverse(WfReferenceType* node);
				virtual void Traverse(WfRawPointerType* node);
				virtual void Traverse(WfSharedPointerType* node);
				virtual void Traverse(WfNullableType* node);
				virtual void Traverse(WfEnumerableType* node);
				virtual void Traverse(WfMapType* node);
				virtual void Traverse(WfObservableListType* node);
				virtual void Traverse(WfFunctionType* node);
				virtual void Traverse(WfChildType* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfType* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfPredefinedType* node)override;
				void Visit(WfTopQualifiedType* node)override;
				void Visit(WfReferenceType* node)override;
				void Visit(WfRawPointerType* node)override;
				void Visit(WfSharedPointerType* node)override;
				void Visit(WfNullableType* node)override;
				void Visit(WfEnumerableType* node)override;
				void Visit(WfMapType* node)override;
				void Visit(WfObservableListType* node)override;
				void Visit(WfFunctionType* node)override;
				void Visit(WfChildType* node)override;
			};

			class ExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfThisExpression* node);
				virtual void Traverse(WfExpression* node);
				virtual void Traverse(WfTopQualifiedExpression* node);
				virtual void Traverse(WfReferenceExpression* node);
				virtual void Traverse(WfOrderedNameExpression* node);
				virtual void Traverse(WfOrderedLambdaExpression* node);
				virtual void Traverse(WfMemberExpression* node);
				virtual void Traverse(WfChildExpression* node);
				virtual void Traverse(WfLiteralExpression* node);
				virtual void Traverse(WfFloatingExpression* node);
				virtual void Traverse(WfIntegerExpression* node);
				virtual void Traverse(WfStringExpression* node);
				virtual void Traverse(WfUnaryExpression* node);
				virtual void Traverse(WfBinaryExpression* node);
				virtual void Traverse(WfLetExpression* node);
				virtual void Traverse(WfLetVariable* node);
				virtual void Traverse(WfIfExpression* node);
				virtual void Traverse(WfRangeExpression* node);
				virtual void Traverse(WfSetTestingExpression* node);
				virtual void Traverse(WfConstructorExpression* node);
				virtual void Traverse(WfConstructorArgument* node);
				virtual void Traverse(WfInferExpression* node);
				virtual void Traverse(WfTypeCastingExpression* node);
				virtual void Traverse(WfTypeTestingExpression* node);
				virtual void Traverse(WfTypeOfTypeExpression* node);
				virtual void Traverse(WfTypeOfExpressionExpression* node);
				virtual void Traverse(WfAttachEventExpression* node);
				virtual void Traverse(WfDetachEventExpression* node);
				virtual void Traverse(WfObserveExpression* node);
				virtual void Traverse(WfCallExpression* node);
				virtual void Traverse(WfFunctionExpression* node);
				virtual void Traverse(WfFunctionDeclaration* node);
				virtual void Traverse(WfDeclaration* node);
				virtual void Traverse(WfAttribute* node);
				virtual void Traverse(WfClassMember* node);
				virtual void Traverse(WfFunctionArgument* node);
				virtual void Traverse(WfNewClassExpression* node);
				virtual void Traverse(WfNewInterfaceExpression* node);

				// VisitField ----------------------------------------
				void VisitField(WfLetVariable* node);
				void VisitField(WfConstructorArgument* node);
				void VisitField(WfFunctionDeclaration* node);
				void VisitField(WfAttribute* node);
				void VisitField(WfClassMember* node);
				void VisitField(WfFunctionArgument* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfExpression* node) = 0;
				virtual void VisitField(WfType* node) = 0;
				virtual void VisitField(WfStatement* node) = 0;
				virtual void VisitField(WfDeclaration* node) = 0;

				// Dispatch (virtual) --------------------------------
				virtual void Dispatch(WfVirtualCfeExpression* node) = 0;
				virtual void Dispatch(WfVirtualCseExpression* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfThisExpression* node)override;
				void Visit(WfTopQualifiedExpression* node)override;
				void Visit(WfReferenceExpression* node)override;
				void Visit(WfOrderedNameExpression* node)override;
				void Visit(WfOrderedLambdaExpression* node)override;
				void Visit(WfMemberExpression* node)override;
				void Visit(WfChildExpression* node)override;
				void Visit(WfLiteralExpression* node)override;
				void Visit(WfFloatingExpression* node)override;
				void Visit(WfIntegerExpression* node)override;
				void Visit(WfStringExpression* node)override;
				void Visit(WfUnaryExpression* node)override;
				void Visit(WfBinaryExpression* node)override;
				void Visit(WfLetExpression* node)override;
				void Visit(WfIfExpression* node)override;
				void Visit(WfRangeExpression* node)override;
				void Visit(WfSetTestingExpression* node)override;
				void Visit(WfConstructorExpression* node)override;
				void Visit(WfInferExpression* node)override;
				void Visit(WfTypeCastingExpression* node)override;
				void Visit(WfTypeTestingExpression* node)override;
				void Visit(WfTypeOfTypeExpression* node)override;
				void Visit(WfTypeOfExpressionExpression* node)override;
				void Visit(WfAttachEventExpression* node)override;
				void Visit(WfDetachEventExpression* node)override;
				void Visit(WfObserveExpression* node)override;
				void Visit(WfCallExpression* node)override;
				void Visit(WfFunctionExpression* node)override;
				void Visit(WfNewClassExpression* node)override;
				void Visit(WfNewInterfaceExpression* node)override;
				void Visit(WfVirtualCfeExpression* node)override;
				void Visit(WfVirtualCseExpression* node)override;
			};

			class StatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfBreakStatement* node);
				virtual void Traverse(WfStatement* node);
				virtual void Traverse(WfContinueStatement* node);
				virtual void Traverse(WfReturnStatement* node);
				virtual void Traverse(WfDeleteStatement* node);
				virtual void Traverse(WfRaiseExceptionStatement* node);
				virtual void Traverse(WfIfStatement* node);
				virtual void Traverse(WfWhileStatement* node);
				virtual void Traverse(WfTryStatement* node);
				virtual void Traverse(WfBlockStatement* node);
				virtual void Traverse(WfGotoStatement* node);
				virtual void Traverse(WfVariableStatement* node);
				virtual void Traverse(WfVariableDeclaration* node);
				virtual void Traverse(WfDeclaration* node);
				virtual void Traverse(WfAttribute* node);
				virtual void Traverse(WfClassMember* node);
				virtual void Traverse(WfExpressionStatement* node);

				// VisitField ----------------------------------------
				void VisitField(WfVariableDeclaration* node);
				void VisitField(WfAttribute* node);
				void VisitField(WfClassMember* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfExpression* node) = 0;
				virtual void VisitField(WfType* node) = 0;
				virtual void VisitField(WfStatement* node) = 0;

				// Dispatch (virtual) --------------------------------
				virtual void Dispatch(WfVirtualCseStatement* node) = 0;
				virtual void Dispatch(WfCoroutineStatement* node) = 0;
				virtual void Dispatch(WfStateMachineStatement* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfBreakStatement* node)override;
				void Visit(WfContinueStatement* node)override;
				void Visit(WfReturnStatement* node)override;
				void Visit(WfDeleteStatement* node)override;
				void Visit(WfRaiseExceptionStatement* node)override;
				void Visit(WfIfStatement* node)override;
				void Visit(WfWhileStatement* node)override;
				void Visit(WfTryStatement* node)override;
				void Visit(WfBlockStatement* node)override;
				void Visit(WfGotoStatement* node)override;
				void Visit(WfVariableStatement* node)override;
				void Visit(WfExpressionStatement* node)override;
				void Visit(WfVirtualCseStatement* node)override;
				void Visit(WfCoroutineStatement* node)override;
				void Visit(WfStateMachineStatement* node)override;
			};

			class DeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfNamespaceDeclaration* node);
				virtual void Traverse(WfDeclaration* node);
				virtual void Traverse(WfAttribute* node);
				virtual void Traverse(WfClassMember* node);
				virtual void Traverse(WfFunctionDeclaration* node);
				virtual void Traverse(WfFunctionArgument* node);
				virtual void Traverse(WfVariableDeclaration* node);
				virtual void Traverse(WfEventDeclaration* node);
				virtual void Traverse(WfPropertyDeclaration* node);
				virtual void Traverse(WfConstructorDeclaration* node);
				virtual void Traverse(WfBaseConstructorCall* node);
				virtual void Traverse(WfDestructorDeclaration* node);
				virtual void Traverse(WfClassDeclaration* node);
				virtual void Traverse(WfEnumDeclaration* node);
				virtual void Traverse(WfEnumItem* node);
				virtual void Traverse(WfEnumItemIntersection* node);
				virtual void Traverse(WfStructDeclaration* node);
				virtual void Traverse(WfStructMember* node);

				// VisitField ----------------------------------------
				void VisitField(WfAttribute* node);
				void VisitField(WfClassMember* node);
				void VisitField(WfFunctionArgument* node);
				void VisitField(WfBaseConstructorCall* node);
				void VisitField(WfEnumItem* node);
				void VisitField(WfEnumItemIntersection* node);
				void VisitField(WfStructMember* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfExpression* node) = 0;
				virtual void VisitField(WfDeclaration* node) = 0;
				virtual void VisitField(WfType* node) = 0;
				virtual void VisitField(WfStatement* node) = 0;

				// Dispatch (virtual) --------------------------------
				virtual void Dispatch(WfVirtualCfeDeclaration* node) = 0;
				virtual void Dispatch(WfVirtualCseDeclaration* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfNamespaceDeclaration* node)override;
				void Visit(WfFunctionDeclaration* node)override;
				void Visit(WfVariableDeclaration* node)override;
				void Visit(WfEventDeclaration* node)override;
				void Visit(WfPropertyDeclaration* node)override;
				void Visit(WfConstructorDeclaration* node)override;
				void Visit(WfDestructorDeclaration* node)override;
				void Visit(WfClassDeclaration* node)override;
				void Visit(WfEnumDeclaration* node)override;
				void Visit(WfStructDeclaration* node)override;
				void Visit(WfVirtualCfeDeclaration* node)override;
				void Visit(WfVirtualCseDeclaration* node)override;
			};

			class VirtualCfeDeclarationVisitor : public Object, public WfVirtualCfeDeclaration::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfAutoPropertyDeclaration* node);
				virtual void Traverse(WfVirtualCfeDeclaration* node);
				virtual void Traverse(WfDeclaration* node);
				virtual void Traverse(WfAttribute* node);
				virtual void Traverse(WfClassMember* node);
				virtual void Traverse(WfCastResultInterfaceDeclaration* node);

				// VisitField ----------------------------------------
				void VisitField(WfAttribute* node);
				void VisitField(WfClassMember* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfExpression* node) = 0;
				virtual void VisitField(WfDeclaration* node) = 0;
				virtual void VisitField(WfType* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfAutoPropertyDeclaration* node)override;
				void Visit(WfCastResultInterfaceDeclaration* node)override;
			};

			class VirtualCseDeclarationVisitor : public Object, public WfVirtualCseDeclaration::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfStateMachineDeclaration* node);
				virtual void Traverse(WfVirtualCseDeclaration* node);
				virtual void Traverse(WfDeclaration* node);
				virtual void Traverse(WfAttribute* node);
				virtual void Traverse(WfClassMember* node);
				virtual void Traverse(WfStateInput* node);
				virtual void Traverse(WfFunctionArgument* node);
				virtual void Traverse(WfStateDeclaration* node);

				// VisitField ----------------------------------------
				void VisitField(WfAttribute* node);
				void VisitField(WfClassMember* node);
				void VisitField(WfStateInput* node);
				void VisitField(WfFunctionArgument* node);
				void VisitField(WfStateDeclaration* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfExpression* node) = 0;
				virtual void VisitField(WfDeclaration* node) = 0;
				virtual void VisitField(WfType* node) = 0;
				virtual void VisitField(WfStatement* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfStateMachineDeclaration* node)override;
			};

			class VirtualCseStatementVisitor : public Object, public WfVirtualCseStatement::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfForEachStatement* node);
				virtual void Traverse(WfVirtualCseStatement* node);
				virtual void Traverse(WfStatement* node);
				virtual void Traverse(WfSwitchStatement* node);
				virtual void Traverse(WfSwitchCase* node);
				virtual void Traverse(WfCoProviderStatement* node);

				// VisitField ----------------------------------------
				void VisitField(WfSwitchCase* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfStatement* node) = 0;
				virtual void VisitField(WfExpression* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfForEachStatement* node)override;
				void Visit(WfSwitchStatement* node)override;
				void Visit(WfCoProviderStatement* node)override;
			};

			class CoroutineStatementVisitor : public Object, public WfCoroutineStatement::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfCoPauseStatement* node);
				virtual void Traverse(WfCoroutineStatement* node);
				virtual void Traverse(WfStatement* node);
				virtual void Traverse(WfCoOperatorStatement* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfStatement* node) = 0;
				virtual void VisitField(WfExpression* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfCoPauseStatement* node)override;
				void Visit(WfCoOperatorStatement* node)override;
			};

			class StateMachineStatementVisitor : public Object, public WfStateMachineStatement::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfStateSwitchStatement* node);
				virtual void Traverse(WfStateMachineStatement* node);
				virtual void Traverse(WfStatement* node);
				virtual void Traverse(WfStateSwitchCase* node);
				virtual void Traverse(WfStateSwitchArgument* node);
				virtual void Traverse(WfStateInvokeStatement* node);

				// VisitField ----------------------------------------
				void VisitField(WfStateSwitchCase* node);
				void VisitField(WfStateSwitchArgument* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfStatement* node) = 0;
				virtual void VisitField(WfExpression* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfStateSwitchStatement* node)override;
				void Visit(WfStateInvokeStatement* node)override;
			};

			class VirtualCfeExpressionVisitor : public Object, public WfVirtualCfeExpression::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfFormatExpression* node);
				virtual void Traverse(WfVirtualCfeExpression* node);
				virtual void Traverse(WfExpression* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfExpression* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfFormatExpression* node)override;
			};

			class VirtualCseExpressionVisitor : public Object, public WfVirtualCseExpression::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfBindExpression* node);
				virtual void Traverse(WfVirtualCseExpression* node);
				virtual void Traverse(WfExpression* node);
				virtual void Traverse(WfNewCoroutineExpression* node);
				virtual void Traverse(WfMixinCastExpression* node);
				virtual void Traverse(WfExpectedTypeCastExpression* node);
				virtual void Traverse(WfCoOperatorExpression* node);

				// VisitField (virtual) ------------------------------
				virtual void VisitField(WfExpression* node) = 0;
				virtual void VisitField(WfStatement* node) = 0;
				virtual void VisitField(WfType* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfBindExpression* node)override;
				void Visit(WfNewCoroutineExpression* node)override;
				void Visit(WfMixinCastExpression* node)override;
				void Visit(WfExpectedTypeCastExpression* node)override;
				void Visit(WfCoOperatorExpression* node)override;
			};

			class ModuleUsingFragmentVisitor : public Object, public WfModuleUsingFragment::IVisitor
			{
			public:

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfModuleUsingNameFragment* node);
				virtual void Traverse(WfModuleUsingFragment* node);
				virtual void Traverse(WfModuleUsingWildCardFragment* node);

				// Visitor Members -----------------------------------
				void Visit(WfModuleUsingNameFragment* node)override;
				void Visit(WfModuleUsingWildCardFragment* node)override;
			};

			class ModuleVisitor
				: public TypeVisitor
				, public ExpressionVisitor
				, public StatementVisitor
				, public DeclarationVisitor
				, public VirtualCfeDeclarationVisitor
				, public VirtualCseDeclarationVisitor
				, public VirtualCseStatementVisitor
				, public CoroutineStatementVisitor
				, public StateMachineStatementVisitor
				, public VirtualCfeExpressionVisitor
				, public VirtualCseExpressionVisitor
				, public ModuleUsingFragmentVisitor
			{
			public:
				void VisitField(WfModule* node);

				// Traverse ------------------------------------------
				virtual void Traverse(vl::parsing::ParsingToken& token);
				virtual void Traverse(vl::parsing::ParsingTreeCustomBase* node);
				virtual void Traverse(WfModule* node);
				virtual void Traverse(WfModuleUsingPath* node);
				virtual void Traverse(WfModuleUsingItem* node);

				// VisitField ----------------------------------------
				void VisitField(WfModuleUsingPath* node);
				void VisitField(WfModuleUsingItem* node);

				// VisitField (virtual) ------------------------------
				void VisitField(WfType* node);
				void VisitField(WfExpression* node);
				void VisitField(WfStatement* node);
				void VisitField(WfDeclaration* node);
				void VisitField(WfModuleUsingFragment* node);

				// Dispatch (virtual) --------------------------------
				void Dispatch(WfVirtualCfeExpression* node);
				void Dispatch(WfVirtualCseExpression* node);
				void Dispatch(WfVirtualCseStatement* node);
				void Dispatch(WfCoroutineStatement* node);
				void Dispatch(WfStateMachineStatement* node);
				void Dispatch(WfVirtualCfeDeclaration* node);
				void Dispatch(WfVirtualCseDeclaration* node);
			};
		}
	}
}
#endif

/***********************************************************************
.\EXPRESSION\WFEXPRESSION_EMPTY.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_EMPTY
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSIONPARSER_EMPTY


namespace vl
{
	namespace workflow
	{
		namespace empty_visitor
		{
			class TypeVisitor : public Object, public WfType::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfPredefinedType* node)override;
				void Visit(WfTopQualifiedType* node)override;
				void Visit(WfReferenceType* node)override;
				void Visit(WfRawPointerType* node)override;
				void Visit(WfSharedPointerType* node)override;
				void Visit(WfNullableType* node)override;
				void Visit(WfEnumerableType* node)override;
				void Visit(WfMapType* node)override;
				void Visit(WfObservableListType* node)override;
				void Visit(WfFunctionType* node)override;
				void Visit(WfChildType* node)override;
			};

			class ExpressionVisitor : public Object, public WfExpression::IVisitor
			{
			public:

				// Dispatch (virtual) --------------------------------
				virtual void Dispatch(WfVirtualCfeExpression* node) = 0;
				virtual void Dispatch(WfVirtualCseExpression* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfThisExpression* node)override;
				void Visit(WfTopQualifiedExpression* node)override;
				void Visit(WfReferenceExpression* node)override;
				void Visit(WfOrderedNameExpression* node)override;
				void Visit(WfOrderedLambdaExpression* node)override;
				void Visit(WfMemberExpression* node)override;
				void Visit(WfChildExpression* node)override;
				void Visit(WfLiteralExpression* node)override;
				void Visit(WfFloatingExpression* node)override;
				void Visit(WfIntegerExpression* node)override;
				void Visit(WfStringExpression* node)override;
				void Visit(WfUnaryExpression* node)override;
				void Visit(WfBinaryExpression* node)override;
				void Visit(WfLetExpression* node)override;
				void Visit(WfIfExpression* node)override;
				void Visit(WfRangeExpression* node)override;
				void Visit(WfSetTestingExpression* node)override;
				void Visit(WfConstructorExpression* node)override;
				void Visit(WfInferExpression* node)override;
				void Visit(WfTypeCastingExpression* node)override;
				void Visit(WfTypeTestingExpression* node)override;
				void Visit(WfTypeOfTypeExpression* node)override;
				void Visit(WfTypeOfExpressionExpression* node)override;
				void Visit(WfAttachEventExpression* node)override;
				void Visit(WfDetachEventExpression* node)override;
				void Visit(WfObserveExpression* node)override;
				void Visit(WfCallExpression* node)override;
				void Visit(WfFunctionExpression* node)override;
				void Visit(WfNewClassExpression* node)override;
				void Visit(WfNewInterfaceExpression* node)override;
				void Visit(WfVirtualCfeExpression* node)override;
				void Visit(WfVirtualCseExpression* node)override;
			};

			class StatementVisitor : public Object, public WfStatement::IVisitor
			{
			public:

				// Dispatch (virtual) --------------------------------
				virtual void Dispatch(WfVirtualCseStatement* node) = 0;
				virtual void Dispatch(WfCoroutineStatement* node) = 0;
				virtual void Dispatch(WfStateMachineStatement* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfBreakStatement* node)override;
				void Visit(WfContinueStatement* node)override;
				void Visit(WfReturnStatement* node)override;
				void Visit(WfDeleteStatement* node)override;
				void Visit(WfRaiseExceptionStatement* node)override;
				void Visit(WfIfStatement* node)override;
				void Visit(WfWhileStatement* node)override;
				void Visit(WfTryStatement* node)override;
				void Visit(WfBlockStatement* node)override;
				void Visit(WfGotoStatement* node)override;
				void Visit(WfVariableStatement* node)override;
				void Visit(WfExpressionStatement* node)override;
				void Visit(WfVirtualCseStatement* node)override;
				void Visit(WfCoroutineStatement* node)override;
				void Visit(WfStateMachineStatement* node)override;
			};

			class DeclarationVisitor : public Object, public WfDeclaration::IVisitor
			{
			public:

				// Dispatch (virtual) --------------------------------
				virtual void Dispatch(WfVirtualCfeDeclaration* node) = 0;
				virtual void Dispatch(WfVirtualCseDeclaration* node) = 0;

				// Visitor Members -----------------------------------
				void Visit(WfNamespaceDeclaration* node)override;
				void Visit(WfFunctionDeclaration* node)override;
				void Visit(WfVariableDeclaration* node)override;
				void Visit(WfEventDeclaration* node)override;
				void Visit(WfPropertyDeclaration* node)override;
				void Visit(WfConstructorDeclaration* node)override;
				void Visit(WfDestructorDeclaration* node)override;
				void Visit(WfClassDeclaration* node)override;
				void Visit(WfEnumDeclaration* node)override;
				void Visit(WfStructDeclaration* node)override;
				void Visit(WfVirtualCfeDeclaration* node)override;
				void Visit(WfVirtualCseDeclaration* node)override;
			};

			class VirtualCfeDeclarationVisitor : public Object, public WfVirtualCfeDeclaration::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfAutoPropertyDeclaration* node)override;
				void Visit(WfCastResultInterfaceDeclaration* node)override;
			};

			class VirtualCseDeclarationVisitor : public Object, public WfVirtualCseDeclaration::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfStateMachineDeclaration* node)override;
			};

			class VirtualCseStatementVisitor : public Object, public WfVirtualCseStatement::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfForEachStatement* node)override;
				void Visit(WfSwitchStatement* node)override;
				void Visit(WfCoProviderStatement* node)override;
			};

			class CoroutineStatementVisitor : public Object, public WfCoroutineStatement::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfCoPauseStatement* node)override;
				void Visit(WfCoOperatorStatement* node)override;
			};

			class StateMachineStatementVisitor : public Object, public WfStateMachineStatement::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfStateSwitchStatement* node)override;
				void Visit(WfStateInvokeStatement* node)override;
			};

			class VirtualCfeExpressionVisitor : public Object, public WfVirtualCfeExpression::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfFormatExpression* node)override;
			};

			class VirtualCseExpressionVisitor : public Object, public WfVirtualCseExpression::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfBindExpression* node)override;
				void Visit(WfNewCoroutineExpression* node)override;
				void Visit(WfMixinCastExpression* node)override;
				void Visit(WfExpectedTypeCastExpression* node)override;
				void Visit(WfCoOperatorExpression* node)override;
			};

			class ModuleUsingFragmentVisitor : public Object, public WfModuleUsingFragment::IVisitor
			{
			public:

				// Visitor Members -----------------------------------
				void Visit(WfModuleUsingNameFragment* node)override;
				void Visit(WfModuleUsingWildCardFragment* node)override;
			};

		}
	}
}
#endif

/***********************************************************************
.\EXPRESSION\WFEXPRESSION.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::WfExpression

Interfaces:
***********************************************************************/

#ifdef VCZH_DEBUG_NO_REFLECTION
static_assert(false, "Don't use VlppWorkflow.(h|cpp) or VlppWorkflowCompiler.(h|cpp) if VCZH_DEBUG_NO_REFLECTION is defined.");
#endif

#ifndef VCZH_WORKFLOW_EXPRESSION_WFEXPRESSION
#define VCZH_WORKFLOW_EXPRESSION_WFEXPRESSION


namespace vl
{
	namespace workflow
	{
		/// <summary>Print a Workflow attribute.</summary>
		/// <param name="node">The Workflow attribute.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfAttribute> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow type.</summary>
		/// <param name="node">The Workflow type.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfType> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow expression.</summary>
		/// <param name="node">The Workflow expression.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfExpression> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow statement.</summary>
		/// <param name="node">The Workflow statement.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfStatement> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow declaration.</summary>
		/// <param name="node">The Workflow declaration.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfDeclaration> node, const WString& indent, parsing::ParsingWriter& writer);
		/// <summary>Print a Workflow module.</summary>
		/// <param name="node">The Workflow module.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfModule> node, const WString& indent, parsing::ParsingWriter& writer);

		/// <summary>Print a Workflow attribute.</summary>
		/// <param name="node">The Workflow attribute.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfAttribute> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow type.</summary>
		/// <param name="node">The Workflow type.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfType> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow expression.</summary>
		/// <param name="node">The Workflow expression.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfExpression> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow statement.</summary>
		/// <param name="node">The Workflow statement.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfStatement> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow declaration.</summary>
		/// <param name="node">The Workflow declaration.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfDeclaration> node, const WString& indent, stream::TextWriter& writer);
		/// <summary>Print a Workflow module.</summary>
		/// <param name="node">The Workflow module.</param>
		/// <param name="indent">The indentation.</param>
		/// <param name="writer">The target writer.</param>
		extern void			WfPrint(Ptr<WfModule> node, const WString& indent, stream::TextWriter& writer);
	}
}
#endif

/***********************************************************************
.\ANALYZER\WFANALYZER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Analyzer

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_ANALYZER_WFANALYZER
#define VCZH_WORKFLOW_ANALYZER_WFANALYZER


namespace vl
{
	namespace workflow
	{
		namespace analyzer
		{
			class WfLexicalSymbol;
			class WfLexicalScope;
			class WfLexicalScopeManager;
		}

/***********************************************************************
Callback
***********************************************************************/

		class IWfCompilerCallback : public Interface
		{
		public:
			virtual void								OnLoadEnvironment() = 0;
			virtual void								OnInitialize(analyzer::WfLexicalScopeManager* manager) = 0;
			virtual void								OnValidateModule(Ptr<WfModule> module) = 0;

			virtual void								OnGenerateMetadata() = 0;
			virtual void								OnGenerateCode(Ptr<WfModule> module) = 0;
			virtual void								OnGenerateDebugInfo() = 0;
		};

		namespace analyzer
		{
/***********************************************************************
Scope
***********************************************************************/

			class WfLexicalSymbol : public Object
			{
			public:
				WString										name;				// name of this symbol
				Ptr<WfType>									type;				// type of this symbol
				Ptr<reflection::description::ITypeInfo>		typeInfo;			// reflection type info of this symbol, nullable
				Ptr<parsing::ParsingTreeCustomBase>			creatorNode;		// nullable
				WfLexicalScope*								ownerScope;			// scope that contains this symbol

				WfLexicalSymbol(WfLexicalScope* _ownerScope);
				~WfLexicalSymbol();
				
				WString										GetFriendlyName();
			};

			class WfLexicalFunctionConfig : public Object
			{
			public:
				bool										lambda = false;
				bool										thisAccessable = false;
				bool										parentThisAccessable = false;
			};

			class WfLexicalScope : public Object
			{
				typedef collections::Group<WString, Ptr<WfLexicalSymbol>>		TypeGroup;
			public:
				WfLexicalScopeManager*						ownerManager;				// nullable
				Ptr<parsing::ParsingTreeCustomBase>			ownerNode;					// nullable
				parsing::ParsingTreeCustomBase*				ownerNodeSource = nullptr;	// nullable

				Ptr<WfLexicalFunctionConfig>				functionConfig;
				reflection::description::ITypeDescriptor*	typeOfThisExpr = nullptr;	// visible members to this scope

				Ptr<WfLexicalScope>							parentScope;				// null means that this is the root scope
				TypeGroup									symbols;					// all symbols in this scope

				WfLexicalScope(WfLexicalScopeManager* _ownerManager);
				WfLexicalScope(Ptr<WfLexicalScope> _parentScope);
				~WfLexicalScope();

				WfLexicalScopeManager*						FindManager();
				Ptr<WfModule>								FindModule();
				WfLexicalScope*								FindFunctionScope();
				WString										GetFriendlyName();
				Ptr<WfClassMember>							GetOwnerClassMember();
			};

/***********************************************************************
Scope Manager
***********************************************************************/

			class WfLexicalScopeName : public Object
			{
				typedef collections::Dictionary<WString, Ptr<WfLexicalScopeName>>		NameMap;
				typedef collections::List<Ptr<WfDeclaration>>							DeclarationList;
			public:
				WfLexicalScopeName*							parent = nullptr;
				bool										imported = true;
				NameMap										children;
				WString										name;
				reflection::description::ITypeDescriptor*	typeDescriptor = nullptr;	// type that form this name
				DeclarationList								declarations;				// declarations that form this name

				WfLexicalScopeName(bool _imported);
				~WfLexicalScopeName();

				Ptr<WfLexicalScopeName>						AccessChild(const WString& name, bool imported);
				void										RemoveNonTypeDescriptorNames(WfLexicalScopeManager* manager);
				WString										GetFriendlyName();
			};

			struct ResolveExpressionResult
			{
				Ptr<WfLexicalScopeName>						scopeName;
				Ptr<WfLexicalSymbol>						symbol;
				reflection::description::IPropertyInfo*		propertyInfo = nullptr;
				reflection::description::IMethodInfo*		methodInfo = nullptr;
				reflection::description::IMethodInfo*		constructorInfo = nullptr;
				reflection::description::IEventInfo*		eventInfo = nullptr;
				Ptr<reflection::description::ITypeInfo>		type;
				Ptr<reflection::description::ITypeInfo>		writableType;
				Ptr<reflection::description::ITypeInfo>		expectedType;

				WString										GetFriendlyName(bool upperCase = false)const;

				static ResolveExpressionResult				ScopeName(Ptr<WfLexicalScopeName> _scopeName);
				static ResolveExpressionResult				ReadonlySymbol(Ptr<WfLexicalSymbol> _symbol);
				static ResolveExpressionResult				Symbol(Ptr<WfLexicalSymbol> _symbol);
				static ResolveExpressionResult				ReadonlyType(Ptr<reflection::description::ITypeInfo> _type);
				static ResolveExpressionResult				WritableType(Ptr<reflection::description::ITypeInfo> _type);
				static ResolveExpressionResult				Property(reflection::description::IPropertyInfo* _propertyInfo);
				static ResolveExpressionResult				Method(reflection::description::IMethodInfo* _methodInfo);
				static ResolveExpressionResult				Constructor(reflection::description::IMethodInfo* _constructorInfo);
				static ResolveExpressionResult				Event(reflection::description::IEventInfo* _eventInfo);

				bool										operator==(const ResolveExpressionResult& result) const;
				bool										operator!=(const ResolveExpressionResult& result) const;
			};

			struct WfLexicalCapture
			{
				collections::List<Ptr<WfLexicalSymbol>>		symbols;
				collections::List<Ptr<WfLexicalSymbol>>		ctorArgumentSymbols;
			};

			struct WfStateMachineInfo
			{
				Ptr<typeimpl::WfClassMethod>				createCoroutineMethod;
				collections::Dictionary<WString, vint>		inputIds;
				collections::Dictionary<WString, vint>		stateIds;
			};

			/// <summary>Workflow compiler.</summary>
			class WfLexicalScopeManager : public Object
			{
				typedef reflection::description::ITypeDescriptor											ITypeDescriptor;
				typedef reflection::description::IMemberInfo												IMemberInfo;
				typedef reflection::description::IMethodInfo												IMethodInfo;
				typedef reflection::description::ITypeInfo													ITypeInfo;
				typedef reflection::description::Value														Value;

				typedef collections::List<Ptr<WfModule>>													ModuleList;
				typedef collections::List<WString>															ModuleCodeList;
				typedef collections::Pair<WString, WString>													AttributeKey;
				typedef collections::Dictionary<AttributeKey, Ptr<ITypeInfo>>								AttributeTypeMap;

				typedef collections::Dictionary<ITypeDescriptor*, Ptr<WfLexicalScopeName>>					TypeNameMap;

				typedef collections::List<Ptr<parsing::ParsingError>>										ParsingErrorList;
				typedef collections::Dictionary<Ptr<WfNamespaceDeclaration>, Ptr<WfLexicalScopeName>>		NamespaceNameMap;
				typedef collections::Dictionary<parsing::ParsingTreeCustomBase*, Ptr<WfLexicalScope>>		NodeScopeMap;
				typedef collections::SortedList<WfLexicalScope*>											AnalyzedScopeList;

				typedef collections::Dictionary<Ptr<WfExpression>, ResolveExpressionResult>					ExpressionResolvingMap;
				typedef collections::Dictionary<Ptr<WfStatement>, ResolveExpressionResult>					CoOperatorResolvingMap;
				typedef collections::Pair<WfConstructorDeclaration*, ITypeDescriptor*>						BaseConstructorCallKey;
				typedef collections::Pair<WfBaseConstructorCall*, IMethodInfo*>								BaseConstructorCallValue;
				typedef collections::Dictionary<BaseConstructorCallKey, BaseConstructorCallValue>			BaseConstructorCallResolvingMap;

				typedef collections::Dictionary<parsing::ParsingTreeCustomBase*, Ptr<WfLexicalCapture>>		LambdaCaptureMap;
				typedef collections::Dictionary<WfFunctionDeclaration*, IMethodInfo*>						InterfaceMethodImplementationMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, parsing::ParsingTreeCustomBase*>		DeclarationSourceMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, Ptr<ITypeDescriptor>>					DeclarationTypeMap;
				typedef collections::Dictionary<Ptr<WfDeclaration>, Ptr<IMemberInfo>>						DeclarationMemberInfoMap;

				typedef collections::Dictionary<Ptr<WfStateInput>, Ptr<typeimpl::WfClassMethod>>			StateInputMethodMap;
				typedef collections::Dictionary<Ptr<WfFunctionArgument>, Ptr<typeimpl::WfField>>			StateArgumentFieldMap;
				typedef collections::Dictionary<Ptr<WfStateMachineDeclaration>, Ptr<WfStateMachineInfo>>	StateMachineInfoMap;

			protected:
				ModuleList									modules;
				ModuleCodeList								moduleCodes;
				vint										usedCodeIndex = 0;

			public:
				Ptr<parsing::tabling::ParsingTable>			parsingTable;
				AttributeTypeMap							attributes;

				Ptr<WfLexicalScopeName>						globalName;							// root scope
				TypeNameMap									typeNames;							// ITypeDescriptor* to scope name map

				vint										usedTempVars = 0;
				ParsingErrorList							errors;								// compile errors
				NamespaceNameMap							namespaceNames;						// namespace to scope name map
				NodeScopeMap								nodeScopes;							// the nearest scope for a AST
				AnalyzedScopeList							checkedScopes_DuplicatedSymbol;		// scopes that validated by CheckScopes_DuplicatedSymbol
				AnalyzedScopeList							checkedScopes_SymbolType;			// scopes that validated by CheckScopes_SymbolType

				ExpressionResolvingMap						expressionResolvings;				// the resolving result for the expression
				ExpressionResolvingMap						coNewCoroutineResolvings;			// the coroutine type for the WfNewCoroutineExpression (e.g. AsyncCoroutine)
				CoOperatorResolvingMap						coOperatorResolvings;				// the method for the co-operator statement (e.g. AwaitAndRead)
				CoOperatorResolvingMap						coProviderResolvings;				// the constructor for the co-provider statement (e.g. AsyncCoroutine::Create)
				CoOperatorResolvingMap						coCastResultResolvings;				// the method for the co-operator's type casting (e.g. IStringAsync::CastResult)
				BaseConstructorCallResolvingMap				baseConstructorCallResolvings;		// all base constructor call resolvings

				LambdaCaptureMap							lambdaCaptures;						// all captured symbols in a lambda AST
				InterfaceMethodImplementationMap			interfaceMethodImpls;				// the IMethodInfo* that implemented by a function
				DeclarationSourceMap						declaractionScopeSources;			// the source used to build the scope for a declaration
				DeclarationTypeMap							declarationTypes;					// ITypeDescriptor* for type declaration
				DeclarationMemberInfoMap					declarationMemberInfos;				// IMemberInfo* for type description
				StateInputMethodMap							stateInputMethods;					// IMethodInfo* for state input
				StateArgumentFieldMap						stateInputArguments;				// IPropertyInfo* for state input argument temporary cache
				StateArgumentFieldMap						stateDeclArguments;					// IPropertyInfo* for state argument temporary cache
				StateMachineInfoMap							stateMachineInfos;					// members of state machine

				/// <summary>Create a Workflow compiler.</summary>
				/// <param name="_parsingTable">The workflow parser table. It can be retrived from [M:vl.workflow.WfLoadTable].</param>
				WfLexicalScopeManager(Ptr<parsing::tabling::ParsingTable> _parsingTable);
				~WfLexicalScopeManager();
				
				/// <summary>Add a Workflow module. Syntax errors can be found at <see cref="errors"/>.</summary>
				/// <param name="moduleCode">The source code of a workflow module.</param>
				/// <returns>Returns the code index, which is a number representing a module in data structured used in Workflow compiler, runtime and debugger.</returns>
				vint										AddModule(const WString& moduleCode);
				/// <summary>Add a Workflow module.</summary>
				/// <param name="module">The syntax tree of a workflow module.</param>
				/// <returns>Returns the code index, which is a number representing a module in data structured used in Workflow compiler, runtime and debugger.</returns>
				vint										AddModule(Ptr<WfModule> module);
				/// <summary>Get all added modules.</summary>
				/// <returns>All added modules.</returns>
				ModuleList&									GetModules();
				/// <summary>Get all module codes. If a module is added from a syntax tree, then the source code is empty.</summary>
				/// <returns>All module codes.</returns>
				ModuleCodeList&								GetModuleCodes();

				/// <summary>Clean compiling results.</summary>
				/// <param name="keepTypeDescriptorNames">Set to false to delete all cache of reflectable C++ types.</param>
				/// <param name="deleteModules">Set to true to delete all added modules.</param>
				void										Clear(bool keepTypeDescriptorNames, bool deleteModules);
				/// <summary>Compile.</summary>
				/// <param name="keepTypeDescriptorNames">Set to false to delete all cache of reflectable C++ types before compiling.</param>
				/// <param name="callback">The callback to receive progress information, could be nullptr.</param>
				void										Rebuild(bool keepTypeDescriptorNames, IWfCompilerCallback* callback = nullptr);

				bool										ResolveMember(ITypeDescriptor* typeDescriptor, const WString& name, bool preferStatic, collections::SortedList<ITypeDescriptor*>& searchedTypes, collections::List<ResolveExpressionResult>& results);
				bool										ResolveName(WfLexicalScope* scope, const WString& name, collections::List<ResolveExpressionResult>& results);
				Ptr<WfLexicalSymbol>						GetDeclarationSymbol(WfLexicalScope* scope, WfDeclaration* node);
				void										CreateLambdaCapture(parsing::ParsingTreeCustomBase* node, Ptr<WfLexicalCapture> capture = nullptr);
			};

/***********************************************************************
Type Analyzing
***********************************************************************/

			enum class TypeFlag
			{
				Bool,
				I1,
				I2,
				I4,
				I8,
				U1,
				U2,
				U4,
				U8,
				F4,
				F8,
				String,
				Enum,
				Struct,
				Others,
				Count,
				Unknown = -1,
			};

			extern TypeFlag									GetTypeFlag(reflection::description::ITypeDescriptor* typeDescriptor);
			extern TypeFlag									GetTypeFlag(reflection::description::ITypeInfo* typeInfo);
			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromTypeFlag(TypeFlag flag);

			extern void										GetTypeFragments(reflection::description::ITypeDescriptor* typeDescriptor, collections::List<WString>& fragments);
			extern Ptr<WfExpression>						GetExpressionFromTypeDescriptor(reflection::description::ITypeDescriptor* typeDescriptor);
			extern Ptr<WfType>								GetTypeFromTypeInfo(reflection::description::ITypeInfo* typeInfo);
			extern Ptr<WfLexicalScopeName>					GetScopeNameFromReferenceType(WfLexicalScope* scope, Ptr<WfType> type);
			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromType(WfLexicalScope* scope, Ptr<WfType> type, bool checkTypeForValue = true);

			extern Ptr<reflection::description::ITypeInfo>	CopyTypeInfo(reflection::description::ITypeInfo* typeInfo);
			extern bool										CanConvertToType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, bool explicitly);
			extern bool										IsSameType(reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
			extern Ptr<reflection::description::ITypeInfo>	GetMergedType(Ptr<reflection::description::ITypeInfo> firstType, Ptr<reflection::description::ITypeInfo> secondType);
			extern bool										IsNullAcceptableType(reflection::description::ITypeInfo* type);

			extern Ptr<reflection::description::ITypeInfo>	CreateTypeInfoFromMethodInfo(reflection::description::IMethodInfo* info);

			extern bool										IsExpressionDependOnExpectedType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern WString									GetExpressionName(Ptr<WfExpression> expression);
			extern void										SearchOrderedName(WfLexicalScope* scope, Ptr<WfExpression> expression, collections::SortedList<vint>& names);

/***********************************************************************
Structure Analyzing
***********************************************************************/
			
			struct ValidateStructureContext
			{
				WfBindExpression*							currentBindExpression = nullptr;
				WfObserveExpression*						currentObserveExpression = nullptr;
				WfStatement*								currentLoopStatement = nullptr;
				WfStatement*								currentCatchStatement = nullptr;
				WfCoProviderStatement*						currentCoProviderStatement = nullptr;
				WfNewCoroutineExpression*					currentNewCoroutineExpression = nullptr;
				WfCoPauseStatement*							currentCoPauseStatement = nullptr;
				WfStateDeclaration*							currentStateDeclaration = nullptr;

				ValidateStructureContext();
			};

			enum class ValidateTypeStragety
			{
				Value,
				ReturnType,
				BaseType,
			};

			extern void										SetCodeRange(Ptr<WfType> node, parsing::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfExpression> node, parsing::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfStatement> node, parsing::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfDeclaration> node, parsing::ParsingTextRange codeRange, bool asOffset = false);
			extern void										SetCodeRange(Ptr<WfModule> node, parsing::ParsingTextRange codeRange, bool asOffset = false);

			extern void										ContextFreeModuleDesugar(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ContextFreeDeclarationDesugar(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration);
			extern void										ContextFreeStatementDesugar(WfLexicalScopeManager* manager, Ptr<WfStatement> statement);
			extern void										ContextFreeExpressionDesugar(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);

			extern void										ValidateTypeStructure(WfLexicalScopeManager* manager, Ptr<WfType> type, ValidateTypeStragety strategy = ValidateTypeStragety::Value, WfClassDeclaration* classDecl = nullptr);
			extern void										ValidateModuleStructure(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ValidateDeclarationStructure(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration, WfClassDeclaration* classDecl = 0 , WfExpression* surroundingLambda = 0);
			extern void										ValidateStatementStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfStatement>& statement);
			extern void										ValidateExpressionStructure(WfLexicalScopeManager* manager, ValidateStructureContext* context, Ptr<WfExpression>& expression);

/***********************************************************************
Global Name
***********************************************************************/

			extern void										BuildGlobalNameFromTypeDescriptors(WfLexicalScopeManager* manager);
			extern void										BuildNameForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name, WfDeclaration* decl);
			extern void										BuildGlobalNameFromModules(WfLexicalScopeManager* manager);
			extern void										ValidateScopeName(WfLexicalScopeManager* manager, Ptr<WfLexicalScopeName> name);

/***********************************************************************
Scope Analyzing
***********************************************************************/
			
			extern void										CompleteScopeForClassMember(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfDeclaration> memberDecl);
			extern void										CompleteScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration);
			extern void										CompleteScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module);

			extern void										BuildScopeForModule(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										BuildScopeForDeclaration(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfDeclaration> declaration, parsing::ParsingTreeCustomBase* source);
			extern void										BuildScopeForStatement(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfStatement> statement);
			extern void										BuildScopeForExpression(WfLexicalScopeManager* manager, Ptr<WfLexicalScope> parentScope, Ptr<WfExpression> expression);
			extern bool										CheckScopes_DuplicatedSymbol(WfLexicalScopeManager* manager);
			extern bool										CheckScopes_SymbolType(WfLexicalScopeManager* manager);
			extern bool										CheckScopes_CycleDependency(WfLexicalScopeManager* manager);

/***********************************************************************
Semantic Analyzing
***********************************************************************/

			extern reflection::description::IMethodInfo*	FindInterfaceConstructor(reflection::description::ITypeDescriptor* type);
			extern Ptr<reflection::description::ITypeInfo>	SelectFunction(WfLexicalScopeManager* manager, parsing::ParsingTreeCustomBase* node, Ptr<WfExpression> functionExpression, collections::List<ResolveExpressionResult>& functions, collections::List<Ptr<WfExpression>>& arguments, vint& selectedFunctionIndex);

			extern void										ValidateModuleSemantic(WfLexicalScopeManager* manager, Ptr<WfModule> module);
			extern void										ValidateClassMemberSemantic(WfLexicalScopeManager* manager, Ptr<typeimpl::WfCustomType> td, Ptr<WfClassDeclaration> classDecl, Ptr<WfDeclaration> memberDecl);
			extern void										ValidateDeclarationSemantic(WfLexicalScopeManager* manager, Ptr<WfDeclaration> declaration);
			extern void										ValidateStatementSemantic(WfLexicalScopeManager* manager, Ptr<WfStatement> statement);
			extern void										ValidateExpressionSemantic(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, collections::List<ResolveExpressionResult>& results);
			extern void										ValidateConstantExpression(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);

			extern Ptr<WfLexicalScopeName>					GetExpressionScopeName(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern reflection::description::IEventInfo*		GetExpressionEventInfo(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern void										GetExpressionTypes(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType, bool allowEvent, collections::List<ResolveExpressionResult>& results);
			extern Ptr<reflection::description::ITypeInfo>	GetExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);
			extern Ptr<reflection::description::ITypeInfo>	GetLeftValueExpressionType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression);
			extern Ptr<reflection::description::ITypeInfo>	GetEnumerableExpressionItemType(WfLexicalScopeManager* manager, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType);

/***********************************************************************
Expanding Virtual Nodes
***********************************************************************/

			class CopyWithExpandVirtualVisitor : public copy_visitor::ModuleVisitor
			{
			private:
				bool										expandVirtualAst;

				void										Expand(collections::List<Ptr<WfDeclaration>>& decls);
			public:
				CopyWithExpandVirtualVisitor(bool _expandVirtualAst);

				Ptr<parsing::ParsingTreeCustomBase>			Dispatch(WfVirtualCfeExpression* node)override;
				Ptr<parsing::ParsingTreeCustomBase>			Dispatch(WfVirtualCseExpression* node)override;
				Ptr<parsing::ParsingTreeCustomBase>			Dispatch(WfVirtualCseStatement* node)override;

				void										Visit(WfNamespaceDeclaration* node)override;
				void										Visit(WfClassDeclaration* node)override;
				void										Visit(WfNewInterfaceExpression* node)override;
			};

			extern Ptr<WfStatement>							SearchUntilNonVirtualStatement(Ptr<WfStatement> statement);
			extern Ptr<WfType>								CopyType(Ptr<WfType> type);
			extern Ptr<WfExpression>						CopyExpression(Ptr<WfExpression> expression, bool expandVirtualExprStat);
			extern Ptr<WfStatement>							CopyStatement(Ptr<WfStatement> statement, bool expandVirtualExprStat);
			extern Ptr<WfDeclaration>						CopyDeclaration(Ptr<WfDeclaration> declaration, bool expandVirtualExprStat);
			extern Ptr<WfModule>							CopyModule(Ptr<WfModule> module, bool expandVirtualExprStat);
			extern Ptr<WfExpression>						CreateDefaultValue(reflection::description::ITypeInfo* elementType);

			extern void										ExpandBindExpression(WfLexicalScopeManager* manager, WfBindExpression* node);
			extern void										ExpandNewCoroutineExpression(WfLexicalScopeManager* manager, WfNewCoroutineExpression* node);
			extern void										ExpandCoOperatorExpression(WfLexicalScopeManager* manager, WfCoOperatorExpression* node);
			extern void										ExpandMixinCastExpression(WfLexicalScopeManager* manager, WfMixinCastExpression* node);
			extern void										ExpandSwitchStatement(WfLexicalScopeManager* manager, WfSwitchStatement* node);
			extern void										ExpandForEachStatement(WfLexicalScopeManager* manager, WfForEachStatement* node);
			extern void										ExpandCoProviderStatement(WfLexicalScopeManager* manager, WfCoProviderStatement* node);
			extern void										ExpandStateMachine(WfLexicalScopeManager* manager, WfStateMachineDeclaration* node);

/***********************************************************************
Error Messages
***********************************************************************/

			struct WfErrors
			{
				// A: Expression error
				static Ptr<parsing::ParsingError>			WrongFormatStringSyntax(WfExpression* node);
				static Ptr<parsing::ParsingError>			WrongSimpleObserveExpression(WfExpression* node);
				static Ptr<parsing::ParsingError>			WrongSimpleObserveEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			EmptyObserveEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			ObserveNotInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			ObserveInObserveEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			BindInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			AttachInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			DetachInBind(WfExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorMixMapAndList(WfExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorMixStructAndList(WfExpression* node);
				static Ptr<parsing::ParsingError>			DuplicatedConstructorField(WfReferenceExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorMixClassAndInterface(WfNewClassExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorMixClassAndInterface(WfNewInterfaceExpression* node);
				static Ptr<parsing::ParsingError>			ScopeNameIsNotExpression(WfExpression* node, Ptr<WfLexicalScopeName> scopeName);
				static Ptr<parsing::ParsingError>			EventIsNotExpression(WfExpression* node, reflection::description::IEventInfo* eventInfo);
				static Ptr<parsing::ParsingError>			ExpressionIsNotScopeName(WfExpression* node);
				static Ptr<parsing::ParsingError>			ExpressionIsNotEvent(WfExpression* node);
				static Ptr<parsing::ParsingError>			ExpressionCannotResolveType(WfExpression* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			NullCannotResolveType(WfExpression* node);
				static Ptr<parsing::ParsingError>			ConstructorCannotResolveType(WfExpression* node);
				static Ptr<parsing::ParsingError>			OrderedLambdaCannotResolveType(WfExpression* node);
				static Ptr<parsing::ParsingError>			NullCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ConstructorCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			OrderedLambdaCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ExpressionCannotImplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ExpressionCannotExplicitlyConvertToType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			CannotWeakCastToType(WfExpression* node, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			IntegerLiteralOutOfRange(WfIntegerExpression* node);
				static Ptr<parsing::ParsingError>			FloatingLiteralOutOfRange(WfFloatingExpression* node);
				static Ptr<parsing::ParsingError>			CannotMergeTwoType(WfExpression* node, reflection::description::ITypeInfo* firstType, reflection::description::ITypeInfo* secondType);
				static Ptr<parsing::ParsingError>			RangeShouldBeInteger(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			UnaryOperatorOnWrongType(WfUnaryExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			BinaryOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			IndexOperatorOnWrongType(WfBinaryExpression* node, reflection::description::ITypeInfo* containerType);
				static Ptr<parsing::ParsingError>			ExpressionIsNotCollection(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			ExpressionIsNotFunction(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			FunctionArgumentCountMismatched(parsing::ParsingTreeCustomBase* node, vint expectedCount, const ResolveExpressionResult& function);
				static Ptr<parsing::ParsingError>			FunctionArgumentTypeMismatched(parsing::ParsingTreeCustomBase* node, const ResolveExpressionResult& function, vint index, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			CannotPickOverloadedFunctions(parsing::ParsingTreeCustomBase* node, collections::List<ResolveExpressionResult>& results);
				static Ptr<parsing::ParsingError>			ClassContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			InterfaceContainsNoConstructor(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			ConstructorReturnTypeMismatched(WfExpression* node, const ResolveExpressionResult& function, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ExpressionIsNotLeftValue(WfExpression* node, const ResolveExpressionResult& result);
				static Ptr<parsing::ParsingError>			CannotCallMemberOutsideOfClass(WfExpression* node, const ResolveExpressionResult& result);
				static Ptr<parsing::ParsingError>			CannotCallMemberInStaticFunction(WfExpression* node, const ResolveExpressionResult& result);
				static Ptr<parsing::ParsingError>			FieldCannotInitializeUsingEachOther(WfExpression* node, const ResolveExpressionResult& result);
				static Ptr<parsing::ParsingError>			WrongThisExpression(WfExpression* node);
				static Ptr<parsing::ParsingError>			IncorrectTypeForUnion(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			IncorrectTypeForIntersect(WfExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			ExpressionIsNotConstant(WfExpression* node);
				static Ptr<parsing::ParsingError>			WrongMixinTargetType(WfExpression* node, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType);
				static Ptr<parsing::ParsingError>			ExpectedTypeCastCannotResolveType(WfExpression* node);

				// B: Type error
				static Ptr<parsing::ParsingError>			WrongVoidType(WfType* node);
				static Ptr<parsing::ParsingError>			WrongInterfaceType(WfType* node);
				static Ptr<parsing::ParsingError>			RawPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static Ptr<parsing::ParsingError>			SharedPointerToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static Ptr<parsing::ParsingError>			NullableToNonReferenceType(WfType* node, reflection::description::ITypeInfo* typeInfo = 0);
				static Ptr<parsing::ParsingError>			ChildOfNonReferenceType(WfType* node);
				static Ptr<parsing::ParsingError>			TypeNotExists(WfType* node, Ptr<WfLexicalScopeName> scopeName);
				static Ptr<parsing::ParsingError>			TypeNotExists(WfType* node, const ResolveExpressionResult& result);
				static Ptr<parsing::ParsingError>			TypeNotForValue(WfType* node, reflection::description::ITypeInfo* typeInfo);
				
				// C: Statement error
				static Ptr<parsing::ParsingError>			BreakNotInLoop(WfStatement* node);
				static Ptr<parsing::ParsingError>			ContinueNotInLoop(WfStatement* node);
				static Ptr<parsing::ParsingError>			RethrowNotInCatch(WfStatement* node);
				static Ptr<parsing::ParsingError>			TryMissCatchAndFinally(WfStatement* node);
				static Ptr<parsing::ParsingError>			ReturnMissExpression(WfStatement* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			DeleteNonRawPointer(WfStatement* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			CannotReturnExpression(WfStatement* node);
				static Ptr<parsing::ParsingError>			WrongCoPause(WfStatement* node);
				static Ptr<parsing::ParsingError>			WrongCoOperator(WfStatement* node);
				static Ptr<parsing::ParsingError>			WrongCoOperator(WfExpression* node);
				static Ptr<parsing::ParsingError>			CoProviderNotExists(WfCoProviderStatement* node, collections::List<WString>& candidates);
				static Ptr<parsing::ParsingError>			CoOperatorNotExists(WfReturnStatement* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			CoOperatorNotExists(WfCoOperatorStatement* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			CoOperatorNotExists(WfCoOperatorExpression* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			CoOperatorCannotResolveResultType(WfCoOperatorStatement* node, collections::List<reflection::description::ITypeInfo*>& types);
				static Ptr<parsing::ParsingError>			CoProviderCreateNotExists(WfCoProviderStatement* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			CoProviderCreateAndRunNotExists(WfCoProviderStatement* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			GotoLabelNotExists(WfGotoStatement* node);
				static Ptr<parsing::ParsingError>			TooManyGotoLabel(WfGotoStatement* node);
				static Ptr<parsing::ParsingError>			WrongStateSwitchStatement(WfStateSwitchStatement* node);
				static Ptr<parsing::ParsingError>			WrongStateInvokeStatement(WfStateInvokeStatement* node);
				static Ptr<parsing::ParsingError>			StateInputNotExists(WfStateSwitchCase* node);
				static Ptr<parsing::ParsingError>			StateSwitchArgumentCountNotMatch(WfStateSwitchCase* node);
				static Ptr<parsing::ParsingError>			StateNotExists(WfStateInvokeStatement* node);
				static Ptr<parsing::ParsingError>			StateArgumentCountNotMatch(WfStateInvokeStatement* node);

				// D: Declaration error
				static Ptr<parsing::ParsingError>			FunctionShouldHaveName(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			FunctionShouldHaveImplementation(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			InterfaceMethodShouldNotHaveImplementation(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			DuplicatedDeclaration(WfDeclaration* node, const WString& firstDeclarationCategory);
				static Ptr<parsing::ParsingError>			DuplicatedDeclaration(WfStateMachineDeclaration* node);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfDeclaration* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfFunctionArgument* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfStatement* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfExpression* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfStateInput* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfStateDeclaration* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			DuplicatedSymbol(WfStateSwitchArgument* node, Ptr<WfLexicalSymbol> symbol);
				static Ptr<parsing::ParsingError>			InterfaceMethodNotImplemented(WfNewInterfaceExpression* node, reflection::description::IMethodInfo* method);
				static Ptr<parsing::ParsingError>			InterfaceMethodNotFound(WfFunctionDeclaration* node, reflection::description::ITypeInfo* interfaceType, reflection::description::ITypeInfo* methodType);
				static Ptr<parsing::ParsingError>			CannotPickOverloadedInterfaceMethods(WfExpression* node, collections::List<ResolveExpressionResult>& results);
				static Ptr<parsing::ParsingError>			CannotPickOverloadedImplementMethods(WfFunctionDeclaration* node, reflection::description::ITypeInfo* type);
				static Ptr<parsing::ParsingError>			WrongDeclaration(WfEventDeclaration* node);
				static Ptr<parsing::ParsingError>			WrongDeclaration(WfPropertyDeclaration* node);
				static Ptr<parsing::ParsingError>			WrongDeclaration(WfConstructorDeclaration* node);
				static Ptr<parsing::ParsingError>			WrongDeclaration(WfDestructorDeclaration* node);
				static Ptr<parsing::ParsingError>			WrongDeclaration(WfAutoPropertyDeclaration* node);
				static Ptr<parsing::ParsingError>			WrongDeclaration(WfStateMachineDeclaration* node);
				static Ptr<parsing::ParsingError>			WrongDeclarationInInterfaceConstructor(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			EnumValuesNotConsecutiveFromZero(WfEnumDeclaration* node);
				static Ptr<parsing::ParsingError>			FlagValuesNotConsecutiveFromZero(WfEnumDeclaration* node);
				static Ptr<parsing::ParsingError>			FlagValueNotExists(WfEnumItemIntersection* node, WfEnumDeclaration* owner);
				static Ptr<parsing::ParsingError>			DuplicatedEnumValue(WfEnumItem* node, WfEnumDeclaration* owner);
				static Ptr<parsing::ParsingError>			StructContainsNonValueType(WfStructMember* node, WfStructDeclaration* owner);
				static Ptr<parsing::ParsingError>			StructRecursivelyIncludeItself(WfStructDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static Ptr<parsing::ParsingError>			DuplicatedStructMember(WfStructMember* node, WfStructDeclaration* owner);
				static Ptr<parsing::ParsingError>			AttributeNotExists(WfAttribute* node);
				static Ptr<parsing::ParsingError>			AttributeMissValue(WfAttribute* node);
				static Ptr<parsing::ParsingError>			StateMachineClassNotInheritFromStateMachine(WfClassDeclaration* node);
				static Ptr<parsing::ParsingError>			MissingDefaultState(WfStateMachineDeclaration* node);

				// E: Module error
				static Ptr<parsing::ParsingError>			WrongUsingPathWildCard(WfModuleUsingPath* node);

				// F: Symbol Error
				static Ptr<parsing::ParsingError>			TopQualifiedSymbolNotExists(parsing::ParsingTreeCustomBase* node, const WString& name);
				static Ptr<parsing::ParsingError>			ChildSymbolNotExists(parsing::ParsingTreeCustomBase* node, Ptr<WfLexicalScopeName> scopeName, const WString& name);
				static Ptr<parsing::ParsingError>			MemberNotExists(parsing::ParsingTreeCustomBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name);
				static Ptr<parsing::ParsingError>			ReferenceNotExists(parsing::ParsingTreeCustomBase* node, const WString& name);
				static Ptr<parsing::ParsingError>			TooManyTargets(parsing::ParsingTreeCustomBase* node, collections::List<ResolveExpressionResult>& results, const WString& name);
				static Ptr<parsing::ParsingError>			EnumItemNotExists(parsing::ParsingTreeCustomBase* node, reflection::description::ITypeDescriptor* typeDescriptor, const WString& name);

				// G: Class error
				static Ptr<parsing::ParsingError>			WrongClassMemberConfig(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			FunctionInNewTypeExpressionCannotBeStatic(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			AutoPropertyCannotBeNormalOutsideOfClass(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			AutoPropertyCannotBeStatic(WfDeclaration* node);
				static Ptr<parsing::ParsingError>			WrongClassMember(WfNamespaceDeclaration* node);
				static Ptr<parsing::ParsingError>			PropertyGetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertySetterNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertyEventNotFound(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			TooManyPropertyGetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			TooManyPropertySetter(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			TooManyPropertyEvent(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertyGetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			PropertySetterTypeMismatched(WfPropertyDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			WrongBaseType(WfClassDeclaration* node, WfType* type);
				static Ptr<parsing::ParsingError>			WrongBaseTypeOfClass(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static Ptr<parsing::ParsingError>			WrongBaseTypeOfInterface(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static Ptr<parsing::ParsingError>			WrongInterfaceBaseType(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static Ptr<parsing::ParsingError>			ClassWithInterfaceConstructor(WfClassDeclaration* node);
				static Ptr<parsing::ParsingError>			OverrideShouldImplementInterfaceMethod(WfFunctionDeclaration* node);
				static Ptr<parsing::ParsingError>			OverrideShouldImplementInterfaceMethod(WfAutoPropertyDeclaration* node);
				static Ptr<parsing::ParsingError>			MissingFieldType(WfVariableDeclaration* node);
				static Ptr<parsing::ParsingError>			DuplicatedBaseClass(WfClassDeclaration* node, reflection::description::ITypeDescriptor* type);
				static Ptr<parsing::ParsingError>			ClassRecursiveInheritance(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static Ptr<parsing::ParsingError>			InterfaceRecursiveInheritance(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static Ptr<parsing::ParsingError>			WrongBaseConstructorCall(WfBaseConstructorCall* node, reflection::description::ITypeDescriptor* type);
				static Ptr<parsing::ParsingError>			DuplicatedBaseConstructorCall(WfBaseConstructorCall* node, reflection::description::ITypeDescriptor* type);
				static Ptr<parsing::ParsingError>			TooManyDestructor(WfDestructorDeclaration* node, WfClassDeclaration* classDecl);
				static Ptr<parsing::ParsingError>			AutoPropertyShouldBeInitialized(WfAutoPropertyDeclaration* node);
				static Ptr<parsing::ParsingError>			AutoPropertyCannotBeInitializedInInterface(WfAutoPropertyDeclaration* node, WfClassDeclaration* classDecl);

				// CPP: C++ code generation error
				static Ptr<parsing::ParsingError>			CppUnableToDecideClassOrder(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
				static Ptr<parsing::ParsingError>			CppUnableToSeparateCustomFile(WfClassDeclaration* node, collections::List<reflection::description::ITypeDescriptor*>& tds);
			};
		}
	}
}

#endif

/***********************************************************************
.\EMITTER\WFEMITTER.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::Analyzer

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_ANALYZER_WFEMITTER
#define VCZH_WORKFLOW_ANALYZER_WFEMITTER


namespace vl
{
	namespace workflow
	{
		namespace emitter
		{

/***********************************************************************
Attribute Evaluator
***********************************************************************/

			class WfAttributeEvaluator : public Object
			{
				typedef reflection::description::Value														Value;
				typedef collections::Dictionary<Ptr<WfAttribute>, Value>									AttributeValueMap;

			protected:
				analyzer::WfLexicalScopeManager*			manager;
				AttributeValueMap							attributeValues;				// cached value for attribute
				Ptr<runtime::WfAssembly>					attributeAssembly;				// shared assembly for evaluating attribute value
				Ptr<runtime::WfRuntimeGlobalContext>		attributeGlobalContext;			// shared shared context for evaluating attribute value

			public:
				WfAttributeEvaluator(analyzer::WfLexicalScopeManager* _manager);

				Ptr<WfAttribute>							GetAttribute(collections::List<Ptr<WfAttribute>>& atts, const WString& category, const WString& name);
				collections::LazyList<Ptr<WfAttribute>>		GetAttributes(collections::List<Ptr<WfAttribute>>& atts, const WString& category, const WString& name);
				Value										GetAttributeValue(Ptr<WfAttribute> att);
			};

/***********************************************************************
Code Generation
***********************************************************************/

			struct WfCodegenLambdaContext
			{
				WfFunctionDeclaration*				functionDeclaration = 0;
				WfFunctionExpression*				functionExpression = 0;
				WfOrderedLambdaExpression*			orderedLambdaExpression = 0;
			};

			enum class WfCodegenScopeType
			{
				Function,	// contains the whole function
				Loop,		// contains all loops
				TryCatch,	// contains try and catch, not finally
				Block,		// contains labeled blocks
			};

			class WfCodegenScopeContext : public Object
			{
				typedef collections::List<vint>										InstructionIndexList;
				typedef collections::List<runtime::WfInstruction>					InstructionList;
				typedef collections::List<parsing::ParsingTextRange>				RangeMap;
			public:
				WfCodegenScopeType					type = WfCodegenScopeType::Function;
				InstructionIndexList				continueInstructions;
				InstructionIndexList				breakInstructions;
				WString								name;
				
				InstructionList						exitInstructions;
				RangeMap							instructionCodeMappingBeforeCodegen;
				RangeMap							instructionCodeMappingAfterCodegen;
				Ptr<WfStatement>					exitStatement;
			};

			class WfCodegenFunctionContext : public Object
			{
				typedef collections::Dictionary<analyzer::WfLexicalSymbol*, vint>	VariableIndexMap;
				typedef collections::Dictionary<vint, WfCodegenLambdaContext>		ClosureIndexMap;
				typedef collections::List<Ptr<WfCodegenScopeContext>>				ScopeContextList;
			public:
				Ptr<runtime::WfAssemblyFunction>	function;
				VariableIndexMap					capturedVariables;
				VariableIndexMap					arguments;
				VariableIndexMap					localVariables;
				ClosureIndexMap						closuresToCodegen;
				ScopeContextList					scopeContextStack;

				WfCodegenFunctionContext();
				
				Ptr<WfCodegenScopeContext>			GetCurrentScopeContext();
				Ptr<WfCodegenScopeContext>			GetCurrentScopeContext(WfCodegenScopeType type, const WString& name = WString::Empty);
				Ptr<WfCodegenScopeContext>			PushScopeContext(WfCodegenScopeType type, const WString& name = WString::Empty);
				void								PopScopeContext();
			};

			class WfCodegenContext : public Object
			{
				typedef collections::Dictionary<analyzer::WfLexicalSymbol*, vint>								SymbolIndexMap;
				typedef collections::Dictionary<WfConstructorDeclaration*, vint>								ConstructorIndexMap;
				typedef collections::Dictionary<WfDestructorDeclaration*, vint>									DestructorIndexMap;
				typedef collections::Dictionary<parsing::ParsingTreeCustomBase*, parsing::ParsingTextRange>		NodePositionMap;
				typedef collections::Dictionary<Ptr<analyzer::WfLexicalFunctionConfig>, vint>					ThisStackCountMap;
			public:
				Ptr<runtime::WfAssembly>			assembly;
				analyzer::WfLexicalScopeManager*	manager;
				SymbolIndexMap						globalVariables;
				SymbolIndexMap						globalFunctions;
				ConstructorIndexMap					constructors;
				DestructorIndexMap					destructors;
				SymbolIndexMap						closureFunctions;
				Ptr<WfCodegenFunctionContext>		functionContext;
				NodePositionMap						nodePositionsBeforeCodegen;
				NodePositionMap						nodePositionsAfterCodegen;
				ThisStackCountMap					thisStackCounts;

				WfCodegenContext(Ptr<runtime::WfAssembly> _assembly, analyzer::WfLexicalScopeManager* _manager);

				vint								AddInstruction(parsing::ParsingTreeCustomBase* node, const runtime::WfInstruction& ins);
				void								AddExitInstruction(parsing::ParsingTreeCustomBase* node, const runtime::WfInstruction& ins);
				void								ApplyExitInstructions(Ptr<WfCodegenScopeContext> scopeContext);
				vint								GetThisStackCount(analyzer::WfLexicalScope* scope);
			};

			extern void										GenerateFunctionDeclarationMetadata(WfCodegenContext& context, WfFunctionDeclaration* node, Ptr<runtime::WfAssemblyFunction> meta);
			extern void										GenerateGlobalDeclarationMetadata(WfCodegenContext& context, Ptr<WfDeclaration> declaration, const WString& namePrefix = L"");
			extern void										GenerateClosureInstructions(WfCodegenContext& context, Ptr<WfCodegenFunctionContext> functionContext);
			extern void										GenerateInitializeInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration);
			extern void										GenerateDeclarationInstructions(WfCodegenContext& context, Ptr<WfDeclaration> declaration);
			extern void										GenerateStatementInstructions(WfCodegenContext& context, Ptr<WfStatement> statement);
			extern Ptr<reflection::description::ITypeInfo>	GenerateExpressionInstructions(WfCodegenContext& context, Ptr<WfExpression> expression, Ptr<reflection::description::ITypeInfo> expectedType = 0);
			extern void										GenerateTypeCastInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, bool strongCast, WfExpression* node);
			extern void										GenerateTypeTestingInstructions(WfCodegenContext& context, Ptr<reflection::description::ITypeInfo> expectedType, WfExpression* node);
			extern runtime::WfInsType						GetInstructionTypeArgument(Ptr<reflection::description::ITypeInfo> expectedType);

			/// <summary>Generate an assembly from a compiler. [M:vl.workflow.analyzer.WfLexicalScopeManager.Rebuild] should be called before using this function.</summary>
			/// <returns>The generated assembly.</returns>
			/// <param name="manager">The Workflow compiler.</param>
			/// <param name="callback">The callback to receive progress information, could be nullptr.</param>
			extern Ptr<runtime::WfAssembly>					GenerateAssembly(analyzer::WfLexicalScopeManager* manager, IWfCompilerCallback* callback = nullptr);

			/// <summary>Compile a Workflow program.</summary>
			/// <returns>The generated assembly.</returns>
			/// <param name="table">The workflow parser table. It can be retrived from [M:vl.workflow.WfLoadTable].</param>
			/// <param name="manager">The workflow compiler to reuse the cache of C++ reflectable types.</param>
			/// <param name="moduleCodes">All workflow module codes.</param>
			/// <param name="errors">Container to get all compileing errors.</param>
			extern Ptr<runtime::WfAssembly>					Compile(Ptr<parsing::tabling::ParsingTable> table, analyzer::WfLexicalScopeManager* manager, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors);
			
			/// <summary>Compile a Workflow program.</summary>
			/// <returns>The generated assembly.</returns>
			/// <param name="table">The workflow parser table. It can be retrived from [M:vl.workflow.WfLoadTable].</param>
			/// <param name="moduleCodes">All workflow module codes.</param>
			/// <param name="errors">Container to get all compileing errors.</param>
			extern Ptr<runtime::WfAssembly>					Compile(Ptr<parsing::tabling::ParsingTable> table, collections::List<WString>& moduleCodes, collections::List<Ptr<parsing::ParsingError>>& errors);
		}
	}
}

#endif

/***********************************************************************
.\CPP\WFCPP.H
***********************************************************************/
/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Workflow::C++ Code Generator

Interfaces:
**********************************************************************/

#ifndef VCZH_WORKFLOW_CPP_WFCPP
#define VCZH_WORKFLOW_CPP_WFCPP


namespace vl
{
	namespace workflow
	{
		namespace cppcodegen
		{
			/*
			Vczh Workflow Special Name:
				__vwsn_not_exists__		: Represents all not supported code
				__vwsn_temp_(#|_)		: Temporary variable
				__vwsn_CATEGORY			: <CATEGORY>
				__vwsn_CATEGORY_NAME	: <CATEGORY>NAME
				__vwsno#_ASSEMBLY_*		: Ordered lambda class name
				__vwsnf#_ASSEMBLY_*		: Function expression class name
				__vwsnc#_ASSEMBLY_*		: Anonymous interface class name
				__vwsnthis_#			: Captured this pointer in fields
				__vwsnctor_*			: Captured symbol in constructor arguments, assigned to "this->*"
				__vwsnctorthis_#		: Captured this pointer in constructor arguments assigned to "this->__vwsnthis_#"?
				__vwsnt_#				: Temporary type
				__vwsne_#				: Temporary variable (not for lambda)
				__vwsnb_#				: Temporary block
				__vwnsl_#_LABEL_NAME	: Goto label
				__vwsn_structs::NAME	: Struct definition
				__vwsn_enums::NAME		: Struct definition
			*/

			class WfCppConfig : public Object
			{
				using ITypeInfo = reflection::description::ITypeInfo;
				using IMethodInfo = reflection::description::IMethodInfo;
				using ITypeDescriptor = reflection::description::ITypeDescriptor;

			public:
				class ClosureInfo : public Object
				{
					using SymbolMap = collections::Dictionary<WString, Ptr<analyzer::WfLexicalSymbol>>;
				public:
					WString											lambdaClassName;
					SymbolMap										symbols;
					SymbolMap										ctorArgumentSymbols;
					collections::List<ITypeDescriptor*>				thisTypes;				// nearer this pointer first
				};

			public:
				regex::Regex										regexSplitName;
				regex::Regex										regexSpecialName;
				regex::Regex										regexTemplate;

			protected:
				Ptr<ClosureInfo>									CollectClosureInfo(Ptr<WfExpression> closure);
				void												Collect();

				struct GlobalDep
				{
					collections::Dictionary<WString, ITypeDescriptor*>		allTds;				// Type name to type descriptor of class decls. Class index is the position in this map.
					collections::Group<vint, vint>							expandedClassDecls;	// Class index (-1 means top level) to all direct and indirect internal classes
					collections::Group<vint, vint>							dependencies;		// Class dependencies
					collections::SortedList<vint>							topLevelClasses;	// Class index
					collections::Group<vint, vint>							topLevelClassDep;	// Class dependencies for top level classes
				};

				struct ClassLevelDep
				{
					Ptr<WfClassDeclaration>									parentClass;
					vint													parentIndexKey = -1;
					collections::Group<vint, vint>							depGroup;			// A slice of GlobalDep::dependencies
					collections::Dictionary<vint, vint>						subClass;			// Classes to their ancestor, which are direct internal classes of the selected parent class
				};

				void												ExpandClassDeclGroup(Ptr<WfClassDeclaration> parent, GlobalDep& globalDep);
				void												GenerateClassDependencies(GlobalDep& globalDep);
				void												GenerateGlobalDep(GlobalDep& globalDep);

				void												CollectExpandedDepGroup(vint parentIndexKey, GlobalDep& globalDep, ClassLevelDep& classLevelDep);
				void												CollectExpandedSubClass(vint subDeclIndexKey, GlobalDep& globalDep, ClassLevelDep& classLevelDep);
				void												GenerateClassLevelDep(Ptr<WfClassDeclaration> parent, GlobalDep& globalDep, ClassLevelDep& classLevelDep);

				void												SortClassDecls(GlobalDep& globalDep);
				void												GenerateFileClassMaps(GlobalDep& globalDep);
				void												SortFileClassMaps(GlobalDep& globalDep);
				void												AssignClassDeclsToFiles();

				template<typename T>
				void SortDeclsByName(collections::List<Ptr<T>>& decls)
				{
					collections::Sort<Ptr<T>>(&decls[0], decls.Count(), [=](Ptr<T> a, Ptr<T> b)
					{
						auto tdA = manager->declarationTypes[a.Obj()].Obj();
						auto tdB = manager->declarationTypes[b.Obj()].Obj();
						return WString::Compare(tdA->GetTypeName(), tdB->GetTypeName());
					});
				}

			public:
				analyzer::WfLexicalScopeManager*											manager;
				Ptr<emitter::WfAttributeEvaluator>											attributeEvaluator;
				WString																		assemblyNamespace;
				WString																		assemblyName;

				collections::Dictionary<ITypeDescriptor*, Ptr<WfDeclaration>>				tdDecls;			// type descriptor to declaration
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfEnumDeclaration>>			enumDecls;			// class (nullable) to direct internal enums
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfStructDeclaration>>		structDecls;		// class (nullable) to direct internal structs
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfClassDeclaration>>		classDecls;			// class (nullable) to direct internal classes
				collections::List<Ptr<WfVariableDeclaration>>								varDecls;			// global variables
				collections::List<Ptr<WfFunctionDeclaration>>								funcDecls;			// global functions

				collections::Group<WString, Ptr<WfClassDeclaration>>						customFilesClasses;	// @cpp:File to top level classes, empty key means the default cpp
				collections::Group<vint, Ptr<WfClassDeclaration>>							headerFilesClasses;	// non-@cpp:File header file to top level classes, 0 means the default header
				collections::Group<vint, vint>												headerIncludes;		// 0:default header, positive:@cpp:File indexed in customFilesClasses, negative:non-@cpp:File headers

				collections::Dictionary<Ptr<WfExpression>, WString>							lambdaExprs;
				collections::Dictionary<Ptr<WfNewInterfaceExpression>, WString>				classExprs;
				collections::Dictionary<Ptr<WfExpression>, Ptr<ClosureInfo>>				closureInfos;
				collections::Group<Ptr<WfClassDeclaration>, Ptr<WfExpression>>				classClosures;

				WfCppConfig(analyzer::WfLexicalScopeManager* _manager, const WString& _assemblyName, const WString& _assemblyNamespace);
				~WfCppConfig();

				void					WriteFunctionBody(stream::StreamWriter& writer, Ptr<WfExpression> expr, const WString& prefix, ITypeInfo* expectedType);
				void					WriteFunctionBody(stream::StreamWriter& writer, Ptr<WfStatement> stat, const WString& prefix, ITypeInfo* expectedType);

				WString					CppNameToHeaderEnumStructName(const WString& fullName, const WString& type);
				WString					ConvertNameInternal(const WString& name, const WString& specialNameCategory, bool alwaysUseCategory);
				WString					ConvertName(const WString& name);
				WString					ConvertName(const WString& name, const WString& specialNameCategory);
				WString					ConvertFullName(const WString& fullName, WString delimiter = L"::");
				WString					ConvertFunctionType(IMethodInfo* methodInfo, WString name = WString::Empty);
				WString					ConvertFunctionType(ITypeInfo* typeInfo);
				bool					IsSpecialGenericType(ITypeInfo* typeInfo);
				WString					ConvertType(ITypeDescriptor* typeInfo, WString delimiter = L"::");
				WString					ConvertType(ITypeInfo* typeInfo, bool useHeaderEnumStructName = false);
				WString					ConvertArgumentType(ITypeInfo* typeInfo);
				WString					DefaultValue(ITypeInfo* typeInfo);
				bool					IsClassHasUserImplMethods(Ptr<WfClassDeclaration> decl, bool searchInternalClasses);

				vint					CountClassNamespace(Ptr<WfClassDeclaration> decl);
				void					GetClassNamespace(Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);
				WString					GetClassBaseName(Ptr<WfClassDeclaration> decl);
				WString					WriteNamespace(stream::StreamWriter& writer, collections::List<WString>& nss, collections::List<WString>& nss2);
				WString					WriteNamespace(stream::StreamWriter& writer, const WString& fullName, collections::List<WString>& nss, WString& name);
				void					WriteNamespaceEnd(stream::StreamWriter& writer, collections::List<WString>& nss);

				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, ITypeInfo* typeInfo, collections::List<WString>& arguments, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfOrderedLambdaExpression> ordered, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfFunctionExpression> funcExpr, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, Ptr<WfFunctionDeclaration> decl, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, IMethodInfo* methodInfo, collections::List<WString>& arguments, const WString& name, bool writeReturnType);
				ITypeInfo*				WriteFunctionHeader(stream::StreamWriter& writer, IMethodInfo* methodInfo, const WString& name, bool writeReturnType);

				void					WriteHeader_Enum(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, const WString& name, const WString& prefix, bool mainHeaderDefinition);
				void					WriteHeader_EnumOp(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, const WString& name, const WString& prefix);
				void					WriteHeader_Enum(stream::StreamWriter& writer, Ptr<WfEnumDeclaration> decl, collections::List<WString>& nss, bool mainHeaderDefinition);
				void					WriteHeader_MainHeaderEnums(stream::StreamWriter& writer, collections::List<WString>& nss);

				void					WriteHeader_Struct(stream::StreamWriter& writer, Ptr<WfStructDeclaration> decl, const WString& name, const WString& prefix, bool mainHeaderDefinition);
				void					WriteHeader_StructOp(stream::StreamWriter& writer, Ptr<WfStructDeclaration> decl, const WString& name, const WString& prefix);
				void					WriteHeader_Struct(stream::StreamWriter& writer, Ptr<WfStructDeclaration> decl, collections::List<WString>& nss, bool mainHeaderDefinition);
				void					WriteHeader_MainHeaderStructs(stream::StreamWriter& writer, collections::List<WString>& nss);

				void					WriteHeader_ClosurePreDecl(stream::StreamWriter& writer, Ptr<WfExpression> closure);
				void					WriteHeader_LambdaExprDecl(stream::StreamWriter& writer, Ptr<WfExpression> lambda);
				void					WriteHeader_ClassExprDecl(stream::StreamWriter& writer, Ptr<WfNewInterfaceExpression> lambda);
				bool					WriteCpp_ClosureMembers(stream::StreamWriter& writer, Ptr<WfExpression> closure);
				void					WriteCpp_ClosureCtor(stream::StreamWriter& writer, Ptr<WfExpression> closure, const WString& name);
				void					WriteCpp_ClosureCtorInitList(stream::StreamWriter& writer, Ptr<WfExpression> closure);
				void					WriteCpp_LambdaExprImpl(stream::StreamWriter& writer, Ptr<WfExpression> lambda);
				void					WriteCpp_ClassExprImpl(stream::StreamWriter& writer, Ptr<WfNewInterfaceExpression> lambda);

				void					WriteHeader_ClassPreDecl(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, const WString& name, const WString& prefix);
				void					WriteHeader_ClassPreDecl(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);
				void					WriteHeader_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, const WString& name, const WString& prefix);
				WString					WriteHeader_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);
				bool					WriteCpp_ClassMember(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, Ptr<WfDeclaration> memberDecl, collections::List<WString>& nss);
				void					WriteCpp_Class(stream::StreamWriter& writer, Ptr<WfClassDeclaration> decl, collections::List<WString>& nss);

				void					SortClosure(collections::Dictionary<WString, Ptr<WfExpression>>& reversedLambdaExprs, collections::Dictionary<WString, Ptr<WfNewInterfaceExpression>>& reversedClassExprs);
				void					WriteHeader_Global(stream::StreamWriter& writer);
				void					WriteCpp_Global(stream::StreamWriter& writer);

				void					WriteHeader_Reflection(stream::StreamWriter& writer);
				void					WriteCpp_Reflection(stream::StreamWriter& writer);

				void					WritePushCompileOptions(stream::StreamWriter& writer);
				void					WritePopCompileOptions(stream::StreamWriter& writer);
				void					WriteCpp_PushMacros(stream::StreamWriter& writer);
				void					WriteCpp_PopMacros(stream::StreamWriter& writer);

				void					WriteHeader(stream::StreamWriter& writer, bool multiFile);
				void					WriteNonCustomSubHeader(stream::StreamWriter& writer, vint fileIndex);
				void					WriteCpp(stream::StreamWriter& writer, bool multiFile);
				void					WriteSubHeader(stream::StreamWriter& writer, const WString& fileName);
				void					WriteSubCpp(stream::StreamWriter& writer, const WString& fileName);
				void					WriteReflectionHeader(stream::StreamWriter& writer, bool multiFile);
				void					WriteReflectionCpp(stream::StreamWriter& writer, bool multiFile);
			};

/***********************************************************************
WfCppConfig::Collect
***********************************************************************/

			extern void CollectModule(WfCppConfig* config, Ptr<WfModule> module);

/***********************************************************************
WfCppConfig::Write
***********************************************************************/

			class FunctionRecord : public Object
			{
				using LabelMap = collections::Dictionary<WString, WString>;
			public:
				vint					exprCounter = 0;
				vint					blockCounter = 0;
				vint					labelCounter = 0;
				LabelMap				labelNames;
			};

			extern void					GenerateExpression(WfCppConfig* config, stream::StreamWriter& writer, Ptr<WfExpression> node, reflection::description::ITypeInfo* expectedType, bool useReturnValue = true);
			extern void					GenerateStatement(WfCppConfig* config, Ptr<FunctionRecord> functionRecord, stream::StreamWriter& writer, Ptr<WfStatement> node, const WString& prefix, const WString& prefixDelta, reflection::description::ITypeInfo* returnType);
			extern void					GenerateClassMemberDecl(WfCppConfig* config, stream::StreamWriter& writer, const WString& className, Ptr<WfDeclaration> memberDecl, const WString& prefix, bool forClassExpr);
			extern bool					GenerateClassMemberImpl(WfCppConfig* config, stream::StreamWriter& writer, WfClassDeclaration* classDef, const WString& classBaseName, const WString& className, const WString& classFullName, Ptr<WfDeclaration> memberDecl, const WString& prefix);

			extern void					ConvertType(WfCppConfig* config, stream::StreamWriter& writer, reflection::description::ITypeInfo* fromType, reflection::description::ITypeInfo* toType, const Func<void()>& writeExpression, bool strongCast);

/***********************************************************************
GenerateCppFiles
***********************************************************************/

			enum class WfCppFileSwitch
			{
				Enabled,
				Disabled,
				OnDemand,
			};

			class WfCppInput : public Object
			{
			public:
				WfCppFileSwitch									multiFile = WfCppFileSwitch::Enabled;
				WfCppFileSwitch									reflection = WfCppFileSwitch::Enabled;
				WString											comment;
				WString											headerGuardPrefix;
				WString											assemblyName;
				WString											assemblyNamespace;
				WString											includeFileName;
				WString											reflectionFileName;
				WString											defaultFileName;
				collections::List<WString>						normalIncludes;
				collections::List<WString>						reflectionIncludes;

				WfCppInput(const WString& _assemblyName);
			};

			class WfCppOutput : public Object
			{
			public:
				collections::Dictionary<WString, WString>		cppFiles;
				bool											containsReflectionInfo = false;
				bool											multiFile = false;
				bool											reflection = false;
				WString											entryFileName;
			};

			class MergeCppMultiPlatformException : public Exception
			{
			public:
				vint											row32;
				vint											column32;
				vint											row64;
				vint											column64;

				MergeCppMultiPlatformException(vint _row32, vint _column32, vint _row64, vint _column64);
			};

			extern Ptr<WfCppOutput>		GenerateCppFiles(Ptr<WfCppInput> input, analyzer::WfLexicalScopeManager* manager);
			extern WString				MergeCppMultiPlatform(const WString& code32, const WString& code64);
			extern WString				MergeCppFileContent(const WString& dst, const WString& src);
		}
	}
}

#endif
